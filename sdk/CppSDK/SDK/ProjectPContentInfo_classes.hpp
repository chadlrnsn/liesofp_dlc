#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ProjectPContentInfo

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "ProjectPContentInfo_structs.hpp"


namespace SDK
{

// Class ProjectPContentInfo.AbnormalStateCommonInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateCommonInfoFuncLibrary final : public UObject
{
public:
	static ELAbnormalBuffDebuffType GetAbstateBuffdebuffType(const struct FAbnormalStateCommonInfo& Info);
	static ELAbnormalAbstateClass GetAbstateClass(const struct FAbnormalStateCommonInfo& Info);
	static const TArray<struct FActionStateType> GetActionStateArray(const struct FAbnormalStateCommonInfo& Info);
	static ELAbnormalActivation GetActivationType(const struct FAbnormalStateCommonInfo& Info);
	static bool GetApplyBuildUpRecoverIncrease(const struct FAbnormalStateCommonInfo& Info);
	static bool GetApplyDurationPenalty(const struct FAbnormalStateCommonInfo& Info);
	static bool GetApplyTickPenalty(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetAttachActionCommand(const struct FAbnormalStateCommonInfo& Info);
	static bool GetAttachFxAllWeapon(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetAttachFxCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetAttachFxSocket(const struct FAbnormalStateCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetAttachMotion(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetAuraAbnormalCodeName(const struct FAbnormalStateCommonInfo& Info);
	static ELAuraNPCKindType GetAuraNpcKind(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetAuraRadius(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetBuildUpAttack(const struct FAbnormalStateCommonInfo& Info);
	static ELBuildupGuardType GetBuildUpAttackGuardType(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetBuildUpAttackModify(const struct FAbnormalStateCommonInfo& Info);
	static float GetBuildUpRecoverDelayOverride(const struct FAbnormalStateCommonInfo& Info);
	static float GetBuildUpRecoverOverride(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetContentconditionCodeName(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetDecreaseFrenzyPointPerSecond(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetDetachFxCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetDetachFxSocket(const struct FAbnormalStateCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetDetachMotion(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetDisableContentconditionCodeName(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetDuration(const struct FAbnormalStateCommonInfo& Info);
	static ELAbnormalCSCalcType GetDurationModifyCalType(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetDurationModifyMoment(const struct FAbnormalStateCommonInfo& Info);
	static ELStateEffectTargetType GetDurationModifyMomentTarget(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetDurationModifyValue(const struct FAbnormalStateCommonInfo& Info);
	static ELAbnormalEnchantType GetEnchantSdType(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetGroupCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetHumanizationBuffAlterCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetIconResource(const struct FAbnormalStateCommonInfo& Info);
	static bool GetIgnoreSensitiveRange(const struct FAbnormalStateCommonInfo& Info);
	static bool GetIsFableBuff(const struct FAbnormalStateCommonInfo& Info);
	static bool GetIsWeaponEnchant(const struct FAbnormalStateCommonInfo& Info);
	static bool GetKeepDead(const struct FAbnormalStateCommonInfo& Info);
	static bool GetKeepLogout(const struct FAbnormalStateCommonInfo& Info);
	static bool GetKeepRespawn(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetLoopFxCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetLoopFxSocket(const struct FAbnormalStateCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoopMotion(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetMaterialFxCodeName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetMomentconditionCodeName(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetMomentconditionCount(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetMomentconditionProbability(const struct FAbnormalStateCommonInfo& Info);
	static ELStateEffectTargetType GetMomentconditionTarget(const struct FAbnormalStateCommonInfo& Info);
	static class FString GetName(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetNameCn(const struct FAbnormalStateCommonInfo& Info);
	static class FText GetNameLocalize(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetPriority(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetPriorityGroupId(const struct FAbnormalStateCommonInfo& Info);
	static bool GetShowUi(const struct FAbnormalStateCommonInfo& Info);
	static ELAbnormalStackType GetStackType(const struct FAbnormalStateCommonInfo& Info);
	static int32 GetTick(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetTimeoutBuffCodeName(const struct FAbnormalStateCommonInfo& Info);
	static class FString GetTooltip(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetTooltipCn(const struct FAbnormalStateCommonInfo& Info);
	static class FText GetTooltipLocalize(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetVaryingFxCodeName(const struct FAbnormalStateCommonInfo& Info);
	static ELWeaponPartType GetWeaponAnimPartsType(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetWeaponAnimState(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetWeaponAnimStateExit(const struct FAbnormalStateCommonInfo& Info);
	static ELWeaponAttachPointType GetWeaponAttachPointType(const struct FAbnormalStateCommonInfo& Info);
	static ELElementDamageType GetWeaponElementOverride(const struct FAbnormalStateCommonInfo& Info);
	static const class FName GetWeaponMaterialFxCodeName(const struct FAbnormalStateCommonInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateCommonInfoFuncLibrary">();
	}
	static class UAbnormalStateCommonInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateCommonInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateCommonInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateCommonInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateCommonInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateCommonInfoFuncLibrary");

// Class ProjectPContentInfo.WorldZoneInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldZoneInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FWorldZoneInfoPtr& Ptr);
	static const class FName GetLightScenarioAm(const struct FWorldZoneInfoPtr& Ptr);
	static const class FName GetLightScenarioPm(const struct FWorldZoneInfoPtr& Ptr);
	static bool IsValid(const struct FWorldZoneInfoPtr& Ptr);
	static void IsValidBranch(const struct FWorldZoneInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldZoneInfoPtrFuncLibrary">();
	}
	static class UWorldZoneInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldZoneInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWorldZoneInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWorldZoneInfoPtrFuncLibrary");
static_assert(sizeof(UWorldZoneInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWorldZoneInfoPtrFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateCommonInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateCommonInfoPtrFuncLibrary final : public UObject
{
public:
	static ELAbnormalBuffDebuffType GetAbstateBuffdebuffType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELAbnormalAbstateClass GetAbstateClass(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const TArray<struct FActionStateType> GetActionStateArray(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELAbnormalActivation GetActivationType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetApplyBuildUpRecoverIncrease(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetApplyDurationPenalty(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetApplyTickPenalty(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetAttachActionCommand(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetAttachFxAllWeapon(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetAttachFxCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetAttachFxSocket(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetAttachMotion(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetAuraAbnormalCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELAuraNPCKindType GetAuraNpcKind(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetAuraRadius(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetBuildUpAttack(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELBuildupGuardType GetBuildUpAttackGuardType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetBuildUpAttackModify(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static float GetBuildUpRecoverDelayOverride(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static float GetBuildUpRecoverOverride(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetContentconditionCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetDecreaseFrenzyPointPerSecond(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetDetachFxCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetDetachFxSocket(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetDetachMotion(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetDisableContentconditionCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetDuration(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELAbnormalCSCalcType GetDurationModifyCalType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetDurationModifyMoment(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELStateEffectTargetType GetDurationModifyMomentTarget(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetDurationModifyValue(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELAbnormalEnchantType GetEnchantSdType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetGroupCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetHumanizationBuffAlterCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetIconResource(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetIgnoreSensitiveRange(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetIsFableBuff(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetIsWeaponEnchant(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetKeepDead(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetKeepLogout(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetKeepRespawn(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetLoopFxCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetLoopFxSocket(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoopMotion(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetMaterialFxCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetMomentconditionCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetMomentconditionCount(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetMomentconditionProbability(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELStateEffectTargetType GetMomentconditionTarget(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static class FString GetName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetNameCn(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static class FText GetNameLocalize(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetPriority(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetPriorityGroupId(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool GetShowUi(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELAbnormalStackType GetStackType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static int32 GetTick(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetTimeoutBuffCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static class FString GetTooltip(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetTooltipCn(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static class FText GetTooltipLocalize(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetVaryingFxCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELWeaponPartType GetWeaponAnimPartsType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetWeaponAnimState(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetWeaponAnimStateExit(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELWeaponAttachPointType GetWeaponAttachPointType(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static ELElementDamageType GetWeaponElementOverride(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static const class FName GetWeaponMaterialFxCodeName(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateCommonInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateCommonInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateCommonInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateCommonInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateCommonInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateCommonInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateCommonInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateCommonInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateCommonInfoPtrFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateChangeStatusInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateChangeStatusInfoFuncLibrary final : public UObject
{
public:
	static ELAbnormalCSCalcType GetCalculateType(const struct FAbnormalStateChangeStatusInfo& Info);
	static const class FName GetCodeName(const struct FAbnormalStateChangeStatusInfo& Info);
	static ELSecondStat GetMulAddBaseStatCodeName(const struct FAbnormalStateChangeStatusInfo& Info);
	static ELFirstStat GetTargetFirstStatCodeName(const struct FAbnormalStateChangeStatusInfo& Info);
	static ELSecondStat GetTargetStatCodeName(const struct FAbnormalStateChangeStatusInfo& Info);
	static int32 GetValue(const struct FAbnormalStateChangeStatusInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateChangeStatusInfoFuncLibrary">();
	}
	static class UAbnormalStateChangeStatusInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateChangeStatusInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateChangeStatusInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateChangeStatusInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateChangeStatusInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateChangeStatusInfoFuncLibrary");

// Class ProjectPContentInfo.ContentInfoAsset
// 0x0050 (0x0078 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x08) UContentInfoAsset : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentInfoAsset">();
	}
	static class UContentInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentInfoAsset>();
	}
};
#pragma pack(pop)
static_assert(alignof(UContentInfoAsset) == 0x000008, "Wrong alignment on UContentInfoAsset");
static_assert(sizeof(UContentInfoAsset) == 0x000078, "Wrong size on UContentInfoAsset");

// Class ProjectPContentInfo.SkillInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USkillInfoAsset final : public UContentInfoAsset
{
public:
	struct FSkillInfoDB                           ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSkillInfoPtr FindSkillInfoByNameBP(class FName CodeName);
	static const TArray<struct FSkillInfo> GetSkillInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillInfoAsset">();
	}
	static class USkillInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillInfoAsset>();
	}
};
static_assert(alignof(USkillInfoAsset) == 0x000010, "Wrong alignment on USkillInfoAsset");
static_assert(sizeof(USkillInfoAsset) == 0x000120, "Wrong size on USkillInfoAsset");
static_assert(offsetof(USkillInfoAsset, ContentInfoDB) == 0x000078, "Member 'USkillInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.AbnormalStateChangeStatusInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateChangeStatusInfoPtrFuncLibrary final : public UObject
{
public:
	static ELAbnormalCSCalcType GetCalculateType(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static ELSecondStat GetMulAddBaseStatCodeName(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static ELFirstStat GetTargetFirstStatCodeName(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static ELSecondStat GetTargetStatCodeName(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static int32 GetValue(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateChangeStatusInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateChangeStatusInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateChangeStatusInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateChangeStatusInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateChangeStatusInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateChangeStatusInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateChangeStatusInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateChangeStatusInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateChangeStatusInfoPtrFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateDamageHealInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateDamageHealInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAbnormalStateCodeName(const struct FAbnormalStateDamageHealInfo& Info);
	static bool GetApplyRateDotReduce(const struct FAbnormalStateDamageHealInfo& Info);
	static ELAbnormalDHCalcType GetCalculateType(const struct FAbnormalStateDamageHealInfo& Info);
	static const class FName GetCodeName(const struct FAbnormalStateDamageHealInfo& Info);
	static int32 GetNGPDetailIndex(const struct FAbnormalStateDamageHealInfo& Info);
	static ELSecondStat GetRateBaseStatCodeName(const struct FAbnormalStateDamageHealInfo& Info);
	static ELAbnormalDamageHealTargetType GetTargetType(const struct FAbnormalStateDamageHealInfo& Info);
	static int32 GetValue(const struct FAbnormalStateDamageHealInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateDamageHealInfoFuncLibrary">();
	}
	static class UAbnormalStateDamageHealInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateDamageHealInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateDamageHealInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateDamageHealInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateDamageHealInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateDamageHealInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateDamageHealInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateDamageHealInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAbnormalStateCodeName(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static bool GetApplyRateDotReduce(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static ELAbnormalDHCalcType GetCalculateType(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static ELSecondStat GetRateBaseStatCodeName(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static ELAbnormalDamageHealTargetType GetTargetType(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static int32 GetValue(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateDamageHealInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateDamageHealInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateDamageHealInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateDamageHealInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateDamageHealInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateDamageHealInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateDamageHealInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateDamageHealInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateDamageHealInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemPackageInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UItemPackageInfoAsset final : public UContentInfoAsset
{
public:
	struct FItemPackageInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FItemPackageInfoPtr FindItemPackageInfoByNameBP(class FName CodeName);
	static const TArray<struct FItemPackageInfo> GetItemPackageInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPackageInfoAsset">();
	}
	static class UItemPackageInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPackageInfoAsset>();
	}
};
static_assert(alignof(UItemPackageInfoAsset) == 0x000010, "Wrong alignment on UItemPackageInfoAsset");
static_assert(sizeof(UItemPackageInfoAsset) == 0x000120, "Wrong size on UItemPackageInfoAsset");
static_assert(offsetof(UItemPackageInfoAsset, ContentInfoDB) == 0x000078, "Member 'UItemPackageInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.AbnormalStateAttackInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateAttackInfoFuncLibrary final : public UObject
{
public:
	static ELAbnormalAttackType GetAttackType(const struct FAbnormalStateAttackInfo& Info);
	static ELAbnormalACalcType GetCalculateType(const struct FAbnormalStateAttackInfo& Info);
	static const class FName GetCodeName(const struct FAbnormalStateAttackInfo& Info);
	static ELSecondStat GetMulBaseStatCodeName(const struct FAbnormalStateAttackInfo& Info);
	static int32 GetNGPDetailIndex(const struct FAbnormalStateAttackInfo& Info);
	static int32 GetValue(const struct FAbnormalStateAttackInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateAttackInfoFuncLibrary">();
	}
	static class UAbnormalStateAttackInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateAttackInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateAttackInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateAttackInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateAttackInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateAttackInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateAttackInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateAttackInfoPtrFuncLibrary final : public UObject
{
public:
	static ELAbnormalAttackType GetAttackType(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static ELAbnormalACalcType GetCalculateType(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static ELSecondStat GetMulBaseStatCodeName(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static int32 GetValue(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateAttackInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateAttackInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateAttackInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateAttackInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateAttackInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateAttackInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateAttackInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateAttackInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateAttackInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ImageResourceInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UImageResourceInfoAsset final : public UContentInfoAsset
{
public:
	struct FImageResourceInfoDB                   ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FImageResourceInfoPtr FindImageResourceInfoByNameBP(class FName CodeName);
	static const TArray<struct FImageResourceInfo> GetImageResourceInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageResourceInfoAsset">();
	}
	static class UImageResourceInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageResourceInfoAsset>();
	}
};
static_assert(alignof(UImageResourceInfoAsset) == 0x000010, "Wrong alignment on UImageResourceInfoAsset");
static_assert(sizeof(UImageResourceInfoAsset) == 0x000120, "Wrong size on UImageResourceInfoAsset");
static_assert(offsetof(UImageResourceInfoAsset, ContentInfoDB) == 0x000078, "Member 'UImageResourceInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.AbnormalStateChainInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateChainInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAbnormalStateCodeName1(const struct FAbnormalStateChainInfo& Info);
	static const class FName GetAbnormalStateCodeName2(const struct FAbnormalStateChainInfo& Info);
	static const class FName GetAbnormalStateCodeNameResult(const struct FAbnormalStateChainInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateChainInfoFuncLibrary">();
	}
	static class UAbnormalStateChainInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateChainInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateChainInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateChainInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateChainInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateChainInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateChainInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateChainInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAbnormalStateCodeName1(const struct FAbnormalStateChainInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName2(const struct FAbnormalStateChainInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeNameResult(const struct FAbnormalStateChainInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateChainInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateChainInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateChainInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateChainInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateChainInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateChainInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateChainInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateChainInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateChainInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LoadingScreenInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULoadingScreenInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FLoadingScreenInfo& Info);
	static ELConditionLoadingType GetConditionLoadingType(const struct FLoadingScreenInfo& Info);
	static class FString GetConditionNextChapter(const struct FLoadingScreenInfo& Info);
	static const class FName GetConditionQuest(const struct FLoadingScreenInfo& Info);
	static const TArray<class FName> GetFirstDrawChainTip(const struct FLoadingScreenInfo& Info);
	static bool GetFirstDrawPriority(const struct FLoadingScreenInfo& Info);
	static const class FName GetImageCodeName(const struct FLoadingScreenInfo& Info);
	static bool GetResetConditionNewGamePlus(const struct FLoadingScreenInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenInfoFuncLibrary">();
	}
	static class ULoadingScreenInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenInfoFuncLibrary>();
	}
};
static_assert(alignof(ULoadingScreenInfoFuncLibrary) == 0x000008, "Wrong alignment on ULoadingScreenInfoFuncLibrary");
static_assert(sizeof(ULoadingScreenInfoFuncLibrary) == 0x000028, "Wrong size on ULoadingScreenInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateExecInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateExecInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FAbnormalStateExecInfo& Info);
	static ELAbnormalExecType GetExecType(const struct FAbnormalStateExecInfo& Info);
	static class FString GetParam1(const struct FAbnormalStateExecInfo& Info);
	static class FString GetParam2(const struct FAbnormalStateExecInfo& Info);
	static class FString GetParam3(const struct FAbnormalStateExecInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateExecInfoFuncLibrary">();
	}
	static class UAbnormalStateExecInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateExecInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateExecInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateExecInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateExecInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateExecInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateExecInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateExecInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FAbnormalStateExecInfoPtr& Ptr);
	static ELAbnormalExecType GetExecType(const struct FAbnormalStateExecInfoPtr& Ptr);
	static class FString GetParam1(const struct FAbnormalStateExecInfoPtr& Ptr);
	static class FString GetParam2(const struct FAbnormalStateExecInfoPtr& Ptr);
	static class FString GetParam3(const struct FAbnormalStateExecInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateExecInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateExecInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateExecInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateExecInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateExecInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateExecInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateExecInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateExecInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateExecInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemPackageInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemPackageInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FItemPackageInfo& Info);
	static bool GetIsExist(const struct FItemPackageInfo& Info);
	static const class FName GetItem1CodeName(const struct FItemPackageInfo& Info);
	static int32 GetItem1Count(const struct FItemPackageInfo& Info);
	static const class FName GetItem2CodeName(const struct FItemPackageInfo& Info);
	static int32 GetItem2Count(const struct FItemPackageInfo& Info);
	static const class FName GetItem3CodeName(const struct FItemPackageInfo& Info);
	static int32 GetItem3Count(const struct FItemPackageInfo& Info);
	static const class FName GetItem4CodeName(const struct FItemPackageInfo& Info);
	static int32 GetItem4Count(const struct FItemPackageInfo& Info);
	static const class FName GetItem5CodeName(const struct FItemPackageInfo& Info);
	static int32 GetItem5Count(const struct FItemPackageInfo& Info);
	static const class FName GetItem6CodeName(const struct FItemPackageInfo& Info);
	static int32 GetItem6Count(const struct FItemPackageInfo& Info);
	static const class FName GetNGPLink1(const struct FItemPackageInfo& Info);
	static const class FName GetNGPLink2(const struct FItemPackageInfo& Info);
	static const class FName GetNGPLink3(const struct FItemPackageInfo& Info);
	static const class FName GetNGPLink4(const struct FItemPackageInfo& Info);
	static int32 GetNGPRoundForLink1(const struct FItemPackageInfo& Info);
	static int32 GetNGPRoundForLink2(const struct FItemPackageInfo& Info);
	static int32 GetNGPRoundForLink3(const struct FItemPackageInfo& Info);
	static int32 GetNGPRoundForLink4(const struct FItemPackageInfo& Info);
	static const class FName GetSpotCodeName(const struct FItemPackageInfo& Info);
	static const class FName GetWeaponItem1Blade(const struct FItemPackageInfo& Info);
	static const class FName GetWeaponItem1Handle(const struct FItemPackageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPackageInfoFuncLibrary">();
	}
	static class UItemPackageInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPackageInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemPackageInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemPackageInfoFuncLibrary");
static_assert(sizeof(UItemPackageInfoFuncLibrary) == 0x000028, "Wrong size on UItemPackageInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateReplaceEffectInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateReplaceEffectInfoFuncLibrary final : public UObject
{
public:
	static int32 GetChkStackNum(const struct FAbnormalStateReplaceEffectInfo& Info);
	static const class FName GetCodeName(const struct FAbnormalStateReplaceEffectInfo& Info);
	static const class FName GetLoopFxCodeName(const struct FAbnormalStateReplaceEffectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoopMotion(const struct FAbnormalStateReplaceEffectInfo& Info);
	static class FString GetMaterialFxCodeName(const struct FAbnormalStateReplaceEffectInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateReplaceEffectInfoFuncLibrary">();
	}
	static class UAbnormalStateReplaceEffectInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateReplaceEffectInfoFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateReplaceEffectInfoFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateReplaceEffectInfoFuncLibrary");
static_assert(sizeof(UAbnormalStateReplaceEffectInfoFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateReplaceEffectInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateReplaceEffectInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalStateReplaceEffectInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetChkStackNum(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr);
	static const class FName GetLoopFxCodeName(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoopMotion(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr);
	static class FString GetMaterialFxCodeName(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr);
	static bool IsValid(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr);
	static void IsValidBranch(const struct FAbnormalStateReplaceEffectInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateReplaceEffectInfoPtrFuncLibrary">();
	}
	static class UAbnormalStateReplaceEffectInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateReplaceEffectInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAbnormalStateReplaceEffectInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAbnormalStateReplaceEffectInfoPtrFuncLibrary");
static_assert(sizeof(UAbnormalStateReplaceEffectInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAbnormalStateReplaceEffectInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ImageResourceInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UImageResourceInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FImageResourceInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FImageResourceInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageResourceInfoFuncLibrary">();
	}
	static class UImageResourceInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageResourceInfoFuncLibrary>();
	}
};
static_assert(alignof(UImageResourceInfoFuncLibrary) == 0x000008, "Wrong alignment on UImageResourceInfoFuncLibrary");
static_assert(sizeof(UImageResourceInfoFuncLibrary) == 0x000028, "Wrong size on UImageResourceInfoFuncLibrary");

// Class ProjectPContentInfo.AbnormalStateInfoAsset
// 0x0108 (0x0180 - 0x0078)
class alignas(0x10) UAbnormalStateInfoAsset final : public UContentInfoAsset
{
public:
	struct FAbnormalStateInfoDB                   ContentInfoDB;                                     // 0x0078(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FAbnormalStateCommonInfoPtr FindAbnormalStateCommonInfoByNameBP(class FName CodeName);
	static const TArray<struct FAbnormalStateAttackInfo> GetAbnormalStateAttackInfoArrayBP();
	static const TArray<struct FAbnormalStateChainInfo> GetAbnormalStateChainInfoArrayBP();
	static const TArray<struct FAbnormalStateChangeStatusInfo> GetAbnormalStateChangeStatusInfoArrayBP();
	static const TArray<struct FAbnormalStateCommonInfo> GetAbnormalStateCommonInfoArrayBP();
	static const TArray<struct FAbnormalStateDamageHealInfo> GetAbnormalStateDamageHealInfoArrayBP();
	static const TArray<struct FAbnormalStateExecInfo> GetAbnormalStateExecInfoArrayBP();
	static const TArray<struct FAbnormalStateReplaceEffectInfo> GetAbnormalStateReplaceEffectInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalStateInfoAsset">();
	}
	static class UAbnormalStateInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalStateInfoAsset>();
	}
};
static_assert(alignof(UAbnormalStateInfoAsset) == 0x000010, "Wrong alignment on UAbnormalStateInfoAsset");
static_assert(sizeof(UAbnormalStateInfoAsset) == 0x000180, "Wrong size on UAbnormalStateInfoAsset");
static_assert(offsetof(UAbnormalStateInfoAsset, ContentInfoDB) == 0x000078, "Member 'UAbnormalStateInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.GeneralConditionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralConditionInfoFuncLibrary final : public UObject
{
public:
	static ELConditionCompareType GetConditionType(const struct FGeneralConditionInfo& Info);
	static class FString GetParam1(const struct FGeneralConditionInfo& Info);
	static class FString GetParam2(const struct FGeneralConditionInfo& Info);
	static class FString GetParam3(const struct FGeneralConditionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralConditionInfoFuncLibrary">();
	}
	static class UGeneralConditionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralConditionInfoFuncLibrary>();
	}
};
static_assert(alignof(UGeneralConditionInfoFuncLibrary) == 0x000008, "Wrong alignment on UGeneralConditionInfoFuncLibrary");
static_assert(sizeof(UGeneralConditionInfoFuncLibrary) == 0x000028, "Wrong size on UGeneralConditionInfoFuncLibrary");

// Class ProjectPContentInfo.AchievementListInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAchievementListInfoFuncLibrary final : public UObject
{
public:
	static ELAchieveGradeType GetAchieveGrade(const struct FAchievementListInfo& Info);
	static int32 GetActivityIndex(const struct FAchievementListInfo& Info);
	static const class FName GetCodeName(const struct FAchievementListInfo& Info);
	static int32 GetDelayTime(const struct FAchievementListInfo& Info);
	static int32 GetGamerScore(const struct FAchievementListInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FAchievementListInfo& Info);
	static class FString GetLocalTextAchieveDetails(const struct FAchievementListInfo& Info);
	static const class FName GetLocalTextAchieveDetailsCn(const struct FAchievementListInfo& Info);
	static class FText GetLocalTextAchieveDetailsLocalize(const struct FAchievementListInfo& Info);
	static class FString GetLocalTextAchieveName(const struct FAchievementListInfo& Info);
	static const class FName GetLocalTextAchieveNameCn(const struct FAchievementListInfo& Info);
	static class FText GetLocalTextAchieveNameLocalize(const struct FAchievementListInfo& Info);
	static class FString GetPlatformKey(const struct FAchievementListInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementListInfoFuncLibrary">();
	}
	static class UAchievementListInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementListInfoFuncLibrary>();
	}
};
static_assert(alignof(UAchievementListInfoFuncLibrary) == 0x000008, "Wrong alignment on UAchievementListInfoFuncLibrary");
static_assert(sizeof(UAchievementListInfoFuncLibrary) == 0x000028, "Wrong size on UAchievementListInfoFuncLibrary");

// Class ProjectPContentInfo.AchievementListInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAchievementListInfoPtrFuncLibrary final : public UObject
{
public:
	static ELAchieveGradeType GetAchieveGrade(const struct FAchievementListInfoPtr& Ptr);
	static int32 GetActivityIndex(const struct FAchievementListInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAchievementListInfoPtr& Ptr);
	static int32 GetDelayTime(const struct FAchievementListInfoPtr& Ptr);
	static int32 GetGamerScore(const struct FAchievementListInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FAchievementListInfoPtr& Ptr);
	static class FString GetLocalTextAchieveDetails(const struct FAchievementListInfoPtr& Ptr);
	static const class FName GetLocalTextAchieveDetailsCn(const struct FAchievementListInfoPtr& Ptr);
	static class FText GetLocalTextAchieveDetailsLocalize(const struct FAchievementListInfoPtr& Ptr);
	static class FString GetLocalTextAchieveName(const struct FAchievementListInfoPtr& Ptr);
	static const class FName GetLocalTextAchieveNameCn(const struct FAchievementListInfoPtr& Ptr);
	static class FText GetLocalTextAchieveNameLocalize(const struct FAchievementListInfoPtr& Ptr);
	static class FString GetPlatformKey(const struct FAchievementListInfoPtr& Ptr);
	static bool IsValid(const struct FAchievementListInfoPtr& Ptr);
	static void IsValidBranch(const struct FAchievementListInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementListInfoPtrFuncLibrary">();
	}
	static class UAchievementListInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementListInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAchievementListInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAchievementListInfoPtrFuncLibrary");
static_assert(sizeof(UAchievementListInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAchievementListInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ImmuneInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UImmuneInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FImmuneInfoPtr& Ptr);
	static float GetCriticalChance(const struct FImmuneInfoPtr& Ptr);
	static int32 GetDamage(const struct FImmuneInfoPtr& Ptr);
	static int32 GetElementalDamage(const struct FImmuneInfoPtr& Ptr);
	static int32 GetGroggyAttack(const struct FImmuneInfoPtr& Ptr);
	static int32 GetHitActionDmgStand(const struct FImmuneInfoPtr& Ptr);
	static int32 GetHitActionDownAwayUp(const struct FImmuneInfoPtr& Ptr);
	static int32 GetHitActionDownDragStamp(const struct FImmuneInfoPtr& Ptr);
	static int32 GetHitActionGrab(const struct FImmuneInfoPtr& Ptr);
	static int32 GetHitActionKnockBack(const struct FImmuneInfoPtr& Ptr);
	static int32 GetIgnoreHit(const struct FImmuneInfoPtr& Ptr);
	static int32 GetSpecialElementalDamage(const struct FImmuneInfoPtr& Ptr);
	static int32 GetToughAttack(const struct FImmuneInfoPtr& Ptr);
	static int32 GetWeaponAttackPeriod(const struct FImmuneInfoPtr& Ptr);
	static bool IsValid(const struct FImmuneInfoPtr& Ptr);
	static void IsValidBranch(const struct FImmuneInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImmuneInfoPtrFuncLibrary">();
	}
	static class UImmuneInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmuneInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UImmuneInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UImmuneInfoPtrFuncLibrary");
static_assert(sizeof(UImmuneInfoPtrFuncLibrary) == 0x000028, "Wrong size on UImmuneInfoPtrFuncLibrary");

// Class ProjectPContentInfo.AchievementDetailInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAchievementDetailInfoFuncLibrary final : public UObject
{
public:
	static class FString GetCallbackEventParam(const struct FAchievementDetailInfo& Info);
	static class FString GetCallbackEventParam2(const struct FAchievementDetailInfo& Info);
	static ELCallBackEventType GetCallbackEventType(const struct FAchievementDetailInfo& Info);
	static const class FName GetCodeName(const struct FAchievementDetailInfo& Info);
	static int32 GetDetailIndex(const struct FAchievementDetailInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementDetailInfoFuncLibrary">();
	}
	static class UAchievementDetailInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementDetailInfoFuncLibrary>();
	}
};
static_assert(alignof(UAchievementDetailInfoFuncLibrary) == 0x000008, "Wrong alignment on UAchievementDetailInfoFuncLibrary");
static_assert(sizeof(UAchievementDetailInfoFuncLibrary) == 0x000028, "Wrong size on UAchievementDetailInfoFuncLibrary");

// Class ProjectPContentInfo.AchievementDetailInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAchievementDetailInfoPtrFuncLibrary final : public UObject
{
public:
	static class FString GetCallbackEventParam(const struct FAchievementDetailInfoPtr& Ptr);
	static class FString GetCallbackEventParam2(const struct FAchievementDetailInfoPtr& Ptr);
	static ELCallBackEventType GetCallbackEventType(const struct FAchievementDetailInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAchievementDetailInfoPtr& Ptr);
	static int32 GetDetailIndex(const struct FAchievementDetailInfoPtr& Ptr);
	static bool IsValid(const struct FAchievementDetailInfoPtr& Ptr);
	static void IsValidBranch(const struct FAchievementDetailInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementDetailInfoPtrFuncLibrary">();
	}
	static class UAchievementDetailInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementDetailInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAchievementDetailInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAchievementDetailInfoPtrFuncLibrary");
static_assert(sizeof(UAchievementDetailInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAchievementDetailInfoPtrFuncLibrary");

// Class ProjectPContentInfo.HumanizationBuffAlterInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHumanizationBuffAlterInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAlterAbnormalCodeName(const struct FHumanizationBuffAlterInfoPtr& Ptr);
	static const class FName GetAlterSpecialbuffCodeName(const struct FHumanizationBuffAlterInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FHumanizationBuffAlterInfoPtr& Ptr);
	static int32 GetHumanpointUnder(const struct FHumanizationBuffAlterInfoPtr& Ptr);
	static bool IsValid(const struct FHumanizationBuffAlterInfoPtr& Ptr);
	static void IsValidBranch(const struct FHumanizationBuffAlterInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanizationBuffAlterInfoPtrFuncLibrary">();
	}
	static class UHumanizationBuffAlterInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanizationBuffAlterInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UHumanizationBuffAlterInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UHumanizationBuffAlterInfoPtrFuncLibrary");
static_assert(sizeof(UHumanizationBuffAlterInfoPtrFuncLibrary) == 0x000028, "Wrong size on UHumanizationBuffAlterInfoPtrFuncLibrary");

// Class ProjectPContentInfo.AchievementInfoAsset
// 0x00B8 (0x0130 - 0x0078)
class alignas(0x10) UAchievementInfoAsset final : public UContentInfoAsset
{
public:
	struct FAchievementInfoDB                     ContentInfoDB;                                     // 0x0078(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FAchievementListInfoPtr FindAchievementListInfoByNameBP(class FName CodeName);
	static const TArray<struct FAchievementDetailInfo> GetAchievementDetailInfoArrayBP();
	static const TArray<struct FAchievementListInfo> GetAchievementListInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementInfoAsset">();
	}
	static class UAchievementInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementInfoAsset>();
	}
};
static_assert(alignof(UAchievementInfoAsset) == 0x000010, "Wrong alignment on UAchievementInfoAsset");
static_assert(sizeof(UAchievementInfoAsset) == 0x000130, "Wrong size on UAchievementInfoAsset");
static_assert(offsetof(UAchievementInfoAsset, ContentInfoDB) == 0x000078, "Member 'UAchievementInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ActionClassInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionClassInfoFuncLibrary final : public UObject
{
public:
	static const TSoftClassPtr<class UClass> GetActionClass(const struct FActionClassInfo& Info);
	static const class FName GetCodeName(const struct FActionClassInfo& Info);
	static bool GetDisableFatalAttack(const struct FActionClassInfo& Info);
	static bool GetImmediatelyCancelByDie(const struct FActionClassInfo& Info);
	static const class FName GetImmuneCodeName(const struct FActionClassInfo& Info);
	static bool GetPreload(const struct FActionClassInfo& Info);
	static ELActionCategory GetSystemCategory(const struct FActionClassInfo& Info);
	static bool GetUseHeadLookAt(const struct FActionClassInfo& Info);
	static bool GetUseUpperbodyLookAt(const struct FActionClassInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionClassInfoFuncLibrary">();
	}
	static class UActionClassInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionClassInfoFuncLibrary>();
	}
};
static_assert(alignof(UActionClassInfoFuncLibrary) == 0x000008, "Wrong alignment on UActionClassInfoFuncLibrary");
static_assert(sizeof(UActionClassInfoFuncLibrary) == 0x000028, "Wrong size on UActionClassInfoFuncLibrary");

// Class ProjectPContentInfo.FloatRangeValueFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFloatRangeValueFuncLibrary final : public UObject
{
public:
	static float GetMax(const struct FFloatRangeValue& Info);
	static float GetMin(const struct FFloatRangeValue& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatRangeValueFuncLibrary">();
	}
	static class UFloatRangeValueFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatRangeValueFuncLibrary>();
	}
};
static_assert(alignof(UFloatRangeValueFuncLibrary) == 0x000008, "Wrong alignment on UFloatRangeValueFuncLibrary");
static_assert(sizeof(UFloatRangeValueFuncLibrary) == 0x000028, "Wrong size on UFloatRangeValueFuncLibrary");

// Class ProjectPContentInfo.ActionClassInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionClassInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftClassPtr<class UClass> GetActionClass(const struct FActionClassInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FActionClassInfoPtr& Ptr);
	static bool GetDisableFatalAttack(const struct FActionClassInfoPtr& Ptr);
	static bool GetImmediatelyCancelByDie(const struct FActionClassInfoPtr& Ptr);
	static const class FName GetImmuneCodeName(const struct FActionClassInfoPtr& Ptr);
	static bool GetPreload(const struct FActionClassInfoPtr& Ptr);
	static ELActionCategory GetSystemCategory(const struct FActionClassInfoPtr& Ptr);
	static bool GetUseHeadLookAt(const struct FActionClassInfoPtr& Ptr);
	static bool GetUseUpperbodyLookAt(const struct FActionClassInfoPtr& Ptr);
	static bool IsValid(const struct FActionClassInfoPtr& Ptr);
	static void IsValidBranch(const struct FActionClassInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionClassInfoPtrFuncLibrary">();
	}
	static class UActionClassInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionClassInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UActionClassInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UActionClassInfoPtrFuncLibrary");
static_assert(sizeof(UActionClassInfoPtrFuncLibrary) == 0x000028, "Wrong size on UActionClassInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ActionClassInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UActionClassInfoAsset final : public UContentInfoAsset
{
public:
	struct FActionClassInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FActionClassInfoPtr FindActionClassInfoByNameBP(class FName CodeName);
	static const TArray<struct FActionClassInfo> GetActionClassInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionClassInfoAsset">();
	}
	static class UActionClassInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionClassInfoAsset>();
	}
};
static_assert(alignof(UActionClassInfoAsset) == 0x000010, "Wrong alignment on UActionClassInfoAsset");
static_assert(sizeof(UActionClassInfoAsset) == 0x000120, "Wrong size on UActionClassInfoAsset");
static_assert(offsetof(UActionClassInfoAsset, ContentInfoDB) == 0x000078, "Member 'UActionClassInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PackageSettingInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPackageSettingInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAcquisitionDelayMs(const struct FPackageSettingInfo& Info);
	static int32 GetAcquisitionPercentage(const struct FPackageSettingInfo& Info);
	static TArray<int32> GetDropOffset(const struct FPackageSettingInfo& Info);
	static class FString GetFirstKillPackageConfigureCodename(const struct FPackageSettingInfo& Info);
	static ELFirstKillRewardType GetFirstKillRewardType(const struct FPackageSettingInfo& Info);
	static bool GetForceAcquisition(const struct FPackageSettingInfo& Info);
	static EPackageOfferMethodType GetOfferMethod(const struct FPackageSettingInfo& Info);
	static EPackageOfferReasonType GetOfferReason(const struct FPackageSettingInfo& Info);
	static const class FName GetOwnerId(const struct FPackageSettingInfo& Info);
	static EPackageOwnerType GetOwnerType(const struct FPackageSettingInfo& Info);
	static const class FName GetPackageConfigureId(const struct FPackageSettingInfo& Info);
	static const class FName GetPropCodeName(const struct FPackageSettingInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageSettingInfoFuncLibrary">();
	}
	static class UPackageSettingInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackageSettingInfoFuncLibrary>();
	}
};
static_assert(alignof(UPackageSettingInfoFuncLibrary) == 0x000008, "Wrong alignment on UPackageSettingInfoFuncLibrary");
static_assert(sizeof(UPackageSettingInfoFuncLibrary) == 0x000028, "Wrong size on UPackageSettingInfoFuncLibrary");

// Class ProjectPContentInfo.ActionPathInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionPathInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FActionPathInfo& Info);
	static class FString GetPath(const struct FActionPathInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPathInfoFuncLibrary">();
	}
	static class UActionPathInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionPathInfoFuncLibrary>();
	}
};
static_assert(alignof(UActionPathInfoFuncLibrary) == 0x000008, "Wrong alignment on UActionPathInfoFuncLibrary");
static_assert(sizeof(UActionPathInfoFuncLibrary) == 0x000028, "Wrong size on UActionPathInfoFuncLibrary");

// Class ProjectPContentInfo.ActionPathInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionPathInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FActionPathInfoPtr& Ptr);
	static class FString GetPath(const struct FActionPathInfoPtr& Ptr);
	static bool IsValid(const struct FActionPathInfoPtr& Ptr);
	static void IsValidBranch(const struct FActionPathInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPathInfoPtrFuncLibrary">();
	}
	static class UActionPathInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionPathInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UActionPathInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UActionPathInfoPtrFuncLibrary");
static_assert(sizeof(UActionPathInfoPtrFuncLibrary) == 0x000028, "Wrong size on UActionPathInfoPtrFuncLibrary");

// Class ProjectPContentInfo.GeneralCommandInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralCommandInfoFuncLibrary final : public UObject
{
public:
	static ELContentCommandType GetCommandEnum(const struct FGeneralCommandInfo& Info);
	static class FString GetParam1(const struct FGeneralCommandInfo& Info);
	static class FString GetParam10(const struct FGeneralCommandInfo& Info);
	static class FString GetParam2(const struct FGeneralCommandInfo& Info);
	static class FString GetParam3(const struct FGeneralCommandInfo& Info);
	static class FString GetParam4(const struct FGeneralCommandInfo& Info);
	static class FString GetParam5(const struct FGeneralCommandInfo& Info);
	static class FString GetParam6(const struct FGeneralCommandInfo& Info);
	static class FString GetParam7(const struct FGeneralCommandInfo& Info);
	static class FString GetParam8(const struct FGeneralCommandInfo& Info);
	static class FString GetParam9(const struct FGeneralCommandInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralCommandInfoFuncLibrary">();
	}
	static class UGeneralCommandInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralCommandInfoFuncLibrary>();
	}
};
static_assert(alignof(UGeneralCommandInfoFuncLibrary) == 0x000008, "Wrong alignment on UGeneralCommandInfoFuncLibrary");
static_assert(sizeof(UGeneralCommandInfoFuncLibrary) == 0x000028, "Wrong size on UGeneralCommandInfoFuncLibrary");

// Class ProjectPContentInfo.ActionPathInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UActionPathInfoAsset final : public UContentInfoAsset
{
public:
	struct FActionPathInfoDB                      ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FActionPathInfoPtr FindActionPathInfoByNameBP(class FName CodeName);
	static const TArray<struct FActionPathInfo> GetActionPathInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPathInfoAsset">();
	}
	static class UActionPathInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionPathInfoAsset>();
	}
};
static_assert(alignof(UActionPathInfoAsset) == 0x000010, "Wrong alignment on UActionPathInfoAsset");
static_assert(sizeof(UActionPathInfoAsset) == 0x000120, "Wrong size on UActionPathInfoAsset");
static_assert(offsetof(UActionPathInfoAsset, ContentInfoDB) == 0x000078, "Member 'UActionPathInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ActionStateInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionStateInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FActionStateInfo& Info);
	static int32 GetDummy(const struct FActionStateInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateInfoFuncLibrary">();
	}
	static class UActionStateInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateInfoFuncLibrary>();
	}
};
static_assert(alignof(UActionStateInfoFuncLibrary) == 0x000008, "Wrong alignment on UActionStateInfoFuncLibrary");
static_assert(sizeof(UActionStateInfoFuncLibrary) == 0x000028, "Wrong size on UActionStateInfoFuncLibrary");

// Class ProjectPContentInfo.ActorParamInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActorParamInfoFuncLibrary final : public UObject
{
public:
	static int32 GetArmor(const struct FActorParamInfo& Info);
	static float GetAttackPower(const struct FActorParamInfo& Info);
	static float GetCriticalChance(const struct FActorParamInfo& Info);
	static float GetCriticalRating(const struct FActorParamInfo& Info);
	static int32 GetMaxHp(const struct FActorParamInfo& Info);
	static int32 GetMaxMp(const struct FActorParamInfo& Info);
	static float GetWeaponAttackPeriod(const struct FActorParamInfo& Info);
	static float GetWeaponDamage(const struct FActorParamInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorParamInfoFuncLibrary">();
	}
	static class UActorParamInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorParamInfoFuncLibrary>();
	}
};
static_assert(alignof(UActorParamInfoFuncLibrary) == 0x000008, "Wrong alignment on UActorParamInfoFuncLibrary");
static_assert(sizeof(UActorParamInfoFuncLibrary) == 0x000028, "Wrong size on UActorParamInfoFuncLibrary");

// Class ProjectPContentInfo.ActionStateInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionStateInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FActionStateInfoPtr& Ptr);
	static int32 GetDummy(const struct FActionStateInfoPtr& Ptr);
	static bool IsValid(const struct FActionStateInfoPtr& Ptr);
	static void IsValidBranch(const struct FActionStateInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateInfoPtrFuncLibrary">();
	}
	static class UActionStateInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UActionStateInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UActionStateInfoPtrFuncLibrary");
static_assert(sizeof(UActionStateInfoPtrFuncLibrary) == 0x000028, "Wrong size on UActionStateInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ActionStateInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UActionStateInfoAsset final : public UContentInfoAsset
{
public:
	struct FActionStateInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FActionStateInfoPtr FindActionStateInfoByNameBP(class FName CodeName);
	static const TArray<struct FActionStateInfo> GetActionStateInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateInfoAsset">();
	}
	static class UActionStateInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateInfoAsset>();
	}
};
static_assert(alignof(UActionStateInfoAsset) == 0x000010, "Wrong alignment on UActionStateInfoAsset");
static_assert(sizeof(UActionStateInfoAsset) == 0x000120, "Wrong size on UActionStateInfoAsset");
static_assert(offsetof(UActionStateInfoAsset, ContentInfoDB) == 0x000078, "Member 'UActionStateInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ActionStateTypeFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionStateTypeFuncLibrary final : public UObject
{
public:
	static const class FName GetValue(const struct FActionStateType& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateTypeFuncLibrary">();
	}
	static class UActionStateTypeFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateTypeFuncLibrary>();
	}
};
static_assert(alignof(UActionStateTypeFuncLibrary) == 0x000008, "Wrong alignment on UActionStateTypeFuncLibrary");
static_assert(sizeof(UActionStateTypeFuncLibrary) == 0x000028, "Wrong size on UActionStateTypeFuncLibrary");

// Class ProjectPContentInfo.Action_PathInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAction_PathInfoFuncLibrary final : public UObject
{
public:
	static const TSoftClassPtr<class UClass> GetActionClass(const struct FAction_PathInfo& Info);
	static const class FName GetCodeName(const struct FAction_PathInfo& Info);
	static ELActionCategory GetSystemCategory(const struct FAction_PathInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Action_PathInfoFuncLibrary">();
	}
	static class UAction_PathInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAction_PathInfoFuncLibrary>();
	}
};
static_assert(alignof(UAction_PathInfoFuncLibrary) == 0x000008, "Wrong alignment on UAction_PathInfoFuncLibrary");
static_assert(sizeof(UAction_PathInfoFuncLibrary) == 0x000028, "Wrong size on UAction_PathInfoFuncLibrary");

// Class ProjectPContentInfo.Action_PathInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAction_PathInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftClassPtr<class UClass> GetActionClass(const struct FAction_PathInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FAction_PathInfoPtr& Ptr);
	static ELActionCategory GetSystemCategory(const struct FAction_PathInfoPtr& Ptr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Action_PathInfoPtrFuncLibrary">();
	}
	static class UAction_PathInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAction_PathInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UAction_PathInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UAction_PathInfoPtrFuncLibrary");
static_assert(sizeof(UAction_PathInfoPtrFuncLibrary) == 0x000028, "Wrong size on UAction_PathInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemCostumeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemCostumeInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetAccessory(const struct FItemCostumeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetBasic(const struct FItemCostumeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemCostumeInfoPtr& Ptr);
	static bool GetHideAcc(const struct FItemCostumeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLong(const struct FItemCostumeInfoPtr& Ptr);
	static bool GetNeedShrink(const struct FItemCostumeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetWbasic(const struct FItemCostumeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetWlong(const struct FItemCostumeInfoPtr& Ptr);
	static bool IsValid(const struct FItemCostumeInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemCostumeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCostumeInfoPtrFuncLibrary">();
	}
	static class UItemCostumeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCostumeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemCostumeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemCostumeInfoPtrFuncLibrary");
static_assert(sizeof(UItemCostumeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemCostumeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.Action_PathInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UAction_PathInfoAsset final : public UContentInfoAsset
{
public:
	struct FAction_PathInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FAction_PathInfoPtr FindAction_PathInfoByNameBP(class FName CodeName);
	static const TArray<struct FAction_PathInfo> GetAction_PathInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Action_PathInfoAsset">();
	}
	static class UAction_PathInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAction_PathInfoAsset>();
	}
};
static_assert(alignof(UAction_PathInfoAsset) == 0x000010, "Wrong alignment on UAction_PathInfoAsset");
static_assert(sizeof(UAction_PathInfoAsset) == 0x000120, "Wrong size on UAction_PathInfoAsset");
static_assert(offsetof(UAction_PathInfoAsset, ContentInfoDB) == 0x000078, "Member 'UAction_PathInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ComboInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UComboInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetActionGroup(const struct FComboInfo& Info);
	static const class FName GetCmdChargeCancel(const struct FComboInfo& Info);
	static const class FName GetCmdDash(const struct FComboInfo& Info);
	static const class FName GetCmdGuard(const struct FComboInfo& Info);
	static const class FName GetCmdGuardEnd(const struct FComboInfo& Info);
	static const class FName GetCmdLightAttack(const struct FComboInfo& Info);
	static const class FName GetCmdOrbLevel1(const struct FComboInfo& Info);
	static const class FName GetCmdOrbLevel2(const struct FComboInfo& Info);
	static const class FName GetCmdOrbSkillCharging(const struct FComboInfo& Info);
	static const class FName GetCmdStrongAttack(const struct FComboInfo& Info);
	static const class FName GetCmdWeaponChange(const struct FComboInfo& Info);
	static const class FName GetCodeName(const struct FComboInfo& Info);
	static const class FName GetComboType(const struct FComboInfo& Info);
	static ELActionCategory GetCurrActionCategory(const struct FComboInfo& Info);
	static const class FName GetCurrSkill(const struct FComboInfo& Info);
	static const class FName GetFilter(const struct FComboInfo& Info);
	static ELWeaponPostureType GetPostureType(const struct FComboInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboInfoFuncLibrary">();
	}
	static class UComboInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboInfoFuncLibrary>();
	}
};
static_assert(alignof(UComboInfoFuncLibrary) == 0x000008, "Wrong alignment on UComboInfoFuncLibrary");
static_assert(sizeof(UComboInfoFuncLibrary) == 0x000028, "Wrong size on UComboInfoFuncLibrary");

// Class ProjectPContentInfo.PackageConfigureInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPackageConfigureInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetConditionCodename(const struct FPackageConfigureInfo& Info);
	static const class FName GetDropSetCodeName(const struct FPackageConfigureInfo& Info);
	static ELDropType GetDropType(const struct FPackageConfigureInfo& Info);
	static const class FName GetIndex(const struct FPackageConfigureInfo& Info);
	static int32 GetIndexDetail(const struct FPackageConfigureInfo& Info);
	static int32 GetItemAcquisitionPercentage(const struct FPackageConfigureInfo& Info);
	static const class FName GetItemCodeName(const struct FPackageConfigureInfo& Info);
	static int32 GetItemCount(const struct FPackageConfigureInfo& Info);
	static int32 GetNGPRound(const struct FPackageConfigureInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageConfigureInfoFuncLibrary">();
	}
	static class UPackageConfigureInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackageConfigureInfoFuncLibrary>();
	}
};
static_assert(alignof(UPackageConfigureInfoFuncLibrary) == 0x000008, "Wrong alignment on UPackageConfigureInfoFuncLibrary");
static_assert(sizeof(UPackageConfigureInfoFuncLibrary) == 0x000028, "Wrong size on UPackageConfigureInfoFuncLibrary");

// Class ProjectPContentInfo.ComboInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UComboInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetActionGroup(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdChargeCancel(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdDash(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdGuard(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdGuardEnd(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdLightAttack(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdOrbLevel1(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdOrbLevel2(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdOrbSkillCharging(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdStrongAttack(const struct FComboInfoPtr& Ptr);
	static const class FName GetCmdWeaponChange(const struct FComboInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FComboInfoPtr& Ptr);
	static const class FName GetComboType(const struct FComboInfoPtr& Ptr);
	static ELActionCategory GetCurrActionCategory(const struct FComboInfoPtr& Ptr);
	static const class FName GetCurrSkill(const struct FComboInfoPtr& Ptr);
	static const class FName GetFilter(const struct FComboInfoPtr& Ptr);
	static ELWeaponPostureType GetPostureType(const struct FComboInfoPtr& Ptr);
	static bool IsValid(const struct FComboInfoPtr& Ptr);
	static void IsValidBranch(const struct FComboInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboInfoPtrFuncLibrary">();
	}
	static class UComboInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UComboInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UComboInfoPtrFuncLibrary");
static_assert(sizeof(UComboInfoPtrFuncLibrary) == 0x000028, "Wrong size on UComboInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ComboInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UComboInfoAsset final : public UContentInfoAsset
{
public:
	struct FComboInfoDB                           ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FComboInfoPtr FindComboInfoByNameBP(class FName CodeName);
	static const TArray<struct FComboInfo> GetComboInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboInfoAsset">();
	}
	static class UComboInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboInfoAsset>();
	}
};
static_assert(alignof(UComboInfoAsset) == 0x000010, "Wrong alignment on UComboInfoAsset");
static_assert(sizeof(UComboInfoAsset) == 0x000120, "Wrong size on UComboInfoAsset");
static_assert(offsetof(UComboInfoAsset, ContentInfoDB) == 0x000078, "Member 'UComboInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.GeneralCallBackEventInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralCallBackEventInfoFuncLibrary final : public UObject
{
public:
	static class FString GetCallbackEventParam1(const struct FGeneralCallBackEventInfo& Info);
	static class FString GetCallbackEventParam2(const struct FGeneralCallBackEventInfo& Info);
	static ELCallBackEventType GetCallbackEventType(const struct FGeneralCallBackEventInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralCallBackEventInfoFuncLibrary">();
	}
	static class UGeneralCallBackEventInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralCallBackEventInfoFuncLibrary>();
	}
};
static_assert(alignof(UGeneralCallBackEventInfoFuncLibrary) == 0x000008, "Wrong alignment on UGeneralCallBackEventInfoFuncLibrary");
static_assert(sizeof(UGeneralCallBackEventInfoFuncLibrary) == 0x000028, "Wrong size on UGeneralCallBackEventInfoFuncLibrary");

// Class ProjectPContentInfo.ComboTypeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UComboTypeInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FComboTypeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboTypeInfoFuncLibrary">();
	}
	static class UComboTypeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboTypeInfoFuncLibrary>();
	}
};
static_assert(alignof(UComboTypeInfoFuncLibrary) == 0x000008, "Wrong alignment on UComboTypeInfoFuncLibrary");
static_assert(sizeof(UComboTypeInfoFuncLibrary) == 0x000028, "Wrong size on UComboTypeInfoFuncLibrary");

// Class ProjectPContentInfo.ComboTypeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UComboTypeInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FComboTypeInfoPtr& Ptr);
	static bool IsValid(const struct FComboTypeInfoPtr& Ptr);
	static void IsValidBranch(const struct FComboTypeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboTypeInfoPtrFuncLibrary">();
	}
	static class UComboTypeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboTypeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UComboTypeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UComboTypeInfoPtrFuncLibrary");
static_assert(sizeof(UComboTypeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UComboTypeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ComboTypeInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UComboTypeInfoAsset final : public UContentInfoAsset
{
public:
	struct FComboTypeInfoDB                       ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FComboTypeInfoPtr FindComboTypeInfoByNameBP(class FName CodeName);
	static const TArray<struct FComboTypeInfo> GetComboTypeInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboTypeInfoAsset">();
	}
	static class UComboTypeInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboTypeInfoAsset>();
	}
};
static_assert(alignof(UComboTypeInfoAsset) == 0x000010, "Wrong alignment on UComboTypeInfoAsset");
static_assert(sizeof(UComboTypeInfoAsset) == 0x000120, "Wrong size on UComboTypeInfoAsset");
static_assert(offsetof(UComboTypeInfoAsset, ContentInfoDB) == 0x000078, "Member 'UComboTypeInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.CustomInputInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCustomInputInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetInputCmd(const struct FCustomInputInfo& Info);
	static int32 GetInputCmdTime(const struct FCustomInputInfo& Info);
	static ELInputType GetInputType(const struct FCustomInputInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomInputInfoFuncLibrary">();
	}
	static class UCustomInputInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomInputInfoFuncLibrary>();
	}
};
static_assert(alignof(UCustomInputInfoFuncLibrary) == 0x000008, "Wrong alignment on UCustomInputInfoFuncLibrary");
static_assert(sizeof(UCustomInputInfoFuncLibrary) == 0x000028, "Wrong size on UCustomInputInfoFuncLibrary");

// Class ProjectPContentInfo.ItemConsumeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemConsumeInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetBuffCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetCancelAbnormalCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static int32 GetCancelAbnormalDebuildupValue(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetCancelAbnormalGroupName(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static ELItemComplexGroup GetComplexGroup(const struct FItemConsumeInfoPtr& Ptr);
	static ELItemComplexType GetComplexType(const struct FItemConsumeInfoPtr& Ptr);
	static int32 GetDefaultMaxCharge(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetForceUse(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetForceUseDesc(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetFxCommonCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static class FString GetFxSocket(const struct FItemConsumeInfoPtr& Ptr);
	static int32 GetIncreaseWealthAmount(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetIsLocationFx(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetIsToggle(const struct FItemConsumeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetItemMesh(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetItemMeshSocket(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetKeepToggleDead(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetKeepToggleRespawn(const struct FItemConsumeInfoPtr& Ptr);
	static int32 GetMaxChargeLimit(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetProjectileCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetPulseRechargedAbnormalCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetRecallToTorsionCoil(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetRechargeable(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetRequireHelpmateCombat(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetRequireWeapon(const struct FItemConsumeInfoPtr& Ptr);
	static const TArray<struct FActionStateType> GetRestrictActionStateArray(const struct FItemConsumeInfoPtr& Ptr);
	static int32 GetSharpnessRecoveryPoint(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetSlavearmAlterItemMatch(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetStackUse(const struct FItemConsumeInfoPtr& Ptr);
	static ELItemConsumeTargetType GetTargetType(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetUnconsumable(const struct FItemConsumeInfoPtr& Ptr);
	static ELItemUnitUseType GetUnitUseType(const struct FItemConsumeInfoPtr& Ptr);
	static bool GetUseItemInventoryState(const struct FItemConsumeInfoPtr& Ptr);
	static const class FName GetUseSkillCodeName(const struct FItemConsumeInfoPtr& Ptr);
	static bool IsValid(const struct FItemConsumeInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemConsumeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemConsumeInfoPtrFuncLibrary">();
	}
	static class UItemConsumeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemConsumeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemConsumeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemConsumeInfoPtrFuncLibrary");
static_assert(sizeof(UItemConsumeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemConsumeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.CustomInputInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCustomInputInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetInputCmd(const struct FCustomInputInfoPtr& Ptr);
	static int32 GetInputCmdTime(const struct FCustomInputInfoPtr& Ptr);
	static ELInputType GetInputType(const struct FCustomInputInfoPtr& Ptr);
	static bool IsValid(const struct FCustomInputInfoPtr& Ptr);
	static void IsValidBranch(const struct FCustomInputInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomInputInfoPtrFuncLibrary">();
	}
	static class UCustomInputInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomInputInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UCustomInputInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UCustomInputInfoPtrFuncLibrary");
static_assert(sizeof(UCustomInputInfoPtrFuncLibrary) == 0x000028, "Wrong size on UCustomInputInfoPtrFuncLibrary");

// Class ProjectPContentInfo.CommandInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommandInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCommandInfo& Info);
	static const struct FCustomInputInfo GetCustomInputInfo(const struct FCommandInfo& Info);
	static const class FName GetPress(const struct FCommandInfo& Info);
	static const class FName GetPrimaryInput(const struct FCommandInfo& Info);
	static const class FName GetRelease(const struct FCommandInfo& Info);
	static const class FName GetSecondaryInput(const struct FCommandInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandInfoFuncLibrary">();
	}
	static class UCommandInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandInfoFuncLibrary>();
	}
};
static_assert(alignof(UCommandInfoFuncLibrary) == 0x000008, "Wrong alignment on UCommandInfoFuncLibrary");
static_assert(sizeof(UCommandInfoFuncLibrary) == 0x000028, "Wrong size on UCommandInfoFuncLibrary");

// Class ProjectPContentInfo.CommandInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommandInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCommandInfoPtr& Ptr);
	static const struct FCustomInputInfo GetCustomInputInfo(const struct FCommandInfoPtr& Ptr);
	static const class FName GetPress(const struct FCommandInfoPtr& Ptr);
	static const class FName GetPrimaryInput(const struct FCommandInfoPtr& Ptr);
	static const class FName GetRelease(const struct FCommandInfoPtr& Ptr);
	static const class FName GetSecondaryInput(const struct FCommandInfoPtr& Ptr);
	static bool IsValid(const struct FCommandInfoPtr& Ptr);
	static void IsValidBranch(const struct FCommandInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandInfoPtrFuncLibrary">();
	}
	static class UCommandInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UCommandInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UCommandInfoPtrFuncLibrary");
static_assert(sizeof(UCommandInfoPtrFuncLibrary) == 0x000028, "Wrong size on UCommandInfoPtrFuncLibrary");

// Class ProjectPContentInfo.CommandInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UCommandInfoAsset final : public UContentInfoAsset
{
public:
	struct FCommandInfoDB                         ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FCommandInfoPtr FindCommandInfoByNameBP(class FName CodeName);
	static const TArray<struct FCommandInfo> GetCommandInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandInfoAsset">();
	}
	static class UCommandInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandInfoAsset>();
	}
};
static_assert(alignof(UCommandInfoAsset) == 0x000010, "Wrong alignment on UCommandInfoAsset");
static_assert(sizeof(UCommandInfoAsset) == 0x000120, "Wrong size on UCommandInfoAsset");
static_assert(offsetof(UCommandInfoAsset, ContentInfoDB) == 0x000078, "Member 'UCommandInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.CommonActionMontageInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommonActionMontageInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCommonActionMontageInfo& Info);
	static ELCommonActionType GetCommonActionType(const struct FCommonActionMontageInfo& Info);
	static const class FName GetEndCommonAction(const struct FCommonActionMontageInfo& Info);
	static const class FName GetMontage(const struct FCommonActionMontageInfo& Info);
	static float GetOverrideMontageBlendIn(const struct FCommonActionMontageInfo& Info);
	static const class FName GetPhysicalTargetBone(const struct FCommonActionMontageInfo& Info);
	static const class FName GetReplaceMontage(const struct FCommonActionMontageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonActionMontageInfoFuncLibrary">();
	}
	static class UCommonActionMontageInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonActionMontageInfoFuncLibrary>();
	}
};
static_assert(alignof(UCommonActionMontageInfoFuncLibrary) == 0x000008, "Wrong alignment on UCommonActionMontageInfoFuncLibrary");
static_assert(sizeof(UCommonActionMontageInfoFuncLibrary) == 0x000028, "Wrong size on UCommonActionMontageInfoFuncLibrary");

// Class ProjectPContentInfo.CommonActionMontageInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommonActionMontageInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCommonActionMontageInfoPtr& Ptr);
	static ELCommonActionType GetCommonActionType(const struct FCommonActionMontageInfoPtr& Ptr);
	static const class FName GetEndCommonAction(const struct FCommonActionMontageInfoPtr& Ptr);
	static const class FName GetMontage(const struct FCommonActionMontageInfoPtr& Ptr);
	static float GetOverrideMontageBlendIn(const struct FCommonActionMontageInfoPtr& Ptr);
	static const class FName GetPhysicalTargetBone(const struct FCommonActionMontageInfoPtr& Ptr);
	static const class FName GetReplaceMontage(const struct FCommonActionMontageInfoPtr& Ptr);
	static bool IsValid(const struct FCommonActionMontageInfoPtr& Ptr);
	static void IsValidBranch(const struct FCommonActionMontageInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonActionMontageInfoPtrFuncLibrary">();
	}
	static class UCommonActionMontageInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonActionMontageInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UCommonActionMontageInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UCommonActionMontageInfoPtrFuncLibrary");
static_assert(sizeof(UCommonActionMontageInfoPtrFuncLibrary) == 0x000028, "Wrong size on UCommonActionMontageInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemCollectionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemCollectionInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAcquisitionHumanityPlayTime(const struct FItemCollectionInfoPtr& Ptr);
	static int32 GetAcquisitionHumanityPoint(const struct FItemCollectionInfoPtr& Ptr);
	static float GetBgmDuration(const struct FItemCollectionInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetBgmResource(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemCollectionInfoPtr& Ptr);
	static int32 GetCommandExecTime(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetContentCommandCodename(const struct FItemCollectionInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent1(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent10(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent10Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent10Localize(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent1Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent1Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent2(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent2Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent2Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent3(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent3Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent3Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent4(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent4Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent4Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent5(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent5Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent5Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent6(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent6Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent6Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent7(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent7Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent7Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent8(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent8Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent8Localize(const struct FItemCollectionInfoPtr& Ptr);
	static class FString GetLocalTextContent9(const struct FItemCollectionInfoPtr& Ptr);
	static const class FName GetLocalTextContent9Cn(const struct FItemCollectionInfoPtr& Ptr);
	static class FText GetLocalTextContent9Localize(const struct FItemCollectionInfoPtr& Ptr);
	static int32 GetPageMax(const struct FItemCollectionInfoPtr& Ptr);
	static int32 GetRecordListOrder(const struct FItemCollectionInfoPtr& Ptr);
	static ELItemCollectionType GetType(const struct FItemCollectionInfoPtr& Ptr);
	static bool IsValid(const struct FItemCollectionInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemCollectionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCollectionInfoPtrFuncLibrary">();
	}
	static class UItemCollectionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCollectionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemCollectionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemCollectionInfoPtrFuncLibrary");
static_assert(sizeof(UItemCollectionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemCollectionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.CommonActionMontageInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UCommonActionMontageInfoAsset final : public UContentInfoAsset
{
public:
	struct FCommonActionMontageInfoDB             ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FCommonActionMontageInfoPtr FindCommonActionMontageInfoByNameBP(class FName CodeName);
	static const TArray<struct FCommonActionMontageInfo> GetCommonActionMontageInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonActionMontageInfoAsset">();
	}
	static class UCommonActionMontageInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonActionMontageInfoAsset>();
	}
};
static_assert(alignof(UCommonActionMontageInfoAsset) == 0x000010, "Wrong alignment on UCommonActionMontageInfoAsset");
static_assert(sizeof(UCommonActionMontageInfoAsset) == 0x000120, "Wrong size on UCommonActionMontageInfoAsset");
static_assert(offsetof(UCommonActionMontageInfoAsset, ContentInfoDB) == 0x000078, "Member 'UCommonActionMontageInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.CommonConstantInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommonConstantInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCommonConstantInfo& Info);
	static class FString GetValue(const struct FCommonConstantInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonConstantInfoFuncLibrary">();
	}
	static class UCommonConstantInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonConstantInfoFuncLibrary>();
	}
};
static_assert(alignof(UCommonConstantInfoFuncLibrary) == 0x000008, "Wrong alignment on UCommonConstantInfoFuncLibrary");
static_assert(sizeof(UCommonConstantInfoFuncLibrary) == 0x000028, "Wrong size on UCommonConstantInfoFuncLibrary");

// Class ProjectPContentInfo.ItemHandleInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemHandleInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetActionGroupTableCodeName(const struct FItemHandleInfoPtr& Ptr);
	static const TArray<ELBladeShapeType> GetAllowBladeShapeType(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetAttackSpeed(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetBladeWeightCodeName(const struct FItemHandleInfoPtr& Ptr);
	static float GetChargePlayRateMax(const struct FItemHandleInfoPtr& Ptr);
	static float GetChargePlayRateMin(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetComboType(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetCommonActionPathCodeName(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForAdvance(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForMotivity(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForTechnique(const struct FItemHandleInfoPtr& Ptr);
	static float GetDelayPlayRateMax(const struct FItemHandleInfoPtr& Ptr);
	static float GetDelayPlayRateMin(const struct FItemHandleInfoPtr& Ptr);
	static float GetDestructionDefence(const struct FItemHandleInfoPtr& Ptr);
	static float GetDestructionReduce(const struct FItemHandleInfoPtr& Ptr);
	static float GetEndPlayRateMax(const struct FItemHandleInfoPtr& Ptr);
	static float GetEndPlayRateMin(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetFrenzySkillCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardDurationRatio(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardGainFrenzyPointActive(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardGainFrenzyPointPassive(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardIntensity(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetGuardParryCounterSkillCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardPoint(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardRegainRatio(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetGuardStaminaReductionRatio(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetHandleNeedStatLackAbnormalStateCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetHandleNeedStatLackAtkRatio(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetHandleNeedStatLackGuardSaveStaminaRatio(const struct FItemHandleInfoPtr& Ptr);
	static bool GetHaveSwingMotion(const struct FItemHandleInfoPtr& Ptr);
	static bool GetHaveThrustMotion(const struct FItemHandleInfoPtr& Ptr);
	static bool GetHeroicWeapon(const struct FItemHandleInfoPtr& Ptr);
	static float GetIntroPlayRateMax(const struct FItemHandleInfoPtr& Ptr);
	static float GetIntroPlayRateMin(const struct FItemHandleInfoPtr& Ptr);
	static class FString GetLocalTextByname(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetLocalTextBynameCn(const struct FItemHandleInfoPtr& Ptr);
	static class FText GetLocalTextBynameLocalize(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetLocomotionActionPathCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetNecessityAdvance(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetNecessityMotivity(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetNecessityTechnique(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetOriginalBladeCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetPerfectGuardDecreaseEnemyWeaponDurability(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetPerfectGuardGainFrenzyPointActive(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetPerfectGuardGainFrenzyPointPassive(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetPerfectGuardGainFrenzyPointRatioFuryattack(const struct FItemHandleInfoPtr& Ptr);
	static ELWeaponPostureType GetPostureType(const struct FItemHandleInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadSkillList(const struct FItemHandleInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadWeaponList(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetReinforceTableCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetRigidity(const struct FItemHandleInfoPtr& Ptr);
	static ELWeaponShapeType GetShapeType(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetSharpnessBadPointMod(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetSharpnessFinePointMod(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetSharpnessNormalPointMod(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetSkillActionPathCodeName(const struct FItemHandleInfoPtr& Ptr);
	static float GetStaminaConsumeRatioMax(const struct FItemHandleInfoPtr& Ptr);
	static float GetStaminaConsumeRatioMin(const struct FItemHandleInfoPtr& Ptr);
	static ELWeaponStyleType GetStyleType(const struct FItemHandleInfoPtr& Ptr);
	static float GetSwingPlayRateMax(const struct FItemHandleInfoPtr& Ptr);
	static float GetSwingPlayRateMin(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetSwingSoundCodename(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetWeaponBpCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetWeaponCombineCost(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetWeaponCombineItemCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetWeaponCombineItemCount(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetWeaponDivideCost(const struct FItemHandleInfoPtr& Ptr);
	static const class FName GetWeaponDivideItemCodeName(const struct FItemHandleInfoPtr& Ptr);
	static int32 GetWeaponDivideItemCount(const struct FItemHandleInfoPtr& Ptr);
	static bool IsValid(const struct FItemHandleInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemHandleInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemHandleInfoPtrFuncLibrary">();
	}
	static class UItemHandleInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemHandleInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemHandleInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemHandleInfoPtrFuncLibrary");
static_assert(sizeof(UItemHandleInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemHandleInfoPtrFuncLibrary");

// Class ProjectPContentInfo.CommonConstantInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommonConstantInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCommonConstantInfoPtr& Ptr);
	static class FString GetValue(const struct FCommonConstantInfoPtr& Ptr);
	static bool IsValid(const struct FCommonConstantInfoPtr& Ptr);
	static void IsValidBranch(const struct FCommonConstantInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonConstantInfoPtrFuncLibrary">();
	}
	static class UCommonConstantInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonConstantInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UCommonConstantInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UCommonConstantInfoPtrFuncLibrary");
static_assert(sizeof(UCommonConstantInfoPtrFuncLibrary) == 0x000028, "Wrong size on UCommonConstantInfoPtrFuncLibrary");

// Class ProjectPContentInfo.CommonConstantInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UCommonConstantInfoAsset final : public UContentInfoAsset
{
public:
	struct FCommonConstantInfoDB                  ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FCommonConstantInfoPtr FindCommonConstantInfoByNameBP(class FName CodeName);
	static const TArray<struct FCommonConstantInfo> GetCommonConstantInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonConstantInfoAsset">();
	}
	static class UCommonConstantInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonConstantInfoAsset>();
	}
};
static_assert(alignof(UCommonConstantInfoAsset) == 0x000010, "Wrong alignment on UCommonConstantInfoAsset");
static_assert(sizeof(UCommonConstantInfoAsset) == 0x000120, "Wrong size on UCommonConstantInfoAsset");
static_assert(offsetof(UCommonConstantInfoAsset, ContentInfoDB) == 0x000078, "Member 'UCommonConstantInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.BladeWeightInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UBladeWeightInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetChargeMontageSlot(const struct FBladeWeightInfoPtr& Ptr);
	static float GetChargePlayRate(const struct FBladeWeightInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FBladeWeightInfoPtr& Ptr);
	static const class FName GetDelayMontageSlot(const struct FBladeWeightInfoPtr& Ptr);
	static float GetDelayPlayRate(const struct FBladeWeightInfoPtr& Ptr);
	static const class FName GetEndMontageSlot(const struct FBladeWeightInfoPtr& Ptr);
	static float GetEndPlayRate(const struct FBladeWeightInfoPtr& Ptr);
	static int32 GetHitAnimDurationRatio(const struct FBladeWeightInfoPtr& Ptr);
	static const class FName GetIntroMontageSlot(const struct FBladeWeightInfoPtr& Ptr);
	static float GetIntroPlayRate(const struct FBladeWeightInfoPtr& Ptr);
	static int32 GetKnockbackDistanceRatio(const struct FBladeWeightInfoPtr& Ptr);
	static int32 GetStaminaConsumeRatio(const struct FBladeWeightInfoPtr& Ptr);
	static const class FName GetSwingMontageSlot(const struct FBladeWeightInfoPtr& Ptr);
	static float GetSwingPlayRate(const struct FBladeWeightInfoPtr& Ptr);
	static bool IsValid(const struct FBladeWeightInfoPtr& Ptr);
	static void IsValidBranch(const struct FBladeWeightInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BladeWeightInfoPtrFuncLibrary">();
	}
	static class UBladeWeightInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBladeWeightInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UBladeWeightInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UBladeWeightInfoPtrFuncLibrary");
static_assert(sizeof(UBladeWeightInfoPtrFuncLibrary) == 0x000028, "Wrong size on UBladeWeightInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ContentCommandInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UContentCommandInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FContentCommandInfo& Info);
	static ELContentCommandType GetCommandEnum(const struct FContentCommandInfo& Info);
	static class FString GetParam1(const struct FContentCommandInfo& Info);
	static class FString GetParam10(const struct FContentCommandInfo& Info);
	static class FString GetParam2(const struct FContentCommandInfo& Info);
	static class FString GetParam3(const struct FContentCommandInfo& Info);
	static class FString GetParam4(const struct FContentCommandInfo& Info);
	static class FString GetParam5(const struct FContentCommandInfo& Info);
	static class FString GetParam6(const struct FContentCommandInfo& Info);
	static class FString GetParam7(const struct FContentCommandInfo& Info);
	static class FString GetParam8(const struct FContentCommandInfo& Info);
	static class FString GetParam9(const struct FContentCommandInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentCommandInfoFuncLibrary">();
	}
	static class UContentCommandInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentCommandInfoFuncLibrary>();
	}
};
static_assert(alignof(UContentCommandInfoFuncLibrary) == 0x000008, "Wrong alignment on UContentCommandInfoFuncLibrary");
static_assert(sizeof(UContentCommandInfoFuncLibrary) == 0x000028, "Wrong size on UContentCommandInfoFuncLibrary");

// Class ProjectPContentInfo.ContentCommandInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UContentCommandInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FContentCommandInfoPtr& Ptr);
	static ELContentCommandType GetCommandEnum(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam1(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam10(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam2(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam3(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam4(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam5(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam6(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam7(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam8(const struct FContentCommandInfoPtr& Ptr);
	static class FString GetParam9(const struct FContentCommandInfoPtr& Ptr);
	static bool IsValid(const struct FContentCommandInfoPtr& Ptr);
	static void IsValidBranch(const struct FContentCommandInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentCommandInfoPtrFuncLibrary">();
	}
	static class UContentCommandInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentCommandInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UContentCommandInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UContentCommandInfoPtrFuncLibrary");
static_assert(sizeof(UContentCommandInfoPtrFuncLibrary) == 0x000028, "Wrong size on UContentCommandInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemPartsInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemPartsInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAcidDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetAcidReduce(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBreakDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupAcidReduction(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupBreakReduction(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupContaminationReduction(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupCurseReduction(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupElectricReduction(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupFireReduction(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetBuildupImpactReduction(const struct FItemPartsInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetContaminationDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetCurseDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetElectricDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetElectricReduce(const struct FItemPartsInfoPtr& Ptr);
	static ELItemPartsSlot GetEquipSlot(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetFireDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetFireReduce(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetImpactDebuffResist(const struct FItemPartsInfoPtr& Ptr);
	static ELItemMaterial GetMaterialType(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetPhysicalPierceReduce(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetPhysicalReduce(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetPhysicalSlashReduce(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetPhysicalStrikeReduce(const struct FItemPartsInfoPtr& Ptr);
	static int32 GetTough(const struct FItemPartsInfoPtr& Ptr);
	static bool IsValid(const struct FItemPartsInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemPartsInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPartsInfoPtrFuncLibrary">();
	}
	static class UItemPartsInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPartsInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemPartsInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemPartsInfoPtrFuncLibrary");
static_assert(sizeof(UItemPartsInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemPartsInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ContentCommandInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UContentCommandInfoAsset final : public UContentInfoAsset
{
public:
	struct FContentCommandInfoDB                  ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FContentCommandInfo> GetContentCommandInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentCommandInfoAsset">();
	}
	static class UContentCommandInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentCommandInfoAsset>();
	}
};
static_assert(alignof(UContentCommandInfoAsset) == 0x000010, "Wrong alignment on UContentCommandInfoAsset");
static_assert(sizeof(UContentCommandInfoAsset) == 0x0000D0, "Wrong size on UContentCommandInfoAsset");
static_assert(offsetof(UContentCommandInfoAsset, ContentInfoDB) == 0x000078, "Member 'UContentCommandInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ContentConditionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UContentConditionInfoFuncLibrary final : public UObject
{
public:
	static ELConditionCheckType GetCheckType(const struct FContentConditionInfo& Info);
	static const class FName GetCodeName(const struct FContentConditionInfo& Info);
	static ELConditionCompareType GetConditionType(const struct FContentConditionInfo& Info);
	static class FString GetParam1(const struct FContentConditionInfo& Info);
	static class FString GetParam2(const struct FContentConditionInfo& Info);
	static class FString GetParam3(const struct FContentConditionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentConditionInfoFuncLibrary">();
	}
	static class UContentConditionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentConditionInfoFuncLibrary>();
	}
};
static_assert(alignof(UContentConditionInfoFuncLibrary) == 0x000008, "Wrong alignment on UContentConditionInfoFuncLibrary");
static_assert(sizeof(UContentConditionInfoFuncLibrary) == 0x000028, "Wrong size on UContentConditionInfoFuncLibrary");

// Class ProjectPContentInfo.ItemSlaveArmInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemSlaveArmInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetActionGroupTableCodeName(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetAdditionalGroggyTime(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetAmmoMax(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetAmmoReloadAmount(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetAmmoReloadCooltime(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetAttackGainFrenzyPointActive(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetAttackGainFrenzyPointPassive(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemSlaveArmInfoPtr& Ptr);
	static bool GetConsumeCommand(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetConsumeStaminaPoint(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForAdvance(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForMotivity(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForTechnique(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetDestructionDefence(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetDestructionReduce(const struct FItemSlaveArmInfoPtr& Ptr);
	static const TSoftObjectPtr<class USkeletalMesh> GetMesh(const struct FItemSlaveArmInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadProjectileList(const struct FItemSlaveArmInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadSkillList(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetPulseRechargeAttack(const struct FItemSlaveArmInfoPtr& Ptr);
	static ELReserveType GetReserveType(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetRigidity(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetSkillActionPathCodeName(const struct FItemSlaveArmInfoPtr& Ptr);
	static const class FName GetSkillCodeName(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetSlavearmAcidAttack(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetSlavearmDestructionPower(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetSlavearmElectricAttack(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetSlavearmFireAttack(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetSlaveArmPhysicalAttack(const struct FItemSlaveArmInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FItemSlaveArmInfoPtr& Ptr);
	static bool IsValid(const struct FItemSlaveArmInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemSlaveArmInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlaveArmInfoPtrFuncLibrary">();
	}
	static class UItemSlaveArmInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlaveArmInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemSlaveArmInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemSlaveArmInfoPtrFuncLibrary");
static_assert(sizeof(UItemSlaveArmInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemSlaveArmInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ContentConditionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UContentConditionInfoPtrFuncLibrary final : public UObject
{
public:
	static ELConditionCheckType GetCheckType(const struct FContentConditionInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FContentConditionInfoPtr& Ptr);
	static ELConditionCompareType GetConditionType(const struct FContentConditionInfoPtr& Ptr);
	static class FString GetParam1(const struct FContentConditionInfoPtr& Ptr);
	static class FString GetParam2(const struct FContentConditionInfoPtr& Ptr);
	static class FString GetParam3(const struct FContentConditionInfoPtr& Ptr);
	static bool IsValid(const struct FContentConditionInfoPtr& Ptr);
	static void IsValidBranch(const struct FContentConditionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentConditionInfoPtrFuncLibrary">();
	}
	static class UContentConditionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentConditionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UContentConditionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UContentConditionInfoPtrFuncLibrary");
static_assert(sizeof(UContentConditionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UContentConditionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ContentConditionInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UContentConditionInfoAsset final : public UContentInfoAsset
{
public:
	struct FContentConditionInfoDB                ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FContentConditionInfo> GetContentConditionInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentConditionInfoAsset">();
	}
	static class UContentConditionInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentConditionInfoAsset>();
	}
};
static_assert(alignof(UContentConditionInfoAsset) == 0x000010, "Wrong alignment on UContentConditionInfoAsset");
static_assert(sizeof(UContentConditionInfoAsset) == 0x0000D0, "Wrong size on UContentConditionInfoAsset");
static_assert(offsetof(UContentConditionInfoAsset, ContentInfoDB) == 0x000078, "Member 'UContentConditionInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SlavearmAlterItemMatchInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlavearmAlterItemMatchInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetAlterAction(const struct FSlavearmAlterItemMatchInfoPtr& Ptr);
	static const class FName GetAlterConsumeItemCodename(const struct FSlavearmAlterItemMatchInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSlavearmAlterItemMatchInfoPtr& Ptr);
	static int32 GetRequireMagazine(const struct FSlavearmAlterItemMatchInfoPtr& Ptr);
	static const class FName GetSlavearmCodename(const struct FSlavearmAlterItemMatchInfoPtr& Ptr);
	static bool IsValid(const struct FSlavearmAlterItemMatchInfoPtr& Ptr);
	static void IsValidBranch(const struct FSlavearmAlterItemMatchInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlavearmAlterItemMatchInfoPtrFuncLibrary">();
	}
	static class USlavearmAlterItemMatchInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlavearmAlterItemMatchInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USlavearmAlterItemMatchInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USlavearmAlterItemMatchInfoPtrFuncLibrary");
static_assert(sizeof(USlavearmAlterItemMatchInfoPtrFuncLibrary) == 0x000028, "Wrong size on USlavearmAlterItemMatchInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ContentInfoSettings
// 0x0010 (0x0038 - 0x0028)
class UContentInfoSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentInfoSettings">();
	}
	static class UContentInfoSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentInfoSettings>();
	}
};
static_assert(alignof(UContentInfoSettings) == 0x000008, "Wrong alignment on UContentInfoSettings");
static_assert(sizeof(UContentInfoSettings) == 0x000038, "Wrong size on UContentInfoSettings");

// Class ProjectPContentInfo.ContentInfoLocalize
// 0x0000 (0x0028 - 0x0028)
class UContentInfoLocalize final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentInfoLocalize">();
	}
	static class UContentInfoLocalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentInfoLocalize>();
	}
};
static_assert(alignof(UContentInfoLocalize) == 0x000008, "Wrong alignment on UContentInfoLocalize");
static_assert(sizeof(UContentInfoLocalize) == 0x000028, "Wrong size on UContentInfoLocalize");

// Class ProjectPContentInfo.ItemBladeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemBladeInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetAbnormalElementDisable(const struct FItemBladeInfoPtr& Ptr);
	static bool GetAbnormalEnchantDisable(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetAbnormalStateBuildUpAttack(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FItemBladeInfoPtr& Ptr);
	static ELActionCategory GetActionCategory(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetAdditionalGroggyTime(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetAttackGainFrenzyPointActive(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetAttackGainFrenzyPointPassive(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetAttackSpeed(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetBladeNeedStatLackAbnormalStateCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetBladeNeedStatLackAtkRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetBladeNeedStatLackDestructionRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetBladeNeedStatLackStaminaRatio(const struct FItemBladeInfoPtr& Ptr);
	static ELBladeShapeType GetBladeShapeType(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetBladeWeightCodeName(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetConsumeErgoCount(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetConsumeErgoRate(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetConsumeStaminaPoint(const struct FItemBladeInfoPtr& Ptr);
	static ELCrashType GetCrashType(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetCriticalRate(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetDashParryCounterSkillCodeName(const struct FItemBladeInfoPtr& Ptr);
	static float GetDestructionDefence(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetDestructionPower(const struct FItemBladeInfoPtr& Ptr);
	static float GetDestructionReduce(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetElementalAttack(const struct FItemBladeInfoPtr& Ptr);
	static ELElementDamageType GetElementAttackType(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetErgoFrenzySkillCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetFatalDamageRatio(const struct FItemBladeInfoPtr& Ptr);
	static ELBladeFatalType GetFatalType(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetFrenzySkillCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardDamageReductionRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardDurabilityAttack(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardDurationRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardPoint(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardRegainAttackHeal(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardRegainPerfectGuardHeal(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardRegainPointMaxRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetGuardSharpnessDefence(const struct FItemBladeInfoPtr& Ptr);
	static ELSwingPowerType GetHitFxLevel(const struct FItemBladeInfoPtr& Ptr);
	static ELPhysicalSurfaceType GetHitMaterial(const struct FItemBladeInfoPtr& Ptr);
	static class FString GetLocalTextByname(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetLocalTextBynameCn(const struct FItemBladeInfoPtr& Ptr);
	static class FText GetLocalTextBynameLocalize(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetNecessityAdvance(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetNecessityMotivity(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetNecessityTechnique(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetPerfectGuardDecreaseEnemyWeaponDurability(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetPerfectguardDestructionPower(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetPhysicalAttack(const struct FItemBladeInfoPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalSubtypeWithSwing(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetPhysicalSubtypeWithSwingMod(const struct FItemBladeInfoPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalSubtypeWithThrust(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetPhysicalSubtypeWithThrustMod(const struct FItemBladeInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadProjectileList(const struct FItemBladeInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadSkillList(const struct FItemBladeInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadWeaponList(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetProjectileCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetPulseRechargeAttack(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetReinforceTableCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetRepairRatioPerSecond(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetRequireErgoCount(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetRigidity(const struct FItemBladeInfoPtr& Ptr);
	static ELWeaponShapeType GetShapeType(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetSharpnessBadAbnormalstate(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessBadAttackMod(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessBadPoint(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetSharpnessBreakAbnormalstate(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessBreakAttackMod(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetSharpnessFineAbnormalstate(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessFineAttackMod(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessFinePoint(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetSharpnessNormalAbnormalstate(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessNormalAttackMod(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessNormalPoint(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessReduceValueRatio(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessReduceValueRatioOnGuard(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessRepulseLevelBad(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessRepulseLevelBreak(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessRepulseLevelFine(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetSharpnessRepulseLevelNormal(const struct FItemBladeInfoPtr& Ptr);
	static float GetStiffenPlayrateAttacker(const struct FItemBladeInfoPtr& Ptr);
	static float GetStiffenPlayrateDefender(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetSwingSoundCodename(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FItemBladeInfoPtr& Ptr);
	static bool GetUseBluntTrail(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetWeaponBpCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetWeaponCombineCost(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetWeaponCombineItemCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetWeaponCombineItemCount(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetWeaponDivideCost(const struct FItemBladeInfoPtr& Ptr);
	static const class FName GetWeaponDivideItemCodeName(const struct FItemBladeInfoPtr& Ptr);
	static int32 GetWeaponDivideItemCount(const struct FItemBladeInfoPtr& Ptr);
	static bool IsValid(const struct FItemBladeInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemBladeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBladeInfoPtrFuncLibrary">();
	}
	static class UItemBladeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemBladeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemBladeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemBladeInfoPtrFuncLibrary");
static_assert(sizeof(UItemBladeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemBladeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DialogMonsterMonologueInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDialogMonsterMonologueInfoFuncLibrary final : public UObject
{
public:
	static bool GetCheckCooltime(const struct FDialogMonsterMonologueInfo& Info);
	static int32 GetCheckPercentage(const struct FDialogMonsterMonologueInfo& Info);
	static const class FName GetCodeName(const struct FDialogMonsterMonologueInfo& Info);
	static const class FName GetConditionCodename(const struct FDialogMonsterMonologueInfo& Info);
	static const TArray<struct FGeneralConditionInfo> GetConditionIndependentArray(const struct FDialogMonsterMonologueInfo& Info);
	static int32 GetCount(const struct FDialogMonsterMonologueInfo& Info);
	static int32 GetDelayTime(const struct FDialogMonsterMonologueInfo& Info);
	static const class FName GetDialogCodeName(const struct FDialogMonsterMonologueInfo& Info);
	static ELCallBackEventType GetEventType(const struct FDialogMonsterMonologueInfo& Info);
	static int32 GetMonologueCooltime(const struct FDialogMonsterMonologueInfo& Info);
	static const class FName GetMonologueTargetSpot(const struct FDialogMonsterMonologueInfo& Info);
	static class FString GetParam1(const struct FDialogMonsterMonologueInfo& Info);
	static class FString GetParam2(const struct FDialogMonsterMonologueInfo& Info);
	static int32 GetPCdeathDelay(const struct FDialogMonsterMonologueInfo& Info);
	static const class FName GetSpotUniqueId(const struct FDialogMonsterMonologueInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogMonsterMonologueInfoFuncLibrary">();
	}
	static class UDialogMonsterMonologueInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogMonsterMonologueInfoFuncLibrary>();
	}
};
static_assert(alignof(UDialogMonsterMonologueInfoFuncLibrary) == 0x000008, "Wrong alignment on UDialogMonsterMonologueInfoFuncLibrary");
static_assert(sizeof(UDialogMonsterMonologueInfoFuncLibrary) == 0x000028, "Wrong size on UDialogMonsterMonologueInfoFuncLibrary");

// Class ProjectPContentInfo.DialogMonsterMonologueInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDialogMonsterMonologueInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetCheckCooltime(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static int32 GetCheckPercentage(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static const class FName GetConditionCodename(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static const TArray<struct FGeneralConditionInfo> GetConditionIndependentArray(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static int32 GetCount(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static int32 GetDelayTime(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static const class FName GetDialogCodeName(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static ELCallBackEventType GetEventType(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static int32 GetMonologueCooltime(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static const class FName GetMonologueTargetSpot(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static class FString GetParam1(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static class FString GetParam2(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static int32 GetPCdeathDelay(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static const class FName GetSpotUniqueId(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static bool IsValid(const struct FDialogMonsterMonologueInfoPtr& Ptr);
	static void IsValidBranch(const struct FDialogMonsterMonologueInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogMonsterMonologueInfoPtrFuncLibrary">();
	}
	static class UDialogMonsterMonologueInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogMonsterMonologueInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDialogMonsterMonologueInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDialogMonsterMonologueInfoPtrFuncLibrary");
static_assert(sizeof(UDialogMonsterMonologueInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDialogMonsterMonologueInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemWeaponMonsterPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemWeaponMonsterPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAddSkillHitCodeName(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetAddSkillRangeAfterBroken(const struct FItemWeaponMonsterPtr& Ptr);
	static const class FName GetBrokenSwingSoundCodename(const struct FItemWeaponMonsterPtr& Ptr);
	static const class FName GetCodeName(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetCriticalRate(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetDurability(const struct FItemWeaponMonsterPtr& Ptr);
	static ELElementDamageType GetElementDamageType(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardAciddamageReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardDurabilityDefence(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardElectricdamageReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardFiredamageReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardKnockbackDurationReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardPhysicaldamageReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardPoint(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetGuardSuccessDurabilityReductionRatio(const struct FItemWeaponMonsterPtr& Ptr);
	static bool GetHideAtSpawn(const struct FItemWeaponMonsterPtr& Ptr);
	static ELSwingPowerType GetHitFxLevel(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetMinimumSkillRangeMaxAfterBroken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetMinimumSkillRangeMinAfterBroken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetMulpleRateAtkPowerAfterBoken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetMulpleRateDestructionPowerAfterBroken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetMulpleRateRigidityAfterBoken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FItemWeaponMonsterPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalSubtypeWithSwing(const struct FItemWeaponMonsterPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalSubtypeWithThrust(const struct FItemWeaponMonsterPtr& Ptr);
	static bool GetRemoveAbnormalStateAfterBroken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetRigidity(const struct FItemWeaponMonsterPtr& Ptr);
	static const class FName GetSkillhitAbnormalStateOverride(const struct FItemWeaponMonsterPtr& Ptr);
	static const class FName GetSwingSoundCodename(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FItemWeaponMonsterPtr& Ptr);
	static bool GetUseBluntTrail(const struct FItemWeaponMonsterPtr& Ptr);
	static const class FName GetWeaponBpCodeName(const struct FItemWeaponMonsterPtr& Ptr);
	static const class FName GetWeaponEquipAbnormalStateCodeName(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetWeaponEquipAtkPowerRate(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetWeaponEquipMotionSpeedRate(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetWeaponEquipMotionSpeedRateAfterBroken(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetWeaponEquipSkillRangeMaxRate(const struct FItemWeaponMonsterPtr& Ptr);
	static int32 GetWeaponEquipSkillRangeMinRate(const struct FItemWeaponMonsterPtr& Ptr);
	static bool IsValid(const struct FItemWeaponMonsterPtr& Ptr);
	static void IsValidBranch(const struct FItemWeaponMonsterPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWeaponMonsterPtrFuncLibrary">();
	}
	static class UItemWeaponMonsterPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWeaponMonsterPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemWeaponMonsterPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemWeaponMonsterPtrFuncLibrary");
static_assert(sizeof(UItemWeaponMonsterPtrFuncLibrary) == 0x000028, "Wrong size on UItemWeaponMonsterPtrFuncLibrary");

// Class ProjectPContentInfo.DialogMonsterMonologueInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UDialogMonsterMonologueInfoAsset final : public UContentInfoAsset
{
public:
	struct FDialogMonsterMonologueInfoDB          ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FDialogMonsterMonologueInfoPtr FindDialogMonsterMonologueInfoByNameBP(class FName CodeName);
	static const TArray<struct FDialogMonsterMonologueInfo> GetDialogMonsterMonologueInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogMonsterMonologueInfoAsset">();
	}
	static class UDialogMonsterMonologueInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogMonsterMonologueInfoAsset>();
	}
};
static_assert(alignof(UDialogMonsterMonologueInfoAsset) == 0x000010, "Wrong alignment on UDialogMonsterMonologueInfoAsset");
static_assert(sizeof(UDialogMonsterMonologueInfoAsset) == 0x000120, "Wrong size on UDialogMonsterMonologueInfoAsset");
static_assert(offsetof(UDialogMonsterMonologueInfoAsset, ContentInfoDB) == 0x000078, "Member 'UDialogMonsterMonologueInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.TalkerQuestInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTalkerQuestInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FTalkerQuestInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkerQuestInfoFuncLibrary">();
	}
	static class UTalkerQuestInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTalkerQuestInfoFuncLibrary>();
	}
};
static_assert(alignof(UTalkerQuestInfoFuncLibrary) == 0x000008, "Wrong alignment on UTalkerQuestInfoFuncLibrary");
static_assert(sizeof(UTalkerQuestInfoFuncLibrary) == 0x000028, "Wrong size on UTalkerQuestInfoFuncLibrary");

// Class ProjectPContentInfo.HandleStatCorrectionChangeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHandleStatCorrectionChangeInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAdvanceGradeChange(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static const class FName GetKeyItemCodename(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static const class FName GetKeyItemCodenameHero(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetKeyItemNumAToS(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetKeyItemNumBToA(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetKeyItemNumClear(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetKeyItemNumCToB(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetKeyItemNumDToC(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetKeyItemNumNoneToD(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetMotivityGradeChange(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetRequireErgo(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetRequireErgoHero(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static int32 GetTechniqueGradeChange(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static ELStatCorrectChangeType GetUpgradeStat(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static bool IsValid(const struct FHandleStatCorrectionChangeInfoPtr& Ptr);
	static void IsValidBranch(const struct FHandleStatCorrectionChangeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandleStatCorrectionChangeInfoPtrFuncLibrary">();
	}
	static class UHandleStatCorrectionChangeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHandleStatCorrectionChangeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UHandleStatCorrectionChangeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UHandleStatCorrectionChangeInfoPtrFuncLibrary");
static_assert(sizeof(UHandleStatCorrectionChangeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UHandleStatCorrectionChangeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.TalkerQuestInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTalkerQuestInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FTalkerQuestInfoPtr& Ptr);
	static bool IsValid(const struct FTalkerQuestInfoPtr& Ptr);
	static void IsValidBranch(const struct FTalkerQuestInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkerQuestInfoPtrFuncLibrary">();
	}
	static class UTalkerQuestInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTalkerQuestInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UTalkerQuestInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UTalkerQuestInfoPtrFuncLibrary");
static_assert(sizeof(UTalkerQuestInfoPtrFuncLibrary) == 0x000028, "Wrong size on UTalkerQuestInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DialogInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDialogInfoFuncLibrary final : public UObject
{
public:
	static bool GetCamZoom(const struct FDialogInfo& Info);
	static const class FName GetCodeName(const struct FDialogInfo& Info);
	static const class FName GetConditionCodename(const struct FDialogInfo& Info);
	static const TArray<struct FGeneralConditionInfo> GetConditionIndependentArray(const struct FDialogInfo& Info);
	static const class FName GetContentCommandCodename(const struct FDialogInfo& Info);
	static const TArray<struct FGeneralCommandInfo> GetContentCommandIndependentArray(const struct FDialogInfo& Info);
	static ELDialogDialogType GetDialogType(const struct FDialogInfo& Info);
	static ELDialogExecutionType GetExecutionType(const struct FDialogInfo& Info);
	static bool GetHoldSelect(const struct FDialogInfo& Info);
	static ELLieType GetLieType(const struct FDialogInfo& Info);
	static int32 GetListPriority(const struct FDialogInfo& Info);
	static int32 GetListRepeatCount(const struct FDialogInfo& Info);
	static int32 GetListRepeatTerm(const struct FDialogInfo& Info);
	static ELDialogLookatBone GetLookatBone(const struct FDialogInfo& Info);
	static const class FName GetLootatTarget(const struct FDialogInfo& Info);
	static int32 GetMenuItemVariable(const struct FDialogInfo& Info);
	static bool GetNewNotify(const struct FDialogInfo& Info);
	static const class FName GetNewNotifyGroup(const struct FDialogInfo& Info);
	static const class FName GetNpcCodename(const struct FDialogInfo& Info);
	static const class FName GetNpcMotion(const struct FDialogInfo& Info);
	static const class FName GetPcMotion(const struct FDialogInfo& Info);
	static int32 GetPriority(const struct FDialogInfo& Info);
	static int32 GetRandomDefaultIndex(const struct FDialogInfo& Info);
	static bool GetRandomDefaultSelect(const struct FDialogInfo& Info);
	static int32 GetRandomSelect(const struct FDialogInfo& Info);
	static int32 GetSelectTimer(const struct FDialogInfo& Info);
	static const class FName GetSoundResource(const struct FDialogInfo& Info);
	static ELDialogStepType GetStepType(const struct FDialogInfo& Info);
	static const class FName GetTalkCodename(const struct FDialogInfo& Info);
	static bool GetTalkerRadiusIn(const struct FDialogInfo& Info);
	static const TArray<class FName> GetTargetCodename(const struct FDialogInfo& Info);
	static class FString GetText(const struct FDialogInfo& Info);
	static const class FName GetTextCn(const struct FDialogInfo& Info);
	static class FText GetTextLocalize(const struct FDialogInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogInfoFuncLibrary">();
	}
	static class UDialogInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogInfoFuncLibrary>();
	}
};
static_assert(alignof(UDialogInfoFuncLibrary) == 0x000008, "Wrong alignment on UDialogInfoFuncLibrary");
static_assert(sizeof(UDialogInfoFuncLibrary) == 0x000028, "Wrong size on UDialogInfoFuncLibrary");

// Class ProjectPContentInfo.LevelSequenceInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelSequenceInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAfterCommandExec(const struct FLevelSequenceInfoPtr& Ptr);
	static const class FName GetAfterPlayedSequencer(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetAlignToCineCamera(const struct FLevelSequenceInfoPtr& Ptr);
	static const class FName GetBeforePlayedSequencer(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetBindingPlayer(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetCanSave(const struct FLevelSequenceInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetDisableCameraCuts(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetFixCameraSpeed(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetGameProcessPause(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetHeadCostumeOff(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetHideHud(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetHidePlayer(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetIsGrabSkill(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetLockPlayerAction(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetLockPlayerActionCameraEnable(const struct FLevelSequenceInfoPtr& Ptr);
	static int32 GetLoopCount(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetNoSkip(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetPauseAtEnd(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetPlayOnce(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetRestoreState(const struct FLevelSequenceInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSequenceResource(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetSetToBossLocation(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetSetToPlayerLocation(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetShowHud(const struct FLevelSequenceInfoPtr& Ptr);
	static const class FName GetSkipSequencer(const struct FLevelSequenceInfoPtr& Ptr);
	static const class FName GetSubtitleCodeName(const struct FLevelSequenceInfoPtr& Ptr);
	static const class FName GetTogglePlayerSequencer(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetUiBlock(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetUiFadeout(const struct FLevelSequenceInfoPtr& Ptr);
	static bool GetUseCinematicCamera(const struct FLevelSequenceInfoPtr& Ptr);
	static bool IsValid(const struct FLevelSequenceInfoPtr& Ptr);
	static void IsValidBranch(const struct FLevelSequenceInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelSequenceInfoPtrFuncLibrary">();
	}
	static class ULevelSequenceInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelSequenceInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULevelSequenceInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULevelSequenceInfoPtrFuncLibrary");
static_assert(sizeof(ULevelSequenceInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULevelSequenceInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DialogInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDialogInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetCamZoom(const struct FDialogInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FDialogInfoPtr& Ptr);
	static const class FName GetConditionCodename(const struct FDialogInfoPtr& Ptr);
	static const TArray<struct FGeneralConditionInfo> GetConditionIndependentArray(const struct FDialogInfoPtr& Ptr);
	static const class FName GetContentCommandCodename(const struct FDialogInfoPtr& Ptr);
	static const TArray<struct FGeneralCommandInfo> GetContentCommandIndependentArray(const struct FDialogInfoPtr& Ptr);
	static ELDialogDialogType GetDialogType(const struct FDialogInfoPtr& Ptr);
	static ELDialogExecutionType GetExecutionType(const struct FDialogInfoPtr& Ptr);
	static bool GetHoldSelect(const struct FDialogInfoPtr& Ptr);
	static ELLieType GetLieType(const struct FDialogInfoPtr& Ptr);
	static int32 GetListPriority(const struct FDialogInfoPtr& Ptr);
	static int32 GetListRepeatCount(const struct FDialogInfoPtr& Ptr);
	static int32 GetListRepeatTerm(const struct FDialogInfoPtr& Ptr);
	static ELDialogLookatBone GetLookatBone(const struct FDialogInfoPtr& Ptr);
	static const class FName GetLootatTarget(const struct FDialogInfoPtr& Ptr);
	static int32 GetMenuItemVariable(const struct FDialogInfoPtr& Ptr);
	static bool GetNewNotify(const struct FDialogInfoPtr& Ptr);
	static const class FName GetNewNotifyGroup(const struct FDialogInfoPtr& Ptr);
	static const class FName GetNpcCodename(const struct FDialogInfoPtr& Ptr);
	static const class FName GetNpcMotion(const struct FDialogInfoPtr& Ptr);
	static const class FName GetPcMotion(const struct FDialogInfoPtr& Ptr);
	static int32 GetPriority(const struct FDialogInfoPtr& Ptr);
	static int32 GetRandomDefaultIndex(const struct FDialogInfoPtr& Ptr);
	static bool GetRandomDefaultSelect(const struct FDialogInfoPtr& Ptr);
	static int32 GetRandomSelect(const struct FDialogInfoPtr& Ptr);
	static int32 GetSelectTimer(const struct FDialogInfoPtr& Ptr);
	static const class FName GetSoundResource(const struct FDialogInfoPtr& Ptr);
	static ELDialogStepType GetStepType(const struct FDialogInfoPtr& Ptr);
	static const class FName GetTalkCodename(const struct FDialogInfoPtr& Ptr);
	static bool GetTalkerRadiusIn(const struct FDialogInfoPtr& Ptr);
	static const TArray<class FName> GetTargetCodename(const struct FDialogInfoPtr& Ptr);
	static class FString GetText(const struct FDialogInfoPtr& Ptr);
	static const class FName GetTextCn(const struct FDialogInfoPtr& Ptr);
	static class FText GetTextLocalize(const struct FDialogInfoPtr& Ptr);
	static bool IsValid(const struct FDialogInfoPtr& Ptr);
	static void IsValidBranch(const struct FDialogInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogInfoPtrFuncLibrary">();
	}
	static class UDialogInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDialogInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDialogInfoPtrFuncLibrary");
static_assert(sizeof(UDialogInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDialogInfoPtrFuncLibrary");

// Class ProjectPContentInfo.TalkerInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTalkerInfoFuncLibrary final : public UObject
{
public:
	static bool GetAggressive(const struct FTalkerInfo& Info);
	static ELAgressiveRecoverType GetAggressiveRecoverType(const struct FTalkerInfo& Info);
	static bool GetAttackable(const struct FTalkerInfo& Info);
	static const class FName GetAttackedExec(const struct FTalkerInfo& Info);
	static const class FName GetAttackedExecCondition(const struct FTalkerInfo& Info);
	static const class FName GetCodeName(const struct FTalkerInfo& Info);
	static const class FName GetDialogIdle(const struct FTalkerInfo& Info);
	static int32 GetDialogRadius(const struct FTalkerInfo& Info);
	static bool GetEnableDialogRotate(const struct FTalkerInfo& Info);
	static const class FName GetInteractionApproachMessageCodeName(const struct FTalkerInfo& Info);
	static int32 GetInteractionConfrontAngle(const struct FTalkerInfo& Info);
	static int32 GetInteractionConfrontAngleProp(const struct FTalkerInfo& Info);
	static int32 GetInteractionOffsetX(const struct FTalkerInfo& Info);
	static int32 GetInteractionOffsetY(const struct FTalkerInfo& Info);
	static int32 GetInteractionOffsetZ(const struct FTalkerInfo& Info);
	static int32 GetInteractionRadius(const struct FTalkerInfo& Info);
	static class FString GetLocalName(const struct FTalkerInfo& Info);
	static const class FName GetLocalNameCn(const struct FTalkerInfo& Info);
	static class FText GetLocalNameLocalize(const struct FTalkerInfo& Info);
	static ELDialogLookatBone GetLookatBone(const struct FTalkerInfo& Info);
	static int32 GetLookatRadius(const struct FTalkerInfo& Info);
	static const class FName GetLootatTarget(const struct FTalkerInfo& Info);
	static int32 GetMinTurnAngle(const struct FTalkerInfo& Info);
	static int32 GetMonologueRadius(const struct FTalkerInfo& Info);
	static const TArray<class FName> GetQuest(const struct FTalkerInfo& Info);
	static bool GetShowGoldentreeStatus(const struct FTalkerInfo& Info);
	static const class FName GetTalkerIdle(const struct FTalkerInfo& Info);
	static const TArray<class FName> GetTalkerIdleSub(const struct FTalkerInfo& Info);
	static ELTalkStarterType GetTalkStarterType(const struct FTalkerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkerInfoFuncLibrary">();
	}
	static class UTalkerInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTalkerInfoFuncLibrary>();
	}
};
static_assert(alignof(UTalkerInfoFuncLibrary) == 0x000008, "Wrong alignment on UTalkerInfoFuncLibrary");
static_assert(sizeof(UTalkerInfoFuncLibrary) == 0x000028, "Wrong size on UTalkerInfoFuncLibrary");

// Class ProjectPContentInfo.ItemRedundancyExchangeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemRedundancyExchangeInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FItemRedundancyExchangeInfoPtr& Ptr);
	static const class FName GetCodeNameExchange(const struct FItemRedundancyExchangeInfoPtr& Ptr);
	static bool IsValid(const struct FItemRedundancyExchangeInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemRedundancyExchangeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRedundancyExchangeInfoPtrFuncLibrary">();
	}
	static class UItemRedundancyExchangeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRedundancyExchangeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemRedundancyExchangeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemRedundancyExchangeInfoPtrFuncLibrary");
static_assert(sizeof(UItemRedundancyExchangeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemRedundancyExchangeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.TalkerInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTalkerInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetAggressive(const struct FTalkerInfoPtr& Ptr);
	static ELAgressiveRecoverType GetAggressiveRecoverType(const struct FTalkerInfoPtr& Ptr);
	static bool GetAttackable(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetAttackedExec(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetAttackedExecCondition(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetDialogIdle(const struct FTalkerInfoPtr& Ptr);
	static int32 GetDialogRadius(const struct FTalkerInfoPtr& Ptr);
	static bool GetEnableDialogRotate(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetInteractionApproachMessageCodeName(const struct FTalkerInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngle(const struct FTalkerInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngleProp(const struct FTalkerInfoPtr& Ptr);
	static int32 GetInteractionOffsetX(const struct FTalkerInfoPtr& Ptr);
	static int32 GetInteractionOffsetY(const struct FTalkerInfoPtr& Ptr);
	static int32 GetInteractionOffsetZ(const struct FTalkerInfoPtr& Ptr);
	static int32 GetInteractionRadius(const struct FTalkerInfoPtr& Ptr);
	static class FString GetLocalName(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetLocalNameCn(const struct FTalkerInfoPtr& Ptr);
	static class FText GetLocalNameLocalize(const struct FTalkerInfoPtr& Ptr);
	static ELDialogLookatBone GetLookatBone(const struct FTalkerInfoPtr& Ptr);
	static int32 GetLookatRadius(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetLootatTarget(const struct FTalkerInfoPtr& Ptr);
	static int32 GetMinTurnAngle(const struct FTalkerInfoPtr& Ptr);
	static int32 GetMonologueRadius(const struct FTalkerInfoPtr& Ptr);
	static const TArray<class FName> GetQuest(const struct FTalkerInfoPtr& Ptr);
	static bool GetShowGoldentreeStatus(const struct FTalkerInfoPtr& Ptr);
	static const class FName GetTalkerIdle(const struct FTalkerInfoPtr& Ptr);
	static const TArray<class FName> GetTalkerIdleSub(const struct FTalkerInfoPtr& Ptr);
	static ELTalkStarterType GetTalkStarterType(const struct FTalkerInfoPtr& Ptr);
	static bool IsValid(const struct FTalkerInfoPtr& Ptr);
	static void IsValidBranch(const struct FTalkerInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TalkerInfoPtrFuncLibrary">();
	}
	static class UTalkerInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTalkerInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UTalkerInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UTalkerInfoPtrFuncLibrary");
static_assert(sizeof(UTalkerInfoPtrFuncLibrary) == 0x000028, "Wrong size on UTalkerInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SpotTalkerMatchingInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpotTalkerMatchingInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetSpotId(const struct FSpotTalkerMatchingInfo& Info);
	static const class FName GetTalkerCodeName(const struct FSpotTalkerMatchingInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotTalkerMatchingInfoFuncLibrary">();
	}
	static class USpotTalkerMatchingInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpotTalkerMatchingInfoFuncLibrary>();
	}
};
static_assert(alignof(USpotTalkerMatchingInfoFuncLibrary) == 0x000008, "Wrong alignment on USpotTalkerMatchingInfoFuncLibrary");
static_assert(sizeof(USpotTalkerMatchingInfoFuncLibrary) == 0x000028, "Wrong size on USpotTalkerMatchingInfoFuncLibrary");

// Class ProjectPContentInfo.ItemWeaponReinforceInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemWeaponReinforceInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetAcidAttackMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static class FString GetCorrectionCodeNameForAdvance(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static class FString GetCorrectionCodeNameForMotivity(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static class FString GetCorrectionCodeNameForTechnique(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetElectricAttackMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetFireAttackMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static ELWeaponCorrectionPhysicalGrade GetFirstStatCorrectionAdvance(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static ELWeaponCorrectionPhysicalGrade GetFirstStatCorrectionMotivity(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static ELWeaponCorrectionPhysicalGrade GetFirstStatCorrectionTechnique(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetGrade(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static class FString GetLocalTextByname(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetNeedErgo(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static const class FName GetNeedItemCodeName(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetNeedItemNum(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetPhysicalAttackMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetSharpnessBadPoint(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetSharpnessBadPointMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetSharpnessFinePoint(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetSharpnessFinePointMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetSharpnessNormalPoint(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static int32 GetSharpnessNormalPointMod(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static bool IsValid(const struct FItemWeaponReinforceInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemWeaponReinforceInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWeaponReinforceInfoPtrFuncLibrary">();
	}
	static class UItemWeaponReinforceInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWeaponReinforceInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemWeaponReinforceInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemWeaponReinforceInfoPtrFuncLibrary");
static_assert(sizeof(UItemWeaponReinforceInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemWeaponReinforceInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SpotTalkerMatchingInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpotTalkerMatchingInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetSpotId(const struct FSpotTalkerMatchingInfoPtr& Ptr);
	static const class FName GetTalkerCodeName(const struct FSpotTalkerMatchingInfoPtr& Ptr);
	static bool IsValid(const struct FSpotTalkerMatchingInfoPtr& Ptr);
	static void IsValidBranch(const struct FSpotTalkerMatchingInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotTalkerMatchingInfoPtrFuncLibrary">();
	}
	static class USpotTalkerMatchingInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpotTalkerMatchingInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USpotTalkerMatchingInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USpotTalkerMatchingInfoPtrFuncLibrary");
static_assert(sizeof(USpotTalkerMatchingInfoPtrFuncLibrary) == 0x000028, "Wrong size on USpotTalkerMatchingInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DialogQuestInfoAsset
// 0x0118 (0x0190 - 0x0078)
class alignas(0x10) UDialogQuestInfoAsset final : public UContentInfoAsset
{
public:
	struct FDialogQuestInfoDB                     ContentInfoDB;                                     // 0x0078(0x0110)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSpotTalkerMatchingInfoPtr FindSpotTalkerMatchingInfoByNameBP(class FName CodeName);
	static struct FTalkerInfoPtr FindTalkerInfoByNameBP(class FName CodeName);
	static const TArray<struct FDialogInfo> GetDialogInfoArrayBP();
	static const TArray<struct FSpotTalkerMatchingInfo> GetSpotTalkerMatchingInfoArrayBP();
	static const TArray<struct FTalkerInfo> GetTalkerInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogQuestInfoAsset">();
	}
	static class UDialogQuestInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogQuestInfoAsset>();
	}
};
static_assert(alignof(UDialogQuestInfoAsset) == 0x000010, "Wrong alignment on UDialogQuestInfoAsset");
static_assert(sizeof(UDialogQuestInfoAsset) == 0x000190, "Wrong size on UDialogQuestInfoAsset");
static_assert(offsetof(UDialogQuestInfoAsset, ContentInfoDB) == 0x000078, "Member 'UDialogQuestInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PathWayInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPathWayInfoAsset final : public UContentInfoAsset
{
public:
	struct FPathWayInfoDB                         ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPathWayInfo> GetPathWayInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathWayInfoAsset">();
	}
	static class UPathWayInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathWayInfoAsset>();
	}
};
static_assert(alignof(UPathWayInfoAsset) == 0x000010, "Wrong alignment on UPathWayInfoAsset");
static_assert(sizeof(UPathWayInfoAsset) == 0x0000D0, "Wrong size on UPathWayInfoAsset");
static_assert(offsetof(UPathWayInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPathWayInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.DieMotionGroupInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDieMotionGroupInfoFuncLibrary final : public UObject
{
public:
	static int32 GetChosenProbability(const struct FDieMotionGroupInfo& Info);
	static const class FName GetDieMotionGroup(const struct FDieMotionGroupInfo& Info);
	static const class FName GetPlayCommonActionMontageCodeName(const struct FDieMotionGroupInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DieMotionGroupInfoFuncLibrary">();
	}
	static class UDieMotionGroupInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDieMotionGroupInfoFuncLibrary>();
	}
};
static_assert(alignof(UDieMotionGroupInfoFuncLibrary) == 0x000008, "Wrong alignment on UDieMotionGroupInfoFuncLibrary");
static_assert(sizeof(UDieMotionGroupInfoFuncLibrary) == 0x000028, "Wrong size on UDieMotionGroupInfoFuncLibrary");

// Class ProjectPContentInfo.DieMotionGroupInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDieMotionGroupInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetChosenProbability(const struct FDieMotionGroupInfoPtr& Ptr);
	static const class FName GetDieMotionGroup(const struct FDieMotionGroupInfoPtr& Ptr);
	static const class FName GetPlayCommonActionMontageCodeName(const struct FDieMotionGroupInfoPtr& Ptr);
	static bool IsValid(const struct FDieMotionGroupInfoPtr& Ptr);
	static void IsValidBranch(const struct FDieMotionGroupInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DieMotionGroupInfoPtrFuncLibrary">();
	}
	static class UDieMotionGroupInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDieMotionGroupInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDieMotionGroupInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDieMotionGroupInfoPtrFuncLibrary");
static_assert(sizeof(UDieMotionGroupInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDieMotionGroupInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LocalDataInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULocalDataInfoPtrFuncLibrary final : public UObject
{
public:
	static class FString GetChineseSimplified(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetChineseTraditional(const struct FLocalDataInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetEnglish(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetFrench(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetGerman(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetItalian(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetJapanese(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetKorean(const struct FLocalDataInfoPtr& Ptr);
	static class FText GetKoreanLocalize(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetPolish(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetPortuguese(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetRussian(const struct FLocalDataInfoPtr& Ptr);
	static class FString GetSpanish(const struct FLocalDataInfoPtr& Ptr);
	static bool IsValid(const struct FLocalDataInfoPtr& Ptr);
	static void IsValidBranch(const struct FLocalDataInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalDataInfoPtrFuncLibrary">();
	}
	static class ULocalDataInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalDataInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULocalDataInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULocalDataInfoPtrFuncLibrary");
static_assert(sizeof(ULocalDataInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULocalDataInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DieMotionGroupInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UDieMotionGroupInfoAsset final : public UContentInfoAsset
{
public:
	struct FDieMotionGroupInfoDB                  ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FDieMotionGroupInfo> GetDieMotionGroupInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DieMotionGroupInfoAsset">();
	}
	static class UDieMotionGroupInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDieMotionGroupInfoAsset>();
	}
};
static_assert(alignof(UDieMotionGroupInfoAsset) == 0x000010, "Wrong alignment on UDieMotionGroupInfoAsset");
static_assert(sizeof(UDieMotionGroupInfoAsset) == 0x0000D0, "Wrong size on UDieMotionGroupInfoAsset");
static_assert(offsetof(UDieMotionGroupInfoAsset, ContentInfoDB) == 0x000078, "Member 'UDieMotionGroupInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.DieMotionTransitionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDieMotionTransitionInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetActionGroupTableCodeName(const struct FDieMotionTransitionInfo& Info);
	static const class FName GetCurrentActionClassCodeName(const struct FDieMotionTransitionInfo& Info);
	static const class FName GetCurrentCommonActionMontage(const struct FDieMotionTransitionInfo& Info);
	static ELActionCategory GetDieCauseActionCategory(const struct FDieMotionTransitionInfo& Info);
	static ELDieCauseElement GetDieCauseElement(const struct FDieMotionTransitionInfo& Info);
	static ELDieCauseFall GetDieCauseFall(const struct FDieMotionTransitionInfo& Info);
	static ELHitMotionType GetDieCauseHitAction(const struct FDieMotionTransitionInfo& Info);
	static ELDieCauseHitDirection GetDieCauseHitDirection(const struct FDieMotionTransitionInfo& Info);
	static ELPhysicalDamageType GetDieCausePhysicalDamageType(const struct FDieMotionTransitionInfo& Info);
	static ELDieCauseType GetDieCauseType(const struct FDieMotionTransitionInfo& Info);
	static const class FName GetDieMotionGroupCodeName(const struct FDieMotionTransitionInfo& Info);
	static bool GetIsAllowLieDying(const struct FDieMotionTransitionInfo& Info);
	static const class FName GetNpcAssetTableCodeName(const struct FDieMotionTransitionInfo& Info);
	static const class FName GetNpcCodename(const struct FDieMotionTransitionInfo& Info);
	static int32 GetPriority(const struct FDieMotionTransitionInfo& Info);
	static ELSkillHitType GetSkillHitType(const struct FDieMotionTransitionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DieMotionTransitionInfoFuncLibrary">();
	}
	static class UDieMotionTransitionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDieMotionTransitionInfoFuncLibrary>();
	}
};
static_assert(alignof(UDieMotionTransitionInfoFuncLibrary) == 0x000008, "Wrong alignment on UDieMotionTransitionInfoFuncLibrary");
static_assert(sizeof(UDieMotionTransitionInfoFuncLibrary) == 0x000028, "Wrong size on UDieMotionTransitionInfoFuncLibrary");

// Class ProjectPContentInfo.FirstStatToSecondStatInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFirstStatToSecondStatInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetConversionValueA(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueB(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueC(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueD(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueE(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueF(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueG(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueH(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueI(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueJ(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueK(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetConversionValueL(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELFirstStat GetFirstStatA(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatA(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatB(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatC(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatD(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatE(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatF(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatG(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatH(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatI(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatJ(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatK(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static ELSecondStat GetSecondStatL(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static int32 GetStatLevel(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static bool IsValid(const struct FFirstStatToSecondStatInfoPtr& Ptr);
	static void IsValidBranch(const struct FFirstStatToSecondStatInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstStatToSecondStatInfoPtrFuncLibrary">();
	}
	static class UFirstStatToSecondStatInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstStatToSecondStatInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFirstStatToSecondStatInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFirstStatToSecondStatInfoPtrFuncLibrary");
static_assert(sizeof(UFirstStatToSecondStatInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFirstStatToSecondStatInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DieMotionTransitionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDieMotionTransitionInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetActionGroupTableCodeName(const struct FDieMotionTransitionInfoPtr& Ptr);
	static const class FName GetCurrentActionClassCodeName(const struct FDieMotionTransitionInfoPtr& Ptr);
	static const class FName GetCurrentCommonActionMontage(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELActionCategory GetDieCauseActionCategory(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELDieCauseElement GetDieCauseElement(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELDieCauseFall GetDieCauseFall(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELHitMotionType GetDieCauseHitAction(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELDieCauseHitDirection GetDieCauseHitDirection(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELPhysicalDamageType GetDieCausePhysicalDamageType(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELDieCauseType GetDieCauseType(const struct FDieMotionTransitionInfoPtr& Ptr);
	static const class FName GetDieMotionGroupCodeName(const struct FDieMotionTransitionInfoPtr& Ptr);
	static bool GetIsAllowLieDying(const struct FDieMotionTransitionInfoPtr& Ptr);
	static const class FName GetNpcAssetTableCodeName(const struct FDieMotionTransitionInfoPtr& Ptr);
	static const class FName GetNpcCodename(const struct FDieMotionTransitionInfoPtr& Ptr);
	static int32 GetPriority(const struct FDieMotionTransitionInfoPtr& Ptr);
	static ELSkillHitType GetSkillHitType(const struct FDieMotionTransitionInfoPtr& Ptr);
	static bool IsValid(const struct FDieMotionTransitionInfoPtr& Ptr);
	static void IsValidBranch(const struct FDieMotionTransitionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DieMotionTransitionInfoPtrFuncLibrary">();
	}
	static class UDieMotionTransitionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDieMotionTransitionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDieMotionTransitionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDieMotionTransitionInfoPtrFuncLibrary");
static_assert(sizeof(UDieMotionTransitionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDieMotionTransitionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DieMotionTransitionInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UDieMotionTransitionInfoAsset final : public UContentInfoAsset
{
public:
	struct FDieMotionTransitionInfoDB             ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FDieMotionTransitionInfo> GetDieMotionTransitionInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DieMotionTransitionInfoAsset">();
	}
	static class UDieMotionTransitionInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDieMotionTransitionInfoAsset>();
	}
};
static_assert(alignof(UDieMotionTransitionInfoAsset) == 0x000010, "Wrong alignment on UDieMotionTransitionInfoAsset");
static_assert(sizeof(UDieMotionTransitionInfoAsset) == 0x0000D0, "Wrong size on UDieMotionTransitionInfoAsset");
static_assert(offsetof(UDieMotionTransitionInfoAsset, ContentInfoDB) == 0x000078, "Member 'UDieMotionTransitionInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PathWayInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPathWayInfoFuncLibrary final : public UObject
{
public:
	static float GetArrivalRadius(const struct FPathWayInfo& Info);
	static const class FName GetCodeName(const struct FPathWayInfo& Info);
	static int32 GetIndex(const struct FPathWayInfo& Info);
	static ELPathWayType GetType(const struct FPathWayInfo& Info);
	static float GetWaitTime(const struct FPathWayInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathWayInfoFuncLibrary">();
	}
	static class UPathWayInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathWayInfoFuncLibrary>();
	}
};
static_assert(alignof(UPathWayInfoFuncLibrary) == 0x000008, "Wrong alignment on UPathWayInfoFuncLibrary");
static_assert(sizeof(UPathWayInfoFuncLibrary) == 0x000028, "Wrong size on UPathWayInfoFuncLibrary");

// Class ProjectPContentInfo.DLCItemPackageFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDLCItemPackageFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FDLCItemPackage& Info);
	static int32 GetCount(const struct FDLCItemPackage& Info);
	static int32 GetPrintOrder(const struct FDLCItemPackage& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCItemPackageFuncLibrary">();
	}
	static class UDLCItemPackageFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCItemPackageFuncLibrary>();
	}
};
static_assert(alignof(UDLCItemPackageFuncLibrary) == 0x000008, "Wrong alignment on UDLCItemPackageFuncLibrary");
static_assert(sizeof(UDLCItemPackageFuncLibrary) == 0x000028, "Wrong size on UDLCItemPackageFuncLibrary");

// Class ProjectPContentInfo.DLCItemPackagePtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDLCItemPackagePtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FDLCItemPackagePtr& Ptr);
	static int32 GetCount(const struct FDLCItemPackagePtr& Ptr);
	static int32 GetPrintOrder(const struct FDLCItemPackagePtr& Ptr);
	static bool IsValid(const struct FDLCItemPackagePtr& Ptr);
	static void IsValidBranch(const struct FDLCItemPackagePtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCItemPackagePtrFuncLibrary">();
	}
	static class UDLCItemPackagePtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCItemPackagePtrFuncLibrary>();
	}
};
static_assert(alignof(UDLCItemPackagePtrFuncLibrary) == 0x000008, "Wrong alignment on UDLCItemPackagePtrFuncLibrary");
static_assert(sizeof(UDLCItemPackagePtrFuncLibrary) == 0x000028, "Wrong size on UDLCItemPackagePtrFuncLibrary");

// Class ProjectPContentInfo.LoadingScreenInfoAsset
// 0x0108 (0x0180 - 0x0078)
class alignas(0x10) ULoadingScreenInfoAsset final : public UContentInfoAsset
{
public:
	struct FLoadingScreenInfoDB                   ContentInfoDB;                                     // 0x0078(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FLoadingScreenInfoPtr FindLoadingScreenInfoByNameBP(class FName CodeName);
	static struct FLoadingTipInfoPtr FindLoadingTipInfoByNameBP(class FName CodeName);
	static const TArray<struct FLoadingScreenInfo> GetLoadingScreenInfoArrayBP();
	static const TArray<struct FLoadingTipInfo> GetLoadingTipInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenInfoAsset">();
	}
	static class ULoadingScreenInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenInfoAsset>();
	}
};
static_assert(alignof(ULoadingScreenInfoAsset) == 0x000010, "Wrong alignment on ULoadingScreenInfoAsset");
static_assert(sizeof(ULoadingScreenInfoAsset) == 0x000180, "Wrong size on ULoadingScreenInfoAsset");
static_assert(offsetof(ULoadingScreenInfoAsset, ContentInfoDB) == 0x000078, "Member 'ULoadingScreenInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.DLCWeaponPackageFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDLCWeaponPackageFuncLibrary final : public UObject
{
public:
	static const class FName GetBladeCodeName(const struct FDLCWeaponPackage& Info);
	static const class FName GetHandleCodeName(const struct FDLCWeaponPackage& Info);
	static int32 GetPrintOrder(const struct FDLCWeaponPackage& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCWeaponPackageFuncLibrary">();
	}
	static class UDLCWeaponPackageFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCWeaponPackageFuncLibrary>();
	}
};
static_assert(alignof(UDLCWeaponPackageFuncLibrary) == 0x000008, "Wrong alignment on UDLCWeaponPackageFuncLibrary");
static_assert(sizeof(UDLCWeaponPackageFuncLibrary) == 0x000028, "Wrong size on UDLCWeaponPackageFuncLibrary");

// Class ProjectPContentInfo.DLCWeaponPackagePtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDLCWeaponPackagePtrFuncLibrary final : public UObject
{
public:
	static const class FName GetBladeCodeName(const struct FDLCWeaponPackagePtr& Ptr);
	static const class FName GetHandleCodeName(const struct FDLCWeaponPackagePtr& Ptr);
	static int32 GetPrintOrder(const struct FDLCWeaponPackagePtr& Ptr);
	static bool IsValid(const struct FDLCWeaponPackagePtr& Ptr);
	static void IsValidBranch(const struct FDLCWeaponPackagePtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCWeaponPackagePtrFuncLibrary">();
	}
	static class UDLCWeaponPackagePtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCWeaponPackagePtrFuncLibrary>();
	}
};
static_assert(alignof(UDLCWeaponPackagePtrFuncLibrary) == 0x000008, "Wrong alignment on UDLCWeaponPackagePtrFuncLibrary");
static_assert(sizeof(UDLCWeaponPackagePtrFuncLibrary) == 0x000028, "Wrong size on UDLCWeaponPackagePtrFuncLibrary");

// Class ProjectPContentInfo.NPCLocomotionListInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCLocomotionListInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAnimState(const struct FNPCLocomotionListInfoPtr& Ptr);
	static const class FName GetMachine(const struct FNPCLocomotionListInfoPtr& Ptr);
	static const class FName GetOverrideAnimName(const struct FNPCLocomotionListInfoPtr& Ptr);
	static bool IsValid(const struct FNPCLocomotionListInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCLocomotionListInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCLocomotionListInfoPtrFuncLibrary">();
	}
	static class UNPCLocomotionListInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCLocomotionListInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCLocomotionListInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCLocomotionListInfoPtrFuncLibrary");
static_assert(sizeof(UNPCLocomotionListInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCLocomotionListInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DLCInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDLCInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FDLCInfo& Info);
	static const TArray<struct FDLCItemPackage> GetItemListArray(const struct FDLCInfo& Info);
	static class FString GetLocalTextName(const struct FDLCInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FDLCInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FDLCInfo& Info);
	static class FString GetPlaystationKey(const struct FDLCInfo& Info);
	static class FString GetSteamKey(const struct FDLCInfo& Info);
	static const TArray<struct FDLCWeaponPackage> GetWeaponListArray(const struct FDLCInfo& Info);
	static class FString GetXboxKey(const struct FDLCInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCInfoFuncLibrary">();
	}
	static class UDLCInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCInfoFuncLibrary>();
	}
};
static_assert(alignof(UDLCInfoFuncLibrary) == 0x000008, "Wrong alignment on UDLCInfoFuncLibrary");
static_assert(sizeof(UDLCInfoFuncLibrary) == 0x000028, "Wrong size on UDLCInfoFuncLibrary");

// Class ProjectPContentInfo.DLCInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDLCInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FDLCInfoPtr& Ptr);
	static const TArray<struct FDLCItemPackage> GetItemListArray(const struct FDLCInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FDLCInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FDLCInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FDLCInfoPtr& Ptr);
	static class FString GetPlaystationKey(const struct FDLCInfoPtr& Ptr);
	static class FString GetSteamKey(const struct FDLCInfoPtr& Ptr);
	static const TArray<struct FDLCWeaponPackage> GetWeaponListArray(const struct FDLCInfoPtr& Ptr);
	static class FString GetXboxKey(const struct FDLCInfoPtr& Ptr);
	static bool IsValid(const struct FDLCInfoPtr& Ptr);
	static void IsValidBranch(const struct FDLCInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCInfoPtrFuncLibrary">();
	}
	static class UDLCInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDLCInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDLCInfoPtrFuncLibrary");
static_assert(sizeof(UDLCInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDLCInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LocationInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULocationInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FLocationInfo& Info);
	static class FString GetLocalTextName(const struct FLocationInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FLocationInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FLocationInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLocationListImage(const struct FLocationInfo& Info);
	static const class FName GetPersistentLevel(const struct FLocationInfo& Info);
	static const class FName GetWorldZone(const struct FLocationInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocationInfoFuncLibrary">();
	}
	static class ULocationInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocationInfoFuncLibrary>();
	}
};
static_assert(alignof(ULocationInfoFuncLibrary) == 0x000008, "Wrong alignment on ULocationInfoFuncLibrary");
static_assert(sizeof(ULocationInfoFuncLibrary) == 0x000028, "Wrong size on ULocationInfoFuncLibrary");

// Class ProjectPContentInfo.DLCInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UDLCInfoAsset final : public UContentInfoAsset
{
public:
	struct FDLCInfoDB                             ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FDLCInfoPtr FindDLCInfoByNameBP(class FName CodeName);
	static const TArray<struct FDLCInfo> GetDLCInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLCInfoAsset">();
	}
	static class UDLCInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLCInfoAsset>();
	}
};
static_assert(alignof(UDLCInfoAsset) == 0x000010, "Wrong alignment on UDLCInfoAsset");
static_assert(sizeof(UDLCInfoAsset) == 0x000120, "Wrong size on UDLCInfoAsset");
static_assert(offsetof(UDLCInfoAsset, ContentInfoDB) == 0x000078, "Member 'UDLCInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.DynamicDamageVolumeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDynamicDamageVolumeInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FDynamicDamageVolumeInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetAbnormalStatePenaltyBase(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetAcidAttack(const struct FDynamicDamageVolumeInfo& Info);
	static const TSoftClassPtr<class UClass> GetBlueprintClass(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetBuildUpRecoverIncBase(const struct FDynamicDamageVolumeInfo& Info);
	static const class FName GetCodeName(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetDestructionPower(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetDuration(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetElectricAttack(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetFireAttack(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetNGPDetailIndex(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetPhysicalAttack(const struct FDynamicDamageVolumeInfo& Info);
	static ELPhysicalDamageType GetPhysicalAttackSubtype(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetSkillHitApplyTickTime(const struct FDynamicDamageVolumeInfo& Info);
	static const class FName GetSkillHitCodeName(const struct FDynamicDamageVolumeInfo& Info);
	static int32 GetToughRecoveryDelayTime(const struct FDynamicDamageVolumeInfo& Info);
	static float GetVolumeRadius(const struct FDynamicDamageVolumeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicDamageVolumeInfoFuncLibrary">();
	}
	static class UDynamicDamageVolumeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicDamageVolumeInfoFuncLibrary>();
	}
};
static_assert(alignof(UDynamicDamageVolumeInfoFuncLibrary) == 0x000008, "Wrong alignment on UDynamicDamageVolumeInfoFuncLibrary");
static_assert(sizeof(UDynamicDamageVolumeInfoFuncLibrary) == 0x000028, "Wrong size on UDynamicDamageVolumeInfoFuncLibrary");

// Class ProjectPContentInfo.LoadingTipInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULoadingTipInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FLoadingTipInfo& Info);
	static ELConditionLoadingType GetConditionLoadingType(const struct FLoadingTipInfo& Info);
	static const class FName GetConditionQuest(const struct FLoadingTipInfo& Info);
	static bool GetResetConditionNewGamePlus(const struct FLoadingTipInfo& Info);
	static const class FName GetTextCodeName(const struct FLoadingTipInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingTipInfoFuncLibrary">();
	}
	static class ULoadingTipInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingTipInfoFuncLibrary>();
	}
};
static_assert(alignof(ULoadingTipInfoFuncLibrary) == 0x000008, "Wrong alignment on ULoadingTipInfoFuncLibrary");
static_assert(sizeof(ULoadingTipInfoFuncLibrary) == 0x000028, "Wrong size on ULoadingTipInfoFuncLibrary");

// Class ProjectPContentInfo.DynamicDamageVolumeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDynamicDamageVolumeInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetAbnormalStatePenaltyBase(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetAcidAttack(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetBlueprintClass(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetBuildUpRecoverIncBase(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetDestructionPower(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetDuration(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetElectricAttack(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetFireAttack(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetPhysicalAttack(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalAttackSubtype(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetSkillHitApplyTickTime(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static const class FName GetSkillHitCodeName(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static float GetVolumeRadius(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static bool IsValid(const struct FDynamicDamageVolumeInfoPtr& Ptr);
	static void IsValidBranch(const struct FDynamicDamageVolumeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicDamageVolumeInfoPtrFuncLibrary">();
	}
	static class UDynamicDamageVolumeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicDamageVolumeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDynamicDamageVolumeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDynamicDamageVolumeInfoPtrFuncLibrary");
static_assert(sizeof(UDynamicDamageVolumeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDynamicDamageVolumeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DynamicDamageVolumeInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UDynamicDamageVolumeInfoAsset final : public UContentInfoAsset
{
public:
	struct FDynamicDamageVolumeInfoDB             ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FDynamicDamageVolumeInfoPtr FindDynamicDamageVolumeInfoByNameBP(class FName CodeName);
	static const TArray<struct FDynamicDamageVolumeInfo> GetDynamicDamageVolumeInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicDamageVolumeInfoAsset">();
	}
	static class UDynamicDamageVolumeInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicDamageVolumeInfoAsset>();
	}
};
static_assert(alignof(UDynamicDamageVolumeInfoAsset) == 0x000010, "Wrong alignment on UDynamicDamageVolumeInfoAsset");
static_assert(sizeof(UDynamicDamageVolumeInfoAsset) == 0x000120, "Wrong size on UDynamicDamageVolumeInfoAsset");
static_assert(offsetof(UDynamicDamageVolumeInfoAsset, ContentInfoDB) == 0x000078, "Member 'UDynamicDamageVolumeInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PCLocomotionListInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPCLocomotionListInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAnimState(const struct FPCLocomotionListInfoPtr& Ptr);
	static const class FName GetMachine(const struct FPCLocomotionListInfoPtr& Ptr);
	static const class FName GetOverrideAnimName(const struct FPCLocomotionListInfoPtr& Ptr);
	static bool IsValid(const struct FPCLocomotionListInfoPtr& Ptr);
	static void IsValidBranch(const struct FPCLocomotionListInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCLocomotionListInfoPtrFuncLibrary">();
	}
	static class UPCLocomotionListInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCLocomotionListInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPCLocomotionListInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPCLocomotionListInfoPtrFuncLibrary");
static_assert(sizeof(UPCLocomotionListInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPCLocomotionListInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ElementalAttackSettingInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UElementalAttackSettingInfoFuncLibrary final : public UObject
{
public:
	static int32 GetDmgNormalizeBase(const struct FElementalAttackSettingInfo& Info);
	static float GetDmgNormalizeExponent(const struct FElementalAttackSettingInfo& Info);
	static int32 GetDmgToBuildupRatio(const struct FElementalAttackSettingInfo& Info);
	static const class FName GetElementType(const struct FElementalAttackSettingInfo& Info);
	static int32 GetMinRatioToBuildup(const struct FElementalAttackSettingInfo& Info);
	static const class FName GetNpcAddAbnormalState(const struct FElementalAttackSettingInfo& Info);
	static const class FName GetPcAddAbnormalState(const struct FElementalAttackSettingInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElementalAttackSettingInfoFuncLibrary">();
	}
	static class UElementalAttackSettingInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElementalAttackSettingInfoFuncLibrary>();
	}
};
static_assert(alignof(UElementalAttackSettingInfoFuncLibrary) == 0x000008, "Wrong alignment on UElementalAttackSettingInfoFuncLibrary");
static_assert(sizeof(UElementalAttackSettingInfoFuncLibrary) == 0x000028, "Wrong size on UElementalAttackSettingInfoFuncLibrary");

// Class ProjectPContentInfo.ElementalAttackSettingInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UElementalAttackSettingInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetDmgNormalizeBase(const struct FElementalAttackSettingInfoPtr& Ptr);
	static float GetDmgNormalizeExponent(const struct FElementalAttackSettingInfoPtr& Ptr);
	static int32 GetDmgToBuildupRatio(const struct FElementalAttackSettingInfoPtr& Ptr);
	static const class FName GetElementType(const struct FElementalAttackSettingInfoPtr& Ptr);
	static int32 GetMinRatioToBuildup(const struct FElementalAttackSettingInfoPtr& Ptr);
	static const class FName GetNpcAddAbnormalState(const struct FElementalAttackSettingInfoPtr& Ptr);
	static const class FName GetPcAddAbnormalState(const struct FElementalAttackSettingInfoPtr& Ptr);
	static bool IsValid(const struct FElementalAttackSettingInfoPtr& Ptr);
	static void IsValidBranch(const struct FElementalAttackSettingInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElementalAttackSettingInfoPtrFuncLibrary">();
	}
	static class UElementalAttackSettingInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElementalAttackSettingInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UElementalAttackSettingInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UElementalAttackSettingInfoPtrFuncLibrary");
static_assert(sizeof(UElementalAttackSettingInfoPtrFuncLibrary) == 0x000028, "Wrong size on UElementalAttackSettingInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NGPKeepConfigInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNGPKeepConfigInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FNGPKeepConfigInfo& Info);
	static bool GetKeepAppearance(const struct FNGPKeepConfigInfo& Info);
	static bool GetKeepErgo(const struct FNGPKeepConfigInfo& Info);
	static const TArray<ELItemFirstCategory> GetKeepItemByItemFirstCategory(const struct FNGPKeepConfigInfo& Info);
	static const TArray<class FString> GetKeepItemSpotList(const struct FNGPKeepConfigInfo& Info);
	static bool GetKeepLevelAndStat(const struct FNGPKeepConfigInfo& Info);
	static const TArray<class FString> GetKeepNPCSpotList(const struct FNGPKeepConfigInfo& Info);
	static bool GetKeepPOganOpenLevel(const struct FNGPKeepConfigInfo& Info);
	static bool GetKeepPOganQuartz(const struct FNGPKeepConfigInfo& Info);
	static const TArray<class FString> GetKeepPropSpotList(const struct FNGPKeepConfigInfo& Info);
	static const TArray<class FName> GetKeepQuest(const struct FNGPKeepConfigInfo& Info);
	static const TArray<class FName> GetKeepSpecialBuffList(const struct FNGPKeepConfigInfo& Info);
	static bool GetKeepTutorialRecord(const struct FNGPKeepConfigInfo& Info);
	static const class FName GetNewGameExecCommonCodeName(const struct FNGPKeepConfigInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGPKeepConfigInfoFuncLibrary">();
	}
	static class UNGPKeepConfigInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGPKeepConfigInfoFuncLibrary>();
	}
};
static_assert(alignof(UNGPKeepConfigInfoFuncLibrary) == 0x000008, "Wrong alignment on UNGPKeepConfigInfoFuncLibrary");
static_assert(sizeof(UNGPKeepConfigInfoFuncLibrary) == 0x000028, "Wrong size on UNGPKeepConfigInfoFuncLibrary");

// Class ProjectPContentInfo.ElementalAttackSettingInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UElementalAttackSettingInfoAsset final : public UContentInfoAsset
{
public:
	struct FElementalAttackSettingInfoDB          ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FElementalAttackSettingInfoPtr FindElementalAttackSettingInfoByNameBP(class FName CodeName);
	static const TArray<struct FElementalAttackSettingInfo> GetElementalAttackSettingInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ElementalAttackSettingInfoAsset">();
	}
	static class UElementalAttackSettingInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElementalAttackSettingInfoAsset>();
	}
};
static_assert(alignof(UElementalAttackSettingInfoAsset) == 0x000010, "Wrong alignment on UElementalAttackSettingInfoAsset");
static_assert(sizeof(UElementalAttackSettingInfoAsset) == 0x000120, "Wrong size on UElementalAttackSettingInfoAsset");
static_assert(offsetof(UElementalAttackSettingInfoAsset, ContentInfoDB) == 0x000078, "Member 'UElementalAttackSettingInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ExiledNpcInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UExiledNpcInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetExiledNpcCodeName(const struct FExiledNpcInfo& Info);
	static int32 GetIndex(const struct FExiledNpcInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExiledNpcInfoFuncLibrary">();
	}
	static class UExiledNpcInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExiledNpcInfoFuncLibrary>();
	}
};
static_assert(alignof(UExiledNpcInfoFuncLibrary) == 0x000008, "Wrong alignment on UExiledNpcInfoFuncLibrary");
static_assert(sizeof(UExiledNpcInfoFuncLibrary) == 0x000028, "Wrong size on UExiledNpcInfoFuncLibrary");

// Class ProjectPContentInfo.MomentConditionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UMomentConditionInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FMomentConditionInfo& Info);
	static EFactionType GetFaction(const struct FMomentConditionInfo& Info);
	static ENPCGradeType GetGrade(const struct FMomentConditionInfo& Info);
	static bool GetHitGroggy(const struct FMomentConditionInfo& Info);
	static bool GetIsBack(const struct FMomentConditionInfo& Info);
	static bool GetIsGroggy(const struct FMomentConditionInfo& Info);
	static bool GetIsGroggyEnable(const struct FMomentConditionInfo& Info);
	static bool GetIsSubSwing(const struct FMomentConditionInfo& Info);
	static bool GetIsSubThrust(const struct FMomentConditionInfo& Info);
	static ELMomentType GetMomentType(const struct FMomentConditionInfo& Info);
	static const class FName GetNpcCodename(const struct FMomentConditionInfo& Info);
	static ELNPCType GetNpcKind(const struct FMomentConditionInfo& Info);
	static int32 GetSkillHitConditionGroup1(const struct FMomentConditionInfo& Info);
	static int32 GetSkillHitConditionGroup2(const struct FMomentConditionInfo& Info);
	static int32 GetSkillHitConditionGroup3(const struct FMomentConditionInfo& Info);
	static int32 GetSkillHitConditionGroup4(const struct FMomentConditionInfo& Info);
	static ELActionCategory GetUseSkillActionCategory(const struct FMomentConditionInfo& Info);
	static const class FName GetUseSkillCodeName(const struct FMomentConditionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MomentConditionInfoFuncLibrary">();
	}
	static class UMomentConditionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMomentConditionInfoFuncLibrary>();
	}
};
static_assert(alignof(UMomentConditionInfoFuncLibrary) == 0x000008, "Wrong alignment on UMomentConditionInfoFuncLibrary");
static_assert(sizeof(UMomentConditionInfoFuncLibrary) == 0x000028, "Wrong size on UMomentConditionInfoFuncLibrary");

// Class ProjectPContentInfo.ExiledNpcInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UExiledNpcInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetExiledNpcCodeName(const struct FExiledNpcInfoPtr& Ptr);
	static int32 GetIndex(const struct FExiledNpcInfoPtr& Ptr);
	static bool IsValid(const struct FExiledNpcInfoPtr& Ptr);
	static void IsValidBranch(const struct FExiledNpcInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExiledNpcInfoPtrFuncLibrary">();
	}
	static class UExiledNpcInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExiledNpcInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UExiledNpcInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UExiledNpcInfoPtrFuncLibrary");
static_assert(sizeof(UExiledNpcInfoPtrFuncLibrary) == 0x000028, "Wrong size on UExiledNpcInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ExiledNpcSpotInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UExiledNpcSpotInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetExiledNpcSpotCodeName(const struct FExiledNpcSpotInfo& Info);
	static int32 GetIndex(const struct FExiledNpcSpotInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExiledNpcSpotInfoFuncLibrary">();
	}
	static class UExiledNpcSpotInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExiledNpcSpotInfoFuncLibrary>();
	}
};
static_assert(alignof(UExiledNpcSpotInfoFuncLibrary) == 0x000008, "Wrong alignment on UExiledNpcSpotInfoFuncLibrary");
static_assert(sizeof(UExiledNpcSpotInfoFuncLibrary) == 0x000028, "Wrong size on UExiledNpcSpotInfoFuncLibrary");

// Class ProjectPContentInfo.LocationInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) ULocationInfoAsset final : public UContentInfoAsset
{
public:
	struct FLocationInfoDB                        ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FLocationInfoPtr FindLocationInfoByNameBP(class FName CodeName);
	static const TArray<struct FLocationInfo> GetLocationInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocationInfoAsset">();
	}
	static class ULocationInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocationInfoAsset>();
	}
};
static_assert(alignof(ULocationInfoAsset) == 0x000010, "Wrong alignment on ULocationInfoAsset");
static_assert(sizeof(ULocationInfoAsset) == 0x000120, "Wrong size on ULocationInfoAsset");
static_assert(offsetof(ULocationInfoAsset, ContentInfoDB) == 0x000078, "Member 'ULocationInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ExiledNpcSpotInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UExiledNpcSpotInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetExiledNpcSpotCodeName(const struct FExiledNpcSpotInfoPtr& Ptr);
	static int32 GetIndex(const struct FExiledNpcSpotInfoPtr& Ptr);
	static bool IsValid(const struct FExiledNpcSpotInfoPtr& Ptr);
	static void IsValidBranch(const struct FExiledNpcSpotInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExiledNpcSpotInfoPtrFuncLibrary">();
	}
	static class UExiledNpcSpotInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExiledNpcSpotInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UExiledNpcSpotInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UExiledNpcSpotInfoPtrFuncLibrary");
static_assert(sizeof(UExiledNpcSpotInfoPtrFuncLibrary) == 0x000028, "Wrong size on UExiledNpcSpotInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ExiledNpcInfoAsset
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) UExiledNpcInfoAsset final : public UContentInfoAsset
{
public:
	struct FExiledNpcInfoDB                       ContentInfoDB;                                     // 0x0078(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FExiledNpcInfo> GetExiledNpcInfoArrayBP();
	static const TArray<struct FExiledNpcSpotInfo> GetExiledNpcSpotInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExiledNpcInfoAsset">();
	}
	static class UExiledNpcInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExiledNpcInfoAsset>();
	}
};
static_assert(alignof(UExiledNpcInfoAsset) == 0x000010, "Wrong alignment on UExiledNpcInfoAsset");
static_assert(sizeof(UExiledNpcInfoAsset) == 0x0000E0, "Wrong size on UExiledNpcInfoAsset");
static_assert(offsetof(UExiledNpcInfoAsset, ContentInfoDB) == 0x000078, "Member 'UExiledNpcInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.MovieResourceInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UMovieResourceInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAfterCommandExec(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetCanSave(const struct FMovieResourceInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetGameProcessPause(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetHideHud(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetLockPlayerAction(const struct FMovieResourceInfoPtr& Ptr);
	static class FString GetMovieResource(const struct FMovieResourceInfoPtr& Ptr);
	static class FString GetMovieResourceFhd(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetNoSkip(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetPauseOnReachedEnd(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetShowHud(const struct FMovieResourceInfoPtr& Ptr);
	static const class FName GetSubtitleCodeName(const struct FMovieResourceInfoPtr& Ptr);
	static bool GetUiFadeout(const struct FMovieResourceInfoPtr& Ptr);
	static bool IsValid(const struct FMovieResourceInfoPtr& Ptr);
	static void IsValidBranch(const struct FMovieResourceInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieResourceInfoPtrFuncLibrary">();
	}
	static class UMovieResourceInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieResourceInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UMovieResourceInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UMovieResourceInfoPtrFuncLibrary");
static_assert(sizeof(UMovieResourceInfoPtrFuncLibrary) == 0x000028, "Wrong size on UMovieResourceInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FallingHeightDamageInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingHeightDamageInfoFuncLibrary final : public UObject
{
public:
	static int32 GetFallHeightDmgRatio(const struct FFallingHeightDamageInfo& Info);
	static int32 GetFallingHeight(const struct FFallingHeightDamageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingHeightDamageInfoFuncLibrary">();
	}
	static class UFallingHeightDamageInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingHeightDamageInfoFuncLibrary>();
	}
};
static_assert(alignof(UFallingHeightDamageInfoFuncLibrary) == 0x000008, "Wrong alignment on UFallingHeightDamageInfoFuncLibrary");
static_assert(sizeof(UFallingHeightDamageInfoFuncLibrary) == 0x000028, "Wrong size on UFallingHeightDamageInfoFuncLibrary");

// Class ProjectPContentInfo.FallingHeightDamageInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingHeightDamageInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetFallHeightDmgRatio(const struct FFallingHeightDamageInfoPtr& Ptr);
	static int32 GetFallingHeight(const struct FFallingHeightDamageInfoPtr& Ptr);
	static bool IsValid(const struct FFallingHeightDamageInfoPtr& Ptr);
	static void IsValidBranch(const struct FFallingHeightDamageInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingHeightDamageInfoPtrFuncLibrary">();
	}
	static class UFallingHeightDamageInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingHeightDamageInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFallingHeightDamageInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFallingHeightDamageInfoPtrFuncLibrary");
static_assert(sizeof(UFallingHeightDamageInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFallingHeightDamageInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NPCSkillStandbyInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCSkillStandbyInfoPtrFuncLibrary final : public UObject
{
public:
	static class FString GetSkillId(const struct FNPCSkillStandbyInfoPtr& Ptr);
	static int32 GetSkillRate(const struct FNPCSkillStandbyInfoPtr& Ptr);
	static bool IsValid(const struct FNPCSkillStandbyInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCSkillStandbyInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSkillStandbyInfoPtrFuncLibrary">();
	}
	static class UNPCSkillStandbyInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSkillStandbyInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCSkillStandbyInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCSkillStandbyInfoPtrFuncLibrary");
static_assert(sizeof(UNPCSkillStandbyInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCSkillStandbyInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FallingHeightDamageInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UFallingHeightDamageInfoAsset final : public UContentInfoAsset
{
public:
	struct FFallingHeightDamageInfoDB             ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FFallingHeightDamageInfo> GetFallingHeightDamageInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingHeightDamageInfoAsset">();
	}
	static class UFallingHeightDamageInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingHeightDamageInfoAsset>();
	}
};
static_assert(alignof(UFallingHeightDamageInfoAsset) == 0x000010, "Wrong alignment on UFallingHeightDamageInfoAsset");
static_assert(sizeof(UFallingHeightDamageInfoAsset) == 0x0000D0, "Wrong size on UFallingHeightDamageInfoAsset");
static_assert(offsetof(UFallingHeightDamageInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFallingHeightDamageInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.FallingMotionTransitionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingMotionTransitionInfoFuncLibrary final : public UObject
{
public:
	static ELActionCategory GetConditionActionCategory(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetConditionActionState(const struct FFallingMotionTransitionInfo& Info);
	static bool GetConditionBackHit(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetConditionCommonActionMontage(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetFallingAction(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetLandDieHeavy(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetLandDieLight(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetLandHeavy(const struct FFallingMotionTransitionInfo& Info);
	static const class FName GetLandLight(const struct FFallingMotionTransitionInfo& Info);
	static float GetLeastLandingHeight(const struct FFallingMotionTransitionInfo& Info);
	static int32 GetPriority(const struct FFallingMotionTransitionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingMotionTransitionInfoFuncLibrary">();
	}
	static class UFallingMotionTransitionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingMotionTransitionInfoFuncLibrary>();
	}
};
static_assert(alignof(UFallingMotionTransitionInfoFuncLibrary) == 0x000008, "Wrong alignment on UFallingMotionTransitionInfoFuncLibrary");
static_assert(sizeof(UFallingMotionTransitionInfoFuncLibrary) == 0x000028, "Wrong size on UFallingMotionTransitionInfoFuncLibrary");

// Class ProjectPContentInfo.NGPContentChangeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNGPContentChangeInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttackMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetAbnormalStatePenaltyBaseMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetAcidAttackMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetAcidDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetAcidRateDotReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetAcidReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetBreakDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetBuildUpRecoverIncBaseMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetCheckSkillUseCountAdd(const struct FNGPContentChangeInfo& Info);
	static const class FName GetCodeName(const struct FNGPContentChangeInfo& Info);
	static int32 GetContaminationDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetCurseDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetDestructionPowerMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetDurabilityMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetElectricAttackMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetElectricDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetElectricRateDotReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetElectricReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetEtcRateDotReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetExpMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetFireAttackMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetFireDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetFireRateDotReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetFireReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGroggyEnableResetRestoreMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGroggyEnableTimeMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGroggyMaintainTimeMaxMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGroggyMaintainTimeMinMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGroggyPointMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGroggyPointRestoreBaseMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGuardSharpnessAttackMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetGuardStaminaDamageMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetHealthPowerMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetImpactDebuffResistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetMaxStaminaMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetNGPDetailIndex(const struct FNGPContentChangeInfo& Info);
	static int32 GetNGPRound(const struct FNGPContentChangeInfo& Info);
	static int32 GetPhysicalPierceReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetPhysicalPowerMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetPhysicalSlashReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetPhysicalStrikeReduceMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetRegainhpGainRatioMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetRegainhpHealRatioMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetRegainhpMaxExistMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetRestoreStaminaPerSecMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetToughMul(const struct FNGPContentChangeInfo& Info);
	static int32 GetToughRestoreBaseMul(const struct FNGPContentChangeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGPContentChangeInfoFuncLibrary">();
	}
	static class UNGPContentChangeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGPContentChangeInfoFuncLibrary>();
	}
};
static_assert(alignof(UNGPContentChangeInfoFuncLibrary) == 0x000008, "Wrong alignment on UNGPContentChangeInfoFuncLibrary");
static_assert(sizeof(UNGPContentChangeInfoFuncLibrary) == 0x000028, "Wrong size on UNGPContentChangeInfoFuncLibrary");

// Class ProjectPContentInfo.FallingMotionTransitionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingMotionTransitionInfoPtrFuncLibrary final : public UObject
{
public:
	static ELActionCategory GetConditionActionCategory(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetConditionActionState(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static bool GetConditionBackHit(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetConditionCommonActionMontage(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetFallingAction(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetLandDieHeavy(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetLandDieLight(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetLandHeavy(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static const class FName GetLandLight(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static float GetLeastLandingHeight(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static int32 GetPriority(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static bool IsValid(const struct FFallingMotionTransitionInfoPtr& Ptr);
	static void IsValidBranch(const struct FFallingMotionTransitionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingMotionTransitionInfoPtrFuncLibrary">();
	}
	static class UFallingMotionTransitionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingMotionTransitionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFallingMotionTransitionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFallingMotionTransitionInfoPtrFuncLibrary");
static_assert(sizeof(UFallingMotionTransitionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFallingMotionTransitionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FallingMotionTransitionInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UFallingMotionTransitionInfoAsset final : public UContentInfoAsset
{
public:
	struct FFallingMotionTransitionInfoDB         ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FFallingMotionTransitionInfo> GetFallingMotionTransitionInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingMotionTransitionInfoAsset">();
	}
	static class UFallingMotionTransitionInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingMotionTransitionInfoAsset>();
	}
};
static_assert(alignof(UFallingMotionTransitionInfoAsset) == 0x000010, "Wrong alignment on UFallingMotionTransitionInfoAsset");
static_assert(sizeof(UFallingMotionTransitionInfoAsset) == 0x0000D0, "Wrong size on UFallingMotionTransitionInfoAsset");
static_assert(offsetof(UFallingMotionTransitionInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFallingMotionTransitionInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.MomentConditionInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UMomentConditionInfoAsset final : public UContentInfoAsset
{
public:
	struct FMomentConditionInfoDB                 ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FMomentConditionInfo> GetMomentConditionInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MomentConditionInfoAsset">();
	}
	static class UMomentConditionInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMomentConditionInfoAsset>();
	}
};
static_assert(alignof(UMomentConditionInfoAsset) == 0x000010, "Wrong alignment on UMomentConditionInfoAsset");
static_assert(sizeof(UMomentConditionInfoAsset) == 0x0000D0, "Wrong size on UMomentConditionInfoAsset");
static_assert(offsetof(UMomentConditionInfoAsset, ContentInfoDB) == 0x000078, "Member 'UMomentConditionInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.FallingSurfaceDamageInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingSurfaceDamageInfoFuncLibrary final : public UObject
{
public:
	static int32 GetFallSurfaceDmgRatio(const struct FFallingSurfaceDamageInfo& Info);
	static ELPhysicalSurfaceType GetSurfaceType(const struct FFallingSurfaceDamageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingSurfaceDamageInfoFuncLibrary">();
	}
	static class UFallingSurfaceDamageInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingSurfaceDamageInfoFuncLibrary>();
	}
};
static_assert(alignof(UFallingSurfaceDamageInfoFuncLibrary) == 0x000008, "Wrong alignment on UFallingSurfaceDamageInfoFuncLibrary");
static_assert(sizeof(UFallingSurfaceDamageInfoFuncLibrary) == 0x000028, "Wrong size on UFallingSurfaceDamageInfoFuncLibrary");

// Class ProjectPContentInfo.FallingSurfaceDamageInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingSurfaceDamageInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetFallSurfaceDmgRatio(const struct FFallingSurfaceDamageInfoPtr& Ptr);
	static ELPhysicalSurfaceType GetSurfaceType(const struct FFallingSurfaceDamageInfoPtr& Ptr);
	static bool IsValid(const struct FFallingSurfaceDamageInfoPtr& Ptr);
	static void IsValidBranch(const struct FFallingSurfaceDamageInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingSurfaceDamageInfoPtrFuncLibrary">();
	}
	static class UFallingSurfaceDamageInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingSurfaceDamageInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFallingSurfaceDamageInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFallingSurfaceDamageInfoPtrFuncLibrary");
static_assert(sizeof(UFallingSurfaceDamageInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFallingSurfaceDamageInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemCommonInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemCommonInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetBattleItem(const struct FItemCommonInfoPtr& Ptr);
	static bool GetCanAbandonment(const struct FItemCommonInfoPtr& Ptr);
	static bool GetCanKeep(const struct FItemCommonInfoPtr& Ptr);
	static bool GetCanSelling(const struct FItemCommonInfoPtr& Ptr);
	static bool GetCanStackInventory(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetChangeCodeName(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetEquipGroupId(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetEquipSpecialbuffCodeName(const struct FItemCommonInfoPtr& Ptr);
	static ELItemFirstCategory GetFirstCategory(const struct FItemCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetHeroicWeaponImageResource(const struct FItemCommonInfoPtr& Ptr);
	static bool GetHumanityItem(const struct FItemCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImage2Resource(const struct FItemCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImage3Resource(const struct FItemCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImage4Resource(const struct FItemCommonInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetInfoNoticeCount(const struct FItemCommonInfoPtr& Ptr);
	static bool GetIsMinimumRequirements(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetItemCostumeCodename(const struct FItemCommonInfoPtr& Ptr);
	static class FString GetLocalTextItemName(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetLocalTextItemNameCn(const struct FItemCommonInfoPtr& Ptr);
	static class FText GetLocalTextItemNameLocalize(const struct FItemCommonInfoPtr& Ptr);
	static class FString GetLocalTextTooltip1(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetLocalTextTooltip1Cn(const struct FItemCommonInfoPtr& Ptr);
	static class FText GetLocalTextTooltip1Localize(const struct FItemCommonInfoPtr& Ptr);
	static class FString GetLocalTextTooltip2(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetLocalTextTooltip2Cn(const struct FItemCommonInfoPtr& Ptr);
	static class FText GetLocalTextTooltip2Localize(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetMaxStackCount(const struct FItemCommonInfoPtr& Ptr);
	static bool GetNGPDelete(const struct FItemCommonInfoPtr& Ptr);
	static bool GetNGPKeep(const struct FItemCommonInfoPtr& Ptr);
	static bool GetNGPOnlyOne(const struct FItemCommonInfoPtr& Ptr);
	static bool GetQuickslotEquipment(const struct FItemCommonInfoPtr& Ptr);
	static ELItemSecondCategory GetSecondCategory(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetSellingPrice(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetShowTooltipUnusableNow(const struct FItemCommonInfoPtr& Ptr);
	static class FString GetSimpleTooltip(const struct FItemCommonInfoPtr& Ptr);
	static const class FName GetSimpleTooltipCn(const struct FItemCommonInfoPtr& Ptr);
	static class FText GetSimpleTooltipLocalize(const struct FItemCommonInfoPtr& Ptr);
	static ELTooltipIconType GetSimpleTooltipType(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetSortPriority(const struct FItemCommonInfoPtr& Ptr);
	static bool GetUseChangecodename(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetValueGrade(const struct FItemCommonInfoPtr& Ptr);
	static int32 GetWeight(const struct FItemCommonInfoPtr& Ptr);
	static bool IsValid(const struct FItemCommonInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemCommonInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCommonInfoPtrFuncLibrary">();
	}
	static class UItemCommonInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCommonInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemCommonInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemCommonInfoPtrFuncLibrary");
static_assert(sizeof(UItemCommonInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemCommonInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FallingSurfaceDamageInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UFallingSurfaceDamageInfoAsset final : public UContentInfoAsset
{
public:
	struct FFallingSurfaceDamageInfoDB            ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FFallingSurfaceDamageInfo> GetFallingSurfaceDamageInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingSurfaceDamageInfoAsset">();
	}
	static class UFallingSurfaceDamageInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingSurfaceDamageInfoAsset>();
	}
};
static_assert(alignof(UFallingSurfaceDamageInfoAsset) == 0x000010, "Wrong alignment on UFallingSurfaceDamageInfoAsset");
static_assert(sizeof(UFallingSurfaceDamageInfoAsset) == 0x0000D0, "Wrong size on UFallingSurfaceDamageInfoAsset");
static_assert(offsetof(UFallingSurfaceDamageInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFallingSurfaceDamageInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.FallingWeightDamageInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingWeightDamageInfoFuncLibrary final : public UObject
{
public:
	static int32 GetFallWeightDmgRatio(const struct FFallingWeightDamageInfo& Info);
	static int32 GetWeightRate(const struct FFallingWeightDamageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingWeightDamageInfoFuncLibrary">();
	}
	static class UFallingWeightDamageInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingWeightDamageInfoFuncLibrary>();
	}
};
static_assert(alignof(UFallingWeightDamageInfoFuncLibrary) == 0x000008, "Wrong alignment on UFallingWeightDamageInfoFuncLibrary");
static_assert(sizeof(UFallingWeightDamageInfoFuncLibrary) == 0x000028, "Wrong size on UFallingWeightDamageInfoFuncLibrary");

// Class ProjectPContentInfo.NPCStatInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCStatInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalFirePoint(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAbnormalStateBuildUpAttack(const struct FNPCStatInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAbnormalStatePenaltyBase(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAcidAttack(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAcidDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAcidDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAcidGroggyReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAcidRateDotReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAcidReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetAttackSpeedRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetBreakDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetBuildUpRecoverIncBase(const struct FNPCStatInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetContaminationDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetCriticalDamageRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetCriticalRate(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetCriticalResistRate(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetCurseDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionAcidReduce(const struct FNPCStatInfoPtr& Ptr);
	static float GetDestructionDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionElectricReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionFireReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionPhysicalReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionPierceReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionPower(const struct FNPCStatInfoPtr& Ptr);
	static float GetDestructionReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionSlashReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetDestructionStrikeReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetElectricAttack(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetElectricDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetElectricDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetElectricGroggyReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetElectricRateDotReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetElectricReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetEtcRateDotReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetExp(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetFireAttack(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetFireDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetFireDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetFireGroggyReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetFireRateDotReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetFireReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggyAttack(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggyPierceReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggyPoint(const struct FNPCStatInfoPtr& Ptr);
	static float GetGroggyPointResetDelay(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggyPointRestoreBase(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggyPointRestoreStopTime(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggySlashReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGroggyStrikeReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardAciddamageReductionRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardElectricdamageReductionRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardFiredamageReductionRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardKnockbackDurationReductionRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardPenetrationPowerBase(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardPhysicaldamageReductionRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardPoint(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardSharpnessAttack(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetGuardStaminaDamage(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetHealthPower(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetImpactDebuffResist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetMaxStamina(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FNPCStatInfoPtr& Ptr);
	static const class FName GetNpcGaugeGrowth(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalGroggyReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalPierceDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalPierceReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalPower(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalSlashDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalSlashReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalStrikeDefence(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetPhysicalStrikeReduce(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRegainhpGainRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRegainhpHealIncreaseRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRegainhpHealRatio(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRegainhpHealTime(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRegainhpMaxExist(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRestoreStaminaPerSec(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetRigidity(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetSpecialhitGroggyReduction(const struct FNPCStatInfoPtr& Ptr);
	static float GetStiffenPlayrateAttacker(const struct FNPCStatInfoPtr& Ptr);
	static float GetStiffenPlayrateDefender(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetTough(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetToughAttackPowerBase(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetToughDefencePowerBase(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayReduction(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetToughRestoreBase(const struct FNPCStatInfoPtr& Ptr);
	static int32 GetWalkRunSpeedRatio(const struct FNPCStatInfoPtr& Ptr);
	static bool IsValid(const struct FNPCStatInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCStatInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCStatInfoPtrFuncLibrary">();
	}
	static class UNPCStatInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCStatInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCStatInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCStatInfoPtrFuncLibrary");
static_assert(sizeof(UNPCStatInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCStatInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FallingWeightDamageInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFallingWeightDamageInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetFallWeightDmgRatio(const struct FFallingWeightDamageInfoPtr& Ptr);
	static int32 GetWeightRate(const struct FFallingWeightDamageInfoPtr& Ptr);
	static bool IsValid(const struct FFallingWeightDamageInfoPtr& Ptr);
	static void IsValidBranch(const struct FFallingWeightDamageInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingWeightDamageInfoPtrFuncLibrary">();
	}
	static class UFallingWeightDamageInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingWeightDamageInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFallingWeightDamageInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFallingWeightDamageInfoPtrFuncLibrary");
static_assert(sizeof(UFallingWeightDamageInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFallingWeightDamageInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FallingWeightDamageInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UFallingWeightDamageInfoAsset final : public UContentInfoAsset
{
public:
	struct FFallingWeightDamageInfoDB             ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FFallingWeightDamageInfo> GetFallingWeightDamageInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallingWeightDamageInfoAsset">();
	}
	static class UFallingWeightDamageInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallingWeightDamageInfoAsset>();
	}
};
static_assert(alignof(UFallingWeightDamageInfoAsset) == 0x000010, "Wrong alignment on UFallingWeightDamageInfoAsset");
static_assert(sizeof(UFallingWeightDamageInfoAsset) == 0x0000D0, "Wrong size on UFallingWeightDamageInfoAsset");
static_assert(offsetof(UFallingWeightDamageInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFallingWeightDamageInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.CorrectionWeaponFirstStatInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCorrectionWeaponFirstStatInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static const class FName GetDowngradeCodename(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static ELWeaponCorrectionPhysicalGrade GetGrade(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel1(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel10(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel100(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel11(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel12(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel13(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel14(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel15(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel16(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel17(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel18(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel19(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel2(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel20(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel21(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel22(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel23(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel24(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel25(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel26(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel27(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel28(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel29(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel3(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel30(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel31(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel32(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel33(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel34(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel35(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel36(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel37(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel38(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel39(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel4(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel40(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel41(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel42(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel43(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel44(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel45(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel46(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel47(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel48(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel49(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel5(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel50(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel51(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel52(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel53(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel54(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel55(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel56(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel57(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel58(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel59(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel6(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel60(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel61(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel62(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel63(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel64(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel65(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel66(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel67(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel68(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel69(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel7(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel70(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel71(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel72(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel73(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel74(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel75(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel76(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel77(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel78(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel79(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel8(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel80(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel81(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel82(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel83(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel84(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel85(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel86(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel87(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel88(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel89(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel9(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel90(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel91(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel92(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel93(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel94(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel95(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel96(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel97(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel98(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static int32 GetStatLevel99(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static const class FName GetUpgradeCodename(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static bool IsValid(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr);
	static void IsValidBranch(const struct FCorrectionWeaponFirstStatInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CorrectionWeaponFirstStatInfoPtrFuncLibrary">();
	}
	static class UCorrectionWeaponFirstStatInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCorrectionWeaponFirstStatInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UCorrectionWeaponFirstStatInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UCorrectionWeaponFirstStatInfoPtrFuncLibrary");
static_assert(sizeof(UCorrectionWeaponFirstStatInfoPtrFuncLibrary) == 0x000028, "Wrong size on UCorrectionWeaponFirstStatInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FlagFilterInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFlagFilterInfoFuncLibrary final : public UObject
{
public:
	static ELBooleanOrIgnore GetActing(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetAllowDashHeavy(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetAllowDashLight(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetAllowinputDoubledash(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetAllowinputGetupdashB(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetAllowinputGetupdashF(const struct FFlagFilterInfo& Info);
	static const class FName GetCodeName(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetDashDisable(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetDashSuperheavy(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetFalling(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetFrenzy(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetGetUpDashDisable(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetJumping(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetLeverNeutral(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetLockOn(const struct FFlagFilterInfo& Info);
	static int32 GetPriority(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetSprinting(const struct FFlagFilterInfo& Info);
	static ELBooleanOrIgnore GetWeaponTransform(const struct FFlagFilterInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagFilterInfoFuncLibrary">();
	}
	static class UFlagFilterInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagFilterInfoFuncLibrary>();
	}
};
static_assert(alignof(UFlagFilterInfoFuncLibrary) == 0x000008, "Wrong alignment on UFlagFilterInfoFuncLibrary");
static_assert(sizeof(UFlagFilterInfoFuncLibrary) == 0x000028, "Wrong size on UFlagFilterInfoFuncLibrary");

// Class ProjectPContentInfo.FlagFilterInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFlagFilterInfoPtrFuncLibrary final : public UObject
{
public:
	static ELBooleanOrIgnore GetActing(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetAllowDashHeavy(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetAllowDashLight(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetAllowinputDoubledash(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetAllowinputGetupdashB(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetAllowinputGetupdashF(const struct FFlagFilterInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetDashDisable(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetDashSuperheavy(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetFalling(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetFrenzy(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetGetUpDashDisable(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetJumping(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetLeverNeutral(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetLockOn(const struct FFlagFilterInfoPtr& Ptr);
	static int32 GetPriority(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetSprinting(const struct FFlagFilterInfoPtr& Ptr);
	static ELBooleanOrIgnore GetWeaponTransform(const struct FFlagFilterInfoPtr& Ptr);
	static bool IsValid(const struct FFlagFilterInfoPtr& Ptr);
	static void IsValidBranch(const struct FFlagFilterInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagFilterInfoPtrFuncLibrary">();
	}
	static class UFlagFilterInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagFilterInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFlagFilterInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFlagFilterInfoPtrFuncLibrary");
static_assert(sizeof(UFlagFilterInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFlagFilterInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemDropInfoAsset
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) UItemDropInfoAsset final : public UContentInfoAsset
{
public:
	struct FItemDropInfoDB                        ContentInfoDB;                                     // 0x0078(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPackageConfigureInfo> GetPackageConfigureInfoArrayBP();
	static const TArray<struct FPackageSettingInfo> GetPackageSettingInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDropInfoAsset">();
	}
	static class UItemDropInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDropInfoAsset>();
	}
};
static_assert(alignof(UItemDropInfoAsset) == 0x000010, "Wrong alignment on UItemDropInfoAsset");
static_assert(sizeof(UItemDropInfoAsset) == 0x0000E0, "Wrong size on UItemDropInfoAsset");
static_assert(offsetof(UItemDropInfoAsset, ContentInfoDB) == 0x000078, "Member 'UItemDropInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.FlagFilterInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UFlagFilterInfoAsset final : public UContentInfoAsset
{
public:
	struct FFlagFilterInfoDB                      ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FFlagFilterInfoPtr FindFlagFilterInfoByNameBP(class FName CodeName);
	static const TArray<struct FFlagFilterInfo> GetFlagFilterInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagFilterInfoAsset">();
	}
	static class UFlagFilterInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagFilterInfoAsset>();
	}
};
static_assert(alignof(UFlagFilterInfoAsset) == 0x000010, "Wrong alignment on UFlagFilterInfoAsset");
static_assert(sizeof(UFlagFilterInfoAsset) == 0x000120, "Wrong size on UFlagFilterInfoAsset");
static_assert(offsetof(UFlagFilterInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFlagFilterInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.FootstepInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFootstepInfoFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetEffect(const struct FFootstepInfo& Info);
	static const class FName GetEventName(const struct FFootstepInfo& Info);
	static ELPhysicalSurfaceType GetMaterialType(const struct FFootstepInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSound1(const struct FFootstepInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSound2(const struct FFootstepInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepInfoFuncLibrary">();
	}
	static class UFootstepInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepInfoFuncLibrary>();
	}
};
static_assert(alignof(UFootstepInfoFuncLibrary) == 0x000008, "Wrong alignment on UFootstepInfoFuncLibrary");
static_assert(sizeof(UFootstepInfoFuncLibrary) == 0x000028, "Wrong size on UFootstepInfoFuncLibrary");

// Class ProjectPContentInfo.NpcGaugeGrowthInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNpcGaugeGrowthInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAcidDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetAcidDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetBreakDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetBreakDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetContaminationDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetContaminationDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetCurseDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetCurseDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetElectricDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetElectricDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetFireDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetFireDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetFullFillNum(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetGroggyMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetImpactDebuffResistMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetImpactDurationMulsud(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetNGPRound(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static int32 GetToughMuladd(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static bool IsValid(const struct FNpcGaugeGrowthInfoPtr& Ptr);
	static void IsValidBranch(const struct FNpcGaugeGrowthInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcGaugeGrowthInfoPtrFuncLibrary">();
	}
	static class UNpcGaugeGrowthInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcGaugeGrowthInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNpcGaugeGrowthInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNpcGaugeGrowthInfoPtrFuncLibrary");
static_assert(sizeof(UNpcGaugeGrowthInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNpcGaugeGrowthInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FootstepInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFootstepInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetEffect(const struct FFootstepInfoPtr& Ptr);
	static const class FName GetEventName(const struct FFootstepInfoPtr& Ptr);
	static ELPhysicalSurfaceType GetMaterialType(const struct FFootstepInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSound1(const struct FFootstepInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSound2(const struct FFootstepInfoPtr& Ptr);
	static bool IsValid(const struct FFootstepInfoPtr& Ptr);
	static void IsValidBranch(const struct FFootstepInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepInfoPtrFuncLibrary">();
	}
	static class UFootstepInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFootstepInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFootstepInfoPtrFuncLibrary");
static_assert(sizeof(UFootstepInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFootstepInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FootstepInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UFootstepInfoAsset final : public UContentInfoAsset
{
public:
	struct FFootstepInfoDB                        ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FFootstepInfo> GetFootstepInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepInfoAsset">();
	}
	static class UFootstepInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepInfoAsset>();
	}
};
static_assert(alignof(UFootstepInfoAsset) == 0x000010, "Wrong alignment on UFootstepInfoAsset");
static_assert(sizeof(UFootstepInfoAsset) == 0x0000D0, "Wrong size on UFootstepInfoAsset");
static_assert(offsetof(UFootstepInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFootstepInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SpawnControllerInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpawnControllerInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FSpawnControllerInfo& Info);
	static ELLightScenarioType GetSpawnCondAMPM(const struct FSpawnControllerInfo& Info);
	static const class FName GetSpawnCondCompleteQuest(const struct FSpawnControllerInfo& Info);
	static ELQuestState GetSpawnCondCompleteQuestResult(const struct FSpawnControllerInfo& Info);
	static const class FName GetSpawnCondCustom(const struct FSpawnControllerInfo& Info);
	static ELWeatherType GetSpawnCondDryWet(const struct FSpawnControllerInfo& Info);
	static const class FName GetSpawnCondHaveitem(const struct FSpawnControllerInfo& Info);
	static const class FName GetSpawnCondHaveQuest(const struct FSpawnControllerInfo& Info);
	static int32 GetSpawnCondHaveQuestStep(const struct FSpawnControllerInfo& Info);
	static int32 GetSpawnCondHumanPoint(const struct FSpawnControllerInfo& Info);
	static ELTimeZoneType GetSpawnCondTimezone(const struct FSpawnControllerInfo& Info);
	static const class FName GetSpawnCondWeather(const struct FSpawnControllerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnControllerInfoFuncLibrary">();
	}
	static class USpawnControllerInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnControllerInfoFuncLibrary>();
	}
};
static_assert(alignof(USpawnControllerInfoFuncLibrary) == 0x000008, "Wrong alignment on USpawnControllerInfoFuncLibrary");
static_assert(sizeof(USpawnControllerInfoFuncLibrary) == 0x000028, "Wrong size on USpawnControllerInfoFuncLibrary");

// Class ProjectPContentInfo.FxInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFxInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAttribute(const struct FFxInfo& Info);
	static const TSoftObjectPtr<class UObject> GetEffect(const struct FFxInfo& Info);
	static const class FName GetEventName(const struct FFxInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSound(const struct FFxInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FxInfoFuncLibrary">();
	}
	static class UFxInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFxInfoFuncLibrary>();
	}
};
static_assert(alignof(UFxInfoFuncLibrary) == 0x000008, "Wrong alignment on UFxInfoFuncLibrary");
static_assert(sizeof(UFxInfoFuncLibrary) == 0x000028, "Wrong size on UFxInfoFuncLibrary");

// Class ProjectPContentInfo.FxInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFxInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAttribute(const struct FFxInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetEffect(const struct FFxInfoPtr& Ptr);
	static const class FName GetEventName(const struct FFxInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSound(const struct FFxInfoPtr& Ptr);
	static bool IsValid(const struct FFxInfoPtr& Ptr);
	static void IsValidBranch(const struct FFxInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FxInfoPtrFuncLibrary">();
	}
	static class UFxInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFxInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UFxInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UFxInfoPtrFuncLibrary");
static_assert(sizeof(UFxInfoPtrFuncLibrary) == 0x000028, "Wrong size on UFxInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NPCPartsInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCPartsInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetAttackerRepulseEnable(const struct FNPCPartsInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNPCPartsInfoPtr& Ptr);
	static bool GetDestroyedOnSpawn(const struct FNPCPartsInfoPtr& Ptr);
	static bool GetEnableOnSpawn(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetGroggyReduce(const struct FNPCPartsInfoPtr& Ptr);
	static ELNpcPartsHitDirectionType GetHitDirectionType(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetHitRangeAngleEnd(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetHitRangeAngleStart(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetHitRepulseLevelPierce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetHitRepulseLevelSlash(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetHitRepulseLevelStrike(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsAcidReduce(const struct FNPCPartsInfoPtr& Ptr);
	static const class FName GetPartsBpCodeName(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsBreakActionParalyze(const struct FNPCPartsInfoPtr& Ptr);
	static bool GetPartsDamageToMonsterUse(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsDestructionIndex(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsDropItemLimit(const struct FNPCPartsInfoPtr& Ptr);
	static const class FName GetPartsDropItemOnDestroy(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsDropItemProbility(const struct FNPCPartsInfoPtr& Ptr);
	static bool GetPartsDropItemRedropUse(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsElectricReduce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsFireReduce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsHpRatio(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsPhysicalPierceReduce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsPhysicalSlashReduce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsPhysicalStrikeReduce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetPartsRigidity(const struct FNPCPartsInfoPtr& Ptr);
	static const class FName GetPartsSkillCodeNameOnDestroy(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetRegainReduce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetSharpnessMonsterDamageRatioPierce(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetSharpnessMonsterDamageRatioSlash(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetSharpnessMonsterDamageRatioStrike(const struct FNPCPartsInfoPtr& Ptr);
	static int32 GetToughReduce(const struct FNPCPartsInfoPtr& Ptr);
	static ELElementDamageType GetWeakElement(const struct FNPCPartsInfoPtr& Ptr);
	static const class FName GetWeakElementSkillCodeName(const struct FNPCPartsInfoPtr& Ptr);
	static bool IsValid(const struct FNPCPartsInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCPartsInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCPartsInfoPtrFuncLibrary">();
	}
	static class UNPCPartsInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCPartsInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCPartsInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCPartsInfoPtrFuncLibrary");
static_assert(sizeof(UNPCPartsInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCPartsInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FxInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UFxInfoAsset final : public UContentInfoAsset
{
public:
	struct FFxInfoDB                              ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FFxInfo> GetFxInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FxInfoAsset">();
	}
	static class UFxInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFxInfoAsset>();
	}
};
static_assert(alignof(UFxInfoAsset) == 0x000010, "Wrong alignment on UFxInfoAsset");
static_assert(sizeof(UFxInfoAsset) == 0x0000D0, "Wrong size on UFxInfoAsset");
static_assert(offsetof(UFxInfoAsset, ContentInfoDB) == 0x000078, "Member 'UFxInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.GameStringInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameStringInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FGameStringInfo& Info);
	static class FString GetGameString(const struct FGameStringInfo& Info);
	static const class FName GetGameStringCn(const struct FGameStringInfo& Info);
	static class FText GetGameStringLocalize(const struct FGameStringInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStringInfoFuncLibrary">();
	}
	static class UGameStringInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStringInfoFuncLibrary>();
	}
};
static_assert(alignof(UGameStringInfoFuncLibrary) == 0x000008, "Wrong alignment on UGameStringInfoFuncLibrary");
static_assert(sizeof(UGameStringInfoFuncLibrary) == 0x000028, "Wrong size on UGameStringInfoFuncLibrary");

// Class ProjectPContentInfo.NPCSkillLinkInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCSkillLinkInfoPtrFuncLibrary final : public UObject
{
public:
	static ELElementDamageType GetBeHitByElementDamageType(const struct FNPCSkillLinkInfoPtr& Ptr);
	static ELPhysicalDamageType GetBeHitByPhysicalDamageType(const struct FNPCSkillLinkInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetCollideCeilingHeight(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionBeHit(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionCollideCeiling(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionCooltime(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionDefenceSkill(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionHitTarget(const struct FNPCSkillLinkInfoPtr& Ptr);
	static const class FName GetConditionPartNeeded(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionPercent(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetConditionRange(const struct FNPCSkillLinkInfoPtr& Ptr);
	static ELAIDamageType GetHitDamageType(const struct FNPCSkillLinkInfoPtr& Ptr);
	static class FString GetHitTargetActionEventAlias(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool GetLinkSkillUseCooltime(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetPercentValue(const struct FNPCSkillLinkInfoPtr& Ptr);
	static int32 GetPriority(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetSkillDistHeight(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetSkillDistMax(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetSkillDistMin(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetSkillRangeAngleEnd(const struct FNPCSkillLinkInfoPtr& Ptr);
	static float GetSkillRangeAngleStart(const struct FNPCSkillLinkInfoPtr& Ptr);
	static ELAIRangeCheckType GetSkillrangeChecktype(const struct FNPCSkillLinkInfoPtr& Ptr);
	static const class FName GetUseSkillId(const struct FNPCSkillLinkInfoPtr& Ptr);
	static bool IsValid(const struct FNPCSkillLinkInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCSkillLinkInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSkillLinkInfoPtrFuncLibrary">();
	}
	static class UNPCSkillLinkInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSkillLinkInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCSkillLinkInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCSkillLinkInfoPtrFuncLibrary");
static_assert(sizeof(UNPCSkillLinkInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCSkillLinkInfoPtrFuncLibrary");

// Class ProjectPContentInfo.GameStringInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameStringInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FGameStringInfoPtr& Ptr);
	static class FString GetGameString(const struct FGameStringInfoPtr& Ptr);
	static const class FName GetGameStringCn(const struct FGameStringInfoPtr& Ptr);
	static class FText GetGameStringLocalize(const struct FGameStringInfoPtr& Ptr);
	static bool IsValid(const struct FGameStringInfoPtr& Ptr);
	static void IsValidBranch(const struct FGameStringInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStringInfoPtrFuncLibrary">();
	}
	static class UGameStringInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStringInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UGameStringInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UGameStringInfoPtrFuncLibrary");
static_assert(sizeof(UGameStringInfoPtrFuncLibrary) == 0x000028, "Wrong size on UGameStringInfoPtrFuncLibrary");

// Class ProjectPContentInfo.GameStringInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UGameStringInfoAsset final : public UContentInfoAsset
{
public:
	struct FGameStringInfoDB                      ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGameStringInfoPtr FindGameStringInfoByNameBP(class FName CodeName);
	static const TArray<struct FGameStringInfo> GetGameStringInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStringInfoAsset">();
	}
	static class UGameStringInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStringInfoAsset>();
	}
};
static_assert(alignof(UGameStringInfoAsset) == 0x000010, "Wrong alignment on UGameStringInfoAsset");
static_assert(sizeof(UGameStringInfoAsset) == 0x000120, "Wrong size on UGameStringInfoAsset");
static_assert(offsetof(UGameStringInfoAsset, ContentInfoDB) == 0x000078, "Member 'UGameStringInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.NPCSpotDieInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCSpotDieInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetActionStatePc(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetChangeWeather(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetChangeWeatherDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetContentCondition(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetDeadBossAlertAfterCommand(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetDeadBossAlertAfterCommandDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetDeadBossAlertDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetDialog(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetDialogCommand(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetDialogDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static class FString GetDialogTalkerSpotId(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetItemAlertDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetItemDropIndex(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetLevelSequenceCommand(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetLevelSequenceDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static class FString GetLevelSequenceSpotId(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetMonologue(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetMonologueDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetMonologueEndCommand(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetMovie(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetMovieCommand(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetMovieDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static class FString GetNpcSpotId(const struct FNPCSpotDieInfoPtr& Ptr);
	static const class FName GetStartCommand(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetUiFadeout(const struct FNPCSpotDieInfoPtr& Ptr);
	static int32 GetUiFadeOutDelay(const struct FNPCSpotDieInfoPtr& Ptr);
	static bool GetUiFadeOutPause(const struct FNPCSpotDieInfoPtr& Ptr);
	static bool IsValid(const struct FNPCSpotDieInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCSpotDieInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSpotDieInfoPtrFuncLibrary">();
	}
	static class UNPCSpotDieInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSpotDieInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCSpotDieInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCSpotDieInfoPtrFuncLibrary");
static_assert(sizeof(UNPCSpotDieInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCSpotDieInfoPtrFuncLibrary");

// Class ProjectPContentInfo.GlobalVariableInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGlobalVariableInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FGlobalVariableInfo& Info);
	static int32 GetInitValue(const struct FGlobalVariableInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalVariableInfoFuncLibrary">();
	}
	static class UGlobalVariableInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalVariableInfoFuncLibrary>();
	}
};
static_assert(alignof(UGlobalVariableInfoFuncLibrary) == 0x000008, "Wrong alignment on UGlobalVariableInfoFuncLibrary");
static_assert(sizeof(UGlobalVariableInfoFuncLibrary) == 0x000028, "Wrong size on UGlobalVariableInfoFuncLibrary");

// Class ProjectPContentInfo.GlobalVariableInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGlobalVariableInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FGlobalVariableInfoPtr& Ptr);
	static int32 GetInitValue(const struct FGlobalVariableInfoPtr& Ptr);
	static bool IsValid(const struct FGlobalVariableInfoPtr& Ptr);
	static void IsValidBranch(const struct FGlobalVariableInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalVariableInfoPtrFuncLibrary">();
	}
	static class UGlobalVariableInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalVariableInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UGlobalVariableInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UGlobalVariableInfoPtrFuncLibrary");
static_assert(sizeof(UGlobalVariableInfoPtrFuncLibrary) == 0x000028, "Wrong size on UGlobalVariableInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PatchWeaponPackagePtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPatchWeaponPackagePtrFuncLibrary final : public UObject
{
public:
	static const class FName GetBladeCodeName(const struct FPatchWeaponPackagePtr& Ptr);
	static const class FName GetHandleCodeName(const struct FPatchWeaponPackagePtr& Ptr);
	static int32 GetPrintOrder(const struct FPatchWeaponPackagePtr& Ptr);
	static bool IsValid(const struct FPatchWeaponPackagePtr& Ptr);
	static void IsValidBranch(const struct FPatchWeaponPackagePtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchWeaponPackagePtrFuncLibrary">();
	}
	static class UPatchWeaponPackagePtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchWeaponPackagePtrFuncLibrary>();
	}
};
static_assert(alignof(UPatchWeaponPackagePtrFuncLibrary) == 0x000008, "Wrong alignment on UPatchWeaponPackagePtrFuncLibrary");
static_assert(sizeof(UPatchWeaponPackagePtrFuncLibrary) == 0x000028, "Wrong size on UPatchWeaponPackagePtrFuncLibrary");

// Class ProjectPContentInfo.GlobalVariableInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UGlobalVariableInfoAsset final : public UContentInfoAsset
{
public:
	struct FGlobalVariableInfoDB                  ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGlobalVariableInfoPtr FindGlobalVariableInfoByNameBP(class FName CodeName);
	static const TArray<struct FGlobalVariableInfo> GetGlobalVariableInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalVariableInfoAsset">();
	}
	static class UGlobalVariableInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalVariableInfoAsset>();
	}
};
static_assert(alignof(UGlobalVariableInfoAsset) == 0x000010, "Wrong alignment on UGlobalVariableInfoAsset");
static_assert(sizeof(UGlobalVariableInfoAsset) == 0x000120, "Wrong size on UGlobalVariableInfoAsset");
static_assert(offsetof(UGlobalVariableInfoAsset, ContentInfoDB) == 0x000078, "Member 'UGlobalVariableInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.HitIndexInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitIndexInfoFuncLibrary final : public UObject
{
public:
	static int32 GetHitGroup(const struct FHitIndexInfo& Info);
	static int32 GetHitIndex(const struct FHitIndexInfo& Info);
	static int32 GetHitPrioty(const struct FHitIndexInfo& Info);
	static const class FName GetSkillCodeName(const struct FHitIndexInfo& Info);
	static const class FName GetSkillHitCodeName(const struct FHitIndexInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitIndexInfoFuncLibrary">();
	}
	static class UHitIndexInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitIndexInfoFuncLibrary>();
	}
};
static_assert(alignof(UHitIndexInfoFuncLibrary) == 0x000008, "Wrong alignment on UHitIndexInfoFuncLibrary");
static_assert(sizeof(UHitIndexInfoFuncLibrary) == 0x000028, "Wrong size on UHitIndexInfoFuncLibrary");

// Class ProjectPContentInfo.SpotMatchInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpotMatchInfoFuncLibrary final : public UObject
{
public:
	static ELConditionCheckType GetNPCSpawnControllerCheckType(const struct FSpotMatchInfo& Info);
	static const class FName GetNPCSpawnControllerCodeName(const struct FSpotMatchInfo& Info);
	static class FString GetNpcSpotId(const struct FSpotMatchInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotMatchInfoFuncLibrary">();
	}
	static class USpotMatchInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpotMatchInfoFuncLibrary>();
	}
};
static_assert(alignof(USpotMatchInfoFuncLibrary) == 0x000008, "Wrong alignment on USpotMatchInfoFuncLibrary");
static_assert(sizeof(USpotMatchInfoFuncLibrary) == 0x000028, "Wrong size on USpotMatchInfoFuncLibrary");

// Class ProjectPContentInfo.HitIndexInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitIndexInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetHitGroup(const struct FHitIndexInfoPtr& Ptr);
	static int32 GetHitIndex(const struct FHitIndexInfoPtr& Ptr);
	static int32 GetHitPrioty(const struct FHitIndexInfoPtr& Ptr);
	static const class FName GetSkillCodeName(const struct FHitIndexInfoPtr& Ptr);
	static const class FName GetSkillHitCodeName(const struct FHitIndexInfoPtr& Ptr);
	static bool IsValid(const struct FHitIndexInfoPtr& Ptr);
	static void IsValidBranch(const struct FHitIndexInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitIndexInfoPtrFuncLibrary">();
	}
	static class UHitIndexInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitIndexInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UHitIndexInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UHitIndexInfoPtrFuncLibrary");
static_assert(sizeof(UHitIndexInfoPtrFuncLibrary) == 0x000028, "Wrong size on UHitIndexInfoPtrFuncLibrary");

// Class ProjectPContentInfo.HitIndexInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UHitIndexInfoAsset final : public UContentInfoAsset
{
public:
	struct FHitIndexInfoDB                        ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FHitIndexInfo> GetHitIndexInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitIndexInfoAsset">();
	}
	static class UHitIndexInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitIndexInfoAsset>();
	}
};
static_assert(alignof(UHitIndexInfoAsset) == 0x000010, "Wrong alignment on UHitIndexInfoAsset");
static_assert(sizeof(UHitIndexInfoAsset) == 0x0000D0, "Wrong size on UHitIndexInfoAsset");
static_assert(offsetof(UHitIndexInfoAsset, ContentInfoDB) == 0x000078, "Member 'UHitIndexInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.NPCBodyWeaponInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCBodyWeaponInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAddSkillRangeAfterBroken(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static int32 GetDurability(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static int32 GetMinimumSkillRangeMaxAfterBroken(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static int32 GetMinimumSkillRangeMinAfterBroken(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static int32 GetMotionSpeedRateAfterBroken(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static int32 GetMulpleRateAtkPowerAfterBroken(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static int32 GetMulpleRateRigidityAfterBroken(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static const class FName GetWeaponBpCodeName(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static bool IsValid(const struct FNPCBodyWeaponInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCBodyWeaponInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBodyWeaponInfoPtrFuncLibrary">();
	}
	static class UNPCBodyWeaponInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBodyWeaponInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCBodyWeaponInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCBodyWeaponInfoPtrFuncLibrary");
static_assert(sizeof(UNPCBodyWeaponInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCBodyWeaponInfoPtrFuncLibrary");

// Class ProjectPContentInfo.HitMotionGroupInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitMotionGroupInfoFuncLibrary final : public UObject
{
public:
	static int32 GetChosenProbability(const struct FHitMotionGroupInfo& Info);
	static ELHitMotionDirectionType GetHitMotionDirectionType(const struct FHitMotionGroupInfo& Info);
	static ELHitMotionType GetHitMotionType(const struct FHitMotionGroupInfo& Info);
	static const class FName GetPlayCommonActionMontageCodeName(const struct FHitMotionGroupInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMotionGroupInfoFuncLibrary">();
	}
	static class UHitMotionGroupInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMotionGroupInfoFuncLibrary>();
	}
};
static_assert(alignof(UHitMotionGroupInfoFuncLibrary) == 0x000008, "Wrong alignment on UHitMotionGroupInfoFuncLibrary");
static_assert(sizeof(UHitMotionGroupInfoFuncLibrary) == 0x000028, "Wrong size on UHitMotionGroupInfoFuncLibrary");

// Class ProjectPContentInfo.HitMotionGroupInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitMotionGroupInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetChosenProbability(const struct FHitMotionGroupInfoPtr& Ptr);
	static ELHitMotionDirectionType GetHitMotionDirectionType(const struct FHitMotionGroupInfoPtr& Ptr);
	static ELHitMotionType GetHitMotionType(const struct FHitMotionGroupInfoPtr& Ptr);
	static const class FName GetPlayCommonActionMontageCodeName(const struct FHitMotionGroupInfoPtr& Ptr);
	static bool IsValid(const struct FHitMotionGroupInfoPtr& Ptr);
	static void IsValidBranch(const struct FHitMotionGroupInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMotionGroupInfoPtrFuncLibrary">();
	}
	static class UHitMotionGroupInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMotionGroupInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UHitMotionGroupInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UHitMotionGroupInfoPtrFuncLibrary");
static_assert(sizeof(UHitMotionGroupInfoPtrFuncLibrary) == 0x000028, "Wrong size on UHitMotionGroupInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PatchItemPackagePtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPatchItemPackagePtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPatchItemPackagePtr& Ptr);
	static int32 GetCount(const struct FPatchItemPackagePtr& Ptr);
	static int32 GetPrintOrder(const struct FPatchItemPackagePtr& Ptr);
	static bool IsValid(const struct FPatchItemPackagePtr& Ptr);
	static void IsValidBranch(const struct FPatchItemPackagePtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchItemPackagePtrFuncLibrary">();
	}
	static class UPatchItemPackagePtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchItemPackagePtrFuncLibrary>();
	}
};
static_assert(alignof(UPatchItemPackagePtrFuncLibrary) == 0x000008, "Wrong alignment on UPatchItemPackagePtrFuncLibrary");
static_assert(sizeof(UPatchItemPackagePtrFuncLibrary) == 0x000028, "Wrong size on UPatchItemPackagePtrFuncLibrary");

// Class ProjectPContentInfo.HitMotionGroupInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UHitMotionGroupInfoAsset final : public UContentInfoAsset
{
public:
	struct FHitMotionGroupInfoDB                  ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FHitMotionGroupInfo> GetHitMotionGroupInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMotionGroupInfoAsset">();
	}
	static class UHitMotionGroupInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMotionGroupInfoAsset>();
	}
};
static_assert(alignof(UHitMotionGroupInfoAsset) == 0x000010, "Wrong alignment on UHitMotionGroupInfoAsset");
static_assert(sizeof(UHitMotionGroupInfoAsset) == 0x0000D0, "Wrong size on UHitMotionGroupInfoAsset");
static_assert(offsetof(UHitMotionGroupInfoAsset, ContentInfoDB) == 0x000078, "Member 'UHitMotionGroupInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.HitMotionReplaceInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitMotionReplaceInfoFuncLibrary final : public UObject
{
public:
	static int32 GetBoundDuration(const struct FHitMotionReplaceInfo& Info);
	static int32 GetBoundHeight(const struct FHitMotionReplaceInfo& Info);
	static int32 GetHitAnimDuration(const struct FHitMotionReplaceInfo& Info);
	static const class FName GetHitCameraShakeCodeName(const struct FHitMotionReplaceInfo& Info);
	static const class FName GetHitMotionReplaceGroupCodeName(const struct FHitMotionReplaceInfo& Info);
	static ELKnockBackDirectionType GetKnockbackDirection(const struct FHitMotionReplaceInfo& Info);
	static int32 GetKnockbackDistance(const struct FHitMotionReplaceInfo& Info);
	static int32 GetKnockbackDuration(const struct FHitMotionReplaceInfo& Info);
	static float GetKnockbackScale(const struct FHitMotionReplaceInfo& Info);
	static ELHitMotionType GetOriginHitMotionType(const struct FHitMotionReplaceInfo& Info);
	static ELHitMotionType GetReplaceHitMotionType(const struct FHitMotionReplaceInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMotionReplaceInfoFuncLibrary">();
	}
	static class UHitMotionReplaceInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMotionReplaceInfoFuncLibrary>();
	}
};
static_assert(alignof(UHitMotionReplaceInfoFuncLibrary) == 0x000008, "Wrong alignment on UHitMotionReplaceInfoFuncLibrary");
static_assert(sizeof(UHitMotionReplaceInfoFuncLibrary) == 0x000028, "Wrong size on UHitMotionReplaceInfoFuncLibrary");

// Class ProjectPContentInfo.DefaultStatInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDefaultStatInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStatePenaltyBase(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAcidAttack(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAcidDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAcidDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAcidReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAdvance(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAttackGainFrenzyPointIncreaseRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAttackratioSlavearm(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAttackSpeedRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetAttackStaminaReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBreakDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupAcidReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupBreakReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupContaminationReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupCurseReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupElectricReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupFireReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildupImpactReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetBuildUpRecoverIncBase(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetCapacity(const struct FDefaultStatInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetContaminationDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetCriticalDamageRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetCurseDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetDashParryCooltime(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetDashStaminaReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetDestructionPower(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetDownGetupSpeedRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetDropErgoRegainMonkillRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetElectricAttack(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetElectricDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetElectricDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetElectricReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFatalDamageRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFatalPhysicalAttackpower(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFireAttack(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFireDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFireDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFireReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetFrenzyUnitCount(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardAciddamageReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardElectricdamageReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardFiredamageReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardParryCooltime(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardPhysicaldamageReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardRegainAttackHealIncreaseRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardRegainPerfectGuardHealRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardRegainPointMax(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardRegainRecoveryRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardRegainRecoveryReduceRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetGuardStaminaReductionRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetHealthPoint(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetImpactDebuffResist(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetLevel(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetMaxFrenzyGaugePerUnit(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetModificationDropErgoRemainDecrease(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetMotionSpeedRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetMotivity(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetParalyzationAddDamageRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPerfectguardGroggyenableAddtimeRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalAttack(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalPierceDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalPierceReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalSlashDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalSlashReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalStrikeDefence(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPhysicalStrikeReduce(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetPierceAttackRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetRigidity(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetSharpnessBonus(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetSlashAttackRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetSlaveAttackGainFrenzyPointRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetSlaveMagazinePoint(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetSprintConsumeStaminaPerSecond(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetSprintSpeedRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetStaminaExhaustTime(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetStaminaPoint(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetStaminaRestorePerSecond(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetStrikeAttackRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetTechnique(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetTenacity(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetToughPoint(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayReduction(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetToughRestorePerSecond(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetVigor(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetVitality(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetWalkRunSpeedRatio(const struct FDefaultStatInfoPtr& Ptr);
	static int32 GetWeightLimit(const struct FDefaultStatInfoPtr& Ptr);
	static bool IsValid(const struct FDefaultStatInfoPtr& Ptr);
	static void IsValidBranch(const struct FDefaultStatInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultStatInfoPtrFuncLibrary">();
	}
	static class UDefaultStatInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultStatInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDefaultStatInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDefaultStatInfoPtrFuncLibrary");
static_assert(sizeof(UDefaultStatInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDefaultStatInfoPtrFuncLibrary");

// Class ProjectPContentInfo.HitMotionReplaceInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitMotionReplaceInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetBoundDuration(const struct FHitMotionReplaceInfoPtr& Ptr);
	static int32 GetBoundHeight(const struct FHitMotionReplaceInfoPtr& Ptr);
	static int32 GetHitAnimDuration(const struct FHitMotionReplaceInfoPtr& Ptr);
	static const class FName GetHitCameraShakeCodeName(const struct FHitMotionReplaceInfoPtr& Ptr);
	static const class FName GetHitMotionReplaceGroupCodeName(const struct FHitMotionReplaceInfoPtr& Ptr);
	static ELKnockBackDirectionType GetKnockbackDirection(const struct FHitMotionReplaceInfoPtr& Ptr);
	static int32 GetKnockbackDistance(const struct FHitMotionReplaceInfoPtr& Ptr);
	static int32 GetKnockbackDuration(const struct FHitMotionReplaceInfoPtr& Ptr);
	static float GetKnockbackScale(const struct FHitMotionReplaceInfoPtr& Ptr);
	static ELHitMotionType GetOriginHitMotionType(const struct FHitMotionReplaceInfoPtr& Ptr);
	static ELHitMotionType GetReplaceHitMotionType(const struct FHitMotionReplaceInfoPtr& Ptr);
	static bool IsValid(const struct FHitMotionReplaceInfoPtr& Ptr);
	static void IsValidBranch(const struct FHitMotionReplaceInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMotionReplaceInfoPtrFuncLibrary">();
	}
	static class UHitMotionReplaceInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMotionReplaceInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UHitMotionReplaceInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UHitMotionReplaceInfoPtrFuncLibrary");
static_assert(sizeof(UHitMotionReplaceInfoPtrFuncLibrary) == 0x000028, "Wrong size on UHitMotionReplaceInfoPtrFuncLibrary");

// Class ProjectPContentInfo.HitMotionReplaceInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UHitMotionReplaceInfoAsset final : public UContentInfoAsset
{
public:
	struct FHitMotionReplaceInfoDB                ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FHitMotionReplaceInfo> GetHitMotionReplaceInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMotionReplaceInfoAsset">();
	}
	static class UHitMotionReplaceInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMotionReplaceInfoAsset>();
	}
};
static_assert(alignof(UHitMotionReplaceInfoAsset) == 0x000010, "Wrong alignment on UHitMotionReplaceInfoAsset");
static_assert(sizeof(UHitMotionReplaceInfoAsset) == 0x0000D0, "Wrong size on UHitMotionReplaceInfoAsset");
static_assert(offsetof(UHitMotionReplaceInfoAsset, ContentInfoDB) == 0x000078, "Member 'UHitMotionReplaceInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PatchRewardInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPatchRewardInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPatchRewardInfoPtr& Ptr);
	static const TArray<struct FPatchItemPackage> GetItemListArray(const struct FPatchRewardInfoPtr& Ptr);
	static int32 GetOrder(const struct FPatchRewardInfoPtr& Ptr);
	static class FString GetVersion(const struct FPatchRewardInfoPtr& Ptr);
	static class FString GetVersionMac(const struct FPatchRewardInfoPtr& Ptr);
	static class FString GetVersionPs4(const struct FPatchRewardInfoPtr& Ptr);
	static class FString GetVersionPs5(const struct FPatchRewardInfoPtr& Ptr);
	static const TArray<struct FPatchWeaponPackage> GetWeaponListArray(const struct FPatchRewardInfoPtr& Ptr);
	static bool IsValid(const struct FPatchRewardInfoPtr& Ptr);
	static void IsValidBranch(const struct FPatchRewardInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchRewardInfoPtrFuncLibrary">();
	}
	static class UPatchRewardInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchRewardInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPatchRewardInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPatchRewardInfoPtrFuncLibrary");
static_assert(sizeof(UPatchRewardInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPatchRewardInfoPtrFuncLibrary");

// Class ProjectPContentInfo.HumanizationBuffAddInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHumanizationBuffAddInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAddAbnormalstate(const struct FHumanizationBuffAddInfo& Info);
	static const class FName GetAddSpecialbuff(const struct FHumanizationBuffAddInfo& Info);
	static const class FName GetCodeName(const struct FHumanizationBuffAddInfo& Info);
	static int32 GetHumanpointUnder(const struct FHumanizationBuffAddInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanizationBuffAddInfoFuncLibrary">();
	}
	static class UHumanizationBuffAddInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanizationBuffAddInfoFuncLibrary>();
	}
};
static_assert(alignof(UHumanizationBuffAddInfoFuncLibrary) == 0x000008, "Wrong alignment on UHumanizationBuffAddInfoFuncLibrary");
static_assert(sizeof(UHumanizationBuffAddInfoFuncLibrary) == 0x000028, "Wrong size on UHumanizationBuffAddInfoFuncLibrary");

// Class ProjectPContentInfo.HumanizationBuffAddInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHumanizationBuffAddInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAddAbnormalstate(const struct FHumanizationBuffAddInfoPtr& Ptr);
	static const class FName GetAddSpecialbuff(const struct FHumanizationBuffAddInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FHumanizationBuffAddInfoPtr& Ptr);
	static int32 GetHumanpointUnder(const struct FHumanizationBuffAddInfoPtr& Ptr);
	static bool IsValid(const struct FHumanizationBuffAddInfoPtr& Ptr);
	static void IsValidBranch(const struct FHumanizationBuffAddInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanizationBuffAddInfoPtrFuncLibrary">();
	}
	static class UHumanizationBuffAddInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanizationBuffAddInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UHumanizationBuffAddInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UHumanizationBuffAddInfoPtrFuncLibrary");
static_assert(sizeof(UHumanizationBuffAddInfoPtrFuncLibrary) == 0x000028, "Wrong size on UHumanizationBuffAddInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NPCSpawnControllerInfoAsset
// 0x0108 (0x0180 - 0x0078)
class alignas(0x10) UNPCSpawnControllerInfoAsset final : public UContentInfoAsset
{
public:
	struct FNPCSpawnControllerInfoDB              ContentInfoDB;                                     // 0x0078(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSpawnControllerInfoPtr FindSpawnControllerInfoByNameBP(class FName CodeName);
	static struct FSpotMatchInfoPtr FindSpotMatchInfoByNameBP(const class FString& CodeName);
	static const TArray<struct FSpawnControllerInfo> GetSpawnControllerInfoArrayBP();
	static const TArray<struct FSpotMatchInfo> GetSpotMatchInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSpawnControllerInfoAsset">();
	}
	static class UNPCSpawnControllerInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSpawnControllerInfoAsset>();
	}
};
static_assert(alignof(UNPCSpawnControllerInfoAsset) == 0x000010, "Wrong alignment on UNPCSpawnControllerInfoAsset");
static_assert(sizeof(UNPCSpawnControllerInfoAsset) == 0x000180, "Wrong size on UNPCSpawnControllerInfoAsset");
static_assert(offsetof(UNPCSpawnControllerInfoAsset, ContentInfoDB) == 0x000078, "Member 'UNPCSpawnControllerInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.HumanizationBuffAlterInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHumanizationBuffAlterInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAlterAbnormalCodeName(const struct FHumanizationBuffAlterInfo& Info);
	static const class FName GetAlterSpecialbuffCodeName(const struct FHumanizationBuffAlterInfo& Info);
	static const class FName GetCodeName(const struct FHumanizationBuffAlterInfo& Info);
	static int32 GetHumanpointUnder(const struct FHumanizationBuffAlterInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanizationBuffAlterInfoFuncLibrary">();
	}
	static class UHumanizationBuffAlterInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanizationBuffAlterInfoFuncLibrary>();
	}
};
static_assert(alignof(UHumanizationBuffAlterInfoFuncLibrary) == 0x000008, "Wrong alignment on UHumanizationBuffAlterInfoFuncLibrary");
static_assert(sizeof(UHumanizationBuffAlterInfoFuncLibrary) == 0x000028, "Wrong size on UHumanizationBuffAlterInfoFuncLibrary");

// Class ProjectPContentInfo.HumanizationInfoAsset
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) UHumanizationInfoAsset final : public UContentInfoAsset
{
public:
	struct FHumanizationInfoDB                    ContentInfoDB;                                     // 0x0078(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FHumanizationBuffAddInfo> GetHumanizationBuffAddInfoArrayBP();
	static const TArray<struct FHumanizationBuffAlterInfo> GetHumanizationBuffAlterInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanizationInfoAsset">();
	}
	static class UHumanizationInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanizationInfoAsset>();
	}
};
static_assert(alignof(UHumanizationInfoAsset) == 0x000010, "Wrong alignment on UHumanizationInfoAsset");
static_assert(sizeof(UHumanizationInfoAsset) == 0x0000E0, "Wrong size on UHumanizationInfoAsset");
static_assert(offsetof(UHumanizationInfoAsset, ContentInfoDB) == 0x000078, "Member 'UHumanizationInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ImageResourceInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UImageResourceInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FImageResourceInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FImageResourceInfoPtr& Ptr);
	static bool IsValid(const struct FImageResourceInfoPtr& Ptr);
	static void IsValidBranch(const struct FImageResourceInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageResourceInfoPtrFuncLibrary">();
	}
	static class UImageResourceInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageResourceInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UImageResourceInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UImageResourceInfoPtrFuncLibrary");
static_assert(sizeof(UImageResourceInfoPtrFuncLibrary) == 0x000028, "Wrong size on UImageResourceInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ImmuneInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UImmuneInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FImmuneInfo& Info);
	static float GetCriticalChance(const struct FImmuneInfo& Info);
	static int32 GetDamage(const struct FImmuneInfo& Info);
	static int32 GetElementalDamage(const struct FImmuneInfo& Info);
	static int32 GetGroggyAttack(const struct FImmuneInfo& Info);
	static int32 GetHitActionDmgStand(const struct FImmuneInfo& Info);
	static int32 GetHitActionDownAwayUp(const struct FImmuneInfo& Info);
	static int32 GetHitActionDownDragStamp(const struct FImmuneInfo& Info);
	static int32 GetHitActionGrab(const struct FImmuneInfo& Info);
	static int32 GetHitActionKnockBack(const struct FImmuneInfo& Info);
	static int32 GetIgnoreHit(const struct FImmuneInfo& Info);
	static int32 GetSpecialElementalDamage(const struct FImmuneInfo& Info);
	static int32 GetToughAttack(const struct FImmuneInfo& Info);
	static int32 GetWeaponAttackPeriod(const struct FImmuneInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImmuneInfoFuncLibrary">();
	}
	static class UImmuneInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmuneInfoFuncLibrary>();
	}
};
static_assert(alignof(UImmuneInfoFuncLibrary) == 0x000008, "Wrong alignment on UImmuneInfoFuncLibrary");
static_assert(sizeof(UImmuneInfoFuncLibrary) == 0x000028, "Wrong size on UImmuneInfoFuncLibrary");

// Class ProjectPContentInfo.ImmuneInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UImmuneInfoAsset final : public UContentInfoAsset
{
public:
	struct FImmuneInfoDB                          ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FImmuneInfoPtr FindImmuneInfoByNameBP(class FName CodeName);
	static const TArray<struct FImmuneInfo> GetImmuneInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImmuneInfoAsset">();
	}
	static class UImmuneInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmuneInfoAsset>();
	}
};
static_assert(alignof(UImmuneInfoAsset) == 0x000010, "Wrong alignment on UImmuneInfoAsset");
static_assert(sizeof(UImmuneInfoAsset) == 0x000120, "Wrong size on UImmuneInfoAsset");
static_assert(offsetof(UImmuneInfoAsset, ContentInfoDB) == 0x000078, "Member 'UImmuneInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ActorParamInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActorParamInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetArmor(const struct FActorParamInfoPtr& Ptr);
	static float GetAttackPower(const struct FActorParamInfoPtr& Ptr);
	static float GetCriticalChance(const struct FActorParamInfoPtr& Ptr);
	static float GetCriticalRating(const struct FActorParamInfoPtr& Ptr);
	static int32 GetMaxHp(const struct FActorParamInfoPtr& Ptr);
	static int32 GetMaxMp(const struct FActorParamInfoPtr& Ptr);
	static float GetWeaponAttackPeriod(const struct FActorParamInfoPtr& Ptr);
	static float GetWeaponDamage(const struct FActorParamInfoPtr& Ptr);
	static bool IsValid(const struct FActorParamInfoPtr& Ptr);
	static void IsValidBranch(const struct FActorParamInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorParamInfoPtrFuncLibrary">();
	}
	static class UActorParamInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorParamInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UActorParamInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UActorParamInfoPtrFuncLibrary");
static_assert(sizeof(UActorParamInfoPtrFuncLibrary) == 0x000028, "Wrong size on UActorParamInfoPtrFuncLibrary");

// Class ProjectPContentInfo.FloatRangeValuePtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFloatRangeValuePtrFuncLibrary final : public UObject
{
public:
	static float GetMax(const struct FFloatRangeValuePtr& Ptr);
	static float GetMin(const struct FFloatRangeValuePtr& Ptr);
	static bool IsValid(const struct FFloatRangeValuePtr& Ptr);
	static void IsValidBranch(const struct FFloatRangeValuePtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatRangeValuePtrFuncLibrary">();
	}
	static class UFloatRangeValuePtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatRangeValuePtrFuncLibrary>();
	}
};
static_assert(alignof(UFloatRangeValuePtrFuncLibrary) == 0x000008, "Wrong alignment on UFloatRangeValuePtrFuncLibrary");
static_assert(sizeof(UFloatRangeValuePtrFuncLibrary) == 0x000028, "Wrong size on UFloatRangeValuePtrFuncLibrary");

// Class ProjectPContentInfo.GeneralConditionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralConditionInfoPtrFuncLibrary final : public UObject
{
public:
	static ELConditionCompareType GetConditionType(const struct FGeneralConditionInfoPtr& Ptr);
	static class FString GetParam1(const struct FGeneralConditionInfoPtr& Ptr);
	static class FString GetParam2(const struct FGeneralConditionInfoPtr& Ptr);
	static class FString GetParam3(const struct FGeneralConditionInfoPtr& Ptr);
	static bool IsValid(const struct FGeneralConditionInfoPtr& Ptr);
	static void IsValidBranch(const struct FGeneralConditionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralConditionInfoPtrFuncLibrary">();
	}
	static class UGeneralConditionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralConditionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UGeneralConditionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UGeneralConditionInfoPtrFuncLibrary");
static_assert(sizeof(UGeneralConditionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UGeneralConditionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.GeneralCommandInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralCommandInfoPtrFuncLibrary final : public UObject
{
public:
	static ELContentCommandType GetCommandEnum(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam1(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam10(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam2(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam3(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam4(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam5(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam6(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam7(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam8(const struct FGeneralCommandInfoPtr& Ptr);
	static class FString GetParam9(const struct FGeneralCommandInfoPtr& Ptr);
	static bool IsValid(const struct FGeneralCommandInfoPtr& Ptr);
	static void IsValidBranch(const struct FGeneralCommandInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralCommandInfoPtrFuncLibrary">();
	}
	static class UGeneralCommandInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralCommandInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UGeneralCommandInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UGeneralCommandInfoPtrFuncLibrary");
static_assert(sizeof(UGeneralCommandInfoPtrFuncLibrary) == 0x000028, "Wrong size on UGeneralCommandInfoPtrFuncLibrary");

// Class ProjectPContentInfo.GeneralCallBackEventInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UGeneralCallBackEventInfoPtrFuncLibrary final : public UObject
{
public:
	static class FString GetCallbackEventParam1(const struct FGeneralCallBackEventInfoPtr& Ptr);
	static class FString GetCallbackEventParam2(const struct FGeneralCallBackEventInfoPtr& Ptr);
	static ELCallBackEventType GetCallbackEventType(const struct FGeneralCallBackEventInfoPtr& Ptr);
	static bool IsValid(const struct FGeneralCallBackEventInfoPtr& Ptr);
	static void IsValidBranch(const struct FGeneralCallBackEventInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralCallBackEventInfoPtrFuncLibrary">();
	}
	static class UGeneralCallBackEventInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralCallBackEventInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UGeneralCallBackEventInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UGeneralCallBackEventInfoPtrFuncLibrary");
static_assert(sizeof(UGeneralCallBackEventInfoPtrFuncLibrary) == 0x000028, "Wrong size on UGeneralCallBackEventInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ActionStateTypePtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UActionStateTypePtrFuncLibrary final : public UObject
{
public:
	static const class FName GetValue(const struct FActionStateTypePtr& Ptr);
	static bool IsValid(const struct FActionStateTypePtr& Ptr);
	static void IsValidBranch(const struct FActionStateTypePtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionStateTypePtrFuncLibrary">();
	}
	static class UActionStateTypePtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionStateTypePtrFuncLibrary>();
	}
};
static_assert(alignof(UActionStateTypePtrFuncLibrary) == 0x000008, "Wrong alignment on UActionStateTypePtrFuncLibrary");
static_assert(sizeof(UActionStateTypePtrFuncLibrary) == 0x000028, "Wrong size on UActionStateTypePtrFuncLibrary");

// Class ProjectPContentInfo.PackageSettingInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPackageSettingInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAcquisitionDelayMs(const struct FPackageSettingInfoPtr& Ptr);
	static int32 GetAcquisitionPercentage(const struct FPackageSettingInfoPtr& Ptr);
	static TArray<int32> GetDropOffset(const struct FPackageSettingInfoPtr& Ptr);
	static class FString GetFirstKillPackageConfigureCodename(const struct FPackageSettingInfoPtr& Ptr);
	static ELFirstKillRewardType GetFirstKillRewardType(const struct FPackageSettingInfoPtr& Ptr);
	static bool GetForceAcquisition(const struct FPackageSettingInfoPtr& Ptr);
	static EPackageOfferMethodType GetOfferMethod(const struct FPackageSettingInfoPtr& Ptr);
	static EPackageOfferReasonType GetOfferReason(const struct FPackageSettingInfoPtr& Ptr);
	static const class FName GetOwnerId(const struct FPackageSettingInfoPtr& Ptr);
	static EPackageOwnerType GetOwnerType(const struct FPackageSettingInfoPtr& Ptr);
	static const class FName GetPackageConfigureId(const struct FPackageSettingInfoPtr& Ptr);
	static const class FName GetPropCodeName(const struct FPackageSettingInfoPtr& Ptr);
	static bool IsValid(const struct FPackageSettingInfoPtr& Ptr);
	static void IsValidBranch(const struct FPackageSettingInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageSettingInfoPtrFuncLibrary">();
	}
	static class UPackageSettingInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackageSettingInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPackageSettingInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPackageSettingInfoPtrFuncLibrary");
static_assert(sizeof(UPackageSettingInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPackageSettingInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PackageConfigureInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPackageConfigureInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetConditionCodename(const struct FPackageConfigureInfoPtr& Ptr);
	static const class FName GetDropSetCodeName(const struct FPackageConfigureInfoPtr& Ptr);
	static ELDropType GetDropType(const struct FPackageConfigureInfoPtr& Ptr);
	static const class FName GetIndex(const struct FPackageConfigureInfoPtr& Ptr);
	static int32 GetIndexDetail(const struct FPackageConfigureInfoPtr& Ptr);
	static int32 GetItemAcquisitionPercentage(const struct FPackageConfigureInfoPtr& Ptr);
	static const class FName GetItemCodeName(const struct FPackageConfigureInfoPtr& Ptr);
	static int32 GetItemCount(const struct FPackageConfigureInfoPtr& Ptr);
	static int32 GetNGPRound(const struct FPackageConfigureInfoPtr& Ptr);
	static bool IsValid(const struct FPackageConfigureInfoPtr& Ptr);
	static void IsValidBranch(const struct FPackageConfigureInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageConfigureInfoPtrFuncLibrary">();
	}
	static class UPackageConfigureInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackageConfigureInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPackageConfigureInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPackageConfigureInfoPtrFuncLibrary");
static_assert(sizeof(UPackageConfigureInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPackageConfigureInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ItemCommonInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemCommonInfoFuncLibrary final : public UObject
{
public:
	static bool GetBattleItem(const struct FItemCommonInfo& Info);
	static bool GetCanAbandonment(const struct FItemCommonInfo& Info);
	static bool GetCanKeep(const struct FItemCommonInfo& Info);
	static bool GetCanSelling(const struct FItemCommonInfo& Info);
	static bool GetCanStackInventory(const struct FItemCommonInfo& Info);
	static const class FName GetChangeCodeName(const struct FItemCommonInfo& Info);
	static const class FName GetCodeName(const struct FItemCommonInfo& Info);
	static int32 GetEquipGroupId(const struct FItemCommonInfo& Info);
	static const class FName GetEquipSpecialbuffCodeName(const struct FItemCommonInfo& Info);
	static ELItemFirstCategory GetFirstCategory(const struct FItemCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetHeroicWeaponImageResource(const struct FItemCommonInfo& Info);
	static bool GetHumanityItem(const struct FItemCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImage2Resource(const struct FItemCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImage3Resource(const struct FItemCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImage4Resource(const struct FItemCommonInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FItemCommonInfo& Info);
	static int32 GetInfoNoticeCount(const struct FItemCommonInfo& Info);
	static bool GetIsMinimumRequirements(const struct FItemCommonInfo& Info);
	static const class FName GetItemCostumeCodename(const struct FItemCommonInfo& Info);
	static class FString GetLocalTextItemName(const struct FItemCommonInfo& Info);
	static const class FName GetLocalTextItemNameCn(const struct FItemCommonInfo& Info);
	static class FText GetLocalTextItemNameLocalize(const struct FItemCommonInfo& Info);
	static class FString GetLocalTextTooltip1(const struct FItemCommonInfo& Info);
	static const class FName GetLocalTextTooltip1Cn(const struct FItemCommonInfo& Info);
	static class FText GetLocalTextTooltip1Localize(const struct FItemCommonInfo& Info);
	static class FString GetLocalTextTooltip2(const struct FItemCommonInfo& Info);
	static const class FName GetLocalTextTooltip2Cn(const struct FItemCommonInfo& Info);
	static class FText GetLocalTextTooltip2Localize(const struct FItemCommonInfo& Info);
	static int32 GetMaxStackCount(const struct FItemCommonInfo& Info);
	static bool GetNGPDelete(const struct FItemCommonInfo& Info);
	static bool GetNGPKeep(const struct FItemCommonInfo& Info);
	static bool GetNGPOnlyOne(const struct FItemCommonInfo& Info);
	static bool GetQuickslotEquipment(const struct FItemCommonInfo& Info);
	static ELItemSecondCategory GetSecondCategory(const struct FItemCommonInfo& Info);
	static int32 GetSellingPrice(const struct FItemCommonInfo& Info);
	static const class FName GetShowTooltipUnusableNow(const struct FItemCommonInfo& Info);
	static class FString GetSimpleTooltip(const struct FItemCommonInfo& Info);
	static const class FName GetSimpleTooltipCn(const struct FItemCommonInfo& Info);
	static class FText GetSimpleTooltipLocalize(const struct FItemCommonInfo& Info);
	static ELTooltipIconType GetSimpleTooltipType(const struct FItemCommonInfo& Info);
	static int32 GetSortPriority(const struct FItemCommonInfo& Info);
	static bool GetUseChangecodename(const struct FItemCommonInfo& Info);
	static int32 GetValueGrade(const struct FItemCommonInfo& Info);
	static int32 GetWeight(const struct FItemCommonInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCommonInfoFuncLibrary">();
	}
	static class UItemCommonInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCommonInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemCommonInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemCommonInfoFuncLibrary");
static_assert(sizeof(UItemCommonInfoFuncLibrary) == 0x000028, "Wrong size on UItemCommonInfoFuncLibrary");

// Class ProjectPContentInfo.ItemCostumeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemCostumeInfoFuncLibrary final : public UObject
{
public:
	static bool GetAccessory(const struct FItemCostumeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetBasic(const struct FItemCostumeInfo& Info);
	static const class FName GetCodeName(const struct FItemCostumeInfo& Info);
	static bool GetHideAcc(const struct FItemCostumeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLong(const struct FItemCostumeInfo& Info);
	static bool GetNeedShrink(const struct FItemCostumeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetWbasic(const struct FItemCostumeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetWlong(const struct FItemCostumeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCostumeInfoFuncLibrary">();
	}
	static class UItemCostumeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCostumeInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemCostumeInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemCostumeInfoFuncLibrary");
static_assert(sizeof(UItemCostumeInfoFuncLibrary) == 0x000028, "Wrong size on UItemCostumeInfoFuncLibrary");

// Class ProjectPContentInfo.CorrectionWeaponFirstStatInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UCorrectionWeaponFirstStatInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FCorrectionWeaponFirstStatInfo& Info);
	static const class FName GetDowngradeCodename(const struct FCorrectionWeaponFirstStatInfo& Info);
	static ELWeaponCorrectionPhysicalGrade GetGrade(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel1(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel10(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel100(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel11(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel12(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel13(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel14(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel15(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel16(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel17(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel18(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel19(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel2(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel20(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel21(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel22(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel23(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel24(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel25(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel26(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel27(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel28(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel29(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel3(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel30(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel31(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel32(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel33(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel34(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel35(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel36(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel37(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel38(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel39(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel4(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel40(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel41(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel42(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel43(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel44(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel45(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel46(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel47(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel48(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel49(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel5(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel50(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel51(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel52(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel53(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel54(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel55(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel56(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel57(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel58(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel59(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel6(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel60(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel61(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel62(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel63(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel64(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel65(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel66(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel67(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel68(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel69(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel7(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel70(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel71(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel72(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel73(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel74(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel75(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel76(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel77(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel78(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel79(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel8(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel80(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel81(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel82(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel83(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel84(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel85(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel86(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel87(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel88(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel89(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel9(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel90(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel91(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel92(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel93(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel94(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel95(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel96(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel97(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel98(const struct FCorrectionWeaponFirstStatInfo& Info);
	static int32 GetStatLevel99(const struct FCorrectionWeaponFirstStatInfo& Info);
	static const class FName GetUpgradeCodename(const struct FCorrectionWeaponFirstStatInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CorrectionWeaponFirstStatInfoFuncLibrary">();
	}
	static class UCorrectionWeaponFirstStatInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCorrectionWeaponFirstStatInfoFuncLibrary>();
	}
};
static_assert(alignof(UCorrectionWeaponFirstStatInfoFuncLibrary) == 0x000008, "Wrong alignment on UCorrectionWeaponFirstStatInfoFuncLibrary");
static_assert(sizeof(UCorrectionWeaponFirstStatInfoFuncLibrary) == 0x000028, "Wrong size on UCorrectionWeaponFirstStatInfoFuncLibrary");

// Class ProjectPContentInfo.ItemPartsInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemPartsInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAcidDebuffResist(const struct FItemPartsInfo& Info);
	static int32 GetAcidReduce(const struct FItemPartsInfo& Info);
	static int32 GetBreakDebuffResist(const struct FItemPartsInfo& Info);
	static int32 GetBuildupAcidReduction(const struct FItemPartsInfo& Info);
	static int32 GetBuildupBreakReduction(const struct FItemPartsInfo& Info);
	static int32 GetBuildupContaminationReduction(const struct FItemPartsInfo& Info);
	static int32 GetBuildupCurseReduction(const struct FItemPartsInfo& Info);
	static int32 GetBuildupElectricReduction(const struct FItemPartsInfo& Info);
	static int32 GetBuildupFireReduction(const struct FItemPartsInfo& Info);
	static int32 GetBuildupImpactReduction(const struct FItemPartsInfo& Info);
	static const class FName GetCodeName(const struct FItemPartsInfo& Info);
	static int32 GetContaminationDebuffResist(const struct FItemPartsInfo& Info);
	static int32 GetCurseDebuffResist(const struct FItemPartsInfo& Info);
	static int32 GetElectricDebuffResist(const struct FItemPartsInfo& Info);
	static int32 GetElectricReduce(const struct FItemPartsInfo& Info);
	static ELItemPartsSlot GetEquipSlot(const struct FItemPartsInfo& Info);
	static int32 GetFireDebuffResist(const struct FItemPartsInfo& Info);
	static int32 GetFireReduce(const struct FItemPartsInfo& Info);
	static int32 GetImpactDebuffResist(const struct FItemPartsInfo& Info);
	static ELItemMaterial GetMaterialType(const struct FItemPartsInfo& Info);
	static int32 GetPhysicalPierceReduce(const struct FItemPartsInfo& Info);
	static int32 GetPhysicalReduce(const struct FItemPartsInfo& Info);
	static int32 GetPhysicalSlashReduce(const struct FItemPartsInfo& Info);
	static int32 GetPhysicalStrikeReduce(const struct FItemPartsInfo& Info);
	static int32 GetTough(const struct FItemPartsInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPartsInfoFuncLibrary">();
	}
	static class UItemPartsInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPartsInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemPartsInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemPartsInfoFuncLibrary");
static_assert(sizeof(UItemPartsInfoFuncLibrary) == 0x000028, "Wrong size on UItemPartsInfoFuncLibrary");

// Class ProjectPContentInfo.ItemCollectionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemCollectionInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAcquisitionHumanityPlayTime(const struct FItemCollectionInfo& Info);
	static int32 GetAcquisitionHumanityPoint(const struct FItemCollectionInfo& Info);
	static float GetBgmDuration(const struct FItemCollectionInfo& Info);
	static const TSoftObjectPtr<class UObject> GetBgmResource(const struct FItemCollectionInfo& Info);
	static const class FName GetCodeName(const struct FItemCollectionInfo& Info);
	static int32 GetCommandExecTime(const struct FItemCollectionInfo& Info);
	static const class FName GetContentCommandCodename(const struct FItemCollectionInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImageResource(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent1(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent10(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent10Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent10Localize(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent1Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent1Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent2(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent2Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent2Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent3(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent3Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent3Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent4(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent4Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent4Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent5(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent5Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent5Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent6(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent6Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent6Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent7(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent7Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent7Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent8(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent8Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent8Localize(const struct FItemCollectionInfo& Info);
	static class FString GetLocalTextContent9(const struct FItemCollectionInfo& Info);
	static const class FName GetLocalTextContent9Cn(const struct FItemCollectionInfo& Info);
	static class FText GetLocalTextContent9Localize(const struct FItemCollectionInfo& Info);
	static int32 GetPageMax(const struct FItemCollectionInfo& Info);
	static int32 GetRecordListOrder(const struct FItemCollectionInfo& Info);
	static ELItemCollectionType GetType(const struct FItemCollectionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCollectionInfoFuncLibrary">();
	}
	static class UItemCollectionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCollectionInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemCollectionInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemCollectionInfoFuncLibrary");
static_assert(sizeof(UItemCollectionInfoFuncLibrary) == 0x000028, "Wrong size on UItemCollectionInfoFuncLibrary");

// Class ProjectPContentInfo.ItemConsumeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemConsumeInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetBuffCodeName(const struct FItemConsumeInfo& Info);
	static const class FName GetCancelAbnormalCodeName(const struct FItemConsumeInfo& Info);
	static int32 GetCancelAbnormalDebuildupValue(const struct FItemConsumeInfo& Info);
	static const class FName GetCancelAbnormalGroupName(const struct FItemConsumeInfo& Info);
	static const class FName GetCodeName(const struct FItemConsumeInfo& Info);
	static ELItemComplexGroup GetComplexGroup(const struct FItemConsumeInfo& Info);
	static ELItemComplexType GetComplexType(const struct FItemConsumeInfo& Info);
	static int32 GetDefaultMaxCharge(const struct FItemConsumeInfo& Info);
	static bool GetForceUse(const struct FItemConsumeInfo& Info);
	static const class FName GetForceUseDesc(const struct FItemConsumeInfo& Info);
	static const class FName GetFxCommonCodeName(const struct FItemConsumeInfo& Info);
	static class FString GetFxSocket(const struct FItemConsumeInfo& Info);
	static int32 GetIncreaseWealthAmount(const struct FItemConsumeInfo& Info);
	static bool GetIsLocationFx(const struct FItemConsumeInfo& Info);
	static bool GetIsToggle(const struct FItemConsumeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetItemMesh(const struct FItemConsumeInfo& Info);
	static const class FName GetItemMeshSocket(const struct FItemConsumeInfo& Info);
	static bool GetKeepToggleDead(const struct FItemConsumeInfo& Info);
	static bool GetKeepToggleRespawn(const struct FItemConsumeInfo& Info);
	static int32 GetMaxChargeLimit(const struct FItemConsumeInfo& Info);
	static const class FName GetProjectileCodeName(const struct FItemConsumeInfo& Info);
	static const class FName GetPulseRechargedAbnormalCodeName(const struct FItemConsumeInfo& Info);
	static bool GetRecallToTorsionCoil(const struct FItemConsumeInfo& Info);
	static bool GetRechargeable(const struct FItemConsumeInfo& Info);
	static bool GetRequireHelpmateCombat(const struct FItemConsumeInfo& Info);
	static bool GetRequireWeapon(const struct FItemConsumeInfo& Info);
	static const TArray<struct FActionStateType> GetRestrictActionStateArray(const struct FItemConsumeInfo& Info);
	static int32 GetSharpnessRecoveryPoint(const struct FItemConsumeInfo& Info);
	static const class FName GetSlavearmAlterItemMatch(const struct FItemConsumeInfo& Info);
	static bool GetStackUse(const struct FItemConsumeInfo& Info);
	static ELItemConsumeTargetType GetTargetType(const struct FItemConsumeInfo& Info);
	static bool GetUnconsumable(const struct FItemConsumeInfo& Info);
	static ELItemUnitUseType GetUnitUseType(const struct FItemConsumeInfo& Info);
	static bool GetUseItemInventoryState(const struct FItemConsumeInfo& Info);
	static const class FName GetUseSkillCodeName(const struct FItemConsumeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemConsumeInfoFuncLibrary">();
	}
	static class UItemConsumeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemConsumeInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemConsumeInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemConsumeInfoFuncLibrary");
static_assert(sizeof(UItemConsumeInfoFuncLibrary) == 0x000028, "Wrong size on UItemConsumeInfoFuncLibrary");

// Class ProjectPContentInfo.BladeWeightInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UBladeWeightInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetChargeMontageSlot(const struct FBladeWeightInfo& Info);
	static float GetChargePlayRate(const struct FBladeWeightInfo& Info);
	static const class FName GetCodeName(const struct FBladeWeightInfo& Info);
	static const class FName GetDelayMontageSlot(const struct FBladeWeightInfo& Info);
	static float GetDelayPlayRate(const struct FBladeWeightInfo& Info);
	static const class FName GetEndMontageSlot(const struct FBladeWeightInfo& Info);
	static float GetEndPlayRate(const struct FBladeWeightInfo& Info);
	static int32 GetHitAnimDurationRatio(const struct FBladeWeightInfo& Info);
	static const class FName GetIntroMontageSlot(const struct FBladeWeightInfo& Info);
	static float GetIntroPlayRate(const struct FBladeWeightInfo& Info);
	static int32 GetKnockbackDistanceRatio(const struct FBladeWeightInfo& Info);
	static int32 GetStaminaConsumeRatio(const struct FBladeWeightInfo& Info);
	static const class FName GetSwingMontageSlot(const struct FBladeWeightInfo& Info);
	static float GetSwingPlayRate(const struct FBladeWeightInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BladeWeightInfoFuncLibrary">();
	}
	static class UBladeWeightInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBladeWeightInfoFuncLibrary>();
	}
};
static_assert(alignof(UBladeWeightInfoFuncLibrary) == 0x000008, "Wrong alignment on UBladeWeightInfoFuncLibrary");
static_assert(sizeof(UBladeWeightInfoFuncLibrary) == 0x000028, "Wrong size on UBladeWeightInfoFuncLibrary");

// Class ProjectPContentInfo.ItemWeaponMonsterFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemWeaponMonsterFuncLibrary final : public UObject
{
public:
	static const class FName GetAddSkillHitCodeName(const struct FItemWeaponMonster& Info);
	static int32 GetAddSkillRangeAfterBroken(const struct FItemWeaponMonster& Info);
	static const class FName GetBrokenSwingSoundCodename(const struct FItemWeaponMonster& Info);
	static const class FName GetCodeName(const struct FItemWeaponMonster& Info);
	static int32 GetCriticalRate(const struct FItemWeaponMonster& Info);
	static int32 GetDurability(const struct FItemWeaponMonster& Info);
	static ELElementDamageType GetElementDamageType(const struct FItemWeaponMonster& Info);
	static int32 GetGuardAciddamageReductionRatio(const struct FItemWeaponMonster& Info);
	static int32 GetGuardDurabilityDefence(const struct FItemWeaponMonster& Info);
	static int32 GetGuardElectricdamageReductionRatio(const struct FItemWeaponMonster& Info);
	static int32 GetGuardFiredamageReductionRatio(const struct FItemWeaponMonster& Info);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FItemWeaponMonster& Info);
	static int32 GetGuardKnockbackDurationReductionRatio(const struct FItemWeaponMonster& Info);
	static int32 GetGuardPhysicaldamageReductionRatio(const struct FItemWeaponMonster& Info);
	static int32 GetGuardPoint(const struct FItemWeaponMonster& Info);
	static int32 GetGuardSuccessDurabilityReductionRatio(const struct FItemWeaponMonster& Info);
	static bool GetHideAtSpawn(const struct FItemWeaponMonster& Info);
	static ELSwingPowerType GetHitFxLevel(const struct FItemWeaponMonster& Info);
	static int32 GetMinimumSkillRangeMaxAfterBroken(const struct FItemWeaponMonster& Info);
	static int32 GetMinimumSkillRangeMinAfterBroken(const struct FItemWeaponMonster& Info);
	static int32 GetMulpleRateAtkPowerAfterBoken(const struct FItemWeaponMonster& Info);
	static int32 GetMulpleRateDestructionPowerAfterBroken(const struct FItemWeaponMonster& Info);
	static int32 GetMulpleRateRigidityAfterBoken(const struct FItemWeaponMonster& Info);
	static int32 GetNGPDetailIndex(const struct FItemWeaponMonster& Info);
	static ELPhysicalDamageType GetPhysicalSubtypeWithSwing(const struct FItemWeaponMonster& Info);
	static ELPhysicalDamageType GetPhysicalSubtypeWithThrust(const struct FItemWeaponMonster& Info);
	static bool GetRemoveAbnormalStateAfterBroken(const struct FItemWeaponMonster& Info);
	static int32 GetRigidity(const struct FItemWeaponMonster& Info);
	static const class FName GetSkillhitAbnormalStateOverride(const struct FItemWeaponMonster& Info);
	static const class FName GetSwingSoundCodename(const struct FItemWeaponMonster& Info);
	static int32 GetToughRecoveryDelayTime(const struct FItemWeaponMonster& Info);
	static bool GetUseBluntTrail(const struct FItemWeaponMonster& Info);
	static const class FName GetWeaponBpCodeName(const struct FItemWeaponMonster& Info);
	static const class FName GetWeaponEquipAbnormalStateCodeName(const struct FItemWeaponMonster& Info);
	static int32 GetWeaponEquipAtkPowerRate(const struct FItemWeaponMonster& Info);
	static int32 GetWeaponEquipMotionSpeedRate(const struct FItemWeaponMonster& Info);
	static int32 GetWeaponEquipMotionSpeedRateAfterBroken(const struct FItemWeaponMonster& Info);
	static int32 GetWeaponEquipSkillRangeMaxRate(const struct FItemWeaponMonster& Info);
	static int32 GetWeaponEquipSkillRangeMinRate(const struct FItemWeaponMonster& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWeaponMonsterFuncLibrary">();
	}
	static class UItemWeaponMonsterFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWeaponMonsterFuncLibrary>();
	}
};
static_assert(alignof(UItemWeaponMonsterFuncLibrary) == 0x000008, "Wrong alignment on UItemWeaponMonsterFuncLibrary");
static_assert(sizeof(UItemWeaponMonsterFuncLibrary) == 0x000028, "Wrong size on UItemWeaponMonsterFuncLibrary");

// Class ProjectPContentInfo.ItemSlaveArmInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemSlaveArmInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FItemSlaveArmInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FItemSlaveArmInfo& Info);
	static const class FName GetActionGroupTableCodeName(const struct FItemSlaveArmInfo& Info);
	static int32 GetAdditionalGroggyTime(const struct FItemSlaveArmInfo& Info);
	static int32 GetAmmoMax(const struct FItemSlaveArmInfo& Info);
	static int32 GetAmmoReloadAmount(const struct FItemSlaveArmInfo& Info);
	static int32 GetAmmoReloadCooltime(const struct FItemSlaveArmInfo& Info);
	static int32 GetAttackGainFrenzyPointActive(const struct FItemSlaveArmInfo& Info);
	static int32 GetAttackGainFrenzyPointPassive(const struct FItemSlaveArmInfo& Info);
	static const class FName GetCodeName(const struct FItemSlaveArmInfo& Info);
	static bool GetConsumeCommand(const struct FItemSlaveArmInfo& Info);
	static int32 GetConsumeStaminaPoint(const struct FItemSlaveArmInfo& Info);
	static const class FName GetCorrectionCodeNameForAdvance(const struct FItemSlaveArmInfo& Info);
	static const class FName GetCorrectionCodeNameForMotivity(const struct FItemSlaveArmInfo& Info);
	static const class FName GetCorrectionCodeNameForTechnique(const struct FItemSlaveArmInfo& Info);
	static int32 GetDestructionDefence(const struct FItemSlaveArmInfo& Info);
	static int32 GetDestructionReduce(const struct FItemSlaveArmInfo& Info);
	static const TSoftObjectPtr<class USkeletalMesh> GetMesh(const struct FItemSlaveArmInfo& Info);
	static const TArray<class FName> GetPreloadProjectileList(const struct FItemSlaveArmInfo& Info);
	static const TArray<class FName> GetPreloadSkillList(const struct FItemSlaveArmInfo& Info);
	static int32 GetPulseRechargeAttack(const struct FItemSlaveArmInfo& Info);
	static ELReserveType GetReserveType(const struct FItemSlaveArmInfo& Info);
	static int32 GetRigidity(const struct FItemSlaveArmInfo& Info);
	static const class FName GetSkillActionPathCodeName(const struct FItemSlaveArmInfo& Info);
	static const class FName GetSkillCodeName(const struct FItemSlaveArmInfo& Info);
	static int32 GetSlavearmAcidAttack(const struct FItemSlaveArmInfo& Info);
	static int32 GetSlavearmDestructionPower(const struct FItemSlaveArmInfo& Info);
	static int32 GetSlavearmElectricAttack(const struct FItemSlaveArmInfo& Info);
	static int32 GetSlavearmFireAttack(const struct FItemSlaveArmInfo& Info);
	static int32 GetSlaveArmPhysicalAttack(const struct FItemSlaveArmInfo& Info);
	static int32 GetToughRecoveryDelayTime(const struct FItemSlaveArmInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlaveArmInfoFuncLibrary">();
	}
	static class UItemSlaveArmInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSlaveArmInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemSlaveArmInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemSlaveArmInfoFuncLibrary");
static_assert(sizeof(UItemSlaveArmInfoFuncLibrary) == 0x000028, "Wrong size on UItemSlaveArmInfoFuncLibrary");

// Class ProjectPContentInfo.ItemHandleInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemHandleInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetActionGroupTableCodeName(const struct FItemHandleInfo& Info);
	static const TArray<ELBladeShapeType> GetAllowBladeShapeType(const struct FItemHandleInfo& Info);
	static int32 GetAttackSpeed(const struct FItemHandleInfo& Info);
	static const class FName GetBladeWeightCodeName(const struct FItemHandleInfo& Info);
	static float GetChargePlayRateMax(const struct FItemHandleInfo& Info);
	static float GetChargePlayRateMin(const struct FItemHandleInfo& Info);
	static const class FName GetCodeName(const struct FItemHandleInfo& Info);
	static const class FName GetComboType(const struct FItemHandleInfo& Info);
	static const class FName GetCommonActionPathCodeName(const struct FItemHandleInfo& Info);
	static const class FName GetCorrectionCodeNameForAdvance(const struct FItemHandleInfo& Info);
	static const class FName GetCorrectionCodeNameForMotivity(const struct FItemHandleInfo& Info);
	static const class FName GetCorrectionCodeNameForTechnique(const struct FItemHandleInfo& Info);
	static float GetDelayPlayRateMax(const struct FItemHandleInfo& Info);
	static float GetDelayPlayRateMin(const struct FItemHandleInfo& Info);
	static float GetDestructionDefence(const struct FItemHandleInfo& Info);
	static float GetDestructionReduce(const struct FItemHandleInfo& Info);
	static float GetEndPlayRateMax(const struct FItemHandleInfo& Info);
	static float GetEndPlayRateMin(const struct FItemHandleInfo& Info);
	static const class FName GetFrenzySkillCodeName(const struct FItemHandleInfo& Info);
	static int32 GetGuardDurationRatio(const struct FItemHandleInfo& Info);
	static int32 GetGuardGainFrenzyPointActive(const struct FItemHandleInfo& Info);
	static int32 GetGuardGainFrenzyPointPassive(const struct FItemHandleInfo& Info);
	static int32 GetGuardIntensity(const struct FItemHandleInfo& Info);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FItemHandleInfo& Info);
	static const class FName GetGuardParryCounterSkillCodeName(const struct FItemHandleInfo& Info);
	static int32 GetGuardPoint(const struct FItemHandleInfo& Info);
	static int32 GetGuardRegainRatio(const struct FItemHandleInfo& Info);
	static int32 GetGuardStaminaReductionRatio(const struct FItemHandleInfo& Info);
	static const class FName GetHandleNeedStatLackAbnormalStateCodeName(const struct FItemHandleInfo& Info);
	static int32 GetHandleNeedStatLackAtkRatio(const struct FItemHandleInfo& Info);
	static int32 GetHandleNeedStatLackGuardSaveStaminaRatio(const struct FItemHandleInfo& Info);
	static bool GetHaveSwingMotion(const struct FItemHandleInfo& Info);
	static bool GetHaveThrustMotion(const struct FItemHandleInfo& Info);
	static bool GetHeroicWeapon(const struct FItemHandleInfo& Info);
	static float GetIntroPlayRateMax(const struct FItemHandleInfo& Info);
	static float GetIntroPlayRateMin(const struct FItemHandleInfo& Info);
	static class FString GetLocalTextByname(const struct FItemHandleInfo& Info);
	static const class FName GetLocalTextBynameCn(const struct FItemHandleInfo& Info);
	static class FText GetLocalTextBynameLocalize(const struct FItemHandleInfo& Info);
	static const class FName GetLocomotionActionPathCodeName(const struct FItemHandleInfo& Info);
	static int32 GetNecessityAdvance(const struct FItemHandleInfo& Info);
	static int32 GetNecessityMotivity(const struct FItemHandleInfo& Info);
	static int32 GetNecessityTechnique(const struct FItemHandleInfo& Info);
	static const class FName GetOriginalBladeCodeName(const struct FItemHandleInfo& Info);
	static int32 GetPerfectGuardDecreaseEnemyWeaponDurability(const struct FItemHandleInfo& Info);
	static int32 GetPerfectGuardGainFrenzyPointActive(const struct FItemHandleInfo& Info);
	static int32 GetPerfectGuardGainFrenzyPointPassive(const struct FItemHandleInfo& Info);
	static int32 GetPerfectGuardGainFrenzyPointRatioFuryattack(const struct FItemHandleInfo& Info);
	static ELWeaponPostureType GetPostureType(const struct FItemHandleInfo& Info);
	static const TArray<class FName> GetPreloadSkillList(const struct FItemHandleInfo& Info);
	static const TArray<class FName> GetPreloadWeaponList(const struct FItemHandleInfo& Info);
	static const class FName GetReinforceTableCodeName(const struct FItemHandleInfo& Info);
	static int32 GetRigidity(const struct FItemHandleInfo& Info);
	static ELWeaponShapeType GetShapeType(const struct FItemHandleInfo& Info);
	static int32 GetSharpnessBadPointMod(const struct FItemHandleInfo& Info);
	static int32 GetSharpnessFinePointMod(const struct FItemHandleInfo& Info);
	static int32 GetSharpnessNormalPointMod(const struct FItemHandleInfo& Info);
	static const class FName GetSkillActionPathCodeName(const struct FItemHandleInfo& Info);
	static float GetStaminaConsumeRatioMax(const struct FItemHandleInfo& Info);
	static float GetStaminaConsumeRatioMin(const struct FItemHandleInfo& Info);
	static ELWeaponStyleType GetStyleType(const struct FItemHandleInfo& Info);
	static float GetSwingPlayRateMax(const struct FItemHandleInfo& Info);
	static float GetSwingPlayRateMin(const struct FItemHandleInfo& Info);
	static const class FName GetSwingSoundCodename(const struct FItemHandleInfo& Info);
	static const class FName GetWeaponBpCodeName(const struct FItemHandleInfo& Info);
	static int32 GetWeaponCombineCost(const struct FItemHandleInfo& Info);
	static const class FName GetWeaponCombineItemCodeName(const struct FItemHandleInfo& Info);
	static int32 GetWeaponCombineItemCount(const struct FItemHandleInfo& Info);
	static int32 GetWeaponDivideCost(const struct FItemHandleInfo& Info);
	static const class FName GetWeaponDivideItemCodeName(const struct FItemHandleInfo& Info);
	static int32 GetWeaponDivideItemCount(const struct FItemHandleInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemHandleInfoFuncLibrary">();
	}
	static class UItemHandleInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemHandleInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemHandleInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemHandleInfoFuncLibrary");
static_assert(sizeof(UItemHandleInfoFuncLibrary) == 0x000028, "Wrong size on UItemHandleInfoFuncLibrary");

// Class ProjectPContentInfo.ItemBladeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemBladeInfoFuncLibrary final : public UObject
{
public:
	static bool GetAbnormalElementDisable(const struct FItemBladeInfo& Info);
	static bool GetAbnormalEnchantDisable(const struct FItemBladeInfo& Info);
	static int32 GetAbnormalStateBuildUpAttack(const struct FItemBladeInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FItemBladeInfo& Info);
	static ELActionCategory GetActionCategory(const struct FItemBladeInfo& Info);
	static int32 GetAdditionalGroggyTime(const struct FItemBladeInfo& Info);
	static int32 GetAttackGainFrenzyPointActive(const struct FItemBladeInfo& Info);
	static int32 GetAttackGainFrenzyPointPassive(const struct FItemBladeInfo& Info);
	static int32 GetAttackSpeed(const struct FItemBladeInfo& Info);
	static const class FName GetBladeNeedStatLackAbnormalStateCodeName(const struct FItemBladeInfo& Info);
	static int32 GetBladeNeedStatLackAtkRatio(const struct FItemBladeInfo& Info);
	static int32 GetBladeNeedStatLackDestructionRatio(const struct FItemBladeInfo& Info);
	static int32 GetBladeNeedStatLackStaminaRatio(const struct FItemBladeInfo& Info);
	static ELBladeShapeType GetBladeShapeType(const struct FItemBladeInfo& Info);
	static const class FName GetBladeWeightCodeName(const struct FItemBladeInfo& Info);
	static const class FName GetCodeName(const struct FItemBladeInfo& Info);
	static int32 GetConsumeErgoCount(const struct FItemBladeInfo& Info);
	static int32 GetConsumeErgoRate(const struct FItemBladeInfo& Info);
	static int32 GetConsumeStaminaPoint(const struct FItemBladeInfo& Info);
	static ELCrashType GetCrashType(const struct FItemBladeInfo& Info);
	static int32 GetCriticalRate(const struct FItemBladeInfo& Info);
	static const class FName GetDashParryCounterSkillCodeName(const struct FItemBladeInfo& Info);
	static float GetDestructionDefence(const struct FItemBladeInfo& Info);
	static int32 GetDestructionPower(const struct FItemBladeInfo& Info);
	static float GetDestructionReduce(const struct FItemBladeInfo& Info);
	static int32 GetElementalAttack(const struct FItemBladeInfo& Info);
	static ELElementDamageType GetElementAttackType(const struct FItemBladeInfo& Info);
	static const class FName GetErgoFrenzySkillCodeName(const struct FItemBladeInfo& Info);
	static int32 GetFatalDamageRatio(const struct FItemBladeInfo& Info);
	static ELBladeFatalType GetFatalType(const struct FItemBladeInfo& Info);
	static const class FName GetFrenzySkillCodeName(const struct FItemBladeInfo& Info);
	static int32 GetGuardDamageReductionRatio(const struct FItemBladeInfo& Info);
	static int32 GetGuardDurabilityAttack(const struct FItemBladeInfo& Info);
	static int32 GetGuardDurationRatio(const struct FItemBladeInfo& Info);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FItemBladeInfo& Info);
	static int32 GetGuardPoint(const struct FItemBladeInfo& Info);
	static int32 GetGuardRegainAttackHeal(const struct FItemBladeInfo& Info);
	static int32 GetGuardRegainPerfectGuardHeal(const struct FItemBladeInfo& Info);
	static int32 GetGuardRegainPointMaxRatio(const struct FItemBladeInfo& Info);
	static int32 GetGuardSharpnessDefence(const struct FItemBladeInfo& Info);
	static ELSwingPowerType GetHitFxLevel(const struct FItemBladeInfo& Info);
	static ELPhysicalSurfaceType GetHitMaterial(const struct FItemBladeInfo& Info);
	static class FString GetLocalTextByname(const struct FItemBladeInfo& Info);
	static const class FName GetLocalTextBynameCn(const struct FItemBladeInfo& Info);
	static class FText GetLocalTextBynameLocalize(const struct FItemBladeInfo& Info);
	static int32 GetNecessityAdvance(const struct FItemBladeInfo& Info);
	static int32 GetNecessityMotivity(const struct FItemBladeInfo& Info);
	static int32 GetNecessityTechnique(const struct FItemBladeInfo& Info);
	static int32 GetPerfectGuardDecreaseEnemyWeaponDurability(const struct FItemBladeInfo& Info);
	static int32 GetPerfectguardDestructionPower(const struct FItemBladeInfo& Info);
	static int32 GetPhysicalAttack(const struct FItemBladeInfo& Info);
	static ELPhysicalDamageType GetPhysicalSubtypeWithSwing(const struct FItemBladeInfo& Info);
	static int32 GetPhysicalSubtypeWithSwingMod(const struct FItemBladeInfo& Info);
	static ELPhysicalDamageType GetPhysicalSubtypeWithThrust(const struct FItemBladeInfo& Info);
	static int32 GetPhysicalSubtypeWithThrustMod(const struct FItemBladeInfo& Info);
	static const TArray<class FName> GetPreloadProjectileList(const struct FItemBladeInfo& Info);
	static const TArray<class FName> GetPreloadSkillList(const struct FItemBladeInfo& Info);
	static const TArray<class FName> GetPreloadWeaponList(const struct FItemBladeInfo& Info);
	static const class FName GetProjectileCodeName(const struct FItemBladeInfo& Info);
	static int32 GetPulseRechargeAttack(const struct FItemBladeInfo& Info);
	static const class FName GetReinforceTableCodeName(const struct FItemBladeInfo& Info);
	static int32 GetRepairRatioPerSecond(const struct FItemBladeInfo& Info);
	static int32 GetRequireErgoCount(const struct FItemBladeInfo& Info);
	static int32 GetRigidity(const struct FItemBladeInfo& Info);
	static ELWeaponShapeType GetShapeType(const struct FItemBladeInfo& Info);
	static const class FName GetSharpnessBadAbnormalstate(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessBadAttackMod(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessBadPoint(const struct FItemBladeInfo& Info);
	static const class FName GetSharpnessBreakAbnormalstate(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessBreakAttackMod(const struct FItemBladeInfo& Info);
	static const class FName GetSharpnessFineAbnormalstate(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessFineAttackMod(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessFinePoint(const struct FItemBladeInfo& Info);
	static const class FName GetSharpnessNormalAbnormalstate(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessNormalAttackMod(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessNormalPoint(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessReduceValueRatio(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessReduceValueRatioOnGuard(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessRepulseLevelBad(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessRepulseLevelBreak(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessRepulseLevelFine(const struct FItemBladeInfo& Info);
	static int32 GetSharpnessRepulseLevelNormal(const struct FItemBladeInfo& Info);
	static float GetStiffenPlayrateAttacker(const struct FItemBladeInfo& Info);
	static float GetStiffenPlayrateDefender(const struct FItemBladeInfo& Info);
	static const class FName GetSwingSoundCodename(const struct FItemBladeInfo& Info);
	static int32 GetToughRecoveryDelayTime(const struct FItemBladeInfo& Info);
	static bool GetUseBluntTrail(const struct FItemBladeInfo& Info);
	static const class FName GetWeaponBpCodeName(const struct FItemBladeInfo& Info);
	static int32 GetWeaponCombineCost(const struct FItemBladeInfo& Info);
	static const class FName GetWeaponCombineItemCodeName(const struct FItemBladeInfo& Info);
	static int32 GetWeaponCombineItemCount(const struct FItemBladeInfo& Info);
	static int32 GetWeaponDivideCost(const struct FItemBladeInfo& Info);
	static const class FName GetWeaponDivideItemCodeName(const struct FItemBladeInfo& Info);
	static int32 GetWeaponDivideItemCount(const struct FItemBladeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBladeInfoFuncLibrary">();
	}
	static class UItemBladeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemBladeInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemBladeInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemBladeInfoFuncLibrary");
static_assert(sizeof(UItemBladeInfoFuncLibrary) == 0x000028, "Wrong size on UItemBladeInfoFuncLibrary");

// Class ProjectPContentInfo.ItemWeaponReinforceInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemWeaponReinforceInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FItemWeaponReinforceInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetAcidAttackMod(const struct FItemWeaponReinforceInfo& Info);
	static const class FName GetCodeName(const struct FItemWeaponReinforceInfo& Info);
	static class FString GetCorrectionCodeNameForAdvance(const struct FItemWeaponReinforceInfo& Info);
	static class FString GetCorrectionCodeNameForMotivity(const struct FItemWeaponReinforceInfo& Info);
	static class FString GetCorrectionCodeNameForTechnique(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetElectricAttackMod(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetFireAttackMod(const struct FItemWeaponReinforceInfo& Info);
	static ELWeaponCorrectionPhysicalGrade GetFirstStatCorrectionAdvance(const struct FItemWeaponReinforceInfo& Info);
	static ELWeaponCorrectionPhysicalGrade GetFirstStatCorrectionMotivity(const struct FItemWeaponReinforceInfo& Info);
	static ELWeaponCorrectionPhysicalGrade GetFirstStatCorrectionTechnique(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetGrade(const struct FItemWeaponReinforceInfo& Info);
	static class FString GetLocalTextByname(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetNeedErgo(const struct FItemWeaponReinforceInfo& Info);
	static const class FName GetNeedItemCodeName(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetNeedItemNum(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetPhysicalAttackMod(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetSharpnessBadPoint(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetSharpnessBadPointMod(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetSharpnessFinePoint(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetSharpnessFinePointMod(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetSharpnessNormalPoint(const struct FItemWeaponReinforceInfo& Info);
	static int32 GetSharpnessNormalPointMod(const struct FItemWeaponReinforceInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWeaponReinforceInfoFuncLibrary">();
	}
	static class UItemWeaponReinforceInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemWeaponReinforceInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemWeaponReinforceInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemWeaponReinforceInfoFuncLibrary");
static_assert(sizeof(UItemWeaponReinforceInfoFuncLibrary) == 0x000028, "Wrong size on UItemWeaponReinforceInfoFuncLibrary");

// Class ProjectPContentInfo.HandleStatCorrectionChangeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UHandleStatCorrectionChangeInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAdvanceGradeChange(const struct FHandleStatCorrectionChangeInfo& Info);
	static const class FName GetCodeName(const struct FHandleStatCorrectionChangeInfo& Info);
	static const class FName GetKeyItemCodename(const struct FHandleStatCorrectionChangeInfo& Info);
	static const class FName GetKeyItemCodenameHero(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetKeyItemNumAToS(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetKeyItemNumBToA(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetKeyItemNumClear(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetKeyItemNumCToB(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetKeyItemNumDToC(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetKeyItemNumNoneToD(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetMotivityGradeChange(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetRequireErgo(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetRequireErgoHero(const struct FHandleStatCorrectionChangeInfo& Info);
	static int32 GetTechniqueGradeChange(const struct FHandleStatCorrectionChangeInfo& Info);
	static ELStatCorrectChangeType GetUpgradeStat(const struct FHandleStatCorrectionChangeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandleStatCorrectionChangeInfoFuncLibrary">();
	}
	static class UHandleStatCorrectionChangeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHandleStatCorrectionChangeInfoFuncLibrary>();
	}
};
static_assert(alignof(UHandleStatCorrectionChangeInfoFuncLibrary) == 0x000008, "Wrong alignment on UHandleStatCorrectionChangeInfoFuncLibrary");
static_assert(sizeof(UHandleStatCorrectionChangeInfoFuncLibrary) == 0x000028, "Wrong size on UHandleStatCorrectionChangeInfoFuncLibrary");

// Class ProjectPContentInfo.SlavearmAlterItemMatchInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlavearmAlterItemMatchInfoFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetAlterAction(const struct FSlavearmAlterItemMatchInfo& Info);
	static const class FName GetAlterConsumeItemCodename(const struct FSlavearmAlterItemMatchInfo& Info);
	static const class FName GetCodeName(const struct FSlavearmAlterItemMatchInfo& Info);
	static int32 GetRequireMagazine(const struct FSlavearmAlterItemMatchInfo& Info);
	static const class FName GetSlavearmCodename(const struct FSlavearmAlterItemMatchInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlavearmAlterItemMatchInfoFuncLibrary">();
	}
	static class USlavearmAlterItemMatchInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlavearmAlterItemMatchInfoFuncLibrary>();
	}
};
static_assert(alignof(USlavearmAlterItemMatchInfoFuncLibrary) == 0x000008, "Wrong alignment on USlavearmAlterItemMatchInfoFuncLibrary");
static_assert(sizeof(USlavearmAlterItemMatchInfoFuncLibrary) == 0x000028, "Wrong size on USlavearmAlterItemMatchInfoFuncLibrary");

// Class ProjectPContentInfo.ItemRedundancyExchangeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemRedundancyExchangeInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FItemRedundancyExchangeInfo& Info);
	static const class FName GetCodeNameExchange(const struct FItemRedundancyExchangeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRedundancyExchangeInfoFuncLibrary">();
	}
	static class UItemRedundancyExchangeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRedundancyExchangeInfoFuncLibrary>();
	}
};
static_assert(alignof(UItemRedundancyExchangeInfoFuncLibrary) == 0x000008, "Wrong alignment on UItemRedundancyExchangeInfoFuncLibrary");
static_assert(sizeof(UItemRedundancyExchangeInfoFuncLibrary) == 0x000028, "Wrong size on UItemRedundancyExchangeInfoFuncLibrary");

// Class ProjectPContentInfo.ItemInfoAsset
// 0x0548 (0x05C0 - 0x0078)
class alignas(0x10) UItemInfoAsset final : public UContentInfoAsset
{
public:
	struct FItemInfoDB                            ContentInfoDB;                                     // 0x0078(0x0540)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FBladeWeightInfoPtr FindBladeWeightInfoByNameBP(class FName CodeName);
	static struct FCorrectionWeaponFirstStatInfoPtr FindCorrectionWeaponFirstStatInfoByNameBP(class FName CodeName);
	static struct FHandleStatCorrectionChangeInfoPtr FindHandleStatCorrectionChangeInfoByNameBP(class FName CodeName);
	static struct FItemBladeInfoPtr FindItemBladeInfoByNameBP(class FName CodeName);
	static struct FItemCollectionInfoPtr FindItemCollectionInfoByNameBP(class FName CodeName);
	static struct FItemCommonInfoPtr FindItemCommonInfoByNameBP(class FName CodeName);
	static struct FItemConsumeInfoPtr FindItemConsumeInfoByNameBP(class FName CodeName);
	static struct FItemCostumeInfoPtr FindItemCostumeInfoByNameBP(class FName CodeName);
	static struct FItemHandleInfoPtr FindItemHandleInfoByNameBP(class FName CodeName);
	static struct FItemPartsInfoPtr FindItemPartsInfoByNameBP(class FName CodeName);
	static struct FItemRedundancyExchangeInfoPtr FindItemRedundancyExchangeInfoByNameBP(class FName CodeName);
	static struct FItemSlaveArmInfoPtr FindItemSlaveArmInfoByNameBP(class FName CodeName);
	static struct FItemWeaponMonsterPtr FindItemWeaponMonsterInfoByNameBP(class FName CodeName);
	static const TArray<struct FBladeWeightInfo> GetBladeWeightInfoArrayBP();
	static const TArray<struct FCorrectionWeaponFirstStatInfo> GetCorrectionWeaponFirstStatInfoArrayBP();
	static const TArray<struct FHandleStatCorrectionChangeInfo> GetHandleStatCorrectionChangeInfoArrayBP();
	static const TArray<struct FItemBladeInfo> GetItemBladeInfoArrayBP();
	static const TArray<struct FItemCollectionInfo> GetItemCollectionInfoArrayBP();
	static const TArray<struct FItemCommonInfo> GetItemCommonInfoArrayBP();
	static const TArray<struct FItemConsumeInfo> GetItemConsumeInfoArrayBP();
	static const TArray<struct FItemCostumeInfo> GetItemCostumeInfoArrayBP();
	static const TArray<struct FItemHandleInfo> GetItemHandleInfoArrayBP();
	static const TArray<struct FItemPartsInfo> GetItemPartsInfoArrayBP();
	static const TArray<struct FItemRedundancyExchangeInfo> GetItemRedundancyExchangeInfoArrayBP();
	static const TArray<struct FItemSlaveArmInfo> GetItemSlaveArmInfoArrayBP();
	static const TArray<struct FItemWeaponMonster> GetItemWeaponMonsterInfoArrayBP();
	static const TArray<struct FItemWeaponReinforceInfo> GetItemWeaponReinforceInfoArrayBP();
	static const TArray<struct FSlavearmAlterItemMatchInfo> GetSlavearmAlterItemMatchInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInfoAsset">();
	}
	static class UItemInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInfoAsset>();
	}
};
static_assert(alignof(UItemInfoAsset) == 0x000010, "Wrong alignment on UItemInfoAsset");
static_assert(sizeof(UItemInfoAsset) == 0x0005C0, "Wrong size on UItemInfoAsset");
static_assert(offsetof(UItemInfoAsset, ContentInfoDB) == 0x000078, "Member 'UItemInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ItemPackageInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemPackageInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FItemPackageInfoPtr& Ptr);
	static bool GetIsExist(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetItem1CodeName(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetItem1Count(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetItem2CodeName(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetItem2Count(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetItem3CodeName(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetItem3Count(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetItem4CodeName(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetItem4Count(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetItem5CodeName(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetItem5Count(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetItem6CodeName(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetItem6Count(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetNGPLink1(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetNGPLink2(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetNGPLink3(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetNGPLink4(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetNGPRoundForLink1(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetNGPRoundForLink2(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetNGPRoundForLink3(const struct FItemPackageInfoPtr& Ptr);
	static int32 GetNGPRoundForLink4(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetSpotCodeName(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetWeaponItem1Blade(const struct FItemPackageInfoPtr& Ptr);
	static const class FName GetWeaponItem1Handle(const struct FItemPackageInfoPtr& Ptr);
	static bool IsValid(const struct FItemPackageInfoPtr& Ptr);
	static void IsValidBranch(const struct FItemPackageInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPackageInfoPtrFuncLibrary">();
	}
	static class UItemPackageInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPackageInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UItemPackageInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UItemPackageInfoPtrFuncLibrary");
static_assert(sizeof(UItemPackageInfoPtrFuncLibrary) == 0x000028, "Wrong size on UItemPackageInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LevelSequenceInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelSequenceInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAfterCommandExec(const struct FLevelSequenceInfo& Info);
	static const class FName GetAfterPlayedSequencer(const struct FLevelSequenceInfo& Info);
	static bool GetAlignToCineCamera(const struct FLevelSequenceInfo& Info);
	static const class FName GetBeforePlayedSequencer(const struct FLevelSequenceInfo& Info);
	static bool GetBindingPlayer(const struct FLevelSequenceInfo& Info);
	static bool GetCanSave(const struct FLevelSequenceInfo& Info);
	static const class FName GetCodeName(const struct FLevelSequenceInfo& Info);
	static bool GetDisableCameraCuts(const struct FLevelSequenceInfo& Info);
	static bool GetFixCameraSpeed(const struct FLevelSequenceInfo& Info);
	static bool GetGameProcessPause(const struct FLevelSequenceInfo& Info);
	static bool GetHeadCostumeOff(const struct FLevelSequenceInfo& Info);
	static bool GetHideHud(const struct FLevelSequenceInfo& Info);
	static bool GetHidePlayer(const struct FLevelSequenceInfo& Info);
	static bool GetIsGrabSkill(const struct FLevelSequenceInfo& Info);
	static bool GetLockPlayerAction(const struct FLevelSequenceInfo& Info);
	static bool GetLockPlayerActionCameraEnable(const struct FLevelSequenceInfo& Info);
	static int32 GetLoopCount(const struct FLevelSequenceInfo& Info);
	static bool GetNoSkip(const struct FLevelSequenceInfo& Info);
	static bool GetPauseAtEnd(const struct FLevelSequenceInfo& Info);
	static bool GetPlayOnce(const struct FLevelSequenceInfo& Info);
	static bool GetRestoreState(const struct FLevelSequenceInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSequenceResource(const struct FLevelSequenceInfo& Info);
	static bool GetSetToBossLocation(const struct FLevelSequenceInfo& Info);
	static bool GetSetToPlayerLocation(const struct FLevelSequenceInfo& Info);
	static bool GetShowHud(const struct FLevelSequenceInfo& Info);
	static const class FName GetSkipSequencer(const struct FLevelSequenceInfo& Info);
	static const class FName GetSubtitleCodeName(const struct FLevelSequenceInfo& Info);
	static const class FName GetTogglePlayerSequencer(const struct FLevelSequenceInfo& Info);
	static bool GetUiBlock(const struct FLevelSequenceInfo& Info);
	static bool GetUiFadeout(const struct FLevelSequenceInfo& Info);
	static bool GetUseCinematicCamera(const struct FLevelSequenceInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelSequenceInfoFuncLibrary">();
	}
	static class ULevelSequenceInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelSequenceInfoFuncLibrary>();
	}
};
static_assert(alignof(ULevelSequenceInfoFuncLibrary) == 0x000008, "Wrong alignment on ULevelSequenceInfoFuncLibrary");
static_assert(sizeof(ULevelSequenceInfoFuncLibrary) == 0x000028, "Wrong size on ULevelSequenceInfoFuncLibrary");

// Class ProjectPContentInfo.LevelSequenceInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) ULevelSequenceInfoAsset final : public UContentInfoAsset
{
public:
	struct FLevelSequenceInfoDB                   ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FLevelSequenceInfoPtr FindLevelSequenceInfoByNameBP(class FName CodeName);
	static const TArray<struct FLevelSequenceInfo> GetLevelSequenceInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelSequenceInfoAsset">();
	}
	static class ULevelSequenceInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelSequenceInfoAsset>();
	}
};
static_assert(alignof(ULevelSequenceInfoAsset) == 0x000010, "Wrong alignment on ULevelSequenceInfoAsset");
static_assert(sizeof(ULevelSequenceInfoAsset) == 0x000120, "Wrong size on ULevelSequenceInfoAsset");
static_assert(offsetof(ULevelSequenceInfoAsset, ContentInfoDB) == 0x000078, "Member 'ULevelSequenceInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.LoadingScreenInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULoadingScreenInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FLoadingScreenInfoPtr& Ptr);
	static ELConditionLoadingType GetConditionLoadingType(const struct FLoadingScreenInfoPtr& Ptr);
	static class FString GetConditionNextChapter(const struct FLoadingScreenInfoPtr& Ptr);
	static const class FName GetConditionQuest(const struct FLoadingScreenInfoPtr& Ptr);
	static const TArray<class FName> GetFirstDrawChainTip(const struct FLoadingScreenInfoPtr& Ptr);
	static bool GetFirstDrawPriority(const struct FLoadingScreenInfoPtr& Ptr);
	static const class FName GetImageCodeName(const struct FLoadingScreenInfoPtr& Ptr);
	static bool GetResetConditionNewGamePlus(const struct FLoadingScreenInfoPtr& Ptr);
	static bool IsValid(const struct FLoadingScreenInfoPtr& Ptr);
	static void IsValidBranch(const struct FLoadingScreenInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenInfoPtrFuncLibrary">();
	}
	static class ULoadingScreenInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULoadingScreenInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULoadingScreenInfoPtrFuncLibrary");
static_assert(sizeof(ULoadingScreenInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULoadingScreenInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LoadingTipInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULoadingTipInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FLoadingTipInfoPtr& Ptr);
	static ELConditionLoadingType GetConditionLoadingType(const struct FLoadingTipInfoPtr& Ptr);
	static const class FName GetConditionQuest(const struct FLoadingTipInfoPtr& Ptr);
	static bool GetResetConditionNewGamePlus(const struct FLoadingTipInfoPtr& Ptr);
	static const class FName GetTextCodeName(const struct FLoadingTipInfoPtr& Ptr);
	static bool IsValid(const struct FLoadingTipInfoPtr& Ptr);
	static void IsValidBranch(const struct FLoadingTipInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingTipInfoPtrFuncLibrary">();
	}
	static class ULoadingTipInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingTipInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULoadingTipInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULoadingTipInfoPtrFuncLibrary");
static_assert(sizeof(ULoadingTipInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULoadingTipInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LocalDataInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULocalDataInfoFuncLibrary final : public UObject
{
public:
	static class FString GetChineseSimplified(const struct FLocalDataInfo& Info);
	static class FString GetChineseTraditional(const struct FLocalDataInfo& Info);
	static const class FName GetCodeName(const struct FLocalDataInfo& Info);
	static class FString GetEnglish(const struct FLocalDataInfo& Info);
	static class FString GetFrench(const struct FLocalDataInfo& Info);
	static class FString GetGerman(const struct FLocalDataInfo& Info);
	static class FString GetItalian(const struct FLocalDataInfo& Info);
	static class FString GetJapanese(const struct FLocalDataInfo& Info);
	static class FString GetKorean(const struct FLocalDataInfo& Info);
	static class FText GetKoreanLocalize(const struct FLocalDataInfo& Info);
	static class FString GetPolish(const struct FLocalDataInfo& Info);
	static class FString GetPortuguese(const struct FLocalDataInfo& Info);
	static class FString GetRussian(const struct FLocalDataInfo& Info);
	static class FString GetSpanish(const struct FLocalDataInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalDataInfoFuncLibrary">();
	}
	static class ULocalDataInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalDataInfoFuncLibrary>();
	}
};
static_assert(alignof(ULocalDataInfoFuncLibrary) == 0x000008, "Wrong alignment on ULocalDataInfoFuncLibrary");
static_assert(sizeof(ULocalDataInfoFuncLibrary) == 0x000028, "Wrong size on ULocalDataInfoFuncLibrary");

// Class ProjectPContentInfo.LocalDataInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) ULocalDataInfoAsset final : public UContentInfoAsset
{
public:
	struct FLocalDataInfoDB                       ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FLocalDataInfoPtr FindLocalDataInfoByNameBP(class FName CodeName);
	static const TArray<struct FLocalDataInfo> GetLocalDataInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalDataInfoAsset">();
	}
	static class ULocalDataInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalDataInfoAsset>();
	}
};
static_assert(alignof(ULocalDataInfoAsset) == 0x000010, "Wrong alignment on ULocalDataInfoAsset");
static_assert(sizeof(ULocalDataInfoAsset) == 0x000120, "Wrong size on ULocalDataInfoAsset");
static_assert(offsetof(ULocalDataInfoAsset, ContentInfoDB) == 0x000078, "Member 'ULocalDataInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.LocationInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULocationInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FLocationInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FLocationInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FLocationInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FLocationInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLocationListImage(const struct FLocationInfoPtr& Ptr);
	static const class FName GetPersistentLevel(const struct FLocationInfoPtr& Ptr);
	static const class FName GetWorldZone(const struct FLocationInfoPtr& Ptr);
	static bool IsValid(const struct FLocationInfoPtr& Ptr);
	static void IsValidBranch(const struct FLocationInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocationInfoPtrFuncLibrary">();
	}
	static class ULocationInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocationInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULocationInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULocationInfoPtrFuncLibrary");
static_assert(sizeof(ULocationInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULocationInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PCLocomotionListInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPCLocomotionListInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAnimState(const struct FPCLocomotionListInfo& Info);
	static const class FName GetMachine(const struct FPCLocomotionListInfo& Info);
	static const class FName GetOverrideAnimName(const struct FPCLocomotionListInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCLocomotionListInfoFuncLibrary">();
	}
	static class UPCLocomotionListInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCLocomotionListInfoFuncLibrary>();
	}
};
static_assert(alignof(UPCLocomotionListInfoFuncLibrary) == 0x000008, "Wrong alignment on UPCLocomotionListInfoFuncLibrary");
static_assert(sizeof(UPCLocomotionListInfoFuncLibrary) == 0x000028, "Wrong size on UPCLocomotionListInfoFuncLibrary");

// Class ProjectPContentInfo.NPCLocomotionListInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCLocomotionListInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAnimState(const struct FNPCLocomotionListInfo& Info);
	static const class FName GetMachine(const struct FNPCLocomotionListInfo& Info);
	static const class FName GetOverrideAnimName(const struct FNPCLocomotionListInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCLocomotionListInfoFuncLibrary">();
	}
	static class UNPCLocomotionListInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCLocomotionListInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCLocomotionListInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCLocomotionListInfoFuncLibrary");
static_assert(sizeof(UNPCLocomotionListInfoFuncLibrary) == 0x000028, "Wrong size on UNPCLocomotionListInfoFuncLibrary");

// Class ProjectPContentInfo.LocomotionListInfoAsset
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) ULocomotionListInfoAsset final : public UContentInfoAsset
{
public:
	struct FLocomotionListInfoDB                  ContentInfoDB;                                     // 0x0078(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FNPCLocomotionListInfo> GetNPCLocomotionListInfoArrayBP();
	static const TArray<struct FPCLocomotionListInfo> GetPCLocomotionListInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionListInfoAsset">();
	}
	static class ULocomotionListInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionListInfoAsset>();
	}
};
static_assert(alignof(ULocomotionListInfoAsset) == 0x000010, "Wrong alignment on ULocomotionListInfoAsset");
static_assert(sizeof(ULocomotionListInfoAsset) == 0x0000E0, "Wrong size on ULocomotionListInfoAsset");
static_assert(offsetof(ULocomotionListInfoAsset, ContentInfoDB) == 0x000078, "Member 'ULocomotionListInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.MomentConditionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UMomentConditionInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FMomentConditionInfoPtr& Ptr);
	static EFactionType GetFaction(const struct FMomentConditionInfoPtr& Ptr);
	static ENPCGradeType GetGrade(const struct FMomentConditionInfoPtr& Ptr);
	static bool GetHitGroggy(const struct FMomentConditionInfoPtr& Ptr);
	static bool GetIsBack(const struct FMomentConditionInfoPtr& Ptr);
	static bool GetIsGroggy(const struct FMomentConditionInfoPtr& Ptr);
	static bool GetIsGroggyEnable(const struct FMomentConditionInfoPtr& Ptr);
	static bool GetIsSubSwing(const struct FMomentConditionInfoPtr& Ptr);
	static bool GetIsSubThrust(const struct FMomentConditionInfoPtr& Ptr);
	static ELMomentType GetMomentType(const struct FMomentConditionInfoPtr& Ptr);
	static const class FName GetNpcCodename(const struct FMomentConditionInfoPtr& Ptr);
	static ELNPCType GetNpcKind(const struct FMomentConditionInfoPtr& Ptr);
	static int32 GetSkillHitConditionGroup1(const struct FMomentConditionInfoPtr& Ptr);
	static int32 GetSkillHitConditionGroup2(const struct FMomentConditionInfoPtr& Ptr);
	static int32 GetSkillHitConditionGroup3(const struct FMomentConditionInfoPtr& Ptr);
	static int32 GetSkillHitConditionGroup4(const struct FMomentConditionInfoPtr& Ptr);
	static ELActionCategory GetUseSkillActionCategory(const struct FMomentConditionInfoPtr& Ptr);
	static const class FName GetUseSkillCodeName(const struct FMomentConditionInfoPtr& Ptr);
	static bool IsValid(const struct FMomentConditionInfoPtr& Ptr);
	static void IsValidBranch(const struct FMomentConditionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MomentConditionInfoPtrFuncLibrary">();
	}
	static class UMomentConditionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMomentConditionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UMomentConditionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UMomentConditionInfoPtrFuncLibrary");
static_assert(sizeof(UMomentConditionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UMomentConditionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.MovieResourceInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UMovieResourceInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAfterCommandExec(const struct FMovieResourceInfo& Info);
	static bool GetCanSave(const struct FMovieResourceInfo& Info);
	static const class FName GetCodeName(const struct FMovieResourceInfo& Info);
	static bool GetGameProcessPause(const struct FMovieResourceInfo& Info);
	static bool GetHideHud(const struct FMovieResourceInfo& Info);
	static bool GetLockPlayerAction(const struct FMovieResourceInfo& Info);
	static class FString GetMovieResource(const struct FMovieResourceInfo& Info);
	static class FString GetMovieResourceFhd(const struct FMovieResourceInfo& Info);
	static bool GetNoSkip(const struct FMovieResourceInfo& Info);
	static bool GetPauseOnReachedEnd(const struct FMovieResourceInfo& Info);
	static bool GetShowHud(const struct FMovieResourceInfo& Info);
	static const class FName GetSubtitleCodeName(const struct FMovieResourceInfo& Info);
	static bool GetUiFadeout(const struct FMovieResourceInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieResourceInfoFuncLibrary">();
	}
	static class UMovieResourceInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieResourceInfoFuncLibrary>();
	}
};
static_assert(alignof(UMovieResourceInfoFuncLibrary) == 0x000008, "Wrong alignment on UMovieResourceInfoFuncLibrary");
static_assert(sizeof(UMovieResourceInfoFuncLibrary) == 0x000028, "Wrong size on UMovieResourceInfoFuncLibrary");

// Class ProjectPContentInfo.MovieResourceInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UMovieResourceInfoAsset final : public UContentInfoAsset
{
public:
	struct FMovieResourceInfoDB                   ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FMovieResourceInfoPtr FindMovieResourceInfoByNameBP(class FName CodeName);
	static const TArray<struct FMovieResourceInfo> GetMovieResourceInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieResourceInfoAsset">();
	}
	static class UMovieResourceInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieResourceInfoAsset>();
	}
};
static_assert(alignof(UMovieResourceInfoAsset) == 0x000010, "Wrong alignment on UMovieResourceInfoAsset");
static_assert(sizeof(UMovieResourceInfoAsset) == 0x000120, "Wrong size on UMovieResourceInfoAsset");
static_assert(offsetof(UMovieResourceInfoAsset, ContentInfoDB) == 0x000078, "Member 'UMovieResourceInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.NGPKeepConfigInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNGPKeepConfigInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool GetKeepAppearance(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool GetKeepErgo(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const TArray<ELItemFirstCategory> GetKeepItemByItemFirstCategory(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const TArray<class FString> GetKeepItemSpotList(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool GetKeepLevelAndStat(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const TArray<class FString> GetKeepNPCSpotList(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool GetKeepPOganOpenLevel(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool GetKeepPOganQuartz(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const TArray<class FString> GetKeepPropSpotList(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const TArray<class FName> GetKeepQuest(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const TArray<class FName> GetKeepSpecialBuffList(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool GetKeepTutorialRecord(const struct FNGPKeepConfigInfoPtr& Ptr);
	static const class FName GetNewGameExecCommonCodeName(const struct FNGPKeepConfigInfoPtr& Ptr);
	static bool IsValid(const struct FNGPKeepConfigInfoPtr& Ptr);
	static void IsValidBranch(const struct FNGPKeepConfigInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGPKeepConfigInfoPtrFuncLibrary">();
	}
	static class UNGPKeepConfigInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGPKeepConfigInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNGPKeepConfigInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNGPKeepConfigInfoPtrFuncLibrary");
static_assert(sizeof(UNGPKeepConfigInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNGPKeepConfigInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NGPContentChangeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNGPContentChangeInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttackMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetAbnormalStatePenaltyBaseMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetAcidAttackMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetAcidDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetAcidRateDotReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetAcidReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetBreakDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetBuildUpRecoverIncBaseMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetCheckSkillUseCountAdd(const struct FNGPContentChangeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetContaminationDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetCurseDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetDestructionPowerMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetDurabilityMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetElectricAttackMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetElectricDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetElectricRateDotReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetElectricReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetEtcRateDotReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetExpMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetFireAttackMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetFireDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetFireRateDotReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetFireReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGroggyEnableResetRestoreMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGroggyEnableTimeMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGroggyMaintainTimeMaxMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGroggyMaintainTimeMinMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGroggyPointMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGroggyPointRestoreBaseMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGuardSharpnessAttackMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetGuardStaminaDamageMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetHealthPowerMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetImpactDebuffResistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetMaxStaminaMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetNGPRound(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetPhysicalPierceReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetPhysicalPowerMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetPhysicalSlashReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetPhysicalStrikeReduceMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetRegainhpGainRatioMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetRegainhpHealRatioMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetRegainhpMaxExistMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetRestoreStaminaPerSecMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetToughMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static int32 GetToughRestoreBaseMul(const struct FNGPContentChangeInfoPtr& Ptr);
	static bool IsValid(const struct FNGPContentChangeInfoPtr& Ptr);
	static void IsValidBranch(const struct FNGPContentChangeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NGPContentChangeInfoPtrFuncLibrary">();
	}
	static class UNGPContentChangeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNGPContentChangeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNGPContentChangeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNGPContentChangeInfoPtrFuncLibrary");
static_assert(sizeof(UNGPContentChangeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNGPContentChangeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NewGamePlusInfoAsset
// 0x00B8 (0x0130 - 0x0078)
class alignas(0x10) UNewGamePlusInfoAsset final : public UContentInfoAsset
{
public:
	struct FNewGamePlusInfoDB                     ContentInfoDB;                                     // 0x0078(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FNGPKeepConfigInfoPtr FindNGPKeepConfigInfoByNameBP(class FName CodeName);
	static const TArray<struct FNGPContentChangeInfo> GetNGPContentChangeInfoArrayBP();
	static const TArray<struct FNGPKeepConfigInfo> GetNGPKeepConfigInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewGamePlusInfoAsset">();
	}
	static class UNewGamePlusInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewGamePlusInfoAsset>();
	}
};
static_assert(alignof(UNewGamePlusInfoAsset) == 0x000010, "Wrong alignment on UNewGamePlusInfoAsset");
static_assert(sizeof(UNewGamePlusInfoAsset) == 0x000130, "Wrong size on UNewGamePlusInfoAsset");
static_assert(offsetof(UNewGamePlusInfoAsset, ContentInfoDB) == 0x000078, "Member 'UNewGamePlusInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.NPCDieInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCDieInfoFuncLibrary final : public UObject
{
public:
	static int32 GetDieAniDuration(const struct FNPCDieInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCDieInfoFuncLibrary">();
	}
	static class UNPCDieInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCDieInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCDieInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCDieInfoFuncLibrary");
static_assert(sizeof(UNPCDieInfoFuncLibrary) == 0x000028, "Wrong size on UNPCDieInfoFuncLibrary");

// Class ProjectPContentInfo.NPCDieInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCDieInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetDieAniDuration(const struct FNPCDieInfoPtr& Ptr);
	static bool IsValid(const struct FNPCDieInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCDieInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCDieInfoPtrFuncLibrary">();
	}
	static class UNPCDieInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCDieInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCDieInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCDieInfoPtrFuncLibrary");
static_assert(sizeof(UNPCDieInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCDieInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NPCSkillStandbyInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCSkillStandbyInfoFuncLibrary final : public UObject
{
public:
	static class FString GetSkillId(const struct FNPCSkillStandbyInfo& Info);
	static int32 GetSkillRate(const struct FNPCSkillStandbyInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSkillStandbyInfoFuncLibrary">();
	}
	static class UNPCSkillStandbyInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSkillStandbyInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCSkillStandbyInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCSkillStandbyInfoFuncLibrary");
static_assert(sizeof(UNPCSkillStandbyInfoFuncLibrary) == 0x000028, "Wrong size on UNPCSkillStandbyInfoFuncLibrary");

// Class ProjectPContentInfo.NPCInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCInfoFuncLibrary final : public UObject
{
public:
	static ELAdditiveHitType GetAdditiveHitType(const struct FNPCInfo& Info);
	static const TSoftClassPtr<class UClass> GetAiStatemachine(const struct FNPCInfo& Info);
	static float GetAlwaysGuardAngle(const struct FNPCInfo& Info);
	static const class FName GetAlwaysGuardAttachSlot(const struct FNPCInfo& Info);
	static float GetAlwaysGuardBoxX(const struct FNPCInfo& Info);
	static float GetAlwaysGuardBoxY(const struct FNPCInfo& Info);
	static float GetAlwaysGuardBoxZ(const struct FNPCInfo& Info);
	static ELAlwaysGuardDirection GetAlwaysGuardDirection(const struct FNPCInfo& Info);
	static float GetArriveCheckRange(const struct FNPCInfo& Info);
	static int32 GetCheckSkillUseCount(const struct FNPCInfo& Info);
	static int32 GetCheckTargetNearAllyNum(const struct FNPCInfo& Info);
	static const class FName GetCodeName(const struct FNPCInfo& Info);
	static const class FName GetCommonActionPathCodeName(const struct FNPCInfo& Info);
	static bool GetDeadHelpsignal(const struct FNPCInfo& Info);
	static bool GetDieImmediatelyHide(const struct FNPCInfo& Info);
	static float GetDieImmediatelyHideDelaytime(const struct FNPCInfo& Info);
	static bool GetDontUseCheckAllyNum(const struct FNPCInfo& Info);
	static bool GetExceptCheckAllyNum(const struct FNPCInfo& Info);
	static bool GetExplosiveKillPossible(const struct FNPCInfo& Info);
	static EFactionType GetFaction(const struct FNPCInfo& Info);
	static int32 GetFatalBehitEnableCooltime(const struct FNPCInfo& Info);
	static ELFatalEnableCondType GetFatalEnableCondType(const struct FNPCInfo& Info);
	static ELFatalHitType GetFatalHitType(const struct FNPCInfo& Info);
	static ELNpcFXSizeType GetFxSize(const struct FNPCInfo& Info);
	static const struct FFloatRangeValue GetGlobalCooltime(const struct FNPCInfo& Info);
	static ENPCGradeType GetGrade(const struct FNPCInfo& Info);
	static ELGrapplegunHitType GetGrapplegunHitType(const struct FNPCInfo& Info);
	static int32 GetGroggyEnableResetRestore(const struct FNPCInfo& Info);
	static int32 GetGroggyEnableTime(const struct FNPCInfo& Info);
	static int32 GetGroggyFxScale(const struct FNPCInfo& Info);
	static const struct FFloatRangeValue GetGroggyMaintainTime(const struct FNPCInfo& Info);
	static int32 GetGroggySndScale(const struct FNPCInfo& Info);
	static ELGroggyType GetGroggyTypeBack(const struct FNPCInfo& Info);
	static ELGroggyType GetGroggyTypeFront(const struct FNPCInfo& Info);
	static ELGroggyType GetGroggyTypeSide(const struct FNPCInfo& Info);
	static int32 GetGuardDurationRatio(const struct FNPCInfo& Info);
	static ELHeadTagVisibleType GetHeadtagVisibleType(const struct FNPCInfo& Info);
	static bool GetHelpsignalEnable(const struct FNPCInfo& Info);
	static float GetHelpsignalRange(const struct FNPCInfo& Info);
	static ELSwingPowerType GetHitFxLevel(const struct FNPCInfo& Info);
	static int32 GetHitRepulseLevelPierce(const struct FNPCInfo& Info);
	static int32 GetHitRepulseLevelSlash(const struct FNPCInfo& Info);
	static int32 GetHitRepulseLevelStrike(const struct FNPCInfo& Info);
	static ELHPUIType GetHpUiType(const struct FNPCInfo& Info);
	static const class FName GetImmuneCodeName(const struct FNPCInfo& Info);
	static const TArray<class FName> GetInitAbnormalCodeName(const struct FNPCInfo& Info);
	static class FString GetLocalTextName(const struct FNPCInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FNPCInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FNPCInfo& Info);
	static const class FName GetLocomotionActionPathCodeName(const struct FNPCInfo& Info);
	static bool GetMoveHeightCheck(const struct FNPCInfo& Info);
	static int32 GetNGPDetailIndex(const struct FNPCInfo& Info);
	static int32 GetNgpMinGroggyMaintaintime(const struct FNPCInfo& Info);
	static const class FName GetNpcAssetTableCodeName(const struct FNPCInfo& Info);
	static int32 GetNpcBackGroggyPointRatio(const struct FNPCInfo& Info);
	static const TSoftClassPtr<class UClass> GetNpcBp(const struct FNPCInfo& Info);
	static ELNpcDisappearType GetNpcDisappearType(const struct FNPCInfo& Info);
	static int32 GetNpcFrontGroggyPointRatio(const struct FNPCInfo& Info);
	static ELNPCType GetNpcKind(const struct FNPCInfo& Info);
	static int32 GetNpcScale(const struct FNPCInfo& Info);
	static int32 GetNpcSideGroggyPointRatio(const struct FNPCInfo& Info);
	static int32 GetPerfectGuardGroggyDamage(const struct FNPCInfo& Info);
	static bool GetPlayBgm(const struct FNPCInfo& Info);
	static const TArray<class FName> GetPreloadMonsterWeaponList(const struct FNPCInfo& Info);
	static float GetPursuitDistance(const struct FNPCInfo& Info);
	static bool GetRespawnEnable(const struct FNPCInfo& Info);
	static float GetReturnDistance(const struct FNPCInfo& Info);
	static int32 GetRoamRange(const struct FNPCInfo& Info);
	static int32 GetRotateAngle(const struct FNPCInfo& Info);
	static int32 GetRotateCooltime(const struct FNPCInfo& Info);
	static float GetRunSpeedCombat(const struct FNPCInfo& Info);
	static float GetRunSpeedPeace(const struct FNPCInfo& Info);
	static float GetRunSpeedWarning(const struct FNPCInfo& Info);
	static float GetSensitiveRange(const struct FNPCInfo& Info);
	static float GetSensitiveSpeed(const struct FNPCInfo& Info);
	static float GetSensitiveTime(const struct FNPCInfo& Info);
	static int32 GetSharpnessMonsterDamageRatioPierce(const struct FNPCInfo& Info);
	static int32 GetSharpnessMonsterDamageRatioSlash(const struct FNPCInfo& Info);
	static int32 GetSharpnessMonsterDamageRatioStrike(const struct FNPCInfo& Info);
	static float GetSightAngle(const struct FNPCInfo& Info);
	static float GetSightDistanceCombat(const struct FNPCInfo& Info);
	static float GetSightDistancePeace(const struct FNPCInfo& Info);
	static float GetSightDistanceWarning(const struct FNPCInfo& Info);
	static float GetSightHeight(const struct FNPCInfo& Info);
	static const class FName GetSkillActionPathCodeName(const struct FNPCInfo& Info);
	static const class FName GetSkillHitCodeNameDestroyed(const struct FNPCInfo& Info);
	static const TArray<struct FNPCSkillStandbyInfo> GetSkillListArray(const struct FNPCInfo& Info);
	static const class FName GetSpawnIdleCodeName(const struct FNPCInfo& Info);
	static const TArray<class FName> GetSpawnNpcCodeName(const struct FNPCInfo& Info);
	static float GetStrafeMoveDist(const struct FNPCInfo& Info);
	static const class FName GetSwapNpcCodeName(const struct FNPCInfo& Info);
	static float GetTargetdecisionRange(const struct FNPCInfo& Info);
	static int32 GetTargetdecisionTimeMax(const struct FNPCInfo& Info);
	static int32 GetTargetdecisionTimeMin(const struct FNPCInfo& Info);
	static ELNpcTargetDecisionType GetTargetDecisionType(const struct FNPCInfo& Info);
	static int32 GetTicketMoveDist(const struct FNPCInfo& Info);
	static ELToughMotionType GetToughMotionType(const struct FNPCInfo& Info);
	static bool GetUsePhysicsHit(const struct FNPCInfo& Info);
	static float GetWalkSpeedCombat(const struct FNPCInfo& Info);
	static float GetWalkSpeedPeace(const struct FNPCInfo& Info);
	static float GetWalkSpeedWarning(const struct FNPCInfo& Info);
	static float GetWarningDetectRange(const struct FNPCInfo& Info);
	static ELWeaponBreakMotionType GetWeaponBreakMotionType(const struct FNPCInfo& Info);
	static const class FName GetWeaponCodeNameEx1(const struct FNPCInfo& Info);
	static const class FName GetWeaponCodeNameEx2(const struct FNPCInfo& Info);
	static const class FName GetWeaponCodeNameEx3(const struct FNPCInfo& Info);
	static const class FName GetWeaponCodeNameL(const struct FNPCInfo& Info);
	static const class FName GetWeaponCodeNameR(const struct FNPCInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCInfoFuncLibrary">();
	}
	static class UNPCInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCInfoFuncLibrary");
static_assert(sizeof(UNPCInfoFuncLibrary) == 0x000028, "Wrong size on UNPCInfoFuncLibrary");

// Class ProjectPContentInfo.NPCInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCInfoPtrFuncLibrary final : public UObject
{
public:
	static ELAdditiveHitType GetAdditiveHitType(const struct FNPCInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetAiStatemachine(const struct FNPCInfoPtr& Ptr);
	static float GetAlwaysGuardAngle(const struct FNPCInfoPtr& Ptr);
	static const class FName GetAlwaysGuardAttachSlot(const struct FNPCInfoPtr& Ptr);
	static float GetAlwaysGuardBoxX(const struct FNPCInfoPtr& Ptr);
	static float GetAlwaysGuardBoxY(const struct FNPCInfoPtr& Ptr);
	static float GetAlwaysGuardBoxZ(const struct FNPCInfoPtr& Ptr);
	static ELAlwaysGuardDirection GetAlwaysGuardDirection(const struct FNPCInfoPtr& Ptr);
	static float GetArriveCheckRange(const struct FNPCInfoPtr& Ptr);
	static int32 GetCheckSkillUseCount(const struct FNPCInfoPtr& Ptr);
	static int32 GetCheckTargetNearAllyNum(const struct FNPCInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FNPCInfoPtr& Ptr);
	static const class FName GetCommonActionPathCodeName(const struct FNPCInfoPtr& Ptr);
	static bool GetDeadHelpsignal(const struct FNPCInfoPtr& Ptr);
	static bool GetDieImmediatelyHide(const struct FNPCInfoPtr& Ptr);
	static float GetDieImmediatelyHideDelaytime(const struct FNPCInfoPtr& Ptr);
	static bool GetDontUseCheckAllyNum(const struct FNPCInfoPtr& Ptr);
	static bool GetExceptCheckAllyNum(const struct FNPCInfoPtr& Ptr);
	static bool GetExplosiveKillPossible(const struct FNPCInfoPtr& Ptr);
	static EFactionType GetFaction(const struct FNPCInfoPtr& Ptr);
	static int32 GetFatalBehitEnableCooltime(const struct FNPCInfoPtr& Ptr);
	static ELFatalEnableCondType GetFatalEnableCondType(const struct FNPCInfoPtr& Ptr);
	static ELFatalHitType GetFatalHitType(const struct FNPCInfoPtr& Ptr);
	static ELNpcFXSizeType GetFxSize(const struct FNPCInfoPtr& Ptr);
	static const struct FFloatRangeValue GetGlobalCooltime(const struct FNPCInfoPtr& Ptr);
	static ENPCGradeType GetGrade(const struct FNPCInfoPtr& Ptr);
	static ELGrapplegunHitType GetGrapplegunHitType(const struct FNPCInfoPtr& Ptr);
	static int32 GetGroggyEnableResetRestore(const struct FNPCInfoPtr& Ptr);
	static int32 GetGroggyEnableTime(const struct FNPCInfoPtr& Ptr);
	static int32 GetGroggyFxScale(const struct FNPCInfoPtr& Ptr);
	static const struct FFloatRangeValue GetGroggyMaintainTime(const struct FNPCInfoPtr& Ptr);
	static int32 GetGroggySndScale(const struct FNPCInfoPtr& Ptr);
	static ELGroggyType GetGroggyTypeBack(const struct FNPCInfoPtr& Ptr);
	static ELGroggyType GetGroggyTypeFront(const struct FNPCInfoPtr& Ptr);
	static ELGroggyType GetGroggyTypeSide(const struct FNPCInfoPtr& Ptr);
	static int32 GetGuardDurationRatio(const struct FNPCInfoPtr& Ptr);
	static ELHeadTagVisibleType GetHeadtagVisibleType(const struct FNPCInfoPtr& Ptr);
	static bool GetHelpsignalEnable(const struct FNPCInfoPtr& Ptr);
	static float GetHelpsignalRange(const struct FNPCInfoPtr& Ptr);
	static ELSwingPowerType GetHitFxLevel(const struct FNPCInfoPtr& Ptr);
	static int32 GetHitRepulseLevelPierce(const struct FNPCInfoPtr& Ptr);
	static int32 GetHitRepulseLevelSlash(const struct FNPCInfoPtr& Ptr);
	static int32 GetHitRepulseLevelStrike(const struct FNPCInfoPtr& Ptr);
	static ELHPUIType GetHpUiType(const struct FNPCInfoPtr& Ptr);
	static const class FName GetImmuneCodeName(const struct FNPCInfoPtr& Ptr);
	static const TArray<class FName> GetInitAbnormalCodeName(const struct FNPCInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FNPCInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FNPCInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FNPCInfoPtr& Ptr);
	static const class FName GetLocomotionActionPathCodeName(const struct FNPCInfoPtr& Ptr);
	static bool GetMoveHeightCheck(const struct FNPCInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FNPCInfoPtr& Ptr);
	static int32 GetNgpMinGroggyMaintaintime(const struct FNPCInfoPtr& Ptr);
	static const class FName GetNpcAssetTableCodeName(const struct FNPCInfoPtr& Ptr);
	static int32 GetNpcBackGroggyPointRatio(const struct FNPCInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetNpcBp(const struct FNPCInfoPtr& Ptr);
	static ELNpcDisappearType GetNpcDisappearType(const struct FNPCInfoPtr& Ptr);
	static int32 GetNpcFrontGroggyPointRatio(const struct FNPCInfoPtr& Ptr);
	static ELNPCType GetNpcKind(const struct FNPCInfoPtr& Ptr);
	static int32 GetNpcScale(const struct FNPCInfoPtr& Ptr);
	static int32 GetNpcSideGroggyPointRatio(const struct FNPCInfoPtr& Ptr);
	static int32 GetPerfectGuardGroggyDamage(const struct FNPCInfoPtr& Ptr);
	static bool GetPlayBgm(const struct FNPCInfoPtr& Ptr);
	static const TArray<class FName> GetPreloadMonsterWeaponList(const struct FNPCInfoPtr& Ptr);
	static float GetPursuitDistance(const struct FNPCInfoPtr& Ptr);
	static bool GetRespawnEnable(const struct FNPCInfoPtr& Ptr);
	static float GetReturnDistance(const struct FNPCInfoPtr& Ptr);
	static int32 GetRoamRange(const struct FNPCInfoPtr& Ptr);
	static int32 GetRotateAngle(const struct FNPCInfoPtr& Ptr);
	static int32 GetRotateCooltime(const struct FNPCInfoPtr& Ptr);
	static float GetRunSpeedCombat(const struct FNPCInfoPtr& Ptr);
	static float GetRunSpeedPeace(const struct FNPCInfoPtr& Ptr);
	static float GetRunSpeedWarning(const struct FNPCInfoPtr& Ptr);
	static float GetSensitiveRange(const struct FNPCInfoPtr& Ptr);
	static float GetSensitiveSpeed(const struct FNPCInfoPtr& Ptr);
	static float GetSensitiveTime(const struct FNPCInfoPtr& Ptr);
	static int32 GetSharpnessMonsterDamageRatioPierce(const struct FNPCInfoPtr& Ptr);
	static int32 GetSharpnessMonsterDamageRatioSlash(const struct FNPCInfoPtr& Ptr);
	static int32 GetSharpnessMonsterDamageRatioStrike(const struct FNPCInfoPtr& Ptr);
	static float GetSightAngle(const struct FNPCInfoPtr& Ptr);
	static float GetSightDistanceCombat(const struct FNPCInfoPtr& Ptr);
	static float GetSightDistancePeace(const struct FNPCInfoPtr& Ptr);
	static float GetSightDistanceWarning(const struct FNPCInfoPtr& Ptr);
	static float GetSightHeight(const struct FNPCInfoPtr& Ptr);
	static const class FName GetSkillActionPathCodeName(const struct FNPCInfoPtr& Ptr);
	static const class FName GetSkillHitCodeNameDestroyed(const struct FNPCInfoPtr& Ptr);
	static const TArray<struct FNPCSkillStandbyInfo> GetSkillListArray(const struct FNPCInfoPtr& Ptr);
	static const class FName GetSpawnIdleCodeName(const struct FNPCInfoPtr& Ptr);
	static const TArray<class FName> GetSpawnNpcCodeName(const struct FNPCInfoPtr& Ptr);
	static float GetStrafeMoveDist(const struct FNPCInfoPtr& Ptr);
	static const class FName GetSwapNpcCodeName(const struct FNPCInfoPtr& Ptr);
	static float GetTargetdecisionRange(const struct FNPCInfoPtr& Ptr);
	static int32 GetTargetdecisionTimeMax(const struct FNPCInfoPtr& Ptr);
	static int32 GetTargetdecisionTimeMin(const struct FNPCInfoPtr& Ptr);
	static ELNpcTargetDecisionType GetTargetDecisionType(const struct FNPCInfoPtr& Ptr);
	static int32 GetTicketMoveDist(const struct FNPCInfoPtr& Ptr);
	static ELToughMotionType GetToughMotionType(const struct FNPCInfoPtr& Ptr);
	static bool GetUsePhysicsHit(const struct FNPCInfoPtr& Ptr);
	static float GetWalkSpeedCombat(const struct FNPCInfoPtr& Ptr);
	static float GetWalkSpeedPeace(const struct FNPCInfoPtr& Ptr);
	static float GetWalkSpeedWarning(const struct FNPCInfoPtr& Ptr);
	static float GetWarningDetectRange(const struct FNPCInfoPtr& Ptr);
	static ELWeaponBreakMotionType GetWeaponBreakMotionType(const struct FNPCInfoPtr& Ptr);
	static const class FName GetWeaponCodeNameEx1(const struct FNPCInfoPtr& Ptr);
	static const class FName GetWeaponCodeNameEx2(const struct FNPCInfoPtr& Ptr);
	static const class FName GetWeaponCodeNameEx3(const struct FNPCInfoPtr& Ptr);
	static const class FName GetWeaponCodeNameL(const struct FNPCInfoPtr& Ptr);
	static const class FName GetWeaponCodeNameR(const struct FNPCInfoPtr& Ptr);
	static bool IsValid(const struct FNPCInfoPtr& Ptr);
	static void IsValidBranch(const struct FNPCInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCInfoPtrFuncLibrary">();
	}
	static class UNPCInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UNPCInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UNPCInfoPtrFuncLibrary");
static_assert(sizeof(UNPCInfoPtrFuncLibrary) == 0x000028, "Wrong size on UNPCInfoPtrFuncLibrary");

// Class ProjectPContentInfo.NPCSkillLinkInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCSkillLinkInfoFuncLibrary final : public UObject
{
public:
	static ELElementDamageType GetBeHitByElementDamageType(const struct FNPCSkillLinkInfo& Info);
	static ELPhysicalDamageType GetBeHitByPhysicalDamageType(const struct FNPCSkillLinkInfo& Info);
	static const class FName GetCodeName(const struct FNPCSkillLinkInfo& Info);
	static float GetCollideCeilingHeight(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionBeHit(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionCollideCeiling(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionCooltime(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionDefenceSkill(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionHitTarget(const struct FNPCSkillLinkInfo& Info);
	static const class FName GetConditionPartNeeded(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionPercent(const struct FNPCSkillLinkInfo& Info);
	static bool GetConditionRange(const struct FNPCSkillLinkInfo& Info);
	static ELAIDamageType GetHitDamageType(const struct FNPCSkillLinkInfo& Info);
	static class FString GetHitTargetActionEventAlias(const struct FNPCSkillLinkInfo& Info);
	static bool GetLinkSkillUseCooltime(const struct FNPCSkillLinkInfo& Info);
	static float GetPercentValue(const struct FNPCSkillLinkInfo& Info);
	static int32 GetPriority(const struct FNPCSkillLinkInfo& Info);
	static float GetSkillDistHeight(const struct FNPCSkillLinkInfo& Info);
	static float GetSkillDistMax(const struct FNPCSkillLinkInfo& Info);
	static float GetSkillDistMin(const struct FNPCSkillLinkInfo& Info);
	static float GetSkillRangeAngleEnd(const struct FNPCSkillLinkInfo& Info);
	static float GetSkillRangeAngleStart(const struct FNPCSkillLinkInfo& Info);
	static ELAIRangeCheckType GetSkillrangeChecktype(const struct FNPCSkillLinkInfo& Info);
	static const class FName GetUseSkillId(const struct FNPCSkillLinkInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSkillLinkInfoFuncLibrary">();
	}
	static class UNPCSkillLinkInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSkillLinkInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCSkillLinkInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCSkillLinkInfoFuncLibrary");
static_assert(sizeof(UNPCSkillLinkInfoFuncLibrary) == 0x000028, "Wrong size on UNPCSkillLinkInfoFuncLibrary");

// Class ProjectPContentInfo.NpcGaugeGrowthInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNpcGaugeGrowthInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAcidDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetAcidDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetBreakDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetBreakDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static const class FName GetCodeName(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetContaminationDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetContaminationDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetCurseDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetCurseDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetElectricDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetElectricDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetFireDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetFireDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetFullFillNum(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetGroggyMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetImpactDebuffResistMuladd(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetImpactDurationMulsud(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetNGPRound(const struct FNpcGaugeGrowthInfo& Info);
	static int32 GetToughMuladd(const struct FNpcGaugeGrowthInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcGaugeGrowthInfoFuncLibrary">();
	}
	static class UNpcGaugeGrowthInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcGaugeGrowthInfoFuncLibrary>();
	}
};
static_assert(alignof(UNpcGaugeGrowthInfoFuncLibrary) == 0x000008, "Wrong alignment on UNpcGaugeGrowthInfoFuncLibrary");
static_assert(sizeof(UNpcGaugeGrowthInfoFuncLibrary) == 0x000028, "Wrong size on UNpcGaugeGrowthInfoFuncLibrary");

// Class ProjectPContentInfo.NPCStatInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCStatInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalFirePoint(const struct FNPCStatInfo& Info);
	static int32 GetAbnormalStateBuildUpAttack(const struct FNPCStatInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FNPCStatInfo& Info);
	static int32 GetAbnormalStatePenaltyBase(const struct FNPCStatInfo& Info);
	static int32 GetAcidAttack(const struct FNPCStatInfo& Info);
	static int32 GetAcidDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetAcidDefence(const struct FNPCStatInfo& Info);
	static int32 GetAcidGroggyReduce(const struct FNPCStatInfo& Info);
	static int32 GetAcidRateDotReduce(const struct FNPCStatInfo& Info);
	static int32 GetAcidReduce(const struct FNPCStatInfo& Info);
	static int32 GetAttackSpeedRatio(const struct FNPCStatInfo& Info);
	static int32 GetBreakDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetBuildUpRecoverIncBase(const struct FNPCStatInfo& Info);
	static const class FName GetCodeName(const struct FNPCStatInfo& Info);
	static int32 GetContaminationDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetCriticalDamageRatio(const struct FNPCStatInfo& Info);
	static int32 GetCriticalRate(const struct FNPCStatInfo& Info);
	static int32 GetCriticalResistRate(const struct FNPCStatInfo& Info);
	static int32 GetCurseDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetDestructionAcidReduce(const struct FNPCStatInfo& Info);
	static float GetDestructionDefence(const struct FNPCStatInfo& Info);
	static int32 GetDestructionElectricReduce(const struct FNPCStatInfo& Info);
	static int32 GetDestructionFireReduce(const struct FNPCStatInfo& Info);
	static int32 GetDestructionPhysicalReduce(const struct FNPCStatInfo& Info);
	static int32 GetDestructionPierceReduce(const struct FNPCStatInfo& Info);
	static int32 GetDestructionPower(const struct FNPCStatInfo& Info);
	static float GetDestructionReduce(const struct FNPCStatInfo& Info);
	static int32 GetDestructionSlashReduce(const struct FNPCStatInfo& Info);
	static int32 GetDestructionStrikeReduce(const struct FNPCStatInfo& Info);
	static int32 GetElectricAttack(const struct FNPCStatInfo& Info);
	static int32 GetElectricDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetElectricDefence(const struct FNPCStatInfo& Info);
	static int32 GetElectricGroggyReduce(const struct FNPCStatInfo& Info);
	static int32 GetElectricRateDotReduce(const struct FNPCStatInfo& Info);
	static int32 GetElectricReduce(const struct FNPCStatInfo& Info);
	static int32 GetEtcRateDotReduce(const struct FNPCStatInfo& Info);
	static int32 GetExp(const struct FNPCStatInfo& Info);
	static int32 GetFireAttack(const struct FNPCStatInfo& Info);
	static int32 GetFireDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetFireDefence(const struct FNPCStatInfo& Info);
	static int32 GetFireGroggyReduce(const struct FNPCStatInfo& Info);
	static int32 GetFireRateDotReduce(const struct FNPCStatInfo& Info);
	static int32 GetFireReduce(const struct FNPCStatInfo& Info);
	static int32 GetGroggyAttack(const struct FNPCStatInfo& Info);
	static int32 GetGroggyPierceReduce(const struct FNPCStatInfo& Info);
	static int32 GetGroggyPoint(const struct FNPCStatInfo& Info);
	static float GetGroggyPointResetDelay(const struct FNPCStatInfo& Info);
	static int32 GetGroggyPointRestoreBase(const struct FNPCStatInfo& Info);
	static int32 GetGroggyPointRestoreStopTime(const struct FNPCStatInfo& Info);
	static int32 GetGroggySlashReduce(const struct FNPCStatInfo& Info);
	static int32 GetGroggyStrikeReduce(const struct FNPCStatInfo& Info);
	static int32 GetGuardAciddamageReductionRatio(const struct FNPCStatInfo& Info);
	static int32 GetGuardElectricdamageReductionRatio(const struct FNPCStatInfo& Info);
	static int32 GetGuardFiredamageReductionRatio(const struct FNPCStatInfo& Info);
	static int32 GetGuardKnockbackDistanceReductionRatio(const struct FNPCStatInfo& Info);
	static int32 GetGuardKnockbackDurationReductionRatio(const struct FNPCStatInfo& Info);
	static int32 GetGuardPenetrationPowerBase(const struct FNPCStatInfo& Info);
	static int32 GetGuardPhysicaldamageReductionRatio(const struct FNPCStatInfo& Info);
	static int32 GetGuardPoint(const struct FNPCStatInfo& Info);
	static int32 GetGuardSharpnessAttack(const struct FNPCStatInfo& Info);
	static int32 GetGuardStaminaDamage(const struct FNPCStatInfo& Info);
	static int32 GetHealthPower(const struct FNPCStatInfo& Info);
	static int32 GetImpactDebuffResist(const struct FNPCStatInfo& Info);
	static int32 GetMaxStamina(const struct FNPCStatInfo& Info);
	static int32 GetNGPDetailIndex(const struct FNPCStatInfo& Info);
	static const class FName GetNpcGaugeGrowth(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalDefence(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalGroggyReduce(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalPierceDefence(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalPierceReduce(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalPower(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalReduce(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalSlashDefence(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalSlashReduce(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalStrikeDefence(const struct FNPCStatInfo& Info);
	static int32 GetPhysicalStrikeReduce(const struct FNPCStatInfo& Info);
	static int32 GetRegainhpGainRatio(const struct FNPCStatInfo& Info);
	static int32 GetRegainhpHealIncreaseRatio(const struct FNPCStatInfo& Info);
	static int32 GetRegainhpHealRatio(const struct FNPCStatInfo& Info);
	static int32 GetRegainhpHealTime(const struct FNPCStatInfo& Info);
	static int32 GetRegainhpMaxExist(const struct FNPCStatInfo& Info);
	static int32 GetRestoreStaminaPerSec(const struct FNPCStatInfo& Info);
	static int32 GetRigidity(const struct FNPCStatInfo& Info);
	static int32 GetSpecialhitGroggyReduction(const struct FNPCStatInfo& Info);
	static float GetStiffenPlayrateAttacker(const struct FNPCStatInfo& Info);
	static float GetStiffenPlayrateDefender(const struct FNPCStatInfo& Info);
	static int32 GetTough(const struct FNPCStatInfo& Info);
	static int32 GetToughAttackPowerBase(const struct FNPCStatInfo& Info);
	static int32 GetToughDefencePowerBase(const struct FNPCStatInfo& Info);
	static int32 GetToughRecoveryDelayReduction(const struct FNPCStatInfo& Info);
	static int32 GetToughRecoveryDelayTime(const struct FNPCStatInfo& Info);
	static int32 GetToughRestoreBase(const struct FNPCStatInfo& Info);
	static int32 GetWalkRunSpeedRatio(const struct FNPCStatInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCStatInfoFuncLibrary">();
	}
	static class UNPCStatInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCStatInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCStatInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCStatInfoFuncLibrary");
static_assert(sizeof(UNPCStatInfoFuncLibrary) == 0x000028, "Wrong size on UNPCStatInfoFuncLibrary");

// Class ProjectPContentInfo.NPCPartsInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCPartsInfoFuncLibrary final : public UObject
{
public:
	static bool GetAttackerRepulseEnable(const struct FNPCPartsInfo& Info);
	static const class FName GetCodeName(const struct FNPCPartsInfo& Info);
	static bool GetDestroyedOnSpawn(const struct FNPCPartsInfo& Info);
	static bool GetEnableOnSpawn(const struct FNPCPartsInfo& Info);
	static int32 GetGroggyReduce(const struct FNPCPartsInfo& Info);
	static ELNpcPartsHitDirectionType GetHitDirectionType(const struct FNPCPartsInfo& Info);
	static int32 GetHitRangeAngleEnd(const struct FNPCPartsInfo& Info);
	static int32 GetHitRangeAngleStart(const struct FNPCPartsInfo& Info);
	static int32 GetHitRepulseLevelPierce(const struct FNPCPartsInfo& Info);
	static int32 GetHitRepulseLevelSlash(const struct FNPCPartsInfo& Info);
	static int32 GetHitRepulseLevelStrike(const struct FNPCPartsInfo& Info);
	static int32 GetPartsAcidReduce(const struct FNPCPartsInfo& Info);
	static const class FName GetPartsBpCodeName(const struct FNPCPartsInfo& Info);
	static int32 GetPartsBreakActionParalyze(const struct FNPCPartsInfo& Info);
	static bool GetPartsDamageToMonsterUse(const struct FNPCPartsInfo& Info);
	static int32 GetPartsDestructionIndex(const struct FNPCPartsInfo& Info);
	static int32 GetPartsDropItemLimit(const struct FNPCPartsInfo& Info);
	static const class FName GetPartsDropItemOnDestroy(const struct FNPCPartsInfo& Info);
	static int32 GetPartsDropItemProbility(const struct FNPCPartsInfo& Info);
	static bool GetPartsDropItemRedropUse(const struct FNPCPartsInfo& Info);
	static int32 GetPartsElectricReduce(const struct FNPCPartsInfo& Info);
	static int32 GetPartsFireReduce(const struct FNPCPartsInfo& Info);
	static int32 GetPartsHpRatio(const struct FNPCPartsInfo& Info);
	static int32 GetPartsPhysicalPierceReduce(const struct FNPCPartsInfo& Info);
	static int32 GetPartsPhysicalSlashReduce(const struct FNPCPartsInfo& Info);
	static int32 GetPartsPhysicalStrikeReduce(const struct FNPCPartsInfo& Info);
	static int32 GetPartsRigidity(const struct FNPCPartsInfo& Info);
	static const class FName GetPartsSkillCodeNameOnDestroy(const struct FNPCPartsInfo& Info);
	static int32 GetRegainReduce(const struct FNPCPartsInfo& Info);
	static int32 GetSharpnessMonsterDamageRatioPierce(const struct FNPCPartsInfo& Info);
	static int32 GetSharpnessMonsterDamageRatioSlash(const struct FNPCPartsInfo& Info);
	static int32 GetSharpnessMonsterDamageRatioStrike(const struct FNPCPartsInfo& Info);
	static int32 GetToughReduce(const struct FNPCPartsInfo& Info);
	static ELElementDamageType GetWeakElement(const struct FNPCPartsInfo& Info);
	static const class FName GetWeakElementSkillCodeName(const struct FNPCPartsInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCPartsInfoFuncLibrary">();
	}
	static class UNPCPartsInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCPartsInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCPartsInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCPartsInfoFuncLibrary");
static_assert(sizeof(UNPCPartsInfoFuncLibrary) == 0x000028, "Wrong size on UNPCPartsInfoFuncLibrary");

// Class ProjectPContentInfo.NPCBodyWeaponInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCBodyWeaponInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAddSkillRangeAfterBroken(const struct FNPCBodyWeaponInfo& Info);
	static const class FName GetCodeName(const struct FNPCBodyWeaponInfo& Info);
	static int32 GetDurability(const struct FNPCBodyWeaponInfo& Info);
	static int32 GetMinimumSkillRangeMaxAfterBroken(const struct FNPCBodyWeaponInfo& Info);
	static int32 GetMinimumSkillRangeMinAfterBroken(const struct FNPCBodyWeaponInfo& Info);
	static int32 GetMotionSpeedRateAfterBroken(const struct FNPCBodyWeaponInfo& Info);
	static int32 GetMulpleRateAtkPowerAfterBroken(const struct FNPCBodyWeaponInfo& Info);
	static int32 GetMulpleRateRigidityAfterBroken(const struct FNPCBodyWeaponInfo& Info);
	static const class FName GetWeaponBpCodeName(const struct FNPCBodyWeaponInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCBodyWeaponInfoFuncLibrary">();
	}
	static class UNPCBodyWeaponInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCBodyWeaponInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCBodyWeaponInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCBodyWeaponInfoFuncLibrary");
static_assert(sizeof(UNPCBodyWeaponInfoFuncLibrary) == 0x000028, "Wrong size on UNPCBodyWeaponInfoFuncLibrary");

// Class ProjectPContentInfo.NPCSpotDieInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UNPCSpotDieInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetActionStatePc(const struct FNPCSpotDieInfo& Info);
	static const class FName GetChangeWeather(const struct FNPCSpotDieInfo& Info);
	static int32 GetChangeWeatherDelay(const struct FNPCSpotDieInfo& Info);
	static const class FName GetContentCondition(const struct FNPCSpotDieInfo& Info);
	static const class FName GetDeadBossAlertAfterCommand(const struct FNPCSpotDieInfo& Info);
	static int32 GetDeadBossAlertAfterCommandDelay(const struct FNPCSpotDieInfo& Info);
	static int32 GetDeadBossAlertDelay(const struct FNPCSpotDieInfo& Info);
	static const class FName GetDialog(const struct FNPCSpotDieInfo& Info);
	static const class FName GetDialogCommand(const struct FNPCSpotDieInfo& Info);
	static int32 GetDialogDelay(const struct FNPCSpotDieInfo& Info);
	static class FString GetDialogTalkerSpotId(const struct FNPCSpotDieInfo& Info);
	static int32 GetItemAlertDelay(const struct FNPCSpotDieInfo& Info);
	static const class FName GetItemDropIndex(const struct FNPCSpotDieInfo& Info);
	static const class FName GetLevelSequenceCommand(const struct FNPCSpotDieInfo& Info);
	static int32 GetLevelSequenceDelay(const struct FNPCSpotDieInfo& Info);
	static class FString GetLevelSequenceSpotId(const struct FNPCSpotDieInfo& Info);
	static const class FName GetMonologue(const struct FNPCSpotDieInfo& Info);
	static int32 GetMonologueDelay(const struct FNPCSpotDieInfo& Info);
	static const class FName GetMonologueEndCommand(const struct FNPCSpotDieInfo& Info);
	static const class FName GetMovie(const struct FNPCSpotDieInfo& Info);
	static const class FName GetMovieCommand(const struct FNPCSpotDieInfo& Info);
	static int32 GetMovieDelay(const struct FNPCSpotDieInfo& Info);
	static class FString GetNpcSpotId(const struct FNPCSpotDieInfo& Info);
	static const class FName GetStartCommand(const struct FNPCSpotDieInfo& Info);
	static int32 GetUiFadeout(const struct FNPCSpotDieInfo& Info);
	static int32 GetUiFadeOutDelay(const struct FNPCSpotDieInfo& Info);
	static bool GetUiFadeOutPause(const struct FNPCSpotDieInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCSpotDieInfoFuncLibrary">();
	}
	static class UNPCSpotDieInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCSpotDieInfoFuncLibrary>();
	}
};
static_assert(alignof(UNPCSpotDieInfoFuncLibrary) == 0x000008, "Wrong alignment on UNPCSpotDieInfoFuncLibrary");
static_assert(sizeof(UNPCSpotDieInfoFuncLibrary) == 0x000028, "Wrong size on UNPCSpotDieInfoFuncLibrary");

// Class ProjectPContentInfo.NPCInfoAsset
// 0x01F8 (0x0270 - 0x0078)
class alignas(0x10) UNPCInfoAsset final : public UContentInfoAsset
{
public:
	struct FNPCInfoDB                             ContentInfoDB;                                     // 0x0078(0x01F0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FNPCBodyWeaponInfoPtr FindNPCBodyWeaponInfoByNameBP(class FName CodeName);
	static struct FNPCInfoPtr FindNpcInfoByNameBP(class FName CodeName);
	static struct FNPCSkillLinkInfoPtr FindNpcSkillLinkInfoByNameBP(class FName CodeName);
	static struct FNPCStatInfoPtr FindNpcStatInfoByNameBP(class FName CodeName);
	static const TArray<struct FNPCBodyWeaponInfo> GetNPCBodyWeaponInfoArrayBP();
	static const TArray<struct FNpcGaugeGrowthInfo> GetNpcGaugeGrowthInfoArrayBP();
	static const TArray<struct FNPCInfo> GetNpcInfoArrayBP();
	static const TArray<struct FNPCPartsInfo> GetNpcPartsInfoArrayBP();
	static const TArray<struct FNPCSkillLinkInfo> GetNpcSkillLinkInfoArrayBP();
	static const TArray<struct FNPCSpotDieInfo> GetNPCSpotDieInfoArrayBP();
	static const TArray<struct FNPCStatInfo> GetNpcStatInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCInfoAsset">();
	}
	static class UNPCInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCInfoAsset>();
	}
};
static_assert(alignof(UNPCInfoAsset) == 0x000010, "Wrong alignment on UNPCInfoAsset");
static_assert(sizeof(UNPCInfoAsset) == 0x000270, "Wrong size on UNPCInfoAsset");
static_assert(offsetof(UNPCInfoAsset, ContentInfoDB) == 0x000078, "Member 'UNPCInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SpawnControllerInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpawnControllerInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FSpawnControllerInfoPtr& Ptr);
	static ELLightScenarioType GetSpawnCondAMPM(const struct FSpawnControllerInfoPtr& Ptr);
	static const class FName GetSpawnCondCompleteQuest(const struct FSpawnControllerInfoPtr& Ptr);
	static ELQuestState GetSpawnCondCompleteQuestResult(const struct FSpawnControllerInfoPtr& Ptr);
	static const class FName GetSpawnCondCustom(const struct FSpawnControllerInfoPtr& Ptr);
	static ELWeatherType GetSpawnCondDryWet(const struct FSpawnControllerInfoPtr& Ptr);
	static const class FName GetSpawnCondHaveitem(const struct FSpawnControllerInfoPtr& Ptr);
	static const class FName GetSpawnCondHaveQuest(const struct FSpawnControllerInfoPtr& Ptr);
	static int32 GetSpawnCondHaveQuestStep(const struct FSpawnControllerInfoPtr& Ptr);
	static int32 GetSpawnCondHumanPoint(const struct FSpawnControllerInfoPtr& Ptr);
	static ELTimeZoneType GetSpawnCondTimezone(const struct FSpawnControllerInfoPtr& Ptr);
	static const class FName GetSpawnCondWeather(const struct FSpawnControllerInfoPtr& Ptr);
	static bool IsValid(const struct FSpawnControllerInfoPtr& Ptr);
	static void IsValidBranch(const struct FSpawnControllerInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnControllerInfoPtrFuncLibrary">();
	}
	static class USpawnControllerInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnControllerInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USpawnControllerInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USpawnControllerInfoPtrFuncLibrary");
static_assert(sizeof(USpawnControllerInfoPtrFuncLibrary) == 0x000028, "Wrong size on USpawnControllerInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SpotMatchInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpotMatchInfoPtrFuncLibrary final : public UObject
{
public:
	static ELConditionCheckType GetNPCSpawnControllerCheckType(const struct FSpotMatchInfoPtr& Ptr);
	static const class FName GetNPCSpawnControllerCodeName(const struct FSpotMatchInfoPtr& Ptr);
	static class FString GetNpcSpotId(const struct FSpotMatchInfoPtr& Ptr);
	static bool IsValid(const struct FSpotMatchInfoPtr& Ptr);
	static void IsValidBranch(const struct FSpotMatchInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpotMatchInfoPtrFuncLibrary">();
	}
	static class USpotMatchInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpotMatchInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USpotMatchInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USpotMatchInfoPtrFuncLibrary");
static_assert(sizeof(USpotMatchInfoPtrFuncLibrary) == 0x000028, "Wrong size on USpotMatchInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PatchItemPackageFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPatchItemPackageFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPatchItemPackage& Info);
	static int32 GetCount(const struct FPatchItemPackage& Info);
	static int32 GetPrintOrder(const struct FPatchItemPackage& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchItemPackageFuncLibrary">();
	}
	static class UPatchItemPackageFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchItemPackageFuncLibrary>();
	}
};
static_assert(alignof(UPatchItemPackageFuncLibrary) == 0x000008, "Wrong alignment on UPatchItemPackageFuncLibrary");
static_assert(sizeof(UPatchItemPackageFuncLibrary) == 0x000028, "Wrong size on UPatchItemPackageFuncLibrary");

// Class ProjectPContentInfo.PatchWeaponPackageFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPatchWeaponPackageFuncLibrary final : public UObject
{
public:
	static const class FName GetBladeCodeName(const struct FPatchWeaponPackage& Info);
	static const class FName GetHandleCodeName(const struct FPatchWeaponPackage& Info);
	static int32 GetPrintOrder(const struct FPatchWeaponPackage& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchWeaponPackageFuncLibrary">();
	}
	static class UPatchWeaponPackageFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchWeaponPackageFuncLibrary>();
	}
};
static_assert(alignof(UPatchWeaponPackageFuncLibrary) == 0x000008, "Wrong alignment on UPatchWeaponPackageFuncLibrary");
static_assert(sizeof(UPatchWeaponPackageFuncLibrary) == 0x000028, "Wrong size on UPatchWeaponPackageFuncLibrary");

// Class ProjectPContentInfo.PatchRewardInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPatchRewardInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPatchRewardInfo& Info);
	static const TArray<struct FPatchItemPackage> GetItemListArray(const struct FPatchRewardInfo& Info);
	static int32 GetOrder(const struct FPatchRewardInfo& Info);
	static class FString GetVersion(const struct FPatchRewardInfo& Info);
	static class FString GetVersionMac(const struct FPatchRewardInfo& Info);
	static class FString GetVersionPs4(const struct FPatchRewardInfo& Info);
	static class FString GetVersionPs5(const struct FPatchRewardInfo& Info);
	static const TArray<struct FPatchWeaponPackage> GetWeaponListArray(const struct FPatchRewardInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchRewardInfoFuncLibrary">();
	}
	static class UPatchRewardInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchRewardInfoFuncLibrary>();
	}
};
static_assert(alignof(UPatchRewardInfoFuncLibrary) == 0x000008, "Wrong alignment on UPatchRewardInfoFuncLibrary");
static_assert(sizeof(UPatchRewardInfoFuncLibrary) == 0x000028, "Wrong size on UPatchRewardInfoFuncLibrary");

// Class ProjectPContentInfo.PatchRewardInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UPatchRewardInfoAsset final : public UContentInfoAsset
{
public:
	struct FPatchRewardInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FPatchRewardInfoPtr FindPatchRewardInfoByNameBP(class FName CodeName);
	static const TArray<struct FPatchRewardInfo> GetPatchRewardInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatchRewardInfoAsset">();
	}
	static class UPatchRewardInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatchRewardInfoAsset>();
	}
};
static_assert(alignof(UPatchRewardInfoAsset) == 0x000010, "Wrong alignment on UPatchRewardInfoAsset");
static_assert(sizeof(UPatchRewardInfoAsset) == 0x000120, "Wrong size on UPatchRewardInfoAsset");
static_assert(offsetof(UPatchRewardInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPatchRewardInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PathWayInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPathWayInfoPtrFuncLibrary final : public UObject
{
public:
	static float GetArrivalRadius(const struct FPathWayInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FPathWayInfoPtr& Ptr);
	static int32 GetIndex(const struct FPathWayInfoPtr& Ptr);
	static ELPathWayType GetType(const struct FPathWayInfoPtr& Ptr);
	static float GetWaitTime(const struct FPathWayInfoPtr& Ptr);
	static bool IsValid(const struct FPathWayInfoPtr& Ptr);
	static void IsValidBranch(const struct FPathWayInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathWayInfoPtrFuncLibrary">();
	}
	static class UPathWayInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathWayInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPathWayInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPathWayInfoPtrFuncLibrary");
static_assert(sizeof(UPathWayInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPathWayInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DefaultStatInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDefaultStatInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStatePenaltyBase(const struct FDefaultStatInfo& Info);
	static int32 GetAcidAttack(const struct FDefaultStatInfo& Info);
	static int32 GetAcidDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetAcidDefence(const struct FDefaultStatInfo& Info);
	static int32 GetAcidReduce(const struct FDefaultStatInfo& Info);
	static int32 GetAdvance(const struct FDefaultStatInfo& Info);
	static int32 GetAttackGainFrenzyPointIncreaseRatio(const struct FDefaultStatInfo& Info);
	static int32 GetAttackratioSlavearm(const struct FDefaultStatInfo& Info);
	static int32 GetAttackSpeedRatio(const struct FDefaultStatInfo& Info);
	static int32 GetAttackStaminaReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetBreakDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupAcidReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupBreakReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupContaminationReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupCurseReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupElectricReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupFireReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildupImpactReduction(const struct FDefaultStatInfo& Info);
	static int32 GetBuildUpRecoverIncBase(const struct FDefaultStatInfo& Info);
	static int32 GetCapacity(const struct FDefaultStatInfo& Info);
	static const class FName GetCodeName(const struct FDefaultStatInfo& Info);
	static int32 GetContaminationDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetCriticalDamageRatio(const struct FDefaultStatInfo& Info);
	static int32 GetCurseDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetDashParryCooltime(const struct FDefaultStatInfo& Info);
	static int32 GetDashStaminaReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetDestructionPower(const struct FDefaultStatInfo& Info);
	static int32 GetDownGetupSpeedRatio(const struct FDefaultStatInfo& Info);
	static int32 GetDropErgoRegainMonkillRatio(const struct FDefaultStatInfo& Info);
	static int32 GetElectricAttack(const struct FDefaultStatInfo& Info);
	static int32 GetElectricDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetElectricDefence(const struct FDefaultStatInfo& Info);
	static int32 GetElectricReduce(const struct FDefaultStatInfo& Info);
	static int32 GetFatalDamageRatio(const struct FDefaultStatInfo& Info);
	static int32 GetFatalPhysicalAttackpower(const struct FDefaultStatInfo& Info);
	static int32 GetFireAttack(const struct FDefaultStatInfo& Info);
	static int32 GetFireDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetFireDefence(const struct FDefaultStatInfo& Info);
	static int32 GetFireReduce(const struct FDefaultStatInfo& Info);
	static int32 GetFrenzyUnitCount(const struct FDefaultStatInfo& Info);
	static int32 GetGuardAciddamageReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardElectricdamageReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardFiredamageReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardParryCooltime(const struct FDefaultStatInfo& Info);
	static int32 GetGuardPhysicaldamageReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardRegainAttackHealIncreaseRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardRegainPerfectGuardHealRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardRegainPointMax(const struct FDefaultStatInfo& Info);
	static int32 GetGuardRegainRecoveryRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardRegainRecoveryReduceRatio(const struct FDefaultStatInfo& Info);
	static int32 GetGuardStaminaReductionRatio(const struct FDefaultStatInfo& Info);
	static int32 GetHealthPoint(const struct FDefaultStatInfo& Info);
	static int32 GetImpactDebuffResist(const struct FDefaultStatInfo& Info);
	static int32 GetLevel(const struct FDefaultStatInfo& Info);
	static int32 GetMaxFrenzyGaugePerUnit(const struct FDefaultStatInfo& Info);
	static int32 GetModificationDropErgoRemainDecrease(const struct FDefaultStatInfo& Info);
	static int32 GetMotionSpeedRatio(const struct FDefaultStatInfo& Info);
	static int32 GetMotivity(const struct FDefaultStatInfo& Info);
	static int32 GetParalyzationAddDamageRatio(const struct FDefaultStatInfo& Info);
	static int32 GetPerfectguardGroggyenableAddtimeRatio(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalAttack(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalDefence(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalPierceDefence(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalPierceReduce(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalReduce(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalSlashDefence(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalSlashReduce(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalStrikeDefence(const struct FDefaultStatInfo& Info);
	static int32 GetPhysicalStrikeReduce(const struct FDefaultStatInfo& Info);
	static int32 GetPierceAttackRatio(const struct FDefaultStatInfo& Info);
	static int32 GetRigidity(const struct FDefaultStatInfo& Info);
	static int32 GetSharpnessBonus(const struct FDefaultStatInfo& Info);
	static int32 GetSlashAttackRatio(const struct FDefaultStatInfo& Info);
	static int32 GetSlaveAttackGainFrenzyPointRatio(const struct FDefaultStatInfo& Info);
	static int32 GetSlaveMagazinePoint(const struct FDefaultStatInfo& Info);
	static int32 GetSprintConsumeStaminaPerSecond(const struct FDefaultStatInfo& Info);
	static int32 GetSprintSpeedRatio(const struct FDefaultStatInfo& Info);
	static int32 GetStaminaExhaustTime(const struct FDefaultStatInfo& Info);
	static int32 GetStaminaPoint(const struct FDefaultStatInfo& Info);
	static int32 GetStaminaRestorePerSecond(const struct FDefaultStatInfo& Info);
	static int32 GetStrikeAttackRatio(const struct FDefaultStatInfo& Info);
	static int32 GetTechnique(const struct FDefaultStatInfo& Info);
	static int32 GetTenacity(const struct FDefaultStatInfo& Info);
	static int32 GetToughPoint(const struct FDefaultStatInfo& Info);
	static int32 GetToughRecoveryDelayReduction(const struct FDefaultStatInfo& Info);
	static int32 GetToughRecoveryDelayTime(const struct FDefaultStatInfo& Info);
	static int32 GetToughRestorePerSecond(const struct FDefaultStatInfo& Info);
	static int32 GetVigor(const struct FDefaultStatInfo& Info);
	static int32 GetVitality(const struct FDefaultStatInfo& Info);
	static int32 GetWalkRunSpeedRatio(const struct FDefaultStatInfo& Info);
	static int32 GetWeightLimit(const struct FDefaultStatInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultStatInfoFuncLibrary">();
	}
	static class UDefaultStatInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultStatInfoFuncLibrary>();
	}
};
static_assert(alignof(UDefaultStatInfoFuncLibrary) == 0x000008, "Wrong alignment on UDefaultStatInfoFuncLibrary");
static_assert(sizeof(UDefaultStatInfoFuncLibrary) == 0x000028, "Wrong size on UDefaultStatInfoFuncLibrary");

// Class ProjectPContentInfo.FirstStatToSecondStatInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UFirstStatToSecondStatInfoFuncLibrary final : public UObject
{
public:
	static int32 GetConversionValueA(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueB(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueC(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueD(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueE(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueF(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueG(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueH(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueI(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueJ(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueK(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetConversionValueL(const struct FFirstStatToSecondStatInfo& Info);
	static ELFirstStat GetFirstStatA(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatA(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatB(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatC(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatD(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatE(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatF(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatG(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatH(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatI(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatJ(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatK(const struct FFirstStatToSecondStatInfo& Info);
	static ELSecondStat GetSecondStatL(const struct FFirstStatToSecondStatInfo& Info);
	static int32 GetStatLevel(const struct FFirstStatToSecondStatInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstStatToSecondStatInfoFuncLibrary">();
	}
	static class UFirstStatToSecondStatInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstStatToSecondStatInfoFuncLibrary>();
	}
};
static_assert(alignof(UFirstStatToSecondStatInfoFuncLibrary) == 0x000008, "Wrong alignment on UFirstStatToSecondStatInfoFuncLibrary");
static_assert(sizeof(UFirstStatToSecondStatInfoFuncLibrary) == 0x000028, "Wrong size on UFirstStatToSecondStatInfoFuncLibrary");

// Class ProjectPContentInfo.LevelExpInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelExpInfoFuncLibrary final : public UObject
{
public:
	static int32 GetCharacterLevel(const struct FLevelExpInfo& Info);
	static int32 GetCharacterLevelExpAmount(const struct FLevelExpInfo& Info);
	static const class FName GetCodeName(const struct FLevelExpInfo& Info);
	static int32 GetDropsoulNaturalConsumeAmount(const struct FLevelExpInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelExpInfoFuncLibrary">();
	}
	static class ULevelExpInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelExpInfoFuncLibrary>();
	}
};
static_assert(alignof(ULevelExpInfoFuncLibrary) == 0x000008, "Wrong alignment on ULevelExpInfoFuncLibrary");
static_assert(sizeof(ULevelExpInfoFuncLibrary) == 0x000028, "Wrong size on ULevelExpInfoFuncLibrary");

// Class ProjectPContentInfo.LevelExpInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelExpInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetCharacterLevel(const struct FLevelExpInfoPtr& Ptr);
	static int32 GetCharacterLevelExpAmount(const struct FLevelExpInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FLevelExpInfoPtr& Ptr);
	static int32 GetDropsoulNaturalConsumeAmount(const struct FLevelExpInfoPtr& Ptr);
	static bool IsValid(const struct FLevelExpInfoPtr& Ptr);
	static void IsValidBranch(const struct FLevelExpInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelExpInfoPtrFuncLibrary">();
	}
	static class ULevelExpInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelExpInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULevelExpInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULevelExpInfoPtrFuncLibrary");
static_assert(sizeof(ULevelExpInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULevelExpInfoPtrFuncLibrary");

// Class ProjectPContentInfo.LevelHumanityInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelHumanityInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAcquisitionTextCodeName(const struct FLevelHumanityInfo& Info);
	static const class FName GetCodeName(const struct FLevelHumanityInfo& Info);
	static int32 GetHumanityLevel(const struct FLevelHumanityInfo& Info);
	static int32 GetNextLevelHumanity(const struct FLevelHumanityInfo& Info);
	static ELHumanityNoseStaffFormType GetNosestaffForm(const struct FLevelHumanityInfo& Info);
	static bool GetShowText(const struct FLevelHumanityInfo& Info);
	static const class FName GetSoundNotifyTrack(const struct FLevelHumanityInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelHumanityInfoFuncLibrary">();
	}
	static class ULevelHumanityInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelHumanityInfoFuncLibrary>();
	}
};
static_assert(alignof(ULevelHumanityInfoFuncLibrary) == 0x000008, "Wrong alignment on ULevelHumanityInfoFuncLibrary");
static_assert(sizeof(ULevelHumanityInfoFuncLibrary) == 0x000028, "Wrong size on ULevelHumanityInfoFuncLibrary");

// Class ProjectPContentInfo.LevelHumanityInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULevelHumanityInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAcquisitionTextCodeName(const struct FLevelHumanityInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FLevelHumanityInfoPtr& Ptr);
	static int32 GetHumanityLevel(const struct FLevelHumanityInfoPtr& Ptr);
	static int32 GetNextLevelHumanity(const struct FLevelHumanityInfoPtr& Ptr);
	static ELHumanityNoseStaffFormType GetNosestaffForm(const struct FLevelHumanityInfoPtr& Ptr);
	static bool GetShowText(const struct FLevelHumanityInfoPtr& Ptr);
	static const class FName GetSoundNotifyTrack(const struct FLevelHumanityInfoPtr& Ptr);
	static bool IsValid(const struct FLevelHumanityInfoPtr& Ptr);
	static void IsValidBranch(const struct FLevelHumanityInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelHumanityInfoPtrFuncLibrary">();
	}
	static class ULevelHumanityInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelHumanityInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(ULevelHumanityInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on ULevelHumanityInfoPtrFuncLibrary");
static_assert(sizeof(ULevelHumanityInfoPtrFuncLibrary) == 0x000028, "Wrong size on ULevelHumanityInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PCInfoAsset
// 0x0178 (0x01F0 - 0x0078)
class alignas(0x10) UPCInfoAsset final : public UContentInfoAsset
{
public:
	struct FPCInfoDB                              ContentInfoDB;                                     // 0x0078(0x0170)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FDefaultStatInfoPtr FindDefaultStatInfoByNameBP(class FName CodeName);
	static struct FLevelExpInfoPtr FindLevelExpInfoByNameBP(class FName CodeName);
	static struct FLevelHumanityInfoPtr FindLevelHumanityInfoByNameBP(class FName CodeName);
	static const TArray<struct FDefaultStatInfo> GetDefaultStatInfoArrayBP();
	static const TArray<struct FFirstStatToSecondStatInfo> GetFirstStatTOSecondStatInfoArrayBP();
	static const TArray<struct FLevelExpInfo> GetLevelExpInfoArrayBP();
	static const TArray<struct FLevelHumanityInfo> GetLevelHumanityInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PCInfoAsset">();
	}
	static class UPCInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPCInfoAsset>();
	}
};
static_assert(alignof(UPCInfoAsset) == 0x000010, "Wrong alignment on UPCInfoAsset");
static_assert(sizeof(UPCInfoAsset) == 0x0001F0, "Wrong size on UPCInfoAsset");
static_assert(offsetof(UPCInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPCInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ProjectileInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectileInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FProjectileInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FProjectileInfo& Info);
	static int32 GetAbnormalStatePenaltyBase(const struct FProjectileInfo& Info);
	static int32 GetAcidAttack(const struct FProjectileInfo& Info);
	static int32 GetAdditionalGroggyTime(const struct FProjectileInfo& Info);
	static int32 GetBuildUpRecoverIncBase(const struct FProjectileInfo& Info);
	static const class FName GetCodeName(const struct FProjectileInfo& Info);
	static int32 GetCollisionStartDelay(const struct FProjectileInfo& Info);
	static int32 GetConsumeSlaveMagazinePoint(const struct FProjectileInfo& Info);
	static int32 GetConsumeStaminaPoint(const struct FProjectileInfo& Info);
	static const class FName GetCorrectionCodeNameForAdvance(const struct FProjectileInfo& Info);
	static const class FName GetCorrectionCodeNameForMotivity(const struct FProjectileInfo& Info);
	static const class FName GetCorrectionCodeNameForTechnique(const struct FProjectileInfo& Info);
	static int32 GetDestructionPower(const struct FProjectileInfo& Info);
	static int32 GetElectricAttack(const struct FProjectileInfo& Info);
	static float GetFinSpeed(const struct FProjectileInfo& Info);
	static float GetFinSpeedTime(const struct FProjectileInfo& Info);
	static int32 GetFireAttack(const struct FProjectileInfo& Info);
	static float GetForceFireForwardDistance(const struct FProjectileInfo& Info);
	static ELProjectileGenerateType GetGenerateLocType(const struct FProjectileInfo& Info);
	static ELProjectileHitFactionType GetHitFaction(const struct FProjectileInfo& Info);
	static float GetHomingAccelerationMagnitude(const struct FProjectileInfo& Info);
	static bool GetIgnoreCameraPitchWhenMovingForward(const struct FProjectileInfo& Info);
	static float GetInitSpeed(const struct FProjectileInfo& Info);
	static float GetMidSpeed(const struct FProjectileInfo& Info);
	static float GetMidSpeedTime(const struct FProjectileInfo& Info);
	static int32 GetMoveStartTime(const struct FProjectileInfo& Info);
	static ELProjectileMoveTargetType GetMoveType(const struct FProjectileInfo& Info);
	static float GetMoveXyDegree(const struct FProjectileInfo& Info);
	static float GetMoveZDegree(const struct FProjectileInfo& Info);
	static int32 GetNGPDetailIndex(const struct FProjectileInfo& Info);
	static int32 GetPhysicalAttack(const struct FProjectileInfo& Info);
	static ELPhysicalDamageType GetPhysicalAttackSubtype(const struct FProjectileInfo& Info);
	static float GetPitchLimit(const struct FProjectileInfo& Info);
	static const TSoftClassPtr<class UClass> GetProjectileClass(const struct FProjectileInfo& Info);
	static const TSoftClassPtr<class UClass> GetProjectileDesignClass(const struct FProjectileInfo& Info);
	static ELProjectileType GetProjectileType(const struct FProjectileInfo& Info);
	static int32 GetPulseRechargeAttack(const struct FProjectileInfo& Info);
	static float GetSpawnOffsetX(const struct FProjectileInfo& Info);
	static float GetSpawnOffsetY(const struct FProjectileInfo& Info);
	static float GetSpawnOffsetZ(const struct FProjectileInfo& Info);
	static bool GetSpawnOnGround(const struct FProjectileInfo& Info);
	static const class FName GetSpawnSocketName(const struct FProjectileInfo& Info);
	static float GetSpeed(const struct FProjectileInfo& Info);
	static float GetTargetOffsetX(const struct FProjectileInfo& Info);
	static float GetTargetOffsetY(const struct FProjectileInfo& Info);
	static float GetTargetOffsetZ(const struct FProjectileInfo& Info);
	static const class FName GetTargetSocketName(const struct FProjectileInfo& Info);
	static int32 GetToughRecoveryDelayTime(const struct FProjectileInfo& Info);
	static float GetTraceEndAngle(const struct FProjectileInfo& Info);
	static float GetTraceEndDistance(const struct FProjectileInfo& Info);
	static float GetTraceEndFinSpeed(const struct FProjectileInfo& Info);
	static float GetTraceEndFinSpeedTime(const struct FProjectileInfo& Info);
	static float GetTraceEndHalfheight(const struct FProjectileInfo& Info);
	static float GetTraceEndInitSpeed(const struct FProjectileInfo& Info);
	static float GetTraceEndInitSpeedTime(const struct FProjectileInfo& Info);
	static float GetTraceEndMidSpeed(const struct FProjectileInfo& Info);
	static float GetTraceEndMidSpeedTime(const struct FProjectileInfo& Info);
	static float GetTraceIngFinSpeed(const struct FProjectileInfo& Info);
	static float GetTraceIngFinSpeedTime(const struct FProjectileInfo& Info);
	static float GetTraceIngInitSpeed(const struct FProjectileInfo& Info);
	static float GetTraceIngInitSpeedTime(const struct FProjectileInfo& Info);
	static float GetTraceIngMidSpeed(const struct FProjectileInfo& Info);
	static float GetTraceIngMidSpeedTime(const struct FProjectileInfo& Info);
	static float GetTraceStartAngle(const struct FProjectileInfo& Info);
	static float GetTraceStartDistance(const struct FProjectileInfo& Info);
	static float GetTraceStartHalfheight(const struct FProjectileInfo& Info);
	static float GetTraceStartTime(const struct FProjectileInfo& Info);
	static const class FName GetTraceTargetSocket(const struct FProjectileInfo& Info);
	static bool GetUseSocketDirection(const struct FProjectileInfo& Info);
	static float GetYawLimit(const struct FProjectileInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileInfoFuncLibrary">();
	}
	static class UProjectileInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileInfoFuncLibrary>();
	}
};
static_assert(alignof(UProjectileInfoFuncLibrary) == 0x000008, "Wrong alignment on UProjectileInfoFuncLibrary");
static_assert(sizeof(UProjectileInfoFuncLibrary) == 0x000028, "Wrong size on UProjectileInfoFuncLibrary");

// Class ProjectPContentInfo.ProjectileInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectileInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttack(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FProjectileInfoPtr& Ptr);
	static int32 GetAbnormalStatePenaltyBase(const struct FProjectileInfoPtr& Ptr);
	static int32 GetAcidAttack(const struct FProjectileInfoPtr& Ptr);
	static int32 GetAdditionalGroggyTime(const struct FProjectileInfoPtr& Ptr);
	static int32 GetBuildUpRecoverIncBase(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FProjectileInfoPtr& Ptr);
	static int32 GetCollisionStartDelay(const struct FProjectileInfoPtr& Ptr);
	static int32 GetConsumeSlaveMagazinePoint(const struct FProjectileInfoPtr& Ptr);
	static int32 GetConsumeStaminaPoint(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForAdvance(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForMotivity(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetCorrectionCodeNameForTechnique(const struct FProjectileInfoPtr& Ptr);
	static int32 GetDestructionPower(const struct FProjectileInfoPtr& Ptr);
	static int32 GetElectricAttack(const struct FProjectileInfoPtr& Ptr);
	static float GetFinSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetFinSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static int32 GetFireAttack(const struct FProjectileInfoPtr& Ptr);
	static float GetForceFireForwardDistance(const struct FProjectileInfoPtr& Ptr);
	static ELProjectileGenerateType GetGenerateLocType(const struct FProjectileInfoPtr& Ptr);
	static ELProjectileHitFactionType GetHitFaction(const struct FProjectileInfoPtr& Ptr);
	static float GetHomingAccelerationMagnitude(const struct FProjectileInfoPtr& Ptr);
	static bool GetIgnoreCameraPitchWhenMovingForward(const struct FProjectileInfoPtr& Ptr);
	static float GetInitSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetMidSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetMidSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static int32 GetMoveStartTime(const struct FProjectileInfoPtr& Ptr);
	static ELProjectileMoveTargetType GetMoveType(const struct FProjectileInfoPtr& Ptr);
	static float GetMoveXyDegree(const struct FProjectileInfoPtr& Ptr);
	static float GetMoveZDegree(const struct FProjectileInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FProjectileInfoPtr& Ptr);
	static int32 GetPhysicalAttack(const struct FProjectileInfoPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalAttackSubtype(const struct FProjectileInfoPtr& Ptr);
	static float GetPitchLimit(const struct FProjectileInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetProjectileClass(const struct FProjectileInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetProjectileDesignClass(const struct FProjectileInfoPtr& Ptr);
	static ELProjectileType GetProjectileType(const struct FProjectileInfoPtr& Ptr);
	static int32 GetPulseRechargeAttack(const struct FProjectileInfoPtr& Ptr);
	static float GetSpawnOffsetX(const struct FProjectileInfoPtr& Ptr);
	static float GetSpawnOffsetY(const struct FProjectileInfoPtr& Ptr);
	static float GetSpawnOffsetZ(const struct FProjectileInfoPtr& Ptr);
	static bool GetSpawnOnGround(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetSpawnSocketName(const struct FProjectileInfoPtr& Ptr);
	static float GetSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTargetOffsetX(const struct FProjectileInfoPtr& Ptr);
	static float GetTargetOffsetY(const struct FProjectileInfoPtr& Ptr);
	static float GetTargetOffsetZ(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetTargetSocketName(const struct FProjectileInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndAngle(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndDistance(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndFinSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndFinSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndHalfheight(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndInitSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndInitSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndMidSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceEndMidSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceIngFinSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceIngFinSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceIngInitSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceIngInitSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceIngMidSpeed(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceIngMidSpeedTime(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceStartAngle(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceStartDistance(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceStartHalfheight(const struct FProjectileInfoPtr& Ptr);
	static float GetTraceStartTime(const struct FProjectileInfoPtr& Ptr);
	static const class FName GetTraceTargetSocket(const struct FProjectileInfoPtr& Ptr);
	static bool GetUseSocketDirection(const struct FProjectileInfoPtr& Ptr);
	static float GetYawLimit(const struct FProjectileInfoPtr& Ptr);
	static bool IsValid(const struct FProjectileInfoPtr& Ptr);
	static void IsValidBranch(const struct FProjectileInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileInfoPtrFuncLibrary">();
	}
	static class UProjectileInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UProjectileInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UProjectileInfoPtrFuncLibrary");
static_assert(sizeof(UProjectileInfoPtrFuncLibrary) == 0x000028, "Wrong size on UProjectileInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ProjectileInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UProjectileInfoAsset final : public UContentInfoAsset
{
public:
	struct FProjectileInfoDB                      ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FProjectileInfoPtr FindProjectileInfoByNameBP(class FName CodeName);
	static const TArray<struct FProjectileInfo> GetProjectileInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileInfoAsset">();
	}
	static class UProjectileInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileInfoAsset>();
	}
};
static_assert(alignof(UProjectileInfoAsset) == 0x000010, "Wrong alignment on UProjectileInfoAsset");
static_assert(sizeof(UProjectileInfoAsset) == 0x000120, "Wrong size on UProjectileInfoAsset");
static_assert(offsetof(UProjectileInfoAsset, ContentInfoDB) == 0x000078, "Member 'UProjectileInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropDestructionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropDestructionInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropDestructionInfo& Info);
	static bool GetDestroyOnlyOnce(const struct FPropDestructionInfo& Info);
	static ELDestructionConditionActionType GetDestructionConditionActionType(const struct FPropDestructionInfo& Info);
	static class FString GetDestructionConditionActorCodename(const struct FPropDestructionInfo& Info);
	static ELDeathByOwnerFaction GetDestructionConditionActorType(const struct FPropDestructionInfo& Info);
	static const TArray<class FName> GetDestructionConditionSkillCodename(const struct FPropDestructionInfo& Info);
	static const TArray<class FName> GetDestructionConditionSkillhitCodename(const struct FPropDestructionInfo& Info);
	static const class FName GetDrop(const struct FPropDestructionInfo& Info);
	static const class FName GetDropProp(const struct FPropDestructionInfo& Info);
	static int32 GetHp(const struct FPropDestructionInfo& Info);
	static ELHpDiscountMethod GetHpDiscountMethod(const struct FPropDestructionInfo& Info);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropDestructionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropDestructionInfoFuncLibrary">();
	}
	static class UPropDestructionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropDestructionInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropDestructionInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropDestructionInfoFuncLibrary");
static_assert(sizeof(UPropDestructionInfoFuncLibrary) == 0x000028, "Wrong size on UPropDestructionInfoFuncLibrary");

// Class ProjectPContentInfo.PropDestructionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropDestructionInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropDestructionInfoPtr& Ptr);
	static bool GetDestroyOnlyOnce(const struct FPropDestructionInfoPtr& Ptr);
	static ELDestructionConditionActionType GetDestructionConditionActionType(const struct FPropDestructionInfoPtr& Ptr);
	static class FString GetDestructionConditionActorCodename(const struct FPropDestructionInfoPtr& Ptr);
	static ELDeathByOwnerFaction GetDestructionConditionActorType(const struct FPropDestructionInfoPtr& Ptr);
	static const TArray<class FName> GetDestructionConditionSkillCodename(const struct FPropDestructionInfoPtr& Ptr);
	static const TArray<class FName> GetDestructionConditionSkillhitCodename(const struct FPropDestructionInfoPtr& Ptr);
	static const class FName GetDrop(const struct FPropDestructionInfoPtr& Ptr);
	static const class FName GetDropProp(const struct FPropDestructionInfoPtr& Ptr);
	static int32 GetHp(const struct FPropDestructionInfoPtr& Ptr);
	static ELHpDiscountMethod GetHpDiscountMethod(const struct FPropDestructionInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropDestructionInfoPtr& Ptr);
	static bool IsValid(const struct FPropDestructionInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropDestructionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropDestructionInfoPtrFuncLibrary">();
	}
	static class UPropDestructionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropDestructionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropDestructionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropDestructionInfoPtrFuncLibrary");
static_assert(sizeof(UPropDestructionInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropDestructionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropDestructionInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropDestructionInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropDestructionInfoDB                 ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropDestructionInfo> GetPropDestructionInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropDestructionInfoAsset">();
	}
	static class UPropDestructionInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropDestructionInfoAsset>();
	}
};
static_assert(alignof(UPropDestructionInfoAsset) == 0x000010, "Wrong alignment on UPropDestructionInfoAsset");
static_assert(sizeof(UPropDestructionInfoAsset) == 0x0000D0, "Wrong size on UPropDestructionInfoAsset");
static_assert(offsetof(UPropDestructionInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropDestructionInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropDoorInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropDoorInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropDoorInfo& Info);
	static const class FName GetContentCommandCodename(const struct FPropDoorInfo& Info);
	static bool GetDelConditionItem(const struct FPropDoorInfo& Info);
	static ELMessageAlertType GetFailMessageType(const struct FPropDoorInfo& Info);
	static bool GetFixCameraOnInterAction(const struct FPropDoorInfo& Info);
	static const class FName GetInteractionApproachMessageCodeName(const struct FPropDoorInfo& Info);
	static const class FName GetInteractionCondition(const struct FPropDoorInfo& Info);
	static const class FName GetInteractionConditionFailApproachMessage(const struct FPropDoorInfo& Info);
	static const class FName GetInteractionConditionFailMessage(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionConditionFailPropMotionResource(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionConditionFailUserMotionResource(const struct FPropDoorInfo& Info);
	static int32 GetInteractionConditionHumanPoint(const struct FPropDoorInfo& Info);
	static const class FName GetInteractionConditionItem(const struct FPropDoorInfo& Info);
	static int32 GetInteractionConfrontAngle(const struct FPropDoorInfo& Info);
	static int32 GetInteractionConfrontAngleProp(const struct FPropDoorInfo& Info);
	static float GetInteractionMessageTime(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionPropMotionResource(const struct FPropDoorInfo& Info);
	static int32 GetInteractionRadius(const struct FPropDoorInfo& Info);
	static const class FName GetInteractionSuccessMassage(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropDoorInfo& Info);
	static ELPropInteractType GetInteractType(const struct FPropDoorInfo& Info);
	static ELLinkedPropExecute GetLinkedPropExecute(const struct FPropDoorInfo& Info);
	static bool GetLinkedPropStateChange(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoopMotionResource(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropDoorInfo& Info);
	static int32 GetState(const struct FPropDoorInfo& Info);
	static ELMessageAlertType GetSuccesMessageType(const struct FPropDoorInfo& Info);
	static const class FName GetUseLevelSequence(const struct FPropDoorInfo& Info);
	static const class FName GetWrongApproachMessageCodeName(const struct FPropDoorInfo& Info);
	static const class FName GetWrongApproachNextMessageCodeName(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetWrongApproachPropMotionResource(const struct FPropDoorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetWrongApproachUserMotionResource(const struct FPropDoorInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropDoorInfoFuncLibrary">();
	}
	static class UPropDoorInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropDoorInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropDoorInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropDoorInfoFuncLibrary");
static_assert(sizeof(UPropDoorInfoFuncLibrary) == 0x000028, "Wrong size on UPropDoorInfoFuncLibrary");

// Class ProjectPContentInfo.PropDoorInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropDoorInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetContentCommandCodename(const struct FPropDoorInfoPtr& Ptr);
	static bool GetDelConditionItem(const struct FPropDoorInfoPtr& Ptr);
	static ELMessageAlertType GetFailMessageType(const struct FPropDoorInfoPtr& Ptr);
	static bool GetFixCameraOnInterAction(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetInteractionApproachMessageCodeName(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetInteractionCondition(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetInteractionConditionFailApproachMessage(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetInteractionConditionFailMessage(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionConditionFailPropMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionConditionFailUserMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static int32 GetInteractionConditionHumanPoint(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetInteractionConditionItem(const struct FPropDoorInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngle(const struct FPropDoorInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngleProp(const struct FPropDoorInfoPtr& Ptr);
	static float GetInteractionMessageTime(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionPropMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static int32 GetInteractionRadius(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetInteractionSuccessMassage(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static ELPropInteractType GetInteractType(const struct FPropDoorInfoPtr& Ptr);
	static ELLinkedPropExecute GetLinkedPropExecute(const struct FPropDoorInfoPtr& Ptr);
	static bool GetLinkedPropStateChange(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoopMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropDoorInfoPtr& Ptr);
	static int32 GetState(const struct FPropDoorInfoPtr& Ptr);
	static ELMessageAlertType GetSuccesMessageType(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetUseLevelSequence(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetWrongApproachMessageCodeName(const struct FPropDoorInfoPtr& Ptr);
	static const class FName GetWrongApproachNextMessageCodeName(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetWrongApproachPropMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetWrongApproachUserMotionResource(const struct FPropDoorInfoPtr& Ptr);
	static bool IsValid(const struct FPropDoorInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropDoorInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropDoorInfoPtrFuncLibrary">();
	}
	static class UPropDoorInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropDoorInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropDoorInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropDoorInfoPtrFuncLibrary");
static_assert(sizeof(UPropDoorInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropDoorInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropDoorInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropDoorInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropDoorInfoDB                        ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropDoorInfo> GetPropDoorInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropDoorInfoAsset">();
	}
	static class UPropDoorInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropDoorInfoAsset>();
	}
};
static_assert(alignof(UPropDoorInfoAsset) == 0x000010, "Wrong alignment on UPropDoorInfoAsset");
static_assert(sizeof(UPropDoorInfoAsset) == 0x0000D0, "Wrong size on UPropDoorInfoAsset");
static_assert(offsetof(UPropDoorInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropDoorInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropInfoFuncLibrary final : public UObject
{
public:
	static bool GetCanChangeDestructionMode(const struct FPropInfo& Info);
	static int32 GetCanPlayDeathMotion(const struct FPropInfo& Info);
	static const class FName GetCodeName(const struct FPropInfo& Info);
	static ELDeathByOwnerFaction GetDeathByOwnerFaction(const struct FPropInfo& Info);
	static const TSoftObjectPtr<class UObject> GetDestructionSound(const struct FPropInfo& Info);
	static class FString GetDetailOfDeathByOwnerFaction(const struct FPropInfo& Info);
	static bool GetFixCameraOnInterAction(const struct FPropInfo& Info);
	static int32 GetHp(const struct FPropInfo& Info);
	static int32 GetHpDiscountMethod(const struct FPropInfo& Info);
	static const class FName GetInteractionApproachMessageCodeName(const struct FPropInfo& Info);
	static int32 GetInteractionConfrontAngle(const struct FPropInfo& Info);
	static int32 GetInteractionConfrontAngleProp(const struct FPropInfo& Info);
	static int32 GetInteractionOffsetX(const struct FPropInfo& Info);
	static int32 GetInteractionOffsetY(const struct FPropInfo& Info);
	static int32 GetInteractionOffsetZ(const struct FPropInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionPropMotionResource(const struct FPropInfo& Info);
	static int32 GetInteractionRadius(const struct FPropInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropInfo& Info);
	static bool GetIsPossibleAttackReaction(const struct FPropInfo& Info);
	static bool GetIsPossibleAttackResistance(const struct FPropInfo& Info);
	static bool GetIsPossibleBlocking(const struct FPropInfo& Info);
	static bool GetIsPossibleBlockingRemains(const struct FPropInfo& Info);
	static bool GetIsPossibleDeath(const struct FPropInfo& Info);
	static bool GetIsPossiblePhysicalReaction(const struct FPropInfo& Info);
	static bool GetIsPossiblePhysicalReactionRemains(const struct FPropInfo& Info);
	static int32 GetMaintainTimeAfterDeath(const struct FPropInfo& Info);
	static int32 GetMass(const struct FPropInfo& Info);
	static EFxBranchType GetMaterial(const struct FPropInfo& Info);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropInfo& Info);
	static const TSoftObjectPtr<class UObject> GetMotionResource(const struct FPropInfo& Info);
	static const TSoftClassPtr<class UClass> GetPropClass(const struct FPropInfo& Info);
	static bool GetRespawnEnable(const struct FPropInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSoundResource(const struct FPropInfo& Info);
	static int32 GetState(const struct FPropInfo& Info);
	static bool GetStateFreezing(const struct FPropInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropInfoFuncLibrary">();
	}
	static class UPropInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropInfoFuncLibrary");
static_assert(sizeof(UPropInfoFuncLibrary) == 0x000028, "Wrong size on UPropInfoFuncLibrary");

// Class ProjectPContentInfo.PropInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetCanChangeDestructionMode(const struct FPropInfoPtr& Ptr);
	static int32 GetCanPlayDeathMotion(const struct FPropInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FPropInfoPtr& Ptr);
	static ELDeathByOwnerFaction GetDeathByOwnerFaction(const struct FPropInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetDestructionSound(const struct FPropInfoPtr& Ptr);
	static class FString GetDetailOfDeathByOwnerFaction(const struct FPropInfoPtr& Ptr);
	static bool GetFixCameraOnInterAction(const struct FPropInfoPtr& Ptr);
	static int32 GetHp(const struct FPropInfoPtr& Ptr);
	static int32 GetHpDiscountMethod(const struct FPropInfoPtr& Ptr);
	static const class FName GetInteractionApproachMessageCodeName(const struct FPropInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngle(const struct FPropInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngleProp(const struct FPropInfoPtr& Ptr);
	static int32 GetInteractionOffsetX(const struct FPropInfoPtr& Ptr);
	static int32 GetInteractionOffsetY(const struct FPropInfoPtr& Ptr);
	static int32 GetInteractionOffsetZ(const struct FPropInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionPropMotionResource(const struct FPropInfoPtr& Ptr);
	static int32 GetInteractionRadius(const struct FPropInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossibleAttackReaction(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossibleAttackResistance(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossibleBlocking(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossibleBlockingRemains(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossibleDeath(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossiblePhysicalReaction(const struct FPropInfoPtr& Ptr);
	static bool GetIsPossiblePhysicalReactionRemains(const struct FPropInfoPtr& Ptr);
	static int32 GetMaintainTimeAfterDeath(const struct FPropInfoPtr& Ptr);
	static int32 GetMass(const struct FPropInfoPtr& Ptr);
	static EFxBranchType GetMaterial(const struct FPropInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetMotionResource(const struct FPropInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetPropClass(const struct FPropInfoPtr& Ptr);
	static bool GetRespawnEnable(const struct FPropInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSoundResource(const struct FPropInfoPtr& Ptr);
	static int32 GetState(const struct FPropInfoPtr& Ptr);
	static bool GetStateFreezing(const struct FPropInfoPtr& Ptr);
	static bool IsValid(const struct FPropInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropInfoPtrFuncLibrary">();
	}
	static class UPropInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropInfoPtrFuncLibrary");
static_assert(sizeof(UPropInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropInfoDB                            ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropInfo> GetPropInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropInfoAsset">();
	}
	static class UPropInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropInfoAsset>();
	}
};
static_assert(alignof(UPropInfoAsset) == 0x000010, "Wrong alignment on UPropInfoAsset");
static_assert(sizeof(UPropInfoAsset) == 0x0000D0, "Wrong size on UPropInfoAsset");
static_assert(offsetof(UPropInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropLadderInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropLadderInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropLadderInfo& Info);
	static const class FName GetContentCommandCodename(const struct FPropLadderInfo& Info);
	static const class FName GetDownstairInteractionApproachMessageCodeName(const struct FPropLadderInfo& Info);
	static int32 GetDownstairInteractionConfrontAngle(const struct FPropLadderInfo& Info);
	static int32 GetDownstairInteractionConfrontAngleProp(const struct FPropLadderInfo& Info);
	static int32 GetDownstairInteractionRadius(const struct FPropLadderInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropLadderInfo& Info);
	static ELPhysicalSurfaceType GetLadderMaterial(const struct FPropLadderInfo& Info);
	static ELPropLadderStateType GetLadderState(const struct FPropLadderInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoopMotionResource(const struct FPropLadderInfo& Info);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropLadderInfo& Info);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropLadderInfo& Info);
	static const class FName GetUpstairInteractionApproachMessageCodeName(const struct FPropLadderInfo& Info);
	static const class FName GetUpstairInteractionCondition(const struct FPropLadderInfo& Info);
	static const class FName GetUpstairInteractionConditionFailMessage(const struct FPropLadderInfo& Info);
	static int32 GetUpstairInteractionConfrontAngle(const struct FPropLadderInfo& Info);
	static int32 GetUpstairInteractionConfrontAngleProp(const struct FPropLadderInfo& Info);
	static const TSoftObjectPtr<class UObject> GetUpstairInteractionPropMotionResource(const struct FPropLadderInfo& Info);
	static int32 GetUpstairInteractionRadius(const struct FPropLadderInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropLadderInfoFuncLibrary">();
	}
	static class UPropLadderInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropLadderInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropLadderInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropLadderInfoFuncLibrary");
static_assert(sizeof(UPropLadderInfoFuncLibrary) == 0x000028, "Wrong size on UPropLadderInfoFuncLibrary");

// Class ProjectPContentInfo.PropLadderInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropLadderInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropLadderInfoPtr& Ptr);
	static const class FName GetContentCommandCodename(const struct FPropLadderInfoPtr& Ptr);
	static const class FName GetDownstairInteractionApproachMessageCodeName(const struct FPropLadderInfoPtr& Ptr);
	static int32 GetDownstairInteractionConfrontAngle(const struct FPropLadderInfoPtr& Ptr);
	static int32 GetDownstairInteractionConfrontAngleProp(const struct FPropLadderInfoPtr& Ptr);
	static int32 GetDownstairInteractionRadius(const struct FPropLadderInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropLadderInfoPtr& Ptr);
	static ELPhysicalSurfaceType GetLadderMaterial(const struct FPropLadderInfoPtr& Ptr);
	static ELPropLadderStateType GetLadderState(const struct FPropLadderInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoopMotionResource(const struct FPropLadderInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropLadderInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropLadderInfoPtr& Ptr);
	static const class FName GetUpstairInteractionApproachMessageCodeName(const struct FPropLadderInfoPtr& Ptr);
	static const class FName GetUpstairInteractionCondition(const struct FPropLadderInfoPtr& Ptr);
	static const class FName GetUpstairInteractionConditionFailMessage(const struct FPropLadderInfoPtr& Ptr);
	static int32 GetUpstairInteractionConfrontAngle(const struct FPropLadderInfoPtr& Ptr);
	static int32 GetUpstairInteractionConfrontAngleProp(const struct FPropLadderInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetUpstairInteractionPropMotionResource(const struct FPropLadderInfoPtr& Ptr);
	static int32 GetUpstairInteractionRadius(const struct FPropLadderInfoPtr& Ptr);
	static bool IsValid(const struct FPropLadderInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropLadderInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropLadderInfoPtrFuncLibrary">();
	}
	static class UPropLadderInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropLadderInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropLadderInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropLadderInfoPtrFuncLibrary");
static_assert(sizeof(UPropLadderInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropLadderInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropLadderInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropLadderInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropLadderInfoDB                      ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropLadderInfo> GetPropLadderInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropLadderInfoAsset">();
	}
	static class UPropLadderInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropLadderInfoAsset>();
	}
};
static_assert(alignof(UPropLadderInfoAsset) == 0x000010, "Wrong alignment on UPropLadderInfoAsset");
static_assert(sizeof(UPropLadderInfoAsset) == 0x0000D0, "Wrong size on UPropLadderInfoAsset");
static_assert(offsetof(UPropLadderInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropLadderInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropLiftInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropLiftInfoFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetActivateInteractionUserMotionResource(const struct FPropLiftInfo& Info);
	static const TSoftObjectPtr<class UObject> GetCallFailInteractionUserMotionResource(const struct FPropLiftInfo& Info);
	static const class FName GetCodeName(const struct FPropLiftInfo& Info);
	static const class FName GetConditionCheckFailMessage(const struct FPropLiftInfo& Info);
	static const class FName GetContentCondition(const struct FPropLiftInfo& Info);
	static const class FName GetElevatorInteractionMessageCodeName(const struct FPropLiftInfo& Info);
	static int32 GetInitState(const struct FPropLiftInfo& Info);
	static ELPropLiftStateType GetLiftState(const struct FPropLiftInfo& Info);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropLiftInfo& Info);
	static const TSoftObjectPtr<class UObject> GetMoveInteractionUserMotionResource(const struct FPropLiftInfo& Info);
	static const TSoftObjectPtr<class UObject> GetMovingCurve(const struct FPropLiftInfo& Info);
	static int32 GetMovingTime(const struct FPropLiftInfo& Info);
	static const TSoftClassPtr<class UClass> GetPointADoorBP(const struct FPropLiftInfo& Info);
	static const TSoftClassPtr<class UClass> GetPointATriggerBP(const struct FPropLiftInfo& Info);
	static const class FName GetPointATriggerConditionCheckFailMessage(const struct FPropLiftInfo& Info);
	static const class FName GetPointATriggerContentCondition(const struct FPropLiftInfo& Info);
	static const TSoftClassPtr<class UClass> GetPointBDoorBP(const struct FPropLiftInfo& Info);
	static const TSoftClassPtr<class UClass> GetPointBTriggerBP(const struct FPropLiftInfo& Info);
	static const class FName GetPointBTriggerConditionCheckFailMessage(const struct FPropLiftInfo& Info);
	static const class FName GetPointBTriggerContentCondition(const struct FPropLiftInfo& Info);
	static const class FName GetTriggerInteractionMessageCodeName(const struct FPropLiftInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropLiftInfoFuncLibrary">();
	}
	static class UPropLiftInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropLiftInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropLiftInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropLiftInfoFuncLibrary");
static_assert(sizeof(UPropLiftInfoFuncLibrary) == 0x000028, "Wrong size on UPropLiftInfoFuncLibrary");

// Class ProjectPContentInfo.PropLiftInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropLiftInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetActivateInteractionUserMotionResource(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetCallFailInteractionUserMotionResource(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetConditionCheckFailMessage(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetContentCondition(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetElevatorInteractionMessageCodeName(const struct FPropLiftInfoPtr& Ptr);
	static int32 GetInitState(const struct FPropLiftInfoPtr& Ptr);
	static ELPropLiftStateType GetLiftState(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetMoveInteractionUserMotionResource(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetMovingCurve(const struct FPropLiftInfoPtr& Ptr);
	static int32 GetMovingTime(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetPointADoorBP(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetPointATriggerBP(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetPointATriggerConditionCheckFailMessage(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetPointATriggerContentCondition(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetPointBDoorBP(const struct FPropLiftInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetPointBTriggerBP(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetPointBTriggerConditionCheckFailMessage(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetPointBTriggerContentCondition(const struct FPropLiftInfoPtr& Ptr);
	static const class FName GetTriggerInteractionMessageCodeName(const struct FPropLiftInfoPtr& Ptr);
	static bool IsValid(const struct FPropLiftInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropLiftInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropLiftInfoPtrFuncLibrary">();
	}
	static class UPropLiftInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropLiftInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropLiftInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropLiftInfoPtrFuncLibrary");
static_assert(sizeof(UPropLiftInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropLiftInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropLiftInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropLiftInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropLiftInfoDB                        ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropLiftInfo> GetPropLiftInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropLiftInfoAsset">();
	}
	static class UPropLiftInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropLiftInfoAsset>();
	}
};
static_assert(alignof(UPropLiftInfoAsset) == 0x000010, "Wrong alignment on UPropLiftInfoAsset");
static_assert(sizeof(UPropLiftInfoAsset) == 0x0000D0, "Wrong size on UPropLiftInfoAsset");
static_assert(offsetof(UPropLiftInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropLiftInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropSetProjectileInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropSetProjectileInfoFuncLibrary final : public UObject
{
public:
	static bool GetActiveFire(const struct FPropSetProjectileInfo& Info);
	static const class FName GetCodeName(const struct FPropSetProjectileInfo& Info);
	static const class FName GetDefaultMontageSection(const struct FPropSetProjectileInfo& Info);
	static const class FName GetFireMontageSection(const struct FPropSetProjectileInfo& Info);
	static int32 GetInitState(const struct FPropSetProjectileInfo& Info);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropSetProjectileInfo& Info);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropSetProjectileInfo& Info);
	static const TSoftObjectPtr<class UObject> GetMontageResource(const struct FPropSetProjectileInfo& Info);
	static int32 GetSetStateNum(const struct FPropSetProjectileInfo& Info);
	static int32 GetState(const struct FPropSetProjectileInfo& Info);
	static ELPropVolumeStateCheckType GetVolumeCheckChangeState(const struct FPropSetProjectileInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropSetProjectileInfoFuncLibrary">();
	}
	static class UPropSetProjectileInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropSetProjectileInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropSetProjectileInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropSetProjectileInfoFuncLibrary");
static_assert(sizeof(UPropSetProjectileInfoFuncLibrary) == 0x000028, "Wrong size on UPropSetProjectileInfoFuncLibrary");

// Class ProjectPContentInfo.PropSetProjectileInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropSetProjectileInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetActiveFire(const struct FPropSetProjectileInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FPropSetProjectileInfoPtr& Ptr);
	static const class FName GetDefaultMontageSection(const struct FPropSetProjectileInfoPtr& Ptr);
	static const class FName GetFireMontageSection(const struct FPropSetProjectileInfoPtr& Ptr);
	static int32 GetInitState(const struct FPropSetProjectileInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropSetProjectileInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropSetProjectileInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetMontageResource(const struct FPropSetProjectileInfoPtr& Ptr);
	static int32 GetSetStateNum(const struct FPropSetProjectileInfoPtr& Ptr);
	static int32 GetState(const struct FPropSetProjectileInfoPtr& Ptr);
	static ELPropVolumeStateCheckType GetVolumeCheckChangeState(const struct FPropSetProjectileInfoPtr& Ptr);
	static bool IsValid(const struct FPropSetProjectileInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropSetProjectileInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropSetProjectileInfoPtrFuncLibrary">();
	}
	static class UPropSetProjectileInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropSetProjectileInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropSetProjectileInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropSetProjectileInfoPtrFuncLibrary");
static_assert(sizeof(UPropSetProjectileInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropSetProjectileInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropSetProjectileInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropSetProjectileInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropSetProjectileInfoDB               ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropSetProjectileInfo> GetPropSetProjectileInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropSetProjectileInfoAsset">();
	}
	static class UPropSetProjectileInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropSetProjectileInfoAsset>();
	}
};
static_assert(alignof(UPropSetProjectileInfoAsset) == 0x000010, "Wrong alignment on UPropSetProjectileInfoAsset");
static_assert(sizeof(UPropSetProjectileInfoAsset) == 0x0000D0, "Wrong size on UPropSetProjectileInfoAsset");
static_assert(offsetof(UPropSetProjectileInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropSetProjectileInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropShapeObjectInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropShapeObjectInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropShapeObjectInfo& Info);
	static const class FName GetContentCommandCodename(const struct FPropShapeObjectInfo& Info);
	static bool GetDelConditionItem(const struct FPropShapeObjectInfo& Info);
	static const class FName GetDrop(const struct FPropShapeObjectInfo& Info);
	static bool GetDropItemspot(const struct FPropShapeObjectInfo& Info);
	static const class FName GetDropProp(const struct FPropShapeObjectInfo& Info);
	static ELMessageAlertType GetFailMessageType(const struct FPropShapeObjectInfo& Info);
	static bool GetFixCameraOnInterAction(const struct FPropShapeObjectInfo& Info);
	static int32 GetInitState(const struct FPropShapeObjectInfo& Info);
	static const class FName GetInteractionApproachMessageCodeName(const struct FPropShapeObjectInfo& Info);
	static const class FName GetInteractionCondition(const struct FPropShapeObjectInfo& Info);
	static const class FName GetInteractionConditionFailApproachMessage(const struct FPropShapeObjectInfo& Info);
	static const class FName GetInteractionConditionFailMessage(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionConditionHumanPoint(const struct FPropShapeObjectInfo& Info);
	static const class FName GetInteractionConditionItem(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionConfrontAngle(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionConfrontAngleProp(const struct FPropShapeObjectInfo& Info);
	static float GetInteractionMessageTime(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionOffsetX(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionOffsetY(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionOffsetZ(const struct FPropShapeObjectInfo& Info);
	static float GetInteractionPropMotionDelayTime(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionPropMotionResource(const struct FPropShapeObjectInfo& Info);
	static int32 GetInteractionRadius(const struct FPropShapeObjectInfo& Info);
	static const class FName GetInteractionSuccessMassage(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropShapeObjectInfo& Info);
	static ELPropInteractType GetInteractType(const struct FPropShapeObjectInfo& Info);
	static bool GetIsPossibleBlocking(const struct FPropShapeObjectInfo& Info);
	static bool GetItemGetState(const struct FPropShapeObjectInfo& Info);
	static ELLinkedPropExecute GetLinkedPropExecute(const struct FPropShapeObjectInfo& Info);
	static bool GetLinkedPropStateChange(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoopMotionResource(const struct FPropShapeObjectInfo& Info);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropShapeObjectInfo& Info);
	static bool GetResetState(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetReversePropMotionResource(const struct FPropShapeObjectInfo& Info);
	static bool GetReverseReact(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetReverseUserMotionResource(const struct FPropShapeObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSoundResource(const struct FPropShapeObjectInfo& Info);
	static int32 GetState(const struct FPropShapeObjectInfo& Info);
	static ELMessageAlertType GetSuccesMessageType(const struct FPropShapeObjectInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropShapeObjectInfoFuncLibrary">();
	}
	static class UPropShapeObjectInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropShapeObjectInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropShapeObjectInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropShapeObjectInfoFuncLibrary");
static_assert(sizeof(UPropShapeObjectInfoFuncLibrary) == 0x000028, "Wrong size on UPropShapeObjectInfoFuncLibrary");

// Class ProjectPContentInfo.PropShapeObjectInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropShapeObjectInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetContentCommandCodename(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetDelConditionItem(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetDrop(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetDropItemspot(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetDropProp(const struct FPropShapeObjectInfoPtr& Ptr);
	static ELMessageAlertType GetFailMessageType(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetFixCameraOnInterAction(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInitState(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetInteractionApproachMessageCodeName(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetInteractionCondition(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetInteractionConditionFailApproachMessage(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetInteractionConditionFailMessage(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionConditionHumanPoint(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetInteractionConditionItem(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngle(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionConfrontAngleProp(const struct FPropShapeObjectInfoPtr& Ptr);
	static float GetInteractionMessageTime(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionOffsetX(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionOffsetY(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionOffsetZ(const struct FPropShapeObjectInfoPtr& Ptr);
	static float GetInteractionPropMotionDelayTime(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionPropMotionResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetInteractionRadius(const struct FPropShapeObjectInfoPtr& Ptr);
	static const class FName GetInteractionSuccessMassage(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetInteractionUserMotionResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static ELPropInteractType GetInteractType(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetIsPossibleBlocking(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetItemGetState(const struct FPropShapeObjectInfoPtr& Ptr);
	static ELLinkedPropExecute GetLinkedPropExecute(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetLinkedPropStateChange(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoopMotionResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftClassPtr<class UClass> GetModelBP(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetModelResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetResetState(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetReversePropMotionResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool GetReverseReact(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetReverseUserMotionResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSoundResource(const struct FPropShapeObjectInfoPtr& Ptr);
	static int32 GetState(const struct FPropShapeObjectInfoPtr& Ptr);
	static ELMessageAlertType GetSuccesMessageType(const struct FPropShapeObjectInfoPtr& Ptr);
	static bool IsValid(const struct FPropShapeObjectInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropShapeObjectInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropShapeObjectInfoPtrFuncLibrary">();
	}
	static class UPropShapeObjectInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropShapeObjectInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropShapeObjectInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropShapeObjectInfoPtrFuncLibrary");
static_assert(sizeof(UPropShapeObjectInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropShapeObjectInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropShapeObjectInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropShapeObjectInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropShapeObjectInfoDB                 ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropShapeObjectInfo> GetPropShapeObjectInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropShapeObjectInfoAsset">();
	}
	static class UPropShapeObjectInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropShapeObjectInfoAsset>();
	}
};
static_assert(alignof(UPropShapeObjectInfoAsset) == 0x000010, "Wrong alignment on UPropShapeObjectInfoAsset");
static_assert(sizeof(UPropShapeObjectInfoAsset) == 0x0000D0, "Wrong size on UPropShapeObjectInfoAsset");
static_assert(offsetof(UPropShapeObjectInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropShapeObjectInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PropVolumeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropVolumeInfoFuncLibrary final : public UObject
{
public:
	static ELAbnomalStateApplyType GetAbnomalStateApplyType(const struct FPropVolumeInfo& Info);
	static int32 GetAbnomalStateBuildupDamage(const struct FPropVolumeInfo& Info);
	static int32 GetAbnomalStateBuildupDamageTickTime(const struct FPropVolumeInfo& Info);
	static const class FName GetAbnomalStateCodename(const struct FPropVolumeInfo& Info);
	static int32 GetAbnomalStateDurationTimepassDelayRatioAdd(const struct FPropVolumeInfo& Info);
	static const TArray<EFactionType> GetAbnomalStateTargetFilter(const struct FPropVolumeInfo& Info);
	static int32 GetAbnormalStatePenaltyBase(const struct FPropVolumeInfo& Info);
	static int32 GetBuildUpRecoverIncBase(const struct FPropVolumeInfo& Info);
	static const class FName GetCodeName(const struct FPropVolumeInfo& Info);
	static ELInteractionEvokeType GetInteractionEvokeType(const struct FPropVolumeInfo& Info);
	static const class FName GetLocationNameDisplay(const struct FPropVolumeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoopVisualAssetResource(const struct FPropVolumeInfo& Info);
	static int32 GetNGPDetailIndex(const struct FPropVolumeInfo& Info);
	static int32 GetState(const struct FPropVolumeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropVolumeInfoFuncLibrary">();
	}
	static class UPropVolumeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropVolumeInfoFuncLibrary>();
	}
};
static_assert(alignof(UPropVolumeInfoFuncLibrary) == 0x000008, "Wrong alignment on UPropVolumeInfoFuncLibrary");
static_assert(sizeof(UPropVolumeInfoFuncLibrary) == 0x000028, "Wrong size on UPropVolumeInfoFuncLibrary");

// Class ProjectPContentInfo.PropVolumeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPropVolumeInfoPtrFuncLibrary final : public UObject
{
public:
	static ELAbnomalStateApplyType GetAbnomalStateApplyType(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetAbnomalStateBuildupDamage(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetAbnomalStateBuildupDamageTickTime(const struct FPropVolumeInfoPtr& Ptr);
	static const class FName GetAbnomalStateCodename(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetAbnomalStateDurationTimepassDelayRatioAdd(const struct FPropVolumeInfoPtr& Ptr);
	static const TArray<EFactionType> GetAbnomalStateTargetFilter(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetAbnormalStatePenaltyBase(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetBuildUpRecoverIncBase(const struct FPropVolumeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FPropVolumeInfoPtr& Ptr);
	static ELInteractionEvokeType GetInteractionEvokeType(const struct FPropVolumeInfoPtr& Ptr);
	static const class FName GetLocationNameDisplay(const struct FPropVolumeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoopVisualAssetResource(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetNGPDetailIndex(const struct FPropVolumeInfoPtr& Ptr);
	static int32 GetState(const struct FPropVolumeInfoPtr& Ptr);
	static bool IsValid(const struct FPropVolumeInfoPtr& Ptr);
	static void IsValidBranch(const struct FPropVolumeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropVolumeInfoPtrFuncLibrary">();
	}
	static class UPropVolumeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropVolumeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPropVolumeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPropVolumeInfoPtrFuncLibrary");
static_assert(sizeof(UPropVolumeInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPropVolumeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PropVolumeInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPropVolumeInfoAsset final : public UContentInfoAsset
{
public:
	struct FPropVolumeInfoDB                      ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPropVolumeInfo> GetPropVolumeInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropVolumeInfoAsset">();
	}
	static class UPropVolumeInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropVolumeInfoAsset>();
	}
};
static_assert(alignof(UPropVolumeInfoAsset) == 0x000010, "Wrong alignment on UPropVolumeInfoAsset");
static_assert(sizeof(UPropVolumeInfoAsset) == 0x0000D0, "Wrong size on UPropVolumeInfoAsset");
static_assert(offsetof(UPropVolumeInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPropVolumeInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.PulsePointMaxInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPulsePointMaxInfoFuncLibrary final : public UObject
{
public:
	static int32 GetPulseRechargePointMax(const struct FPulsePointMaxInfo& Info);
	static int32 GetRechargeCount(const struct FPulsePointMaxInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PulsePointMaxInfoFuncLibrary">();
	}
	static class UPulsePointMaxInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPulsePointMaxInfoFuncLibrary>();
	}
};
static_assert(alignof(UPulsePointMaxInfoFuncLibrary) == 0x000008, "Wrong alignment on UPulsePointMaxInfoFuncLibrary");
static_assert(sizeof(UPulsePointMaxInfoFuncLibrary) == 0x000028, "Wrong size on UPulsePointMaxInfoFuncLibrary");

// Class ProjectPContentInfo.PulsePointMaxInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UPulsePointMaxInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetPulseRechargePointMax(const struct FPulsePointMaxInfoPtr& Ptr);
	static int32 GetRechargeCount(const struct FPulsePointMaxInfoPtr& Ptr);
	static bool IsValid(const struct FPulsePointMaxInfoPtr& Ptr);
	static void IsValidBranch(const struct FPulsePointMaxInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PulsePointMaxInfoPtrFuncLibrary">();
	}
	static class UPulsePointMaxInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPulsePointMaxInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UPulsePointMaxInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UPulsePointMaxInfoPtrFuncLibrary");
static_assert(sizeof(UPulsePointMaxInfoPtrFuncLibrary) == 0x000028, "Wrong size on UPulsePointMaxInfoPtrFuncLibrary");

// Class ProjectPContentInfo.PulsePointMaxInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UPulsePointMaxInfoAsset final : public UContentInfoAsset
{
public:
	struct FPulsePointMaxInfoDB                   ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FPulsePointMaxInfo> GetPulsePointMaxInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PulsePointMaxInfoAsset">();
	}
	static class UPulsePointMaxInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPulsePointMaxInfoAsset>();
	}
};
static_assert(alignof(UPulsePointMaxInfoAsset) == 0x000010, "Wrong alignment on UPulsePointMaxInfoAsset");
static_assert(sizeof(UPulsePointMaxInfoAsset) == 0x0000D0, "Wrong size on UPulsePointMaxInfoAsset");
static_assert(offsetof(UPulsePointMaxInfoAsset, ContentInfoDB) == 0x000078, "Member 'UPulsePointMaxInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.QuartzEffectInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuartzEffectInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FQuartzEffectInfo& Info);
	static int32 GetCoreLevel(const struct FQuartzEffectInfo& Info);
	static int32 GetEffectIndex(const struct FQuartzEffectInfo& Info);
	static ELQuartzEffectType GetEffectType(const struct FQuartzEffectInfo& Info);
	static int32 GetNumberOverlappingEffect(const struct FQuartzEffectInfo& Info);
	static const class FName GetSpecialBuffCodeName(const struct FQuartzEffectInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuartzEffectInfoFuncLibrary">();
	}
	static class UQuartzEffectInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuartzEffectInfoFuncLibrary>();
	}
};
static_assert(alignof(UQuartzEffectInfoFuncLibrary) == 0x000008, "Wrong alignment on UQuartzEffectInfoFuncLibrary");
static_assert(sizeof(UQuartzEffectInfoFuncLibrary) == 0x000028, "Wrong size on UQuartzEffectInfoFuncLibrary");

// Class ProjectPContentInfo.QuartzEffectInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuartzEffectInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FQuartzEffectInfoPtr& Ptr);
	static int32 GetCoreLevel(const struct FQuartzEffectInfoPtr& Ptr);
	static int32 GetEffectIndex(const struct FQuartzEffectInfoPtr& Ptr);
	static ELQuartzEffectType GetEffectType(const struct FQuartzEffectInfoPtr& Ptr);
	static int32 GetNumberOverlappingEffect(const struct FQuartzEffectInfoPtr& Ptr);
	static const class FName GetSpecialBuffCodeName(const struct FQuartzEffectInfoPtr& Ptr);
	static bool IsValid(const struct FQuartzEffectInfoPtr& Ptr);
	static void IsValidBranch(const struct FQuartzEffectInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuartzEffectInfoPtrFuncLibrary">();
	}
	static class UQuartzEffectInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuartzEffectInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UQuartzEffectInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UQuartzEffectInfoPtrFuncLibrary");
static_assert(sizeof(UQuartzEffectInfoPtrFuncLibrary) == 0x000028, "Wrong size on UQuartzEffectInfoPtrFuncLibrary");

// Class ProjectPContentInfo.QuartzEffectInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UQuartzEffectInfoAsset final : public UContentInfoAsset
{
public:
	struct FQuartzEffectInfoDB                    ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FQuartzEffectInfoPtr FindQuartzEffectInfoByNameBP(class FName CodeName);
	static const TArray<struct FQuartzEffectInfo> GetQuartzEffectInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuartzEffectInfoAsset">();
	}
	static class UQuartzEffectInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuartzEffectInfoAsset>();
	}
};
static_assert(alignof(UQuartzEffectInfoAsset) == 0x000010, "Wrong alignment on UQuartzEffectInfoAsset");
static_assert(sizeof(UQuartzEffectInfoAsset) == 0x000120, "Wrong size on UQuartzEffectInfoAsset");
static_assert(offsetof(UQuartzEffectInfoAsset, ContentInfoDB) == 0x000078, "Member 'UQuartzEffectInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.QuartzPocketInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuartzPocketInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FQuartzPocketInfo& Info);
	static const class FName GetDescription(const struct FQuartzPocketInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImage(const struct FQuartzPocketInfo& Info);
	static int32 GetLevel(const struct FQuartzPocketInfo& Info);
	static int32 GetNumberOverlappingSynergy(const struct FQuartzPocketInfo& Info);
	static int32 GetPocketIndex(const struct FQuartzPocketInfo& Info);
	static int32 GetSlotCount(const struct FQuartzPocketInfo& Info);
	static int32 GetSynergyActivateSlotCount(const struct FQuartzPocketInfo& Info);
	static const class FName GetSynergySpecialBuffCodeName(const struct FQuartzPocketInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuartzPocketInfoFuncLibrary">();
	}
	static class UQuartzPocketInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuartzPocketInfoFuncLibrary>();
	}
};
static_assert(alignof(UQuartzPocketInfoFuncLibrary) == 0x000008, "Wrong alignment on UQuartzPocketInfoFuncLibrary");
static_assert(sizeof(UQuartzPocketInfoFuncLibrary) == 0x000028, "Wrong size on UQuartzPocketInfoFuncLibrary");

// Class ProjectPContentInfo.QuartzPocketInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuartzPocketInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FQuartzPocketInfoPtr& Ptr);
	static const class FName GetDescription(const struct FQuartzPocketInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImage(const struct FQuartzPocketInfoPtr& Ptr);
	static int32 GetLevel(const struct FQuartzPocketInfoPtr& Ptr);
	static int32 GetNumberOverlappingSynergy(const struct FQuartzPocketInfoPtr& Ptr);
	static int32 GetPocketIndex(const struct FQuartzPocketInfoPtr& Ptr);
	static int32 GetSlotCount(const struct FQuartzPocketInfoPtr& Ptr);
	static int32 GetSynergyActivateSlotCount(const struct FQuartzPocketInfoPtr& Ptr);
	static const class FName GetSynergySpecialBuffCodeName(const struct FQuartzPocketInfoPtr& Ptr);
	static bool IsValid(const struct FQuartzPocketInfoPtr& Ptr);
	static void IsValidBranch(const struct FQuartzPocketInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuartzPocketInfoPtrFuncLibrary">();
	}
	static class UQuartzPocketInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuartzPocketInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UQuartzPocketInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UQuartzPocketInfoPtrFuncLibrary");
static_assert(sizeof(UQuartzPocketInfoPtrFuncLibrary) == 0x000028, "Wrong size on UQuartzPocketInfoPtrFuncLibrary");

// Class ProjectPContentInfo.QuartzPocketInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UQuartzPocketInfoAsset final : public UContentInfoAsset
{
public:
	struct FQuartzPocketInfoDB                    ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FQuartzPocketInfoPtr FindQuartzPocketInfoByNameBP(class FName CodeName);
	static const TArray<struct FQuartzPocketInfo> GetQuartzPocketInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuartzPocketInfoAsset">();
	}
	static class UQuartzPocketInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuartzPocketInfoAsset>();
	}
};
static_assert(alignof(UQuartzPocketInfoAsset) == 0x000010, "Wrong alignment on UQuartzPocketInfoAsset");
static_assert(sizeof(UQuartzPocketInfoAsset) == 0x000120, "Wrong size on UQuartzPocketInfoAsset");
static_assert(offsetof(UQuartzPocketInfoAsset, ContentInfoDB) == 0x000078, "Member 'UQuartzPocketInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.QuestRewardItemInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuestRewardItemInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetItemCodeName(const struct FQuestRewardItemInfo& Info);
	static int32 GetItemCount(const struct FQuestRewardItemInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestRewardItemInfoFuncLibrary">();
	}
	static class UQuestRewardItemInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestRewardItemInfoFuncLibrary>();
	}
};
static_assert(alignof(UQuestRewardItemInfoFuncLibrary) == 0x000008, "Wrong alignment on UQuestRewardItemInfoFuncLibrary");
static_assert(sizeof(UQuestRewardItemInfoFuncLibrary) == 0x000028, "Wrong size on UQuestRewardItemInfoFuncLibrary");

// Class ProjectPContentInfo.QuestRewardItemInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuestRewardItemInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetItemCodeName(const struct FQuestRewardItemInfoPtr& Ptr);
	static int32 GetItemCount(const struct FQuestRewardItemInfoPtr& Ptr);
	static bool IsValid(const struct FQuestRewardItemInfoPtr& Ptr);
	static void IsValidBranch(const struct FQuestRewardItemInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestRewardItemInfoPtrFuncLibrary">();
	}
	static class UQuestRewardItemInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestRewardItemInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UQuestRewardItemInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UQuestRewardItemInfoPtrFuncLibrary");
static_assert(sizeof(UQuestRewardItemInfoPtrFuncLibrary) == 0x000028, "Wrong size on UQuestRewardItemInfoPtrFuncLibrary");

// Class ProjectPContentInfo.QuestDescInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuestDescInfoFuncLibrary final : public UObject
{
public:
	static const TArray<struct FGeneralConditionInfo> GetAddQuestConditionArray(const struct FQuestDescInfo& Info);
	static bool GetAddQuestConditionOr(const struct FQuestDescInfo& Info);
	static const TArray<struct FGeneralCallBackEventInfo> GetAddQuestTypeListArray(const struct FQuestDescInfo& Info);
	static const class FName GetCodeName(const struct FQuestDescInfo& Info);
	static int32 GetDialogSelectNum(const struct FQuestDescInfo& Info);
	static int32 GetQuestVariable(const struct FQuestDescInfo& Info);
	static const TArray<class FName> GetTalker(const struct FQuestDescInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestDescInfoFuncLibrary">();
	}
	static class UQuestDescInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestDescInfoFuncLibrary>();
	}
};
static_assert(alignof(UQuestDescInfoFuncLibrary) == 0x000008, "Wrong alignment on UQuestDescInfoFuncLibrary");
static_assert(sizeof(UQuestDescInfoFuncLibrary) == 0x000028, "Wrong size on UQuestDescInfoFuncLibrary");

// Class ProjectPContentInfo.QuestDescInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuestDescInfoPtrFuncLibrary final : public UObject
{
public:
	static const TArray<struct FGeneralConditionInfo> GetAddQuestConditionArray(const struct FQuestDescInfoPtr& Ptr);
	static bool GetAddQuestConditionOr(const struct FQuestDescInfoPtr& Ptr);
	static const TArray<struct FGeneralCallBackEventInfo> GetAddQuestTypeListArray(const struct FQuestDescInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FQuestDescInfoPtr& Ptr);
	static int32 GetDialogSelectNum(const struct FQuestDescInfoPtr& Ptr);
	static int32 GetQuestVariable(const struct FQuestDescInfoPtr& Ptr);
	static const TArray<class FName> GetTalker(const struct FQuestDescInfoPtr& Ptr);
	static bool IsValid(const struct FQuestDescInfoPtr& Ptr);
	static void IsValidBranch(const struct FQuestDescInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestDescInfoPtrFuncLibrary">();
	}
	static class UQuestDescInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestDescInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UQuestDescInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UQuestDescInfoPtrFuncLibrary");
static_assert(sizeof(UQuestDescInfoPtrFuncLibrary) == 0x000028, "Wrong size on UQuestDescInfoPtrFuncLibrary");

// Class ProjectPContentInfo.QuestStepInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuestStepInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FQuestStepInfo& Info);
	static const TArray<struct FGeneralCommandInfo> GetDontcareExecListArray(const struct FQuestStepInfo& Info);
	static class FString GetFalseNextstepData(const struct FQuestStepInfo& Info);
	static ELNextStepType GetFalseNextstepType(const struct FQuestStepInfo& Info);
	static const class FName GetFalseResultGemini(const struct FQuestStepInfo& Info);
	static const TArray<struct FGeneralCommandInfo> GetFalseResultListArray(const struct FQuestStepInfo& Info);
	static int32 GetFalseRewardHumanPoint(const struct FQuestStepInfo& Info);
	static const TArray<struct FQuestRewardItemInfo> GetFalseRewardItemArray(const struct FQuestStepInfo& Info);
	static const TArray<struct FGeneralConditionInfo> GetQuestFailCheckListArray(const struct FQuestStepInfo& Info);
	static const TArray<struct FGeneralCommandInfo> GetQuestFailExecListArray(const struct FQuestStepInfo& Info);
	static bool GetQuestFailOr(const struct FQuestStepInfo& Info);
	static int32 GetStep(const struct FQuestStepInfo& Info);
	static const TArray<class FName> GetTalkerDialog(const struct FQuestStepInfo& Info);
	static const TArray<struct FGeneralCallBackEventInfo> GetTaskListArray(const struct FQuestStepInfo& Info);
	static ELTaskResultCheckType GetTaskResultCheck(const struct FQuestStepInfo& Info);
	static class FString GetTaskResultCheckData(const struct FQuestStepInfo& Info);
	static const class FName GetTeleportlistIcon(const struct FQuestStepInfo& Info);
	static const TArray<class FName> GetTeleportlistOn(const struct FQuestStepInfo& Info);
	static class FString GetTrueNextstepData(const struct FQuestStepInfo& Info);
	static ELNextStepType GetTrueNextstepType(const struct FQuestStepInfo& Info);
	static const class FName GetTrueResultGemini(const struct FQuestStepInfo& Info);
	static const TArray<struct FGeneralCommandInfo> GetTrueResultListArray(const struct FQuestStepInfo& Info);
	static int32 GetTrueRewardHumanPoint(const struct FQuestStepInfo& Info);
	static const TArray<struct FQuestRewardItemInfo> GetTrueRewardItemArray(const struct FQuestStepInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestStepInfoFuncLibrary">();
	}
	static class UQuestStepInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestStepInfoFuncLibrary>();
	}
};
static_assert(alignof(UQuestStepInfoFuncLibrary) == 0x000008, "Wrong alignment on UQuestStepInfoFuncLibrary");
static_assert(sizeof(UQuestStepInfoFuncLibrary) == 0x000028, "Wrong size on UQuestStepInfoFuncLibrary");

// Class ProjectPContentInfo.QuestStepInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UQuestStepInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FGeneralCommandInfo> GetDontcareExecListArray(const struct FQuestStepInfoPtr& Ptr);
	static class FString GetFalseNextstepData(const struct FQuestStepInfoPtr& Ptr);
	static ELNextStepType GetFalseNextstepType(const struct FQuestStepInfoPtr& Ptr);
	static const class FName GetFalseResultGemini(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FGeneralCommandInfo> GetFalseResultListArray(const struct FQuestStepInfoPtr& Ptr);
	static int32 GetFalseRewardHumanPoint(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FQuestRewardItemInfo> GetFalseRewardItemArray(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FGeneralConditionInfo> GetQuestFailCheckListArray(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FGeneralCommandInfo> GetQuestFailExecListArray(const struct FQuestStepInfoPtr& Ptr);
	static bool GetQuestFailOr(const struct FQuestStepInfoPtr& Ptr);
	static int32 GetStep(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<class FName> GetTalkerDialog(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FGeneralCallBackEventInfo> GetTaskListArray(const struct FQuestStepInfoPtr& Ptr);
	static ELTaskResultCheckType GetTaskResultCheck(const struct FQuestStepInfoPtr& Ptr);
	static class FString GetTaskResultCheckData(const struct FQuestStepInfoPtr& Ptr);
	static const class FName GetTeleportlistIcon(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<class FName> GetTeleportlistOn(const struct FQuestStepInfoPtr& Ptr);
	static class FString GetTrueNextstepData(const struct FQuestStepInfoPtr& Ptr);
	static ELNextStepType GetTrueNextstepType(const struct FQuestStepInfoPtr& Ptr);
	static const class FName GetTrueResultGemini(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FGeneralCommandInfo> GetTrueResultListArray(const struct FQuestStepInfoPtr& Ptr);
	static int32 GetTrueRewardHumanPoint(const struct FQuestStepInfoPtr& Ptr);
	static const TArray<struct FQuestRewardItemInfo> GetTrueRewardItemArray(const struct FQuestStepInfoPtr& Ptr);
	static bool IsValid(const struct FQuestStepInfoPtr& Ptr);
	static void IsValidBranch(const struct FQuestStepInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestStepInfoPtrFuncLibrary">();
	}
	static class UQuestStepInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestStepInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UQuestStepInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UQuestStepInfoPtrFuncLibrary");
static_assert(sizeof(UQuestStepInfoPtrFuncLibrary) == 0x000028, "Wrong size on UQuestStepInfoPtrFuncLibrary");

// Class ProjectPContentInfo.QuestInfoAsset
// 0x00B8 (0x0130 - 0x0078)
class alignas(0x10) UQuestInfoAsset final : public UContentInfoAsset
{
public:
	struct FQuestInfoDB                           ContentInfoDB;                                     // 0x0078(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FQuestDescInfoPtr FindQuestDescInfoByNameBP(class FName CodeName);
	static const TArray<struct FQuestDescInfo> GetQuestDescInfoArrayBP();
	static const TArray<struct FQuestStepInfo> GetQuestStepInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestInfoAsset">();
	}
	static class UQuestInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestInfoAsset>();
	}
};
static_assert(alignof(UQuestInfoAsset) == 0x000010, "Wrong alignment on UQuestInfoAsset");
static_assert(sizeof(UQuestInfoAsset) == 0x000130, "Wrong size on UQuestInfoAsset");
static_assert(offsetof(UQuestInfoAsset, ContentInfoDB) == 0x000078, "Member 'UQuestInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.RecollectionInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class URecollectionInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAssetTableCodeName(const struct FRecollectionInfo& Info);
	static ELRecollectionCategory GetCategory(const struct FRecollectionInfo& Info);
	static const class FName GetCodeName(const struct FRecollectionInfo& Info);
	static int32 GetIndex(const struct FRecollectionInfo& Info);
	static class FString GetLocalTextName(const struct FRecollectionInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FRecollectionInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FRecollectionInfo& Info);
	static class FString GetLocalTextTooltip1(const struct FRecollectionInfo& Info);
	static const class FName GetLocalTextTooltip1Cn(const struct FRecollectionInfo& Info);
	static class FText GetLocalTextTooltip1Localize(const struct FRecollectionInfo& Info);
	static class FString GetLocalTextTooltip2(const struct FRecollectionInfo& Info);
	static const class FName GetLocalTextTooltip2Cn(const struct FRecollectionInfo& Info);
	static class FText GetLocalTextTooltip2Localize(const struct FRecollectionInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionInfoFuncLibrary">();
	}
	static class URecollectionInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionInfoFuncLibrary>();
	}
};
static_assert(alignof(URecollectionInfoFuncLibrary) == 0x000008, "Wrong alignment on URecollectionInfoFuncLibrary");
static_assert(sizeof(URecollectionInfoFuncLibrary) == 0x000028, "Wrong size on URecollectionInfoFuncLibrary");

// Class ProjectPContentInfo.RecollectionInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class URecollectionInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAssetTableCodeName(const struct FRecollectionInfoPtr& Ptr);
	static ELRecollectionCategory GetCategory(const struct FRecollectionInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FRecollectionInfoPtr& Ptr);
	static int32 GetIndex(const struct FRecollectionInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FRecollectionInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FRecollectionInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FRecollectionInfoPtr& Ptr);
	static class FString GetLocalTextTooltip1(const struct FRecollectionInfoPtr& Ptr);
	static const class FName GetLocalTextTooltip1Cn(const struct FRecollectionInfoPtr& Ptr);
	static class FText GetLocalTextTooltip1Localize(const struct FRecollectionInfoPtr& Ptr);
	static class FString GetLocalTextTooltip2(const struct FRecollectionInfoPtr& Ptr);
	static const class FName GetLocalTextTooltip2Cn(const struct FRecollectionInfoPtr& Ptr);
	static class FText GetLocalTextTooltip2Localize(const struct FRecollectionInfoPtr& Ptr);
	static bool IsValid(const struct FRecollectionInfoPtr& Ptr);
	static void IsValidBranch(const struct FRecollectionInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionInfoPtrFuncLibrary">();
	}
	static class URecollectionInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(URecollectionInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on URecollectionInfoPtrFuncLibrary");
static_assert(sizeof(URecollectionInfoPtrFuncLibrary) == 0x000028, "Wrong size on URecollectionInfoPtrFuncLibrary");

// Class ProjectPContentInfo.RecollectionInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) URecollectionInfoAsset final : public UContentInfoAsset
{
public:
	struct FRecollectionInfoDB                    ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FRecollectionInfoPtr FindRecollectionInfoByNameBP(class FName CodeName);
	static const TArray<struct FRecollectionInfo> GetRecollectionInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecollectionInfoAsset">();
	}
	static class URecollectionInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecollectionInfoAsset>();
	}
};
static_assert(alignof(URecollectionInfoAsset) == 0x000010, "Wrong alignment on URecollectionInfoAsset");
static_assert(sizeof(URecollectionInfoAsset) == 0x000120, "Wrong size on URecollectionInfoAsset");
static_assert(offsetof(URecollectionInfoAsset, ContentInfoDB) == 0x000078, "Member 'URecollectionInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ResetNeedItemInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UResetNeedItemInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetNeedItemCodeName(const struct FResetNeedItemInfo& Info);
	static int32 GetNum(const struct FResetNeedItemInfo& Info);
	static int32 GetResetCount(const struct FResetNeedItemInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetNeedItemInfoFuncLibrary">();
	}
	static class UResetNeedItemInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetNeedItemInfoFuncLibrary>();
	}
};
static_assert(alignof(UResetNeedItemInfoFuncLibrary) == 0x000008, "Wrong alignment on UResetNeedItemInfoFuncLibrary");
static_assert(sizeof(UResetNeedItemInfoFuncLibrary) == 0x000028, "Wrong size on UResetNeedItemInfoFuncLibrary");

// Class ProjectPContentInfo.ResetNeedItemInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UResetNeedItemInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetNeedItemCodeName(const struct FResetNeedItemInfoPtr& Ptr);
	static int32 GetNum(const struct FResetNeedItemInfoPtr& Ptr);
	static int32 GetResetCount(const struct FResetNeedItemInfoPtr& Ptr);
	static bool IsValid(const struct FResetNeedItemInfoPtr& Ptr);
	static void IsValidBranch(const struct FResetNeedItemInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetNeedItemInfoPtrFuncLibrary">();
	}
	static class UResetNeedItemInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetNeedItemInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UResetNeedItemInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UResetNeedItemInfoPtrFuncLibrary");
static_assert(sizeof(UResetNeedItemInfoPtrFuncLibrary) == 0x000028, "Wrong size on UResetNeedItemInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ResetSystemSettingInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UResetSystemSettingInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FResetSystemSettingInfo& Info);
	static const TArray<struct FResetNeedItemInfo> GetNeedItemsArray(const struct FResetSystemSettingInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetSystemSettingInfoFuncLibrary">();
	}
	static class UResetSystemSettingInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetSystemSettingInfoFuncLibrary>();
	}
};
static_assert(alignof(UResetSystemSettingInfoFuncLibrary) == 0x000008, "Wrong alignment on UResetSystemSettingInfoFuncLibrary");
static_assert(sizeof(UResetSystemSettingInfoFuncLibrary) == 0x000028, "Wrong size on UResetSystemSettingInfoFuncLibrary");

// Class ProjectPContentInfo.ResetSystemSettingInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UResetSystemSettingInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FResetSystemSettingInfoPtr& Ptr);
	static const TArray<struct FResetNeedItemInfo> GetNeedItemsArray(const struct FResetSystemSettingInfoPtr& Ptr);
	static bool IsValid(const struct FResetSystemSettingInfoPtr& Ptr);
	static void IsValidBranch(const struct FResetSystemSettingInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetSystemSettingInfoPtrFuncLibrary">();
	}
	static class UResetSystemSettingInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetSystemSettingInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UResetSystemSettingInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UResetSystemSettingInfoPtrFuncLibrary");
static_assert(sizeof(UResetSystemSettingInfoPtrFuncLibrary) == 0x000028, "Wrong size on UResetSystemSettingInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ResetSystemSettingInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UResetSystemSettingInfoAsset final : public UContentInfoAsset
{
public:
	struct FResetSystemSettingInfoDB              ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FResetSystemSettingInfoPtr FindResetSystemSettingInfoByNameBP(class FName CodeName);
	static const TArray<struct FResetSystemSettingInfo> GetResetSystemSettingInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResetSystemSettingInfoAsset">();
	}
	static class UResetSystemSettingInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResetSystemSettingInfoAsset>();
	}
};
static_assert(alignof(UResetSystemSettingInfoAsset) == 0x000010, "Wrong alignment on UResetSystemSettingInfoAsset");
static_assert(sizeof(UResetSystemSettingInfoAsset) == 0x000120, "Wrong size on UResetSystemSettingInfoAsset");
static_assert(offsetof(UResetSystemSettingInfoAsset, ContentInfoDB) == 0x000078, "Member 'UResetSystemSettingInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ShopInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UShopInfoFuncLibrary final : public UObject
{
public:
	static int32 GetBuyNumMax(const struct FShopInfo& Info);
	static const class FName GetCondition(const struct FShopInfo& Info);
	static const class FName GetGoodsCodeName(const struct FShopInfo& Info);
	static const class FName GetItemCodeName(const struct FShopInfo& Info);
	static const class FName GetItemCodeName2(const struct FShopInfo& Info);
	static int32 GetSellingPrice(const struct FShopInfo& Info);
	static const class FName GetShopCodeName(const struct FShopInfo& Info);
	static int32 GetSort(const struct FShopInfo& Info);
	static int32 GetStockLimit(const struct FShopInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopInfoFuncLibrary">();
	}
	static class UShopInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopInfoFuncLibrary>();
	}
};
static_assert(alignof(UShopInfoFuncLibrary) == 0x000008, "Wrong alignment on UShopInfoFuncLibrary");
static_assert(sizeof(UShopInfoFuncLibrary) == 0x000028, "Wrong size on UShopInfoFuncLibrary");

// Class ProjectPContentInfo.ShopInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UShopInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetBuyNumMax(const struct FShopInfoPtr& Ptr);
	static const class FName GetCondition(const struct FShopInfoPtr& Ptr);
	static const class FName GetGoodsCodeName(const struct FShopInfoPtr& Ptr);
	static const class FName GetItemCodeName(const struct FShopInfoPtr& Ptr);
	static const class FName GetItemCodeName2(const struct FShopInfoPtr& Ptr);
	static int32 GetSellingPrice(const struct FShopInfoPtr& Ptr);
	static const class FName GetShopCodeName(const struct FShopInfoPtr& Ptr);
	static int32 GetSort(const struct FShopInfoPtr& Ptr);
	static int32 GetStockLimit(const struct FShopInfoPtr& Ptr);
	static bool IsValid(const struct FShopInfoPtr& Ptr);
	static void IsValidBranch(const struct FShopInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopInfoPtrFuncLibrary">();
	}
	static class UShopInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UShopInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UShopInfoPtrFuncLibrary");
static_assert(sizeof(UShopInfoPtrFuncLibrary) == 0x000028, "Wrong size on UShopInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ShopInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UShopInfoAsset final : public UContentInfoAsset
{
public:
	struct FShopInfoDB                            ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FShopInfoPtr FindShopInfoByNameBP(class FName CodeName);
	static const TArray<struct FShopInfo> GetShopInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopInfoAsset">();
	}
	static class UShopInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopInfoAsset>();
	}
};
static_assert(alignof(UShopInfoAsset) == 0x000010, "Wrong alignment on UShopInfoAsset");
static_assert(sizeof(UShopInfoAsset) == 0x000120, "Wrong size on UShopInfoAsset");
static_assert(offsetof(UShopInfoAsset, ContentInfoDB) == 0x000078, "Member 'UShopInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.ShopSpecialInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UShopSpecialInfoFuncLibrary final : public UObject
{
public:
	static int32 GetBuyNumMax(const struct FShopSpecialInfo& Info);
	static const class FName GetCondition(const struct FShopSpecialInfo& Info);
	static const class FName GetGoodsCodeName(const struct FShopSpecialInfo& Info);
	static const class FName GetItemCodeName(const struct FShopSpecialInfo& Info);
	static const class FName GetItemCodeName2(const struct FShopSpecialInfo& Info);
	static int32 GetNeedErgo(const struct FShopSpecialInfo& Info);
	static const class FName GetNeedItem1(const struct FShopSpecialInfo& Info);
	static const class FName GetNeedItem2(const struct FShopSpecialInfo& Info);
	static const class FName GetNeedItem3(const struct FShopSpecialInfo& Info);
	static const class FName GetNeedItem4(const struct FShopSpecialInfo& Info);
	static int32 GetNeedItemNum1(const struct FShopSpecialInfo& Info);
	static int32 GetNeedItemNum2(const struct FShopSpecialInfo& Info);
	static int32 GetNeedItemNum3(const struct FShopSpecialInfo& Info);
	static int32 GetNeedItemNum4(const struct FShopSpecialInfo& Info);
	static const class FName GetShopCodeName(const struct FShopSpecialInfo& Info);
	static int32 GetSort(const struct FShopSpecialInfo& Info);
	static int32 GetStockLimit(const struct FShopSpecialInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopSpecialInfoFuncLibrary">();
	}
	static class UShopSpecialInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopSpecialInfoFuncLibrary>();
	}
};
static_assert(alignof(UShopSpecialInfoFuncLibrary) == 0x000008, "Wrong alignment on UShopSpecialInfoFuncLibrary");
static_assert(sizeof(UShopSpecialInfoFuncLibrary) == 0x000028, "Wrong size on UShopSpecialInfoFuncLibrary");

// Class ProjectPContentInfo.ShopSpecialInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UShopSpecialInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetBuyNumMax(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetCondition(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetGoodsCodeName(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetItemCodeName(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetItemCodeName2(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetNeedErgo(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetNeedItem1(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetNeedItem2(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetNeedItem3(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetNeedItem4(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetNeedItemNum1(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetNeedItemNum2(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetNeedItemNum3(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetNeedItemNum4(const struct FShopSpecialInfoPtr& Ptr);
	static const class FName GetShopCodeName(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetSort(const struct FShopSpecialInfoPtr& Ptr);
	static int32 GetStockLimit(const struct FShopSpecialInfoPtr& Ptr);
	static bool IsValid(const struct FShopSpecialInfoPtr& Ptr);
	static void IsValidBranch(const struct FShopSpecialInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopSpecialInfoPtrFuncLibrary">();
	}
	static class UShopSpecialInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopSpecialInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UShopSpecialInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UShopSpecialInfoPtrFuncLibrary");
static_assert(sizeof(UShopSpecialInfoPtrFuncLibrary) == 0x000028, "Wrong size on UShopSpecialInfoPtrFuncLibrary");

// Class ProjectPContentInfo.ShopSpecialInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UShopSpecialInfoAsset final : public UContentInfoAsset
{
public:
	struct FShopSpecialInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FShopSpecialInfoPtr FindShopSpecialInfoByNameBP(class FName CodeName);
	static const TArray<struct FShopSpecialInfo> GetShopSpecialInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopSpecialInfoAsset">();
	}
	static class UShopSpecialInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopSpecialInfoAsset>();
	}
};
static_assert(alignof(UShopSpecialInfoAsset) == 0x000010, "Wrong alignment on UShopSpecialInfoAsset");
static_assert(sizeof(UShopSpecialInfoAsset) == 0x000120, "Wrong size on UShopSpecialInfoAsset");
static_assert(offsetof(UShopSpecialInfoAsset, ContentInfoDB) == 0x000078, "Member 'UShopSpecialInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SkillHitInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillHitInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttackRatio(const struct FSkillHitInfo& Info);
	static const class FName GetAbnormalStateCodeName(const struct FSkillHitInfo& Info);
	static int32 GetAbnormalstateMomentConditionGroup(const struct FSkillHitInfo& Info);
	static bool GetAllow360Guard(const struct FSkillHitInfo& Info);
	static int32 GetAttackGainFrenzyPointRatio(const struct FSkillHitInfo& Info);
	static ELPartsAttachPointType GetBodyWeaponAttachPointType(const struct FSkillHitInfo& Info);
	static int32 GetBoundDuration(const struct FSkillHitInfo& Info);
	static int32 GetBoundHeight(const struct FSkillHitInfo& Info);
	static const class FName GetCodeName(const struct FSkillHitInfo& Info);
	static int32 GetConsumeSlaveMagazine(const struct FSkillHitInfo& Info);
	static int32 GetConsumeStaminaPoint(const struct FSkillHitInfo& Info);
	static int32 GetConsumeStaminaRatio(const struct FSkillHitInfo& Info);
	static const class FName GetCounterChangeSkillHitCodeName(const struct FSkillHitInfo& Info);
	static int32 GetCounterPostHit(const struct FSkillHitInfo& Info);
	static int32 GetCounterPreHit(const struct FSkillHitInfo& Info);
	static int32 GetDecreaseEnemyWeaponDurability(const struct FSkillHitInfo& Info);
	static int32 GetElementDamageRatio(const struct FSkillHitInfo& Info);
	static ELElementDamageType GetElementDamageType(const struct FSkillHitInfo& Info);
	static bool GetEnable2dSfx(const struct FSkillHitInfo& Info);
	static bool GetEnablePerfectGuardGroggyDamage(const struct FSkillHitInfo& Info);
	static bool GetEnableWarningevent(const struct FSkillHitInfo& Info);
	static ELExplosionPowerType GetExlplosiveKillPower(const struct FSkillHitInfo& Info);
	static ELExplosionDirectionType GetExplosiveKillDirection(const struct FSkillHitInfo& Info);
	static int32 GetExplosiveKillProb(const struct FSkillHitInfo& Info);
	static bool GetFuryAttack(const struct FSkillHitInfo& Info);
	static const class FName GetGroggyChangeSkillHitCodeName(const struct FSkillHitInfo& Info);
	static int32 GetGroggyDamageRatio(const struct FSkillHitInfo& Info);
	static bool GetGroggyEnableHitBack(const struct FSkillHitInfo& Info);
	static bool GetGroggyEnableHitFront(const struct FSkillHitInfo& Info);
	static bool GetGroggyEnableHitSide(const struct FSkillHitInfo& Info);
	static bool GetGroggyImmediatelyHitBack(const struct FSkillHitInfo& Info);
	static bool GetGroggyImmediatelyHitFront(const struct FSkillHitInfo& Info);
	static bool GetGroggyImmediatelyHitSide(const struct FSkillHitInfo& Info);
	static int32 GetGroggyTimeRatio(const struct FSkillHitInfo& Info);
	static ELGuardAttackType GetGuardAttackType(const struct FSkillHitInfo& Info);
	static bool GetGuardBreakAttack(const struct FSkillHitInfo& Info);
	static int32 GetGuardHitDuration(const struct FSkillHitInfo& Info);
	static int32 GetGuardKnockbackDistance(const struct FSkillHitInfo& Info);
	static int32 GetGuardKnockbackDuration(const struct FSkillHitInfo& Info);
	static int32 GetGuardPenetrationRatio(const struct FSkillHitInfo& Info);
	static int32 GetGuardRegainAttackHealRatio(const struct FSkillHitInfo& Info);
	static int32 GetGuardRegainDamageRatio(const struct FSkillHitInfo& Info);
	static int32 GetGuardRegainIncreaseRatio(const struct FSkillHitInfo& Info);
	static int32 GetGuardSharpnessDurabilityRatio(const struct FSkillHitInfo& Info);
	static int32 GetGuardStaminaDamageRatio(const struct FSkillHitInfo& Info);
	static int32 GetHitAnimDuration(const struct FSkillHitInfo& Info);
	static const class FName GetHitCameraShakeCodeName(const struct FSkillHitInfo& Info);
	static ELHitDirectionType GetHitDirectionType(const struct FSkillHitInfo& Info);
	static float GetHitFxAngle(const struct FSkillHitInfo& Info);
	static ELSwingPowerType GetHitFxLevel(const struct FSkillHitInfo& Info);
	static const class FName GetHitGeneratePrjCodeName(const struct FSkillHitInfo& Info);
	static const class FName GetHitIntencityDownSkillHit(const struct FSkillHitInfo& Info);
	static ELPhysicalSurfaceType GetHitMaterial(const struct FSkillHitInfo& Info);
	static ELHitMotionType GetHitMotionType(const struct FSkillHitInfo& Info);
	static bool GetHitRotationReverse(const struct FSkillHitInfo& Info);
	static ELHostileType GetHostileType(const struct FSkillHitInfo& Info);
	static bool GetIgnoreDead(const struct FSkillHitInfo& Info);
	static bool GetIgnoreDodge(const struct FSkillHitInfo& Info);
	static bool GetIgnoreGrabbed(const struct FSkillHitInfo& Info);
	static bool GetIgnoreGuard(const struct FSkillHitInfo& Info);
	static bool GetIgnoreGuardFx(const struct FSkillHitInfo& Info);
	static bool GetIgnoreGuardSfx(const struct FSkillHitInfo& Info);
	static bool GetIgnoreInvincible(const struct FSkillHitInfo& Info);
	static bool GetIgnoreNpc(const struct FSkillHitInfo& Info);
	static bool GetIgnoreParry(const struct FSkillHitInfo& Info);
	static bool GetIgnorePc(const struct FSkillHitInfo& Info);
	static bool GetIgnorePerfectGuard(const struct FSkillHitInfo& Info);
	static bool GetIgnoreRepulseEnv(const struct FSkillHitInfo& Info);
	static bool GetIgnoreRepulseGuard(const struct FSkillHitInfo& Info);
	static bool GetIgnoreRepulseHit(const struct FSkillHitInfo& Info);
	static bool GetIgnoreSuperArmor(const struct FSkillHitInfo& Info);
	static int32 GetImpulseValue(const struct FSkillHitInfo& Info);
	static int32 GetIntensityRatio(const struct FSkillHitInfo& Info);
	static ELKnockBackDirectionType GetKnockbackDirection(const struct FSkillHitInfo& Info);
	static int32 GetKnockbackDistance(const struct FSkillHitInfo& Info);
	static int32 GetKnockbackDuration(const struct FSkillHitInfo& Info);
	static float GetKnockbackScale(const struct FSkillHitInfo& Info);
	static ELSkillMotionType GetMotionType(const struct FSkillHitInfo& Info);
	static int32 GetPerfectGuardDecreaseWeaponDurabilityRate(const struct FSkillHitInfo& Info);
	static int32 GetPhysicalDamageRatio(const struct FSkillHitInfo& Info);
	static ELPhysicalDamageType GetPhysicalDamageType(const struct FSkillHitInfo& Info);
	static int32 GetPulseRechargeRatio(const struct FSkillHitInfo& Info);
	static int32 GetRegainhpDamageRatio(const struct FSkillHitInfo& Info);
	static int32 GetRegainhpMakeRatio(const struct FSkillHitInfo& Info);
	static int32 GetRepulseColRadius(const struct FSkillHitInfo& Info);
	static ELRepulseDirectionType GetRepulseDirection(const struct FSkillHitInfo& Info);
	static int32 GetRepulseDuration(const struct FSkillHitInfo& Info);
	static const class FName GetRepulseEndSocket(const struct FSkillHitInfo& Info);
	static const class FName GetRepulseStartSocket(const struct FSkillHitInfo& Info);
	static int32 GetRigidityRatio(const struct FSkillHitInfo& Info);
	static int32 GetSharpnessReduceValueRatio(const struct FSkillHitInfo& Info);
	static ELSkillHitType GetSkillHitType(const struct FSkillHitInfo& Info);
	static int32 GetSparkColRadius(const struct FSkillHitInfo& Info);
	static const class FName GetSparkEndSocket(const struct FSkillHitInfo& Info);
	static const class FName GetSparkStartSocket(const struct FSkillHitInfo& Info);
	static int32 GetStiffenDurationAttacker(const struct FSkillHitInfo& Info);
	static int32 GetStiffenDurationDefender(const struct FSkillHitInfo& Info);
	static float GetStiffenPlayrateAttacker(const struct FSkillHitInfo& Info);
	static float GetStiffenPlayrateDefender(const struct FSkillHitInfo& Info);
	static bool GetTakeDamageIgnoreWarning(const struct FSkillHitInfo& Info);
	static int32 GetToughDamageRatio(const struct FSkillHitInfo& Info);
	static int32 GetToughRecoveryDelayTimeRatio(const struct FSkillHitInfo& Info);
	static bool GetTraceAttack(const struct FSkillHitInfo& Info);
	static bool GetUseCounter(const struct FSkillHitInfo& Info);
	static bool GetUseHitIntencity(const struct FSkillHitInfo& Info);
	static bool GetUseSmash(const struct FSkillHitInfo& Info);
	static ELWeaponAttachPointType GetWeaponAttachPointType(const struct FSkillHitInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillHitInfoFuncLibrary">();
	}
	static class USkillHitInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillHitInfoFuncLibrary>();
	}
};
static_assert(alignof(USkillHitInfoFuncLibrary) == 0x000008, "Wrong alignment on USkillHitInfoFuncLibrary");
static_assert(sizeof(USkillHitInfoFuncLibrary) == 0x000028, "Wrong size on USkillHitInfoFuncLibrary");

// Class ProjectPContentInfo.SkillHitInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillHitInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbnormalStateBuildUpAttackRatio(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetAbnormalStateCodeName(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetAbnormalstateMomentConditionGroup(const struct FSkillHitInfoPtr& Ptr);
	static bool GetAllow360Guard(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetAttackGainFrenzyPointRatio(const struct FSkillHitInfoPtr& Ptr);
	static ELPartsAttachPointType GetBodyWeaponAttachPointType(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetBoundDuration(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetBoundHeight(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetConsumeSlaveMagazine(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetConsumeStaminaPoint(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetConsumeStaminaRatio(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetCounterChangeSkillHitCodeName(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetCounterPostHit(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetCounterPreHit(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetDecreaseEnemyWeaponDurability(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetElementDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static ELElementDamageType GetElementDamageType(const struct FSkillHitInfoPtr& Ptr);
	static bool GetEnable2dSfx(const struct FSkillHitInfoPtr& Ptr);
	static bool GetEnablePerfectGuardGroggyDamage(const struct FSkillHitInfoPtr& Ptr);
	static bool GetEnableWarningevent(const struct FSkillHitInfoPtr& Ptr);
	static ELExplosionPowerType GetExlplosiveKillPower(const struct FSkillHitInfoPtr& Ptr);
	static ELExplosionDirectionType GetExplosiveKillDirection(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetExplosiveKillProb(const struct FSkillHitInfoPtr& Ptr);
	static bool GetFuryAttack(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetGroggyChangeSkillHitCodeName(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGroggyDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGroggyEnableHitBack(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGroggyEnableHitFront(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGroggyEnableHitSide(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGroggyImmediatelyHitBack(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGroggyImmediatelyHitFront(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGroggyImmediatelyHitSide(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGroggyTimeRatio(const struct FSkillHitInfoPtr& Ptr);
	static ELGuardAttackType GetGuardAttackType(const struct FSkillHitInfoPtr& Ptr);
	static bool GetGuardBreakAttack(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardHitDuration(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardKnockbackDistance(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardKnockbackDuration(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardPenetrationRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardRegainAttackHealRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardRegainDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardRegainIncreaseRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardSharpnessDurabilityRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetGuardStaminaDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetHitAnimDuration(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetHitCameraShakeCodeName(const struct FSkillHitInfoPtr& Ptr);
	static ELHitDirectionType GetHitDirectionType(const struct FSkillHitInfoPtr& Ptr);
	static float GetHitFxAngle(const struct FSkillHitInfoPtr& Ptr);
	static ELSwingPowerType GetHitFxLevel(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetHitGeneratePrjCodeName(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetHitIntencityDownSkillHit(const struct FSkillHitInfoPtr& Ptr);
	static ELPhysicalSurfaceType GetHitMaterial(const struct FSkillHitInfoPtr& Ptr);
	static ELHitMotionType GetHitMotionType(const struct FSkillHitInfoPtr& Ptr);
	static bool GetHitRotationReverse(const struct FSkillHitInfoPtr& Ptr);
	static ELHostileType GetHostileType(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreDead(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreDodge(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreGrabbed(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreGuard(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreGuardFx(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreGuardSfx(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreInvincible(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreNpc(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreParry(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnorePc(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnorePerfectGuard(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreRepulseEnv(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreRepulseGuard(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreRepulseHit(const struct FSkillHitInfoPtr& Ptr);
	static bool GetIgnoreSuperArmor(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetImpulseValue(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetIntensityRatio(const struct FSkillHitInfoPtr& Ptr);
	static ELKnockBackDirectionType GetKnockbackDirection(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetKnockbackDistance(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetKnockbackDuration(const struct FSkillHitInfoPtr& Ptr);
	static float GetKnockbackScale(const struct FSkillHitInfoPtr& Ptr);
	static ELSkillMotionType GetMotionType(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetPerfectGuardDecreaseWeaponDurabilityRate(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetPhysicalDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static ELPhysicalDamageType GetPhysicalDamageType(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetPulseRechargeRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetRegainhpDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetRegainhpMakeRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetRepulseColRadius(const struct FSkillHitInfoPtr& Ptr);
	static ELRepulseDirectionType GetRepulseDirection(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetRepulseDuration(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetRepulseEndSocket(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetRepulseStartSocket(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetRigidityRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetSharpnessReduceValueRatio(const struct FSkillHitInfoPtr& Ptr);
	static ELSkillHitType GetSkillHitType(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetSparkColRadius(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetSparkEndSocket(const struct FSkillHitInfoPtr& Ptr);
	static const class FName GetSparkStartSocket(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetStiffenDurationAttacker(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetStiffenDurationDefender(const struct FSkillHitInfoPtr& Ptr);
	static float GetStiffenPlayrateAttacker(const struct FSkillHitInfoPtr& Ptr);
	static float GetStiffenPlayrateDefender(const struct FSkillHitInfoPtr& Ptr);
	static bool GetTakeDamageIgnoreWarning(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetToughDamageRatio(const struct FSkillHitInfoPtr& Ptr);
	static int32 GetToughRecoveryDelayTimeRatio(const struct FSkillHitInfoPtr& Ptr);
	static bool GetTraceAttack(const struct FSkillHitInfoPtr& Ptr);
	static bool GetUseCounter(const struct FSkillHitInfoPtr& Ptr);
	static bool GetUseHitIntencity(const struct FSkillHitInfoPtr& Ptr);
	static bool GetUseSmash(const struct FSkillHitInfoPtr& Ptr);
	static ELWeaponAttachPointType GetWeaponAttachPointType(const struct FSkillHitInfoPtr& Ptr);
	static bool IsValid(const struct FSkillHitInfoPtr& Ptr);
	static void IsValidBranch(const struct FSkillHitInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillHitInfoPtrFuncLibrary">();
	}
	static class USkillHitInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillHitInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USkillHitInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USkillHitInfoPtrFuncLibrary");
static_assert(sizeof(USkillHitInfoPtrFuncLibrary) == 0x000028, "Wrong size on USkillHitInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SkillHitInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USkillHitInfoAsset final : public UContentInfoAsset
{
public:
	struct FSkillHitInfoDB                        ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSkillHitInfoPtr FindSkillHitInfoByNameBP(class FName CodeName);
	static const TArray<struct FSkillHitInfo> GetSkillHitInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillHitInfoAsset">();
	}
	static class USkillHitInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillHitInfoAsset>();
	}
};
static_assert(alignof(USkillHitInfoAsset) == 0x000010, "Wrong alignment on USkillHitInfoAsset");
static_assert(sizeof(USkillHitInfoAsset) == 0x000120, "Wrong size on USkillHitInfoAsset");
static_assert(offsetof(USkillHitInfoAsset, ContentInfoDB) == 0x000078, "Member 'USkillHitInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SkillIndicatorInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillIndicatorInfoFuncLibrary final : public UObject
{
public:
	static class FString GetAttachSocket(const struct FSkillIndicatorInfo& Info);
	static const class FName GetCodeName(const struct FSkillIndicatorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetFxPath(const struct FSkillIndicatorInfo& Info);
	static const TSoftObjectPtr<class UObject> GetSoundPath(const struct FSkillIndicatorInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillIndicatorInfoFuncLibrary">();
	}
	static class USkillIndicatorInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillIndicatorInfoFuncLibrary>();
	}
};
static_assert(alignof(USkillIndicatorInfoFuncLibrary) == 0x000008, "Wrong alignment on USkillIndicatorInfoFuncLibrary");
static_assert(sizeof(USkillIndicatorInfoFuncLibrary) == 0x000028, "Wrong size on USkillIndicatorInfoFuncLibrary");

// Class ProjectPContentInfo.SkillIndicatorInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillIndicatorInfoPtrFuncLibrary final : public UObject
{
public:
	static class FString GetAttachSocket(const struct FSkillIndicatorInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSkillIndicatorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetFxPath(const struct FSkillIndicatorInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetSoundPath(const struct FSkillIndicatorInfoPtr& Ptr);
	static bool IsValid(const struct FSkillIndicatorInfoPtr& Ptr);
	static void IsValidBranch(const struct FSkillIndicatorInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillIndicatorInfoPtrFuncLibrary">();
	}
	static class USkillIndicatorInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillIndicatorInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USkillIndicatorInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USkillIndicatorInfoPtrFuncLibrary");
static_assert(sizeof(USkillIndicatorInfoPtrFuncLibrary) == 0x000028, "Wrong size on USkillIndicatorInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SkillIndicatorInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USkillIndicatorInfoAsset final : public UContentInfoAsset
{
public:
	struct FSkillIndicatorInfoDB                  ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSkillIndicatorInfoPtr FindSkillIndicatorInfoByNameBP(class FName CodeName);
	static const TArray<struct FSkillIndicatorInfo> GetSkillIndicatorInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillIndicatorInfoAsset">();
	}
	static class USkillIndicatorInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillIndicatorInfoAsset>();
	}
};
static_assert(alignof(USkillIndicatorInfoAsset) == 0x000010, "Wrong alignment on USkillIndicatorInfoAsset");
static_assert(sizeof(USkillIndicatorInfoAsset) == 0x000120, "Wrong size on USkillIndicatorInfoAsset");
static_assert(offsetof(USkillIndicatorInfoAsset, ContentInfoDB) == 0x000078, "Member 'USkillIndicatorInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SkillInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAbortSkillCooltimeresetPercent(const struct FSkillInfo& Info);
	static ELActionCategory GetActionCategory(const struct FSkillInfo& Info);
	static const class FName GetActionClassCodeName(const struct FSkillInfo& Info);
	static const class FName GetActionGroupTableCodeName(const struct FSkillInfo& Info);
	static const class FName GetActionPathCodeName(const struct FSkillInfo& Info);
	static ELStartRotationType GetActionRotationType(const struct FSkillInfo& Info);
	static ELAdditiveHitType GetAdditiveHitType(const struct FSkillInfo& Info);
	static bool GetAllowFalling(const struct FSkillInfo& Info);
	static class FString GetAnimName(const struct FSkillInfo& Info);
	static bool GetAutoTargeting(const struct FSkillInfo& Info);
	static ELPartsAttachPointType GetBodyWeaponAttachPointType(const struct FSkillInfo& Info);
	static const class FName GetCodeName(const struct FSkillInfo& Info);
	static int32 GetConsumeAmmo(const struct FSkillInfo& Info);
	static int32 GetConsumeFrenzyUnitCount(const struct FSkillInfo& Info);
	static int32 GetConsumeItemCount(const struct FSkillInfo& Info);
	static int32 GetConsumeSlaveMagazine(const struct FSkillInfo& Info);
	static int32 GetConsumeStaminaPoint(const struct FSkillInfo& Info);
	static int32 GetCooltimeMax(const struct FSkillInfo& Info);
	static int32 GetCooltimeMin(const struct FSkillInfo& Info);
	static bool GetDecreaceUseSkillCountByCancel(const struct FSkillInfo& Info);
	static bool GetDefenceSkill(const struct FSkillInfo& Info);
	static float GetDestructionDefenceMod(const struct FSkillInfo& Info);
	static float GetDestructionReduceMod(const struct FSkillInfo& Info);
	static bool GetDontUseSkillCount(const struct FSkillInfo& Info);
	static bool GetEnableBladeWeight(const struct FSkillInfo& Info);
	static bool GetEndSectionByLanding(const struct FSkillInfo& Info);
	static class FString GetEndSectionCallingCommand(const struct FSkillInfo& Info);
	static ELFableConsumeUIType GetFableConsumeUi(const struct FSkillInfo& Info);
	static const class FName GetFailSkill(const struct FSkillInfo& Info);
	static int32 GetGlobalCooltimeMax(const struct FSkillInfo& Info);
	static int32 GetGlobalCooltimeMin(const struct FSkillInfo& Info);
	static const class FName GetHandleAnimState(const struct FSkillInfo& Info);
	static bool GetIgnoreCheckRootmotion(const struct FSkillInfo& Info);
	static const class FName GetImmuneCodeName(const struct FSkillInfo& Info);
	static int32 GetInitCooltimeMax(const struct FSkillInfo& Info);
	static int32 GetInitCooltimeMin(const struct FSkillInfo& Info);
	static ELInputTypeHudOnly GetInputTypeHudOnly(const struct FSkillInfo& Info);
	static class FString GetLocalTextSkillName(const struct FSkillInfo& Info);
	static const class FName GetLocalTextSkillNameCn(const struct FSkillInfo& Info);
	static class FText GetLocalTextSkillNameLocalize(const struct FSkillInfo& Info);
	static class FString GetLocalTextSkillTooltip(const struct FSkillInfo& Info);
	static const class FName GetLocalTextSkillTooltipCn(const struct FSkillInfo& Info);
	static class FText GetLocalTextSkillTooltipLocalize(const struct FSkillInfo& Info);
	static const class FName GetLonghandleActionClassCodeName(const struct FSkillInfo& Info);
	static class FString GetLonghandleAnimName(const struct FSkillInfo& Info);
	static bool GetNaviJumpEnable(const struct FSkillInfo& Info);
	static bool GetNotUseDestroyed(const struct FSkillInfo& Info);
	static const class FName GetPartNeeded(const struct FSkillInfo& Info);
	static bool GetPreventFallingDamage(const struct FSkillInfo& Info);
	static int32 GetRequireAmmo(const struct FSkillInfo& Info);
	static int32 GetRequireFrenzyUnitCount(const struct FSkillInfo& Info);
	static const class FName GetRequireItemCodeName(const struct FSkillInfo& Info);
	static bool GetRequireSlaveMagazine(const struct FSkillInfo& Info);
	static int32 GetRequireSlaveMagazinePoint(const struct FSkillInfo& Info);
	static bool GetRequireStamina(const struct FSkillInfo& Info);
	static int32 GetRequireStaminaPoint(const struct FSkillInfo& Info);
	static bool GetResetToughPoint(const struct FSkillInfo& Info);
	static const class FName GetShorthandleActionClassCodeName(const struct FSkillInfo& Info);
	static class FString GetShorthandleAnimName(const struct FSkillInfo& Info);
	static int32 GetSkillApproachDistMax(const struct FSkillInfo& Info);
	static int32 GetSkillApproachDistMin(const struct FSkillInfo& Info);
	static int32 GetSkillDistHeight(const struct FSkillInfo& Info);
	static int32 GetSkillDistMax(const struct FSkillInfo& Info);
	static int32 GetSkillDistMin(const struct FSkillInfo& Info);
	static const class FName GetSkillGroupCodeName(const struct FSkillInfo& Info);
	static int32 GetSkillGroupCooltimeMax(const struct FSkillInfo& Info);
	static int32 GetSkillGroupCooltimeMin(const struct FSkillInfo& Info);
	static int32 GetSkillmoveCheckAngle(const struct FSkillInfo& Info);
	static int32 GetSkillRangeAngleEnd(const struct FSkillInfo& Info);
	static int32 GetSkillRangeAngleStart(const struct FSkillInfo& Info);
	static ELAIRangeCheckType GetSkillrangeChecktype(const struct FSkillInfo& Info);
	static int32 GetSkillRotateAngle(const struct FSkillInfo& Info);
	static int32 GetSkilmoveCheckDist(const struct FSkillInfo& Info);
	static int32 GetStartRotationBlendTime(const struct FSkillInfo& Info);
	static ELStartRotationType GetStartRotationType(const struct FSkillInfo& Info);
	static class FString GetStartSection(const struct FSkillInfo& Info);
	static bool GetUseGlobalCooltime(const struct FSkillInfo& Info);
	static bool GetUsePureWeaponWeight(const struct FSkillInfo& Info);
	static bool GetUseSlopeLookat(const struct FSkillInfo& Info);
	static ELWeaponAttachPointType GetWeaponAttachPointType(const struct FSkillInfo& Info);
	static const class FName GetWeaponBreakChangeSkill(const struct FSkillInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillInfoFuncLibrary">();
	}
	static class USkillInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillInfoFuncLibrary>();
	}
};
static_assert(alignof(USkillInfoFuncLibrary) == 0x000008, "Wrong alignment on USkillInfoFuncLibrary");
static_assert(sizeof(USkillInfoFuncLibrary) == 0x000028, "Wrong size on USkillInfoFuncLibrary");

// Class ProjectPContentInfo.SkillInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAbortSkillCooltimeresetPercent(const struct FSkillInfoPtr& Ptr);
	static ELActionCategory GetActionCategory(const struct FSkillInfoPtr& Ptr);
	static const class FName GetActionClassCodeName(const struct FSkillInfoPtr& Ptr);
	static const class FName GetActionGroupTableCodeName(const struct FSkillInfoPtr& Ptr);
	static const class FName GetActionPathCodeName(const struct FSkillInfoPtr& Ptr);
	static ELStartRotationType GetActionRotationType(const struct FSkillInfoPtr& Ptr);
	static ELAdditiveHitType GetAdditiveHitType(const struct FSkillInfoPtr& Ptr);
	static bool GetAllowFalling(const struct FSkillInfoPtr& Ptr);
	static class FString GetAnimName(const struct FSkillInfoPtr& Ptr);
	static bool GetAutoTargeting(const struct FSkillInfoPtr& Ptr);
	static ELPartsAttachPointType GetBodyWeaponAttachPointType(const struct FSkillInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSkillInfoPtr& Ptr);
	static int32 GetConsumeAmmo(const struct FSkillInfoPtr& Ptr);
	static int32 GetConsumeFrenzyUnitCount(const struct FSkillInfoPtr& Ptr);
	static int32 GetConsumeItemCount(const struct FSkillInfoPtr& Ptr);
	static int32 GetConsumeSlaveMagazine(const struct FSkillInfoPtr& Ptr);
	static int32 GetConsumeStaminaPoint(const struct FSkillInfoPtr& Ptr);
	static int32 GetCooltimeMax(const struct FSkillInfoPtr& Ptr);
	static int32 GetCooltimeMin(const struct FSkillInfoPtr& Ptr);
	static bool GetDecreaceUseSkillCountByCancel(const struct FSkillInfoPtr& Ptr);
	static bool GetDefenceSkill(const struct FSkillInfoPtr& Ptr);
	static float GetDestructionDefenceMod(const struct FSkillInfoPtr& Ptr);
	static float GetDestructionReduceMod(const struct FSkillInfoPtr& Ptr);
	static bool GetDontUseSkillCount(const struct FSkillInfoPtr& Ptr);
	static bool GetEnableBladeWeight(const struct FSkillInfoPtr& Ptr);
	static bool GetEndSectionByLanding(const struct FSkillInfoPtr& Ptr);
	static class FString GetEndSectionCallingCommand(const struct FSkillInfoPtr& Ptr);
	static ELFableConsumeUIType GetFableConsumeUi(const struct FSkillInfoPtr& Ptr);
	static const class FName GetFailSkill(const struct FSkillInfoPtr& Ptr);
	static int32 GetGlobalCooltimeMax(const struct FSkillInfoPtr& Ptr);
	static int32 GetGlobalCooltimeMin(const struct FSkillInfoPtr& Ptr);
	static const class FName GetHandleAnimState(const struct FSkillInfoPtr& Ptr);
	static bool GetIgnoreCheckRootmotion(const struct FSkillInfoPtr& Ptr);
	static const class FName GetImmuneCodeName(const struct FSkillInfoPtr& Ptr);
	static int32 GetInitCooltimeMax(const struct FSkillInfoPtr& Ptr);
	static int32 GetInitCooltimeMin(const struct FSkillInfoPtr& Ptr);
	static ELInputTypeHudOnly GetInputTypeHudOnly(const struct FSkillInfoPtr& Ptr);
	static class FString GetLocalTextSkillName(const struct FSkillInfoPtr& Ptr);
	static const class FName GetLocalTextSkillNameCn(const struct FSkillInfoPtr& Ptr);
	static class FText GetLocalTextSkillNameLocalize(const struct FSkillInfoPtr& Ptr);
	static class FString GetLocalTextSkillTooltip(const struct FSkillInfoPtr& Ptr);
	static const class FName GetLocalTextSkillTooltipCn(const struct FSkillInfoPtr& Ptr);
	static class FText GetLocalTextSkillTooltipLocalize(const struct FSkillInfoPtr& Ptr);
	static const class FName GetLonghandleActionClassCodeName(const struct FSkillInfoPtr& Ptr);
	static class FString GetLonghandleAnimName(const struct FSkillInfoPtr& Ptr);
	static bool GetNaviJumpEnable(const struct FSkillInfoPtr& Ptr);
	static bool GetNotUseDestroyed(const struct FSkillInfoPtr& Ptr);
	static const class FName GetPartNeeded(const struct FSkillInfoPtr& Ptr);
	static bool GetPreventFallingDamage(const struct FSkillInfoPtr& Ptr);
	static int32 GetRequireAmmo(const struct FSkillInfoPtr& Ptr);
	static int32 GetRequireFrenzyUnitCount(const struct FSkillInfoPtr& Ptr);
	static const class FName GetRequireItemCodeName(const struct FSkillInfoPtr& Ptr);
	static bool GetRequireSlaveMagazine(const struct FSkillInfoPtr& Ptr);
	static int32 GetRequireSlaveMagazinePoint(const struct FSkillInfoPtr& Ptr);
	static bool GetRequireStamina(const struct FSkillInfoPtr& Ptr);
	static int32 GetRequireStaminaPoint(const struct FSkillInfoPtr& Ptr);
	static bool GetResetToughPoint(const struct FSkillInfoPtr& Ptr);
	static const class FName GetShorthandleActionClassCodeName(const struct FSkillInfoPtr& Ptr);
	static class FString GetShorthandleAnimName(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillApproachDistMax(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillApproachDistMin(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillDistHeight(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillDistMax(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillDistMin(const struct FSkillInfoPtr& Ptr);
	static const class FName GetSkillGroupCodeName(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillGroupCooltimeMax(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillGroupCooltimeMin(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillmoveCheckAngle(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillRangeAngleEnd(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillRangeAngleStart(const struct FSkillInfoPtr& Ptr);
	static ELAIRangeCheckType GetSkillrangeChecktype(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkillRotateAngle(const struct FSkillInfoPtr& Ptr);
	static int32 GetSkilmoveCheckDist(const struct FSkillInfoPtr& Ptr);
	static int32 GetStartRotationBlendTime(const struct FSkillInfoPtr& Ptr);
	static ELStartRotationType GetStartRotationType(const struct FSkillInfoPtr& Ptr);
	static class FString GetStartSection(const struct FSkillInfoPtr& Ptr);
	static bool GetUseGlobalCooltime(const struct FSkillInfoPtr& Ptr);
	static bool GetUsePureWeaponWeight(const struct FSkillInfoPtr& Ptr);
	static bool GetUseSlopeLookat(const struct FSkillInfoPtr& Ptr);
	static ELWeaponAttachPointType GetWeaponAttachPointType(const struct FSkillInfoPtr& Ptr);
	static const class FName GetWeaponBreakChangeSkill(const struct FSkillInfoPtr& Ptr);
	static bool IsValid(const struct FSkillInfoPtr& Ptr);
	static void IsValidBranch(const struct FSkillInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillInfoPtrFuncLibrary">();
	}
	static class USkillInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USkillInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USkillInfoPtrFuncLibrary");
static_assert(sizeof(USkillInfoPtrFuncLibrary) == 0x000028, "Wrong size on USkillInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SkillMoveInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillMoveInfoFuncLibrary final : public UObject
{
public:
	static bool GetApplyAnimScaling(const struct FSkillMoveInfo& Info);
	static const class FName GetCodeName(const struct FSkillMoveInfo& Info);
	static bool GetIgnoreRootmotionMove(const struct FSkillMoveInfo& Info);
	static bool GetIgnoreRootmotionRotation(const struct FSkillMoveInfo& Info);
	static bool GetMoveCheckNavPath(const struct FSkillMoveInfo& Info);
	static const TSoftObjectPtr<class UObject> GetMoveCurve(const struct FSkillMoveInfo& Info);
	static float GetMoveDistance(const struct FSkillMoveInfo& Info);
	static bool GetMoveEnable(const struct FSkillMoveInfo& Info);
	static bool GetMoveFixedDirectionUse(const struct FSkillMoveInfo& Info);
	static bool GetMoveIgnoreRotateUse(const struct FSkillMoveInfo& Info);
	static float GetMoveRotYaw(const struct FSkillMoveInfo& Info);
	static float GetMoveSpeed(const struct FSkillMoveInfo& Info);
	static float GetMoveToTargetOffsetDistance(const struct FSkillMoveInfo& Info);
	static float GetMoveToTargetSpeed(const struct FSkillMoveInfo& Info);
	static bool GetMoveToTargetUse(const struct FSkillMoveInfo& Info);
	static float GetPursuitToTargetScalingOffsetDistance(const struct FSkillMoveInfo& Info);
	static float GetPursuitToTargetScalingSpeedMax(const struct FSkillMoveInfo& Info);
	static bool GetPursuitToTargetScalingSpeedUse(const struct FSkillMoveInfo& Info);
	static float GetRotateAngle(const struct FSkillMoveInfo& Info);
	static bool GetRotateAngleUse(const struct FSkillMoveInfo& Info);
	static bool GetRotateEnable(const struct FSkillMoveInfo& Info);
	static float GetRotateLimit(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingCompletionDegree(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingCompletionDegreeLeft(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingCompletionDegreeRight(const struct FSkillMoveInfo& Info);
	static ELTrackingDirectionType GetRotateTrackingDirection(const struct FSkillMoveInfo& Info);
	static bool GetRotateTrackingFullHomingUse(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingGiveUpDegree(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingRotateAngleOffset(const struct FSkillMoveInfo& Info);
	static bool GetRotateTrackingSetDirectionOnStart(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingSetDirectionOnStartLeft(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingSetDirectionOnStartRight(const struct FSkillMoveInfo& Info);
	static float GetRotateTrackingSpeed(const struct FSkillMoveInfo& Info);
	static bool GetRotateTrackingUse(const struct FSkillMoveInfo& Info);
	static bool GetRotateUseCaptureLocation(const struct FSkillMoveInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillMoveInfoFuncLibrary">();
	}
	static class USkillMoveInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillMoveInfoFuncLibrary>();
	}
};
static_assert(alignof(USkillMoveInfoFuncLibrary) == 0x000008, "Wrong alignment on USkillMoveInfoFuncLibrary");
static_assert(sizeof(USkillMoveInfoFuncLibrary) == 0x000028, "Wrong size on USkillMoveInfoFuncLibrary");

// Class ProjectPContentInfo.SkillMoveInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkillMoveInfoPtrFuncLibrary final : public UObject
{
public:
	static bool GetApplyAnimScaling(const struct FSkillMoveInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetIgnoreRootmotionMove(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetIgnoreRootmotionRotation(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetMoveCheckNavPath(const struct FSkillMoveInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetMoveCurve(const struct FSkillMoveInfoPtr& Ptr);
	static float GetMoveDistance(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetMoveEnable(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetMoveFixedDirectionUse(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetMoveIgnoreRotateUse(const struct FSkillMoveInfoPtr& Ptr);
	static float GetMoveRotYaw(const struct FSkillMoveInfoPtr& Ptr);
	static float GetMoveSpeed(const struct FSkillMoveInfoPtr& Ptr);
	static float GetMoveToTargetOffsetDistance(const struct FSkillMoveInfoPtr& Ptr);
	static float GetMoveToTargetSpeed(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetMoveToTargetUse(const struct FSkillMoveInfoPtr& Ptr);
	static float GetPursuitToTargetScalingOffsetDistance(const struct FSkillMoveInfoPtr& Ptr);
	static float GetPursuitToTargetScalingSpeedMax(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetPursuitToTargetScalingSpeedUse(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateAngle(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetRotateAngleUse(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetRotateEnable(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateLimit(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingCompletionDegree(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingCompletionDegreeLeft(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingCompletionDegreeRight(const struct FSkillMoveInfoPtr& Ptr);
	static ELTrackingDirectionType GetRotateTrackingDirection(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetRotateTrackingFullHomingUse(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingGiveUpDegree(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingRotateAngleOffset(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetRotateTrackingSetDirectionOnStart(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingSetDirectionOnStartLeft(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingSetDirectionOnStartRight(const struct FSkillMoveInfoPtr& Ptr);
	static float GetRotateTrackingSpeed(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetRotateTrackingUse(const struct FSkillMoveInfoPtr& Ptr);
	static bool GetRotateUseCaptureLocation(const struct FSkillMoveInfoPtr& Ptr);
	static bool IsValid(const struct FSkillMoveInfoPtr& Ptr);
	static void IsValidBranch(const struct FSkillMoveInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillMoveInfoPtrFuncLibrary">();
	}
	static class USkillMoveInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillMoveInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USkillMoveInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USkillMoveInfoPtrFuncLibrary");
static_assert(sizeof(USkillMoveInfoPtrFuncLibrary) == 0x000028, "Wrong size on USkillMoveInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SkillMoveInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USkillMoveInfoAsset final : public UContentInfoAsset
{
public:
	struct FSkillMoveInfoDB                       ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSkillMoveInfoPtr FindSkillMoveInfoByNameBP(class FName CodeName);
	static const TArray<struct FSkillMoveInfo> GetSkillMoveInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillMoveInfoAsset">();
	}
	static class USkillMoveInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillMoveInfoAsset>();
	}
};
static_assert(alignof(USkillMoveInfoAsset) == 0x000010, "Wrong alignment on USkillMoveInfoAsset");
static_assert(sizeof(USkillMoveInfoAsset) == 0x000120, "Wrong size on USkillMoveInfoAsset");
static_assert(offsetof(USkillMoveInfoAsset, ContentInfoDB) == 0x000078, "Member 'USkillMoveInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.Skill_IndicatorInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkill_IndicatorInfoFuncLibrary final : public UObject
{
public:
	static const TSoftClassPtr<class UClass> GetActionClass(const struct FSkill_IndicatorInfo& Info);
	static const class FName GetCodeName(const struct FSkill_IndicatorInfo& Info);
	static ELActionCategory GetSystemCategory(const struct FSkill_IndicatorInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skill_IndicatorInfoFuncLibrary">();
	}
	static class USkill_IndicatorInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkill_IndicatorInfoFuncLibrary>();
	}
};
static_assert(alignof(USkill_IndicatorInfoFuncLibrary) == 0x000008, "Wrong alignment on USkill_IndicatorInfoFuncLibrary");
static_assert(sizeof(USkill_IndicatorInfoFuncLibrary) == 0x000028, "Wrong size on USkill_IndicatorInfoFuncLibrary");

// Class ProjectPContentInfo.Skill_IndicatorInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USkill_IndicatorInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftClassPtr<class UClass> GetActionClass(const struct FSkill_IndicatorInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSkill_IndicatorInfoPtr& Ptr);
	static ELActionCategory GetSystemCategory(const struct FSkill_IndicatorInfoPtr& Ptr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skill_IndicatorInfoPtrFuncLibrary">();
	}
	static class USkill_IndicatorInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkill_IndicatorInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USkill_IndicatorInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USkill_IndicatorInfoPtrFuncLibrary");
static_assert(sizeof(USkill_IndicatorInfoPtrFuncLibrary) == 0x000028, "Wrong size on USkill_IndicatorInfoPtrFuncLibrary");

// Class ProjectPContentInfo.Skill_IndicatorInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USkill_IndicatorInfoAsset final : public UContentInfoAsset
{
public:
	struct FSkill_IndicatorInfoDB                 ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSkill_IndicatorInfoPtr FindSkill_IndicatorInfoByNameBP(class FName CodeName);
	static const TArray<struct FSkill_IndicatorInfo> GetSkill_IndicatorInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skill_IndicatorInfoAsset">();
	}
	static class USkill_IndicatorInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkill_IndicatorInfoAsset>();
	}
};
static_assert(alignof(USkill_IndicatorInfoAsset) == 0x000010, "Wrong alignment on USkill_IndicatorInfoAsset");
static_assert(sizeof(USkill_IndicatorInfoAsset) == 0x000120, "Wrong size on USkill_IndicatorInfoAsset");
static_assert(offsetof(USkill_IndicatorInfoAsset, ContentInfoDB) == 0x000078, "Member 'USkill_IndicatorInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SlaveArmPageInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlaveArmPageInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetActivateRequireItemCodeName(const struct FSlaveArmPageInfo& Info);
	static const class FName GetCodeName(const struct FSlaveArmPageInfo& Info);
	static const class FName GetIcon(const struct FSlaveArmPageInfo& Info);
	static class FString GetLocalTextTooltip(const struct FSlaveArmPageInfo& Info);
	static const class FName GetLocalTextTooltipCn(const struct FSlaveArmPageInfo& Info);
	static class FText GetLocalTextTooltipLocalize(const struct FSlaveArmPageInfo& Info);
	static int32 GetPageIndex(const struct FSlaveArmPageInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmPageInfoFuncLibrary">();
	}
	static class USlaveArmPageInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmPageInfoFuncLibrary>();
	}
};
static_assert(alignof(USlaveArmPageInfoFuncLibrary) == 0x000008, "Wrong alignment on USlaveArmPageInfoFuncLibrary");
static_assert(sizeof(USlaveArmPageInfoFuncLibrary) == 0x000028, "Wrong size on USlaveArmPageInfoFuncLibrary");

// Class ProjectPContentInfo.SlaveArmPageInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlaveArmPageInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetActivateRequireItemCodeName(const struct FSlaveArmPageInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSlaveArmPageInfoPtr& Ptr);
	static const class FName GetIcon(const struct FSlaveArmPageInfoPtr& Ptr);
	static class FString GetLocalTextTooltip(const struct FSlaveArmPageInfoPtr& Ptr);
	static const class FName GetLocalTextTooltipCn(const struct FSlaveArmPageInfoPtr& Ptr);
	static class FText GetLocalTextTooltipLocalize(const struct FSlaveArmPageInfoPtr& Ptr);
	static int32 GetPageIndex(const struct FSlaveArmPageInfoPtr& Ptr);
	static bool IsValid(const struct FSlaveArmPageInfoPtr& Ptr);
	static void IsValidBranch(const struct FSlaveArmPageInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmPageInfoPtrFuncLibrary">();
	}
	static class USlaveArmPageInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmPageInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USlaveArmPageInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USlaveArmPageInfoPtrFuncLibrary");
static_assert(sizeof(USlaveArmPageInfoPtrFuncLibrary) == 0x000028, "Wrong size on USlaveArmPageInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SlaveArmPageInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USlaveArmPageInfoAsset final : public UContentInfoAsset
{
public:
	struct FSlaveArmPageInfoDB                    ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSlaveArmPageInfoPtr FindSlaveArmPageInfoByNameBP(class FName CodeName);
	static const TArray<struct FSlaveArmPageInfo> GetSlaveArmPageInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmPageInfoAsset">();
	}
	static class USlaveArmPageInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmPageInfoAsset>();
	}
};
static_assert(alignof(USlaveArmPageInfoAsset) == 0x000010, "Wrong alignment on USlaveArmPageInfoAsset");
static_assert(sizeof(USlaveArmPageInfoAsset) == 0x000120, "Wrong size on USlaveArmPageInfoAsset");
static_assert(offsetof(USlaveArmPageInfoAsset, ContentInfoDB) == 0x000078, "Member 'USlaveArmPageInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SlaveArmReinforcementInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlaveArmReinforcementInfoFuncLibrary final : public UObject
{
public:
	static int32 GetAdditionalAmmoMax(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetChangeHitIndex(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetChangePlayRateSection(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetChangeProjectile(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetChangeSection(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetChangeSkillCodeName(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetConsumeSlaveMagazineMod(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetHitIndexToChange(const struct FSlaveArmReinforcementInfo& Info);
	static float GetPlayRate(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetProjectileToChange(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetReinforcementName(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetSectionToChange(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetSlavearmAcidAttackMod(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetSlavearmElectricAttackMod(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetSlavearmFireAttackMod(const struct FSlaveArmReinforcementInfo& Info);
	static int32 GetSlavearmPhysicalAttackMod(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetSpecialBuffCodeName(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetSpecialBuffSection(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetVariableToChange(const struct FSlaveArmReinforcementInfo& Info);
	static const class FName GetVariableValue(const struct FSlaveArmReinforcementInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmReinforcementInfoFuncLibrary">();
	}
	static class USlaveArmReinforcementInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmReinforcementInfoFuncLibrary>();
	}
};
static_assert(alignof(USlaveArmReinforcementInfoFuncLibrary) == 0x000008, "Wrong alignment on USlaveArmReinforcementInfoFuncLibrary");
static_assert(sizeof(USlaveArmReinforcementInfoFuncLibrary) == 0x000028, "Wrong size on USlaveArmReinforcementInfoFuncLibrary");

// Class ProjectPContentInfo.SlaveArmReinforcementInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlaveArmReinforcementInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetAdditionalAmmoMax(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetChangeHitIndex(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetChangePlayRateSection(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetChangeProjectile(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetChangeSection(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetChangeSkillCodeName(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetConsumeSlaveMagazineMod(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetHitIndexToChange(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static float GetPlayRate(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetProjectileToChange(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetReinforcementName(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetSectionToChange(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetSlavearmAcidAttackMod(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetSlavearmElectricAttackMod(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetSlavearmFireAttackMod(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static int32 GetSlavearmPhysicalAttackMod(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetSpecialBuffCodeName(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetSpecialBuffSection(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetVariableToChange(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static const class FName GetVariableValue(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static bool IsValid(const struct FSlaveArmReinforcementInfoPtr& Ptr);
	static void IsValidBranch(const struct FSlaveArmReinforcementInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmReinforcementInfoPtrFuncLibrary">();
	}
	static class USlaveArmReinforcementInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmReinforcementInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USlaveArmReinforcementInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USlaveArmReinforcementInfoPtrFuncLibrary");
static_assert(sizeof(USlaveArmReinforcementInfoPtrFuncLibrary) == 0x000028, "Wrong size on USlaveArmReinforcementInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SlaveArmReinforcementInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) USlaveArmReinforcementInfoAsset final : public UContentInfoAsset
{
public:
	struct FSlaveArmReinforcementInfoDB           ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FSlaveArmReinforcementInfo> GetSlaveArmReinforcementInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmReinforcementInfoAsset">();
	}
	static class USlaveArmReinforcementInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmReinforcementInfoAsset>();
	}
};
static_assert(alignof(USlaveArmReinforcementInfoAsset) == 0x000010, "Wrong alignment on USlaveArmReinforcementInfoAsset");
static_assert(sizeof(USlaveArmReinforcementInfoAsset) == 0x0000D0, "Wrong size on USlaveArmReinforcementInfoAsset");
static_assert(offsetof(USlaveArmReinforcementInfoAsset, ContentInfoDB) == 0x000078, "Member 'USlaveArmReinforcementInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SlaveArmTreeInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlaveArmTreeInfoFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetAttachMesh(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetCodeName(const struct FSlaveArmTreeInfo& Info);
	static int32 GetDepth(const struct FSlaveArmTreeInfo& Info);
	static const TSoftObjectPtr<class UObject> GetIcon(const struct FSlaveArmTreeInfo& Info);
	static class FString GetLocalTextName(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FSlaveArmTreeInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FSlaveArmTreeInfo& Info);
	static class FString GetLocalTextTooltip(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetLocalTextTooltipCn(const struct FSlaveArmTreeInfo& Info);
	static class FText GetLocalTextTooltipLocalize(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetPrerequisiteTreeCodeName(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetReinforcementCodeName(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetRequireItemCodeName(const struct FSlaveArmTreeInfo& Info);
	static int32 GetRequireItemCount(const struct FSlaveArmTreeInfo& Info);
	static const class FName GetSlavearmPageCodeName(const struct FSlaveArmTreeInfo& Info);
	static class FString GetVideo(const struct FSlaveArmTreeInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmTreeInfoFuncLibrary">();
	}
	static class USlaveArmTreeInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmTreeInfoFuncLibrary>();
	}
};
static_assert(alignof(USlaveArmTreeInfoFuncLibrary) == 0x000008, "Wrong alignment on USlaveArmTreeInfoFuncLibrary");
static_assert(sizeof(USlaveArmTreeInfoFuncLibrary) == 0x000028, "Wrong size on USlaveArmTreeInfoFuncLibrary");

// Class ProjectPContentInfo.SlaveArmTreeInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USlaveArmTreeInfoPtrFuncLibrary final : public UObject
{
public:
	static const TSoftObjectPtr<class UObject> GetAttachMesh(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSlaveArmTreeInfoPtr& Ptr);
	static int32 GetDepth(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetIcon(const struct FSlaveArmTreeInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FSlaveArmTreeInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FSlaveArmTreeInfoPtr& Ptr);
	static class FString GetLocalTextTooltip(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetLocalTextTooltipCn(const struct FSlaveArmTreeInfoPtr& Ptr);
	static class FText GetLocalTextTooltipLocalize(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetPrerequisiteTreeCodeName(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetReinforcementCodeName(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetRequireItemCodeName(const struct FSlaveArmTreeInfoPtr& Ptr);
	static int32 GetRequireItemCount(const struct FSlaveArmTreeInfoPtr& Ptr);
	static const class FName GetSlavearmPageCodeName(const struct FSlaveArmTreeInfoPtr& Ptr);
	static class FString GetVideo(const struct FSlaveArmTreeInfoPtr& Ptr);
	static bool IsValid(const struct FSlaveArmTreeInfoPtr& Ptr);
	static void IsValidBranch(const struct FSlaveArmTreeInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmTreeInfoPtrFuncLibrary">();
	}
	static class USlaveArmTreeInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmTreeInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USlaveArmTreeInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USlaveArmTreeInfoPtrFuncLibrary");
static_assert(sizeof(USlaveArmTreeInfoPtrFuncLibrary) == 0x000028, "Wrong size on USlaveArmTreeInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SlaveArmTreeInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USlaveArmTreeInfoAsset final : public UContentInfoAsset
{
public:
	struct FSlaveArmTreeInfoDB                    ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSlaveArmTreeInfoPtr FindSlaveArmTreeInfoByNameBP(class FName CodeName);
	static const TArray<struct FSlaveArmTreeInfo> GetSlaveArmTreeInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveArmTreeInfoAsset">();
	}
	static class USlaveArmTreeInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlaveArmTreeInfoAsset>();
	}
};
static_assert(alignof(USlaveArmTreeInfoAsset) == 0x000010, "Wrong alignment on USlaveArmTreeInfoAsset");
static_assert(sizeof(USlaveArmTreeInfoAsset) == 0x000120, "Wrong size on USlaveArmTreeInfoAsset");
static_assert(offsetof(USlaveArmTreeInfoAsset, ContentInfoDB) == 0x000078, "Member 'USlaveArmTreeInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SpecialBuffInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpecialBuffInfoFuncLibrary final : public UObject
{
public:
	static int32 GetBase(const struct FSpecialBuffInfo& Info);
	static float GetBottom(const struct FSpecialBuffInfo& Info);
	static const class FName GetCodeName(const struct FSpecialBuffInfo& Info);
	static float GetExponent(const struct FSpecialBuffInfo& Info);
	static int32 GetFactor(const struct FSpecialBuffInfo& Info);
	static const class FName GetHumanizationBuffAlterCodeName(const struct FSpecialBuffInfo& Info);
	static const TSoftObjectPtr<class UObject> GetIconResource(const struct FSpecialBuffInfo& Info);
	static class FString GetLocalTextName(const struct FSpecialBuffInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FSpecialBuffInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FSpecialBuffInfo& Info);
	static class FString GetLocalTextTooltip(const struct FSpecialBuffInfo& Info);
	static const class FName GetLocalTextTooltipCn(const struct FSpecialBuffInfo& Info);
	static class FText GetLocalTextTooltipLocalize(const struct FSpecialBuffInfo& Info);
	static int32 GetParamInt1(const struct FSpecialBuffInfo& Info);
	static int32 GetParamInt2(const struct FSpecialBuffInfo& Info);
	static int32 GetParamNum(const struct FSpecialBuffInfo& Info);
	static const class FName GetParamString1(const struct FSpecialBuffInfo& Info);
	static const class FName GetParamString2(const struct FSpecialBuffInfo& Info);
	static bool GetShowUi(const struct FSpecialBuffInfo& Info);
	static ELSpecialBuffType GetType(const struct FSpecialBuffInfo& Info);
	static bool GetUseHumanityAsMultiplier(const struct FSpecialBuffInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBuffInfoFuncLibrary">();
	}
	static class USpecialBuffInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBuffInfoFuncLibrary>();
	}
};
static_assert(alignof(USpecialBuffInfoFuncLibrary) == 0x000008, "Wrong alignment on USpecialBuffInfoFuncLibrary");
static_assert(sizeof(USpecialBuffInfoFuncLibrary) == 0x000028, "Wrong size on USpecialBuffInfoFuncLibrary");

// Class ProjectPContentInfo.SpecialBuffInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USpecialBuffInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetBase(const struct FSpecialBuffInfoPtr& Ptr);
	static float GetBottom(const struct FSpecialBuffInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FSpecialBuffInfoPtr& Ptr);
	static float GetExponent(const struct FSpecialBuffInfoPtr& Ptr);
	static int32 GetFactor(const struct FSpecialBuffInfoPtr& Ptr);
	static const class FName GetHumanizationBuffAlterCodeName(const struct FSpecialBuffInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetIconResource(const struct FSpecialBuffInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FSpecialBuffInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FSpecialBuffInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FSpecialBuffInfoPtr& Ptr);
	static class FString GetLocalTextTooltip(const struct FSpecialBuffInfoPtr& Ptr);
	static const class FName GetLocalTextTooltipCn(const struct FSpecialBuffInfoPtr& Ptr);
	static class FText GetLocalTextTooltipLocalize(const struct FSpecialBuffInfoPtr& Ptr);
	static int32 GetParamInt1(const struct FSpecialBuffInfoPtr& Ptr);
	static int32 GetParamInt2(const struct FSpecialBuffInfoPtr& Ptr);
	static int32 GetParamNum(const struct FSpecialBuffInfoPtr& Ptr);
	static const class FName GetParamString1(const struct FSpecialBuffInfoPtr& Ptr);
	static const class FName GetParamString2(const struct FSpecialBuffInfoPtr& Ptr);
	static bool GetShowUi(const struct FSpecialBuffInfoPtr& Ptr);
	static ELSpecialBuffType GetType(const struct FSpecialBuffInfoPtr& Ptr);
	static bool GetUseHumanityAsMultiplier(const struct FSpecialBuffInfoPtr& Ptr);
	static bool IsValid(const struct FSpecialBuffInfoPtr& Ptr);
	static void IsValidBranch(const struct FSpecialBuffInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBuffInfoPtrFuncLibrary">();
	}
	static class USpecialBuffInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBuffInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USpecialBuffInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USpecialBuffInfoPtrFuncLibrary");
static_assert(sizeof(USpecialBuffInfoPtrFuncLibrary) == 0x000028, "Wrong size on USpecialBuffInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SpecialBuffInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) USpecialBuffInfoAsset final : public UContentInfoAsset
{
public:
	struct FSpecialBuffInfoDB                     ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FSpecialBuffInfoPtr FindSpecialBuffInfoByNameBP(class FName CodeName);
	static const TArray<struct FSpecialBuffInfo> GetSpecialBuffInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBuffInfoAsset">();
	}
	static class USpecialBuffInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBuffInfoAsset>();
	}
};
static_assert(alignof(USpecialBuffInfoAsset) == 0x000010, "Wrong alignment on USpecialBuffInfoAsset");
static_assert(sizeof(USpecialBuffInfoAsset) == 0x000120, "Wrong size on USpecialBuffInfoAsset");
static_assert(offsetof(USpecialBuffInfoAsset, ContentInfoDB) == 0x000078, "Member 'USpecialBuffInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SubLevelOnOffInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USubLevelOnOffInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FSubLevelOnOffInfo& Info);
	static const class FName GetCondition(const struct FSubLevelOnOffInfo& Info);
	static class FString GetMapResource(const struct FSubLevelOnOffInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubLevelOnOffInfoFuncLibrary">();
	}
	static class USubLevelOnOffInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubLevelOnOffInfoFuncLibrary>();
	}
};
static_assert(alignof(USubLevelOnOffInfoFuncLibrary) == 0x000008, "Wrong alignment on USubLevelOnOffInfoFuncLibrary");
static_assert(sizeof(USubLevelOnOffInfoFuncLibrary) == 0x000028, "Wrong size on USubLevelOnOffInfoFuncLibrary");

// Class ProjectPContentInfo.SubLevelOnOffInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USubLevelOnOffInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FSubLevelOnOffInfoPtr& Ptr);
	static const class FName GetCondition(const struct FSubLevelOnOffInfoPtr& Ptr);
	static class FString GetMapResource(const struct FSubLevelOnOffInfoPtr& Ptr);
	static bool IsValid(const struct FSubLevelOnOffInfoPtr& Ptr);
	static void IsValidBranch(const struct FSubLevelOnOffInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubLevelOnOffInfoPtrFuncLibrary">();
	}
	static class USubLevelOnOffInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubLevelOnOffInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USubLevelOnOffInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USubLevelOnOffInfoPtrFuncLibrary");
static_assert(sizeof(USubLevelOnOffInfoPtrFuncLibrary) == 0x000028, "Wrong size on USubLevelOnOffInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SubLevelOnOffInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) USubLevelOnOffInfoAsset final : public UContentInfoAsset
{
public:
	struct FSubLevelOnOffInfoDB                   ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FSubLevelOnOffInfo> GetSubLevelOnOffInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubLevelOnOffInfoAsset">();
	}
	static class USubLevelOnOffInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubLevelOnOffInfoAsset>();
	}
};
static_assert(alignof(USubLevelOnOffInfoAsset) == 0x000010, "Wrong alignment on USubLevelOnOffInfoAsset");
static_assert(sizeof(USubLevelOnOffInfoAsset) == 0x0000D0, "Wrong size on USubLevelOnOffInfoAsset");
static_assert(offsetof(USubLevelOnOffInfoAsset, ContentInfoDB) == 0x000078, "Member 'USubLevelOnOffInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.SubtitleInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USubtitleInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FSubtitleInfo& Info);
	static int32 GetDuration(const struct FSubtitleInfo& Info);
	static int32 GetStartTime(const struct FSubtitleInfo& Info);
	static const class FName GetTextCodeName(const struct FSubtitleInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleInfoFuncLibrary">();
	}
	static class USubtitleInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleInfoFuncLibrary>();
	}
};
static_assert(alignof(USubtitleInfoFuncLibrary) == 0x000008, "Wrong alignment on USubtitleInfoFuncLibrary");
static_assert(sizeof(USubtitleInfoFuncLibrary) == 0x000028, "Wrong size on USubtitleInfoFuncLibrary");

// Class ProjectPContentInfo.SubtitleInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class USubtitleInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FSubtitleInfoPtr& Ptr);
	static int32 GetDuration(const struct FSubtitleInfoPtr& Ptr);
	static int32 GetStartTime(const struct FSubtitleInfoPtr& Ptr);
	static const class FName GetTextCodeName(const struct FSubtitleInfoPtr& Ptr);
	static bool IsValid(const struct FSubtitleInfoPtr& Ptr);
	static void IsValidBranch(const struct FSubtitleInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleInfoPtrFuncLibrary">();
	}
	static class USubtitleInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(USubtitleInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on USubtitleInfoPtrFuncLibrary");
static_assert(sizeof(USubtitleInfoPtrFuncLibrary) == 0x000028, "Wrong size on USubtitleInfoPtrFuncLibrary");

// Class ProjectPContentInfo.SubtitleInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) USubtitleInfoAsset final : public UContentInfoAsset
{
public:
	struct FSubtitleInfoDB                        ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FSubtitleInfo> GetSubtitleInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleInfoAsset">();
	}
	static class USubtitleInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleInfoAsset>();
	}
};
static_assert(alignof(USubtitleInfoAsset) == 0x000010, "Wrong alignment on USubtitleInfoAsset");
static_assert(sizeof(USubtitleInfoAsset) == 0x0000D0, "Wrong size on USubtitleInfoAsset");
static_assert(offsetof(USubtitleInfoAsset, ContentInfoDB) == 0x000078, "Member 'USubtitleInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.TeleportObjectInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTeleportObjectInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FTeleportObjectInfo& Info);
	static const class FName GetCommandArrival(const struct FTeleportObjectInfo& Info);
	static const class FName GetCommandDeparture(const struct FTeleportObjectInfo& Info);
	static class FString GetConditionFailMsg(const struct FTeleportObjectInfo& Info);
	static const class FName GetConditionFailMsgCn(const struct FTeleportObjectInfo& Info);
	static class FText GetConditionFailMsgLocalize(const struct FTeleportObjectInfo& Info);
	static const class FName GetConditionLocationVisible(const struct FTeleportObjectInfo& Info);
	static const class FName GetExitPortal(const struct FTeleportObjectInfo& Info);
	static class FString GetLoadingCharpter(const struct FTeleportObjectInfo& Info);
	static const TSoftObjectPtr<class UObject> GetLoadingImage(const struct FTeleportObjectInfo& Info);
	static class FString GetLocalTextName(const struct FTeleportObjectInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FTeleportObjectInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FTeleportObjectInfo& Info);
	static const class FName GetLocationCodeName(const struct FTeleportObjectInfo& Info);
	static const class FName GetLocationHiddenCondition(const struct FTeleportObjectInfo& Info);
	static bool GetPortalLocationVisible(const struct FTeleportObjectInfo& Info);
	static const class FName GetPortalSequenceArrival(const struct FTeleportObjectInfo& Info);
	static const class FName GetPortalSequenceDeparture(const struct FTeleportObjectInfo& Info);
	static const class FName GetPotralCondition(const struct FTeleportObjectInfo& Info);
	static const class FName GetProb(const struct FTeleportObjectInfo& Info);
	static ELStargazerType GetStargazerType(const struct FTeleportObjectInfo& Info);
	static const class FName GetTalkerCodeName(const struct FTeleportObjectInfo& Info);
	static ELTeleportType GetTeleportType(const struct FTeleportObjectInfo& Info);
	static bool GetTorsioncoilActivate(const struct FTeleportObjectInfo& Info);
	static int32 GetTorsioncoilCategory(const struct FTeleportObjectInfo& Info);
	static int32 GetTorsioncoilSet(const struct FTeleportObjectInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportObjectInfoFuncLibrary">();
	}
	static class UTeleportObjectInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportObjectInfoFuncLibrary>();
	}
};
static_assert(alignof(UTeleportObjectInfoFuncLibrary) == 0x000008, "Wrong alignment on UTeleportObjectInfoFuncLibrary");
static_assert(sizeof(UTeleportObjectInfoFuncLibrary) == 0x000028, "Wrong size on UTeleportObjectInfoFuncLibrary");

// Class ProjectPContentInfo.TeleportObjectInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTeleportObjectInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetCommandArrival(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetCommandDeparture(const struct FTeleportObjectInfoPtr& Ptr);
	static class FString GetConditionFailMsg(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetConditionFailMsgCn(const struct FTeleportObjectInfoPtr& Ptr);
	static class FText GetConditionFailMsgLocalize(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetConditionLocationVisible(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetExitPortal(const struct FTeleportObjectInfoPtr& Ptr);
	static class FString GetLoadingCharpter(const struct FTeleportObjectInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetLoadingImage(const struct FTeleportObjectInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FTeleportObjectInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetLocationCodeName(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetLocationHiddenCondition(const struct FTeleportObjectInfoPtr& Ptr);
	static bool GetPortalLocationVisible(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetPortalSequenceArrival(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetPortalSequenceDeparture(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetPotralCondition(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetProb(const struct FTeleportObjectInfoPtr& Ptr);
	static ELStargazerType GetStargazerType(const struct FTeleportObjectInfoPtr& Ptr);
	static const class FName GetTalkerCodeName(const struct FTeleportObjectInfoPtr& Ptr);
	static ELTeleportType GetTeleportType(const struct FTeleportObjectInfoPtr& Ptr);
	static bool GetTorsioncoilActivate(const struct FTeleportObjectInfoPtr& Ptr);
	static int32 GetTorsioncoilCategory(const struct FTeleportObjectInfoPtr& Ptr);
	static int32 GetTorsioncoilSet(const struct FTeleportObjectInfoPtr& Ptr);
	static bool IsValid(const struct FTeleportObjectInfoPtr& Ptr);
	static void IsValidBranch(const struct FTeleportObjectInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportObjectInfoPtrFuncLibrary">();
	}
	static class UTeleportObjectInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportObjectInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UTeleportObjectInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UTeleportObjectInfoPtrFuncLibrary");
static_assert(sizeof(UTeleportObjectInfoPtrFuncLibrary) == 0x000028, "Wrong size on UTeleportObjectInfoPtrFuncLibrary");

// Class ProjectPContentInfo.TeleportObjectInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UTeleportObjectInfoAsset final : public UContentInfoAsset
{
public:
	struct FTeleportObjectInfoDB                  ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FTeleportObjectInfoPtr FindTeleportObjectInfoByNameBP(class FName CodeName);
	static const TArray<struct FTeleportObjectInfo> GetTeleportObjectInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportObjectInfoAsset">();
	}
	static class UTeleportObjectInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportObjectInfoAsset>();
	}
};
static_assert(alignof(UTeleportObjectInfoAsset) == 0x000010, "Wrong alignment on UTeleportObjectInfoAsset");
static_assert(sizeof(UTeleportObjectInfoAsset) == 0x000120, "Wrong size on UTeleportObjectInfoAsset");
static_assert(offsetof(UTeleportObjectInfoAsset, ContentInfoDB) == 0x000078, "Member 'UTeleportObjectInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.TitleSetInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTitleSetInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FTitleSetInfo& Info);
	static const class FName GetOpenLevel(const struct FTitleSetInfo& Info);
	static int32 GetPriority(const struct FTitleSetInfo& Info);
	static const class FName GetSetCondition(const struct FTitleSetInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleSetInfoFuncLibrary">();
	}
	static class UTitleSetInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleSetInfoFuncLibrary>();
	}
};
static_assert(alignof(UTitleSetInfoFuncLibrary) == 0x000008, "Wrong alignment on UTitleSetInfoFuncLibrary");
static_assert(sizeof(UTitleSetInfoFuncLibrary) == 0x000028, "Wrong size on UTitleSetInfoFuncLibrary");

// Class ProjectPContentInfo.TitleSetInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTitleSetInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FTitleSetInfoPtr& Ptr);
	static const class FName GetOpenLevel(const struct FTitleSetInfoPtr& Ptr);
	static int32 GetPriority(const struct FTitleSetInfoPtr& Ptr);
	static const class FName GetSetCondition(const struct FTitleSetInfoPtr& Ptr);
	static bool IsValid(const struct FTitleSetInfoPtr& Ptr);
	static void IsValidBranch(const struct FTitleSetInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleSetInfoPtrFuncLibrary">();
	}
	static class UTitleSetInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleSetInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UTitleSetInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UTitleSetInfoPtrFuncLibrary");
static_assert(sizeof(UTitleSetInfoPtrFuncLibrary) == 0x000028, "Wrong size on UTitleSetInfoPtrFuncLibrary");

// Class ProjectPContentInfo.TitleInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UTitleInfoAsset final : public UContentInfoAsset
{
public:
	struct FTitleInfoDB                           ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FTitleSetInfoPtr FindTitleSetInfoByNameBP(class FName CodeName);
	static const TArray<struct FTitleSetInfo> GetTitleSetInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TitleInfoAsset">();
	}
	static class UTitleInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTitleInfoAsset>();
	}
};
static_assert(alignof(UTitleInfoAsset) == 0x000010, "Wrong alignment on UTitleInfoAsset");
static_assert(sizeof(UTitleInfoAsset) == 0x000120, "Wrong size on UTitleInfoAsset");
static_assert(offsetof(UTitleInfoAsset, ContentInfoDB) == 0x000078, "Member 'UTitleInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.TutorialInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTutorialInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAfterCommandExec(const struct FTutorialInfo& Info);
	static bool GetBattlePending(const struct FTutorialInfo& Info);
	static const class FName GetCodeName(const struct FTutorialInfo& Info);
	static int32 GetCooltimeGroup(const struct FTutorialInfo& Info);
	static bool GetDefaultCooltimeApplied(const struct FTutorialInfo& Info);
	static const TArray<struct FGeneralCallBackEventInfo> GetEndTriggerArray(const struct FTutorialInfo& Info);
	static bool GetGamePause(const struct FTutorialInfo& Info);
	static const TSoftObjectPtr<class UObject> GetImage(const struct FTutorialInfo& Info);
	static int32 GetListIndex(const struct FTutorialInfo& Info);
	static bool GetListOn(const struct FTutorialInfo& Info);
	static ELTutorialListOnConditionType GetListOnCondition(const struct FTutorialInfo& Info);
	static class FString GetLocalTextDescription(const struct FTutorialInfo& Info);
	static const class FName GetLocalTextDescriptionCn(const struct FTutorialInfo& Info);
	static class FText GetLocalTextDescriptionLocalize(const struct FTutorialInfo& Info);
	static class FString GetLocalTextTitle(const struct FTutorialInfo& Info);
	static const class FName GetLocalTextTitleCn(const struct FTutorialInfo& Info);
	static class FText GetLocalTextTitleLocalize(const struct FTutorialInfo& Info);
	static const class FName GetOpenUi(const struct FTutorialInfo& Info);
	static int32 GetPlayCount(const struct FTutorialInfo& Info);
	static ELTutorialPlayCountAssignType GetPlayCountAssign(const struct FTutorialInfo& Info);
	static const TArray<struct FGeneralCallBackEventInfo> GetPlayCountAssignTriggerArray(const struct FTutorialInfo& Info);
	static float GetPlayCountCooltime(const struct FTutorialInfo& Info);
	static const class FName GetPrecedentTutorial(const struct FTutorialInfo& Info);
	static int32 GetPriority(const struct FTutorialInfo& Info);
	static bool GetPriorityPending(const struct FTutorialInfo& Info);
	static const TArray<struct FGeneralConditionInfo> GetStartConditionArray(const struct FTutorialInfo& Info);
	static const TArray<struct FGeneralConditionInfo> GetStartConditionOrArray(const struct FTutorialInfo& Info);
	static float GetStartDelayTime(const struct FTutorialInfo& Info);
	static const TArray<struct FGeneralCallBackEventInfo> GetStartTriggerArray(const struct FTutorialInfo& Info);
	static int32 GetStep(const struct FTutorialInfo& Info);
	static float GetWidgetTime(const struct FTutorialInfo& Info);
	static ELTutorialWidgetType GetWidgetType(const struct FTutorialInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialInfoFuncLibrary">();
	}
	static class UTutorialInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialInfoFuncLibrary>();
	}
};
static_assert(alignof(UTutorialInfoFuncLibrary) == 0x000008, "Wrong alignment on UTutorialInfoFuncLibrary");
static_assert(sizeof(UTutorialInfoFuncLibrary) == 0x000028, "Wrong size on UTutorialInfoFuncLibrary");

// Class ProjectPContentInfo.TutorialInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UTutorialInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAfterCommandExec(const struct FTutorialInfoPtr& Ptr);
	static bool GetBattlePending(const struct FTutorialInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FTutorialInfoPtr& Ptr);
	static int32 GetCooltimeGroup(const struct FTutorialInfoPtr& Ptr);
	static bool GetDefaultCooltimeApplied(const struct FTutorialInfoPtr& Ptr);
	static const TArray<struct FGeneralCallBackEventInfo> GetEndTriggerArray(const struct FTutorialInfoPtr& Ptr);
	static bool GetGamePause(const struct FTutorialInfoPtr& Ptr);
	static const TSoftObjectPtr<class UObject> GetImage(const struct FTutorialInfoPtr& Ptr);
	static int32 GetListIndex(const struct FTutorialInfoPtr& Ptr);
	static bool GetListOn(const struct FTutorialInfoPtr& Ptr);
	static ELTutorialListOnConditionType GetListOnCondition(const struct FTutorialInfoPtr& Ptr);
	static class FString GetLocalTextDescription(const struct FTutorialInfoPtr& Ptr);
	static const class FName GetLocalTextDescriptionCn(const struct FTutorialInfoPtr& Ptr);
	static class FText GetLocalTextDescriptionLocalize(const struct FTutorialInfoPtr& Ptr);
	static class FString GetLocalTextTitle(const struct FTutorialInfoPtr& Ptr);
	static const class FName GetLocalTextTitleCn(const struct FTutorialInfoPtr& Ptr);
	static class FText GetLocalTextTitleLocalize(const struct FTutorialInfoPtr& Ptr);
	static const class FName GetOpenUi(const struct FTutorialInfoPtr& Ptr);
	static int32 GetPlayCount(const struct FTutorialInfoPtr& Ptr);
	static ELTutorialPlayCountAssignType GetPlayCountAssign(const struct FTutorialInfoPtr& Ptr);
	static const TArray<struct FGeneralCallBackEventInfo> GetPlayCountAssignTriggerArray(const struct FTutorialInfoPtr& Ptr);
	static float GetPlayCountCooltime(const struct FTutorialInfoPtr& Ptr);
	static const class FName GetPrecedentTutorial(const struct FTutorialInfoPtr& Ptr);
	static int32 GetPriority(const struct FTutorialInfoPtr& Ptr);
	static bool GetPriorityPending(const struct FTutorialInfoPtr& Ptr);
	static const TArray<struct FGeneralConditionInfo> GetStartConditionArray(const struct FTutorialInfoPtr& Ptr);
	static const TArray<struct FGeneralConditionInfo> GetStartConditionOrArray(const struct FTutorialInfoPtr& Ptr);
	static float GetStartDelayTime(const struct FTutorialInfoPtr& Ptr);
	static const TArray<struct FGeneralCallBackEventInfo> GetStartTriggerArray(const struct FTutorialInfoPtr& Ptr);
	static int32 GetStep(const struct FTutorialInfoPtr& Ptr);
	static float GetWidgetTime(const struct FTutorialInfoPtr& Ptr);
	static ELTutorialWidgetType GetWidgetType(const struct FTutorialInfoPtr& Ptr);
	static bool IsValid(const struct FTutorialInfoPtr& Ptr);
	static void IsValidBranch(const struct FTutorialInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialInfoPtrFuncLibrary">();
	}
	static class UTutorialInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UTutorialInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UTutorialInfoPtrFuncLibrary");
static_assert(sizeof(UTutorialInfoPtrFuncLibrary) == 0x000028, "Wrong size on UTutorialInfoPtrFuncLibrary");

// Class ProjectPContentInfo.TutorialInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UTutorialInfoAsset final : public UContentInfoAsset
{
public:
	struct FTutorialInfoDB                        ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FTutorialInfo> GetTutorialInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialInfoAsset">();
	}
	static class UTutorialInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialInfoAsset>();
	}
};
static_assert(alignof(UTutorialInfoAsset) == 0x000010, "Wrong alignment on UTutorialInfoAsset");
static_assert(sizeof(UTutorialInfoAsset) == 0x0000D0, "Wrong size on UTutorialInfoAsset");
static_assert(offsetof(UTutorialInfoAsset, ContentInfoDB) == 0x000078, "Member 'UTutorialInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.WeaponAnimStateInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeaponAnimStateInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FWeaponAnimStateInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimStateInfoFuncLibrary">();
	}
	static class UWeaponAnimStateInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimStateInfoFuncLibrary>();
	}
};
static_assert(alignof(UWeaponAnimStateInfoFuncLibrary) == 0x000008, "Wrong alignment on UWeaponAnimStateInfoFuncLibrary");
static_assert(sizeof(UWeaponAnimStateInfoFuncLibrary) == 0x000028, "Wrong size on UWeaponAnimStateInfoFuncLibrary");

// Class ProjectPContentInfo.WeaponAnimStateInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeaponAnimStateInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FWeaponAnimStateInfoPtr& Ptr);
	static bool IsValid(const struct FWeaponAnimStateInfoPtr& Ptr);
	static void IsValidBranch(const struct FWeaponAnimStateInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimStateInfoPtrFuncLibrary">();
	}
	static class UWeaponAnimStateInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimStateInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWeaponAnimStateInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWeaponAnimStateInfoPtrFuncLibrary");
static_assert(sizeof(UWeaponAnimStateInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWeaponAnimStateInfoPtrFuncLibrary");

// Class ProjectPContentInfo.WeaponInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UWeaponInfoAsset final : public UContentInfoAsset
{
public:
	struct FWeaponInfoDB                          ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FWeaponAnimStateInfoPtr FindWeaponAnimStateInfoByNameBP(class FName CodeName);
	static const TArray<struct FWeaponAnimStateInfo> GetWeaponAnimStateInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponInfoAsset">();
	}
	static class UWeaponInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponInfoAsset>();
	}
};
static_assert(alignof(UWeaponInfoAsset) == 0x000010, "Wrong alignment on UWeaponInfoAsset");
static_assert(sizeof(UWeaponInfoAsset) == 0x000120, "Wrong size on UWeaponInfoAsset");
static_assert(offsetof(UWeaponInfoAsset, ContentInfoDB) == 0x000078, "Member 'UWeaponInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.WeatherInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeatherInfoFuncLibrary final : public UObject
{
public:
	static int32 GetChangeTime(const struct FWeatherInfo& Info);
	static const class FName GetCodeName(const struct FWeatherInfo& Info);
	static ELLightScenarioType GetLightScenarioType(const struct FWeatherInfo& Info);
	static class FString GetLocalTextName(const struct FWeatherInfo& Info);
	static const class FName GetLocalTextNameCn(const struct FWeatherInfo& Info);
	static class FText GetLocalTextNameLocalize(const struct FWeatherInfo& Info);
	static ELTimeZoneType GetTimeZoneType(const struct FWeatherInfo& Info);
	static ELWeatherType GetWeatherType(const struct FWeatherInfo& Info);
	static ELWorldZoneType GetWorldZoneType(const struct FWeatherInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherInfoFuncLibrary">();
	}
	static class UWeatherInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherInfoFuncLibrary>();
	}
};
static_assert(alignof(UWeatherInfoFuncLibrary) == 0x000008, "Wrong alignment on UWeatherInfoFuncLibrary");
static_assert(sizeof(UWeatherInfoFuncLibrary) == 0x000028, "Wrong size on UWeatherInfoFuncLibrary");

// Class ProjectPContentInfo.WeatherInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeatherInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetChangeTime(const struct FWeatherInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FWeatherInfoPtr& Ptr);
	static ELLightScenarioType GetLightScenarioType(const struct FWeatherInfoPtr& Ptr);
	static class FString GetLocalTextName(const struct FWeatherInfoPtr& Ptr);
	static const class FName GetLocalTextNameCn(const struct FWeatherInfoPtr& Ptr);
	static class FText GetLocalTextNameLocalize(const struct FWeatherInfoPtr& Ptr);
	static ELTimeZoneType GetTimeZoneType(const struct FWeatherInfoPtr& Ptr);
	static ELWeatherType GetWeatherType(const struct FWeatherInfoPtr& Ptr);
	static ELWorldZoneType GetWorldZoneType(const struct FWeatherInfoPtr& Ptr);
	static bool IsValid(const struct FWeatherInfoPtr& Ptr);
	static void IsValidBranch(const struct FWeatherInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherInfoPtrFuncLibrary">();
	}
	static class UWeatherInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWeatherInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWeatherInfoPtrFuncLibrary");
static_assert(sizeof(UWeatherInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWeatherInfoPtrFuncLibrary");

// Class ProjectPContentInfo.WeatherChangeEventInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeatherChangeEventInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetChangeCondition(const struct FWeatherChangeEventInfo& Info);
	static const class FName GetCodeName(const struct FWeatherChangeEventInfo& Info);
	static const class FName GetMovePersistentLevel(const struct FWeatherChangeEventInfo& Info);
	static const class FName GetNextWeather(const struct FWeatherChangeEventInfo& Info);
	static const class FName GetPrevWeather(const struct FWeatherChangeEventInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherChangeEventInfoFuncLibrary">();
	}
	static class UWeatherChangeEventInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherChangeEventInfoFuncLibrary>();
	}
};
static_assert(alignof(UWeatherChangeEventInfoFuncLibrary) == 0x000008, "Wrong alignment on UWeatherChangeEventInfoFuncLibrary");
static_assert(sizeof(UWeatherChangeEventInfoFuncLibrary) == 0x000028, "Wrong size on UWeatherChangeEventInfoFuncLibrary");

// Class ProjectPContentInfo.WeatherChangeEventInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeatherChangeEventInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetChangeCondition(const struct FWeatherChangeEventInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FWeatherChangeEventInfoPtr& Ptr);
	static const class FName GetMovePersistentLevel(const struct FWeatherChangeEventInfoPtr& Ptr);
	static const class FName GetNextWeather(const struct FWeatherChangeEventInfoPtr& Ptr);
	static const class FName GetPrevWeather(const struct FWeatherChangeEventInfoPtr& Ptr);
	static bool IsValid(const struct FWeatherChangeEventInfoPtr& Ptr);
	static void IsValidBranch(const struct FWeatherChangeEventInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherChangeEventInfoPtrFuncLibrary">();
	}
	static class UWeatherChangeEventInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherChangeEventInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWeatherChangeEventInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWeatherChangeEventInfoPtrFuncLibrary");
static_assert(sizeof(UWeatherChangeEventInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWeatherChangeEventInfoPtrFuncLibrary");

// Class ProjectPContentInfo.WeatherInfoAsset
// 0x0108 (0x0180 - 0x0078)
class alignas(0x10) UWeatherInfoAsset final : public UContentInfoAsset
{
public:
	struct FWeatherInfoDB                         ContentInfoDB;                                     // 0x0078(0x0100)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FWeatherChangeEventInfoPtr FindWeatherChangeEventInfoByNameBP(class FName CodeName);
	static struct FWeatherInfoPtr FindWeatherInfoByNameBP(class FName CodeName);
	static const TArray<struct FWeatherChangeEventInfo> GetWeatherChangeEventInfoArrayBP();
	static const TArray<struct FWeatherInfo> GetWeatherInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherInfoAsset">();
	}
	static class UWeatherInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherInfoAsset>();
	}
};
static_assert(alignof(UWeatherInfoAsset) == 0x000010, "Wrong alignment on UWeatherInfoAsset");
static_assert(sizeof(UWeatherInfoAsset) == 0x000180, "Wrong size on UWeatherInfoAsset");
static_assert(offsetof(UWeatherInfoAsset, ContentInfoDB) == 0x000078, "Member 'UWeatherInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.WeightPenaltyInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeightPenaltyInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetAdvantageAbnormalstate(const struct FWeightPenaltyInfo& Info);
	static const class FName GetGroupCodeName(const struct FWeightPenaltyInfo& Info);
	static const class FName GetIndex(const struct FWeightPenaltyInfo& Info);
	static const class FName GetPanaltyAbnormalstate(const struct FWeightPenaltyInfo& Info);
	static int32 GetRunSpeedBack(const struct FWeightPenaltyInfo& Info);
	static int32 GetRunSpeedFront(const struct FWeightPenaltyInfo& Info);
	static int32 GetRunSpeedSide(const struct FWeightPenaltyInfo& Info);
	static int32 GetSprintSpeed(const struct FWeightPenaltyInfo& Info);
	static int32 GetWalkSpeedBack(const struct FWeightPenaltyInfo& Info);
	static int32 GetWalkSpeedFront(const struct FWeightPenaltyInfo& Info);
	static int32 GetWalkSpeedSide(const struct FWeightPenaltyInfo& Info);
	static const class FName GetWaringMsg(const struct FWeightPenaltyInfo& Info);
	static float GetWeightRateUpper(const struct FWeightPenaltyInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightPenaltyInfoFuncLibrary">();
	}
	static class UWeightPenaltyInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightPenaltyInfoFuncLibrary>();
	}
};
static_assert(alignof(UWeightPenaltyInfoFuncLibrary) == 0x000008, "Wrong alignment on UWeightPenaltyInfoFuncLibrary");
static_assert(sizeof(UWeightPenaltyInfoFuncLibrary) == 0x000028, "Wrong size on UWeightPenaltyInfoFuncLibrary");

// Class ProjectPContentInfo.WeightPenaltyInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWeightPenaltyInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetAdvantageAbnormalstate(const struct FWeightPenaltyInfoPtr& Ptr);
	static const class FName GetGroupCodeName(const struct FWeightPenaltyInfoPtr& Ptr);
	static const class FName GetIndex(const struct FWeightPenaltyInfoPtr& Ptr);
	static const class FName GetPanaltyAbnormalstate(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetRunSpeedBack(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetRunSpeedFront(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetRunSpeedSide(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetSprintSpeed(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetWalkSpeedBack(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetWalkSpeedFront(const struct FWeightPenaltyInfoPtr& Ptr);
	static int32 GetWalkSpeedSide(const struct FWeightPenaltyInfoPtr& Ptr);
	static const class FName GetWaringMsg(const struct FWeightPenaltyInfoPtr& Ptr);
	static float GetWeightRateUpper(const struct FWeightPenaltyInfoPtr& Ptr);
	static bool IsValid(const struct FWeightPenaltyInfoPtr& Ptr);
	static void IsValidBranch(const struct FWeightPenaltyInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightPenaltyInfoPtrFuncLibrary">();
	}
	static class UWeightPenaltyInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightPenaltyInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWeightPenaltyInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWeightPenaltyInfoPtrFuncLibrary");
static_assert(sizeof(UWeightPenaltyInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWeightPenaltyInfoPtrFuncLibrary");

// Class ProjectPContentInfo.WeightPenaltyInfoAsset
// 0x0058 (0x00D0 - 0x0078)
class alignas(0x10) UWeightPenaltyInfoAsset final : public UContentInfoAsset
{
public:
	struct FWeightPenaltyInfoDB                   ContentInfoDB;                                     // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FWeightPenaltyInfo> GetWeightPenaltyInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightPenaltyInfoAsset">();
	}
	static class UWeightPenaltyInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightPenaltyInfoAsset>();
	}
};
static_assert(alignof(UWeightPenaltyInfoAsset) == 0x000010, "Wrong alignment on UWeightPenaltyInfoAsset");
static_assert(sizeof(UWeightPenaltyInfoAsset) == 0x0000D0, "Wrong size on UWeightPenaltyInfoAsset");
static_assert(offsetof(UWeightPenaltyInfoAsset, ContentInfoDB) == 0x000078, "Member 'UWeightPenaltyInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.WorldEventInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldEventInfoFuncLibrary final : public UObject
{
public:
	static int32 GetCallbackCount(const struct FWorldEventInfo& Info);
	static class FString GetCallbackEventParam(const struct FWorldEventInfo& Info);
	static class FString GetCallbackEventParam2(const struct FWorldEventInfo& Info);
	static ELCallBackEventType GetCallbackEventType(const struct FWorldEventInfo& Info);
	static const class FName GetCodeName(const struct FWorldEventInfo& Info);
	static const class FName GetCommandsetCodeName(const struct FWorldEventInfo& Info);
	static const class FName GetConditionCodename(const struct FWorldEventInfo& Info);
	static int32 GetDetailIndex(const struct FWorldEventInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldEventInfoFuncLibrary">();
	}
	static class UWorldEventInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldEventInfoFuncLibrary>();
	}
};
static_assert(alignof(UWorldEventInfoFuncLibrary) == 0x000008, "Wrong alignment on UWorldEventInfoFuncLibrary");
static_assert(sizeof(UWorldEventInfoFuncLibrary) == 0x000028, "Wrong size on UWorldEventInfoFuncLibrary");

// Class ProjectPContentInfo.WorldEventInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldEventInfoPtrFuncLibrary final : public UObject
{
public:
	static int32 GetCallbackCount(const struct FWorldEventInfoPtr& Ptr);
	static class FString GetCallbackEventParam(const struct FWorldEventInfoPtr& Ptr);
	static class FString GetCallbackEventParam2(const struct FWorldEventInfoPtr& Ptr);
	static ELCallBackEventType GetCallbackEventType(const struct FWorldEventInfoPtr& Ptr);
	static const class FName GetCodeName(const struct FWorldEventInfoPtr& Ptr);
	static const class FName GetCommandsetCodeName(const struct FWorldEventInfoPtr& Ptr);
	static const class FName GetConditionCodename(const struct FWorldEventInfoPtr& Ptr);
	static int32 GetDetailIndex(const struct FWorldEventInfoPtr& Ptr);
	static bool IsValid(const struct FWorldEventInfoPtr& Ptr);
	static void IsValidBranch(const struct FWorldEventInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldEventInfoPtrFuncLibrary">();
	}
	static class UWorldEventInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldEventInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWorldEventInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWorldEventInfoPtrFuncLibrary");
static_assert(sizeof(UWorldEventInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWorldEventInfoPtrFuncLibrary");

// Class ProjectPContentInfo.DefaultPCWorldEventListInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDefaultPCWorldEventListInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetWorldEventCodeName(const struct FDefaultPCWorldEventListInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultPCWorldEventListInfoFuncLibrary">();
	}
	static class UDefaultPCWorldEventListInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultPCWorldEventListInfoFuncLibrary>();
	}
};
static_assert(alignof(UDefaultPCWorldEventListInfoFuncLibrary) == 0x000008, "Wrong alignment on UDefaultPCWorldEventListInfoFuncLibrary");
static_assert(sizeof(UDefaultPCWorldEventListInfoFuncLibrary) == 0x000028, "Wrong size on UDefaultPCWorldEventListInfoFuncLibrary");

// Class ProjectPContentInfo.DefaultPCWorldEventListInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UDefaultPCWorldEventListInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetWorldEventCodeName(const struct FDefaultPCWorldEventListInfoPtr& Ptr);
	static bool IsValid(const struct FDefaultPCWorldEventListInfoPtr& Ptr);
	static void IsValidBranch(const struct FDefaultPCWorldEventListInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultPCWorldEventListInfoPtrFuncLibrary">();
	}
	static class UDefaultPCWorldEventListInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultPCWorldEventListInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UDefaultPCWorldEventListInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UDefaultPCWorldEventListInfoPtrFuncLibrary");
static_assert(sizeof(UDefaultPCWorldEventListInfoPtrFuncLibrary) == 0x000028, "Wrong size on UDefaultPCWorldEventListInfoPtrFuncLibrary");

// Class ProjectPContentInfo.WorldEventInfoAsset
// 0x0068 (0x00E0 - 0x0078)
class alignas(0x10) UWorldEventInfoAsset final : public UContentInfoAsset
{
public:
	struct FWorldEventInfoDB                      ContentInfoDB;                                     // 0x0078(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const TArray<struct FDefaultPCWorldEventListInfo> GetDefault_PC_WorldEventListInfoArrayBP();
	static const TArray<struct FWorldEventInfo> GetWorldEventInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldEventInfoAsset">();
	}
	static class UWorldEventInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldEventInfoAsset>();
	}
};
static_assert(alignof(UWorldEventInfoAsset) == 0x000010, "Wrong alignment on UWorldEventInfoAsset");
static_assert(sizeof(UWorldEventInfoAsset) == 0x0000E0, "Wrong size on UWorldEventInfoAsset");
static_assert(offsetof(UWorldEventInfoAsset, ContentInfoDB) == 0x000078, "Member 'UWorldEventInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.WorldRuleInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldRuleInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FWorldRuleInfo& Info);
	static float GetToughConstant(const struct FWorldRuleInfo& Info);
	static float GetToughRestoreStopTime(const struct FWorldRuleInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldRuleInfoFuncLibrary">();
	}
	static class UWorldRuleInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldRuleInfoFuncLibrary>();
	}
};
static_assert(alignof(UWorldRuleInfoFuncLibrary) == 0x000008, "Wrong alignment on UWorldRuleInfoFuncLibrary");
static_assert(sizeof(UWorldRuleInfoFuncLibrary) == 0x000028, "Wrong size on UWorldRuleInfoFuncLibrary");

// Class ProjectPContentInfo.WorldRuleInfoPtrFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldRuleInfoPtrFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FWorldRuleInfoPtr& Ptr);
	static float GetToughConstant(const struct FWorldRuleInfoPtr& Ptr);
	static float GetToughRestoreStopTime(const struct FWorldRuleInfoPtr& Ptr);
	static bool IsValid(const struct FWorldRuleInfoPtr& Ptr);
	static void IsValidBranch(const struct FWorldRuleInfoPtr& Ptr, EContentInfoExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldRuleInfoPtrFuncLibrary">();
	}
	static class UWorldRuleInfoPtrFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldRuleInfoPtrFuncLibrary>();
	}
};
static_assert(alignof(UWorldRuleInfoPtrFuncLibrary) == 0x000008, "Wrong alignment on UWorldRuleInfoPtrFuncLibrary");
static_assert(sizeof(UWorldRuleInfoPtrFuncLibrary) == 0x000028, "Wrong size on UWorldRuleInfoPtrFuncLibrary");

// Class ProjectPContentInfo.WorldRuleInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UWorldRuleInfoAsset final : public UContentInfoAsset
{
public:
	struct FWorldRuleInfoDB                       ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FWorldRuleInfoPtr FindWorldRuleInfoByNameBP(class FName CodeName);
	static const TArray<struct FWorldRuleInfo> GetWorldRuleInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldRuleInfoAsset">();
	}
	static class UWorldRuleInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldRuleInfoAsset>();
	}
};
static_assert(alignof(UWorldRuleInfoAsset) == 0x000010, "Wrong alignment on UWorldRuleInfoAsset");
static_assert(sizeof(UWorldRuleInfoAsset) == 0x000120, "Wrong size on UWorldRuleInfoAsset");
static_assert(offsetof(UWorldRuleInfoAsset, ContentInfoDB) == 0x000078, "Member 'UWorldRuleInfoAsset::ContentInfoDB' has a wrong offset!");

// Class ProjectPContentInfo.WorldZoneInfoFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorldZoneInfoFuncLibrary final : public UObject
{
public:
	static const class FName GetCodeName(const struct FWorldZoneInfo& Info);
	static const class FName GetLightScenarioAm(const struct FWorldZoneInfo& Info);
	static const class FName GetLightScenarioPm(const struct FWorldZoneInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldZoneInfoFuncLibrary">();
	}
	static class UWorldZoneInfoFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldZoneInfoFuncLibrary>();
	}
};
static_assert(alignof(UWorldZoneInfoFuncLibrary) == 0x000008, "Wrong alignment on UWorldZoneInfoFuncLibrary");
static_assert(sizeof(UWorldZoneInfoFuncLibrary) == 0x000028, "Wrong size on UWorldZoneInfoFuncLibrary");

// Class ProjectPContentInfo.WorldZoneInfoAsset
// 0x00A8 (0x0120 - 0x0078)
class alignas(0x10) UWorldZoneInfoAsset final : public UContentInfoAsset
{
public:
	struct FWorldZoneInfoDB                       ContentInfoDB;                                     // 0x0078(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FWorldZoneInfoPtr FindWorldZoneInfoByNameBP(class FName CodeName);
	static const TArray<struct FWorldZoneInfo> GetWorldZoneInfoArrayBP();
	static void StaticParseInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldZoneInfoAsset">();
	}
	static class UWorldZoneInfoAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldZoneInfoAsset>();
	}
};
static_assert(alignof(UWorldZoneInfoAsset) == 0x000010, "Wrong alignment on UWorldZoneInfoAsset");
static_assert(sizeof(UWorldZoneInfoAsset) == 0x000120, "Wrong size on UWorldZoneInfoAsset");
static_assert(offsetof(UWorldZoneInfoAsset, ContentInfoDB) == 0x000078, "Member 'UWorldZoneInfoAsset::ContentInfoDB' has a wrong offset!");

}

