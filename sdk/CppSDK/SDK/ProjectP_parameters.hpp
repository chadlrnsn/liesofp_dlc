#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ProjectP

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "ProjectP_structs.hpp"
#include "ProjectPContentInfo_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "UMG_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK::Params
{

// Function ProjectP.LWeaponAnimInstance.ChangeAnimState
// 0x0008 (0x0008 - 0x0000)
struct LWeaponAnimInstance_ChangeAnimState final
{
public:
	class FName                                   AnimState_0;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponAnimInstance_ChangeAnimState) == 0x000004, "Wrong alignment on LWeaponAnimInstance_ChangeAnimState");
static_assert(sizeof(LWeaponAnimInstance_ChangeAnimState) == 0x000008, "Wrong size on LWeaponAnimInstance_ChangeAnimState");
static_assert(offsetof(LWeaponAnimInstance_ChangeAnimState, AnimState_0) == 0x000000, "Member 'LWeaponAnimInstance_ChangeAnimState::AnimState_0' has a wrong offset!");

// Function ProjectP.LPropSpot.OnChangePropStateFromLevelObject
// 0x0004 (0x0004 - 0x0000)
struct LPropSpot_OnChangePropStateFromLevelObject final
{
public:
	int32                                         TargetState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropSpot_OnChangePropStateFromLevelObject) == 0x000004, "Wrong alignment on LPropSpot_OnChangePropStateFromLevelObject");
static_assert(sizeof(LPropSpot_OnChangePropStateFromLevelObject) == 0x000004, "Wrong size on LPropSpot_OnChangePropStateFromLevelObject");
static_assert(offsetof(LPropSpot_OnChangePropStateFromLevelObject, TargetState) == 0x000000, "Member 'LPropSpot_OnChangePropStateFromLevelObject::TargetState' has a wrong offset!");

// Function ProjectP.LPropSpot.OnCheckLinkedNpcSpotFromLevelObject
// 0x0001 (0x0001 - 0x0000)
struct LPropSpot_OnCheckLinkedNpcSpotFromLevelObject final
{
public:
	ELLinkedNpcSpotExecuteType                    ExecuteType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropSpot_OnCheckLinkedNpcSpotFromLevelObject) == 0x000001, "Wrong alignment on LPropSpot_OnCheckLinkedNpcSpotFromLevelObject");
static_assert(sizeof(LPropSpot_OnCheckLinkedNpcSpotFromLevelObject) == 0x000001, "Wrong size on LPropSpot_OnCheckLinkedNpcSpotFromLevelObject");
static_assert(offsetof(LPropSpot_OnCheckLinkedNpcSpotFromLevelObject, ExecuteType) == 0x000000, "Member 'LPropSpot_OnCheckLinkedNpcSpotFromLevelObject::ExecuteType' has a wrong offset!");

// Function ProjectP.LPropSpot.OnComponentBeginOverlapPropVolume
// 0x00A8 (0x00A8 - 0x0000)
struct LPropSpot_OnComponentBeginOverlapPropVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropSpot_OnComponentBeginOverlapPropVolume) == 0x000008, "Wrong alignment on LPropSpot_OnComponentBeginOverlapPropVolume");
static_assert(sizeof(LPropSpot_OnComponentBeginOverlapPropVolume) == 0x0000A8, "Wrong size on LPropSpot_OnComponentBeginOverlapPropVolume");
static_assert(offsetof(LPropSpot_OnComponentBeginOverlapPropVolume, OverlappedComponent) == 0x000000, "Member 'LPropSpot_OnComponentBeginOverlapPropVolume::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentBeginOverlapPropVolume, OtherActor) == 0x000008, "Member 'LPropSpot_OnComponentBeginOverlapPropVolume::OtherActor' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentBeginOverlapPropVolume, OtherComp) == 0x000010, "Member 'LPropSpot_OnComponentBeginOverlapPropVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentBeginOverlapPropVolume, OtherBodyIndex) == 0x000018, "Member 'LPropSpot_OnComponentBeginOverlapPropVolume::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentBeginOverlapPropVolume, bFromSweep) == 0x00001C, "Member 'LPropSpot_OnComponentBeginOverlapPropVolume::bFromSweep' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentBeginOverlapPropVolume, SweepResult) == 0x000020, "Member 'LPropSpot_OnComponentBeginOverlapPropVolume::SweepResult' has a wrong offset!");

// Function ProjectP.LPropSpot.OnComponentEndOverlapPropVolume
// 0x0020 (0x0020 - 0x0000)
struct LPropSpot_OnComponentEndOverlapPropVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPropSpot_OnComponentEndOverlapPropVolume) == 0x000008, "Wrong alignment on LPropSpot_OnComponentEndOverlapPropVolume");
static_assert(sizeof(LPropSpot_OnComponentEndOverlapPropVolume) == 0x000020, "Wrong size on LPropSpot_OnComponentEndOverlapPropVolume");
static_assert(offsetof(LPropSpot_OnComponentEndOverlapPropVolume, OverlappedComponent) == 0x000000, "Member 'LPropSpot_OnComponentEndOverlapPropVolume::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentEndOverlapPropVolume, OtherActor) == 0x000008, "Member 'LPropSpot_OnComponentEndOverlapPropVolume::OtherActor' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentEndOverlapPropVolume, OtherComp) == 0x000010, "Member 'LPropSpot_OnComponentEndOverlapPropVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropSpot_OnComponentEndOverlapPropVolume, OtherBodyIndex) == 0x000018, "Member 'LPropSpot_OnComponentEndOverlapPropVolume::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LBossRoomSpot.OnDeadSpawnNpc
// 0x0008 (0x0008 - 0x0000)
struct LBossRoomSpot_OnDeadSpawnNpc final
{
public:
	class ALNPCSpot*                              TargetNpcSpot;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBossRoomSpot_OnDeadSpawnNpc) == 0x000008, "Wrong alignment on LBossRoomSpot_OnDeadSpawnNpc");
static_assert(sizeof(LBossRoomSpot_OnDeadSpawnNpc) == 0x000008, "Wrong size on LBossRoomSpot_OnDeadSpawnNpc");
static_assert(offsetof(LBossRoomSpot_OnDeadSpawnNpc, TargetNpcSpot) == 0x000000, "Member 'LBossRoomSpot_OnDeadSpawnNpc::TargetNpcSpot' has a wrong offset!");

// Function ProjectP.LBossRoomSpot.OnSpawnedActor
// 0x0008 (0x0008 - 0x0000)
struct LBossRoomSpot_OnSpawnedActor final
{
public:
	class ALPropSpot*                             TargetPropSpot;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBossRoomSpot_OnSpawnedActor) == 0x000008, "Wrong alignment on LBossRoomSpot_OnSpawnedActor");
static_assert(sizeof(LBossRoomSpot_OnSpawnedActor) == 0x000008, "Wrong size on LBossRoomSpot_OnSpawnedActor");
static_assert(offsetof(LBossRoomSpot_OnSpawnedActor, TargetPropSpot) == 0x000000, "Member 'LBossRoomSpot_OnSpawnedActor::TargetPropSpot' has a wrong offset!");

// Function ProjectP.LDurableAbnormalBPFuncLibrary.GetInfo
// 0x0010 (0x0010 - 0x0000)
struct LDurableAbnormalBPFuncLibrary_GetInfo final
{
public:
	struct FLDurableAbnormalBPPtr                 In;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FAbnormalStateCommonInfoPtr            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDurableAbnormalBPFuncLibrary_GetInfo) == 0x000008, "Wrong alignment on LDurableAbnormalBPFuncLibrary_GetInfo");
static_assert(sizeof(LDurableAbnormalBPFuncLibrary_GetInfo) == 0x000010, "Wrong size on LDurableAbnormalBPFuncLibrary_GetInfo");
static_assert(offsetof(LDurableAbnormalBPFuncLibrary_GetInfo, In) == 0x000000, "Member 'LDurableAbnormalBPFuncLibrary_GetInfo::In' has a wrong offset!");
static_assert(offsetof(LDurableAbnormalBPFuncLibrary_GetInfo, ReturnValue) == 0x000008, "Member 'LDurableAbnormalBPFuncLibrary_GetInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LDurableAbnormalBPFuncLibrary.GetUniqueId
// 0x0010 (0x0010 - 0x0000)
struct LDurableAbnormalBPFuncLibrary_GetUniqueId final
{
public:
	struct FLDurableAbnormalBPPtr                 In;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDurableAbnormalBPFuncLibrary_GetUniqueId) == 0x000008, "Wrong alignment on LDurableAbnormalBPFuncLibrary_GetUniqueId");
static_assert(sizeof(LDurableAbnormalBPFuncLibrary_GetUniqueId) == 0x000010, "Wrong size on LDurableAbnormalBPFuncLibrary_GetUniqueId");
static_assert(offsetof(LDurableAbnormalBPFuncLibrary_GetUniqueId, In) == 0x000000, "Member 'LDurableAbnormalBPFuncLibrary_GetUniqueId::In' has a wrong offset!");
static_assert(offsetof(LDurableAbnormalBPFuncLibrary_GetUniqueId, ReturnValue) == 0x000008, "Member 'LDurableAbnormalBPFuncLibrary_GetUniqueId::ReturnValue' has a wrong offset!");

// Function ProjectP.LDurableAbnormalBPFuncLibrary.GetRemainDuration
// 0x0010 (0x0010 - 0x0000)
struct LDurableAbnormalBPFuncLibrary_GetRemainDuration final
{
public:
	struct FLDurableAbnormalBPPtr                 In;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LDurableAbnormalBPFuncLibrary_GetRemainDuration) == 0x000008, "Wrong alignment on LDurableAbnormalBPFuncLibrary_GetRemainDuration");
static_assert(sizeof(LDurableAbnormalBPFuncLibrary_GetRemainDuration) == 0x000010, "Wrong size on LDurableAbnormalBPFuncLibrary_GetRemainDuration");
static_assert(offsetof(LDurableAbnormalBPFuncLibrary_GetRemainDuration, In) == 0x000000, "Member 'LDurableAbnormalBPFuncLibrary_GetRemainDuration::In' has a wrong offset!");
static_assert(offsetof(LDurableAbnormalBPFuncLibrary_GetRemainDuration, ReturnValue) == 0x000008, "Member 'LDurableAbnormalBPFuncLibrary_GetRemainDuration::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.BuildupHitBP
// 0x001C (0x001C - 0x0000)
struct LAbnormalComponent_BuildupHitBP final
{
public:
	struct FLCalcBuildupData                      InBuildupData;                                     // 0x0000(0x001C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_BuildupHitBP) == 0x000004, "Wrong alignment on LAbnormalComponent_BuildupHitBP");
static_assert(sizeof(LAbnormalComponent_BuildupHitBP) == 0x00001C, "Wrong size on LAbnormalComponent_BuildupHitBP");
static_assert(offsetof(LAbnormalComponent_BuildupHitBP, InBuildupData) == 0x000000, "Member 'LAbnormalComponent_BuildupHitBP::InBuildupData' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.CalcDirectBuildupHitByHit
// 0x0170 (0x0170 - 0x0000)
struct LAbnormalComponent_CalcDirectBuildupHitByHit final
{
public:
	struct FLHitInfo                              InHitInfo;                                         // 0x0000(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         InSkillBuildupDamage;                              // 0x0150(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InFireBuildupDamage;                               // 0x0154(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InElectricBuildupDamage;                           // 0x0158(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InAcidBuildupDamage;                               // 0x015C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLCalcBuildupData>              ReturnValue;                                       // 0x0160(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_CalcDirectBuildupHitByHit) == 0x000008, "Wrong alignment on LAbnormalComponent_CalcDirectBuildupHitByHit");
static_assert(sizeof(LAbnormalComponent_CalcDirectBuildupHitByHit) == 0x000170, "Wrong size on LAbnormalComponent_CalcDirectBuildupHitByHit");
static_assert(offsetof(LAbnormalComponent_CalcDirectBuildupHitByHit, InHitInfo) == 0x000000, "Member 'LAbnormalComponent_CalcDirectBuildupHitByHit::InHitInfo' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_CalcDirectBuildupHitByHit, InSkillBuildupDamage) == 0x000150, "Member 'LAbnormalComponent_CalcDirectBuildupHitByHit::InSkillBuildupDamage' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_CalcDirectBuildupHitByHit, InFireBuildupDamage) == 0x000154, "Member 'LAbnormalComponent_CalcDirectBuildupHitByHit::InFireBuildupDamage' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_CalcDirectBuildupHitByHit, InElectricBuildupDamage) == 0x000158, "Member 'LAbnormalComponent_CalcDirectBuildupHitByHit::InElectricBuildupDamage' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_CalcDirectBuildupHitByHit, InAcidBuildupDamage) == 0x00015C, "Member 'LAbnormalComponent_CalcDirectBuildupHitByHit::InAcidBuildupDamage' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_CalcDirectBuildupHitByHit, ReturnValue) == 0x000160, "Member 'LAbnormalComponent_CalcDirectBuildupHitByHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.GetAppliedAbnormalMaxDurationByUniqueId
// 0x0010 (0x0010 - 0x0000)
struct LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId final
{
public:
	int64                                         InAbnormalUniqueId;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId) == 0x000008, "Wrong alignment on LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId");
static_assert(sizeof(LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId) == 0x000010, "Wrong size on LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId");
static_assert(offsetof(LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId, InAbnormalUniqueId) == 0x000000, "Member 'LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId::InAbnormalUniqueId' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.GetAppliedAbnormalRemainDurationByUniqueId
// 0x0010 (0x0010 - 0x0000)
struct LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId final
{
public:
	int64                                         InAbnormalUniqueId;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId) == 0x000008, "Wrong alignment on LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId");
static_assert(sizeof(LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId) == 0x000010, "Wrong size on LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId");
static_assert(offsetof(LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId, InAbnormalUniqueId) == 0x000000, "Member 'LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId::InAbnormalUniqueId' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.OnCaptureMoment
// 0x0030 (0x0030 - 0x0000)
struct LAbnormalComponent_OnCaptureMoment final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMomentConditionCaptureInfo            Capture;                                           // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_OnCaptureMoment) == 0x000008, "Wrong alignment on LAbnormalComponent_OnCaptureMoment");
static_assert(sizeof(LAbnormalComponent_OnCaptureMoment) == 0x000030, "Wrong size on LAbnormalComponent_OnCaptureMoment");
static_assert(offsetof(LAbnormalComponent_OnCaptureMoment, Owner) == 0x000000, "Member 'LAbnormalComponent_OnCaptureMoment::Owner' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_OnCaptureMoment, Capture) == 0x000008, "Member 'LAbnormalComponent_OnCaptureMoment::Capture' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.OnChooseOtherWeapon
// 0x0018 (0x0018 - 0x0000)
struct LAbnormalComponent_OnChooseOtherWeapon final
{
public:
	struct FLEquipItemSlot                        EquipSlot;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_OnChooseOtherWeapon) == 0x000008, "Wrong alignment on LAbnormalComponent_OnChooseOtherWeapon");
static_assert(sizeof(LAbnormalComponent_OnChooseOtherWeapon) == 0x000018, "Wrong size on LAbnormalComponent_OnChooseOtherWeapon");
static_assert(offsetof(LAbnormalComponent_OnChooseOtherWeapon, EquipSlot) == 0x000000, "Member 'LAbnormalComponent_OnChooseOtherWeapon::EquipSlot' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.OnPlayHideFX
// 0x0001 (0x0001 - 0x0000)
struct LAbnormalComponent_OnPlayHideFX final
{
public:
	bool                                          IsHide;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_OnPlayHideFX) == 0x000001, "Wrong alignment on LAbnormalComponent_OnPlayHideFX");
static_assert(sizeof(LAbnormalComponent_OnPlayHideFX) == 0x000001, "Wrong size on LAbnormalComponent_OnPlayHideFX");
static_assert(offsetof(LAbnormalComponent_OnPlayHideFX, IsHide) == 0x000000, "Member 'LAbnormalComponent_OnPlayHideFX::IsHide' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.OnRemoveAbnormalNiagaraFX
// 0x0008 (0x0008 - 0x0000)
struct LAbnormalComponent_OnRemoveAbnormalNiagaraFX final
{
public:
	class UNiagaraComponent*                      InNiagaraComp;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_OnRemoveAbnormalNiagaraFX) == 0x000008, "Wrong alignment on LAbnormalComponent_OnRemoveAbnormalNiagaraFX");
static_assert(sizeof(LAbnormalComponent_OnRemoveAbnormalNiagaraFX) == 0x000008, "Wrong size on LAbnormalComponent_OnRemoveAbnormalNiagaraFX");
static_assert(offsetof(LAbnormalComponent_OnRemoveAbnormalNiagaraFX, InNiagaraComp) == 0x000000, "Member 'LAbnormalComponent_OnRemoveAbnormalNiagaraFX::InNiagaraComp' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.OnRemoveAbnormalParticleFX
// 0x0008 (0x0008 - 0x0000)
struct LAbnormalComponent_OnRemoveAbnormalParticleFX final
{
public:
	class UParticleSystemComponent*               InParticleComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_OnRemoveAbnormalParticleFX) == 0x000008, "Wrong alignment on LAbnormalComponent_OnRemoveAbnormalParticleFX");
static_assert(sizeof(LAbnormalComponent_OnRemoveAbnormalParticleFX) == 0x000008, "Wrong size on LAbnormalComponent_OnRemoveAbnormalParticleFX");
static_assert(offsetof(LAbnormalComponent_OnRemoveAbnormalParticleFX, InParticleComp) == 0x000000, "Member 'LAbnormalComponent_OnRemoveAbnormalParticleFX::InParticleComp' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.OnSatisfiedBuffAlter
// 0x0008 (0x0008 - 0x0000)
struct LAbnormalComponent_OnSatisfiedBuffAlter final
{
public:
	struct FHumanizationBuffAlterInfoPtr          InActiveBuffAlterInfo;                             // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_OnSatisfiedBuffAlter) == 0x000008, "Wrong alignment on LAbnormalComponent_OnSatisfiedBuffAlter");
static_assert(sizeof(LAbnormalComponent_OnSatisfiedBuffAlter) == 0x000008, "Wrong size on LAbnormalComponent_OnSatisfiedBuffAlter");
static_assert(offsetof(LAbnormalComponent_OnSatisfiedBuffAlter, InActiveBuffAlterInfo) == 0x000000, "Member 'LAbnormalComponent_OnSatisfiedBuffAlter::InActiveBuffAlterInfo' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.PutOn
// 0x0018 (0x0018 - 0x0000)
struct LAbnormalComponent_PutOn final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceNewAbnormal;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_PutOn) == 0x000008, "Wrong alignment on LAbnormalComponent_PutOn");
static_assert(sizeof(LAbnormalComponent_PutOn) == 0x000018, "Wrong size on LAbnormalComponent_PutOn");
static_assert(offsetof(LAbnormalComponent_PutOn, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_PutOn::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOn, ForceNewAbnormal) == 0x000008, "Member 'LAbnormalComponent_PutOn::ForceNewAbnormal' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOn, ReturnValue) == 0x000010, "Member 'LAbnormalComponent_PutOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.PutOnByPayload
// 0x0038 (0x0038 - 0x0000)
struct LAbnormalComponent_PutOnByPayload final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAbnormalPayload                      InPayload;                                         // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_PutOnByPayload) == 0x000008, "Wrong alignment on LAbnormalComponent_PutOnByPayload");
static_assert(sizeof(LAbnormalComponent_PutOnByPayload) == 0x000038, "Wrong size on LAbnormalComponent_PutOnByPayload");
static_assert(offsetof(LAbnormalComponent_PutOnByPayload, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_PutOnByPayload::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOnByPayload, InPayload) == 0x000008, "Member 'LAbnormalComponent_PutOnByPayload::InPayload' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOnByPayload, ReturnValue) == 0x000030, "Member 'LAbnormalComponent_PutOnByPayload::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.PutOnWithInstigator
// 0x0018 (0x0018 - 0x0000)
struct LAbnormalComponent_PutOnWithInstigator final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InInstigator;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_PutOnWithInstigator) == 0x000008, "Wrong alignment on LAbnormalComponent_PutOnWithInstigator");
static_assert(sizeof(LAbnormalComponent_PutOnWithInstigator) == 0x000018, "Wrong size on LAbnormalComponent_PutOnWithInstigator");
static_assert(offsetof(LAbnormalComponent_PutOnWithInstigator, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_PutOnWithInstigator::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOnWithInstigator, InInstigator) == 0x000008, "Member 'LAbnormalComponent_PutOnWithInstigator::InInstigator' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOnWithInstigator, ReturnValue) == 0x000010, "Member 'LAbnormalComponent_PutOnWithInstigator::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.PutOnWithReason
// 0x0018 (0x0018 - 0x0000)
struct LAbnormalComponent_PutOnWithReason final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InReasonCodeName;                                  // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_PutOnWithReason) == 0x000008, "Wrong alignment on LAbnormalComponent_PutOnWithReason");
static_assert(sizeof(LAbnormalComponent_PutOnWithReason) == 0x000018, "Wrong size on LAbnormalComponent_PutOnWithReason");
static_assert(offsetof(LAbnormalComponent_PutOnWithReason, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_PutOnWithReason::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOnWithReason, InReasonCodeName) == 0x000008, "Member 'LAbnormalComponent_PutOnWithReason::InReasonCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_PutOnWithReason, ReturnValue) == 0x000010, "Member 'LAbnormalComponent_PutOnWithReason::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.TakeOff
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_TakeOff final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediately;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_TakeOff) == 0x000004, "Wrong alignment on LAbnormalComponent_TakeOff");
static_assert(sizeof(LAbnormalComponent_TakeOff) == 0x00000C, "Wrong size on LAbnormalComponent_TakeOff");
static_assert(offsetof(LAbnormalComponent_TakeOff, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_TakeOff::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOff, Immediately) == 0x000008, "Member 'LAbnormalComponent_TakeOff::Immediately' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.TakeOffAllByInstigator
// 0x0010 (0x0010 - 0x0000)
struct LAbnormalComponent_TakeOffAllByInstigator final
{
public:
	class UObject*                                InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediately;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_TakeOffAllByInstigator) == 0x000008, "Wrong alignment on LAbnormalComponent_TakeOffAllByInstigator");
static_assert(sizeof(LAbnormalComponent_TakeOffAllByInstigator) == 0x000010, "Wrong size on LAbnormalComponent_TakeOffAllByInstigator");
static_assert(offsetof(LAbnormalComponent_TakeOffAllByInstigator, InInstigator) == 0x000000, "Member 'LAbnormalComponent_TakeOffAllByInstigator::InInstigator' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffAllByInstigator, Immediately) == 0x000008, "Member 'LAbnormalComponent_TakeOffAllByInstigator::Immediately' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.TakeOffByGroup
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_TakeOffByGroup final
{
public:
	class FName                                   IGroupCodeName;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediately;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_TakeOffByGroup) == 0x000004, "Wrong alignment on LAbnormalComponent_TakeOffByGroup");
static_assert(sizeof(LAbnormalComponent_TakeOffByGroup) == 0x00000C, "Wrong size on LAbnormalComponent_TakeOffByGroup");
static_assert(offsetof(LAbnormalComponent_TakeOffByGroup, IGroupCodeName) == 0x000000, "Member 'LAbnormalComponent_TakeOffByGroup::IGroupCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffByGroup, Immediately) == 0x000008, "Member 'LAbnormalComponent_TakeOffByGroup::Immediately' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.TakeOffByInstigator
// 0x0018 (0x0018 - 0x0000)
struct LAbnormalComponent_TakeOffByInstigator final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InInstigator;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediately;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_TakeOffByInstigator) == 0x000008, "Wrong alignment on LAbnormalComponent_TakeOffByInstigator");
static_assert(sizeof(LAbnormalComponent_TakeOffByInstigator) == 0x000018, "Wrong size on LAbnormalComponent_TakeOffByInstigator");
static_assert(offsetof(LAbnormalComponent_TakeOffByInstigator, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_TakeOffByInstigator::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffByInstigator, InInstigator) == 0x000008, "Member 'LAbnormalComponent_TakeOffByInstigator::InInstigator' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffByInstigator, Immediately) == 0x000010, "Member 'LAbnormalComponent_TakeOffByInstigator::Immediately' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.TakeOffByUniqueId
// 0x0010 (0x0010 - 0x0000)
struct LAbnormalComponent_TakeOffByUniqueId final
{
public:
	int64                                         InAbnormalUniqueId;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediately;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_TakeOffByUniqueId) == 0x000008, "Wrong alignment on LAbnormalComponent_TakeOffByUniqueId");
static_assert(sizeof(LAbnormalComponent_TakeOffByUniqueId) == 0x000010, "Wrong size on LAbnormalComponent_TakeOffByUniqueId");
static_assert(offsetof(LAbnormalComponent_TakeOffByUniqueId, InAbnormalUniqueId) == 0x000000, "Member 'LAbnormalComponent_TakeOffByUniqueId::InAbnormalUniqueId' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffByUniqueId, Immediately) == 0x000008, "Member 'LAbnormalComponent_TakeOffByUniqueId::Immediately' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.TakeOffWithRefCount
// 0x0010 (0x0010 - 0x0000)
struct LAbnormalComponent_TakeOffWithRefCount final
{
public:
	int64                                         InAbnormalUniqueId;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Immediately;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_TakeOffWithRefCount) == 0x000008, "Wrong alignment on LAbnormalComponent_TakeOffWithRefCount");
static_assert(sizeof(LAbnormalComponent_TakeOffWithRefCount) == 0x000010, "Wrong size on LAbnormalComponent_TakeOffWithRefCount");
static_assert(offsetof(LAbnormalComponent_TakeOffWithRefCount, InAbnormalUniqueId) == 0x000000, "Member 'LAbnormalComponent_TakeOffWithRefCount::InAbnormalUniqueId' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffWithRefCount, Immediately) == 0x000008, "Member 'LAbnormalComponent_TakeOffWithRefCount::Immediately' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_TakeOffWithRefCount, ReturnValue) == 0x000009, "Member 'LAbnormalComponent_TakeOffWithRefCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.GetAppliedAbnormals
// 0x0010 (0x0010 - 0x0000)
struct LAbnormalComponent_GetAppliedAbnormals final
{
public:
	TArray<struct FLDurableAbnormalBPPtr>         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_GetAppliedAbnormals) == 0x000008, "Wrong alignment on LAbnormalComponent_GetAppliedAbnormals");
static_assert(sizeof(LAbnormalComponent_GetAppliedAbnormals) == 0x000010, "Wrong size on LAbnormalComponent_GetAppliedAbnormals");
static_assert(offsetof(LAbnormalComponent_GetAppliedAbnormals, ReturnValue) == 0x000000, "Member 'LAbnormalComponent_GetAppliedAbnormals::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.IsAppliedAbnormal
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_IsAppliedAbnormal final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_IsAppliedAbnormal) == 0x000004, "Wrong alignment on LAbnormalComponent_IsAppliedAbnormal");
static_assert(sizeof(LAbnormalComponent_IsAppliedAbnormal) == 0x00000C, "Wrong size on LAbnormalComponent_IsAppliedAbnormal");
static_assert(offsetof(LAbnormalComponent_IsAppliedAbnormal, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_IsAppliedAbnormal::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_IsAppliedAbnormal, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_IsAppliedAbnormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.IsAppliedAbnormalCount
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_IsAppliedAbnormalCount final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAbnormalComponent_IsAppliedAbnormalCount) == 0x000004, "Wrong alignment on LAbnormalComponent_IsAppliedAbnormalCount");
static_assert(sizeof(LAbnormalComponent_IsAppliedAbnormalCount) == 0x00000C, "Wrong size on LAbnormalComponent_IsAppliedAbnormalCount");
static_assert(offsetof(LAbnormalComponent_IsAppliedAbnormalCount, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_IsAppliedAbnormalCount::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_IsAppliedAbnormalCount, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_IsAppliedAbnormalCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.IsAppliedGroupAbnormal
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_IsAppliedGroupAbnormal final
{
public:
	class FName                                   GroupCodename;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_IsAppliedGroupAbnormal) == 0x000004, "Wrong alignment on LAbnormalComponent_IsAppliedGroupAbnormal");
static_assert(sizeof(LAbnormalComponent_IsAppliedGroupAbnormal) == 0x00000C, "Wrong size on LAbnormalComponent_IsAppliedGroupAbnormal");
static_assert(offsetof(LAbnormalComponent_IsAppliedGroupAbnormal, GroupCodename) == 0x000000, "Member 'LAbnormalComponent_IsAppliedGroupAbnormal::GroupCodename' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_IsAppliedGroupAbnormal, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_IsAppliedGroupAbnormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.IsBuildupAbnormal
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_IsBuildupAbnormal final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_IsBuildupAbnormal) == 0x000004, "Wrong alignment on LAbnormalComponent_IsBuildupAbnormal");
static_assert(sizeof(LAbnormalComponent_IsBuildupAbnormal) == 0x00000C, "Wrong size on LAbnormalComponent_IsBuildupAbnormal");
static_assert(offsetof(LAbnormalComponent_IsBuildupAbnormal, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_IsBuildupAbnormal::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_IsBuildupAbnormal, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_IsBuildupAbnormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LAbnormalComponent.IsGaugeAbnormal
// 0x000C (0x000C - 0x0000)
struct LAbnormalComponent_IsGaugeAbnormal final
{
public:
	class FName                                   InAbnormalCodeName;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAbnormalComponent_IsGaugeAbnormal) == 0x000004, "Wrong alignment on LAbnormalComponent_IsGaugeAbnormal");
static_assert(sizeof(LAbnormalComponent_IsGaugeAbnormal) == 0x00000C, "Wrong size on LAbnormalComponent_IsGaugeAbnormal");
static_assert(offsetof(LAbnormalComponent_IsGaugeAbnormal, InAbnormalCodeName) == 0x000000, "Member 'LAbnormalComponent_IsGaugeAbnormal::InAbnormalCodeName' has a wrong offset!");
static_assert(offsetof(LAbnormalComponent_IsGaugeAbnormal, ReturnValue) == 0x000008, "Member 'LAbnormalComponent_IsGaugeAbnormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LBTask_BlueprintBase.GetBehaivorTreeNodeName
// 0x0010 (0x0010 - 0x0000)
struct LBTask_BlueprintBase_GetBehaivorTreeNodeName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBTask_BlueprintBase_GetBehaivorTreeNodeName) == 0x000008, "Wrong alignment on LBTask_BlueprintBase_GetBehaivorTreeNodeName");
static_assert(sizeof(LBTask_BlueprintBase_GetBehaivorTreeNodeName) == 0x000010, "Wrong size on LBTask_BlueprintBase_GetBehaivorTreeNodeName");
static_assert(offsetof(LBTask_BlueprintBase_GetBehaivorTreeNodeName, ReturnValue) == 0x000000, "Member 'LBTask_BlueprintBase_GetBehaivorTreeNodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LBTask_BlueprintBase.SetBehaivorTreeNodeName
// 0x0010 (0x0010 - 0x0000)
struct LBTask_BlueprintBase_SetBehaivorTreeNodeName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBTask_BlueprintBase_SetBehaivorTreeNodeName) == 0x000008, "Wrong alignment on LBTask_BlueprintBase_SetBehaivorTreeNodeName");
static_assert(sizeof(LBTask_BlueprintBase_SetBehaivorTreeNodeName) == 0x000010, "Wrong size on LBTask_BlueprintBase_SetBehaivorTreeNodeName");
static_assert(offsetof(LBTask_BlueprintBase_SetBehaivorTreeNodeName, Name_0) == 0x000000, "Member 'LBTask_BlueprintBase_SetBehaivorTreeNodeName::Name_0' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.AddDamagePerTime
// 0x0008 (0x0008 - 0x0000)
struct LDynamicDamageVolumeActor_AddDamagePerTime final
{
public:
	class ALCharacter*                            TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_AddDamagePerTime) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_AddDamagePerTime");
static_assert(sizeof(LDynamicDamageVolumeActor_AddDamagePerTime) == 0x000008, "Wrong size on LDynamicDamageVolumeActor_AddDamagePerTime");
static_assert(offsetof(LDynamicDamageVolumeActor_AddDamagePerTime, TargetActor) == 0x000000, "Member 'LDynamicDamageVolumeActor_AddDamagePerTime::TargetActor' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.ApplyDamage
// 0x0098 (0x0098 - 0x0000)
struct LDynamicDamageVolumeActor_ApplyDamage final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Skill_Hit_Override;                                // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_ApplyDamage) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_ApplyDamage");
static_assert(sizeof(LDynamicDamageVolumeActor_ApplyDamage) == 0x000098, "Wrong size on LDynamicDamageVolumeActor_ApplyDamage");
static_assert(offsetof(LDynamicDamageVolumeActor_ApplyDamage, TargetActor) == 0x000000, "Member 'LDynamicDamageVolumeActor_ApplyDamage::TargetActor' has a wrong offset!");
static_assert(offsetof(LDynamicDamageVolumeActor_ApplyDamage, HitResult) == 0x000008, "Member 'LDynamicDamageVolumeActor_ApplyDamage::HitResult' has a wrong offset!");
static_assert(offsetof(LDynamicDamageVolumeActor_ApplyDamage, Skill_Hit_Override) == 0x000090, "Member 'LDynamicDamageVolumeActor_ApplyDamage::Skill_Hit_Override' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.GetOverlappedActors
// 0x0010 (0x0010 - 0x0000)
struct LDynamicDamageVolumeActor_GetOverlappedActors final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_GetOverlappedActors) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_GetOverlappedActors");
static_assert(sizeof(LDynamicDamageVolumeActor_GetOverlappedActors) == 0x000010, "Wrong size on LDynamicDamageVolumeActor_GetOverlappedActors");
static_assert(offsetof(LDynamicDamageVolumeActor_GetOverlappedActors, ReturnValue) == 0x000000, "Member 'LDynamicDamageVolumeActor_GetOverlappedActors::ReturnValue' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.OnBeginOverlap
// 0x0090 (0x0090 - 0x0000)
struct LDynamicDamageVolumeActor_OnBeginOverlap final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_OnBeginOverlap) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_OnBeginOverlap");
static_assert(sizeof(LDynamicDamageVolumeActor_OnBeginOverlap) == 0x000090, "Wrong size on LDynamicDamageVolumeActor_OnBeginOverlap");
static_assert(offsetof(LDynamicDamageVolumeActor_OnBeginOverlap, Actor) == 0x000000, "Member 'LDynamicDamageVolumeActor_OnBeginOverlap::Actor' has a wrong offset!");
static_assert(offsetof(LDynamicDamageVolumeActor_OnBeginOverlap, HitResult) == 0x000008, "Member 'LDynamicDamageVolumeActor_OnBeginOverlap::HitResult' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.OnEndOverlap
// 0x0008 (0x0008 - 0x0000)
struct LDynamicDamageVolumeActor_OnEndOverlap final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_OnEndOverlap) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_OnEndOverlap");
static_assert(sizeof(LDynamicDamageVolumeActor_OnEndOverlap) == 0x000008, "Wrong size on LDynamicDamageVolumeActor_OnEndOverlap");
static_assert(offsetof(LDynamicDamageVolumeActor_OnEndOverlap, Actor) == 0x000000, "Member 'LDynamicDamageVolumeActor_OnEndOverlap::Actor' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.RemoveDamagePerTime
// 0x0008 (0x0008 - 0x0000)
struct LDynamicDamageVolumeActor_RemoveDamagePerTime final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_RemoveDamagePerTime) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_RemoveDamagePerTime");
static_assert(sizeof(LDynamicDamageVolumeActor_RemoveDamagePerTime) == 0x000008, "Wrong size on LDynamicDamageVolumeActor_RemoveDamagePerTime");
static_assert(offsetof(LDynamicDamageVolumeActor_RemoveDamagePerTime, TargetActor) == 0x000000, "Member 'LDynamicDamageVolumeActor_RemoveDamagePerTime::TargetActor' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.ResetDynamicDamageVolumeInfo
// 0x0008 (0x0008 - 0x0000)
struct LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo) == 0x000004, "Wrong alignment on LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo");
static_assert(sizeof(LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo) == 0x000008, "Wrong size on LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo");
static_assert(offsetof(LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo, InCodeName) == 0x000000, "Member 'LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo::InCodeName' has a wrong offset!");

// Function ProjectP.LDynamicDamageVolumeActor.SetOverlappedActors
// 0x0010 (0x0010 - 0x0000)
struct LDynamicDamageVolumeActor_SetOverlappedActors final
{
public:
	TArray<class AActor*>                         InActorList;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDynamicDamageVolumeActor_SetOverlappedActors) == 0x000008, "Wrong alignment on LDynamicDamageVolumeActor_SetOverlappedActors");
static_assert(sizeof(LDynamicDamageVolumeActor_SetOverlappedActors) == 0x000010, "Wrong size on LDynamicDamageVolumeActor_SetOverlappedActors");
static_assert(offsetof(LDynamicDamageVolumeActor_SetOverlappedActors, InActorList) == 0x000000, "Member 'LDynamicDamageVolumeActor_SetOverlappedActors::InActorList' has a wrong offset!");

// Function ProjectP.LAchievementSystem.MakeAchievementLog
// 0x0018 (0x0018 - 0x0000)
struct LAchievementSystem_MakeAchievementLog final
{
public:
	class FName                                   AchievementCodeName;                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAchievementSystem_MakeAchievementLog) == 0x000008, "Wrong alignment on LAchievementSystem_MakeAchievementLog");
static_assert(sizeof(LAchievementSystem_MakeAchievementLog) == 0x000018, "Wrong size on LAchievementSystem_MakeAchievementLog");
static_assert(offsetof(LAchievementSystem_MakeAchievementLog, AchievementCodeName) == 0x000000, "Member 'LAchievementSystem_MakeAchievementLog::AchievementCodeName' has a wrong offset!");
static_assert(offsetof(LAchievementSystem_MakeAchievementLog, ReturnValue) == 0x000008, "Member 'LAchievementSystem_MakeAchievementLog::ReturnValue' has a wrong offset!");

// Function ProjectP.LAchievementSystem.OnSendPlatform
// 0x0008 (0x0008 - 0x0000)
struct LAchievementSystem_OnSendPlatform final
{
public:
	class FName                                   AchievementCodeName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAchievementSystem_OnSendPlatform) == 0x000004, "Wrong alignment on LAchievementSystem_OnSendPlatform");
static_assert(sizeof(LAchievementSystem_OnSendPlatform) == 0x000008, "Wrong size on LAchievementSystem_OnSendPlatform");
static_assert(offsetof(LAchievementSystem_OnSendPlatform, AchievementCodeName) == 0x000000, "Member 'LAchievementSystem_OnSendPlatform::AchievementCodeName' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Climb
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Climb final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Climb) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Climb");
static_assert(sizeof(LActionClass_ULActionClass_Climb) == 0x000008, "Wrong size on LActionClass_ULActionClass_Climb");
static_assert(offsetof(LActionClass_ULActionClass_Climb, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Climb::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Common
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Common final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Common) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Common");
static_assert(sizeof(LActionClass_ULActionClass_Common) == 0x000008, "Wrong size on LActionClass_ULActionClass_Common");
static_assert(offsetof(LActionClass_ULActionClass_Common, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Common::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_CommonMontage
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_CommonMontage final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_CommonMontage) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_CommonMontage");
static_assert(sizeof(LActionClass_ULActionClass_CommonMontage) == 0x000008, "Wrong size on LActionClass_ULActionClass_CommonMontage");
static_assert(offsetof(LActionClass_ULActionClass_CommonMontage, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_CommonMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Dialoging
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Dialoging final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Dialoging) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Dialoging");
static_assert(sizeof(LActionClass_ULActionClass_Dialoging) == 0x000008, "Wrong size on LActionClass_ULActionClass_Dialoging");
static_assert(offsetof(LActionClass_ULActionClass_Dialoging, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Dialoging::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Die
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Die final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Die) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Die");
static_assert(sizeof(LActionClass_ULActionClass_Die) == 0x000008, "Wrong size on LActionClass_ULActionClass_Die");
static_assert(offsetof(LActionClass_ULActionClass_Die, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Die::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_DMG_STAND
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_DMG_STAND final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_DMG_STAND) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_DMG_STAND");
static_assert(sizeof(LActionClass_ULActionClass_DMG_STAND) == 0x000008, "Wrong size on LActionClass_ULActionClass_DMG_STAND");
static_assert(offsetof(LActionClass_ULActionClass_DMG_STAND, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_DMG_STAND::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Down_Away
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Down_Away final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Down_Away) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Down_Away");
static_assert(sizeof(LActionClass_ULActionClass_Down_Away) == 0x000008, "Wrong size on LActionClass_ULActionClass_Down_Away");
static_assert(offsetof(LActionClass_ULActionClass_Down_Away, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Down_Away::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Down_Drag
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Down_Drag final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Down_Drag) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Down_Drag");
static_assert(sizeof(LActionClass_ULActionClass_Down_Drag) == 0x000008, "Wrong size on LActionClass_ULActionClass_Down_Drag");
static_assert(offsetof(LActionClass_ULActionClass_Down_Drag, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Down_Drag::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Down_Stamp
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Down_Stamp final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Down_Stamp) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Down_Stamp");
static_assert(sizeof(LActionClass_ULActionClass_Down_Stamp) == 0x000008, "Wrong size on LActionClass_ULActionClass_Down_Stamp");
static_assert(offsetof(LActionClass_ULActionClass_Down_Stamp, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Down_Stamp::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Down_Up
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Down_Up final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Down_Up) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Down_Up");
static_assert(sizeof(LActionClass_ULActionClass_Down_Up) == 0x000008, "Wrong size on LActionClass_ULActionClass_Down_Up");
static_assert(offsetof(LActionClass_ULActionClass_Down_Up, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Down_Up::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Draw_Weapon
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Draw_Weapon final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Draw_Weapon) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Draw_Weapon");
static_assert(sizeof(LActionClass_ULActionClass_Draw_Weapon) == 0x000008, "Wrong size on LActionClass_ULActionClass_Draw_Weapon");
static_assert(offsetof(LActionClass_ULActionClass_Draw_Weapon, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Draw_Weapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Falling
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Falling final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Falling) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Falling");
static_assert(sizeof(LActionClass_ULActionClass_Falling) == 0x000008, "Wrong size on LActionClass_ULActionClass_Falling");
static_assert(offsetof(LActionClass_ULActionClass_Falling, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Falling::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_FatalAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_FatalAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_FatalAttack) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_FatalAttack");
static_assert(sizeof(LActionClass_ULActionClass_FatalAttack) == 0x000008, "Wrong size on LActionClass_ULActionClass_FatalAttack");
static_assert(offsetof(LActionClass_ULActionClass_FatalAttack, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_FatalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_FatalAttack_Victim
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_FatalAttack_Victim final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_FatalAttack_Victim) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_FatalAttack_Victim");
static_assert(sizeof(LActionClass_ULActionClass_FatalAttack_Victim) == 0x000008, "Wrong size on LActionClass_ULActionClass_FatalAttack_Victim");
static_assert(offsetof(LActionClass_ULActionClass_FatalAttack_Victim, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_FatalAttack_Victim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_FatalAttack_Victim_BeforeHit
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit");
static_assert(sizeof(LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit) == 0x000008, "Wrong size on LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit");
static_assert(offsetof(LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_FatalAttack_Victim_End
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_FatalAttack_Victim_End final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_FatalAttack_Victim_End) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_FatalAttack_Victim_End");
static_assert(sizeof(LActionClass_ULActionClass_FatalAttack_Victim_End) == 0x000008, "Wrong size on LActionClass_ULActionClass_FatalAttack_Victim_End");
static_assert(offsetof(LActionClass_ULActionClass_FatalAttack_Victim_End, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_FatalAttack_Victim_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_FloatingHit
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_FloatingHit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_FloatingHit) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_FloatingHit");
static_assert(sizeof(LActionClass_ULActionClass_FloatingHit) == 0x000008, "Wrong size on LActionClass_ULActionClass_FloatingHit");
static_assert(offsetof(LActionClass_ULActionClass_FloatingHit, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_FloatingHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Game_Start
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Game_Start final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Game_Start) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Game_Start");
static_assert(sizeof(LActionClass_ULActionClass_Game_Start) == 0x000008, "Wrong size on LActionClass_ULActionClass_Game_Start");
static_assert(offsetof(LActionClass_ULActionClass_Game_Start, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Game_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_GetUpDash
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_GetUpDash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_GetUpDash) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_GetUpDash");
static_assert(sizeof(LActionClass_ULActionClass_GetUpDash) == 0x000008, "Wrong size on LActionClass_ULActionClass_GetUpDash");
static_assert(offsetof(LActionClass_ULActionClass_GetUpDash, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_GetUpDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Grab
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Grab final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Grab) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Grab");
static_assert(sizeof(LActionClass_ULActionClass_Grab) == 0x000008, "Wrong size on LActionClass_ULActionClass_Grab");
static_assert(offsetof(LActionClass_ULActionClass_Grab, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Grab::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Grabbed
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Grabbed final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Grabbed) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Grabbed");
static_assert(sizeof(LActionClass_ULActionClass_Grabbed) == 0x000008, "Wrong size on LActionClass_ULActionClass_Grabbed");
static_assert(offsetof(LActionClass_ULActionClass_Grabbed, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Grabbed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_GrabRelease
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_GrabRelease final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_GrabRelease) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_GrabRelease");
static_assert(sizeof(LActionClass_ULActionClass_GrabRelease) == 0x000008, "Wrong size on LActionClass_ULActionClass_GrabRelease");
static_assert(offsetof(LActionClass_ULActionClass_GrabRelease, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_GrabRelease::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Grinder_Element
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Grinder_Element final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Grinder_Element) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Grinder_Element");
static_assert(sizeof(LActionClass_ULActionClass_Grinder_Element) == 0x000008, "Wrong size on LActionClass_ULActionClass_Grinder_Element");
static_assert(offsetof(LActionClass_ULActionClass_Grinder_Element, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Grinder_Element::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Groggy
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Groggy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Groggy) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Groggy");
static_assert(sizeof(LActionClass_ULActionClass_Groggy) == 0x000008, "Wrong size on LActionClass_ULActionClass_Groggy");
static_assert(offsetof(LActionClass_ULActionClass_Groggy, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Groggy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Guard) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Guard");
static_assert(sizeof(LActionClass_ULActionClass_Guard) == 0x000008, "Wrong size on LActionClass_ULActionClass_Guard");
static_assert(offsetof(LActionClass_ULActionClass_Guard, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Guard_Break
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Guard_Break final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Guard_Break) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Guard_Break");
static_assert(sizeof(LActionClass_ULActionClass_Guard_Break) == 0x000008, "Wrong size on LActionClass_ULActionClass_Guard_Break");
static_assert(offsetof(LActionClass_ULActionClass_Guard_Break, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Guard_Break::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Guard_Hit_Heavy
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Guard_Hit_Heavy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Guard_Hit_Heavy) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Guard_Hit_Heavy");
static_assert(sizeof(LActionClass_ULActionClass_Guard_Hit_Heavy) == 0x000008, "Wrong size on LActionClass_ULActionClass_Guard_Hit_Heavy");
static_assert(offsetof(LActionClass_ULActionClass_Guard_Hit_Heavy, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Guard_Hit_Heavy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Guard_Hit_Normal
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Guard_Hit_Normal final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Guard_Hit_Normal) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Guard_Hit_Normal");
static_assert(sizeof(LActionClass_ULActionClass_Guard_Hit_Normal) == 0x000008, "Wrong size on LActionClass_ULActionClass_Guard_Hit_Normal");
static_assert(offsetof(LActionClass_ULActionClass_Guard_Hit_Normal, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Guard_Hit_Normal::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Guard_Reflect
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Guard_Reflect final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Guard_Reflect) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Guard_Reflect");
static_assert(sizeof(LActionClass_ULActionClass_Guard_Reflect) == 0x000008, "Wrong size on LActionClass_ULActionClass_Guard_Reflect");
static_assert(offsetof(LActionClass_ULActionClass_Guard_Reflect, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Guard_Reflect::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Guard_Repulse
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Guard_Repulse final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Guard_Repulse) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Guard_Repulse");
static_assert(sizeof(LActionClass_ULActionClass_Guard_Repulse) == 0x000008, "Wrong size on LActionClass_ULActionClass_Guard_Repulse");
static_assert(offsetof(LActionClass_ULActionClass_Guard_Repulse, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Guard_Repulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_IdleTurn
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_IdleTurn final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_IdleTurn) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_IdleTurn");
static_assert(sizeof(LActionClass_ULActionClass_IdleTurn) == 0x000008, "Wrong size on LActionClass_ULActionClass_IdleTurn");
static_assert(offsetof(LActionClass_ULActionClass_IdleTurn, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_IdleTurn::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_IdleTurnEnd
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_IdleTurnEnd final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_IdleTurnEnd) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_IdleTurnEnd");
static_assert(sizeof(LActionClass_ULActionClass_IdleTurnEnd) == 0x000008, "Wrong size on LActionClass_ULActionClass_IdleTurnEnd");
static_assert(offsetof(LActionClass_ULActionClass_IdleTurnEnd, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_IdleTurnEnd::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Interaction
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Interaction final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Interaction) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Interaction");
static_assert(sizeof(LActionClass_ULActionClass_Interaction) == 0x000008, "Wrong size on LActionClass_ULActionClass_Interaction");
static_assert(offsetof(LActionClass_ULActionClass_Interaction, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Interaction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Jump
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Jump final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Jump) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Jump");
static_assert(sizeof(LActionClass_ULActionClass_Jump) == 0x000008, "Wrong size on LActionClass_ULActionClass_Jump");
static_assert(offsetof(LActionClass_ULActionClass_Jump, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Jump::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_KnockBack
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_KnockBack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_KnockBack) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_KnockBack");
static_assert(sizeof(LActionClass_ULActionClass_KnockBack) == 0x000008, "Wrong size on LActionClass_ULActionClass_KnockBack");
static_assert(offsetof(LActionClass_ULActionClass_KnockBack, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_KnockBack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Landing
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Landing final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Landing) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Landing");
static_assert(sizeof(LActionClass_ULActionClass_Landing) == 0x000008, "Wrong size on LActionClass_ULActionClass_Landing");
static_assert(offsetof(LActionClass_ULActionClass_Landing, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Landing::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Multiple
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Multiple final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Multiple) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Multiple");
static_assert(sizeof(LActionClass_ULActionClass_Multiple) == 0x000008, "Wrong size on LActionClass_ULActionClass_Multiple");
static_assert(offsetof(LActionClass_ULActionClass_Multiple, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Multiple::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_None
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_None) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_None");
static_assert(sizeof(LActionClass_ULActionClass_None) == 0x000008, "Wrong size on LActionClass_ULActionClass_None");
static_assert(offsetof(LActionClass_ULActionClass_None, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_NpcGuard_Break
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_NpcGuard_Break final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_NpcGuard_Break) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_NpcGuard_Break");
static_assert(sizeof(LActionClass_ULActionClass_NpcGuard_Break) == 0x000008, "Wrong size on LActionClass_ULActionClass_NpcGuard_Break");
static_assert(offsetof(LActionClass_ULActionClass_NpcGuard_Break, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_NpcGuard_Break::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_NpcGuard_Hit
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_NpcGuard_Hit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_NpcGuard_Hit) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_NpcGuard_Hit");
static_assert(sizeof(LActionClass_ULActionClass_NpcGuard_Hit) == 0x000008, "Wrong size on LActionClass_ULActionClass_NpcGuard_Hit");
static_assert(offsetof(LActionClass_ULActionClass_NpcGuard_Hit, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_NpcGuard_Hit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_NpcGuard_Hit_Repulse
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_NpcGuard_Hit_Repulse final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_NpcGuard_Hit_Repulse) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_NpcGuard_Hit_Repulse");
static_assert(sizeof(LActionClass_ULActionClass_NpcGuard_Hit_Repulse) == 0x000008, "Wrong size on LActionClass_ULActionClass_NpcGuard_Hit_Repulse");
static_assert(offsetof(LActionClass_ULActionClass_NpcGuard_Hit_Repulse, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_NpcGuard_Hit_Repulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Object_Repulse
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Object_Repulse final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Object_Repulse) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Object_Repulse");
static_assert(sizeof(LActionClass_ULActionClass_Object_Repulse) == 0x000008, "Wrong size on LActionClass_ULActionClass_Object_Repulse");
static_assert(offsetof(LActionClass_ULActionClass_Object_Repulse, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Object_Repulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Paralyzation
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Paralyzation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Paralyzation) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Paralyzation");
static_assert(sizeof(LActionClass_ULActionClass_Paralyzation) == 0x000008, "Wrong size on LActionClass_ULActionClass_Paralyzation");
static_assert(offsetof(LActionClass_ULActionClass_Paralyzation, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Paralyzation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Parry
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Parry final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Parry) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Parry");
static_assert(sizeof(LActionClass_ULActionClass_Parry) == 0x000008, "Wrong size on LActionClass_ULActionClass_Parry");
static_assert(offsetof(LActionClass_ULActionClass_Parry, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Parry::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Put_Weapon
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Put_Weapon final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Put_Weapon) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Put_Weapon");
static_assert(sizeof(LActionClass_ULActionClass_Put_Weapon) == 0x000008, "Wrong size on LActionClass_ULActionClass_Put_Weapon");
static_assert(offsetof(LActionClass_ULActionClass_Put_Weapon, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Put_Weapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_SkillFailed
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_SkillFailed final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_SkillFailed) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_SkillFailed");
static_assert(sizeof(LActionClass_ULActionClass_SkillFailed) == 0x000008, "Wrong size on LActionClass_ULActionClass_SkillFailed");
static_assert(offsetof(LActionClass_ULActionClass_SkillFailed, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_SkillFailed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_SlaveArm
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_SlaveArm final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_SlaveArm) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_SlaveArm");
static_assert(sizeof(LActionClass_ULActionClass_SlaveArm) == 0x000008, "Wrong size on LActionClass_ULActionClass_SlaveArm");
static_assert(offsetof(LActionClass_ULActionClass_SlaveArm, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_SlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_SlaveArm_Visual_Idle
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_SlaveArm_Visual_Idle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_SlaveArm_Visual_Idle) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_SlaveArm_Visual_Idle");
static_assert(sizeof(LActionClass_ULActionClass_SlaveArm_Visual_Idle) == 0x000008, "Wrong size on LActionClass_ULActionClass_SlaveArm_Visual_Idle");
static_assert(offsetof(LActionClass_ULActionClass_SlaveArm_Visual_Idle, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_SlaveArm_Visual_Idle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_SpawnIdle
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_SpawnIdle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_SpawnIdle) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_SpawnIdle");
static_assert(sizeof(LActionClass_ULActionClass_SpawnIdle) == 0x000008, "Wrong size on LActionClass_ULActionClass_SpawnIdle");
static_assert(offsetof(LActionClass_ULActionClass_SpawnIdle, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_SpawnIdle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Sprint
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Sprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Sprint) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Sprint");
static_assert(sizeof(LActionClass_ULActionClass_Sprint) == 0x000008, "Wrong size on LActionClass_ULActionClass_Sprint");
static_assert(offsetof(LActionClass_ULActionClass_Sprint, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Sprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Sprint_Exhausted
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Sprint_Exhausted final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Sprint_Exhausted) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Sprint_Exhausted");
static_assert(sizeof(LActionClass_ULActionClass_Sprint_Exhausted) == 0x000008, "Wrong size on LActionClass_ULActionClass_Sprint_Exhausted");
static_assert(offsetof(LActionClass_ULActionClass_Sprint_Exhausted, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Sprint_Exhausted::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Sprint_TurnAround
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Sprint_TurnAround final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Sprint_TurnAround) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Sprint_TurnAround");
static_assert(sizeof(LActionClass_ULActionClass_Sprint_TurnAround) == 0x000008, "Wrong size on LActionClass_ULActionClass_Sprint_TurnAround");
static_assert(offsetof(LActionClass_ULActionClass_Sprint_TurnAround, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Sprint_TurnAround::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_StopRunning
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_StopRunning final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_StopRunning) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_StopRunning");
static_assert(sizeof(LActionClass_ULActionClass_StopRunning) == 0x000008, "Wrong size on LActionClass_ULActionClass_StopRunning");
static_assert(offsetof(LActionClass_ULActionClass_StopRunning, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_StopRunning::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_StopSprint
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_StopSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_StopSprint) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_StopSprint");
static_assert(sizeof(LActionClass_ULActionClass_StopSprint) == 0x000008, "Wrong size on LActionClass_ULActionClass_StopSprint");
static_assert(offsetof(LActionClass_ULActionClass_StopSprint, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_StopSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_TalkerIdle
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_TalkerIdle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_TalkerIdle) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_TalkerIdle");
static_assert(sizeof(LActionClass_ULActionClass_TalkerIdle) == 0x000008, "Wrong size on LActionClass_ULActionClass_TalkerIdle");
static_assert(offsetof(LActionClass_ULActionClass_TalkerIdle, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_TalkerIdle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Teleport_End
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Teleport_End final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Teleport_End) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Teleport_End");
static_assert(sizeof(LActionClass_ULActionClass_Teleport_End) == 0x000008, "Wrong size on LActionClass_ULActionClass_Teleport_End");
static_assert(offsetof(LActionClass_ULActionClass_Teleport_End, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Teleport_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Teleport_NewGamePlus
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Teleport_NewGamePlus final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Teleport_NewGamePlus) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Teleport_NewGamePlus");
static_assert(sizeof(LActionClass_ULActionClass_Teleport_NewGamePlus) == 0x000008, "Wrong size on LActionClass_ULActionClass_Teleport_NewGamePlus");
static_assert(offsetof(LActionClass_ULActionClass_Teleport_NewGamePlus, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Teleport_NewGamePlus::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Teleport_Start
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Teleport_Start final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Teleport_Start) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Teleport_Start");
static_assert(sizeof(LActionClass_ULActionClass_Teleport_Start) == 0x000008, "Wrong size on LActionClass_ULActionClass_Teleport_Start");
static_assert(offsetof(LActionClass_ULActionClass_Teleport_Start, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Teleport_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_ToughSpecialHit
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_ToughSpecialHit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_ToughSpecialHit) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_ToughSpecialHit");
static_assert(sizeof(LActionClass_ULActionClass_ToughSpecialHit) == 0x000008, "Wrong size on LActionClass_ULActionClass_ToughSpecialHit");
static_assert(offsetof(LActionClass_ULActionClass_ToughSpecialHit, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_ToughSpecialHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_TurnAround
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_TurnAround final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_TurnAround) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_TurnAround");
static_assert(sizeof(LActionClass_ULActionClass_TurnAround) == 0x000008, "Wrong size on LActionClass_ULActionClass_TurnAround");
static_assert(offsetof(LActionClass_ULActionClass_TurnAround, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_TurnAround::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Use_Item
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Use_Item final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Use_Item) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Use_Item");
static_assert(sizeof(LActionClass_ULActionClass_Use_Item) == 0x000008, "Wrong size on LActionClass_ULActionClass_Use_Item");
static_assert(offsetof(LActionClass_ULActionClass_Use_Item, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Use_Item::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Weapon_Change
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Weapon_Change final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Weapon_Change) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Weapon_Change");
static_assert(sizeof(LActionClass_ULActionClass_Weapon_Change) == 0x000008, "Wrong size on LActionClass_ULActionClass_Weapon_Change");
static_assert(offsetof(LActionClass_ULActionClass_Weapon_Change, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Weapon_Change::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Wire_Following
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Wire_Following final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Wire_Following) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Wire_Following");
static_assert(sizeof(LActionClass_ULActionClass_Wire_Following) == 0x000008, "Wrong size on LActionClass_ULActionClass_Wire_Following");
static_assert(offsetof(LActionClass_ULActionClass_Wire_Following, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Wire_Following::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Wire_Hit
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Wire_Hit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Wire_Hit) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Wire_Hit");
static_assert(sizeof(LActionClass_ULActionClass_Wire_Hit) == 0x000008, "Wrong size on LActionClass_ULActionClass_Wire_Hit");
static_assert(offsetof(LActionClass_ULActionClass_Wire_Hit, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Wire_Hit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_Wire_Pulling
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_Wire_Pulling final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_Wire_Pulling) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_Wire_Pulling");
static_assert(sizeof(LActionClass_ULActionClass_Wire_Pulling) == 0x000008, "Wrong size on LActionClass_ULActionClass_Wire_Pulling");
static_assert(offsetof(LActionClass_ULActionClass_Wire_Pulling, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_Wire_Pulling::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_WireAction
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_WireAction final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_WireAction) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_WireAction");
static_assert(sizeof(LActionClass_ULActionClass_WireAction) == 0x000008, "Wrong size on LActionClass_ULActionClass_WireAction");
static_assert(offsetof(LActionClass_ULActionClass_WireAction, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_WireAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionClass.ULActionClass_WireJumpSmash
// 0x0008 (0x0008 - 0x0000)
struct LActionClass_ULActionClass_WireJumpSmash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionClass_ULActionClass_WireJumpSmash) == 0x000004, "Wrong alignment on LActionClass_ULActionClass_WireJumpSmash");
static_assert(sizeof(LActionClass_ULActionClass_WireJumpSmash) == 0x000008, "Wrong size on LActionClass_ULActionClass_WireJumpSmash");
static_assert(offsetof(LActionClass_ULActionClass_WireJumpSmash, ReturnValue) == 0x000000, "Member 'LActionClass_ULActionClass_WireJumpSmash::ReturnValue' has a wrong offset!");

// Function ProjectP.LEnvSettings.OnApplySetting_BP
// 0x0004 (0x0004 - 0x0000)
struct LEnvSettings_OnApplySetting_BP final
{
public:
	float                                         LocalWeight;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEnvSettings_OnApplySetting_BP) == 0x000004, "Wrong alignment on LEnvSettings_OnApplySetting_BP");
static_assert(sizeof(LEnvSettings_OnApplySetting_BP) == 0x000004, "Wrong size on LEnvSettings_OnApplySetting_BP");
static_assert(offsetof(LEnvSettings_OnApplySetting_BP, LocalWeight) == 0x000000, "Member 'LEnvSettings_OnApplySetting_BP::LocalWeight' has a wrong offset!");

// Function ProjectP.LBTreeFuncLibrary.GetBlackboardValueAsLocation
// 0x0040 (0x0040 - 0x0000)
struct LBTreeFuncLibrary_GetBlackboardValueAsLocation final
{
public:
	class UBTNode*                                NodeOwner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Key;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBTreeFuncLibrary_GetBlackboardValueAsLocation) == 0x000008, "Wrong alignment on LBTreeFuncLibrary_GetBlackboardValueAsLocation");
static_assert(sizeof(LBTreeFuncLibrary_GetBlackboardValueAsLocation) == 0x000040, "Wrong size on LBTreeFuncLibrary_GetBlackboardValueAsLocation");
static_assert(offsetof(LBTreeFuncLibrary_GetBlackboardValueAsLocation, NodeOwner) == 0x000000, "Member 'LBTreeFuncLibrary_GetBlackboardValueAsLocation::NodeOwner' has a wrong offset!");
static_assert(offsetof(LBTreeFuncLibrary_GetBlackboardValueAsLocation, Key) == 0x000008, "Member 'LBTreeFuncLibrary_GetBlackboardValueAsLocation::Key' has a wrong offset!");
static_assert(offsetof(LBTreeFuncLibrary_GetBlackboardValueAsLocation, ReturnValue) == 0x000030, "Member 'LBTreeFuncLibrary_GetBlackboardValueAsLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LButton.SetSelected
// 0x0001 (0x0001 - 0x0000)
struct LButton_SetSelected final
{
public:
	bool                                          bSelected_0;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LButton_SetSelected) == 0x000001, "Wrong alignment on LButton_SetSelected");
static_assert(sizeof(LButton_SetSelected) == 0x000001, "Wrong size on LButton_SetSelected");
static_assert(offsetof(LButton_SetSelected, bSelected_0) == 0x000000, "Member 'LButton_SetSelected::bSelected_0' has a wrong offset!");

// Function ProjectP.LButton.IsSelected
// 0x0001 (0x0001 - 0x0000)
struct LButton_IsSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LButton_IsSelected) == 0x000001, "Wrong alignment on LButton_IsSelected");
static_assert(sizeof(LButton_IsSelected) == 0x000001, "Wrong size on LButton_IsSelected");
static_assert(offsetof(LButton_IsSelected, ReturnValue) == 0x000000, "Member 'LButton_IsSelected::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.ApplyMaxStatMultiplier
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_ApplyMaxStatMultiplier final
{
public:
	class AActor*                                 TargetChar;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  SecondStatType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Muliplier;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_ApplyMaxStatMultiplier) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_ApplyMaxStatMultiplier");
static_assert(sizeof(LCalcStatFuncLibrary_ApplyMaxStatMultiplier) == 0x000018, "Wrong size on LCalcStatFuncLibrary_ApplyMaxStatMultiplier");
static_assert(offsetof(LCalcStatFuncLibrary_ApplyMaxStatMultiplier, TargetChar) == 0x000000, "Member 'LCalcStatFuncLibrary_ApplyMaxStatMultiplier::TargetChar' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_ApplyMaxStatMultiplier, SecondStatType) == 0x000008, "Member 'LCalcStatFuncLibrary_ApplyMaxStatMultiplier::SecondStatType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_ApplyMaxStatMultiplier, Muliplier) == 0x00000C, "Member 'LCalcStatFuncLibrary_ApplyMaxStatMultiplier::Muliplier' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_ApplyMaxStatMultiplier, ReturnValue) == 0x000010, "Member 'LCalcStatFuncLibrary_ApplyMaxStatMultiplier::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeFrenzyAmount
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcConsumeFrenzyAmount final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         FrenzyAmount;                                      // 0x0160(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0164(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcConsumeFrenzyAmount");
static_assert(sizeof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcConsumeFrenzyAmount");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcConsumeFrenzyAmount::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcConsumeFrenzyAmount::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcConsumeFrenzyAmount::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount, FrenzyAmount) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcConsumeFrenzyAmount::FrenzyAmount' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeFrenzyAmount, ReturnValue) == 0x000164, "Member 'LCalcStatFuncLibrary_CalcConsumeFrenzyAmount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeGuardWeaponSharpness
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness");
static_assert(sizeof(LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness) == 0x000010, "Wrong size on LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness, Victim) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeWeaponSharpness_Attacker
// 0x0170 (0x0170 - 0x0000)
struct LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       HitPartsComp;                                      // 0x0160(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0168(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker");
static_assert(sizeof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker) == 0x000170, "Wrong size on LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker, HitPartsComp) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker::HitPartsComp' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker, ReturnValue) == 0x000168, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeWeaponSharpness_Victim
// 0x0170 (0x0170 - 0x0000)
struct LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       HitPartsComp;                                      // 0x0160(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0168(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim");
static_assert(sizeof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim) == 0x000170, "Wrong size on LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim, HitPartsComp) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim::HitPartsComp' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim, ReturnValue) == 0x000168, "Member 'LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcDamage
// 0x0300 (0x0300 - 0x0000)
struct LCalcStatFuncLibrary_CalcDamage final
{
public:
	struct FLCalcDamageData                       CalcDamageData;                                    // 0x0000(0x0110)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Attacker;                                          // 0x0110(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0118(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0120(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0270(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULHitProcContext*                       HitProcContext;                                    // 0x02F8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcDamage) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcDamage");
static_assert(sizeof(LCalcStatFuncLibrary_CalcDamage) == 0x000300, "Wrong size on LCalcStatFuncLibrary_CalcDamage");
static_assert(offsetof(LCalcStatFuncLibrary_CalcDamage, CalcDamageData) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcDamage::CalcDamageData' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcDamage, Attacker) == 0x000110, "Member 'LCalcStatFuncLibrary_CalcDamage::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcDamage, Victim) == 0x000118, "Member 'LCalcStatFuncLibrary_CalcDamage::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcDamage, HitInfo) == 0x000120, "Member 'LCalcStatFuncLibrary_CalcDamage::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcDamage, HitResult) == 0x000270, "Member 'LCalcStatFuncLibrary_CalcDamage::HitResult' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcDamage, HitProcContext) == 0x0002F8, "Member 'LCalcStatFuncLibrary_CalcDamage::HitProcContext' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcElementalDamage
// 0x0300 (0x0300 - 0x0000)
struct LCalcStatFuncLibrary_CalcElementalDamage final
{
public:
	struct FLCalcDamageData                       CalcDamageData;                                    // 0x0000(0x0110)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Attacker;                                          // 0x0110(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0118(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0120(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0270(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULHitProcContext*                       HitProcContext;                                    // 0x02F8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcElementalDamage) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcElementalDamage");
static_assert(sizeof(LCalcStatFuncLibrary_CalcElementalDamage) == 0x000300, "Wrong size on LCalcStatFuncLibrary_CalcElementalDamage");
static_assert(offsetof(LCalcStatFuncLibrary_CalcElementalDamage, CalcDamageData) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcElementalDamage::CalcDamageData' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcElementalDamage, Attacker) == 0x000110, "Member 'LCalcStatFuncLibrary_CalcElementalDamage::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcElementalDamage, Victim) == 0x000118, "Member 'LCalcStatFuncLibrary_CalcElementalDamage::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcElementalDamage, HitInfo) == 0x000120, "Member 'LCalcStatFuncLibrary_CalcElementalDamage::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcElementalDamage, HitResult) == 0x000270, "Member 'LCalcStatFuncLibrary_CalcElementalDamage::HitResult' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcElementalDamage, HitProcContext) == 0x0002F8, "Member 'LCalcStatFuncLibrary_CalcElementalDamage::HitProcContext' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcEquipmentWeightRatio
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_CalcEquipmentWeightRatio final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcEquipmentWeightRatio) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcEquipmentWeightRatio");
static_assert(sizeof(LCalcStatFuncLibrary_CalcEquipmentWeightRatio) == 0x000010, "Wrong size on LCalcStatFuncLibrary_CalcEquipmentWeightRatio");
static_assert(offsetof(LCalcStatFuncLibrary_CalcEquipmentWeightRatio, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcEquipmentWeightRatio::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcEquipmentWeightRatio, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcEquipmentWeightRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcEquipmentWeightRatioInGivenMaxWeight
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMaxWeight;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight");
static_assert(sizeof(LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight) == 0x000010, "Wrong size on LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight");
static_assert(offsetof(LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight, InMaxWeight) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight::InMaxWeight' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcFallingDamage
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_CalcFallingDamage final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcFallingDamage) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcFallingDamage");
static_assert(sizeof(LCalcStatFuncLibrary_CalcFallingDamage) == 0x000010, "Wrong size on LCalcStatFuncLibrary_CalcFallingDamage");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFallingDamage, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcFallingDamage::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFallingDamage, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcFallingDamage::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcFrenzyPoint_ForAttacker
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker");
static_assert(sizeof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcFrenzyPoint_ForVictim
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ALWeapon*                               VictimWeapon;                                      // 0x0158(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerfectGuard;                                     // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0164(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim");
static_assert(sizeof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim, Victim) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim, VictimWeapon) == 0x000158, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim::VictimWeapon' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim, bPerfectGuard) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim::bPerfectGuard' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim, ReturnValue) == 0x000164, "Member 'LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcGroggy_ConsumablePoint
// 0x0178 (0x0178 - 0x0000)
struct LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OutGroggyAttackDamage;                             // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPartsComponent*                       ReduceByPartsComp;                                 // 0x0168(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0170(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint");
static_assert(sizeof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint) == 0x000178, "Wrong size on LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint, OutGroggyAttackDamage) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint::OutGroggyAttackDamage' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint, ReduceByPartsComp) == 0x000168, "Member 'LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint::ReduceByPartsComp' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint, ReturnValue) == 0x000170, "Member 'LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcGroggy_MaintainTime
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_CalcGroggy_MaintainTime final
{
public:
	class AActor*                                 TargetChar;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0158(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcGroggy_MaintainTime) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcGroggy_MaintainTime");
static_assert(sizeof(LCalcStatFuncLibrary_CalcGroggy_MaintainTime) == 0x000160, "Wrong size on LCalcStatFuncLibrary_CalcGroggy_MaintainTime");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_MaintainTime, TargetChar) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcGroggy_MaintainTime::TargetChar' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_MaintainTime, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcGroggy_MaintainTime::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggy_MaintainTime, ReturnValue) == 0x000158, "Member 'LCalcStatFuncLibrary_CalcGroggy_MaintainTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcGroggyEnableTimeAdd
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPerfectGuard;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFuryAttack;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd");
static_assert(sizeof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd) == 0x000018, "Wrong size on LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd, IsPerfectGuard) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd::IsPerfectGuard' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd, IsFuryAttack) == 0x000011, "Member 'LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd::IsFuryAttack' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd, ReturnValue) == 0x000014, "Member 'LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcGuard_ConsumablePoint
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcGuard_ConsumablePoint final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcGuard_ConsumablePoint) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcGuard_ConsumablePoint");
static_assert(sizeof(LCalcStatFuncLibrary_CalcGuard_ConsumablePoint) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcGuard_ConsumablePoint");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_ConsumablePoint, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcGuard_ConsumablePoint::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_ConsumablePoint, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcGuard_ConsumablePoint::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_ConsumablePoint, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcGuard_ConsumablePoint::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_ConsumablePoint, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcGuard_ConsumablePoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcGuard_GuardHitDuration
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_CalcGuard_GuardHitDuration final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0158(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcGuard_GuardHitDuration) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcGuard_GuardHitDuration");
static_assert(sizeof(LCalcStatFuncLibrary_CalcGuard_GuardHitDuration) == 0x000160, "Wrong size on LCalcStatFuncLibrary_CalcGuard_GuardHitDuration");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_GuardHitDuration, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcGuard_GuardHitDuration::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_GuardHitDuration, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcGuard_GuardHitDuration::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_GuardHitDuration, ReturnValue) == 0x000158, "Member 'LCalcStatFuncLibrary_CalcGuard_GuardHitDuration::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcGuard_PenetrationPower
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_CalcGuard_PenetrationPower final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcGuard_PenetrationPower) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcGuard_PenetrationPower");
static_assert(sizeof(LCalcStatFuncLibrary_CalcGuard_PenetrationPower) == 0x000018, "Wrong size on LCalcStatFuncLibrary_CalcGuard_PenetrationPower");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_PenetrationPower, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcGuard_PenetrationPower::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_PenetrationPower, SkillHitCodeName) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcGuard_PenetrationPower::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcGuard_PenetrationPower, ReturnValue) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcGuard_PenetrationPower::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcHitIntensity
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcHitIntensity final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OutHitIntensity;                                   // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0164(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcHitIntensity) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcHitIntensity");
static_assert(sizeof(LCalcStatFuncLibrary_CalcHitIntensity) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcHitIntensity");
static_assert(offsetof(LCalcStatFuncLibrary_CalcHitIntensity, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcHitIntensity::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcHitIntensity, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcHitIntensity::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcHitIntensity, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcHitIntensity::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcHitIntensity, OutHitIntensity) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcHitIntensity::OutHitIntensity' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcHitIntensity, ReturnValue) == 0x000164, "Member 'LCalcStatFuncLibrary_CalcHitIntensity::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcParalyzation_ConsumablePoint
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint");
static_assert(sizeof(LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint");
static_assert(offsetof(LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcParalyzation_MaintainTime
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_CalcParalyzation_MaintainTime final
{
public:
	class AActor*                                 TargetChar;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcParalyzation_MaintainTime) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcParalyzation_MaintainTime");
static_assert(sizeof(LCalcStatFuncLibrary_CalcParalyzation_MaintainTime) == 0x000010, "Wrong size on LCalcStatFuncLibrary_CalcParalyzation_MaintainTime");
static_assert(offsetof(LCalcStatFuncLibrary_CalcParalyzation_MaintainTime, TargetChar) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcParalyzation_MaintainTime::TargetChar' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcParalyzation_MaintainTime, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcParalyzation_MaintainTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcPulseRechargePoint
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcPulseRechargePoint final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcPulseRechargePoint) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcPulseRechargePoint");
static_assert(sizeof(LCalcStatFuncLibrary_CalcPulseRechargePoint) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcPulseRechargePoint");
static_assert(offsetof(LCalcStatFuncLibrary_CalcPulseRechargePoint, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcPulseRechargePoint::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcPulseRechargePoint, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcPulseRechargePoint::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcPulseRechargePoint, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcPulseRechargePoint::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcPulseRechargePoint, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcPulseRechargePoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcRigidity
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_CalcRigidity final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               Weapon;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcRigidity) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcRigidity");
static_assert(sizeof(LCalcStatFuncLibrary_CalcRigidity) == 0x000018, "Wrong size on LCalcStatFuncLibrary_CalcRigidity");
static_assert(offsetof(LCalcStatFuncLibrary_CalcRigidity, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcRigidity::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcRigidity, Weapon) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcRigidity::Weapon' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcRigidity, ReturnValue) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcRigidity::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcTough_DamageFinal
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcTough_DamageFinal final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OutToughAttackDamage;                              // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0164(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_CalcTough_DamageFinal) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcTough_DamageFinal");
static_assert(sizeof(LCalcStatFuncLibrary_CalcTough_DamageFinal) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcTough_DamageFinal");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageFinal, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcTough_DamageFinal::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageFinal, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcTough_DamageFinal::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageFinal, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcTough_DamageFinal::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageFinal, OutToughAttackDamage) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcTough_DamageFinal::OutToughAttackDamage' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageFinal, ReturnValue) == 0x000164, "Member 'LCalcStatFuncLibrary_CalcTough_DamageFinal::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcTough_DamagePrimary
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcTough_DamagePrimary final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcTough_DamagePrimary) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcTough_DamagePrimary");
static_assert(sizeof(LCalcStatFuncLibrary_CalcTough_DamagePrimary) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcTough_DamagePrimary");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamagePrimary, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcTough_DamagePrimary::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamagePrimary, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcTough_DamagePrimary::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamagePrimary, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcTough_DamagePrimary::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamagePrimary, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcTough_DamagePrimary::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CalcTough_DamageSecondary
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_CalcTough_DamageSecondary final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CalcTough_DamageSecondary) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CalcTough_DamageSecondary");
static_assert(sizeof(LCalcStatFuncLibrary_CalcTough_DamageSecondary) == 0x000168, "Wrong size on LCalcStatFuncLibrary_CalcTough_DamageSecondary");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageSecondary, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CalcTough_DamageSecondary::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageSecondary, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CalcTough_DamageSecondary::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageSecondary, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_CalcTough_DamageSecondary::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CalcTough_DamageSecondary, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_CalcTough_DamageSecondary::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.CheckVictimInCounterEnableBP
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_CheckVictimInCounterEnableBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_CheckVictimInCounterEnableBP) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_CheckVictimInCounterEnableBP");
static_assert(sizeof(LCalcStatFuncLibrary_CheckVictimInCounterEnableBP) == 0x000018, "Wrong size on LCalcStatFuncLibrary_CheckVictimInCounterEnableBP");
static_assert(offsetof(LCalcStatFuncLibrary_CheckVictimInCounterEnableBP, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_CheckVictimInCounterEnableBP::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CheckVictimInCounterEnableBP, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_CheckVictimInCounterEnableBP::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CheckVictimInCounterEnableBP, Branches) == 0x000010, "Member 'LCalcStatFuncLibrary_CheckVictimInCounterEnableBP::Branches' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_CheckVictimInCounterEnableBP, ReturnValue) == 0x000011, "Member 'LCalcStatFuncLibrary_CheckVictimInCounterEnableBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetAttackRatio_by_Stat
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_GetAttackRatio_by_Stat final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          PhysicalDamageType;                                // 0x0158(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x015C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetAttackRatio_by_Stat) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetAttackRatio_by_Stat");
static_assert(sizeof(LCalcStatFuncLibrary_GetAttackRatio_by_Stat) == 0x000160, "Wrong size on LCalcStatFuncLibrary_GetAttackRatio_by_Stat");
static_assert(offsetof(LCalcStatFuncLibrary_GetAttackRatio_by_Stat, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_GetAttackRatio_by_Stat::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetAttackRatio_by_Stat, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_GetAttackRatio_by_Stat::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetAttackRatio_by_Stat, PhysicalDamageType) == 0x000158, "Member 'LCalcStatFuncLibrary_GetAttackRatio_by_Stat::PhysicalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetAttackRatio_by_Stat, ReturnValue) == 0x00015C, "Member 'LCalcStatFuncLibrary_GetAttackRatio_by_Stat::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetCharacterElementalAttack
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_GetCharacterElementalAttack final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalDamageType;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetCharacterElementalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetCharacterElementalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetCharacterElementalAttack) == 0x000018, "Wrong size on LCalcStatFuncLibrary_GetCharacterElementalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalAttack, Character) == 0x000000, "Member 'LCalcStatFuncLibrary_GetCharacterElementalAttack::Character' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalAttack, SkillHitCodeName) == 0x000008, "Member 'LCalcStatFuncLibrary_GetCharacterElementalAttack::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalAttack, ElementalDamageType) == 0x000010, "Member 'LCalcStatFuncLibrary_GetCharacterElementalAttack::ElementalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalAttack, ReturnValue) == 0x000014, "Member 'LCalcStatFuncLibrary_GetCharacterElementalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetCharacterElementalDefence
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetCharacterElementalDefence final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalDamageType;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetCharacterElementalDefence) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetCharacterElementalDefence");
static_assert(sizeof(LCalcStatFuncLibrary_GetCharacterElementalDefence) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetCharacterElementalDefence");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalDefence, Character) == 0x000000, "Member 'LCalcStatFuncLibrary_GetCharacterElementalDefence::Character' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalDefence, ElementalDamageType) == 0x000008, "Member 'LCalcStatFuncLibrary_GetCharacterElementalDefence::ElementalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterElementalDefence, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_GetCharacterElementalDefence::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetCharacterPhysicalAttack
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_GetCharacterPhysicalAttack final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          PhysicalDamageType;                                // 0x0158(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x015C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetCharacterPhysicalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetCharacterPhysicalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetCharacterPhysicalAttack) == 0x000160, "Wrong size on LCalcStatFuncLibrary_GetCharacterPhysicalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalAttack, Character) == 0x000000, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalAttack::Character' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalAttack, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalAttack::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalAttack, PhysicalDamageType) == 0x000158, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalAttack::PhysicalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalAttack, ReturnValue) == 0x00015C, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetCharacterPhysicalDefence
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetCharacterPhysicalDefence final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          PhysicalDamageType;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetCharacterPhysicalDefence) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetCharacterPhysicalDefence");
static_assert(sizeof(LCalcStatFuncLibrary_GetCharacterPhysicalDefence) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetCharacterPhysicalDefence");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalDefence, Character) == 0x000000, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalDefence::Character' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalDefence, PhysicalDamageType) == 0x000008, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalDefence::PhysicalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetCharacterPhysicalDefence, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_GetCharacterPhysicalDefence::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetDestructionPower
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_GetDestructionPower final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0158(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetDestructionPower) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetDestructionPower");
static_assert(sizeof(LCalcStatFuncLibrary_GetDestructionPower) == 0x000160, "Wrong size on LCalcStatFuncLibrary_GetDestructionPower");
static_assert(offsetof(LCalcStatFuncLibrary_GetDestructionPower, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_GetDestructionPower::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetDestructionPower, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_GetDestructionPower::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetDestructionPower, ReturnValue) == 0x000158, "Member 'LCalcStatFuncLibrary_GetDestructionPower::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetDynamicDamageVolumeElementalAttack
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack final
{
public:
	class ALDynamicDamageVolumeActor*             DynamicDamageVolume;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack, DynamicDamageVolume) == 0x000000, "Member 'LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack::DynamicDamageVolume' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack, ElementalType) == 0x000008, "Member 'LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack::ElementalType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetDynamicDamageVolumePhysicalAttack
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack final
{
public:
	class ALDynamicDamageVolumeActor*             DynamicDamageVolume;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack, DynamicDamageVolume) == 0x000000, "Member 'LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack::DynamicDamageVolume' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetFirstStat
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetFirstStat final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFirstStatDataType                           DataType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFirstStat                                   StatType;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVirtual;                                         // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetFirstStat) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetFirstStat");
static_assert(sizeof(LCalcStatFuncLibrary_GetFirstStat) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetFirstStat");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStat, WorldContextObject) == 0x000000, "Member 'LCalcStatFuncLibrary_GetFirstStat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStat, DataType) == 0x000008, "Member 'LCalcStatFuncLibrary_GetFirstStat::DataType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStat, StatType) == 0x000009, "Member 'LCalcStatFuncLibrary_GetFirstStat::StatType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStat, IsVirtual) == 0x00000A, "Member 'LCalcStatFuncLibrary_GetFirstStat::IsVirtual' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStat, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_GetFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetFirstStatDataList
// 0x0020 (0x0020 - 0x0000)
struct LCalcStatFuncLibrary_GetFirstStatDataList final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVirtual;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFirstStatData>                ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetFirstStatDataList) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetFirstStatDataList");
static_assert(sizeof(LCalcStatFuncLibrary_GetFirstStatDataList) == 0x000020, "Wrong size on LCalcStatFuncLibrary_GetFirstStatDataList");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStatDataList, WorldContextObject) == 0x000000, "Member 'LCalcStatFuncLibrary_GetFirstStatDataList::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStatDataList, IsVirtual) == 0x000008, "Member 'LCalcStatFuncLibrary_GetFirstStatDataList::IsVirtual' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetFirstStatDataList, ReturnValue) == 0x000010, "Member 'LCalcStatFuncLibrary_GetFirstStatDataList::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetGuardPoint
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetGuardPoint final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetGuardPoint) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetGuardPoint");
static_assert(sizeof(LCalcStatFuncLibrary_GetGuardPoint) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetGuardPoint");
static_assert(offsetof(LCalcStatFuncLibrary_GetGuardPoint, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_GetGuardPoint::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetGuardPoint, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_GetGuardPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetProjectileElementalAttack
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetProjectileElementalAttack final
{
public:
	class ALProjectile*                           Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetProjectileElementalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetProjectileElementalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetProjectileElementalAttack) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetProjectileElementalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetProjectileElementalAttack, Projectile) == 0x000000, "Member 'LCalcStatFuncLibrary_GetProjectileElementalAttack::Projectile' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetProjectileElementalAttack, ElementalType) == 0x000008, "Member 'LCalcStatFuncLibrary_GetProjectileElementalAttack::ElementalType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetProjectileElementalAttack, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_GetProjectileElementalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetProjectilePhysicalAttack
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetProjectilePhysicalAttack final
{
public:
	class ALProjectile*                           Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetProjectilePhysicalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetProjectilePhysicalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetProjectilePhysicalAttack) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetProjectilePhysicalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetProjectilePhysicalAttack, Projectile) == 0x000000, "Member 'LCalcStatFuncLibrary_GetProjectilePhysicalAttack::Projectile' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetProjectilePhysicalAttack, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_GetProjectilePhysicalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetPulseRechargePointMax
// 0x0008 (0x0008 - 0x0000)
struct LCalcStatFuncLibrary_GetPulseRechargePointMax final
{
public:
	int32                                         RechargeCount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetPulseRechargePointMax) == 0x000004, "Wrong alignment on LCalcStatFuncLibrary_GetPulseRechargePointMax");
static_assert(sizeof(LCalcStatFuncLibrary_GetPulseRechargePointMax) == 0x000008, "Wrong size on LCalcStatFuncLibrary_GetPulseRechargePointMax");
static_assert(offsetof(LCalcStatFuncLibrary_GetPulseRechargePointMax, RechargeCount) == 0x000000, "Member 'LCalcStatFuncLibrary_GetPulseRechargePointMax::RechargeCount' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetPulseRechargePointMax, ReturnValue) == 0x000004, "Member 'LCalcStatFuncLibrary_GetPulseRechargePointMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetSlaveArmElementalAttack
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetSlaveArmElementalAttack final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetSlaveArmElementalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetSlaveArmElementalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetSlaveArmElementalAttack) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetSlaveArmElementalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetSlaveArmElementalAttack, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_GetSlaveArmElementalAttack::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetSlaveArmElementalAttack, ElementalType) == 0x000008, "Member 'LCalcStatFuncLibrary_GetSlaveArmElementalAttack::ElementalType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetSlaveArmElementalAttack, ReturnValue) == 0x00000C, "Member 'LCalcStatFuncLibrary_GetSlaveArmElementalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetSlaveArmPhysicalAttack
// 0x0010 (0x0010 - 0x0000)
struct LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack) == 0x000010, "Wrong size on LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack, ReturnValue) == 0x000008, "Member 'LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetSpecialBuffAttackMultiplier
// 0x0168 (0x0168 - 0x0000)
struct LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0160(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier");
static_assert(sizeof(LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier) == 0x000168, "Wrong size on LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier");
static_assert(offsetof(LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier, Victim) == 0x000008, "Member 'LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier::Victim' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier, HitInfo) == 0x000010, "Member 'LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier, ReturnValue) == 0x000160, "Member 'LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetStatComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_GetStatComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULStatComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetStatComponentBP) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetStatComponentBP");
static_assert(sizeof(LCalcStatFuncLibrary_GetStatComponentBP) == 0x000018, "Wrong size on LCalcStatFuncLibrary_GetStatComponentBP");
static_assert(offsetof(LCalcStatFuncLibrary_GetStatComponentBP, TargetActor) == 0x000000, "Member 'LCalcStatFuncLibrary_GetStatComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetStatComponentBP, Branches) == 0x000008, "Member 'LCalcStatFuncLibrary_GetStatComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetStatComponentBP, ReturnValue) == 0x000010, "Member 'LCalcStatFuncLibrary_GetStatComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetTotalDamage
// 0x0118 (0x0118 - 0x0000)
struct LCalcStatFuncLibrary_GetTotalDamage final
{
public:
	struct FLCalcDamageData                       CalcDamageData;                                    // 0x0000(0x0110)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0110(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_GetTotalDamage) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetTotalDamage");
static_assert(sizeof(LCalcStatFuncLibrary_GetTotalDamage) == 0x000118, "Wrong size on LCalcStatFuncLibrary_GetTotalDamage");
static_assert(offsetof(LCalcStatFuncLibrary_GetTotalDamage, CalcDamageData) == 0x000000, "Member 'LCalcStatFuncLibrary_GetTotalDamage::CalcDamageData' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetTotalDamage, ReturnValue) == 0x000110, "Member 'LCalcStatFuncLibrary_GetTotalDamage::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetWeaponSkillElementalAttack
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_GetWeaponSkillElementalAttack final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               AttackerWeapon;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalDamageType;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetWeaponSkillElementalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetWeaponSkillElementalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetWeaponSkillElementalAttack) == 0x000018, "Wrong size on LCalcStatFuncLibrary_GetWeaponSkillElementalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillElementalAttack, Character) == 0x000000, "Member 'LCalcStatFuncLibrary_GetWeaponSkillElementalAttack::Character' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillElementalAttack, AttackerWeapon) == 0x000008, "Member 'LCalcStatFuncLibrary_GetWeaponSkillElementalAttack::AttackerWeapon' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillElementalAttack, ElementalDamageType) == 0x000010, "Member 'LCalcStatFuncLibrary_GetWeaponSkillElementalAttack::ElementalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillElementalAttack, ReturnValue) == 0x000014, "Member 'LCalcStatFuncLibrary_GetWeaponSkillElementalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.GetWeaponSkillPhysicalAttack
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               AttackerWeapon;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          PhysicalDamageType;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack) == 0x000018, "Wrong size on LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack, Character) == 0x000000, "Member 'LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack::Character' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack, AttackerWeapon) == 0x000008, "Member 'LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack::AttackerWeapon' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack, PhysicalDamageType) == 0x000010, "Member 'LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack::PhysicalDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack, ReturnValue) == 0x000014, "Member 'LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.HasElementDamage
// 0x0118 (0x0118 - 0x0000)
struct LCalcStatFuncLibrary_HasElementDamage final
{
public:
	struct FLCalcDamageData                       CalcDamageData;                                    // 0x0000(0x0110)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementDamageType;                                 // 0x0110(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0111(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_HasElementDamage) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_HasElementDamage");
static_assert(sizeof(LCalcStatFuncLibrary_HasElementDamage) == 0x000118, "Wrong size on LCalcStatFuncLibrary_HasElementDamage");
static_assert(offsetof(LCalcStatFuncLibrary_HasElementDamage, CalcDamageData) == 0x000000, "Member 'LCalcStatFuncLibrary_HasElementDamage::CalcDamageData' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_HasElementDamage, ElementDamageType) == 0x000110, "Member 'LCalcStatFuncLibrary_HasElementDamage::ElementDamageType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_HasElementDamage, ReturnValue) == 0x000111, "Member 'LCalcStatFuncLibrary_HasElementDamage::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.IsElementalAttack
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_IsElementalAttack final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalType;                                     // 0x0158(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0159(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_IsElementalAttack) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_IsElementalAttack");
static_assert(sizeof(LCalcStatFuncLibrary_IsElementalAttack) == 0x000160, "Wrong size on LCalcStatFuncLibrary_IsElementalAttack");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_IsElementalAttack::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_IsElementalAttack::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack, ElementalType) == 0x000158, "Member 'LCalcStatFuncLibrary_IsElementalAttack::ElementalType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack, ReturnValue) == 0x000159, "Member 'LCalcStatFuncLibrary_IsElementalAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.IsElementalAttack_Impl
// 0x0020 (0x0020 - 0x0000)
struct LCalcStatFuncLibrary_IsElementalAttack_Impl final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               AttackerWeapon;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           ElementalType;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_IsElementalAttack_Impl) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_IsElementalAttack_Impl");
static_assert(sizeof(LCalcStatFuncLibrary_IsElementalAttack_Impl) == 0x000020, "Wrong size on LCalcStatFuncLibrary_IsElementalAttack_Impl");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack_Impl, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_IsElementalAttack_Impl::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack_Impl, SkillHitCodeName) == 0x000008, "Member 'LCalcStatFuncLibrary_IsElementalAttack_Impl::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack_Impl, AttackerWeapon) == 0x000010, "Member 'LCalcStatFuncLibrary_IsElementalAttack_Impl::AttackerWeapon' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack_Impl, ElementalType) == 0x000018, "Member 'LCalcStatFuncLibrary_IsElementalAttack_Impl::ElementalType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_IsElementalAttack_Impl, ReturnValue) == 0x000019, "Member 'LCalcStatFuncLibrary_IsElementalAttack_Impl::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.PickPhysicalDamagedType
// 0x0160 (0x0160 - 0x0000)
struct LCalcStatFuncLibrary_PickPhysicalDamagedType final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0008(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          ReturnValue;                                       // 0x0158(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_PickPhysicalDamagedType) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_PickPhysicalDamagedType");
static_assert(sizeof(LCalcStatFuncLibrary_PickPhysicalDamagedType) == 0x000160, "Wrong size on LCalcStatFuncLibrary_PickPhysicalDamagedType");
static_assert(offsetof(LCalcStatFuncLibrary_PickPhysicalDamagedType, Attacker) == 0x000000, "Member 'LCalcStatFuncLibrary_PickPhysicalDamagedType::Attacker' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_PickPhysicalDamagedType, HitInfo) == 0x000008, "Member 'LCalcStatFuncLibrary_PickPhysicalDamagedType::HitInfo' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_PickPhysicalDamagedType, ReturnValue) == 0x000158, "Member 'LCalcStatFuncLibrary_PickPhysicalDamagedType::ReturnValue' has a wrong offset!");

// Function ProjectP.LCalcStatFuncLibrary.Test_ApplyCharacterStat
// 0x0018 (0x0018 - 0x0000)
struct LCalcStatFuncLibrary_Test_ApplyCharacterStat final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  StatType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputStat;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyMax;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Broadcast;                                         // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCalcStatFuncLibrary_Test_ApplyCharacterStat) == 0x000008, "Wrong alignment on LCalcStatFuncLibrary_Test_ApplyCharacterStat");
static_assert(sizeof(LCalcStatFuncLibrary_Test_ApplyCharacterStat) == 0x000018, "Wrong size on LCalcStatFuncLibrary_Test_ApplyCharacterStat");
static_assert(offsetof(LCalcStatFuncLibrary_Test_ApplyCharacterStat, Target) == 0x000000, "Member 'LCalcStatFuncLibrary_Test_ApplyCharacterStat::Target' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_Test_ApplyCharacterStat, StatType) == 0x000008, "Member 'LCalcStatFuncLibrary_Test_ApplyCharacterStat::StatType' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_Test_ApplyCharacterStat, InputStat) == 0x00000C, "Member 'LCalcStatFuncLibrary_Test_ApplyCharacterStat::InputStat' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_Test_ApplyCharacterStat, ApplyMax) == 0x000010, "Member 'LCalcStatFuncLibrary_Test_ApplyCharacterStat::ApplyMax' has a wrong offset!");
static_assert(offsetof(LCalcStatFuncLibrary_Test_ApplyCharacterStat, Broadcast) == 0x000011, "Member 'LCalcStatFuncLibrary_Test_ApplyCharacterStat::Broadcast' has a wrong offset!");

// Function ProjectP.LCameraManager.DestoryCameraWork
// 0x0008 (0x0008 - 0x0000)
struct LCameraManager_DestoryCameraWork final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_DestoryCameraWork) == 0x000008, "Wrong alignment on LCameraManager_DestoryCameraWork");
static_assert(sizeof(LCameraManager_DestoryCameraWork) == 0x000008, "Wrong size on LCameraManager_DestoryCameraWork");
static_assert(offsetof(LCameraManager_DestoryCameraWork, CameraWork) == 0x000000, "Member 'LCameraManager_DestoryCameraWork::CameraWork' has a wrong offset!");

// Function ProjectP.LCameraManager.EnableMoveCameraUpDown
// 0x0001 (0x0001 - 0x0000)
struct LCameraManager_EnableMoveCameraUpDown final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_EnableMoveCameraUpDown) == 0x000001, "Wrong alignment on LCameraManager_EnableMoveCameraUpDown");
static_assert(sizeof(LCameraManager_EnableMoveCameraUpDown) == 0x000001, "Wrong size on LCameraManager_EnableMoveCameraUpDown");
static_assert(offsetof(LCameraManager_EnableMoveCameraUpDown, bEnable) == 0x000000, "Member 'LCameraManager_EnableMoveCameraUpDown::bEnable' has a wrong offset!");

// Function ProjectP.LCameraManager.EnableShoulderView
// 0x0014 (0x0014 - 0x0000)
struct LCameraManager_EnableShoulderView final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_EnableShoulderView) == 0x000004, "Wrong alignment on LCameraManager_EnableShoulderView");
static_assert(sizeof(LCameraManager_EnableShoulderView) == 0x000014, "Wrong size on LCameraManager_EnableShoulderView");
static_assert(offsetof(LCameraManager_EnableShoulderView, Offset) == 0x000000, "Member 'LCameraManager_EnableShoulderView::Offset' has a wrong offset!");
static_assert(offsetof(LCameraManager_EnableShoulderView, BlendInTime) == 0x00000C, "Member 'LCameraManager_EnableShoulderView::BlendInTime' has a wrong offset!");
static_assert(offsetof(LCameraManager_EnableShoulderView, BlendOutTime) == 0x000010, "Member 'LCameraManager_EnableShoulderView::BlendOutTime' has a wrong offset!");

// Function ProjectP.LCameraManager.GetBasicCameraRotation
// 0x000C (0x000C - 0x0000)
struct LCameraManager_GetBasicCameraRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_GetBasicCameraRotation) == 0x000004, "Wrong alignment on LCameraManager_GetBasicCameraRotation");
static_assert(sizeof(LCameraManager_GetBasicCameraRotation) == 0x00000C, "Wrong size on LCameraManager_GetBasicCameraRotation");
static_assert(offsetof(LCameraManager_GetBasicCameraRotation, ReturnValue) == 0x000000, "Member 'LCameraManager_GetBasicCameraRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraManager.NewCameraWork
// 0x0010 (0x0010 - 0x0000)
struct LCameraManager_NewCameraWork final
{
public:
	class FName                                   CameraWorkName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALCameraWork*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_NewCameraWork) == 0x000008, "Wrong alignment on LCameraManager_NewCameraWork");
static_assert(sizeof(LCameraManager_NewCameraWork) == 0x000010, "Wrong size on LCameraManager_NewCameraWork");
static_assert(offsetof(LCameraManager_NewCameraWork, CameraWorkName) == 0x000000, "Member 'LCameraManager_NewCameraWork::CameraWorkName' has a wrong offset!");
static_assert(offsetof(LCameraManager_NewCameraWork, ReturnValue) == 0x000008, "Member 'LCameraManager_NewCameraWork::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraManager.OnStopWorkFinish
// 0x0008 (0x0008 - 0x0000)
struct LCameraManager_OnStopWorkFinish final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_OnStopWorkFinish) == 0x000008, "Wrong alignment on LCameraManager_OnStopWorkFinish");
static_assert(sizeof(LCameraManager_OnStopWorkFinish) == 0x000008, "Wrong size on LCameraManager_OnStopWorkFinish");
static_assert(offsetof(LCameraManager_OnStopWorkFinish, CameraWork) == 0x000000, "Member 'LCameraManager_OnStopWorkFinish::CameraWork' has a wrong offset!");

// Function ProjectP.LCameraManager.PlayCameraWork
// 0x0050 (0x0050 - 0x0000)
struct LCameraManager_PlayCameraWork final
{
public:
	class FName                                   CameraWorkName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ObjectContext;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TransformContext;                                  // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALCameraWork*                           ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_PlayCameraWork) == 0x000010, "Wrong alignment on LCameraManager_PlayCameraWork");
static_assert(sizeof(LCameraManager_PlayCameraWork) == 0x000050, "Wrong size on LCameraManager_PlayCameraWork");
static_assert(offsetof(LCameraManager_PlayCameraWork, CameraWorkName) == 0x000000, "Member 'LCameraManager_PlayCameraWork::CameraWorkName' has a wrong offset!");
static_assert(offsetof(LCameraManager_PlayCameraWork, ObjectContext) == 0x000008, "Member 'LCameraManager_PlayCameraWork::ObjectContext' has a wrong offset!");
static_assert(offsetof(LCameraManager_PlayCameraWork, TransformContext) == 0x000010, "Member 'LCameraManager_PlayCameraWork::TransformContext' has a wrong offset!");
static_assert(offsetof(LCameraManager_PlayCameraWork, DurationTime) == 0x000040, "Member 'LCameraManager_PlayCameraWork::DurationTime' has a wrong offset!");
static_assert(offsetof(LCameraManager_PlayCameraWork, ReturnValue) == 0x000048, "Member 'LCameraManager_PlayCameraWork::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraManager.RegisterCameraWork
// 0x0008 (0x0008 - 0x0000)
struct LCameraManager_RegisterCameraWork final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_RegisterCameraWork) == 0x000008, "Wrong alignment on LCameraManager_RegisterCameraWork");
static_assert(sizeof(LCameraManager_RegisterCameraWork) == 0x000008, "Wrong size on LCameraManager_RegisterCameraWork");
static_assert(offsetof(LCameraManager_RegisterCameraWork, CameraWork) == 0x000000, "Member 'LCameraManager_RegisterCameraWork::CameraWork' has a wrong offset!");

// Function ProjectP.LCameraManager.ResetAllModifiers
// 0x0008 (0x0008 - 0x0000)
struct LCameraManager_ResetAllModifiers final
{
public:
	class UObject*                                InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_ResetAllModifiers) == 0x000008, "Wrong alignment on LCameraManager_ResetAllModifiers");
static_assert(sizeof(LCameraManager_ResetAllModifiers) == 0x000008, "Wrong size on LCameraManager_ResetAllModifiers");
static_assert(offsetof(LCameraManager_ResetAllModifiers, InInstigator) == 0x000000, "Member 'LCameraManager_ResetAllModifiers::InInstigator' has a wrong offset!");

// Function ProjectP.LCameraManager.ResetCameraDistanceModifier
// 0x0008 (0x0008 - 0x0000)
struct LCameraManager_ResetCameraDistanceModifier final
{
public:
	class UObject*                                InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_ResetCameraDistanceModifier) == 0x000008, "Wrong alignment on LCameraManager_ResetCameraDistanceModifier");
static_assert(sizeof(LCameraManager_ResetCameraDistanceModifier) == 0x000008, "Wrong size on LCameraManager_ResetCameraDistanceModifier");
static_assert(offsetof(LCameraManager_ResetCameraDistanceModifier, InInstigator) == 0x000000, "Member 'LCameraManager_ResetCameraDistanceModifier::InInstigator' has a wrong offset!");

// Function ProjectP.LCameraManager.ResetCameraLagSpeedModifier
// 0x0010 (0x0010 - 0x0000)
struct LCameraManager_ResetCameraLagSpeedModifier final
{
public:
	struct FLCameraAttrModifierID                 ModifierID;                                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_ResetCameraLagSpeedModifier) == 0x000004, "Wrong alignment on LCameraManager_ResetCameraLagSpeedModifier");
static_assert(sizeof(LCameraManager_ResetCameraLagSpeedModifier) == 0x000010, "Wrong size on LCameraManager_ResetCameraLagSpeedModifier");
static_assert(offsetof(LCameraManager_ResetCameraLagSpeedModifier, ModifierID) == 0x000000, "Member 'LCameraManager_ResetCameraLagSpeedModifier::ModifierID' has a wrong offset!");

// Function ProjectP.LCameraManager.ResetCameraRotationLagSpeedModifier
// 0x0010 (0x0010 - 0x0000)
struct LCameraManager_ResetCameraRotationLagSpeedModifier final
{
public:
	struct FLCameraAttrModifierID                 ModifierID;                                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_ResetCameraRotationLagSpeedModifier) == 0x000004, "Wrong alignment on LCameraManager_ResetCameraRotationLagSpeedModifier");
static_assert(sizeof(LCameraManager_ResetCameraRotationLagSpeedModifier) == 0x000010, "Wrong size on LCameraManager_ResetCameraRotationLagSpeedModifier");
static_assert(offsetof(LCameraManager_ResetCameraRotationLagSpeedModifier, ModifierID) == 0x000000, "Member 'LCameraManager_ResetCameraRotationLagSpeedModifier::ModifierID' has a wrong offset!");

// Function ProjectP.LCameraManager.ResetLocationOffsetModifier
// 0x0010 (0x0010 - 0x0000)
struct LCameraManager_ResetLocationOffsetModifier final
{
public:
	struct FLCameraAttrModifierID                 ModifierID;                                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_ResetLocationOffsetModifier) == 0x000004, "Wrong alignment on LCameraManager_ResetLocationOffsetModifier");
static_assert(sizeof(LCameraManager_ResetLocationOffsetModifier) == 0x000010, "Wrong size on LCameraManager_ResetLocationOffsetModifier");
static_assert(offsetof(LCameraManager_ResetLocationOffsetModifier, ModifierID) == 0x000000, "Member 'LCameraManager_ResetLocationOffsetModifier::ModifierID' has a wrong offset!");

// Function ProjectP.LCameraManager.SetCameraDistanceModifier
// 0x0010 (0x0010 - 0x0000)
struct LCameraManager_SetCameraDistanceModifier final
{
public:
	class UObject*                                InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCameraModifierPriority                      Priority;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraManager_SetCameraDistanceModifier) == 0x000008, "Wrong alignment on LCameraManager_SetCameraDistanceModifier");
static_assert(sizeof(LCameraManager_SetCameraDistanceModifier) == 0x000010, "Wrong size on LCameraManager_SetCameraDistanceModifier");
static_assert(offsetof(LCameraManager_SetCameraDistanceModifier, InInstigator) == 0x000000, "Member 'LCameraManager_SetCameraDistanceModifier::InInstigator' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraDistanceModifier, Distance) == 0x000008, "Member 'LCameraManager_SetCameraDistanceModifier::Distance' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraDistanceModifier, Priority) == 0x00000C, "Member 'LCameraManager_SetCameraDistanceModifier::Priority' has a wrong offset!");

// Function ProjectP.LCameraManager.SetCameraLagSpeedModifier
// 0x0020 (0x0020 - 0x0000)
struct LCameraManager_SetCameraLagSpeedModifier final
{
public:
	struct FLCameraAttrModifierID                 ModifierID;                                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraLagSpeed;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCameraModifierPriority                      Priority;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCameraAttrModifierBlendTime          BlendTime;                                         // 0x0018(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetCameraLagSpeedModifier) == 0x000004, "Wrong alignment on LCameraManager_SetCameraLagSpeedModifier");
static_assert(sizeof(LCameraManager_SetCameraLagSpeedModifier) == 0x000020, "Wrong size on LCameraManager_SetCameraLagSpeedModifier");
static_assert(offsetof(LCameraManager_SetCameraLagSpeedModifier, ModifierID) == 0x000000, "Member 'LCameraManager_SetCameraLagSpeedModifier::ModifierID' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraLagSpeedModifier, CameraLagSpeed) == 0x000010, "Member 'LCameraManager_SetCameraLagSpeedModifier::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraLagSpeedModifier, Priority) == 0x000014, "Member 'LCameraManager_SetCameraLagSpeedModifier::Priority' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraLagSpeedModifier, BlendTime) == 0x000018, "Member 'LCameraManager_SetCameraLagSpeedModifier::BlendTime' has a wrong offset!");

// Function ProjectP.LCameraManager.SetCameraRotationLagSpeedModifier
// 0x0020 (0x0020 - 0x0000)
struct LCameraManager_SetCameraRotationLagSpeedModifier final
{
public:
	struct FLCameraAttrModifierID                 ModifierID;                                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed_0;                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCameraModifierPriority                      Priority;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCameraAttrModifierBlendTime          BlendTime;                                         // 0x0018(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetCameraRotationLagSpeedModifier) == 0x000004, "Wrong alignment on LCameraManager_SetCameraRotationLagSpeedModifier");
static_assert(sizeof(LCameraManager_SetCameraRotationLagSpeedModifier) == 0x000020, "Wrong size on LCameraManager_SetCameraRotationLagSpeedModifier");
static_assert(offsetof(LCameraManager_SetCameraRotationLagSpeedModifier, ModifierID) == 0x000000, "Member 'LCameraManager_SetCameraRotationLagSpeedModifier::ModifierID' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraRotationLagSpeedModifier, CameraRotationLagSpeed_0) == 0x000010, "Member 'LCameraManager_SetCameraRotationLagSpeedModifier::CameraRotationLagSpeed_0' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraRotationLagSpeedModifier, Priority) == 0x000014, "Member 'LCameraManager_SetCameraRotationLagSpeedModifier::Priority' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCameraRotationLagSpeedModifier, BlendTime) == 0x000018, "Member 'LCameraManager_SetCameraRotationLagSpeedModifier::BlendTime' has a wrong offset!");

// Function ProjectP.LCameraManager.SetCharacterFastMovement
// 0x0001 (0x0001 - 0x0000)
struct LCameraManager_SetCharacterFastMovement final
{
public:
	bool                                          bFastMovement;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetCharacterFastMovement) == 0x000001, "Wrong alignment on LCameraManager_SetCharacterFastMovement");
static_assert(sizeof(LCameraManager_SetCharacterFastMovement) == 0x000001, "Wrong size on LCameraManager_SetCharacterFastMovement");
static_assert(offsetof(LCameraManager_SetCharacterFastMovement, bFastMovement) == 0x000000, "Member 'LCameraManager_SetCharacterFastMovement::bFastMovement' has a wrong offset!");

// Function ProjectP.LCameraManager.SetCineCamera
// 0x0002 (0x0002 - 0x0000)
struct LCameraManager_SetCineCamera final
{
public:
	bool                                          bAlignToCineCamera;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignToPlayerBack;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetCineCamera) == 0x000001, "Wrong alignment on LCameraManager_SetCineCamera");
static_assert(sizeof(LCameraManager_SetCineCamera) == 0x000002, "Wrong size on LCameraManager_SetCineCamera");
static_assert(offsetof(LCameraManager_SetCineCamera, bAlignToCineCamera) == 0x000000, "Member 'LCameraManager_SetCineCamera::bAlignToCineCamera' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetCineCamera, bAlignToPlayerBack) == 0x000001, "Member 'LCameraManager_SetCineCamera::bAlignToPlayerBack' has a wrong offset!");

// Function ProjectP.LCameraManager.SetCinematicPlay
// 0x0001 (0x0001 - 0x0000)
struct LCameraManager_SetCinematicPlay final
{
public:
	bool                                          bPlaying;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetCinematicPlay) == 0x000001, "Wrong alignment on LCameraManager_SetCinematicPlay");
static_assert(sizeof(LCameraManager_SetCinematicPlay) == 0x000001, "Wrong size on LCameraManager_SetCinematicPlay");
static_assert(offsetof(LCameraManager_SetCinematicPlay, bPlaying) == 0x000000, "Member 'LCameraManager_SetCinematicPlay::bPlaying' has a wrong offset!");

// Function ProjectP.LCameraManager.SetControlRotation
// 0x000C (0x000C - 0x0000)
struct LCameraManager_SetControlRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetControlRotation) == 0x000004, "Wrong alignment on LCameraManager_SetControlRotation");
static_assert(sizeof(LCameraManager_SetControlRotation) == 0x00000C, "Wrong size on LCameraManager_SetControlRotation");
static_assert(offsetof(LCameraManager_SetControlRotation, Rotation) == 0x000000, "Member 'LCameraManager_SetControlRotation::Rotation' has a wrong offset!");

// Function ProjectP.LCameraManager.SetControlRotationSmooth
// 0x000C (0x000C - 0x0000)
struct LCameraManager_SetControlRotationSmooth final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetControlRotationSmooth) == 0x000004, "Wrong alignment on LCameraManager_SetControlRotationSmooth");
static_assert(sizeof(LCameraManager_SetControlRotationSmooth) == 0x00000C, "Wrong size on LCameraManager_SetControlRotationSmooth");
static_assert(offsetof(LCameraManager_SetControlRotationSmooth, Rotation) == 0x000000, "Member 'LCameraManager_SetControlRotationSmooth::Rotation' has a wrong offset!");

// Function ProjectP.LCameraManager.SetDialogCamera
// 0x0001 (0x0001 - 0x0000)
struct LCameraManager_SetDialogCamera final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetDialogCamera) == 0x000001, "Wrong alignment on LCameraManager_SetDialogCamera");
static_assert(sizeof(LCameraManager_SetDialogCamera) == 0x000001, "Wrong size on LCameraManager_SetDialogCamera");
static_assert(offsetof(LCameraManager_SetDialogCamera, bEnable) == 0x000000, "Member 'LCameraManager_SetDialogCamera::bEnable' has a wrong offset!");

// Function ProjectP.LCameraManager.SetFollowingCamera
// 0x0001 (0x0001 - 0x0000)
struct LCameraManager_SetFollowingCamera final
{
public:
	bool                                          bFollowing;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetFollowingCamera) == 0x000001, "Wrong alignment on LCameraManager_SetFollowingCamera");
static_assert(sizeof(LCameraManager_SetFollowingCamera) == 0x000001, "Wrong size on LCameraManager_SetFollowingCamera");
static_assert(offsetof(LCameraManager_SetFollowingCamera, bFollowing) == 0x000000, "Member 'LCameraManager_SetFollowingCamera::bFollowing' has a wrong offset!");

// Function ProjectP.LCameraManager.SetLadderCamera
// 0x0001 (0x0001 - 0x0000)
struct LCameraManager_SetLadderCamera final
{
public:
	bool                                          bLadderCamera;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetLadderCamera) == 0x000001, "Wrong alignment on LCameraManager_SetLadderCamera");
static_assert(sizeof(LCameraManager_SetLadderCamera) == 0x000001, "Wrong size on LCameraManager_SetLadderCamera");
static_assert(offsetof(LCameraManager_SetLadderCamera, bLadderCamera) == 0x000000, "Member 'LCameraManager_SetLadderCamera::bLadderCamera' has a wrong offset!");

// Function ProjectP.LCameraManager.SetLocationOffsetModifier
// 0x0028 (0x0028 - 0x0000)
struct LCameraManager_SetLocationOffsetModifier final
{
public:
	struct FLCameraAttrModifierID                 ModifierID;                                        // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCameraModifierPriority                      Priority;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCameraAttrModifierBlendTime          BlendTime;                                         // 0x0020(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SetLocationOffsetModifier) == 0x000004, "Wrong alignment on LCameraManager_SetLocationOffsetModifier");
static_assert(sizeof(LCameraManager_SetLocationOffsetModifier) == 0x000028, "Wrong size on LCameraManager_SetLocationOffsetModifier");
static_assert(offsetof(LCameraManager_SetLocationOffsetModifier, ModifierID) == 0x000000, "Member 'LCameraManager_SetLocationOffsetModifier::ModifierID' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetLocationOffsetModifier, LocationOffset) == 0x000010, "Member 'LCameraManager_SetLocationOffsetModifier::LocationOffset' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetLocationOffsetModifier, Priority) == 0x00001C, "Member 'LCameraManager_SetLocationOffsetModifier::Priority' has a wrong offset!");
static_assert(offsetof(LCameraManager_SetLocationOffsetModifier, BlendTime) == 0x000020, "Member 'LCameraManager_SetLocationOffsetModifier::BlendTime' has a wrong offset!");

// Function ProjectP.LCameraManager.SpawnCameraWorkByName
// 0x0010 (0x0010 - 0x0000)
struct LCameraManager_SpawnCameraWorkByName final
{
public:
	class FName                                   CameraWorkName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALCameraWork*                           CameraWork;                                        // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_SpawnCameraWorkByName) == 0x000008, "Wrong alignment on LCameraManager_SpawnCameraWorkByName");
static_assert(sizeof(LCameraManager_SpawnCameraWorkByName) == 0x000010, "Wrong size on LCameraManager_SpawnCameraWorkByName");
static_assert(offsetof(LCameraManager_SpawnCameraWorkByName, CameraWorkName) == 0x000000, "Member 'LCameraManager_SpawnCameraWorkByName::CameraWorkName' has a wrong offset!");
static_assert(offsetof(LCameraManager_SpawnCameraWorkByName, CameraWork) == 0x000008, "Member 'LCameraManager_SpawnCameraWorkByName::CameraWork' has a wrong offset!");

// Function ProjectP.LCameraManager.GetBodyLookAtCameraRotation
// 0x000C (0x000C - 0x0000)
struct LCameraManager_GetBodyLookAtCameraRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_GetBodyLookAtCameraRotation) == 0x000004, "Wrong alignment on LCameraManager_GetBodyLookAtCameraRotation");
static_assert(sizeof(LCameraManager_GetBodyLookAtCameraRotation) == 0x00000C, "Wrong size on LCameraManager_GetBodyLookAtCameraRotation");
static_assert(offsetof(LCameraManager_GetBodyLookAtCameraRotation, ReturnValue) == 0x000000, "Member 'LCameraManager_GetBodyLookAtCameraRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraManager.GetCameraDistanceValue
// 0x0004 (0x0004 - 0x0000)
struct LCameraManager_GetCameraDistanceValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_GetCameraDistanceValue) == 0x000004, "Wrong alignment on LCameraManager_GetCameraDistanceValue");
static_assert(sizeof(LCameraManager_GetCameraDistanceValue) == 0x000004, "Wrong size on LCameraManager_GetCameraDistanceValue");
static_assert(offsetof(LCameraManager_GetCameraDistanceValue, ReturnValue) == 0x000000, "Member 'LCameraManager_GetCameraDistanceValue::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraManager.GetDefaultCameraData
// 0x003C (0x003C - 0x0000)
struct LCameraManager_GetDefaultCameraData final
{
public:
	struct FLPlayerCameraData                     ReturnValue;                                       // 0x0000(0x003C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_GetDefaultCameraData) == 0x000004, "Wrong alignment on LCameraManager_GetDefaultCameraData");
static_assert(sizeof(LCameraManager_GetDefaultCameraData) == 0x00003C, "Wrong size on LCameraManager_GetDefaultCameraData");
static_assert(offsetof(LCameraManager_GetDefaultCameraData, ReturnValue) == 0x000000, "Member 'LCameraManager_GetDefaultCameraData::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraManager.GetPlayingCameraWork
// 0x0008 (0x0008 - 0x0000)
struct LCameraManager_GetPlayingCameraWork final
{
public:
	class ALCameraWork*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraManager_GetPlayingCameraWork) == 0x000008, "Wrong alignment on LCameraManager_GetPlayingCameraWork");
static_assert(sizeof(LCameraManager_GetPlayingCameraWork) == 0x000008, "Wrong size on LCameraManager_GetPlayingCameraWork");
static_assert(offsetof(LCameraManager_GetPlayingCameraWork, ReturnValue) == 0x000000, "Member 'LCameraManager_GetPlayingCameraWork::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_CancelDash
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_CancelDash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_CancelDash) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_CancelDash");
static_assert(sizeof(LActionStopReason_ActionStopReason_CancelDash) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_CancelDash");
static_assert(offsetof(LActionStopReason_ActionStopReason_CancelDash, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_CancelDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_CancelMove
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_CancelMove final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_CancelMove) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_CancelMove");
static_assert(sizeof(LActionStopReason_ActionStopReason_CancelMove) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_CancelMove");
static_assert(offsetof(LActionStopReason_ActionStopReason_CancelMove, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_CancelMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_ChangeCostume
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_ChangeCostume final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_ChangeCostume) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_ChangeCostume");
static_assert(sizeof(LActionStopReason_ActionStopReason_ChangeCostume) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_ChangeCostume");
static_assert(offsetof(LActionStopReason_ActionStopReason_ChangeCostume, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_ChangeCostume::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_EscapeFromInfiniteGrabbing
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing");
static_assert(sizeof(LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing");
static_assert(offsetof(LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_Explode
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_Explode final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_Explode) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_Explode");
static_assert(sizeof(LActionStopReason_ActionStopReason_Explode) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_Explode");
static_assert(offsetof(LActionStopReason_ActionStopReason_Explode, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_Explode::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_GrabFailed
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_GrabFailed final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_GrabFailed) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_GrabFailed");
static_assert(sizeof(LActionStopReason_ActionStopReason_GrabFailed) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_GrabFailed");
static_assert(offsetof(LActionStopReason_ActionStopReason_GrabFailed, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_GrabFailed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_None
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_None) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_None");
static_assert(sizeof(LActionStopReason_ActionStopReason_None) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_None");
static_assert(offsetof(LActionStopReason_ActionStopReason_None, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_PayloadInvalid
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_PayloadInvalid final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_PayloadInvalid) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_PayloadInvalid");
static_assert(sizeof(LActionStopReason_ActionStopReason_PayloadInvalid) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_PayloadInvalid");
static_assert(offsetof(LActionStopReason_ActionStopReason_PayloadInvalid, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_PayloadInvalid::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_PlayAnimFailed
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_PlayAnimFailed final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_PlayAnimFailed) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_PlayAnimFailed");
static_assert(sizeof(LActionStopReason_ActionStopReason_PlayAnimFailed) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_PlayAnimFailed");
static_assert(offsetof(LActionStopReason_ActionStopReason_PlayAnimFailed, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_PlayAnimFailed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_PlayLevelSequenceBySpot
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot");
static_assert(sizeof(LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot");
static_assert(offsetof(LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_Sequencer
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_Sequencer final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_Sequencer) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_Sequencer");
static_assert(sizeof(LActionStopReason_ActionStopReason_Sequencer) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_Sequencer");
static_assert(offsetof(LActionStopReason_ActionStopReason_Sequencer, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_Sequencer::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_StaminaExhausted
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_StaminaExhausted final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_StaminaExhausted) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_StaminaExhausted");
static_assert(sizeof(LActionStopReason_ActionStopReason_StaminaExhausted) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_StaminaExhausted");
static_assert(offsetof(LActionStopReason_ActionStopReason_StaminaExhausted, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_StaminaExhausted::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_Tutorial
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_Tutorial final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_Tutorial) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_Tutorial");
static_assert(sizeof(LActionStopReason_ActionStopReason_Tutorial) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_Tutorial");
static_assert(offsetof(LActionStopReason_ActionStopReason_Tutorial, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_Tutorial::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStopReason.ActionStopReason_UnexpectedBehaviour
// 0x0008 (0x0008 - 0x0000)
struct LActionStopReason_ActionStopReason_UnexpectedBehaviour final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStopReason_ActionStopReason_UnexpectedBehaviour) == 0x000004, "Wrong alignment on LActionStopReason_ActionStopReason_UnexpectedBehaviour");
static_assert(sizeof(LActionStopReason_ActionStopReason_UnexpectedBehaviour) == 0x000008, "Wrong size on LActionStopReason_ActionStopReason_UnexpectedBehaviour");
static_assert(offsetof(LActionStopReason_ActionStopReason_UnexpectedBehaviour, ReturnValue) == 0x000000, "Member 'LActionStopReason_ActionStopReason_UnexpectedBehaviour::ReturnValue' has a wrong offset!");

// DelegateFunction ProjectP.LCameraWork.Delegate_OnStopWorkFinish__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature) == 0x000008, "Wrong alignment on LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature");
static_assert(sizeof(LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature) == 0x000008, "Wrong size on LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature");
static_assert(offsetof(LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature, CameraWork) == 0x000000, "Member 'LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature::CameraWork' has a wrong offset!");

// Function ProjectP.LCameraWork.OnChangeBlend
// 0x0001 (0x0001 - 0x0000)
struct LCameraWork_OnChangeBlend final
{
public:
	ELCameraWorkBlendState                        CameraWorkBlendState;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_OnChangeBlend) == 0x000001, "Wrong alignment on LCameraWork_OnChangeBlend");
static_assert(sizeof(LCameraWork_OnChangeBlend) == 0x000001, "Wrong size on LCameraWork_OnChangeBlend");
static_assert(offsetof(LCameraWork_OnChangeBlend, CameraWorkBlendState) == 0x000000, "Member 'LCameraWork_OnChangeBlend::CameraWorkBlendState' has a wrong offset!");

// Function ProjectP.LCameraWork.OnPreWork
// 0x0001 (0x0001 - 0x0000)
struct LCameraWork_OnPreWork final
{
public:
	bool                                          bCanStartWorking;                                  // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_OnPreWork) == 0x000001, "Wrong alignment on LCameraWork_OnPreWork");
static_assert(sizeof(LCameraWork_OnPreWork) == 0x000001, "Wrong size on LCameraWork_OnPreWork");
static_assert(offsetof(LCameraWork_OnPreWork, bCanStartWorking) == 0x000000, "Member 'LCameraWork_OnPreWork::bCanStartWorking' has a wrong offset!");

// Function ProjectP.LCameraWork.ResetWork
// 0x0010 (0x0010 - 0x0000)
struct LCameraWork_ResetWork final
{
public:
	class APlayerCameraManager*                   Manager;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULCameraWorkManager*                    WorkManager_0;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_ResetWork) == 0x000008, "Wrong alignment on LCameraWork_ResetWork");
static_assert(sizeof(LCameraWork_ResetWork) == 0x000010, "Wrong size on LCameraWork_ResetWork");
static_assert(offsetof(LCameraWork_ResetWork, Manager) == 0x000000, "Member 'LCameraWork_ResetWork::Manager' has a wrong offset!");
static_assert(offsetof(LCameraWork_ResetWork, WorkManager_0) == 0x000008, "Member 'LCameraWork_ResetWork::WorkManager_0' has a wrong offset!");

// Function ProjectP.LCameraWork.SetPostProcess
// 0x05C0 (0x05C0 - 0x0000)
struct LCameraWork_SetPostProcess final
{
public:
	float                                         PostProcessBlendWeight;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0010(0x05B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_SetPostProcess) == 0x000010, "Wrong alignment on LCameraWork_SetPostProcess");
static_assert(sizeof(LCameraWork_SetPostProcess) == 0x0005C0, "Wrong size on LCameraWork_SetPostProcess");
static_assert(offsetof(LCameraWork_SetPostProcess, PostProcessBlendWeight) == 0x000000, "Member 'LCameraWork_SetPostProcess::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(LCameraWork_SetPostProcess, PostProcessSettings) == 0x000010, "Member 'LCameraWork_SetPostProcess::PostProcessSettings' has a wrong offset!");

// Function ProjectP.LCameraWork.SetViewInfo
// 0x001C (0x001C - 0x0000)
struct LCameraWork_SetViewInfo final
{
public:
	struct FLCameraWorkViewInfo                   ViewInfo;                                          // 0x0000(0x001C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_SetViewInfo) == 0x000004, "Wrong alignment on LCameraWork_SetViewInfo");
static_assert(sizeof(LCameraWork_SetViewInfo) == 0x00001C, "Wrong size on LCameraWork_SetViewInfo");
static_assert(offsetof(LCameraWork_SetViewInfo, ViewInfo) == 0x000000, "Member 'LCameraWork_SetViewInfo::ViewInfo' has a wrong offset!");

// Function ProjectP.LCameraWork.StartWork
// 0x0008 (0x0008 - 0x0000)
struct LCameraWork_StartWork final
{
public:
	float                                         DurationTime_0;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraWork_StartWork) == 0x000004, "Wrong alignment on LCameraWork_StartWork");
static_assert(sizeof(LCameraWork_StartWork) == 0x000008, "Wrong size on LCameraWork_StartWork");
static_assert(offsetof(LCameraWork_StartWork, DurationTime_0) == 0x000000, "Member 'LCameraWork_StartWork::DurationTime_0' has a wrong offset!");
static_assert(offsetof(LCameraWork_StartWork, ReturnValue) == 0x000004, "Member 'LCameraWork_StartWork::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraWork.UpdatePostProcess
// 0x0004 (0x0004 - 0x0000)
struct LCameraWork_UpdatePostProcess final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_UpdatePostProcess) == 0x000004, "Wrong alignment on LCameraWork_UpdatePostProcess");
static_assert(sizeof(LCameraWork_UpdatePostProcess) == 0x000004, "Wrong size on LCameraWork_UpdatePostProcess");
static_assert(offsetof(LCameraWork_UpdatePostProcess, DeltaTime) == 0x000000, "Member 'LCameraWork_UpdatePostProcess::DeltaTime' has a wrong offset!");

// Function ProjectP.LCameraWork.UpdateTargetView
// 0x0004 (0x0004 - 0x0000)
struct LCameraWork_UpdateTargetView final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_UpdateTargetView) == 0x000004, "Wrong alignment on LCameraWork_UpdateTargetView");
static_assert(sizeof(LCameraWork_UpdateTargetView) == 0x000004, "Wrong size on LCameraWork_UpdateTargetView");
static_assert(offsetof(LCameraWork_UpdateTargetView, DeltaTime) == 0x000000, "Member 'LCameraWork_UpdateTargetView::DeltaTime' has a wrong offset!");

// Function ProjectP.LCameraWork.UpdateTargetViewBlendIn
// 0x0004 (0x0004 - 0x0000)
struct LCameraWork_UpdateTargetViewBlendIn final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_UpdateTargetViewBlendIn) == 0x000004, "Wrong alignment on LCameraWork_UpdateTargetViewBlendIn");
static_assert(sizeof(LCameraWork_UpdateTargetViewBlendIn) == 0x000004, "Wrong size on LCameraWork_UpdateTargetViewBlendIn");
static_assert(offsetof(LCameraWork_UpdateTargetViewBlendIn, DeltaTime) == 0x000000, "Member 'LCameraWork_UpdateTargetViewBlendIn::DeltaTime' has a wrong offset!");

// Function ProjectP.LCameraWork.UpdateTargetViewBlendInFully
// 0x0004 (0x0004 - 0x0000)
struct LCameraWork_UpdateTargetViewBlendInFully final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_UpdateTargetViewBlendInFully) == 0x000004, "Wrong alignment on LCameraWork_UpdateTargetViewBlendInFully");
static_assert(sizeof(LCameraWork_UpdateTargetViewBlendInFully) == 0x000004, "Wrong size on LCameraWork_UpdateTargetViewBlendInFully");
static_assert(offsetof(LCameraWork_UpdateTargetViewBlendInFully, DeltaTime) == 0x000000, "Member 'LCameraWork_UpdateTargetViewBlendInFully::DeltaTime' has a wrong offset!");

// Function ProjectP.LCameraWork.UpdateTargetViewBlendOut
// 0x0004 (0x0004 - 0x0000)
struct LCameraWork_UpdateTargetViewBlendOut final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_UpdateTargetViewBlendOut) == 0x000004, "Wrong alignment on LCameraWork_UpdateTargetViewBlendOut");
static_assert(sizeof(LCameraWork_UpdateTargetViewBlendOut) == 0x000004, "Wrong size on LCameraWork_UpdateTargetViewBlendOut");
static_assert(offsetof(LCameraWork_UpdateTargetViewBlendOut, DeltaTime) == 0x000000, "Member 'LCameraWork_UpdateTargetViewBlendOut::DeltaTime' has a wrong offset!");

// Function ProjectP.LCameraWork.GetElapsedAlpha
// 0x0008 (0x0008 - 0x0000)
struct LCameraWork_GetElapsedAlpha final
{
public:
	float                                         Multiflier;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_GetElapsedAlpha) == 0x000004, "Wrong alignment on LCameraWork_GetElapsedAlpha");
static_assert(sizeof(LCameraWork_GetElapsedAlpha) == 0x000008, "Wrong size on LCameraWork_GetElapsedAlpha");
static_assert(offsetof(LCameraWork_GetElapsedAlpha, Multiflier) == 0x000000, "Member 'LCameraWork_GetElapsedAlpha::Multiflier' has a wrong offset!");
static_assert(offsetof(LCameraWork_GetElapsedAlpha, ReturnValue) == 0x000004, "Member 'LCameraWork_GetElapsedAlpha::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraWork.HasDurationTime
// 0x0001 (0x0001 - 0x0000)
struct LCameraWork_HasDurationTime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_HasDurationTime) == 0x000001, "Wrong alignment on LCameraWork_HasDurationTime");
static_assert(sizeof(LCameraWork_HasDurationTime) == 0x000001, "Wrong size on LCameraWork_HasDurationTime");
static_assert(offsetof(LCameraWork_HasDurationTime, ReturnValue) == 0x000000, "Member 'LCameraWork_HasDurationTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraWork.IsWorking
// 0x0001 (0x0001 - 0x0000)
struct LCameraWork_IsWorking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_IsWorking) == 0x000001, "Wrong alignment on LCameraWork_IsWorking");
static_assert(sizeof(LCameraWork_IsWorking) == 0x000001, "Wrong size on LCameraWork_IsWorking");
static_assert(offsetof(LCameraWork_IsWorking, ReturnValue) == 0x000000, "Member 'LCameraWork_IsWorking::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraWork.UpdateElapsedAlphaForBlend
// 0x000C (0x000C - 0x0000)
struct LCameraWork_UpdateElapsedAlphaForBlend final
{
public:
	float                                         LastElapsedAlaph;                                  // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultAlpha;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiflierIn;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraWork_UpdateElapsedAlphaForBlend) == 0x000004, "Wrong alignment on LCameraWork_UpdateElapsedAlphaForBlend");
static_assert(sizeof(LCameraWork_UpdateElapsedAlphaForBlend) == 0x00000C, "Wrong size on LCameraWork_UpdateElapsedAlphaForBlend");
static_assert(offsetof(LCameraWork_UpdateElapsedAlphaForBlend, LastElapsedAlaph) == 0x000000, "Member 'LCameraWork_UpdateElapsedAlphaForBlend::LastElapsedAlaph' has a wrong offset!");
static_assert(offsetof(LCameraWork_UpdateElapsedAlphaForBlend, ResultAlpha) == 0x000004, "Member 'LCameraWork_UpdateElapsedAlphaForBlend::ResultAlpha' has a wrong offset!");
static_assert(offsetof(LCameraWork_UpdateElapsedAlphaForBlend, MultiflierIn) == 0x000008, "Member 'LCameraWork_UpdateElapsedAlphaForBlend::MultiflierIn' has a wrong offset!");

// Function ProjectP.LActBase.AddActionState
// 0x0008 (0x0008 - 0x0000)
struct LActBase_AddActionState final
{
public:
	class FName                                   ActionState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_AddActionState) == 0x000004, "Wrong alignment on LActBase_AddActionState");
static_assert(sizeof(LActBase_AddActionState) == 0x000008, "Wrong size on LActBase_AddActionState");
static_assert(offsetof(LActBase_AddActionState, ActionState) == 0x000000, "Member 'LActBase_AddActionState::ActionState' has a wrong offset!");

// Function ProjectP.LActBase.AddInitActionState
// 0x0008 (0x0008 - 0x0000)
struct LActBase_AddInitActionState final
{
public:
	class FName                                   ActionState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_AddInitActionState) == 0x000004, "Wrong alignment on LActBase_AddInitActionState");
static_assert(sizeof(LActBase_AddInitActionState) == 0x000008, "Wrong size on LActBase_AddInitActionState");
static_assert(offsetof(LActBase_AddInitActionState, ActionState) == 0x000000, "Member 'LActBase_AddInitActionState::ActionState' has a wrong offset!");

// Function ProjectP.LActBase.ChangeActionImmuneState
// 0x0001 (0x0001 - 0x0000)
struct LActBase_ChangeActionImmuneState final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_ChangeActionImmuneState) == 0x000001, "Wrong alignment on LActBase_ChangeActionImmuneState");
static_assert(sizeof(LActBase_ChangeActionImmuneState) == 0x000001, "Wrong size on LActBase_ChangeActionImmuneState");
static_assert(offsetof(LActBase_ChangeActionImmuneState, Enable) == 0x000000, "Member 'LActBase_ChangeActionImmuneState::Enable' has a wrong offset!");

// Function ProjectP.LActBase.OnPreProcessAction
// 0x0001 (0x0001 - 0x0000)
struct LActBase_OnPreProcessAction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_OnPreProcessAction) == 0x000001, "Wrong alignment on LActBase_OnPreProcessAction");
static_assert(sizeof(LActBase_OnPreProcessAction) == 0x000001, "Wrong size on LActBase_OnPreProcessAction");
static_assert(offsetof(LActBase_OnPreProcessAction, ReturnValue) == 0x000000, "Member 'LActBase_OnPreProcessAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.OnStop
// 0x0010 (0x0010 - 0x0000)
struct LActBase_OnStop final
{
public:
	class ULActBase*                              ReasonAction;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_OnStop) == 0x000008, "Wrong alignment on LActBase_OnStop");
static_assert(sizeof(LActBase_OnStop) == 0x000010, "Wrong size on LActBase_OnStop");
static_assert(offsetof(LActBase_OnStop, ReasonAction) == 0x000000, "Member 'LActBase_OnStop::ReasonAction' has a wrong offset!");
static_assert(offsetof(LActBase_OnStop, Reason) == 0x000008, "Member 'LActBase_OnStop::Reason' has a wrong offset!");

// Function ProjectP.LActBase.OnStopByMe
// 0x0008 (0x0008 - 0x0000)
struct LActBase_OnStopByMe final
{
public:
	class ULActBase*                              StoppingAction;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_OnStopByMe) == 0x000008, "Wrong alignment on LActBase_OnStopByMe");
static_assert(sizeof(LActBase_OnStopByMe) == 0x000008, "Wrong size on LActBase_OnStopByMe");
static_assert(offsetof(LActBase_OnStopByMe, StoppingAction) == 0x000000, "Member 'LActBase_OnStopByMe::StoppingAction' has a wrong offset!");

// Function ProjectP.LActBase.OnTick
// 0x0004 (0x0004 - 0x0000)
struct LActBase_OnTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_OnTick) == 0x000004, "Wrong alignment on LActBase_OnTick");
static_assert(sizeof(LActBase_OnTick) == 0x000004, "Wrong size on LActBase_OnTick");
static_assert(offsetof(LActBase_OnTick, DeltaTime) == 0x000000, "Member 'LActBase_OnTick::DeltaTime' has a wrong offset!");

// Function ProjectP.LActBase.ProcessValidLandingSpot
// 0x0098 (0x0098 - 0x0000)
struct LActBase_ProcessValidLandingSpot final
{
public:
	struct FVector                                CapsuleLocation;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x000C(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsValidLandingSpot;                                // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0095(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActBase_ProcessValidLandingSpot) == 0x000004, "Wrong alignment on LActBase_ProcessValidLandingSpot");
static_assert(sizeof(LActBase_ProcessValidLandingSpot) == 0x000098, "Wrong size on LActBase_ProcessValidLandingSpot");
static_assert(offsetof(LActBase_ProcessValidLandingSpot, CapsuleLocation) == 0x000000, "Member 'LActBase_ProcessValidLandingSpot::CapsuleLocation' has a wrong offset!");
static_assert(offsetof(LActBase_ProcessValidLandingSpot, Hit) == 0x00000C, "Member 'LActBase_ProcessValidLandingSpot::Hit' has a wrong offset!");
static_assert(offsetof(LActBase_ProcessValidLandingSpot, IsValidLandingSpot) == 0x000094, "Member 'LActBase_ProcessValidLandingSpot::IsValidLandingSpot' has a wrong offset!");
static_assert(offsetof(LActBase_ProcessValidLandingSpot, ReturnValue) == 0x000095, "Member 'LActBase_ProcessValidLandingSpot::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.RemoveActionState
// 0x0008 (0x0008 - 0x0000)
struct LActBase_RemoveActionState final
{
public:
	class FName                                   ActionState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_RemoveActionState) == 0x000004, "Wrong alignment on LActBase_RemoveActionState");
static_assert(sizeof(LActBase_RemoveActionState) == 0x000008, "Wrong size on LActBase_RemoveActionState");
static_assert(offsetof(LActBase_RemoveActionState, ActionState) == 0x000000, "Member 'LActBase_RemoveActionState::ActionState' has a wrong offset!");

// Function ProjectP.LActBase.RemoveInitActionState
// 0x0008 (0x0008 - 0x0000)
struct LActBase_RemoveInitActionState final
{
public:
	class FName                                   ActionState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_RemoveInitActionState) == 0x000004, "Wrong alignment on LActBase_RemoveInitActionState");
static_assert(sizeof(LActBase_RemoveInitActionState) == 0x000008, "Wrong size on LActBase_RemoveInitActionState");
static_assert(offsetof(LActBase_RemoveInitActionState, ActionState) == 0x000000, "Member 'LActBase_RemoveInitActionState::ActionState' has a wrong offset!");

// Function ProjectP.LActBase.Reset
// 0x0001 (0x0001 - 0x0000)
struct LActBase_Reset final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_Reset) == 0x000001, "Wrong alignment on LActBase_Reset");
static_assert(sizeof(LActBase_Reset) == 0x000001, "Wrong size on LActBase_Reset");
static_assert(offsetof(LActBase_Reset, ReturnValue) == 0x000000, "Member 'LActBase_Reset::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.SetActPayload
// 0x0010 (0x0010 - 0x0000)
struct LActBase_SetActPayload final
{
public:
	class ULActPayloadBase*                       InActPayload;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActBase_SetActPayload) == 0x000008, "Wrong alignment on LActBase_SetActPayload");
static_assert(sizeof(LActBase_SetActPayload) == 0x000010, "Wrong size on LActBase_SetActPayload");
static_assert(offsetof(LActBase_SetActPayload, InActPayload) == 0x000000, "Member 'LActBase_SetActPayload::InActPayload' has a wrong offset!");
static_assert(offsetof(LActBase_SetActPayload, ReturnValue) == 0x000008, "Member 'LActBase_SetActPayload::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.SetTickable
// 0x0002 (0x0002 - 0x0000)
struct LActBase_SetTickable final
{
public:
	bool                                          InTickable;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_SetTickable) == 0x000001, "Wrong alignment on LActBase_SetTickable");
static_assert(sizeof(LActBase_SetTickable) == 0x000002, "Wrong size on LActBase_SetTickable");
static_assert(offsetof(LActBase_SetTickable, InTickable) == 0x000000, "Member 'LActBase_SetTickable::InTickable' has a wrong offset!");
static_assert(offsetof(LActBase_SetTickable, ReturnValue) == 0x000001, "Member 'LActBase_SetTickable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.Start
// 0x0001 (0x0001 - 0x0000)
struct LActBase_Start final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_Start) == 0x000001, "Wrong alignment on LActBase_Start");
static_assert(sizeof(LActBase_Start) == 0x000001, "Wrong size on LActBase_Start");
static_assert(offsetof(LActBase_Start, ReturnValue) == 0x000000, "Member 'LActBase_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.Stop
// 0x0018 (0x0018 - 0x0000)
struct LActBase_Stop final
{
public:
	class ULActBase*                              ReasonAction;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActBase_Stop) == 0x000008, "Wrong alignment on LActBase_Stop");
static_assert(sizeof(LActBase_Stop) == 0x000018, "Wrong size on LActBase_Stop");
static_assert(offsetof(LActBase_Stop, ReasonAction) == 0x000000, "Member 'LActBase_Stop::ReasonAction' has a wrong offset!");
static_assert(offsetof(LActBase_Stop, Reason) == 0x000008, "Member 'LActBase_Stop::Reason' has a wrong offset!");
static_assert(offsetof(LActBase_Stop, ReturnValue) == 0x000010, "Member 'LActBase_Stop::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.GetActionTime_End
// 0x0004 (0x0004 - 0x0000)
struct LActBase_GetActionTime_End final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_GetActionTime_End) == 0x000004, "Wrong alignment on LActBase_GetActionTime_End");
static_assert(sizeof(LActBase_GetActionTime_End) == 0x000004, "Wrong size on LActBase_GetActionTime_End");
static_assert(offsetof(LActBase_GetActionTime_End, ReturnValue) == 0x000000, "Member 'LActBase_GetActionTime_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.GetActionTime_Start
// 0x0004 (0x0004 - 0x0000)
struct LActBase_GetActionTime_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_GetActionTime_Start) == 0x000004, "Wrong alignment on LActBase_GetActionTime_Start");
static_assert(sizeof(LActBase_GetActionTime_Start) == 0x000004, "Wrong size on LActBase_GetActionTime_Start");
static_assert(offsetof(LActBase_GetActionTime_Start, ReturnValue) == 0x000000, "Member 'LActBase_GetActionTime_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.GetActPayload
// 0x0008 (0x0008 - 0x0000)
struct LActBase_GetActPayload final
{
public:
	class ULActPayloadBase*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_GetActPayload) == 0x000008, "Wrong alignment on LActBase_GetActPayload");
static_assert(sizeof(LActBase_GetActPayload) == 0x000008, "Wrong size on LActBase_GetActPayload");
static_assert(offsetof(LActBase_GetActPayload, ReturnValue) == 0x000000, "Member 'LActBase_GetActPayload::ReturnValue' has a wrong offset!");

// Function ProjectP.LActBase.IsPlaying
// 0x0001 (0x0001 - 0x0000)
struct LActBase_IsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActBase_IsPlaying) == 0x000001, "Wrong alignment on LActBase_IsPlaying");
static_assert(sizeof(LActBase_IsPlaying) == 0x000001, "Wrong size on LActBase_IsPlaying");
static_assert(offsetof(LActBase_IsPlaying, ReturnValue) == 0x000000, "Member 'LActBase_IsPlaying::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.BindOnCurrMontageBlendOutStarted
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_BindOnCurrMontageBlendOutStarted final
{
public:
	int32                                         MontageInstanceID;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_SingleAnim_BindOnCurrMontageBlendOutStarted) == 0x000004, "Wrong alignment on LAction_SingleAnim_BindOnCurrMontageBlendOutStarted");
static_assert(sizeof(LAction_SingleAnim_BindOnCurrMontageBlendOutStarted) == 0x000008, "Wrong size on LAction_SingleAnim_BindOnCurrMontageBlendOutStarted");
static_assert(offsetof(LAction_SingleAnim_BindOnCurrMontageBlendOutStarted, MontageInstanceID) == 0x000000, "Member 'LAction_SingleAnim_BindOnCurrMontageBlendOutStarted::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_BindOnCurrMontageBlendOutStarted, ReturnValue) == 0x000004, "Member 'LAction_SingleAnim_BindOnCurrMontageBlendOutStarted::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.BindOnCurrMontageEnded
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_BindOnCurrMontageEnded final
{
public:
	int32                                         MontageInstanceID;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_SingleAnim_BindOnCurrMontageEnded) == 0x000004, "Wrong alignment on LAction_SingleAnim_BindOnCurrMontageEnded");
static_assert(sizeof(LAction_SingleAnim_BindOnCurrMontageEnded) == 0x000008, "Wrong size on LAction_SingleAnim_BindOnCurrMontageEnded");
static_assert(offsetof(LAction_SingleAnim_BindOnCurrMontageEnded, MontageInstanceID) == 0x000000, "Member 'LAction_SingleAnim_BindOnCurrMontageEnded::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_BindOnCurrMontageEnded, ReturnValue) == 0x000004, "Member 'LAction_SingleAnim_BindOnCurrMontageEnded::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.ConditionalAnimBranch
// 0x0058 (0x0058 - 0x0000)
struct LAction_SingleAnim_ConditionalAnimBranch final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Montage;                                           // 0x0020(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELConditionalAnimBranch                       OutBranchResult;                                   // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                OutInstigator;                                     // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_ConditionalAnimBranch) == 0x000008, "Wrong alignment on LAction_SingleAnim_ConditionalAnimBranch");
static_assert(sizeof(LAction_SingleAnim_ConditionalAnimBranch) == 0x000058, "Wrong size on LAction_SingleAnim_ConditionalAnimBranch");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch, WorldContextObject) == 0x000000, "Member 'LAction_SingleAnim_ConditionalAnimBranch::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch, LatentInfo) == 0x000008, "Member 'LAction_SingleAnim_ConditionalAnimBranch::LatentInfo' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch, Montage) == 0x000020, "Member 'LAction_SingleAnim_ConditionalAnimBranch::Montage' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch, OutBranchResult) == 0x000048, "Member 'LAction_SingleAnim_ConditionalAnimBranch::OutBranchResult' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch, OutInstigator) == 0x000050, "Member 'LAction_SingleAnim_ConditionalAnimBranch::OutInstigator' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.ConditionalAnimBranch_WithMontageInstanceID
// 0x0030 (0x0030 - 0x0000)
struct LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELConditionalAnimBranch                       OutBranchResult;                                   // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                OutInstigator;                                     // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID) == 0x000008, "Wrong alignment on LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID");
static_assert(sizeof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID) == 0x000030, "Wrong size on LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID, WorldContextObject) == 0x000000, "Member 'LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID, LatentInfo) == 0x000008, "Member 'LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID::LatentInfo' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID, MontageInstanceID) == 0x000020, "Member 'LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID, OutBranchResult) == 0x000024, "Member 'LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID::OutBranchResult' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID, OutInstigator) == 0x000028, "Member 'LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID::OutInstigator' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.GetAnimInst
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_GetAnimInst final
{
public:
	class UAnimInstance*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_GetAnimInst) == 0x000008, "Wrong alignment on LAction_SingleAnim_GetAnimInst");
static_assert(sizeof(LAction_SingleAnim_GetAnimInst) == 0x000008, "Wrong size on LAction_SingleAnim_GetAnimInst");
static_assert(offsetof(LAction_SingleAnim_GetAnimInst, ReturnValue) == 0x000000, "Member 'LAction_SingleAnim_GetAnimInst::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.GetAnimInstBP
// 0x0010 (0x0010 - 0x0000)
struct LAction_SingleAnim_GetAnimInstBP final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_GetAnimInstBP) == 0x000008, "Wrong alignment on LAction_SingleAnim_GetAnimInstBP");
static_assert(sizeof(LAction_SingleAnim_GetAnimInstBP) == 0x000010, "Wrong size on LAction_SingleAnim_GetAnimInstBP");
static_assert(offsetof(LAction_SingleAnim_GetAnimInstBP, Branches) == 0x000000, "Member 'LAction_SingleAnim_GetAnimInstBP::Branches' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_GetAnimInstBP, ReturnValue) == 0x000008, "Member 'LAction_SingleAnim_GetAnimInstBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.GetCurrMontage
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_GetCurrMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_GetCurrMontage) == 0x000008, "Wrong alignment on LAction_SingleAnim_GetCurrMontage");
static_assert(sizeof(LAction_SingleAnim_GetCurrMontage) == 0x000008, "Wrong size on LAction_SingleAnim_GetCurrMontage");
static_assert(offsetof(LAction_SingleAnim_GetCurrMontage, ReturnValue) == 0x000000, "Member 'LAction_SingleAnim_GetCurrMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.GetCurrMontageInstanceID
// 0x0010 (0x0010 - 0x0000)
struct LAction_SingleAnim_GetCurrMontageInstanceID final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_GetCurrMontageInstanceID) == 0x000008, "Wrong alignment on LAction_SingleAnim_GetCurrMontageInstanceID");
static_assert(sizeof(LAction_SingleAnim_GetCurrMontageInstanceID) == 0x000010, "Wrong size on LAction_SingleAnim_GetCurrMontageInstanceID");
static_assert(offsetof(LAction_SingleAnim_GetCurrMontageInstanceID, AnimInstance) == 0x000000, "Member 'LAction_SingleAnim_GetCurrMontageInstanceID::AnimInstance' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_GetCurrMontageInstanceID, Branches) == 0x000008, "Member 'LAction_SingleAnim_GetCurrMontageInstanceID::Branches' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_GetCurrMontageInstanceID, ReturnValue) == 0x00000C, "Member 'LAction_SingleAnim_GetCurrMontageInstanceID::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.GetPlayingCharacter
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_GetPlayingCharacter final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_GetPlayingCharacter) == 0x000008, "Wrong alignment on LAction_SingleAnim_GetPlayingCharacter");
static_assert(sizeof(LAction_SingleAnim_GetPlayingCharacter) == 0x000008, "Wrong size on LAction_SingleAnim_GetPlayingCharacter");
static_assert(offsetof(LAction_SingleAnim_GetPlayingCharacter, ReturnValue) == 0x000000, "Member 'LAction_SingleAnim_GetPlayingCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.InitSingleAnim
// 0x0001 (0x0001 - 0x0000)
struct LAction_SingleAnim_InitSingleAnim final
{
public:
	bool                                          LoadPayload;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_InitSingleAnim) == 0x000001, "Wrong alignment on LAction_SingleAnim_InitSingleAnim");
static_assert(sizeof(LAction_SingleAnim_InitSingleAnim) == 0x000001, "Wrong size on LAction_SingleAnim_InitSingleAnim");
static_assert(offsetof(LAction_SingleAnim_InitSingleAnim, LoadPayload) == 0x000000, "Member 'LAction_SingleAnim_InitSingleAnim::LoadPayload' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.MakeAbsoluteRootMotionContextBP
// 0x0080 (0x0080 - 0x0000)
struct LAction_SingleAnim_MakeAbsoluteRootMotionContextBP final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EndTransform;                                      // 0x0040(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartBlendTime;                                    // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndBlendTime;                                      // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetManualFinishTime;                               // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FixStartRotation;                                  // 0x007C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAbsoluteRootMotionModeType                  AbsoluteRootMotionModeType;                        // 0x007D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x007E(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F[0x1];                                       // 0x007F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP) == 0x000010, "Wrong alignment on LAction_SingleAnim_MakeAbsoluteRootMotionContextBP");
static_assert(sizeof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP) == 0x000080, "Wrong size on LAction_SingleAnim_MakeAbsoluteRootMotionContextBP");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, AnimMontage) == 0x000000, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::AnimMontage' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, StartTransform) == 0x000010, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::StartTransform' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, EndTransform) == 0x000040, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::EndTransform' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, StartBlendTime) == 0x000070, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::StartBlendTime' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, EndBlendTime) == 0x000074, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::EndBlendTime' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, SetManualFinishTime) == 0x000078, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::SetManualFinishTime' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, FixStartRotation) == 0x00007C, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::FixStartRotation' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, AbsoluteRootMotionModeType) == 0x00007D, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::AbsoluteRootMotionModeType' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_MakeAbsoluteRootMotionContextBP, Branches) == 0x00007E, "Member 'LAction_SingleAnim_MakeAbsoluteRootMotionContextBP::Branches' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.OnAbsoluteRootMotionFinished
// 0x0010 (0x0010 - 0x0000)
struct LAction_SingleAnim_OnAbsoluteRootMotionFinished final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MontageInstanceID;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_OnAbsoluteRootMotionFinished) == 0x000008, "Wrong alignment on LAction_SingleAnim_OnAbsoluteRootMotionFinished");
static_assert(sizeof(LAction_SingleAnim_OnAbsoluteRootMotionFinished) == 0x000010, "Wrong size on LAction_SingleAnim_OnAbsoluteRootMotionFinished");
static_assert(offsetof(LAction_SingleAnim_OnAbsoluteRootMotionFinished, Montage) == 0x000000, "Member 'LAction_SingleAnim_OnAbsoluteRootMotionFinished::Montage' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnAbsoluteRootMotionFinished, bInterrupted) == 0x000008, "Member 'LAction_SingleAnim_OnAbsoluteRootMotionFinished::bInterrupted' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnAbsoluteRootMotionFinished, MontageInstanceID) == 0x00000C, "Member 'LAction_SingleAnim_OnAbsoluteRootMotionFinished::MontageInstanceID' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.OnCurrMontageBlendOutStarted
// 0x0010 (0x0010 - 0x0000)
struct LAction_SingleAnim_OnCurrMontageBlendOutStarted final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MontageInstanceID;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_OnCurrMontageBlendOutStarted) == 0x000008, "Wrong alignment on LAction_SingleAnim_OnCurrMontageBlendOutStarted");
static_assert(sizeof(LAction_SingleAnim_OnCurrMontageBlendOutStarted) == 0x000010, "Wrong size on LAction_SingleAnim_OnCurrMontageBlendOutStarted");
static_assert(offsetof(LAction_SingleAnim_OnCurrMontageBlendOutStarted, Montage) == 0x000000, "Member 'LAction_SingleAnim_OnCurrMontageBlendOutStarted::Montage' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnCurrMontageBlendOutStarted, bInterrupted) == 0x000008, "Member 'LAction_SingleAnim_OnCurrMontageBlendOutStarted::bInterrupted' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnCurrMontageBlendOutStarted, MontageInstanceID) == 0x00000C, "Member 'LAction_SingleAnim_OnCurrMontageBlendOutStarted::MontageInstanceID' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.OnCurrMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct LAction_SingleAnim_OnCurrMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MontageInstanceID;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_OnCurrMontageEnded) == 0x000008, "Wrong alignment on LAction_SingleAnim_OnCurrMontageEnded");
static_assert(sizeof(LAction_SingleAnim_OnCurrMontageEnded) == 0x000010, "Wrong size on LAction_SingleAnim_OnCurrMontageEnded");
static_assert(offsetof(LAction_SingleAnim_OnCurrMontageEnded, Montage) == 0x000000, "Member 'LAction_SingleAnim_OnCurrMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnCurrMontageEnded, bInterrupted) == 0x000008, "Member 'LAction_SingleAnim_OnCurrMontageEnded::bInterrupted' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnCurrMontageEnded, MontageInstanceID) == 0x00000C, "Member 'LAction_SingleAnim_OnCurrMontageEnded::MontageInstanceID' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.OnLanded
// 0x0098 (0x0098 - 0x0000)
struct LAction_SingleAnim_OnLanded final
{
public:
	class ACharacter*                             LandingChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_SingleAnim_OnLanded) == 0x000008, "Wrong alignment on LAction_SingleAnim_OnLanded");
static_assert(sizeof(LAction_SingleAnim_OnLanded) == 0x000098, "Wrong size on LAction_SingleAnim_OnLanded");
static_assert(offsetof(LAction_SingleAnim_OnLanded, LandingChar) == 0x000000, "Member 'LAction_SingleAnim_OnLanded::LandingChar' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnLanded, Hit) == 0x000008, "Member 'LAction_SingleAnim_OnLanded::Hit' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnLanded, ReturnValue) == 0x000090, "Member 'LAction_SingleAnim_OnLanded::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.OnMoveBlockedBy
// 0x0098 (0x0098 - 0x0000)
struct LAction_SingleAnim_OnMoveBlockedBy final
{
public:
	class ACharacter*                             BlockedChar;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_SingleAnim_OnMoveBlockedBy) == 0x000008, "Wrong alignment on LAction_SingleAnim_OnMoveBlockedBy");
static_assert(sizeof(LAction_SingleAnim_OnMoveBlockedBy) == 0x000098, "Wrong size on LAction_SingleAnim_OnMoveBlockedBy");
static_assert(offsetof(LAction_SingleAnim_OnMoveBlockedBy, BlockedChar) == 0x000000, "Member 'LAction_SingleAnim_OnMoveBlockedBy::BlockedChar' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnMoveBlockedBy, Hit) == 0x000008, "Member 'LAction_SingleAnim_OnMoveBlockedBy::Hit' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_OnMoveBlockedBy, ReturnValue) == 0x000090, "Member 'LAction_SingleAnim_OnMoveBlockedBy::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin
// 0x0004 (0x0004 - 0x0000)
struct LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin final
{
public:
	float                                         InStopRemainTimeCompensateMargin;                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin) == 0x000004, "Wrong alignment on LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin");
static_assert(sizeof(LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin) == 0x000004, "Wrong size on LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin");
static_assert(offsetof(LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin, InStopRemainTimeCompensateMargin) == 0x000000, "Member 'LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin::InStopRemainTimeCompensateMargin' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.PlayCommomAnimBP
// 0x0020 (0x0020 - 0x0000)
struct LAction_SingleAnim_PlayCommomAnimBP final
{
public:
	class FName                                   CommomAnim;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_SingleAnim_PlayCommomAnimBP) == 0x000008, "Wrong alignment on LAction_SingleAnim_PlayCommomAnimBP");
static_assert(sizeof(LAction_SingleAnim_PlayCommomAnimBP) == 0x000020, "Wrong size on LAction_SingleAnim_PlayCommomAnimBP");
static_assert(offsetof(LAction_SingleAnim_PlayCommomAnimBP, CommomAnim) == 0x000000, "Member 'LAction_SingleAnim_PlayCommomAnimBP::CommomAnim' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayCommomAnimBP, MontageInstanceID) == 0x000008, "Member 'LAction_SingleAnim_PlayCommomAnimBP::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayCommomAnimBP, Montage) == 0x000010, "Member 'LAction_SingleAnim_PlayCommomAnimBP::Montage' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayCommomAnimBP, Branches) == 0x000018, "Member 'LAction_SingleAnim_PlayCommomAnimBP::Branches' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.PlayTargetAnim
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_PlayTargetAnim final
{
public:
	bool                                          UseAbsoluteRootMotion;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_PlayTargetAnim) == 0x000004, "Wrong alignment on LAction_SingleAnim_PlayTargetAnim");
static_assert(sizeof(LAction_SingleAnim_PlayTargetAnim) == 0x000008, "Wrong size on LAction_SingleAnim_PlayTargetAnim");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnim, UseAbsoluteRootMotion) == 0x000000, "Member 'LAction_SingleAnim_PlayTargetAnim::UseAbsoluteRootMotion' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnim, ReturnValue) == 0x000004, "Member 'LAction_SingleAnim_PlayTargetAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.PlayTargetAnimBP
// 0x0008 (0x0008 - 0x0000)
struct LAction_SingleAnim_PlayTargetAnimBP final
{
public:
	bool                                          UseAbsoluteRootMotion;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_PlayTargetAnimBP) == 0x000004, "Wrong alignment on LAction_SingleAnim_PlayTargetAnimBP");
static_assert(sizeof(LAction_SingleAnim_PlayTargetAnimBP) == 0x000008, "Wrong size on LAction_SingleAnim_PlayTargetAnimBP");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimBP, UseAbsoluteRootMotion) == 0x000000, "Member 'LAction_SingleAnim_PlayTargetAnimBP::UseAbsoluteRootMotion' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimBP, Branches) == 0x000001, "Member 'LAction_SingleAnim_PlayTargetAnimBP::Branches' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimBP, ReturnValue) == 0x000004, "Member 'LAction_SingleAnim_PlayTargetAnimBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.PlayTargetAnimExBP
// 0x0010 (0x0010 - 0x0000)
struct LAction_SingleAnim_PlayTargetAnimExBP final
{
public:
	bool                                          UseAbsoluteRootMotion;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideMontageBlendIn;                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceOverride;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_PlayTargetAnimExBP) == 0x000004, "Wrong alignment on LAction_SingleAnim_PlayTargetAnimExBP");
static_assert(sizeof(LAction_SingleAnim_PlayTargetAnimExBP) == 0x000010, "Wrong size on LAction_SingleAnim_PlayTargetAnimExBP");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimExBP, UseAbsoluteRootMotion) == 0x000000, "Member 'LAction_SingleAnim_PlayTargetAnimExBP::UseAbsoluteRootMotion' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimExBP, OverrideMontageBlendIn) == 0x000004, "Member 'LAction_SingleAnim_PlayTargetAnimExBP::OverrideMontageBlendIn' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimExBP, ForceOverride) == 0x000008, "Member 'LAction_SingleAnim_PlayTargetAnimExBP::ForceOverride' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimExBP, Branches) == 0x000009, "Member 'LAction_SingleAnim_PlayTargetAnimExBP::Branches' has a wrong offset!");
static_assert(offsetof(LAction_SingleAnim_PlayTargetAnimExBP, ReturnValue) == 0x00000C, "Member 'LAction_SingleAnim_PlayTargetAnimExBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.SetAbsoluteRootMotionContext
// 0x0060 (0x0060 - 0x0000)
struct LAction_SingleAnim_SetAbsoluteRootMotionContext final
{
public:
	struct FLAbsoluteRootMotionContext            InAbsoluteRootMotionContext;                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_SetAbsoluteRootMotionContext) == 0x000004, "Wrong alignment on LAction_SingleAnim_SetAbsoluteRootMotionContext");
static_assert(sizeof(LAction_SingleAnim_SetAbsoluteRootMotionContext) == 0x000060, "Wrong size on LAction_SingleAnim_SetAbsoluteRootMotionContext");
static_assert(offsetof(LAction_SingleAnim_SetAbsoluteRootMotionContext, InAbsoluteRootMotionContext) == 0x000000, "Member 'LAction_SingleAnim_SetAbsoluteRootMotionContext::InAbsoluteRootMotionContext' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.StartActionRotation
// 0x0001 (0x0001 - 0x0000)
struct LAction_SingleAnim_StartActionRotation final
{
public:
	bool                                          NeedRotator;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_StartActionRotation) == 0x000001, "Wrong alignment on LAction_SingleAnim_StartActionRotation");
static_assert(sizeof(LAction_SingleAnim_StartActionRotation) == 0x000001, "Wrong size on LAction_SingleAnim_StartActionRotation");
static_assert(offsetof(LAction_SingleAnim_StartActionRotation, NeedRotator) == 0x000000, "Member 'LAction_SingleAnim_StartActionRotation::NeedRotator' has a wrong offset!");

// Function ProjectP.LAction_SingleAnim.StopTargetAnim
// 0x0001 (0x0001 - 0x0000)
struct LAction_SingleAnim_StopTargetAnim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SingleAnim_StopTargetAnim) == 0x000001, "Wrong alignment on LAction_SingleAnim_StopTargetAnim");
static_assert(sizeof(LAction_SingleAnim_StopTargetAnim) == 0x000001, "Wrong size on LAction_SingleAnim_StopTargetAnim");
static_assert(offsetof(LAction_SingleAnim_StopTargetAnim, ReturnValue) == 0x000000, "Member 'LAction_SingleAnim_StopTargetAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_LoopAnim.CancelLoopAnim
// 0x000C (0x000C - 0x0000)
struct LAction_LoopAnim_CancelLoopAnim final
{
public:
	class FName                                   JumpToSectionName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_LoopAnim_CancelLoopAnim) == 0x000004, "Wrong alignment on LAction_LoopAnim_CancelLoopAnim");
static_assert(sizeof(LAction_LoopAnim_CancelLoopAnim) == 0x00000C, "Wrong size on LAction_LoopAnim_CancelLoopAnim");
static_assert(offsetof(LAction_LoopAnim_CancelLoopAnim, JumpToSectionName) == 0x000000, "Member 'LAction_LoopAnim_CancelLoopAnim::JumpToSectionName' has a wrong offset!");
static_assert(offsetof(LAction_LoopAnim_CancelLoopAnim, ReturnValue) == 0x000008, "Member 'LAction_LoopAnim_CancelLoopAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_LoopAnim.Init_LoopAnim
// 0x0001 (0x0001 - 0x0000)
struct LAction_LoopAnim_Init_LoopAnim final
{
public:
	bool                                          LoadPayload;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_LoopAnim_Init_LoopAnim) == 0x000001, "Wrong alignment on LAction_LoopAnim_Init_LoopAnim");
static_assert(sizeof(LAction_LoopAnim_Init_LoopAnim) == 0x000001, "Wrong size on LAction_LoopAnim_Init_LoopAnim");
static_assert(offsetof(LAction_LoopAnim_Init_LoopAnim, LoadPayload) == 0x000000, "Member 'LAction_LoopAnim_Init_LoopAnim::LoadPayload' has a wrong offset!");

// Function ProjectP.LAction_LoopAnim.IsLoopAnim
// 0x0001 (0x0001 - 0x0000)
struct LAction_LoopAnim_IsLoopAnim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_LoopAnim_IsLoopAnim) == 0x000001, "Wrong alignment on LAction_LoopAnim_IsLoopAnim");
static_assert(sizeof(LAction_LoopAnim_IsLoopAnim) == 0x000001, "Wrong size on LAction_LoopAnim_IsLoopAnim");
static_assert(offsetof(LAction_LoopAnim_IsLoopAnim, ReturnValue) == 0x000000, "Member 'LAction_LoopAnim_IsLoopAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_LoopAnim.NextLoopAnim
// 0x0008 (0x0008 - 0x0000)
struct LAction_LoopAnim_NextLoopAnim final
{
public:
	class FName                                   JumpToSectionName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_LoopAnim_NextLoopAnim) == 0x000004, "Wrong alignment on LAction_LoopAnim_NextLoopAnim");
static_assert(sizeof(LAction_LoopAnim_NextLoopAnim) == 0x000008, "Wrong size on LAction_LoopAnim_NextLoopAnim");
static_assert(offsetof(LAction_LoopAnim_NextLoopAnim, JumpToSectionName) == 0x000000, "Member 'LAction_LoopAnim_NextLoopAnim::JumpToSectionName' has a wrong offset!");

// Function ProjectP.LAction_LoopAnim.OnCommandOccurred
// 0x0028 (0x0028 - 0x0000)
struct LAction_LoopAnim_OnCommandOccurred final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Command;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipCommandPrerequisitiesCheck;                    // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_LoopAnim_OnCommandOccurred) == 0x000008, "Wrong alignment on LAction_LoopAnim_OnCommandOccurred");
static_assert(sizeof(LAction_LoopAnim_OnCommandOccurred) == 0x000028, "Wrong size on LAction_LoopAnim_OnCommandOccurred");
static_assert(offsetof(LAction_LoopAnim_OnCommandOccurred, ActMgrComponent) == 0x000000, "Member 'LAction_LoopAnim_OnCommandOccurred::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LAction_LoopAnim_OnCommandOccurred, TargetActor) == 0x000008, "Member 'LAction_LoopAnim_OnCommandOccurred::TargetActor' has a wrong offset!");
static_assert(offsetof(LAction_LoopAnim_OnCommandOccurred, Command) == 0x000010, "Member 'LAction_LoopAnim_OnCommandOccurred::Command' has a wrong offset!");
static_assert(offsetof(LAction_LoopAnim_OnCommandOccurred, Lever) == 0x000018, "Member 'LAction_LoopAnim_OnCommandOccurred::Lever' has a wrong offset!");
static_assert(offsetof(LAction_LoopAnim_OnCommandOccurred, SkipCommandPrerequisitiesCheck) == 0x000024, "Member 'LAction_LoopAnim_OnCommandOccurred::SkipCommandPrerequisitiesCheck' has a wrong offset!");

// Function ProjectP.LAction_HitAnim.PlayHitAnim
// 0x000C (0x000C - 0x0000)
struct LAction_HitAnim_PlayHitAnim final
{
public:
	class FName                                   HitAnim;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_HitAnim_PlayHitAnim) == 0x000004, "Wrong alignment on LAction_HitAnim_PlayHitAnim");
static_assert(sizeof(LAction_HitAnim_PlayHitAnim) == 0x00000C, "Wrong size on LAction_HitAnim_PlayHitAnim");
static_assert(offsetof(LAction_HitAnim_PlayHitAnim, HitAnim) == 0x000000, "Member 'LAction_HitAnim_PlayHitAnim::HitAnim' has a wrong offset!");
static_assert(offsetof(LAction_HitAnim_PlayHitAnim, ReturnValue) == 0x000008, "Member 'LAction_HitAnim_PlayHitAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_HitAnim.PlayHitAnimBP
// 0x0020 (0x0020 - 0x0000)
struct LAction_HitAnim_PlayHitAnimBP final
{
public:
	class FName                                   HitAnim;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_HitAnim_PlayHitAnimBP) == 0x000008, "Wrong alignment on LAction_HitAnim_PlayHitAnimBP");
static_assert(sizeof(LAction_HitAnim_PlayHitAnimBP) == 0x000020, "Wrong size on LAction_HitAnim_PlayHitAnimBP");
static_assert(offsetof(LAction_HitAnim_PlayHitAnimBP, HitAnim) == 0x000000, "Member 'LAction_HitAnim_PlayHitAnimBP::HitAnim' has a wrong offset!");
static_assert(offsetof(LAction_HitAnim_PlayHitAnimBP, MontageInstanceID) == 0x000008, "Member 'LAction_HitAnim_PlayHitAnimBP::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LAction_HitAnim_PlayHitAnimBP, Montage) == 0x000010, "Member 'LAction_HitAnim_PlayHitAnimBP::Montage' has a wrong offset!");
static_assert(offsetof(LAction_HitAnim_PlayHitAnimBP, Branches) == 0x000018, "Member 'LAction_HitAnim_PlayHitAnimBP::Branches' has a wrong offset!");

// Function ProjectP.LAction_HitAnim.SetLastPlayedHitAnim
// 0x0008 (0x0008 - 0x0000)
struct LAction_HitAnim_SetLastPlayedHitAnim final
{
public:
	class FName                                   HitAnim;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_HitAnim_SetLastPlayedHitAnim) == 0x000004, "Wrong alignment on LAction_HitAnim_SetLastPlayedHitAnim");
static_assert(sizeof(LAction_HitAnim_SetLastPlayedHitAnim) == 0x000008, "Wrong size on LAction_HitAnim_SetLastPlayedHitAnim");
static_assert(offsetof(LAction_HitAnim_SetLastPlayedHitAnim, HitAnim) == 0x000000, "Member 'LAction_HitAnim_SetLastPlayedHitAnim::HitAnim' has a wrong offset!");

// Function ProjectP.LAction_HitAnim.UpdateHitMotionReplace
// 0x0002 (0x0002 - 0x0000)
struct LAction_HitAnim_UpdateHitMotionReplace final
{
public:
	ELHitMotionType                               OriginHitMotionType;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_HitAnim_UpdateHitMotionReplace) == 0x000001, "Wrong alignment on LAction_HitAnim_UpdateHitMotionReplace");
static_assert(sizeof(LAction_HitAnim_UpdateHitMotionReplace) == 0x000002, "Wrong size on LAction_HitAnim_UpdateHitMotionReplace");
static_assert(offsetof(LAction_HitAnim_UpdateHitMotionReplace, OriginHitMotionType) == 0x000000, "Member 'LAction_HitAnim_UpdateHitMotionReplace::OriginHitMotionType' has a wrong offset!");
static_assert(offsetof(LAction_HitAnim_UpdateHitMotionReplace, ReturnValue) == 0x000001, "Member 'LAction_HitAnim_UpdateHitMotionReplace::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_HitAnim.UpdateSkillHitReplace
// 0x000C (0x000C - 0x0000)
struct LAction_HitAnim_UpdateSkillHitReplace final
{
public:
	class FName                                   NewSkillHitCodeName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_HitAnim_UpdateSkillHitReplace) == 0x000004, "Wrong alignment on LAction_HitAnim_UpdateSkillHitReplace");
static_assert(sizeof(LAction_HitAnim_UpdateSkillHitReplace) == 0x00000C, "Wrong size on LAction_HitAnim_UpdateSkillHitReplace");
static_assert(offsetof(LAction_HitAnim_UpdateSkillHitReplace, NewSkillHitCodeName) == 0x000000, "Member 'LAction_HitAnim_UpdateSkillHitReplace::NewSkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LAction_HitAnim_UpdateSkillHitReplace, ReturnValue) == 0x000008, "Member 'LAction_HitAnim_UpdateSkillHitReplace::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_MultiAnim.OnSelectNextAnim
// 0x0018 (0x0018 - 0x0000)
struct LAction_MultiAnim_OnSelectNextAnim final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAnimIndex;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAction_MultiAnim_OnSelectNextAnim) == 0x000008, "Wrong alignment on LAction_MultiAnim_OnSelectNextAnim");
static_assert(sizeof(LAction_MultiAnim_OnSelectNextAnim) == 0x000018, "Wrong size on LAction_MultiAnim_OnSelectNextAnim");
static_assert(offsetof(LAction_MultiAnim_OnSelectNextAnim, Montage) == 0x000000, "Member 'LAction_MultiAnim_OnSelectNextAnim::Montage' has a wrong offset!");
static_assert(offsetof(LAction_MultiAnim_OnSelectNextAnim, bInterrupted) == 0x000008, "Member 'LAction_MultiAnim_OnSelectNextAnim::bInterrupted' has a wrong offset!");
static_assert(offsetof(LAction_MultiAnim_OnSelectNextAnim, CurrentAnimIndex) == 0x00000C, "Member 'LAction_MultiAnim_OnSelectNextAnim::CurrentAnimIndex' has a wrong offset!");
static_assert(offsetof(LAction_MultiAnim_OnSelectNextAnim, ReturnValue) == 0x000010, "Member 'LAction_MultiAnim_OnSelectNextAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_MultiAnim.PlayTargetAnimByIndexBP
// 0x000C (0x000C - 0x0000)
struct LAction_MultiAnim_PlayTargetAnimByIndexBP final
{
public:
	int32                                         TargetAnimIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_MultiAnim_PlayTargetAnimByIndexBP) == 0x000004, "Wrong alignment on LAction_MultiAnim_PlayTargetAnimByIndexBP");
static_assert(sizeof(LAction_MultiAnim_PlayTargetAnimByIndexBP) == 0x00000C, "Wrong size on LAction_MultiAnim_PlayTargetAnimByIndexBP");
static_assert(offsetof(LAction_MultiAnim_PlayTargetAnimByIndexBP, TargetAnimIndex) == 0x000000, "Member 'LAction_MultiAnim_PlayTargetAnimByIndexBP::TargetAnimIndex' has a wrong offset!");
static_assert(offsetof(LAction_MultiAnim_PlayTargetAnimByIndexBP, Branches) == 0x000004, "Member 'LAction_MultiAnim_PlayTargetAnimByIndexBP::Branches' has a wrong offset!");
static_assert(offsetof(LAction_MultiAnim_PlayTargetAnimByIndexBP, ReturnValue) == 0x000008, "Member 'LAction_MultiAnim_PlayTargetAnimByIndexBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SlaveArmVisual.GetSlaveArmAdditiveAlpha
// 0x0004 (0x0004 - 0x0000)
struct LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha) == 0x000004, "Wrong alignment on LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha");
static_assert(sizeof(LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha) == 0x000004, "Wrong size on LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha");
static_assert(offsetof(LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha, ReturnValue) == 0x000000, "Member 'LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_SlaveArmVisual.GetSlaveArmAdditiveAnim
// 0x0008 (0x0008 - 0x0000)
struct LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim) == 0x000008, "Wrong alignment on LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim");
static_assert(sizeof(LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim) == 0x000008, "Wrong size on LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim");
static_assert(offsetof(LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim, ReturnValue) == 0x000000, "Member 'LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_Dialoging.IsPlayingMainAnim
// 0x0001 (0x0001 - 0x0000)
struct LAction_Dialoging_IsPlayingMainAnim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_Dialoging_IsPlayingMainAnim) == 0x000001, "Wrong alignment on LAction_Dialoging_IsPlayingMainAnim");
static_assert(sizeof(LAction_Dialoging_IsPlayingMainAnim) == 0x000001, "Wrong size on LAction_Dialoging_IsPlayingMainAnim");
static_assert(offsetof(LAction_Dialoging_IsPlayingMainAnim, ReturnValue) == 0x000000, "Member 'LAction_Dialoging_IsPlayingMainAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LAction_Dialoging.IsPlayingRotateAnim
// 0x0001 (0x0001 - 0x0000)
struct LAction_Dialoging_IsPlayingRotateAnim final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAction_Dialoging_IsPlayingRotateAnim) == 0x000001, "Wrong alignment on LAction_Dialoging_IsPlayingRotateAnim");
static_assert(sizeof(LAction_Dialoging_IsPlayingRotateAnim) == 0x000001, "Wrong size on LAction_Dialoging_IsPlayingRotateAnim");
static_assert(offsetof(LAction_Dialoging_IsPlayingRotateAnim, ReturnValue) == 0x000000, "Member 'LAction_Dialoging_IsPlayingRotateAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_Action
// 0x0010 (0x0010 - 0x0000)
struct LActionStateDebugInfo_ActionStateDebugInfo_From_Action final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStateDebugInfo_ActionStateDebugInfo_From_Action) == 0x000008, "Wrong alignment on LActionStateDebugInfo_ActionStateDebugInfo_From_Action");
static_assert(sizeof(LActionStateDebugInfo_ActionStateDebugInfo_From_Action) == 0x000010, "Wrong size on LActionStateDebugInfo_ActionStateDebugInfo_From_Action");
static_assert(offsetof(LActionStateDebugInfo_ActionStateDebugInfo_From_Action, ReturnValue) == 0x000000, "Member 'LActionStateDebugInfo_ActionStateDebugInfo_From_Action::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_Notify
// 0x0010 (0x0010 - 0x0000)
struct LActionStateDebugInfo_ActionStateDebugInfo_From_Notify final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStateDebugInfo_ActionStateDebugInfo_From_Notify) == 0x000008, "Wrong alignment on LActionStateDebugInfo_ActionStateDebugInfo_From_Notify");
static_assert(sizeof(LActionStateDebugInfo_ActionStateDebugInfo_From_Notify) == 0x000010, "Wrong size on LActionStateDebugInfo_ActionStateDebugInfo_From_Notify");
static_assert(offsetof(LActionStateDebugInfo_ActionStateDebugInfo_From_Notify, ReturnValue) == 0x000000, "Member 'LActionStateDebugInfo_ActionStateDebugInfo_From_Notify::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_Notify_ApplyInput
// 0x0010 (0x0010 - 0x0000)
struct LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput) == 0x000008, "Wrong alignment on LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput");
static_assert(sizeof(LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput) == 0x000010, "Wrong size on LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput");
static_assert(offsetof(LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput, ReturnValue) == 0x000000, "Member 'LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_NotifyEndMarked
// 0x0010 (0x0010 - 0x0000)
struct LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked) == 0x000008, "Wrong alignment on LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked");
static_assert(sizeof(LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked) == 0x000010, "Wrong size on LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked");
static_assert(offsetof(LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked, ReturnValue) == 0x000000, "Member 'LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_None
// 0x0010 (0x0010 - 0x0000)
struct LActionStateDebugInfo_ActionStateDebugInfo_None final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionStateDebugInfo_ActionStateDebugInfo_None) == 0x000008, "Wrong alignment on LActionStateDebugInfo_ActionStateDebugInfo_None");
static_assert(sizeof(LActionStateDebugInfo_ActionStateDebugInfo_None) == 0x000010, "Wrong size on LActionStateDebugInfo_ActionStateDebugInfo_None");
static_assert(offsetof(LActionStateDebugInfo_ActionStateDebugInfo_None, ReturnValue) == 0x000000, "Member 'LActionStateDebugInfo_ActionStateDebugInfo_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Aggro_Target
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Aggro_Target final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Aggro_Target) == 0x000004, "Wrong alignment on LActionState_ActionState_Aggro_Target");
static_assert(sizeof(LActionState_ActionState_Aggro_Target) == 0x000008, "Wrong size on LActionState_ActionState_Aggro_Target");
static_assert(offsetof(LActionState_ActionState_Aggro_Target, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Aggro_Target::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AIState_Force_Return_CHK
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AIState_Force_Return_CHK final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AIState_Force_Return_CHK) == 0x000004, "Wrong alignment on LActionState_ActionState_AIState_Force_Return_CHK");
static_assert(sizeof(LActionState_ActionState_AIState_Force_Return_CHK) == 0x000008, "Wrong size on LActionState_ActionState_AIState_Force_Return_CHK");
static_assert(offsetof(LActionState_ActionState_AIState_Force_Return_CHK, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AIState_Force_Return_CHK::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AITargetList_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AITargetList_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AITargetList_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_AITargetList_Disable");
static_assert(sizeof(LActionState_ActionState_AITargetList_Disable) == 0x000008, "Wrong size on LActionState_ActionState_AITargetList_Disable");
static_assert(offsetof(LActionState_ActionState_AITargetList_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AITargetList_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AITargetList_DisableInDialog
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AITargetList_DisableInDialog final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AITargetList_DisableInDialog) == 0x000004, "Wrong alignment on LActionState_ActionState_AITargetList_DisableInDialog");
static_assert(sizeof(LActionState_ActionState_AITargetList_DisableInDialog) == 0x000008, "Wrong size on LActionState_ActionState_AITargetList_DisableInDialog");
static_assert(offsetof(LActionState_ActionState_AITargetList_DisableInDialog, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AITargetList_DisableInDialog::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_AcquireGroggyPoint
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_AcquireGroggyPoint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_AcquireGroggyPoint) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_AcquireGroggyPoint");
static_assert(sizeof(LActionState_ActionState_Allow_AcquireGroggyPoint) == 0x000008, "Wrong size on LActionState_ActionState_Allow_AcquireGroggyPoint");
static_assert(offsetof(LActionState_ActionState_Allow_AcquireGroggyPoint, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_AcquireGroggyPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_ChargeCancel
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_ChargeCancel final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_ChargeCancel) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_ChargeCancel");
static_assert(sizeof(LActionState_ActionState_Allow_ChargeCancel) == 0x000008, "Wrong size on LActionState_ActionState_Allow_ChargeCancel");
static_assert(offsetof(LActionState_ActionState_Allow_ChargeCancel, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_ChargeCancel::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_Dash_Heavy
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_Dash_Heavy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_Dash_Heavy) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_Dash_Heavy");
static_assert(sizeof(LActionState_ActionState_Allow_Dash_Heavy) == 0x000008, "Wrong size on LActionState_ActionState_Allow_Dash_Heavy");
static_assert(offsetof(LActionState_ActionState_Allow_Dash_Heavy, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_Dash_Heavy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_Dash_Light
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_Dash_Light final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_Dash_Light) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_Dash_Light");
static_assert(sizeof(LActionState_ActionState_Allow_Dash_Light) == 0x000008, "Wrong size on LActionState_ActionState_Allow_Dash_Light");
static_assert(offsetof(LActionState_ActionState_Allow_Dash_Light, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_Dash_Light::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_Dying
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_Dying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_Dying) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_Dying");
static_assert(sizeof(LActionState_ActionState_Allow_Dying) == 0x000008, "Wrong size on LActionState_ActionState_Allow_Dying");
static_assert(offsetof(LActionState_ActionState_Allow_Dying, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_Dying::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_FableCancel
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_FableCancel final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_FableCancel) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_FableCancel");
static_assert(sizeof(LActionState_ActionState_Allow_FableCancel) == 0x000008, "Wrong size on LActionState_ActionState_Allow_FableCancel");
static_assert(offsetof(LActionState_ActionState_Allow_FableCancel, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_FableCancel::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_GuardRepulse
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_GuardRepulse final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_GuardRepulse) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_GuardRepulse");
static_assert(sizeof(LActionState_ActionState_Allow_GuardRepulse) == 0x000008, "Wrong size on LActionState_ActionState_Allow_GuardRepulse");
static_assert(offsetof(LActionState_ActionState_Allow_GuardRepulse, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_GuardRepulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_LieDying
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_LieDying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_LieDying) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_LieDying");
static_assert(sizeof(LActionState_ActionState_Allow_LieDying) == 0x000008, "Wrong size on LActionState_ActionState_Allow_LieDying");
static_assert(offsetof(LActionState_ActionState_Allow_LieDying, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_LieDying::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Allow_RepairCancel
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Allow_RepairCancel final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Allow_RepairCancel) == 0x000004, "Wrong alignment on LActionState_ActionState_Allow_RepairCancel");
static_assert(sizeof(LActionState_ActionState_Allow_RepairCancel) == 0x000008, "Wrong size on LActionState_ActionState_Allow_RepairCancel");
static_assert(offsetof(LActionState_ActionState_Allow_RepairCancel, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Allow_RepairCancel::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowAction_Sequence
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowAction_Sequence final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowAction_Sequence) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowAction_Sequence");
static_assert(sizeof(LActionState_ActionState_AllowAction_Sequence) == 0x000008, "Wrong size on LActionState_ActionState_AllowAction_Sequence");
static_assert(offsetof(LActionState_ActionState_AllowAction_Sequence, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowAction_Sequence::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Dash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Dash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Dash) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Dash");
static_assert(sizeof(LActionState_ActionState_AllowInput_Dash) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Dash");
static_assert(offsetof(LActionState_ActionState_AllowInput_Dash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Dash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_DoubleDash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_DoubleDash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_DoubleDash) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_DoubleDash");
static_assert(sizeof(LActionState_ActionState_AllowInput_DoubleDash) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_DoubleDash");
static_assert(offsetof(LActionState_ActionState_AllowInput_DoubleDash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_DoubleDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_FableHandle
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_FableHandle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_FableHandle) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_FableHandle");
static_assert(sizeof(LActionState_ActionState_AllowInput_FableHandle) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_FableHandle");
static_assert(offsetof(LActionState_ActionState_AllowInput_FableHandle, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_FableHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Frenzy
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Frenzy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Frenzy) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Frenzy");
static_assert(sizeof(LActionState_ActionState_AllowInput_Frenzy) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Frenzy");
static_assert(offsetof(LActionState_ActionState_AllowInput_Frenzy, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Frenzy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_GetUpDash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_GetUpDash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_GetUpDash) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_GetUpDash");
static_assert(sizeof(LActionState_ActionState_AllowInput_GetUpDash) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_GetUpDash");
static_assert(offsetof(LActionState_ActionState_AllowInput_GetUpDash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_GetUpDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Guard");
static_assert(sizeof(LActionState_ActionState_AllowInput_Guard) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Guard");
static_assert(offsetof(LActionState_ActionState_AllowInput_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_LightAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_LightAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_LightAttack) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_LightAttack");
static_assert(sizeof(LActionState_ActionState_AllowInput_LightAttack) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_LightAttack");
static_assert(offsetof(LActionState_ActionState_AllowInput_LightAttack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_LightAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Movement
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Movement final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Movement) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Movement");
static_assert(sizeof(LActionState_ActionState_AllowInput_Movement) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Movement");
static_assert(offsetof(LActionState_ActionState_AllowInput_Movement, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Movement::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Movement_Forced
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Movement_Forced final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Movement_Forced) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Movement_Forced");
static_assert(sizeof(LActionState_ActionState_AllowInput_Movement_Forced) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Movement_Forced");
static_assert(offsetof(LActionState_ActionState_AllowInput_Movement_Forced, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Movement_Forced::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Parrying
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Parrying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Parrying) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Parrying");
static_assert(sizeof(LActionState_ActionState_AllowInput_Parrying) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Parrying");
static_assert(offsetof(LActionState_ActionState_AllowInput_Parrying, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Parrying::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Rotation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Rotation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Rotation) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Rotation");
static_assert(sizeof(LActionState_ActionState_AllowInput_Rotation) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Rotation");
static_assert(offsetof(LActionState_ActionState_AllowInput_Rotation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Rotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_Rotation_Forced
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_Rotation_Forced final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_Rotation_Forced) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_Rotation_Forced");
static_assert(sizeof(LActionState_ActionState_AllowInput_Rotation_Forced) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_Rotation_Forced");
static_assert(offsetof(LActionState_ActionState_AllowInput_Rotation_Forced, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_Rotation_Forced::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_SlaveArm
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_SlaveArm final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_SlaveArm) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_SlaveArm");
static_assert(sizeof(LActionState_ActionState_AllowInput_SlaveArm) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_SlaveArm");
static_assert(offsetof(LActionState_ActionState_AllowInput_SlaveArm, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_SlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_StrongAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_StrongAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_StrongAttack) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_StrongAttack");
static_assert(sizeof(LActionState_ActionState_AllowInput_StrongAttack) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_StrongAttack");
static_assert(offsetof(LActionState_ActionState_AllowInput_StrongAttack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_StrongAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_UseItem
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_UseItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_UseItem) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_UseItem");
static_assert(sizeof(LActionState_ActionState_AllowInput_UseItem) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_UseItem");
static_assert(offsetof(LActionState_ActionState_AllowInput_UseItem, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_UseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_AllowInput_WeaponChange
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_AllowInput_WeaponChange final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_AllowInput_WeaponChange) == 0x000004, "Wrong alignment on LActionState_ActionState_AllowInput_WeaponChange");
static_assert(sizeof(LActionState_ActionState_AllowInput_WeaponChange) == 0x000008, "Wrong size on LActionState_ActionState_AllowInput_WeaponChange");
static_assert(offsetof(LActionState_ActionState_AllowInput_WeaponChange, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_AllowInput_WeaponChange::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ApplyInput
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ApplyInput final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ApplyInput) == 0x000004, "Wrong alignment on LActionState_ActionState_ApplyInput");
static_assert(sizeof(LActionState_ActionState_ApplyInput) == 0x000008, "Wrong size on LActionState_ActionState_ApplyInput");
static_assert(offsetof(LActionState_ActionState_ApplyInput, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ApplyInput::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_BladeWeight
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_BladeWeight final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_BladeWeight) == 0x000004, "Wrong alignment on LActionState_ActionState_BladeWeight");
static_assert(sizeof(LActionState_ActionState_BladeWeight) == 0x000008, "Wrong size on LActionState_ActionState_BladeWeight");
static_assert(offsetof(LActionState_ActionState_BladeWeight, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_BladeWeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Can_Dodge_Zero_Stamina
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Can_Dodge_Zero_Stamina final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Can_Dodge_Zero_Stamina) == 0x000004, "Wrong alignment on LActionState_ActionState_Can_Dodge_Zero_Stamina");
static_assert(sizeof(LActionState_ActionState_Can_Dodge_Zero_Stamina) == 0x000008, "Wrong size on LActionState_ActionState_Can_Dodge_Zero_Stamina");
static_assert(offsetof(LActionState_ActionState_Can_Dodge_Zero_Stamina, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Can_Dodge_Zero_Stamina::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_CancelMove
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_CancelMove final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_CancelMove) == 0x000004, "Wrong alignment on LActionState_ActionState_CancelMove");
static_assert(sizeof(LActionState_ActionState_CancelMove) == 0x000008, "Wrong size on LActionState_ActionState_CancelMove");
static_assert(offsetof(LActionState_ActionState_CancelMove, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_CancelMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Cinematic
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Cinematic final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Cinematic) == 0x000004, "Wrong alignment on LActionState_ActionState_Cinematic");
static_assert(sizeof(LActionState_ActionState_Cinematic) == 0x000008, "Wrong size on LActionState_ActionState_Cinematic");
static_assert(offsetof(LActionState_ActionState_Cinematic, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Cinematic::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ClimbDown
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ClimbDown final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ClimbDown) == 0x000004, "Wrong alignment on LActionState_ActionState_ClimbDown");
static_assert(sizeof(LActionState_ActionState_ClimbDown) == 0x000008, "Wrong size on LActionState_ActionState_ClimbDown");
static_assert(offsetof(LActionState_ActionState_ClimbDown, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ClimbDown::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ClimbUp
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ClimbUp final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ClimbUp) == 0x000004, "Wrong alignment on LActionState_ActionState_ClimbUp");
static_assert(sizeof(LActionState_ActionState_ClimbUp) == 0x000008, "Wrong size on LActionState_ActionState_ClimbUp");
static_assert(offsetof(LActionState_ActionState_ClimbUp, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ClimbUp::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ConsumeMovement
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ConsumeMovement final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ConsumeMovement) == 0x000004, "Wrong alignment on LActionState_ActionState_ConsumeMovement");
static_assert(sizeof(LActionState_ActionState_ConsumeMovement) == 0x000008, "Wrong size on LActionState_ActionState_ConsumeMovement");
static_assert(offsetof(LActionState_ActionState_ConsumeMovement, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ConsumeMovement::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ConsumeRotation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ConsumeRotation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ConsumeRotation) == 0x000004, "Wrong alignment on LActionState_ActionState_ConsumeRotation");
static_assert(sizeof(LActionState_ActionState_ConsumeRotation) == 0x000008, "Wrong size on LActionState_ActionState_ConsumeRotation");
static_assert(offsetof(LActionState_ActionState_ConsumeRotation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ConsumeRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Dash_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Dash_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Dash_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_Dash_Disable");
static_assert(sizeof(LActionState_ActionState_Dash_Disable) == 0x000008, "Wrong size on LActionState_ActionState_Dash_Disable");
static_assert(offsetof(LActionState_ActionState_Dash_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Dash_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Dash_SuperHeavy
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Dash_SuperHeavy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Dash_SuperHeavy) == 0x000004, "Wrong alignment on LActionState_ActionState_Dash_SuperHeavy");
static_assert(sizeof(LActionState_ActionState_Dash_SuperHeavy) == 0x000008, "Wrong size on LActionState_ActionState_Dash_SuperHeavy");
static_assert(offsetof(LActionState_ActionState_Dash_SuperHeavy, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Dash_SuperHeavy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Dead
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Dead) == 0x000004, "Wrong alignment on LActionState_ActionState_Dead");
static_assert(sizeof(LActionState_ActionState_Dead) == 0x000008, "Wrong size on LActionState_ActionState_Dead");
static_assert(offsetof(LActionState_ActionState_Dead, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_DeadInvincible_DeadCharacter
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_DeadInvincible_DeadCharacter final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_DeadInvincible_DeadCharacter) == 0x000004, "Wrong alignment on LActionState_ActionState_DeadInvincible_DeadCharacter");
static_assert(sizeof(LActionState_ActionState_DeadInvincible_DeadCharacter) == 0x000008, "Wrong size on LActionState_ActionState_DeadInvincible_DeadCharacter");
static_assert(offsetof(LActionState_ActionState_DeadInvincible_DeadCharacter, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_DeadInvincible_DeadCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_DeadInvincible_WorldCommand
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_DeadInvincible_WorldCommand final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_DeadInvincible_WorldCommand) == 0x000004, "Wrong alignment on LActionState_ActionState_DeadInvincible_WorldCommand");
static_assert(sizeof(LActionState_ActionState_DeadInvincible_WorldCommand) == 0x000008, "Wrong size on LActionState_ActionState_DeadInvincible_WorldCommand");
static_assert(offsetof(LActionState_ActionState_DeadInvincible_WorldCommand, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_DeadInvincible_WorldCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_DepenetrateFromEnv
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_DepenetrateFromEnv final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_DepenetrateFromEnv) == 0x000004, "Wrong alignment on LActionState_ActionState_DepenetrateFromEnv");
static_assert(sizeof(LActionState_ActionState_DepenetrateFromEnv) == 0x000008, "Wrong size on LActionState_ActionState_DepenetrateFromEnv");
static_assert(offsetof(LActionState_ActionState_DepenetrateFromEnv, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_DepenetrateFromEnv::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_DestructionDefence
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_DestructionDefence final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_DestructionDefence) == 0x000004, "Wrong alignment on LActionState_ActionState_DestructionDefence");
static_assert(sizeof(LActionState_ActionState_DestructionDefence) == 0x000008, "Wrong size on LActionState_ActionState_DestructionDefence");
static_assert(offsetof(LActionState_ActionState_DestructionDefence, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_DestructionDefence::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Dialoging
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Dialoging final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Dialoging) == 0x000004, "Wrong alignment on LActionState_ActionState_Dialoging");
static_assert(sizeof(LActionState_ActionState_Dialoging) == 0x000008, "Wrong size on LActionState_ActionState_Dialoging");
static_assert(offsetof(LActionState_ActionState_Dialoging, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Dialoging::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Disable_Footstep
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Disable_Footstep final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Disable_Footstep) == 0x000004, "Wrong alignment on LActionState_ActionState_Disable_Footstep");
static_assert(sizeof(LActionState_ActionState_Disable_Footstep) == 0x000008, "Wrong size on LActionState_ActionState_Disable_Footstep");
static_assert(offsetof(LActionState_ActionState_Disable_Footstep, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Disable_Footstep::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Disable_LockOnRotation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Disable_LockOnRotation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Disable_LockOnRotation) == 0x000004, "Wrong alignment on LActionState_ActionState_Disable_LockOnRotation");
static_assert(sizeof(LActionState_ActionState_Disable_LockOnRotation) == 0x000008, "Wrong size on LActionState_ActionState_Disable_LockOnRotation");
static_assert(offsetof(LActionState_ActionState_Disable_LockOnRotation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Disable_LockOnRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Disable_Send_HelpSignal
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Disable_Send_HelpSignal final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Disable_Send_HelpSignal) == 0x000004, "Wrong alignment on LActionState_ActionState_Disable_Send_HelpSignal");
static_assert(sizeof(LActionState_ActionState_Disable_Send_HelpSignal) == 0x000008, "Wrong size on LActionState_ActionState_Disable_Send_HelpSignal");
static_assert(offsetof(LActionState_ActionState_Disable_Send_HelpSignal, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Disable_Send_HelpSignal::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Disable_TransformModifier_MoveActor
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Disable_TransformModifier_MoveActor final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Disable_TransformModifier_MoveActor) == 0x000004, "Wrong alignment on LActionState_ActionState_Disable_TransformModifier_MoveActor");
static_assert(sizeof(LActionState_ActionState_Disable_TransformModifier_MoveActor) == 0x000008, "Wrong size on LActionState_ActionState_Disable_TransformModifier_MoveActor");
static_assert(offsetof(LActionState_ActionState_Disable_TransformModifier_MoveActor, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Disable_TransformModifier_MoveActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Dodge
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Dodge final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Dodge) == 0x000004, "Wrong alignment on LActionState_ActionState_Dodge");
static_assert(sizeof(LActionState_ActionState_Dodge) == 0x000008, "Wrong size on LActionState_ActionState_Dodge");
static_assert(offsetof(LActionState_ActionState_Dodge, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Dodge::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_DoubleDash_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_DoubleDash_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_DoubleDash_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_DoubleDash_Enable");
static_assert(sizeof(LActionState_ActionState_DoubleDash_Enable) == 0x000008, "Wrong size on LActionState_ActionState_DoubleDash_Enable");
static_assert(offsetof(LActionState_ActionState_DoubleDash_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_DoubleDash_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Dying
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Dying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Dying) == 0x000004, "Wrong alignment on LActionState_ActionState_Dying");
static_assert(sizeof(LActionState_ActionState_Dying) == 0x000008, "Wrong size on LActionState_ActionState_Dying");
static_assert(offsetof(LActionState_ActionState_Dying, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Dying::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ExitReposition_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ExitReposition_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ExitReposition_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_ExitReposition_Disable");
static_assert(sizeof(LActionState_ActionState_ExitReposition_Disable) == 0x000008, "Wrong size on LActionState_ActionState_ExitReposition_Disable");
static_assert(offsetof(LActionState_ActionState_ExitReposition_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ExitReposition_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Fable_Buff_Blade
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Fable_Buff_Blade final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Fable_Buff_Blade) == 0x000004, "Wrong alignment on LActionState_ActionState_Fable_Buff_Blade");
static_assert(sizeof(LActionState_ActionState_Fable_Buff_Blade) == 0x000008, "Wrong size on LActionState_ActionState_Fable_Buff_Blade");
static_assert(offsetof(LActionState_ActionState_Fable_Buff_Blade, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Fable_Buff_Blade::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Fable_Buff_Handle
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Fable_Buff_Handle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Fable_Buff_Handle) == 0x000004, "Wrong alignment on LActionState_ActionState_Fable_Buff_Handle");
static_assert(sizeof(LActionState_ActionState_Fable_Buff_Handle) == 0x000008, "Wrong size on LActionState_ActionState_Fable_Buff_Handle");
static_assert(offsetof(LActionState_ActionState_Fable_Buff_Handle, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Fable_Buff_Handle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FableArt
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FableArt final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FableArt) == 0x000004, "Wrong alignment on LActionState_ActionState_FableArt");
static_assert(sizeof(LActionState_ActionState_FableArt) == 0x000008, "Wrong size on LActionState_ActionState_FableArt");
static_assert(offsetof(LActionState_ActionState_FableArt, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FableArt::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Falling
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Falling final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Falling) == 0x000004, "Wrong alignment on LActionState_ActionState_Falling");
static_assert(sizeof(LActionState_ActionState_Falling) == 0x000008, "Wrong size on LActionState_ActionState_Falling");
static_assert(offsetof(LActionState_ActionState_Falling, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Falling::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FallingFromDownDrag_B
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FallingFromDownDrag_B final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FallingFromDownDrag_B) == 0x000004, "Wrong alignment on LActionState_ActionState_FallingFromDownDrag_B");
static_assert(sizeof(LActionState_ActionState_FallingFromDownDrag_B) == 0x000008, "Wrong size on LActionState_ActionState_FallingFromDownDrag_B");
static_assert(offsetof(LActionState_ActionState_FallingFromDownDrag_B, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FallingFromDownDrag_B::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FallingFromDownDrag_F
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FallingFromDownDrag_F final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FallingFromDownDrag_F) == 0x000004, "Wrong alignment on LActionState_ActionState_FallingFromDownDrag_F");
static_assert(sizeof(LActionState_ActionState_FallingFromDownDrag_F) == 0x000008, "Wrong size on LActionState_ActionState_FallingFromDownDrag_F");
static_assert(offsetof(LActionState_ActionState_FallingFromDownDrag_F, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FallingFromDownDrag_F::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FallingStart
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FallingStart final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FallingStart) == 0x000004, "Wrong alignment on LActionState_ActionState_FallingStart");
static_assert(sizeof(LActionState_ActionState_FallingStart) == 0x000008, "Wrong size on LActionState_ActionState_FallingStart");
static_assert(offsetof(LActionState_ActionState_FallingStart, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FallingStart::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FatalAttack_As_Attacker
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FatalAttack_As_Attacker final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FatalAttack_As_Attacker) == 0x000004, "Wrong alignment on LActionState_ActionState_FatalAttack_As_Attacker");
static_assert(sizeof(LActionState_ActionState_FatalAttack_As_Attacker) == 0x000008, "Wrong size on LActionState_ActionState_FatalAttack_As_Attacker");
static_assert(offsetof(LActionState_ActionState_FatalAttack_As_Attacker, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FatalAttack_As_Attacker::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FatalAttack_As_Victim
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FatalAttack_As_Victim final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FatalAttack_As_Victim) == 0x000004, "Wrong alignment on LActionState_ActionState_FatalAttack_As_Victim");
static_assert(sizeof(LActionState_ActionState_FatalAttack_As_Victim) == 0x000008, "Wrong size on LActionState_ActionState_FatalAttack_As_Victim");
static_assert(offsetof(LActionState_ActionState_FatalAttack_As_Victim, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FatalAttack_As_Victim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FatalAttack_Counter_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FatalAttack_Counter_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FatalAttack_Counter_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_FatalAttack_Counter_Enable");
static_assert(sizeof(LActionState_ActionState_FatalAttack_Counter_Enable) == 0x000008, "Wrong size on LActionState_ActionState_FatalAttack_Counter_Enable");
static_assert(offsetof(LActionState_ActionState_FatalAttack_Counter_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FatalAttack_Counter_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FatalAttack_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FatalAttack_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FatalAttack_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_FatalAttack_Disable");
static_assert(sizeof(LActionState_ActionState_FatalAttack_Disable) == 0x000008, "Wrong size on LActionState_ActionState_FatalAttack_Disable");
static_assert(offsetof(LActionState_ActionState_FatalAttack_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FatalAttack_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FatalAttack_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FatalAttack_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FatalAttack_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_FatalAttack_Enable");
static_assert(sizeof(LActionState_ActionState_FatalAttack_Enable) == 0x000008, "Wrong size on LActionState_ActionState_FatalAttack_Enable");
static_assert(offsetof(LActionState_ActionState_FatalAttack_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FatalAttack_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FatalAttack_Enable_Forced
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FatalAttack_Enable_Forced final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FatalAttack_Enable_Forced) == 0x000004, "Wrong alignment on LActionState_ActionState_FatalAttack_Enable_Forced");
static_assert(sizeof(LActionState_ActionState_FatalAttack_Enable_Forced) == 0x000008, "Wrong size on LActionState_ActionState_FatalAttack_Enable_Forced");
static_assert(offsetof(LActionState_ActionState_FatalAttack_Enable_Forced, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FatalAttack_Enable_Forced::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Floating
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Floating final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Floating) == 0x000004, "Wrong alignment on LActionState_ActionState_Floating");
static_assert(sizeof(LActionState_ActionState_Floating) == 0x000008, "Wrong size on LActionState_ActionState_Floating");
static_assert(offsetof(LActionState_ActionState_Floating, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Floating::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FloatingCeiling
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FloatingCeiling final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FloatingCeiling) == 0x000004, "Wrong alignment on LActionState_ActionState_FloatingCeiling");
static_assert(sizeof(LActionState_ActionState_FloatingCeiling) == 0x000008, "Wrong size on LActionState_ActionState_FloatingCeiling");
static_assert(offsetof(LActionState_ActionState_FloatingCeiling, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FloatingCeiling::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FloatingHit_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FloatingHit_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FloatingHit_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_FloatingHit_Enable");
static_assert(sizeof(LActionState_ActionState_FloatingHit_Enable) == 0x000008, "Wrong size on LActionState_ActionState_FloatingHit_Enable");
static_assert(offsetof(LActionState_ActionState_FloatingHit_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FloatingHit_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Frenzy
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Frenzy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Frenzy) == 0x000004, "Wrong alignment on LActionState_ActionState_Frenzy");
static_assert(sizeof(LActionState_ActionState_Frenzy) == 0x000008, "Wrong size on LActionState_ActionState_Frenzy");
static_assert(offsetof(LActionState_ActionState_Frenzy, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Frenzy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FuryAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FuryAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FuryAttack) == 0x000004, "Wrong alignment on LActionState_ActionState_FuryAttack");
static_assert(sizeof(LActionState_ActionState_FuryAttack) == 0x000008, "Wrong size on LActionState_ActionState_FuryAttack");
static_assert(offsetof(LActionState_ActionState_FuryAttack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FuryAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_FuryAttackGuardEnable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_FuryAttackGuardEnable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_FuryAttackGuardEnable) == 0x000004, "Wrong alignment on LActionState_ActionState_FuryAttackGuardEnable");
static_assert(sizeof(LActionState_ActionState_FuryAttackGuardEnable) == 0x000008, "Wrong size on LActionState_ActionState_FuryAttackGuardEnable");
static_assert(offsetof(LActionState_ActionState_FuryAttackGuardEnable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_FuryAttackGuardEnable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_GetUpDash_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_GetUpDash_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_GetUpDash_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_GetUpDash_Disable");
static_assert(sizeof(LActionState_ActionState_GetUpDash_Disable) == 0x000008, "Wrong size on LActionState_ActionState_GetUpDash_Disable");
static_assert(offsetof(LActionState_ActionState_GetUpDash_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_GetUpDash_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_GetUpDash_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_GetUpDash_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_GetUpDash_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_GetUpDash_Enable");
static_assert(sizeof(LActionState_ActionState_GetUpDash_Enable) == 0x000008, "Wrong size on LActionState_ActionState_GetUpDash_Enable");
static_assert(offsetof(LActionState_ActionState_GetUpDash_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_GetUpDash_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Grab
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Grab final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Grab) == 0x000004, "Wrong alignment on LActionState_ActionState_Grab");
static_assert(sizeof(LActionState_ActionState_Grab) == 0x000008, "Wrong size on LActionState_ActionState_Grab");
static_assert(offsetof(LActionState_ActionState_Grab, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Grab::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Grabbed
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Grabbed final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Grabbed) == 0x000004, "Wrong alignment on LActionState_ActionState_Grabbed");
static_assert(sizeof(LActionState_ActionState_Grabbed) == 0x000008, "Wrong size on LActionState_ActionState_Grabbed");
static_assert(offsetof(LActionState_ActionState_Grabbed, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Grabbed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_GrappleGun_Reflect
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_GrappleGun_Reflect final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_GrappleGun_Reflect) == 0x000004, "Wrong alignment on LActionState_ActionState_GrappleGun_Reflect");
static_assert(sizeof(LActionState_ActionState_GrappleGun_Reflect) == 0x000008, "Wrong size on LActionState_ActionState_GrappleGun_Reflect");
static_assert(offsetof(LActionState_ActionState_GrappleGun_Reflect, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_GrappleGun_Reflect::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Groggy
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Groggy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Groggy) == 0x000004, "Wrong alignment on LActionState_ActionState_Groggy");
static_assert(sizeof(LActionState_ActionState_Groggy) == 0x000008, "Wrong size on LActionState_ActionState_Groggy");
static_assert(offsetof(LActionState_ActionState_Groggy, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Groggy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Groggy_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Groggy_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Groggy_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_Groggy_Enable");
static_assert(sizeof(LActionState_ActionState_Groggy_Enable) == 0x000008, "Wrong size on LActionState_ActionState_Groggy_Enable");
static_assert(offsetof(LActionState_ActionState_Groggy_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Groggy_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Groggy_Enable_Time_Added
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Groggy_Enable_Time_Added final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Groggy_Enable_Time_Added) == 0x000004, "Wrong alignment on LActionState_ActionState_Groggy_Enable_Time_Added");
static_assert(sizeof(LActionState_ActionState_Groggy_Enable_Time_Added) == 0x000008, "Wrong size on LActionState_ActionState_Groggy_Enable_Time_Added");
static_assert(offsetof(LActionState_ActionState_Groggy_Enable_Time_Added, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Groggy_Enable_Time_Added::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Guard_Hit
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Guard_Hit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Guard_Hit) == 0x000004, "Wrong alignment on LActionState_ActionState_Guard_Hit");
static_assert(sizeof(LActionState_ActionState_Guard_Hit) == 0x000008, "Wrong size on LActionState_ActionState_Guard_Hit");
static_assert(offsetof(LActionState_ActionState_Guard_Hit, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Guard_Hit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_GuardEx_CoolTime
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_GuardEx_CoolTime final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_GuardEx_CoolTime) == 0x000004, "Wrong alignment on LActionState_ActionState_GuardEx_CoolTime");
static_assert(sizeof(LActionState_ActionState_GuardEx_CoolTime) == 0x000008, "Wrong size on LActionState_ActionState_GuardEx_CoolTime");
static_assert(offsetof(LActionState_ActionState_GuardEx_CoolTime, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_GuardEx_CoolTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_HeadCostumeOff_Sequence
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_HeadCostumeOff_Sequence final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_HeadCostumeOff_Sequence) == 0x000004, "Wrong alignment on LActionState_ActionState_HeadCostumeOff_Sequence");
static_assert(sizeof(LActionState_ActionState_HeadCostumeOff_Sequence) == 0x000008, "Wrong size on LActionState_ActionState_HeadCostumeOff_Sequence");
static_assert(offsetof(LActionState_ActionState_HeadCostumeOff_Sequence, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_HeadCostumeOff_Sequence::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Heal_Guard_Regain_Maintain
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Heal_Guard_Regain_Maintain final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Heal_Guard_Regain_Maintain) == 0x000004, "Wrong alignment on LActionState_ActionState_Heal_Guard_Regain_Maintain");
static_assert(sizeof(LActionState_ActionState_Heal_Guard_Regain_Maintain) == 0x000008, "Wrong size on LActionState_ActionState_Heal_Guard_Regain_Maintain");
static_assert(offsetof(LActionState_ActionState_Heal_Guard_Regain_Maintain, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Heal_Guard_Regain_Maintain::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Hide
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Hide final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Hide) == 0x000004, "Wrong alignment on LActionState_ActionState_Hide");
static_assert(sizeof(LActionState_ActionState_Hide) == 0x000008, "Wrong size on LActionState_ActionState_Hide");
static_assert(offsetof(LActionState_ActionState_Hide, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Hide::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_HitBoom
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_HitBoom final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_HitBoom) == 0x000004, "Wrong alignment on LActionState_ActionState_HitBoom");
static_assert(sizeof(LActionState_ActionState_HitBoom) == 0x000008, "Wrong size on LActionState_ActionState_HitBoom");
static_assert(offsetof(LActionState_ActionState_HitBoom, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_HitBoom::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_HitBoom_CoolTime
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_HitBoom_CoolTime final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_HitBoom_CoolTime) == 0x000004, "Wrong alignment on LActionState_ActionState_HitBoom_CoolTime");
static_assert(sizeof(LActionState_ActionState_HitBoom_CoolTime) == 0x000008, "Wrong size on LActionState_ActionState_HitBoom_CoolTime");
static_assert(offsetof(LActionState_ActionState_HitBoom_CoolTime, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_HitBoom_CoolTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_HitCheck
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_HitCheck final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_HitCheck) == 0x000004, "Wrong alignment on LActionState_ActionState_HitCheck");
static_assert(sizeof(LActionState_ActionState_HitCheck) == 0x000008, "Wrong size on LActionState_ActionState_HitCheck");
static_assert(offsetof(LActionState_ActionState_HitCheck, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_HitCheck::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Ignore_Damage
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Ignore_Damage final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Ignore_Damage) == 0x000004, "Wrong alignment on LActionState_ActionState_Ignore_Damage");
static_assert(sizeof(LActionState_ActionState_Ignore_Damage) == 0x000008, "Wrong size on LActionState_ActionState_Ignore_Damage");
static_assert(offsetof(LActionState_ActionState_Ignore_Damage, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Ignore_Damage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Ignore_Drop_Ergo
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Ignore_Drop_Ergo final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Ignore_Drop_Ergo) == 0x000004, "Wrong alignment on LActionState_ActionState_Ignore_Drop_Ergo");
static_assert(sizeof(LActionState_ActionState_Ignore_Drop_Ergo) == 0x000008, "Wrong size on LActionState_ActionState_Ignore_Drop_Ergo");
static_assert(offsetof(LActionState_ActionState_Ignore_Drop_Ergo, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Ignore_Drop_Ergo::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Ignore_FallingLateralFriction
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Ignore_FallingLateralFriction final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Ignore_FallingLateralFriction) == 0x000004, "Wrong alignment on LActionState_ActionState_Ignore_FallingLateralFriction");
static_assert(sizeof(LActionState_ActionState_Ignore_FallingLateralFriction) == 0x000008, "Wrong size on LActionState_ActionState_Ignore_FallingLateralFriction");
static_assert(offsetof(LActionState_ActionState_Ignore_FallingLateralFriction, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Ignore_FallingLateralFriction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Ignore_Invincible_OnDamagedByAbnormal
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal) == 0x000004, "Wrong alignment on LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal");
static_assert(sizeof(LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal) == 0x000008, "Wrong size on LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal");
static_assert(offsetof(LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Ignore_LeverSpeed_ABP
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Ignore_LeverSpeed_ABP final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Ignore_LeverSpeed_ABP) == 0x000004, "Wrong alignment on LActionState_ActionState_Ignore_LeverSpeed_ABP");
static_assert(sizeof(LActionState_ActionState_Ignore_LeverSpeed_ABP) == 0x000008, "Wrong size on LActionState_ActionState_Ignore_LeverSpeed_ABP");
static_assert(offsetof(LActionState_ActionState_Ignore_LeverSpeed_ABP, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Ignore_LeverSpeed_ABP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Ignore_Repulse_All
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Ignore_Repulse_All final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Ignore_Repulse_All) == 0x000004, "Wrong alignment on LActionState_ActionState_Ignore_Repulse_All");
static_assert(sizeof(LActionState_ActionState_Ignore_Repulse_All) == 0x000008, "Wrong size on LActionState_ActionState_Ignore_Repulse_All");
static_assert(offsetof(LActionState_ActionState_Ignore_Repulse_All, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Ignore_Repulse_All::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_IK_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_IK_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_IK_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_IK_Disable");
static_assert(sizeof(LActionState_ActionState_IK_Disable) == 0x000008, "Wrong size on LActionState_ActionState_IK_Disable");
static_assert(offsetof(LActionState_ActionState_IK_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_IK_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Damage
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Damage final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Damage) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Damage");
static_assert(sizeof(LActionState_ActionState_Immune_Damage) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Damage");
static_assert(offsetof(LActionState_ActionState_Immune_Damage, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Damage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Elemental
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Elemental final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Elemental) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Elemental");
static_assert(sizeof(LActionState_ActionState_Immune_Elemental) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Elemental");
static_assert(offsetof(LActionState_ActionState_Immune_Elemental, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Elemental::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Groggy
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Groggy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Groggy) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Groggy");
static_assert(sizeof(LActionState_ActionState_Immune_Groggy) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Groggy");
static_assert(offsetof(LActionState_ActionState_Immune_Groggy, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Groggy::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Hit
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Hit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Hit) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Hit");
static_assert(sizeof(LActionState_ActionState_Immune_Hit) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Hit");
static_assert(offsetof(LActionState_ActionState_Immune_Hit, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Hit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_HitActionDMGStand
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_HitActionDMGStand final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_HitActionDMGStand) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_HitActionDMGStand");
static_assert(sizeof(LActionState_ActionState_Immune_HitActionDMGStand) == 0x000008, "Wrong size on LActionState_ActionState_Immune_HitActionDMGStand");
static_assert(offsetof(LActionState_ActionState_Immune_HitActionDMGStand, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_HitActionDMGStand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_HitActionDownAwayUp
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_HitActionDownAwayUp final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_HitActionDownAwayUp) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_HitActionDownAwayUp");
static_assert(sizeof(LActionState_ActionState_Immune_HitActionDownAwayUp) == 0x000008, "Wrong size on LActionState_ActionState_Immune_HitActionDownAwayUp");
static_assert(offsetof(LActionState_ActionState_Immune_HitActionDownAwayUp, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_HitActionDownAwayUp::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_HitActionDownDragStamp
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_HitActionDownDragStamp final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_HitActionDownDragStamp) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_HitActionDownDragStamp");
static_assert(sizeof(LActionState_ActionState_Immune_HitActionDownDragStamp) == 0x000008, "Wrong size on LActionState_ActionState_Immune_HitActionDownDragStamp");
static_assert(offsetof(LActionState_ActionState_Immune_HitActionDownDragStamp, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_HitActionDownDragStamp::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_HitActionGrab
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_HitActionGrab final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_HitActionGrab) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_HitActionGrab");
static_assert(sizeof(LActionState_ActionState_Immune_HitActionGrab) == 0x000008, "Wrong size on LActionState_ActionState_Immune_HitActionGrab");
static_assert(offsetof(LActionState_ActionState_Immune_HitActionGrab, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_HitActionGrab::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_HitActionKnockBack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_HitActionKnockBack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_HitActionKnockBack) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_HitActionKnockBack");
static_assert(sizeof(LActionState_ActionState_Immune_HitActionKnockBack) == 0x000008, "Wrong size on LActionState_ActionState_Immune_HitActionKnockBack");
static_assert(offsetof(LActionState_ActionState_Immune_HitActionKnockBack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_HitActionKnockBack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Immune_Abnormal_Fire_Point
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point");
static_assert(sizeof(LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point");
static_assert(offsetof(LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Paralyzation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Paralyzation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Paralyzation) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Paralyzation");
static_assert(sizeof(LActionState_ActionState_Immune_Paralyzation) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Paralyzation");
static_assert(offsetof(LActionState_ActionState_Immune_Paralyzation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Paralyzation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Special_Elemental
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Special_Elemental final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Special_Elemental) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Special_Elemental");
static_assert(sizeof(LActionState_ActionState_Immune_Special_Elemental) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Special_Elemental");
static_assert(offsetof(LActionState_ActionState_Immune_Special_Elemental, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Special_Elemental::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Immune_Tough
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Immune_Tough final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Immune_Tough) == 0x000004, "Wrong alignment on LActionState_ActionState_Immune_Tough");
static_assert(sizeof(LActionState_ActionState_Immune_Tough) == 0x000008, "Wrong size on LActionState_ActionState_Immune_Tough");
static_assert(offsetof(LActionState_ActionState_Immune_Tough, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Immune_Tough::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Invincible
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Invincible final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Invincible) == 0x000004, "Wrong alignment on LActionState_ActionState_Invincible");
static_assert(sizeof(LActionState_ActionState_Invincible) == 0x000008, "Wrong size on LActionState_ActionState_Invincible");
static_assert(offsetof(LActionState_ActionState_Invincible, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Invincible::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Key_Pressed_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Key_Pressed_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Key_Pressed_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Key_Pressed_Guard");
static_assert(sizeof(LActionState_ActionState_Key_Pressed_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Key_Pressed_Guard");
static_assert(offsetof(LActionState_ActionState_Key_Pressed_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Key_Pressed_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Key_Pressed_Sprint
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Key_Pressed_Sprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Key_Pressed_Sprint) == 0x000004, "Wrong alignment on LActionState_ActionState_Key_Pressed_Sprint");
static_assert(sizeof(LActionState_ActionState_Key_Pressed_Sprint) == 0x000008, "Wrong size on LActionState_ActionState_Key_Pressed_Sprint");
static_assert(offsetof(LActionState_ActionState_Key_Pressed_Sprint, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Key_Pressed_Sprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockCameraMovement
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockCameraMovement final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockCameraMovement) == 0x000004, "Wrong alignment on LActionState_ActionState_LockCameraMovement");
static_assert(sizeof(LActionState_ActionState_LockCameraMovement) == 0x000008, "Wrong size on LActionState_ActionState_LockCameraMovement");
static_assert(offsetof(LActionState_ActionState_LockCameraMovement, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockCameraMovement::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockCancelMove
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockCancelMove final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockCancelMove) == 0x000004, "Wrong alignment on LActionState_ActionState_LockCancelMove");
static_assert(sizeof(LActionState_ActionState_LockCancelMove) == 0x000008, "Wrong size on LActionState_ActionState_LockCancelMove");
static_assert(offsetof(LActionState_ActionState_LockCancelMove, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockCancelMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockDieAction
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockDieAction final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockDieAction) == 0x000004, "Wrong alignment on LActionState_ActionState_LockDieAction");
static_assert(sizeof(LActionState_ActionState_LockDieAction) == 0x000008, "Wrong size on LActionState_ActionState_LockDieAction");
static_assert(offsetof(LActionState_ActionState_LockDieAction, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockDieAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockFalling
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockFalling final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockFalling) == 0x000004, "Wrong alignment on LActionState_ActionState_LockFalling");
static_assert(sizeof(LActionState_ActionState_LockFalling) == 0x000008, "Wrong size on LActionState_ActionState_LockFalling");
static_assert(offsetof(LActionState_ActionState_LockFalling, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockFalling::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockInput_Movement_Forced
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockInput_Movement_Forced final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockInput_Movement_Forced) == 0x000004, "Wrong alignment on LActionState_ActionState_LockInput_Movement_Forced");
static_assert(sizeof(LActionState_ActionState_LockInput_Movement_Forced) == 0x000008, "Wrong size on LActionState_ActionState_LockInput_Movement_Forced");
static_assert(offsetof(LActionState_ActionState_LockInput_Movement_Forced, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockInput_Movement_Forced::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockInput_Rotation_Forced
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockInput_Rotation_Forced final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockInput_Rotation_Forced) == 0x000004, "Wrong alignment on LActionState_ActionState_LockInput_Rotation_Forced");
static_assert(sizeof(LActionState_ActionState_LockInput_Rotation_Forced) == 0x000008, "Wrong size on LActionState_ActionState_LockInput_Rotation_Forced");
static_assert(offsetof(LActionState_ActionState_LockInput_Rotation_Forced, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockInput_Rotation_Forced::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockMovement
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockMovement final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockMovement) == 0x000004, "Wrong alignment on LActionState_ActionState_LockMovement");
static_assert(sizeof(LActionState_ActionState_LockMovement) == 0x000008, "Wrong size on LActionState_ActionState_LockMovement");
static_assert(offsetof(LActionState_ActionState_LockMovement, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockMovement::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockOn_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockOn_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockOn_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_LockOn_Disable");
static_assert(sizeof(LActionState_ActionState_LockOn_Disable) == 0x000008, "Wrong size on LActionState_ActionState_LockOn_Disable");
static_assert(offsetof(LActionState_ActionState_LockOn_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockOn_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockOn_DisablePC
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockOn_DisablePC final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockOn_DisablePC) == 0x000004, "Wrong alignment on LActionState_ActionState_LockOn_DisablePC");
static_assert(sizeof(LActionState_ActionState_LockOn_DisablePC) == 0x000008, "Wrong size on LActionState_ActionState_LockOn_DisablePC");
static_assert(offsetof(LActionState_ActionState_LockOn_DisablePC, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockOn_DisablePC::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockOnRotateTarget
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockOnRotateTarget final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockOnRotateTarget) == 0x000004, "Wrong alignment on LActionState_ActionState_LockOnRotateTarget");
static_assert(sizeof(LActionState_ActionState_LockOnRotateTarget) == 0x000008, "Wrong size on LActionState_ActionState_LockOnRotateTarget");
static_assert(offsetof(LActionState_ActionState_LockOnRotateTarget, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockOnRotateTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockParry_Dash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockParry_Dash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockParry_Dash) == 0x000004, "Wrong alignment on LActionState_ActionState_LockParry_Dash");
static_assert(sizeof(LActionState_ActionState_LockParry_Dash) == 0x000008, "Wrong size on LActionState_ActionState_LockParry_Dash");
static_assert(offsetof(LActionState_ActionState_LockParry_Dash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockParry_Dash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockParry_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockParry_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockParry_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_LockParry_Guard");
static_assert(sizeof(LActionState_ActionState_LockParry_Guard) == 0x000008, "Wrong size on LActionState_ActionState_LockParry_Guard");
static_assert(offsetof(LActionState_ActionState_LockParry_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockParry_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockPerfectGuard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockPerfectGuard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockPerfectGuard) == 0x000004, "Wrong alignment on LActionState_ActionState_LockPerfectGuard");
static_assert(sizeof(LActionState_ActionState_LockPerfectGuard) == 0x000008, "Wrong size on LActionState_ActionState_LockPerfectGuard");
static_assert(offsetof(LActionState_ActionState_LockPerfectGuard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockPerfectGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockPlayerAction_Movie
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockPlayerAction_Movie final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockPlayerAction_Movie) == 0x000004, "Wrong alignment on LActionState_ActionState_LockPlayerAction_Movie");
static_assert(sizeof(LActionState_ActionState_LockPlayerAction_Movie) == 0x000008, "Wrong size on LActionState_ActionState_LockPlayerAction_Movie");
static_assert(offsetof(LActionState_ActionState_LockPlayerAction_Movie, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockPlayerAction_Movie::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockPlayerAction_Sequence
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockPlayerAction_Sequence final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockPlayerAction_Sequence) == 0x000004, "Wrong alignment on LActionState_ActionState_LockPlayerAction_Sequence");
static_assert(sizeof(LActionState_ActionState_LockPlayerAction_Sequence) == 0x000008, "Wrong size on LActionState_ActionState_LockPlayerAction_Sequence");
static_assert(offsetof(LActionState_ActionState_LockPlayerAction_Sequence, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockPlayerAction_Sequence::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockPlayerAction_Sequence_CameraEnable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable) == 0x000004, "Wrong alignment on LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable");
static_assert(sizeof(LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable) == 0x000008, "Wrong size on LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable");
static_assert(offsetof(LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockProcessCommand
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockProcessCommand final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockProcessCommand) == 0x000004, "Wrong alignment on LActionState_ActionState_LockProcessCommand");
static_assert(sizeof(LActionState_ActionState_LockProcessCommand) == 0x000008, "Wrong size on LActionState_ActionState_LockProcessCommand");
static_assert(offsetof(LActionState_ActionState_LockProcessCommand, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockProcessCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockRotation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockRotation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockRotation) == 0x000004, "Wrong alignment on LActionState_ActionState_LockRotation");
static_assert(sizeof(LActionState_ActionState_LockRotation) == 0x000008, "Wrong size on LActionState_ActionState_LockRotation");
static_assert(offsetof(LActionState_ActionState_LockRotation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockUseSkill
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockUseSkill final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockUseSkill) == 0x000004, "Wrong alignment on LActionState_ActionState_LockUseSkill");
static_assert(sizeof(LActionState_ActionState_LockUseSkill) == 0x000008, "Wrong size on LActionState_ActionState_LockUseSkill");
static_assert(offsetof(LActionState_ActionState_LockUseSkill, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockUseSkill::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockUseSkill_ExceptItem
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockUseSkill_ExceptItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockUseSkill_ExceptItem) == 0x000004, "Wrong alignment on LActionState_ActionState_LockUseSkill_ExceptItem");
static_assert(sizeof(LActionState_ActionState_LockUseSkill_ExceptItem) == 0x000008, "Wrong size on LActionState_ActionState_LockUseSkill_ExceptItem");
static_assert(offsetof(LActionState_ActionState_LockUseSkill_ExceptItem, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockUseSkill_ExceptItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LockUseSkill_ExceptItem_SkipTest
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest) == 0x000004, "Wrong alignment on LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest");
static_assert(sizeof(LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest) == 0x000008, "Wrong size on LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest");
static_assert(offsetof(LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_AimToTarget
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_AimToTarget final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_AimToTarget) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_AimToTarget");
static_assert(sizeof(LActionState_ActionState_LookAt_AimToTarget) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_AimToTarget");
static_assert(offsetof(LActionState_ActionState_LookAt_AimToTarget, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_AimToTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_Disable");
static_assert(sizeof(LActionState_ActionState_LookAt_Disable) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_Disable");
static_assert(offsetof(LActionState_ActionState_LookAt_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_FixAimToTarget
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_FixAimToTarget final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_FixAimToTarget) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_FixAimToTarget");
static_assert(sizeof(LActionState_ActionState_LookAt_FixAimToTarget) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_FixAimToTarget");
static_assert(offsetof(LActionState_ActionState_LookAt_FixAimToTarget, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_FixAimToTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_Head
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_Head final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_Head) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_Head");
static_assert(sizeof(LActionState_ActionState_LookAt_Head) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_Head");
static_assert(offsetof(LActionState_ActionState_LookAt_Head, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_Head::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_Head_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_Head_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_Head_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_Head_Disable");
static_assert(sizeof(LActionState_ActionState_LookAt_Head_Disable) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_Head_Disable");
static_assert(offsetof(LActionState_ActionState_LookAt_Head_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_Head_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_Smash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_Smash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_Smash) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_Smash");
static_assert(sizeof(LActionState_ActionState_LookAt_Smash) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_Smash");
static_assert(offsetof(LActionState_ActionState_LookAt_Smash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_Smash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_LookAt_UpperBody
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_LookAt_UpperBody final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_LookAt_UpperBody) == 0x000004, "Wrong alignment on LActionState_ActionState_LookAt_UpperBody");
static_assert(sizeof(LActionState_ActionState_LookAt_UpperBody) == 0x000008, "Wrong size on LActionState_ActionState_LookAt_UpperBody");
static_assert(offsetof(LActionState_ActionState_LookAt_UpperBody, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_LookAt_UpperBody::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_None
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_None) == 0x000004, "Wrong alignment on LActionState_ActionState_None");
static_assert(sizeof(LActionState_ActionState_None) == 0x000008, "Wrong size on LActionState_ActionState_None");
static_assert(offsetof(LActionState_ActionState_None, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_NotifyApplyInput_Dash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_NotifyApplyInput_Dash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_NotifyApplyInput_Dash) == 0x000004, "Wrong alignment on LActionState_ActionState_NotifyApplyInput_Dash");
static_assert(sizeof(LActionState_ActionState_NotifyApplyInput_Dash) == 0x000008, "Wrong size on LActionState_ActionState_NotifyApplyInput_Dash");
static_assert(offsetof(LActionState_ActionState_NotifyApplyInput_Dash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_NotifyApplyInput_Dash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_NotifyApplyInput_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_NotifyApplyInput_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_NotifyApplyInput_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_NotifyApplyInput_Guard");
static_assert(sizeof(LActionState_ActionState_NotifyApplyInput_Guard) == 0x000008, "Wrong size on LActionState_ActionState_NotifyApplyInput_Guard");
static_assert(offsetof(LActionState_ActionState_NotifyApplyInput_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_NotifyApplyInput_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_NotifyApplyInput_LightAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_NotifyApplyInput_LightAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_NotifyApplyInput_LightAttack) == 0x000004, "Wrong alignment on LActionState_ActionState_NotifyApplyInput_LightAttack");
static_assert(sizeof(LActionState_ActionState_NotifyApplyInput_LightAttack) == 0x000008, "Wrong size on LActionState_ActionState_NotifyApplyInput_LightAttack");
static_assert(offsetof(LActionState_ActionState_NotifyApplyInput_LightAttack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_NotifyApplyInput_LightAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_NotifyApplyInput_StrongAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_NotifyApplyInput_StrongAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_NotifyApplyInput_StrongAttack) == 0x000004, "Wrong alignment on LActionState_ActionState_NotifyApplyInput_StrongAttack");
static_assert(sizeof(LActionState_ActionState_NotifyApplyInput_StrongAttack) == 0x000008, "Wrong size on LActionState_ActionState_NotifyApplyInput_StrongAttack");
static_assert(offsetof(LActionState_ActionState_NotifyApplyInput_StrongAttack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_NotifyApplyInput_StrongAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_OnGuardHit_Attacker
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_OnGuardHit_Attacker final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_OnGuardHit_Attacker) == 0x000004, "Wrong alignment on LActionState_ActionState_OnGuardHit_Attacker");
static_assert(sizeof(LActionState_ActionState_OnGuardHit_Attacker) == 0x000008, "Wrong size on LActionState_ActionState_OnGuardHit_Attacker");
static_assert(offsetof(LActionState_ActionState_OnGuardHit_Attacker, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_OnGuardHit_Attacker::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_OnGuardHit_Victim
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_OnGuardHit_Victim final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_OnGuardHit_Victim) == 0x000004, "Wrong alignment on LActionState_ActionState_OnGuardHit_Victim");
static_assert(sizeof(LActionState_ActionState_OnGuardHit_Victim) == 0x000008, "Wrong size on LActionState_ActionState_OnGuardHit_Victim");
static_assert(offsetof(LActionState_ActionState_OnGuardHit_Victim, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_OnGuardHit_Victim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_OutOfBossRoom
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_OutOfBossRoom final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_OutOfBossRoom) == 0x000004, "Wrong alignment on LActionState_ActionState_OutOfBossRoom");
static_assert(sizeof(LActionState_ActionState_OutOfBossRoom) == 0x000008, "Wrong size on LActionState_ActionState_OutOfBossRoom");
static_assert(offsetof(LActionState_ActionState_OutOfBossRoom, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_OutOfBossRoom::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Paralyzation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Paralyzation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Paralyzation) == 0x000004, "Wrong alignment on LActionState_ActionState_Paralyzation");
static_assert(sizeof(LActionState_ActionState_Paralyzation) == 0x000008, "Wrong size on LActionState_ActionState_Paralyzation");
static_assert(offsetof(LActionState_ActionState_Paralyzation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Paralyzation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Paralyzation_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Paralyzation_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Paralyzation_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_Paralyzation_Enable");
static_assert(sizeof(LActionState_ActionState_Paralyzation_Enable) == 0x000008, "Wrong size on LActionState_ActionState_Paralyzation_Enable");
static_assert(offsetof(LActionState_ActionState_Paralyzation_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Paralyzation_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Peace
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Peace final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Peace) == 0x000004, "Wrong alignment on LActionState_ActionState_Peace");
static_assert(sizeof(LActionState_ActionState_Peace) == 0x000008, "Wrong size on LActionState_ActionState_Peace");
static_assert(offsetof(LActionState_ActionState_Peace, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Peace::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_PerBodyCollisionProfileApplied
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_PerBodyCollisionProfileApplied final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_PerBodyCollisionProfileApplied) == 0x000004, "Wrong alignment on LActionState_ActionState_PerBodyCollisionProfileApplied");
static_assert(sizeof(LActionState_ActionState_PerBodyCollisionProfileApplied) == 0x000008, "Wrong size on LActionState_ActionState_PerBodyCollisionProfileApplied");
static_assert(offsetof(LActionState_ActionState_PerBodyCollisionProfileApplied, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_PerBodyCollisionProfileApplied::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Perception_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Perception_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Perception_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_Perception_Disable");
static_assert(sizeof(LActionState_ActionState_Perception_Disable) == 0x000008, "Wrong size on LActionState_ActionState_Perception_Disable");
static_assert(offsetof(LActionState_ActionState_Perception_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Perception_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Perfect_Guard_Tough_Damage_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable");
static_assert(sizeof(LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable) == 0x000008, "Wrong size on LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable");
static_assert(offsetof(LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_PhysicsSimulation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_PhysicsSimulation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_PhysicsSimulation) == 0x000004, "Wrong alignment on LActionState_ActionState_PhysicsSimulation");
static_assert(sizeof(LActionState_ActionState_PhysicsSimulation) == 0x000008, "Wrong size on LActionState_ActionState_PhysicsSimulation");
static_assert(offsetof(LActionState_ActionState_PhysicsSimulation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_PhysicsSimulation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Prepare_Spawn
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Prepare_Spawn final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Prepare_Spawn) == 0x000004, "Wrong alignment on LActionState_ActionState_Prepare_Spawn");
static_assert(sizeof(LActionState_ActionState_Prepare_Spawn) == 0x000008, "Wrong size on LActionState_ActionState_Prepare_Spawn");
static_assert(offsetof(LActionState_ActionState_Prepare_Spawn, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Prepare_Spawn::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_PreventFallingDamage
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_PreventFallingDamage final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_PreventFallingDamage) == 0x000004, "Wrong alignment on LActionState_ActionState_PreventFallingDamage");
static_assert(sizeof(LActionState_ActionState_PreventFallingDamage) == 0x000008, "Wrong size on LActionState_ActionState_PreventFallingDamage");
static_assert(offsetof(LActionState_ActionState_PreventFallingDamage, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_PreventFallingDamage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Pulse_Rechargeable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Pulse_Rechargeable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Pulse_Rechargeable) == 0x000004, "Wrong alignment on LActionState_ActionState_Pulse_Rechargeable");
static_assert(sizeof(LActionState_ActionState_Pulse_Rechargeable) == 0x000008, "Wrong size on LActionState_ActionState_Pulse_Rechargeable");
static_assert(offsetof(LActionState_ActionState_Pulse_Rechargeable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Pulse_Rechargeable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_PushingReposition_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_PushingReposition_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_PushingReposition_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_PushingReposition_Disable");
static_assert(sizeof(LActionState_ActionState_PushingReposition_Disable) == 0x000008, "Wrong size on LActionState_ActionState_PushingReposition_Disable");
static_assert(offsetof(LActionState_ActionState_PushingReposition_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_PushingReposition_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_RepairWeapon
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_RepairWeapon final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_RepairWeapon) == 0x000004, "Wrong alignment on LActionState_ActionState_RepairWeapon");
static_assert(sizeof(LActionState_ActionState_RepairWeapon) == 0x000008, "Wrong size on LActionState_ActionState_RepairWeapon");
static_assert(offsetof(LActionState_ActionState_RepairWeapon, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_RepairWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ReserveInput
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ReserveInput final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ReserveInput) == 0x000004, "Wrong alignment on LActionState_ActionState_ReserveInput");
static_assert(sizeof(LActionState_ActionState_ReserveInput) == 0x000008, "Wrong size on LActionState_ActionState_ReserveInput");
static_assert(offsetof(LActionState_ActionState_ReserveInput, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ReserveInput::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ReserveInput_Attack
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ReserveInput_Attack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ReserveInput_Attack) == 0x000004, "Wrong alignment on LActionState_ActionState_ReserveInput_Attack");
static_assert(sizeof(LActionState_ActionState_ReserveInput_Attack) == 0x000008, "Wrong size on LActionState_ActionState_ReserveInput_Attack");
static_assert(offsetof(LActionState_ActionState_ReserveInput_Attack, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ReserveInput_Attack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ReserveInput_Dash
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ReserveInput_Dash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ReserveInput_Dash) == 0x000004, "Wrong alignment on LActionState_ActionState_ReserveInput_Dash");
static_assert(sizeof(LActionState_ActionState_ReserveInput_Dash) == 0x000008, "Wrong size on LActionState_ActionState_ReserveInput_Dash");
static_assert(offsetof(LActionState_ActionState_ReserveInput_Dash, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ReserveInput_Dash::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ReserveInput_Special
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ReserveInput_Special final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ReserveInput_Special) == 0x000004, "Wrong alignment on LActionState_ActionState_ReserveInput_Special");
static_assert(sizeof(LActionState_ActionState_ReserveInput_Special) == 0x000008, "Wrong size on LActionState_ActionState_ReserveInput_Special");
static_assert(offsetof(LActionState_ActionState_ReserveInput_Special, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ReserveInput_Special::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Resurrection
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Resurrection final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Resurrection) == 0x000004, "Wrong alignment on LActionState_ActionState_Resurrection");
static_assert(sizeof(LActionState_ActionState_Resurrection) == 0x000008, "Wrong size on LActionState_ActionState_Resurrection");
static_assert(offsetof(LActionState_ActionState_Resurrection, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Resurrection::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Resurrection_Used
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Resurrection_Used final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Resurrection_Used) == 0x000004, "Wrong alignment on LActionState_ActionState_Resurrection_Used");
static_assert(sizeof(LActionState_ActionState_Resurrection_Used) == 0x000008, "Wrong size on LActionState_ActionState_Resurrection_Used");
static_assert(offsetof(LActionState_ActionState_Resurrection_Used, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Resurrection_Used::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_RideOnLift
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_RideOnLift final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_RideOnLift) == 0x000004, "Wrong alignment on LActionState_ActionState_RideOnLift");
static_assert(sizeof(LActionState_ActionState_RideOnLift) == 0x000008, "Wrong size on LActionState_ActionState_RideOnLift");
static_assert(offsetof(LActionState_ActionState_RideOnLift, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_RideOnLift::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_RisingAttack_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_RisingAttack_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_RisingAttack_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_RisingAttack_Enable");
static_assert(sizeof(LActionState_ActionState_RisingAttack_Enable) == 0x000008, "Wrong size on LActionState_ActionState_RisingAttack_Enable");
static_assert(offsetof(LActionState_ActionState_RisingAttack_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_RisingAttack_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Rootmotion_Velocity_Cap
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Rootmotion_Velocity_Cap final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Rootmotion_Velocity_Cap) == 0x000004, "Wrong alignment on LActionState_ActionState_Rootmotion_Velocity_Cap");
static_assert(sizeof(LActionState_ActionState_Rootmotion_Velocity_Cap) == 0x000008, "Wrong size on LActionState_ActionState_Rootmotion_Velocity_Cap");
static_assert(offsetof(LActionState_ActionState_Rootmotion_Velocity_Cap, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Rootmotion_Velocity_Cap::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_SA_NicolaTail_Active
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_SA_NicolaTail_Active final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_SA_NicolaTail_Active) == 0x000004, "Wrong alignment on LActionState_ActionState_SA_NicolaTail_Active");
static_assert(sizeof(LActionState_ActionState_SA_NicolaTail_Active) == 0x000008, "Wrong size on LActionState_ActionState_SA_NicolaTail_Active");
static_assert(offsetof(LActionState_ActionState_SA_NicolaTail_Active, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_SA_NicolaTail_Active::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_SA_NicolaTail_Counter
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_SA_NicolaTail_Counter final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_SA_NicolaTail_Counter) == 0x000004, "Wrong alignment on LActionState_ActionState_SA_NicolaTail_Counter");
static_assert(sizeof(LActionState_ActionState_SA_NicolaTail_Counter) == 0x000008, "Wrong size on LActionState_ActionState_SA_NicolaTail_Counter");
static_assert(offsetof(LActionState_ActionState_SA_NicolaTail_Counter, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_SA_NicolaTail_Counter::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_SA_PileBunker_Lock
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_SA_PileBunker_Lock final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_SA_PileBunker_Lock) == 0x000004, "Wrong alignment on LActionState_ActionState_SA_PileBunker_Lock");
static_assert(sizeof(LActionState_ActionState_SA_PileBunker_Lock) == 0x000008, "Wrong size on LActionState_ActionState_SA_PileBunker_Lock");
static_assert(offsetof(LActionState_ActionState_SA_PileBunker_Lock, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_SA_PileBunker_Lock::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Shotgun_Hold
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Shotgun_Hold final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Shotgun_Hold) == 0x000004, "Wrong alignment on LActionState_ActionState_Shotgun_Hold");
static_assert(sizeof(LActionState_ActionState_Shotgun_Hold) == 0x000008, "Wrong size on LActionState_ActionState_Shotgun_Hold");
static_assert(offsetof(LActionState_ActionState_Shotgun_Hold, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Shotgun_Hold::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Show_Weapon_Forced
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Show_Weapon_Forced final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Show_Weapon_Forced) == 0x000004, "Wrong alignment on LActionState_ActionState_Show_Weapon_Forced");
static_assert(sizeof(LActionState_ActionState_Show_Weapon_Forced) == 0x000008, "Wrong size on LActionState_ActionState_Show_Weapon_Forced");
static_assert(offsetof(LActionState_ActionState_Show_Weapon_Forced, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Show_Weapon_Forced::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_SlaveArm_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_SlaveArm_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_SlaveArm_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_SlaveArm_Disable");
static_assert(sizeof(LActionState_ActionState_SlaveArm_Disable) == 0x000008, "Wrong size on LActionState_ActionState_SlaveArm_Disable");
static_assert(offsetof(LActionState_ActionState_SlaveArm_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_SlaveArm_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Sleep
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Sleep final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Sleep) == 0x000004, "Wrong alignment on LActionState_ActionState_Sleep");
static_assert(sizeof(LActionState_ActionState_Sleep) == 0x000008, "Wrong size on LActionState_ActionState_Sleep");
static_assert(offsetof(LActionState_ActionState_Sleep, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Sleep::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_SpawnIdle
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_SpawnIdle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_SpawnIdle) == 0x000004, "Wrong alignment on LActionState_ActionState_SpawnIdle");
static_assert(sizeof(LActionState_ActionState_SpawnIdle) == 0x000008, "Wrong size on LActionState_ActionState_SpawnIdle");
static_assert(offsetof(LActionState_ActionState_SpawnIdle, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_SpawnIdle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Sprint_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Sprint_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Sprint_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_Sprint_Disable");
static_assert(sizeof(LActionState_ActionState_Sprint_Disable) == 0x000008, "Wrong size on LActionState_ActionState_Sprint_Disable");
static_assert(offsetof(LActionState_ActionState_Sprint_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Sprint_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Sprint_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Sprint_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Sprint_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_Sprint_Enable");
static_assert(sizeof(LActionState_ActionState_Sprint_Enable) == 0x000008, "Wrong size on LActionState_ActionState_Sprint_Enable");
static_assert(offsetof(LActionState_ActionState_Sprint_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Sprint_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Always_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Always_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Always_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Always_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_Always_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Always_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_Always_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Always_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Always_Guard_Off
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Always_Guard_Off final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Always_Guard_Off) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Always_Guard_Off");
static_assert(sizeof(LActionState_ActionState_Stance_Always_Guard_Off) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Always_Guard_Off");
static_assert(offsetof(LActionState_ActionState_Stance_Always_Guard_Off, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Always_Guard_Off::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Arm_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Arm_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Arm_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Arm_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_Arm_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Arm_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_Arm_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Arm_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Arm_NoStiffen_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Arm_NoStiffen_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Arm_NoStiffen_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Arm_NoStiffen_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_Arm_NoStiffen_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Arm_NoStiffen_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_Arm_NoStiffen_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Arm_NoStiffen_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_NoStiffen_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_NoStiffen_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_NoStiffen_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_NoStiffen_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_NoStiffen_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_NoStiffen_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_NoStiffen_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_NoStiffen_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Parrying
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Parrying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Parrying) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Parrying");
static_assert(sizeof(LActionState_ActionState_Stance_Parrying) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Parrying");
static_assert(offsetof(LActionState_ActionState_Stance_Parrying, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Parrying::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Perfect_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Perfect_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Perfect_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Perfect_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_Perfect_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Perfect_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_Perfect_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Perfect_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Reflect_Guard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Reflect_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Reflect_Guard) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Reflect_Guard");
static_assert(sizeof(LActionState_ActionState_Stance_Reflect_Guard) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Reflect_Guard");
static_assert(offsetof(LActionState_ActionState_Stance_Reflect_Guard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Reflect_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Stance_BareHand
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Stance_BareHand final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Stance_BareHand) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Stance_BareHand");
static_assert(sizeof(LActionState_ActionState_Stance_Stance_BareHand) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Stance_BareHand");
static_assert(offsetof(LActionState_ActionState_Stance_Stance_BareHand, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Stance_BareHand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Sword_OneHand
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Sword_OneHand final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Sword_OneHand) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Sword_OneHand");
static_assert(sizeof(LActionState_ActionState_Stance_Sword_OneHand) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Sword_OneHand");
static_assert(offsetof(LActionState_ActionState_Stance_Sword_OneHand, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Sword_OneHand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Sword_TwoHand
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Sword_TwoHand final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Sword_TwoHand) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Sword_TwoHand");
static_assert(sizeof(LActionState_ActionState_Stance_Sword_TwoHand) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Sword_TwoHand");
static_assert(offsetof(LActionState_ActionState_Stance_Sword_TwoHand, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Sword_TwoHand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Axe
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Axe final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Axe) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Axe");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Axe) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Axe");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Axe, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Axe::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Axe2
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Axe2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Axe2) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Axe2");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Axe2) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Axe2");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Axe2, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Axe2::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Blade
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Blade final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Blade) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Blade");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Blade) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Blade");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Blade, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Blade::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Blade2
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Blade2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Blade2) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Blade2");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Blade2) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Blade2");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Blade2, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Blade2::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Spear
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Spear final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Spear) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Spear");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Spear) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Spear");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Spear, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Spear::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Spear2
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Spear2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Spear2) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Spear2");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Spear2) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Spear2");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Spear2, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Spear2::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Sword
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Sword final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Sword) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Sword");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Sword) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Sword");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Sword, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Sword::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Stance_Weapon_Sword2
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Stance_Weapon_Sword2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Stance_Weapon_Sword2) == 0x000004, "Wrong alignment on LActionState_ActionState_Stance_Weapon_Sword2");
static_assert(sizeof(LActionState_ActionState_Stance_Weapon_Sword2) == 0x000008, "Wrong size on LActionState_ActionState_Stance_Weapon_Sword2");
static_assert(offsetof(LActionState_ActionState_Stance_Weapon_Sword2, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Stance_Weapon_Sword2::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_StandGuard
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_StandGuard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_StandGuard) == 0x000004, "Wrong alignment on LActionState_ActionState_StandGuard");
static_assert(sizeof(LActionState_ActionState_StandGuard) == 0x000008, "Wrong size on LActionState_ActionState_StandGuard");
static_assert(offsetof(LActionState_ActionState_StandGuard, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_StandGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_StandGuardEnable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_StandGuardEnable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_StandGuardEnable) == 0x000004, "Wrong alignment on LActionState_ActionState_StandGuardEnable");
static_assert(sizeof(LActionState_ActionState_StandGuardEnable) == 0x000008, "Wrong size on LActionState_ActionState_StandGuardEnable");
static_assert(offsetof(LActionState_ActionState_StandGuardEnable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_StandGuardEnable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Start_Rotation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Start_Rotation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Start_Rotation) == 0x000004, "Wrong alignment on LActionState_ActionState_Start_Rotation");
static_assert(sizeof(LActionState_ActionState_Start_Rotation) == 0x000008, "Wrong size on LActionState_ActionState_Start_Rotation");
static_assert(offsetof(LActionState_ActionState_Start_Rotation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Start_Rotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_StopSprint
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_StopSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_StopSprint) == 0x000004, "Wrong alignment on LActionState_ActionState_StopSprint");
static_assert(sizeof(LActionState_ActionState_StopSprint) == 0x000008, "Wrong size on LActionState_ActionState_StopSprint");
static_assert(offsetof(LActionState_ActionState_StopSprint, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_StopSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_SuperArmor
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_SuperArmor final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_SuperArmor) == 0x000004, "Wrong alignment on LActionState_ActionState_SuperArmor");
static_assert(sizeof(LActionState_ActionState_SuperArmor) == 0x000008, "Wrong size on LActionState_ActionState_SuperArmor");
static_assert(offsetof(LActionState_ActionState_SuperArmor, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_SuperArmor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_ToggleWalkMode
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_ToggleWalkMode final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_ToggleWalkMode) == 0x000004, "Wrong alignment on LActionState_ActionState_ToggleWalkMode");
static_assert(sizeof(LActionState_ActionState_ToggleWalkMode) == 0x000008, "Wrong size on LActionState_ActionState_ToggleWalkMode");
static_assert(offsetof(LActionState_ActionState_ToggleWalkMode, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_ToggleWalkMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_TransitAnimation_Dead
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_TransitAnimation_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_TransitAnimation_Dead) == 0x000004, "Wrong alignment on LActionState_ActionState_TransitAnimation_Dead");
static_assert(sizeof(LActionState_ActionState_TransitAnimation_Dead) == 0x000008, "Wrong size on LActionState_ActionState_TransitAnimation_Dead");
static_assert(offsetof(LActionState_ActionState_TransitAnimation_Dead, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_TransitAnimation_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_TryLockInput_Movement
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_TryLockInput_Movement final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_TryLockInput_Movement) == 0x000004, "Wrong alignment on LActionState_ActionState_TryLockInput_Movement");
static_assert(sizeof(LActionState_ActionState_TryLockInput_Movement) == 0x000008, "Wrong size on LActionState_ActionState_TryLockInput_Movement");
static_assert(offsetof(LActionState_ActionState_TryLockInput_Movement, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_TryLockInput_Movement::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_TryLockInput_Rotation
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_TryLockInput_Rotation final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_TryLockInput_Rotation) == 0x000004, "Wrong alignment on LActionState_ActionState_TryLockInput_Rotation");
static_assert(sizeof(LActionState_ActionState_TryLockInput_Rotation) == 0x000008, "Wrong size on LActionState_ActionState_TryLockInput_Rotation");
static_assert(offsetof(LActionState_ActionState_TryLockInput_Rotation, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_TryLockInput_Rotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Tutorial_Walk
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Tutorial_Walk final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Tutorial_Walk) == 0x000004, "Wrong alignment on LActionState_ActionState_Tutorial_Walk");
static_assert(sizeof(LActionState_ActionState_Tutorial_Walk) == 0x000008, "Wrong size on LActionState_ActionState_Tutorial_Walk");
static_assert(offsetof(LActionState_ActionState_Tutorial_Walk, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Tutorial_Walk::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Use_FSM_For_LowerBody
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Use_FSM_For_LowerBody final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Use_FSM_For_LowerBody) == 0x000004, "Wrong alignment on LActionState_ActionState_Use_FSM_For_LowerBody");
static_assert(sizeof(LActionState_ActionState_Use_FSM_For_LowerBody) == 0x000008, "Wrong size on LActionState_ActionState_Use_FSM_For_LowerBody");
static_assert(offsetof(LActionState_ActionState_Use_FSM_For_LowerBody, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Use_FSM_For_LowerBody::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_UseItem_Disable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_UseItem_Disable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_UseItem_Disable) == 0x000004, "Wrong alignment on LActionState_ActionState_UseItem_Disable");
static_assert(sizeof(LActionState_ActionState_UseItem_Disable) == 0x000008, "Wrong size on LActionState_ActionState_UseItem_Disable");
static_assert(offsetof(LActionState_ActionState_UseItem_Disable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_UseItem_Disable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Victim_Counter_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Victim_Counter_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Victim_Counter_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_Victim_Counter_Enable");
static_assert(sizeof(LActionState_ActionState_Victim_Counter_Enable) == 0x000008, "Wrong size on LActionState_ActionState_Victim_Counter_Enable");
static_assert(offsetof(LActionState_ActionState_Victim_Counter_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Victim_Counter_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Weapon_Transform
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Weapon_Transform final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Weapon_Transform) == 0x000004, "Wrong alignment on LActionState_ActionState_Weapon_Transform");
static_assert(sizeof(LActionState_ActionState_Weapon_Transform) == 0x000008, "Wrong size on LActionState_ActionState_Weapon_Transform");
static_assert(offsetof(LActionState_ActionState_Weapon_Transform, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Weapon_Transform::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_EX1
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_WeaponHideByNotify_EX1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_WeaponHideByNotify_EX1) == 0x000004, "Wrong alignment on LActionState_ActionState_WeaponHideByNotify_EX1");
static_assert(sizeof(LActionState_ActionState_WeaponHideByNotify_EX1) == 0x000008, "Wrong size on LActionState_ActionState_WeaponHideByNotify_EX1");
static_assert(offsetof(LActionState_ActionState_WeaponHideByNotify_EX1, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_WeaponHideByNotify_EX1::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_EX2
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_WeaponHideByNotify_EX2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_WeaponHideByNotify_EX2) == 0x000004, "Wrong alignment on LActionState_ActionState_WeaponHideByNotify_EX2");
static_assert(sizeof(LActionState_ActionState_WeaponHideByNotify_EX2) == 0x000008, "Wrong size on LActionState_ActionState_WeaponHideByNotify_EX2");
static_assert(offsetof(LActionState_ActionState_WeaponHideByNotify_EX2, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_WeaponHideByNotify_EX2::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_EX3
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_WeaponHideByNotify_EX3 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_WeaponHideByNotify_EX3) == 0x000004, "Wrong alignment on LActionState_ActionState_WeaponHideByNotify_EX3");
static_assert(sizeof(LActionState_ActionState_WeaponHideByNotify_EX3) == 0x000008, "Wrong size on LActionState_ActionState_WeaponHideByNotify_EX3");
static_assert(offsetof(LActionState_ActionState_WeaponHideByNotify_EX3, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_WeaponHideByNotify_EX3::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_L
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_WeaponHideByNotify_L final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_WeaponHideByNotify_L) == 0x000004, "Wrong alignment on LActionState_ActionState_WeaponHideByNotify_L");
static_assert(sizeof(LActionState_ActionState_WeaponHideByNotify_L) == 0x000008, "Wrong size on LActionState_ActionState_WeaponHideByNotify_L");
static_assert(offsetof(LActionState_ActionState_WeaponHideByNotify_L, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_WeaponHideByNotify_L::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_R
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_WeaponHideByNotify_R final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_WeaponHideByNotify_R) == 0x000004, "Wrong alignment on LActionState_ActionState_WeaponHideByNotify_R");
static_assert(sizeof(LActionState_ActionState_WeaponHideByNotify_R) == 0x000008, "Wrong size on LActionState_ActionState_WeaponHideByNotify_R");
static_assert(offsetof(LActionState_ActionState_WeaponHideByNotify_R, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_WeaponHideByNotify_R::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Weight_Advantage_Enable
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Weight_Advantage_Enable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Weight_Advantage_Enable) == 0x000004, "Wrong alignment on LActionState_ActionState_Weight_Advantage_Enable");
static_assert(sizeof(LActionState_ActionState_Weight_Advantage_Enable) == 0x000008, "Wrong size on LActionState_ActionState_Weight_Advantage_Enable");
static_assert(offsetof(LActionState_ActionState_Weight_Advantage_Enable, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Weight_Advantage_Enable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_WeightPenalty_Decrease_L1_Change
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_WeightPenalty_Decrease_L1_Change final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_WeightPenalty_Decrease_L1_Change) == 0x000004, "Wrong alignment on LActionState_ActionState_WeightPenalty_Decrease_L1_Change");
static_assert(sizeof(LActionState_ActionState_WeightPenalty_Decrease_L1_Change) == 0x000008, "Wrong size on LActionState_ActionState_WeightPenalty_Decrease_L1_Change");
static_assert(offsetof(LActionState_ActionState_WeightPenalty_Decrease_L1_Change, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_WeightPenalty_Decrease_L1_Change::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionState.ActionState_Zombie
// 0x0008 (0x0008 - 0x0000)
struct LActionState_ActionState_Zombie final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionState_ActionState_Zombie) == 0x000004, "Wrong alignment on LActionState_ActionState_Zombie");
static_assert(sizeof(LActionState_ActionState_Zombie) == 0x000008, "Wrong size on LActionState_ActionState_Zombie");
static_assert(offsetof(LActionState_ActionState_Zombie, ReturnValue) == 0x000000, "Member 'LActionState_ActionState_Zombie::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystemData.FindHandBloodMaterial_ForCurrentBody
// 0x0010 (0x0010 - 0x0000)
struct LActionSystemData_FindHandBloodMaterial_ForCurrentBody final
{
public:
	class UMaterialInstance*                      OutMaterial;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystemData_FindHandBloodMaterial_ForCurrentBody) == 0x000008, "Wrong alignment on LActionSystemData_FindHandBloodMaterial_ForCurrentBody");
static_assert(sizeof(LActionSystemData_FindHandBloodMaterial_ForCurrentBody) == 0x000010, "Wrong size on LActionSystemData_FindHandBloodMaterial_ForCurrentBody");
static_assert(offsetof(LActionSystemData_FindHandBloodMaterial_ForCurrentBody, OutMaterial) == 0x000000, "Member 'LActionSystemData_FindHandBloodMaterial_ForCurrentBody::OutMaterial' has a wrong offset!");
static_assert(offsetof(LActionSystemData_FindHandBloodMaterial_ForCurrentBody, ReturnValue) == 0x000008, "Member 'LActionSystemData_FindHandBloodMaterial_ForCurrentBody::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystemData.FindPixelDepthOffsetData_ForCurrentFace
// 0x0010 (0x0010 - 0x0000)
struct LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace final
{
public:
	class UTexture*                               OutMask;                                           // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutIntensity;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace) == 0x000008, "Wrong alignment on LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace");
static_assert(sizeof(LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace) == 0x000010, "Wrong size on LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace");
static_assert(offsetof(LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace, OutMask) == 0x000000, "Member 'LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace::OutMask' has a wrong offset!");
static_assert(offsetof(LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace, OutIntensity) == 0x000008, "Member 'LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace::OutIntensity' has a wrong offset!");
static_assert(offsetof(LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace, ReturnValue) == 0x00000C, "Member 'LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystemData.FindShrinkMesh_ForCurrentBody
// 0x0018 (0x0018 - 0x0000)
struct LActionSystemData_FindShrinkMesh_ForCurrentBody final
{
public:
	class ALCharacter*                            TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          OutMesh;                                           // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystemData_FindShrinkMesh_ForCurrentBody) == 0x000008, "Wrong alignment on LActionSystemData_FindShrinkMesh_ForCurrentBody");
static_assert(sizeof(LActionSystemData_FindShrinkMesh_ForCurrentBody) == 0x000018, "Wrong size on LActionSystemData_FindShrinkMesh_ForCurrentBody");
static_assert(offsetof(LActionSystemData_FindShrinkMesh_ForCurrentBody, TargetCharacter) == 0x000000, "Member 'LActionSystemData_FindShrinkMesh_ForCurrentBody::TargetCharacter' has a wrong offset!");
static_assert(offsetof(LActionSystemData_FindShrinkMesh_ForCurrentBody, OutMesh) == 0x000008, "Member 'LActionSystemData_FindShrinkMesh_ForCurrentBody::OutMesh' has a wrong offset!");
static_assert(offsetof(LActionSystemData_FindShrinkMesh_ForCurrentBody, ReturnValue) == 0x000010, "Member 'LActionSystemData_FindShrinkMesh_ForCurrentBody::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystemData.OnApplyNeedShrink
// 0x0010 (0x0010 - 0x0000)
struct LActionSystemData_OnApplyNeedShrink final
{
public:
	class ALCharacter*                            TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystemData_OnApplyNeedShrink) == 0x000008, "Wrong alignment on LActionSystemData_OnApplyNeedShrink");
static_assert(sizeof(LActionSystemData_OnApplyNeedShrink) == 0x000010, "Wrong size on LActionSystemData_OnApplyNeedShrink");
static_assert(offsetof(LActionSystemData_OnApplyNeedShrink, TargetCharacter) == 0x000000, "Member 'LActionSystemData_OnApplyNeedShrink::TargetCharacter' has a wrong offset!");
static_assert(offsetof(LActionSystemData_OnApplyNeedShrink, ReturnValue) == 0x000008, "Member 'LActionSystemData_OnApplyNeedShrink::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystemData.RemoveFatalLocationIndicator
// 0x0060 (0x0060 - 0x0000)
struct LActionSystemData_RemoveFatalLocationIndicator final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo;                                   // 0x0008(0x0054)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SuccessFatalAttackInfoIndex;                       // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystemData_RemoveFatalLocationIndicator) == 0x000008, "Wrong alignment on LActionSystemData_RemoveFatalLocationIndicator");
static_assert(sizeof(LActionSystemData_RemoveFatalLocationIndicator) == 0x000060, "Wrong size on LActionSystemData_RemoveFatalLocationIndicator");
static_assert(offsetof(LActionSystemData_RemoveFatalLocationIndicator, TargetActor) == 0x000000, "Member 'LActionSystemData_RemoveFatalLocationIndicator::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionSystemData_RemoveFatalLocationIndicator, FatalAttackInfo) == 0x000008, "Member 'LActionSystemData_RemoveFatalLocationIndicator::FatalAttackInfo' has a wrong offset!");
static_assert(offsetof(LActionSystemData_RemoveFatalLocationIndicator, SuccessFatalAttackInfoIndex) == 0x00005C, "Member 'LActionSystemData_RemoveFatalLocationIndicator::SuccessFatalAttackInfoIndex' has a wrong offset!");

// Function ProjectP.LActionSystemData.SetFatalLocationIndicatorState
// 0x00A0 (0x00A0 - 0x0000)
struct LActionSystemData_SetFatalLocationIndicatorState final
{
public:
	struct FLFatalIndicatorFxState                IndicatorFx;                                       // 0x0000(0x00A0)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystemData_SetFatalLocationIndicatorState) == 0x000010, "Wrong alignment on LActionSystemData_SetFatalLocationIndicatorState");
static_assert(sizeof(LActionSystemData_SetFatalLocationIndicatorState) == 0x0000A0, "Wrong size on LActionSystemData_SetFatalLocationIndicatorState");
static_assert(offsetof(LActionSystemData_SetFatalLocationIndicatorState, IndicatorFx) == 0x000000, "Member 'LActionSystemData_SetFatalLocationIndicatorState::IndicatorFx' has a wrong offset!");

// Function ProjectP.LActionSystemData.SpawnFatalLocationIndicator
// 0x0060 (0x0060 - 0x0000)
struct LActionSystemData_SpawnFatalLocationIndicator final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo;                                   // 0x0008(0x0054)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystemData_SpawnFatalLocationIndicator) == 0x000008, "Wrong alignment on LActionSystemData_SpawnFatalLocationIndicator");
static_assert(sizeof(LActionSystemData_SpawnFatalLocationIndicator) == 0x000060, "Wrong size on LActionSystemData_SpawnFatalLocationIndicator");
static_assert(offsetof(LActionSystemData_SpawnFatalLocationIndicator, TargetActor) == 0x000000, "Member 'LActionSystemData_SpawnFatalLocationIndicator::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionSystemData_SpawnFatalLocationIndicator, FatalAttackInfo) == 0x000008, "Member 'LActionSystemData_SpawnFatalLocationIndicator::FatalAttackInfo' has a wrong offset!");

// Function ProjectP.LActionSystem.AddFatalIndicator
// 0x0010 (0x0010 - 0x0000)
struct LActionSystem_AddFatalIndicator final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystem_AddFatalIndicator) == 0x000008, "Wrong alignment on LActionSystem_AddFatalIndicator");
static_assert(sizeof(LActionSystem_AddFatalIndicator) == 0x000010, "Wrong size on LActionSystem_AddFatalIndicator");
static_assert(offsetof(LActionSystem_AddFatalIndicator, TargetActor) == 0x000000, "Member 'LActionSystem_AddFatalIndicator::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionSystem_AddFatalIndicator, ReturnValue) == 0x000008, "Member 'LActionSystem_AddFatalIndicator::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.OnApplyNeedShrink
// 0x0010 (0x0010 - 0x0000)
struct LActionSystem_OnApplyNeedShrink final
{
public:
	class ALCharacter*                            TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystem_OnApplyNeedShrink) == 0x000008, "Wrong alignment on LActionSystem_OnApplyNeedShrink");
static_assert(sizeof(LActionSystem_OnApplyNeedShrink) == 0x000010, "Wrong size on LActionSystem_OnApplyNeedShrink");
static_assert(offsetof(LActionSystem_OnApplyNeedShrink, TargetCharacter) == 0x000000, "Member 'LActionSystem_OnApplyNeedShrink::TargetCharacter' has a wrong offset!");
static_assert(offsetof(LActionSystem_OnApplyNeedShrink, ReturnValue) == 0x000008, "Member 'LActionSystem_OnApplyNeedShrink::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.RemoveFatalIndicator
// 0x0010 (0x0010 - 0x0000)
struct LActionSystem_RemoveFatalIndicator final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuccessFatalAttackInfoIndex;                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystem_RemoveFatalIndicator) == 0x000008, "Wrong alignment on LActionSystem_RemoveFatalIndicator");
static_assert(sizeof(LActionSystem_RemoveFatalIndicator) == 0x000010, "Wrong size on LActionSystem_RemoveFatalIndicator");
static_assert(offsetof(LActionSystem_RemoveFatalIndicator, TargetActor) == 0x000000, "Member 'LActionSystem_RemoveFatalIndicator::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionSystem_RemoveFatalIndicator, SuccessFatalAttackInfoIndex) == 0x000008, "Member 'LActionSystem_RemoveFatalIndicator::SuccessFatalAttackInfoIndex' has a wrong offset!");

// Function ProjectP.LActionSystem.GetBL_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetBL_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetBL_Start) == 0x000004, "Wrong alignment on LActionSystem_GetBL_Start");
static_assert(sizeof(LActionSystem_GetBL_Start) == 0x000004, "Wrong size on LActionSystem_GetBL_Start");
static_assert(offsetof(LActionSystem_GetBL_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetBL_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetBR_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetBR_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetBR_Start) == 0x000004, "Wrong alignment on LActionSystem_GetBR_Start");
static_assert(sizeof(LActionSystem_GetBR_Start) == 0x000004, "Wrong size on LActionSystem_GetBR_Start");
static_assert(offsetof(LActionSystem_GetBR_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetBR_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetDash_Back_End
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetDash_Back_End final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetDash_Back_End) == 0x000004, "Wrong alignment on LActionSystem_GetDash_Back_End");
static_assert(sizeof(LActionSystem_GetDash_Back_End) == 0x000004, "Wrong size on LActionSystem_GetDash_Back_End");
static_assert(offsetof(LActionSystem_GetDash_Back_End, ReturnValue) == 0x000000, "Member 'LActionSystem_GetDash_Back_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetDash_Front_End
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetDash_Front_End final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetDash_Front_End) == 0x000004, "Wrong alignment on LActionSystem_GetDash_Front_End");
static_assert(sizeof(LActionSystem_GetDash_Front_End) == 0x000004, "Wrong size on LActionSystem_GetDash_Front_End");
static_assert(offsetof(LActionSystem_GetDash_Front_End, ReturnValue) == 0x000000, "Member 'LActionSystem_GetDash_Front_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetDash_Left_End
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetDash_Left_End final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetDash_Left_End) == 0x000004, "Wrong alignment on LActionSystem_GetDash_Left_End");
static_assert(sizeof(LActionSystem_GetDash_Left_End) == 0x000004, "Wrong size on LActionSystem_GetDash_Left_End");
static_assert(offsetof(LActionSystem_GetDash_Left_End, ReturnValue) == 0x000000, "Member 'LActionSystem_GetDash_Left_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetDash_Right_End
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetDash_Right_End final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetDash_Right_End) == 0x000004, "Wrong alignment on LActionSystem_GetDash_Right_End");
static_assert(sizeof(LActionSystem_GetDash_Right_End) == 0x000004, "Wrong size on LActionSystem_GetDash_Right_End");
static_assert(offsetof(LActionSystem_GetDash_Right_End, ReturnValue) == 0x000000, "Member 'LActionSystem_GetDash_Right_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetDownRotateTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetDownRotateTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetDownRotateTime) == 0x000004, "Wrong alignment on LActionSystem_GetDownRotateTime");
static_assert(sizeof(LActionSystem_GetDownRotateTime) == 0x000004, "Wrong size on LActionSystem_GetDownRotateTime");
static_assert(offsetof(LActionSystem_GetDownRotateTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetDownRotateTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetFallingDieVariable
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetFallingDieVariable final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetFallingDieVariable) == 0x000004, "Wrong alignment on LActionSystem_GetFallingDieVariable");
static_assert(sizeof(LActionSystem_GetFallingDieVariable) == 0x000004, "Wrong size on LActionSystem_GetFallingDieVariable");
static_assert(offsetof(LActionSystem_GetFallingDieVariable, ReturnValue) == 0x000000, "Member 'LActionSystem_GetFallingDieVariable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetFatalTargetPointLocation
// 0x0014 (0x0014 - 0x0000)
struct LActionSystem_GetFatalTargetPointLocation final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InRange;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionSystem_GetFatalTargetPointLocation) == 0x000004, "Wrong alignment on LActionSystem_GetFatalTargetPointLocation");
static_assert(sizeof(LActionSystem_GetFatalTargetPointLocation) == 0x000014, "Wrong size on LActionSystem_GetFatalTargetPointLocation");
static_assert(offsetof(LActionSystem_GetFatalTargetPointLocation, Index_0) == 0x000000, "Member 'LActionSystem_GetFatalTargetPointLocation::Index_0' has a wrong offset!");
static_assert(offsetof(LActionSystem_GetFatalTargetPointLocation, WorldLocation) == 0x000004, "Member 'LActionSystem_GetFatalTargetPointLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(LActionSystem_GetFatalTargetPointLocation, InRange) == 0x000010, "Member 'LActionSystem_GetFatalTargetPointLocation::InRange' has a wrong offset!");

// Function ProjectP.LActionSystem.GetFL_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetFL_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetFL_Start) == 0x000004, "Wrong alignment on LActionSystem_GetFL_Start");
static_assert(sizeof(LActionSystem_GetFL_Start) == 0x000004, "Wrong size on LActionSystem_GetFL_Start");
static_assert(offsetof(LActionSystem_GetFL_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetFL_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetGroggyDamageRatioJustToughZero
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetGroggyDamageRatioJustToughZero final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetGroggyDamageRatioJustToughZero) == 0x000004, "Wrong alignment on LActionSystem_GetGroggyDamageRatioJustToughZero");
static_assert(sizeof(LActionSystem_GetGroggyDamageRatioJustToughZero) == 0x000004, "Wrong size on LActionSystem_GetGroggyDamageRatioJustToughZero");
static_assert(offsetof(LActionSystem_GetGroggyDamageRatioJustToughZero, ReturnValue) == 0x000000, "Member 'LActionSystem_GetGroggyDamageRatioJustToughZero::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetGuardEx_CoolTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetGuardEx_CoolTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetGuardEx_CoolTime) == 0x000004, "Wrong alignment on LActionSystem_GetGuardEx_CoolTime");
static_assert(sizeof(LActionSystem_GetGuardEx_CoolTime) == 0x000004, "Wrong size on LActionSystem_GetGuardEx_CoolTime");
static_assert(offsetof(LActionSystem_GetGuardEx_CoolTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetGuardEx_CoolTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetGuardRegainDamageRatio
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetGuardRegainDamageRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetGuardRegainDamageRatio) == 0x000004, "Wrong alignment on LActionSystem_GetGuardRegainDamageRatio");
static_assert(sizeof(LActionSystem_GetGuardRegainDamageRatio) == 0x000004, "Wrong size on LActionSystem_GetGuardRegainDamageRatio");
static_assert(offsetof(LActionSystem_GetGuardRegainDamageRatio, ReturnValue) == 0x000000, "Member 'LActionSystem_GetGuardRegainDamageRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetGuardRegainDelayTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetGuardRegainDelayTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetGuardRegainDelayTime) == 0x000004, "Wrong alignment on LActionSystem_GetGuardRegainDelayTime");
static_assert(sizeof(LActionSystem_GetGuardRegainDelayTime) == 0x000004, "Wrong size on LActionSystem_GetGuardRegainDelayTime");
static_assert(offsetof(LActionSystem_GetGuardRegainDelayTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetGuardRegainDelayTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetGuardRegainHealRatioParrying
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetGuardRegainHealRatioParrying final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetGuardRegainHealRatioParrying) == 0x000004, "Wrong alignment on LActionSystem_GetGuardRegainHealRatioParrying");
static_assert(sizeof(LActionSystem_GetGuardRegainHealRatioParrying) == 0x000004, "Wrong size on LActionSystem_GetGuardRegainHealRatioParrying");
static_assert(offsetof(LActionSystem_GetGuardRegainHealRatioParrying, ReturnValue) == 0x000000, "Member 'LActionSystem_GetGuardRegainHealRatioParrying::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetGuardRegainRecoveryRatioGuarding
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetGuardRegainRecoveryRatioGuarding final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetGuardRegainRecoveryRatioGuarding) == 0x000004, "Wrong alignment on LActionSystem_GetGuardRegainRecoveryRatioGuarding");
static_assert(sizeof(LActionSystem_GetGuardRegainRecoveryRatioGuarding) == 0x000004, "Wrong size on LActionSystem_GetGuardRegainRecoveryRatioGuarding");
static_assert(offsetof(LActionSystem_GetGuardRegainRecoveryRatioGuarding, ReturnValue) == 0x000000, "Member 'LActionSystem_GetGuardRegainRecoveryRatioGuarding::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetHit_Intencity_Down
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetHit_Intencity_Down final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetHit_Intencity_Down) == 0x000004, "Wrong alignment on LActionSystem_GetHit_Intencity_Down");
static_assert(sizeof(LActionSystem_GetHit_Intencity_Down) == 0x000004, "Wrong size on LActionSystem_GetHit_Intencity_Down");
static_assert(offsetof(LActionSystem_GetHit_Intencity_Down, ReturnValue) == 0x000000, "Member 'LActionSystem_GetHit_Intencity_Down::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetHit_Intencity_KnockBack
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetHit_Intencity_KnockBack final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetHit_Intencity_KnockBack) == 0x000004, "Wrong alignment on LActionSystem_GetHit_Intencity_KnockBack");
static_assert(sizeof(LActionSystem_GetHit_Intencity_KnockBack) == 0x000004, "Wrong size on LActionSystem_GetHit_Intencity_KnockBack");
static_assert(offsetof(LActionSystem_GetHit_Intencity_KnockBack, ReturnValue) == 0x000000, "Member 'LActionSystem_GetHit_Intencity_KnockBack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetHitRotateTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetHitRotateTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetHitRotateTime) == 0x000004, "Wrong alignment on LActionSystem_GetHitRotateTime");
static_assert(sizeof(LActionSystem_GetHitRotateTime) == 0x000004, "Wrong size on LActionSystem_GetHitRotateTime");
static_assert(offsetof(LActionSystem_GetHitRotateTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetHitRotateTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetJustRepairDuration
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetJustRepairDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetJustRepairDuration) == 0x000004, "Wrong alignment on LActionSystem_GetJustRepairDuration");
static_assert(sizeof(LActionSystem_GetJustRepairDuration) == 0x000004, "Wrong size on LActionSystem_GetJustRepairDuration");
static_assert(offsetof(LActionSystem_GetJustRepairDuration, ReturnValue) == 0x000000, "Member 'LActionSystem_GetJustRepairDuration::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetJustRepairSharpnessRatio
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetJustRepairSharpnessRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetJustRepairSharpnessRatio) == 0x000004, "Wrong alignment on LActionSystem_GetJustRepairSharpnessRatio");
static_assert(sizeof(LActionSystem_GetJustRepairSharpnessRatio) == 0x000004, "Wrong size on LActionSystem_GetJustRepairSharpnessRatio");
static_assert(offsetof(LActionSystem_GetJustRepairSharpnessRatio, ReturnValue) == 0x000000, "Member 'LActionSystem_GetJustRepairSharpnessRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetKnockbackRotateTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetKnockbackRotateTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetKnockbackRotateTime) == 0x000004, "Wrong alignment on LActionSystem_GetKnockbackRotateTime");
static_assert(sizeof(LActionSystem_GetKnockbackRotateTime) == 0x000004, "Wrong size on LActionSystem_GetKnockbackRotateTime");
static_assert(offsetof(LActionSystem_GetKnockbackRotateTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetKnockbackRotateTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetLB_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetLB_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetLB_Start) == 0x000004, "Wrong alignment on LActionSystem_GetLB_Start");
static_assert(sizeof(LActionSystem_GetLB_Start) == 0x000004, "Wrong size on LActionSystem_GetLB_Start");
static_assert(offsetof(LActionSystem_GetLB_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetLB_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetLF_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetLF_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetLF_Start) == 0x000004, "Wrong alignment on LActionSystem_GetLF_Start");
static_assert(sizeof(LActionSystem_GetLF_Start) == 0x000004, "Wrong size on LActionSystem_GetLF_Start");
static_assert(offsetof(LActionSystem_GetLF_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetLF_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetOnGuardHit_RetainTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetOnGuardHit_RetainTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetOnGuardHit_RetainTime) == 0x000004, "Wrong alignment on LActionSystem_GetOnGuardHit_RetainTime");
static_assert(sizeof(LActionSystem_GetOnGuardHit_RetainTime) == 0x000004, "Wrong size on LActionSystem_GetOnGuardHit_RetainTime");
static_assert(offsetof(LActionSystem_GetOnGuardHit_RetainTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetOnGuardHit_RetainTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetPerfectGuard_HitDurationRatio
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetPerfectGuard_HitDurationRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetPerfectGuard_HitDurationRatio) == 0x000004, "Wrong alignment on LActionSystem_GetPerfectGuard_HitDurationRatio");
static_assert(sizeof(LActionSystem_GetPerfectGuard_HitDurationRatio) == 0x000004, "Wrong size on LActionSystem_GetPerfectGuard_HitDurationRatio");
static_assert(offsetof(LActionSystem_GetPerfectGuard_HitDurationRatio, ReturnValue) == 0x000000, "Member 'LActionSystem_GetPerfectGuard_HitDurationRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetPerfectGuard_KnockbackDistanceRatio
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetPerfectGuard_KnockbackDistanceRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetPerfectGuard_KnockbackDistanceRatio) == 0x000004, "Wrong alignment on LActionSystem_GetPerfectGuard_KnockbackDistanceRatio");
static_assert(sizeof(LActionSystem_GetPerfectGuard_KnockbackDistanceRatio) == 0x000004, "Wrong size on LActionSystem_GetPerfectGuard_KnockbackDistanceRatio");
static_assert(offsetof(LActionSystem_GetPerfectGuard_KnockbackDistanceRatio, ReturnValue) == 0x000000, "Member 'LActionSystem_GetPerfectGuard_KnockbackDistanceRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetPerfectGuard_KnockbackDurationRatio
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetPerfectGuard_KnockbackDurationRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetPerfectGuard_KnockbackDurationRatio) == 0x000004, "Wrong alignment on LActionSystem_GetPerfectGuard_KnockbackDurationRatio");
static_assert(sizeof(LActionSystem_GetPerfectGuard_KnockbackDurationRatio) == 0x000004, "Wrong size on LActionSystem_GetPerfectGuard_KnockbackDurationRatio");
static_assert(offsetof(LActionSystem_GetPerfectGuard_KnockbackDurationRatio, ReturnValue) == 0x000000, "Member 'LActionSystem_GetPerfectGuard_KnockbackDurationRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetPerfectGuard_ReduceRate
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetPerfectGuard_ReduceRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetPerfectGuard_ReduceRate) == 0x000004, "Wrong alignment on LActionSystem_GetPerfectGuard_ReduceRate");
static_assert(sizeof(LActionSystem_GetPerfectGuard_ReduceRate) == 0x000004, "Wrong size on LActionSystem_GetPerfectGuard_ReduceRate");
static_assert(offsetof(LActionSystem_GetPerfectGuard_ReduceRate, ReturnValue) == 0x000000, "Member 'LActionSystem_GetPerfectGuard_ReduceRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetPerfectGuard_Stamina_ReduceRate
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetPerfectGuard_Stamina_ReduceRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetPerfectGuard_Stamina_ReduceRate) == 0x000004, "Wrong alignment on LActionSystem_GetPerfectGuard_Stamina_ReduceRate");
static_assert(sizeof(LActionSystem_GetPerfectGuard_Stamina_ReduceRate) == 0x000004, "Wrong size on LActionSystem_GetPerfectGuard_Stamina_ReduceRate");
static_assert(offsetof(LActionSystem_GetPerfectGuard_Stamina_ReduceRate, ReturnValue) == 0x000000, "Member 'LActionSystem_GetPerfectGuard_Stamina_ReduceRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetRagdollFreezeTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetRagdollFreezeTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetRagdollFreezeTime) == 0x000004, "Wrong alignment on LActionSystem_GetRagdollFreezeTime");
static_assert(sizeof(LActionSystem_GetRagdollFreezeTime) == 0x000004, "Wrong size on LActionSystem_GetRagdollFreezeTime");
static_assert(offsetof(LActionSystem_GetRagdollFreezeTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetRagdollFreezeTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetRagdollInteractionTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetRagdollInteractionTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetRagdollInteractionTime) == 0x000004, "Wrong alignment on LActionSystem_GetRagdollInteractionTime");
static_assert(sizeof(LActionSystem_GetRagdollInteractionTime) == 0x000004, "Wrong size on LActionSystem_GetRagdollInteractionTime");
static_assert(offsetof(LActionSystem_GetRagdollInteractionTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetRagdollInteractionTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetRB_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetRB_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetRB_Start) == 0x000004, "Wrong alignment on LActionSystem_GetRB_Start");
static_assert(sizeof(LActionSystem_GetRB_Start) == 0x000004, "Wrong size on LActionSystem_GetRB_Start");
static_assert(offsetof(LActionSystem_GetRB_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetRB_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetRF_Start
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetRF_Start final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetRF_Start) == 0x000004, "Wrong alignment on LActionSystem_GetRF_Start");
static_assert(sizeof(LActionSystem_GetRF_Start) == 0x000004, "Wrong size on LActionSystem_GetRF_Start");
static_assert(offsetof(LActionSystem_GetRF_Start, ReturnValue) == 0x000000, "Member 'LActionSystem_GetRF_Start::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetRgidityRatioPerfectGuard
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetRgidityRatioPerfectGuard final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetRgidityRatioPerfectGuard) == 0x000004, "Wrong alignment on LActionSystem_GetRgidityRatioPerfectGuard");
static_assert(sizeof(LActionSystem_GetRgidityRatioPerfectGuard) == 0x000004, "Wrong size on LActionSystem_GetRgidityRatioPerfectGuard");
static_assert(offsetof(LActionSystem_GetRgidityRatioPerfectGuard, ReturnValue) == 0x000000, "Member 'LActionSystem_GetRgidityRatioPerfectGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetRigidityConstant
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetRigidityConstant final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetRigidityConstant) == 0x000004, "Wrong alignment on LActionSystem_GetRigidityConstant");
static_assert(sizeof(LActionSystem_GetRigidityConstant) == 0x000004, "Wrong size on LActionSystem_GetRigidityConstant");
static_assert(offsetof(LActionSystem_GetRigidityConstant, ReturnValue) == 0x000000, "Member 'LActionSystem_GetRigidityConstant::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetSparkFxInterval
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetSparkFxInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetSparkFxInterval) == 0x000004, "Wrong alignment on LActionSystem_GetSparkFxInterval");
static_assert(sizeof(LActionSystem_GetSparkFxInterval) == 0x000004, "Wrong size on LActionSystem_GetSparkFxInterval");
static_assert(offsetof(LActionSystem_GetSparkFxInterval, ReturnValue) == 0x000000, "Member 'LActionSystem_GetSparkFxInterval::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetSparkSFxInterval
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetSparkSFxInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetSparkSFxInterval) == 0x000004, "Wrong alignment on LActionSystem_GetSparkSFxInterval");
static_assert(sizeof(LActionSystem_GetSparkSFxInterval) == 0x000004, "Wrong size on LActionSystem_GetSparkSFxInterval");
static_assert(offsetof(LActionSystem_GetSparkSFxInterval, ReturnValue) == 0x000000, "Member 'LActionSystem_GetSparkSFxInterval::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetStiffen_Duration_PerfectGuard
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetStiffen_Duration_PerfectGuard final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetStiffen_Duration_PerfectGuard) == 0x000004, "Wrong alignment on LActionSystem_GetStiffen_Duration_PerfectGuard");
static_assert(sizeof(LActionSystem_GetStiffen_Duration_PerfectGuard) == 0x000004, "Wrong size on LActionSystem_GetStiffen_Duration_PerfectGuard");
static_assert(offsetof(LActionSystem_GetStiffen_Duration_PerfectGuard, ReturnValue) == 0x000000, "Member 'LActionSystem_GetStiffen_Duration_PerfectGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetStiffen_PlayRate_PerfectGuard
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetStiffen_PlayRate_PerfectGuard final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetStiffen_PlayRate_PerfectGuard) == 0x000004, "Wrong alignment on LActionSystem_GetStiffen_PlayRate_PerfectGuard");
static_assert(sizeof(LActionSystem_GetStiffen_PlayRate_PerfectGuard) == 0x000004, "Wrong size on LActionSystem_GetStiffen_PlayRate_PerfectGuard");
static_assert(offsetof(LActionSystem_GetStiffen_PlayRate_PerfectGuard, ReturnValue) == 0x000000, "Member 'LActionSystem_GetStiffen_PlayRate_PerfectGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetStiffenDelayDefender
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetStiffenDelayDefender final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetStiffenDelayDefender) == 0x000004, "Wrong alignment on LActionSystem_GetStiffenDelayDefender");
static_assert(sizeof(LActionSystem_GetStiffenDelayDefender) == 0x000004, "Wrong size on LActionSystem_GetStiffenDelayDefender");
static_assert(offsetof(LActionSystem_GetStiffenDelayDefender, ReturnValue) == 0x000000, "Member 'LActionSystem_GetStiffenDelayDefender::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetStopAfterSprintTime
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetStopAfterSprintTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetStopAfterSprintTime) == 0x000004, "Wrong alignment on LActionSystem_GetStopAfterSprintTime");
static_assert(sizeof(LActionSystem_GetStopAfterSprintTime) == 0x000004, "Wrong size on LActionSystem_GetStopAfterSprintTime");
static_assert(offsetof(LActionSystem_GetStopAfterSprintTime, ReturnValue) == 0x000000, "Member 'LActionSystem_GetStopAfterSprintTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetWeaponMaxSharpnessReduceRatio_By_Grinding
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding) == 0x000004, "Wrong alignment on LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding");
static_assert(sizeof(LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding) == 0x000004, "Wrong size on LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding");
static_assert(offsetof(LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding, ReturnValue) == 0x000000, "Member 'LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionSystem.GetWeaponSharpnessReduceMultiplier_By_Grinding_count
// 0x0004 (0x0004 - 0x0000)
struct LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count) == 0x000004, "Wrong alignment on LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count");
static_assert(sizeof(LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count) == 0x000004, "Wrong size on LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count");
static_assert(offsetof(LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count, ReturnValue) == 0x000000, "Member 'LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.AddInputActionKeyMapping
// 0x0038 (0x0038 - 0x0000)
struct LActionUtilFuncLibrary_AddInputActionKeyMapping final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 Mapping;                                           // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_AddInputActionKeyMapping) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_AddInputActionKeyMapping");
static_assert(sizeof(LActionUtilFuncLibrary_AddInputActionKeyMapping) == 0x000038, "Wrong size on LActionUtilFuncLibrary_AddInputActionKeyMapping");
static_assert(offsetof(LActionUtilFuncLibrary_AddInputActionKeyMapping, InputAction) == 0x000000, "Member 'LActionUtilFuncLibrary_AddInputActionKeyMapping::InputAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_AddInputActionKeyMapping, Mapping) == 0x000008, "Member 'LActionUtilFuncLibrary_AddInputActionKeyMapping::Mapping' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_AddInputActionKeyMapping, ReturnValue) == 0x000030, "Member 'LActionUtilFuncLibrary_AddInputActionKeyMapping::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.AddInputAxisKeyMapping
// 0x0038 (0x0038 - 0x0000)
struct LActionUtilFuncLibrary_AddInputAxisKeyMapping final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputAxisKeyMapping                   Mapping;                                           // 0x0008(0x0028)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_AddInputAxisKeyMapping) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_AddInputAxisKeyMapping");
static_assert(sizeof(LActionUtilFuncLibrary_AddInputAxisKeyMapping) == 0x000038, "Wrong size on LActionUtilFuncLibrary_AddInputAxisKeyMapping");
static_assert(offsetof(LActionUtilFuncLibrary_AddInputAxisKeyMapping, InputAction) == 0x000000, "Member 'LActionUtilFuncLibrary_AddInputAxisKeyMapping::InputAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_AddInputAxisKeyMapping, Mapping) == 0x000008, "Member 'LActionUtilFuncLibrary_AddInputAxisKeyMapping::Mapping' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_AddInputAxisKeyMapping, ReturnValue) == 0x000030, "Member 'LActionUtilFuncLibrary_AddInputAxisKeyMapping::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CalcHitAngleBP
// 0x0178 (0x0178 - 0x0000)
struct LActionUtilFuncLibrary_CalcHitAngleBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                OutHitOrigin;                                      // 0x0160(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x016C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0170(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CalcHitAngleBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CalcHitAngleBP");
static_assert(sizeof(LActionUtilFuncLibrary_CalcHitAngleBP) == 0x000178, "Wrong size on LActionUtilFuncLibrary_CalcHitAngleBP");
static_assert(offsetof(LActionUtilFuncLibrary_CalcHitAngleBP, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_CalcHitAngleBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcHitAngleBP, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_CalcHitAngleBP::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcHitAngleBP, HitInfo) == 0x000010, "Member 'LActionUtilFuncLibrary_CalcHitAngleBP::HitInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcHitAngleBP, OutHitOrigin) == 0x000160, "Member 'LActionUtilFuncLibrary_CalcHitAngleBP::OutHitOrigin' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcHitAngleBP, Branches) == 0x00016C, "Member 'LActionUtilFuncLibrary_CalcHitAngleBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcHitAngleBP, ReturnValue) == 0x000170, "Member 'LActionUtilFuncLibrary_CalcHitAngleBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CalcParabolicMoveVelocity
// 0x002C (0x002C - 0x0000)
struct LActionUtilFuncLibrary_CalcParabolicMoveVelocity final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_CalcParabolicMoveVelocity");
static_assert(sizeof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity) == 0x00002C, "Wrong size on LActionUtilFuncLibrary_CalcParabolicMoveVelocity");
static_assert(offsetof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity, StartLocation) == 0x000000, "Member 'LActionUtilFuncLibrary_CalcParabolicMoveVelocity::StartLocation' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity, EndLocation) == 0x00000C, "Member 'LActionUtilFuncLibrary_CalcParabolicMoveVelocity::EndLocation' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity, Duration) == 0x000018, "Member 'LActionUtilFuncLibrary_CalcParabolicMoveVelocity::Duration' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity, Gravity) == 0x00001C, "Member 'LActionUtilFuncLibrary_CalcParabolicMoveVelocity::Gravity' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CalcParabolicMoveVelocity, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_CalcParabolicMoveVelocity::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangeCollisionState
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_ChangeCollisionState final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCollisionState                              CollisionState;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_ChangeCollisionState) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ChangeCollisionState");
static_assert(sizeof(LActionUtilFuncLibrary_ChangeCollisionState) == 0x000010, "Wrong size on LActionUtilFuncLibrary_ChangeCollisionState");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeCollisionState, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangeCollisionState::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeCollisionState, CollisionState) == 0x000008, "Member 'LActionUtilFuncLibrary_ChangeCollisionState::CollisionState' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangeFloatingState
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_ChangeFloatingState final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCeiling;                                     // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_ChangeFloatingState) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ChangeFloatingState");
static_assert(sizeof(LActionUtilFuncLibrary_ChangeFloatingState) == 0x000010, "Wrong size on LActionUtilFuncLibrary_ChangeFloatingState");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeFloatingState, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangeFloatingState::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeFloatingState, bEnable) == 0x000008, "Member 'LActionUtilFuncLibrary_ChangeFloatingState::bEnable' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeFloatingState, bApplyCeiling) == 0x000009, "Member 'LActionUtilFuncLibrary_ChangeFloatingState::bApplyCeiling' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangeHairCategoryType
// 0x0001 (0x0001 - 0x0000)
struct LActionUtilFuncLibrary_ChangeHairCategoryType final
{
public:
	ELHairCategoryType                            HairCategoryType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ChangeHairCategoryType) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_ChangeHairCategoryType");
static_assert(sizeof(LActionUtilFuncLibrary_ChangeHairCategoryType) == 0x000001, "Wrong size on LActionUtilFuncLibrary_ChangeHairCategoryType");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeHairCategoryType, HairCategoryType) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangeHairCategoryType::HairCategoryType' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangeInputPreset
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_ChangeInputPreset final
{
public:
	class FName                                   PresetName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_ChangeInputPreset) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_ChangeInputPreset");
static_assert(sizeof(LActionUtilFuncLibrary_ChangeInputPreset) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_ChangeInputPreset");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeInputPreset, PresetName) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangeInputPreset::PresetName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeInputPreset, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_ChangeInputPreset::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangePerBodyCollisionProfile
// 0x0030 (0x0030 - 0x0000)
struct LActionUtilFuncLibrary_ChangePerBodyCollisionProfile final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnOffOverlapBody;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnOffSecondaryBody;                              // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfile_ChangeTarget;                     // 0x000C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfile_Other;                            // 0x0014(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutCount_AllBody;                                  // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutCount_ChangeByOverlap;                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutCount_ChangedBySecondary;                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ChangePerBodyCollisionProfile");
static_assert(sizeof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile) == 0x000030, "Wrong size on LActionUtilFuncLibrary_ChangePerBodyCollisionProfile");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, TurnOffOverlapBody) == 0x000008, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::TurnOffOverlapBody' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, TurnOffSecondaryBody) == 0x000009, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::TurnOffSecondaryBody' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, CollisionProfile_ChangeTarget) == 0x00000C, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::CollisionProfile_ChangeTarget' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, CollisionProfile_Other) == 0x000014, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::CollisionProfile_Other' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, OutCount_AllBody) == 0x00001C, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::OutCount_AllBody' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, OutCount_ChangeByOverlap) == 0x000020, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::OutCount_ChangeByOverlap' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, OutCount_ChangedBySecondary) == 0x000024, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::OutCount_ChangedBySecondary' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangePerBodyCollisionProfile, ReturnValue) == 0x000028, "Member 'LActionUtilFuncLibrary_ChangePerBodyCollisionProfile::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangeWeaponAnimState
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_ChangeWeaponAnimState final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponPartType                              PartType;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimState;                                         // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ChangeWeaponAnimState) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ChangeWeaponAnimState");
static_assert(sizeof(LActionUtilFuncLibrary_ChangeWeaponAnimState) == 0x000018, "Wrong size on LActionUtilFuncLibrary_ChangeWeaponAnimState");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimState, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimState::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimState, AttachPointType) == 0x000008, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimState::AttachPointType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimState, PartType) == 0x000009, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimState::PartType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimState, AnimState) == 0x00000C, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimState::AnimState' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimState, ReturnValue) == 0x000014, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ChangeWeaponAnimStateWithPickedIndex
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickedIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponPartType                              PartType;                                          // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimState;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex");
static_assert(sizeof(LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex) == 0x000018, "Wrong size on LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex, PickedIndex) == 0x000008, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex::PickedIndex' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex, PartType) == 0x00000C, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex::PartType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex, AnimState) == 0x000010, "Member 'LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex::AnimState' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheatFalling
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_CheatFalling final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_CheatFalling) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheatFalling");
static_assert(sizeof(LActionUtilFuncLibrary_CheatFalling) == 0x000008, "Wrong size on LActionUtilFuncLibrary_CheatFalling");
static_assert(offsetof(LActionUtilFuncLibrary_CheatFalling, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_CheatFalling::TargetActor' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheatFly
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_CheatFly final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_CheatFly) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheatFly");
static_assert(sizeof(LActionUtilFuncLibrary_CheatFly) == 0x000008, "Wrong size on LActionUtilFuncLibrary_CheatFly");
static_assert(offsetof(LActionUtilFuncLibrary_CheatFly, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_CheatFly::TargetActor' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheatGhost
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_CheatGhost final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_CheatGhost) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheatGhost");
static_assert(sizeof(LActionUtilFuncLibrary_CheatGhost) == 0x000008, "Wrong size on LActionUtilFuncLibrary_CheatGhost");
static_assert(offsetof(LActionUtilFuncLibrary_CheatGhost, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_CheatGhost::TargetActor' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheatWalk
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_CheatWalk final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_CheatWalk) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheatWalk");
static_assert(sizeof(LActionUtilFuncLibrary_CheatWalk) == 0x000008, "Wrong size on LActionUtilFuncLibrary_CheatWalk");
static_assert(offsetof(LActionUtilFuncLibrary_CheatWalk, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_CheatWalk::TargetActor' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheckAlwaysGuard
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_CheckAlwaysGuard final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CheckAlwaysGuard) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheckAlwaysGuard");
static_assert(sizeof(LActionUtilFuncLibrary_CheckAlwaysGuard) == 0x000018, "Wrong size on LActionUtilFuncLibrary_CheckAlwaysGuard");
static_assert(offsetof(LActionUtilFuncLibrary_CheckAlwaysGuard, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_CheckAlwaysGuard::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckAlwaysGuard, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_CheckAlwaysGuard::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckAlwaysGuard, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_CheckAlwaysGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheckCollisionOwnerTypeBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP final
{
public:
	const class UPrimitiveComponent*              CollisionComponent;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCollisionOwnerType                          CheckType;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP");
static_assert(sizeof(LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP");
static_assert(offsetof(LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP, CollisionComponent) == 0x000000, "Member 'LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP::CollisionComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP, CheckType) == 0x000008, "Member 'LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP::CheckType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP, Branches) == 0x000009, "Member 'LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP, ReturnValue) == 0x00000A, "Member 'LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheckFatalAttackConditionsBP
// 0x0060 (0x0060 - 0x0000)
struct LActionUtilFuncLibrary_CheckFatalAttackConditionsBP final
{
public:
	class AActor*                                 CheckTarget;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      CheckFatalAttackInfo;                              // 0x0008(0x0054)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AllowFatalTrailMargin;                             // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x005D(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x005E(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheckFatalAttackConditionsBP");
static_assert(sizeof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP) == 0x000060, "Wrong size on LActionUtilFuncLibrary_CheckFatalAttackConditionsBP");
static_assert(offsetof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP, CheckTarget) == 0x000000, "Member 'LActionUtilFuncLibrary_CheckFatalAttackConditionsBP::CheckTarget' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP, CheckFatalAttackInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_CheckFatalAttackConditionsBP::CheckFatalAttackInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP, AllowFatalTrailMargin) == 0x00005C, "Member 'LActionUtilFuncLibrary_CheckFatalAttackConditionsBP::AllowFatalTrailMargin' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP, Branches) == 0x00005D, "Member 'LActionUtilFuncLibrary_CheckFatalAttackConditionsBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckFatalAttackConditionsBP, ReturnValue) == 0x00005E, "Member 'LActionUtilFuncLibrary_CheckFatalAttackConditionsBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheckGrabBP
// 0x0168 (0x0168 - 0x0000)
struct LActionUtilFuncLibrary_CheckGrabBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0160(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0161(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CheckGrabBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheckGrabBP");
static_assert(sizeof(LActionUtilFuncLibrary_CheckGrabBP) == 0x000168, "Wrong size on LActionUtilFuncLibrary_CheckGrabBP");
static_assert(offsetof(LActionUtilFuncLibrary_CheckGrabBP, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_CheckGrabBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckGrabBP, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_CheckGrabBP::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckGrabBP, HitInfo) == 0x000010, "Member 'LActionUtilFuncLibrary_CheckGrabBP::HitInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckGrabBP, Branches) == 0x000160, "Member 'LActionUtilFuncLibrary_CheckGrabBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckGrabBP, ReturnValue) == 0x000161, "Member 'LActionUtilFuncLibrary_CheckGrabBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CheckObstacleOnPathBP
// 0x00A8 (0x00A8 - 0x0000)
struct LActionUtilFuncLibrary_CheckObstacleOnPathBP final
{
public:
	class UPrimitiveComponent*                    CheckTargetComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PathArray;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             ReturnValue;                                       // 0x001C(0x0088)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CheckObstacleOnPathBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CheckObstacleOnPathBP");
static_assert(sizeof(LActionUtilFuncLibrary_CheckObstacleOnPathBP) == 0x0000A8, "Wrong size on LActionUtilFuncLibrary_CheckObstacleOnPathBP");
static_assert(offsetof(LActionUtilFuncLibrary_CheckObstacleOnPathBP, CheckTargetComponent) == 0x000000, "Member 'LActionUtilFuncLibrary_CheckObstacleOnPathBP::CheckTargetComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckObstacleOnPathBP, PathArray) == 0x000008, "Member 'LActionUtilFuncLibrary_CheckObstacleOnPathBP::PathArray' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckObstacleOnPathBP, Branches) == 0x000018, "Member 'LActionUtilFuncLibrary_CheckObstacleOnPathBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CheckObstacleOnPathBP, ReturnValue) == 0x00001C, "Member 'LActionUtilFuncLibrary_CheckObstacleOnPathBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.CollectLCharacterInRange
// 0x0038 (0x0038 - 0x0000)
struct LActionUtilFuncLibrary_CollectLCharacterInRange final
{
public:
	struct FVector                                TestOrigin;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ALCharacter*>                    IgnoredCharacterArray;                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class ALCharacter*>                    OutCollectedCharacterArray;                        // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_CollectLCharacterInRange) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_CollectLCharacterInRange");
static_assert(sizeof(LActionUtilFuncLibrary_CollectLCharacterInRange) == 0x000038, "Wrong size on LActionUtilFuncLibrary_CollectLCharacterInRange");
static_assert(offsetof(LActionUtilFuncLibrary_CollectLCharacterInRange, TestOrigin) == 0x000000, "Member 'LActionUtilFuncLibrary_CollectLCharacterInRange::TestOrigin' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CollectLCharacterInRange, Range) == 0x00000C, "Member 'LActionUtilFuncLibrary_CollectLCharacterInRange::Range' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CollectLCharacterInRange, IgnoredCharacterArray) == 0x000010, "Member 'LActionUtilFuncLibrary_CollectLCharacterInRange::IgnoredCharacterArray' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CollectLCharacterInRange, OutCollectedCharacterArray) == 0x000020, "Member 'LActionUtilFuncLibrary_CollectLCharacterInRange::OutCollectedCharacterArray' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_CollectLCharacterInRange, ReturnValue) == 0x000030, "Member 'LActionUtilFuncLibrary_CollectLCharacterInRange::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ComputeFatalOffsetRotationBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP final
{
public:
	class AActor*                                 CheckTarget;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP");
static_assert(sizeof(LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP");
static_assert(offsetof(LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP, CheckTarget) == 0x000000, "Member 'LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP::CheckTarget' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ConvertToActionKey
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_ConvertToActionKey final
{
public:
	class FString                                 InActionName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_ConvertToActionKey) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ConvertToActionKey");
static_assert(sizeof(LActionUtilFuncLibrary_ConvertToActionKey) == 0x000018, "Wrong size on LActionUtilFuncLibrary_ConvertToActionKey");
static_assert(offsetof(LActionUtilFuncLibrary_ConvertToActionKey, InActionName) == 0x000000, "Member 'LActionUtilFuncLibrary_ConvertToActionKey::InActionName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ConvertToActionKey, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_ConvertToActionKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ConvertToActionKeyString
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_ConvertToActionKeyString final
{
public:
	ELPCActionKeyType                             InActionKey;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ConvertToActionKeyString) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ConvertToActionKeyString");
static_assert(sizeof(LActionUtilFuncLibrary_ConvertToActionKeyString) == 0x000018, "Wrong size on LActionUtilFuncLibrary_ConvertToActionKeyString");
static_assert(offsetof(LActionUtilFuncLibrary_ConvertToActionKeyString, InActionKey) == 0x000000, "Member 'LActionUtilFuncLibrary_ConvertToActionKeyString::InActionKey' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ConvertToActionKeyString, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_ConvertToActionKeyString::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DecreaseWeaponDestructDurability
// 0x0030 (0x0030 - 0x0000)
struct LActionUtilFuncLibrary_DecreaseWeaponDestructDurability final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurabilityAmount;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BreakDirection;                                    // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVictimGuard;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayHitAction;                                    // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OutPlayActionClassCodeName;                        // 0x0024(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DecreaseWeaponDestructDurability");
static_assert(sizeof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability) == 0x000030, "Wrong size on LActionUtilFuncLibrary_DecreaseWeaponDestructDurability");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, DurabilityAmount) == 0x000010, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::DurabilityAmount' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, BreakDirection) == 0x000014, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::BreakDirection' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, bVictimGuard) == 0x000020, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::bVictimGuard' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, bPlayHitAction) == 0x000021, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::bPlayHitAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DecreaseWeaponDestructDurability, OutPlayActionClassCodeName) == 0x000024, "Member 'LActionUtilFuncLibrary_DecreaseWeaponDestructDurability::OutPlayActionClassCodeName' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoChangeCharBlockType
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_DoChangeCharBlockType final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCharacterCollisionType                      CharacterCollisionType;                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStack;                                          // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoChangeCharBlockType) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoChangeCharBlockType");
static_assert(sizeof(LActionUtilFuncLibrary_DoChangeCharBlockType) == 0x000010, "Wrong size on LActionUtilFuncLibrary_DoChangeCharBlockType");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeCharBlockType, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoChangeCharBlockType::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeCharBlockType, CharacterCollisionType) == 0x000008, "Member 'LActionUtilFuncLibrary_DoChangeCharBlockType::CharacterCollisionType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeCharBlockType, UseStack) == 0x000009, "Member 'LActionUtilFuncLibrary_DoChangeCharBlockType::UseStack' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeCharBlockType, ReturnValue) == 0x00000A, "Member 'LActionUtilFuncLibrary_DoChangeCharBlockType::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoChangeWeapon
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_DoChangeWeapon final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectPrevious;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoChangeWeapon) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoChangeWeapon");
static_assert(sizeof(LActionUtilFuncLibrary_DoChangeWeapon) == 0x000010, "Wrong size on LActionUtilFuncLibrary_DoChangeWeapon");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeWeapon, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoChangeWeapon::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeWeapon, SelectPrevious) == 0x000008, "Member 'LActionUtilFuncLibrary_DoChangeWeapon::SelectPrevious' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoChangeWeapon, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_DoChangeWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoCharacterKillZone
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_DoCharacterKillZone final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomDieUIShowTime;                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DieUI_StartDelay;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoExecuteSequence;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoCharacterKillZone) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoCharacterKillZone");
static_assert(sizeof(LActionUtilFuncLibrary_DoCharacterKillZone) == 0x000018, "Wrong size on LActionUtilFuncLibrary_DoCharacterKillZone");
static_assert(offsetof(LActionUtilFuncLibrary_DoCharacterKillZone, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoCharacterKillZone::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoCharacterKillZone, bUseCustomDieUIShowTime) == 0x000008, "Member 'LActionUtilFuncLibrary_DoCharacterKillZone::bUseCustomDieUIShowTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoCharacterKillZone, DieUI_StartDelay) == 0x00000C, "Member 'LActionUtilFuncLibrary_DoCharacterKillZone::DieUI_StartDelay' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoCharacterKillZone, bDoExecuteSequence) == 0x000010, "Member 'LActionUtilFuncLibrary_DoCharacterKillZone::bDoExecuteSequence' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoGrabBP
// 0x0168 (0x0168 - 0x0000)
struct LActionUtilFuncLibrary_DoGrabBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0160(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0161(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoGrabBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoGrabBP");
static_assert(sizeof(LActionUtilFuncLibrary_DoGrabBP) == 0x000168, "Wrong size on LActionUtilFuncLibrary_DoGrabBP");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabBP, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_DoGrabBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabBP, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_DoGrabBP::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabBP, HitInfo) == 0x000010, "Member 'LActionUtilFuncLibrary_DoGrabBP::HitInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabBP, Branches) == 0x000160, "Member 'LActionUtilFuncLibrary_DoGrabBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabBP, ReturnValue) == 0x000161, "Member 'LActionUtilFuncLibrary_DoGrabBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoGrabReleaseBP
// 0x0030 (0x0030 - 0x0000)
struct LActionUtilFuncLibrary_DoGrabReleaseBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGrabReleaseInfo                      GrabReleaseInfo;                                   // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoGrabReleaseBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoGrabReleaseBP");
static_assert(sizeof(LActionUtilFuncLibrary_DoGrabReleaseBP) == 0x000030, "Wrong size on LActionUtilFuncLibrary_DoGrabReleaseBP");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabReleaseBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoGrabReleaseBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabReleaseBP, GrabReleaseInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_DoGrabReleaseBP::GrabReleaseInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabReleaseBP, Branches) == 0x000028, "Member 'LActionUtilFuncLibrary_DoGrabReleaseBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoGrabReleaseBP, ReturnValue) == 0x000029, "Member 'LActionUtilFuncLibrary_DoGrabReleaseBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoHideBone
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_DoHideBone final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hide;                                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoHideBone) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoHideBone");
static_assert(sizeof(LActionUtilFuncLibrary_DoHideBone) == 0x000018, "Wrong size on LActionUtilFuncLibrary_DoHideBone");
static_assert(offsetof(LActionUtilFuncLibrary_DoHideBone, SkeletalMeshComponent) == 0x000000, "Member 'LActionUtilFuncLibrary_DoHideBone::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoHideBone, BoneName) == 0x000008, "Member 'LActionUtilFuncLibrary_DoHideBone::BoneName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoHideBone, Hide) == 0x000010, "Member 'LActionUtilFuncLibrary_DoHideBone::Hide' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoHideBone, ReturnValue) == 0x000011, "Member 'LActionUtilFuncLibrary_DoHideBone::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoIdleMove
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_DoIdleMove final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalledFromNotify;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoIdleMove) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoIdleMove");
static_assert(sizeof(LActionUtilFuncLibrary_DoIdleMove) == 0x000010, "Wrong size on LActionUtilFuncLibrary_DoIdleMove");
static_assert(offsetof(LActionUtilFuncLibrary_DoIdleMove, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoIdleMove::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoIdleMove, bCalledFromNotify) == 0x000008, "Member 'LActionUtilFuncLibrary_DoIdleMove::bCalledFromNotify' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoIdleMove, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_DoIdleMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoNPCSuicide
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_DoNPCSuicide final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELNPCSuicideType                              SuicideType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DeadCodeName;                                      // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemGet;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExpGet;                                           // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideRespawnState;                          // 0x0016(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawnEnable;                                    // 0x0017(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDeadSound;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoNPCSuicide) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoNPCSuicide");
static_assert(sizeof(LActionUtilFuncLibrary_DoNPCSuicide) == 0x000020, "Wrong size on LActionUtilFuncLibrary_DoNPCSuicide");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, SuicideType) == 0x000008, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::SuicideType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, DeadCodeName) == 0x00000C, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::DeadCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, bItemGet) == 0x000014, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::bItemGet' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, bExpGet) == 0x000015, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::bExpGet' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, bUseOverrideRespawnState) == 0x000016, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::bUseOverrideRespawnState' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, bRespawnEnable) == 0x000017, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::bRespawnEnable' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoNPCSuicide, bPlayDeadSound) == 0x000018, "Member 'LActionUtilFuncLibrary_DoNPCSuicide::bPlayDeadSound' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoRespawn
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_DoRespawn final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoRespawn) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoRespawn");
static_assert(sizeof(LActionUtilFuncLibrary_DoRespawn) == 0x000010, "Wrong size on LActionUtilFuncLibrary_DoRespawn");
static_assert(offsetof(LActionUtilFuncLibrary_DoRespawn, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoRespawn::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoRespawn, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_DoRespawn::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoWeaponOffBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_DoWeaponOffBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoWeaponOffBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoWeaponOffBP");
static_assert(sizeof(LActionUtilFuncLibrary_DoWeaponOffBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_DoWeaponOffBP");
static_assert(offsetof(LActionUtilFuncLibrary_DoWeaponOffBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoWeaponOffBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoWeaponOffBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_DoWeaponOffBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoWeaponOffBP, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_DoWeaponOffBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.DoWeaponOnBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_DoWeaponOnBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_DoWeaponOnBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_DoWeaponOnBP");
static_assert(sizeof(LActionUtilFuncLibrary_DoWeaponOnBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_DoWeaponOnBP");
static_assert(offsetof(LActionUtilFuncLibrary_DoWeaponOnBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_DoWeaponOnBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoWeaponOnBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_DoWeaponOnBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_DoWeaponOnBP, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_DoWeaponOnBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ExtractMontageBoneTransformBP
// 0x0050 (0x0050 - 0x0000)
struct LActionUtilFuncLibrary_ExtractMontageBoneTransformBP final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExtractRootmotion;                                 // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x001D(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0020(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP) == 0x000010, "Wrong alignment on LActionUtilFuncLibrary_ExtractMontageBoneTransformBP");
static_assert(sizeof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP) == 0x000050, "Wrong size on LActionUtilFuncLibrary_ExtractMontageBoneTransformBP");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, AnimInstance) == 0x000000, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::AnimInstance' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, AnimMontage) == 0x000008, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::AnimMontage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, BoneName) == 0x000010, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::BoneName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, Position) == 0x000018, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::Position' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, ExtractRootmotion) == 0x00001C, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::ExtractRootmotion' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, Branches) == 0x00001D, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractMontageBoneTransformBP, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_ExtractMontageBoneTransformBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ExtractRootMotionFromTrackRangeBP
// 0x0050 (0x0050 - 0x0000)
struct LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosition;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndPosition;                                       // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0020(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP) == 0x000010, "Wrong alignment on LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP");
static_assert(sizeof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP) == 0x000050, "Wrong size on LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP, AnimInstance) == 0x000000, "Member 'LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP::AnimInstance' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP, AnimMontage) == 0x000008, "Member 'LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP::AnimMontage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP, StartPosition) == 0x000010, "Member 'LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP::StartPosition' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP, EndPosition) == 0x000014, "Member 'LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP::EndPosition' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP, Branches) == 0x000018, "Member 'LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindActionKeyInputAction
// 0x0030 (0x0030 - 0x0000)
struct LActionUtilFuncLibrary_FindActionKeyInputAction final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Alt;                                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ctrl;                                              // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Shift;                                             // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cmd;                                               // 0x001B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindActionKeyInputAction) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindActionKeyInputAction");
static_assert(sizeof(LActionUtilFuncLibrary_FindActionKeyInputAction) == 0x000030, "Wrong size on LActionUtilFuncLibrary_FindActionKeyInputAction");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionKeyInputAction, Key) == 0x000000, "Member 'LActionUtilFuncLibrary_FindActionKeyInputAction::Key' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionKeyInputAction, Alt) == 0x000018, "Member 'LActionUtilFuncLibrary_FindActionKeyInputAction::Alt' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionKeyInputAction, Ctrl) == 0x000019, "Member 'LActionUtilFuncLibrary_FindActionKeyInputAction::Ctrl' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionKeyInputAction, Shift) == 0x00001A, "Member 'LActionUtilFuncLibrary_FindActionKeyInputAction::Shift' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionKeyInputAction, Cmd) == 0x00001B, "Member 'LActionUtilFuncLibrary_FindActionKeyInputAction::Cmd' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionKeyInputAction, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_FindActionKeyInputAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindActionState
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindActionState final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_FindActionState) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindActionState");
static_assert(sizeof(LActionUtilFuncLibrary_FindActionState) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindActionState");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionState, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindActionState::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionState, ActionState) == 0x000008, "Member 'LActionUtilFuncLibrary_FindActionState::ActionState' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActionState, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindActionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindActiveFxSocketTracerInfo
// 0x0118 (0x0118 - 0x0000)
struct LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Handle;                                            // 0x0008(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLFxSocketTracerInfo                   ReturnValue;                                       // 0x0010(0x0108)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo");
static_assert(sizeof(LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo) == 0x000118, "Wrong size on LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo");
static_assert(offsetof(LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo, Handle) == 0x000008, "Member 'LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo::Handle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo, Branches) == 0x00000C, "Member 'LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindAxisKeyInputAction
// 0x0030 (0x0030 - 0x0000)
struct LActionUtilFuncLibrary_FindAxisKeyInputAction final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Alt;                                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ctrl;                                              // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Shift;                                             // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cmd;                                               // 0x001B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindAxisKeyInputAction) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindAxisKeyInputAction");
static_assert(sizeof(LActionUtilFuncLibrary_FindAxisKeyInputAction) == 0x000030, "Wrong size on LActionUtilFuncLibrary_FindAxisKeyInputAction");
static_assert(offsetof(LActionUtilFuncLibrary_FindAxisKeyInputAction, Key) == 0x000000, "Member 'LActionUtilFuncLibrary_FindAxisKeyInputAction::Key' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindAxisKeyInputAction, Alt) == 0x000018, "Member 'LActionUtilFuncLibrary_FindAxisKeyInputAction::Alt' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindAxisKeyInputAction, Ctrl) == 0x000019, "Member 'LActionUtilFuncLibrary_FindAxisKeyInputAction::Ctrl' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindAxisKeyInputAction, Shift) == 0x00001A, "Member 'LActionUtilFuncLibrary_FindAxisKeyInputAction::Shift' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindAxisKeyInputAction, Cmd) == 0x00001B, "Member 'LActionUtilFuncLibrary_FindAxisKeyInputAction::Cmd' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindAxisKeyInputAction, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_FindAxisKeyInputAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindEquippedItemSlaveArmInfoBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemSlaveArmInfoPtr                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindFatalAttackTargetBP
// 0x0068 (0x0068 - 0x0000)
struct LActionUtilFuncLibrary_FindFatalAttackTargetBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      OutFatalAttackInfo;                                // 0x0008(0x0054)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x005C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindFatalAttackTargetBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindFatalAttackTargetBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindFatalAttackTargetBP) == 0x000068, "Wrong size on LActionUtilFuncLibrary_FindFatalAttackTargetBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindFatalAttackTargetBP, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_FindFatalAttackTargetBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindFatalAttackTargetBP, OutFatalAttackInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_FindFatalAttackTargetBP::OutFatalAttackInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindFatalAttackTargetBP, Branches) == 0x00005C, "Member 'LActionUtilFuncLibrary_FindFatalAttackTargetBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindFatalAttackTargetBP, ReturnValue) == 0x000060, "Member 'LActionUtilFuncLibrary_FindFatalAttackTargetBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindHandBloodMaterial_ForCurrentBodyBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP final
{
public:
	class UMaterialInstance*                      OutMaterial;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP, OutMaterial) == 0x000000, "Member 'LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP::OutMaterial' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP::Branches' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindHitIndexInfoBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindHitIndexInfoBP final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitIndexInfoPtr                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindHitIndexInfoBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindHitIndexInfoBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindHitIndexInfoBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindHitIndexInfoBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitIndexInfoBP, SkillCodeName) == 0x000000, "Member 'LActionUtilFuncLibrary_FindHitIndexInfoBP::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitIndexInfoBP, HitIndex) == 0x000008, "Member 'LActionUtilFuncLibrary_FindHitIndexInfoBP::HitIndex' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitIndexInfoBP, Branches) == 0x00000C, "Member 'LActionUtilFuncLibrary_FindHitIndexInfoBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitIndexInfoBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindHitIndexInfoBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindHitMotionReplaceInfoBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP final
{
public:
	class FName                                   HitMotionReplaceGroupCodeName;                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionType                               OriginHitMotionType;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitMotionReplaceInfoPtr               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP, HitMotionReplaceGroupCodeName) == 0x000000, "Member 'LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP::HitMotionReplaceGroupCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP, OriginHitMotionType) == 0x000008, "Member 'LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP::OriginHitMotionType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP, Branches) == 0x000009, "Member 'LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindNoneLockOnAutoGuideTarget
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget");
static_assert(sizeof(LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget) == 0x000010, "Wrong size on LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget");
static_assert(offsetof(LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindPartsActor
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindPartsActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartsIndex;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALPartsActor*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindPartsActor) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindPartsActor");
static_assert(sizeof(LActionUtilFuncLibrary_FindPartsActor) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindPartsActor");
static_assert(offsetof(LActionUtilFuncLibrary_FindPartsActor, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindPartsActor::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPartsActor, PartsIndex) == 0x000008, "Member 'LActionUtilFuncLibrary_FindPartsActor::PartsIndex' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPartsActor, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindPartsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindPartsComponent
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindPartsComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartsIndex;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPartsComponent*                       ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindPartsComponent) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindPartsComponent");
static_assert(sizeof(LActionUtilFuncLibrary_FindPartsComponent) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindPartsComponent");
static_assert(offsetof(LActionUtilFuncLibrary_FindPartsComponent, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindPartsComponent::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPartsComponent, PartsIndex) == 0x000008, "Member 'LActionUtilFuncLibrary_FindPartsComponent::PartsIndex' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPartsComponent, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindPartsComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindPixelDepthOffsetData_ForCurrentFaceBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP final
{
public:
	class UTexture*                               OutMask;                                           // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutIntensity;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP, OutMask) == 0x000000, "Member 'LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP::OutMask' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP, OutIntensity) == 0x000008, "Member 'LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP::OutIntensity' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP, Branches) == 0x00000C, "Member 'LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP::Branches' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindPresetInputAction
// 0x0028 (0x0028 - 0x0000)
struct LActionUtilFuncLibrary_FindPresetInputAction final
{
public:
	class FName                                   InPresetName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_FindPresetInputAction) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindPresetInputAction");
static_assert(sizeof(LActionUtilFuncLibrary_FindPresetInputAction) == 0x000028, "Wrong size on LActionUtilFuncLibrary_FindPresetInputAction");
static_assert(offsetof(LActionUtilFuncLibrary_FindPresetInputAction, InPresetName) == 0x000000, "Member 'LActionUtilFuncLibrary_FindPresetInputAction::InPresetName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPresetInputAction, Key) == 0x000008, "Member 'LActionUtilFuncLibrary_FindPresetInputAction::Key' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPresetInputAction, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_FindPresetInputAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindPresetInputActionKey
// 0x0028 (0x0028 - 0x0000)
struct LActionUtilFuncLibrary_FindPresetInputActionKey final
{
public:
	class FName                                   InPresetName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             KeyType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindPresetInputActionKey) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindPresetInputActionKey");
static_assert(sizeof(LActionUtilFuncLibrary_FindPresetInputActionKey) == 0x000028, "Wrong size on LActionUtilFuncLibrary_FindPresetInputActionKey");
static_assert(offsetof(LActionUtilFuncLibrary_FindPresetInputActionKey, InPresetName) == 0x000000, "Member 'LActionUtilFuncLibrary_FindPresetInputActionKey::InPresetName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPresetInputActionKey, KeyType) == 0x000008, "Member 'LActionUtilFuncLibrary_FindPresetInputActionKey::KeyType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindPresetInputActionKey, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_FindPresetInputActionKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindShrinkMesh_ForCurrentBodyBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP final
{
public:
	class ALCharacter*                            TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          OutMesh;                                           // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP");
static_assert(sizeof(LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP");
static_assert(offsetof(LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP, TargetCharacter) == 0x000000, "Member 'LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP::TargetCharacter' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP, OutMesh) == 0x000008, "Member 'LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP::OutMesh' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP, Branches) == 0x000010, "Member 'LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP::Branches' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindSocketOwnerComponent
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_FindSocketOwnerComponent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_FindSocketOwnerComponent) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindSocketOwnerComponent");
static_assert(sizeof(LActionUtilFuncLibrary_FindSocketOwnerComponent) == 0x000020, "Wrong size on LActionUtilFuncLibrary_FindSocketOwnerComponent");
static_assert(offsetof(LActionUtilFuncLibrary_FindSocketOwnerComponent, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindSocketOwnerComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindSocketOwnerComponent, SocketName) == 0x000008, "Member 'LActionUtilFuncLibrary_FindSocketOwnerComponent::SocketName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindSocketOwnerComponent, MeshSelectionType) == 0x000010, "Member 'LActionUtilFuncLibrary_FindSocketOwnerComponent::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindSocketOwnerComponent, ReturnValue) == 0x000018, "Member 'LActionUtilFuncLibrary_FindSocketOwnerComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.FindWeaponDestructDurability
// 0x0028 (0x0028 - 0x0000)
struct LActionUtilFuncLibrary_FindWeaponDestructDurability final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPoint;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLWeaponDestructDurabilityEnable       WeaponDestructDurabilityEnable_0;                  // 0x000C(0x0014)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_FindWeaponDestructDurability) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_FindWeaponDestructDurability");
static_assert(sizeof(LActionUtilFuncLibrary_FindWeaponDestructDurability) == 0x000028, "Wrong size on LActionUtilFuncLibrary_FindWeaponDestructDurability");
static_assert(offsetof(LActionUtilFuncLibrary_FindWeaponDestructDurability, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_FindWeaponDestructDurability::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindWeaponDestructDurability, WeaponAttachPoint) == 0x000008, "Member 'LActionUtilFuncLibrary_FindWeaponDestructDurability::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindWeaponDestructDurability, WeaponDestructDurabilityEnable_0) == 0x00000C, "Member 'LActionUtilFuncLibrary_FindWeaponDestructDurability::WeaponDestructDurabilityEnable_0' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_FindWeaponDestructDurability, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_FindWeaponDestructDurability::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetActionClassCodeNameBySkillHit
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit");
static_assert(sizeof(LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit");
static_assert(offsetof(LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit, Victim) == 0x000000, "Member 'LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit, SkillHitCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetActiveSlaveArmItemBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetActiveSlaveArmItemBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetActiveSlaveArmItemBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetActiveSlaveArmItemBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetActiveSlaveArmItemBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetActiveSlaveArmItemBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveSlaveArmItemBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetActiveSlaveArmItemBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveSlaveArmItemBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetActiveSlaveArmItemBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveSlaveArmItemBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetActiveSlaveArmItemBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetActiveSlaveArmSkillCodeNameBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetActiveUseItemSkillCodeNameBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP final
{
public:
	class ULActPayloadBase*                       InOptionalPayloadItem;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP, InOptionalPayloadItem) == 0x000000, "Member 'LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP::InOptionalPayloadItem' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetActMgrComponent
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetActMgrComponent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActMgrComponent*                      ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetActMgrComponent) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetActMgrComponent");
static_assert(sizeof(LActionUtilFuncLibrary_GetActMgrComponent) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetActMgrComponent");
static_assert(offsetof(LActionUtilFuncLibrary_GetActMgrComponent, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetActMgrComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActMgrComponent, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetActMgrComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetActMgrComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetActMgrComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActMgrComponent*                      ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetActMgrComponentBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetActMgrComponentBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetActMgrComponentBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetActMgrComponentBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetActMgrComponentBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetActMgrComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActMgrComponentBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetActMgrComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetActMgrComponentBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetActMgrComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetAssistUseItemSkillCodeNameBP
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP final
{
public:
	ELAssistUseItemSlotType                       InSlotType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP, InSlotType) == 0x000000, "Member 'LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP::InSlotType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP, Branches) == 0x000001, "Member 'LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP, ReturnValue) == 0x000004, "Member 'LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetBodyWeaponByAttachPoint
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPartsAttachPointType                        AttachPointType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPartsComponent*                       ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint");
static_assert(sizeof(LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint");
static_assert(offsetof(LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint, AttachPointType) == 0x000008, "Member 'LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint::AttachPointType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetBodyWeaponBySkillHit
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetBodyWeaponBySkillHit final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetBodyWeaponBySkillHit) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetBodyWeaponBySkillHit");
static_assert(sizeof(LActionUtilFuncLibrary_GetBodyWeaponBySkillHit) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetBodyWeaponBySkillHit");
static_assert(offsetof(LActionUtilFuncLibrary_GetBodyWeaponBySkillHit, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetBodyWeaponBySkillHit::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetBodyWeaponBySkillHit, SkillHitCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetBodyWeaponBySkillHit::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetBodyWeaponBySkillHit, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetBodyWeaponBySkillHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCommandConsumed
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_GetCommandConsumed final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetCommandConsumed) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_GetCommandConsumed");
static_assert(sizeof(LActionUtilFuncLibrary_GetCommandConsumed) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_GetCommandConsumed");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommandConsumed, Command) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCommandConsumed::Command' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommandConsumed, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCommandConsumed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCommandRaisedTime
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_GetCommandRaisedTime final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetCommandRaisedTime) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_GetCommandRaisedTime");
static_assert(sizeof(LActionUtilFuncLibrary_GetCommandRaisedTime) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_GetCommandRaisedTime");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommandRaisedTime, Command) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCommandRaisedTime::Command' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommandRaisedTime, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCommandRaisedTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCommonAnim
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetCommonAnim final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonCodeName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetCommonAnim) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCommonAnim");
static_assert(sizeof(LActionUtilFuncLibrary_GetCommonAnim) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetCommonAnim");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnim, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCommonAnim::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnim, CommonCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCommonAnim::CommonCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnim, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetCommonAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCommonAnimBP
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetCommonAnimBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonCodeName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetCommonAnimBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCommonAnimBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetCommonAnimBP) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetCommonAnimBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCommonAnimBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimBP, CommonCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCommonAnimBP::CommonCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimBP, Branches) == 0x000010, "Member 'LActionUtilFuncLibrary_GetCommonAnimBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimBP, ReturnValue) == 0x000018, "Member 'LActionUtilFuncLibrary_GetCommonAnimBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCommonAnimExBP
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetCommonAnimExBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonCodeName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOverrideMontageBlendIn;                         // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetCommonAnimExBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCommonAnimExBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetCommonAnimExBP) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetCommonAnimExBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimExBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCommonAnimExBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimExBP, CommonCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCommonAnimExBP::CommonCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimExBP, OutOverrideMontageBlendIn) == 0x000010, "Member 'LActionUtilFuncLibrary_GetCommonAnimExBP::OutOverrideMontageBlendIn' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimExBP, Branches) == 0x000014, "Member 'LActionUtilFuncLibrary_GetCommonAnimExBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCommonAnimExBP, ReturnValue) == 0x000018, "Member 'LActionUtilFuncLibrary_GetCommonAnimExBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCurrentActionCategory
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetCurrentActionCategory final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExceptHitAction;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELActionCategory                              ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetCurrentActionCategory) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCurrentActionCategory");
static_assert(sizeof(LActionUtilFuncLibrary_GetCurrentActionCategory) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetCurrentActionCategory");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentActionCategory, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCurrentActionCategory::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentActionCategory, ExceptHitAction) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCurrentActionCategory::ExceptHitAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentActionCategory, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_GetCurrentActionCategory::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCurrentGrabResultBP
// 0x0048 (0x0048 - 0x0000)
struct LActionUtilFuncLibrary_GetCurrentGrabResultBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGrabResultInfo                       OutGrabResultInfo;                                 // 0x0008(0x0038)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetCurrentGrabResultBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCurrentGrabResultBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetCurrentGrabResultBP) == 0x000048, "Wrong size on LActionUtilFuncLibrary_GetCurrentGrabResultBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentGrabResultBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCurrentGrabResultBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentGrabResultBP, OutGrabResultInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCurrentGrabResultBP::OutGrabResultInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentGrabResultBP, Branches) == 0x000040, "Member 'LActionUtilFuncLibrary_GetCurrentGrabResultBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentGrabResultBP, ReturnValue) == 0x000041, "Member 'LActionUtilFuncLibrary_GetCurrentGrabResultBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCurrentPresetInputAction
// 0x0028 (0x0028 - 0x0000)
struct LActionUtilFuncLibrary_GetCurrentPresetInputAction final
{
public:
	bool                                          IsGamePad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetCurrentPresetInputAction) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCurrentPresetInputAction");
static_assert(sizeof(LActionUtilFuncLibrary_GetCurrentPresetInputAction) == 0x000028, "Wrong size on LActionUtilFuncLibrary_GetCurrentPresetInputAction");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentPresetInputAction, IsGamePad) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCurrentPresetInputAction::IsGamePad' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentPresetInputAction, Key) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCurrentPresetInputAction::Key' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentPresetInputAction, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_GetCurrentPresetInputAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetCurrentPresetInputActionKey
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetCurrentPresetInputActionKey final
{
public:
	bool                                          IsGamePad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             KeyType;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetCurrentPresetInputActionKey) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetCurrentPresetInputActionKey");
static_assert(sizeof(LActionUtilFuncLibrary_GetCurrentPresetInputActionKey) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetCurrentPresetInputActionKey");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentPresetInputActionKey, IsGamePad) == 0x000000, "Member 'LActionUtilFuncLibrary_GetCurrentPresetInputActionKey::IsGamePad' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentPresetInputActionKey, KeyType) == 0x000001, "Member 'LActionUtilFuncLibrary_GetCurrentPresetInputActionKey::KeyType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetCurrentPresetInputActionKey, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetCurrentPresetInputActionKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetDeathInfo
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetDeathInfo final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULReasonForDeathInfo*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetDeathInfo) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetDeathInfo");
static_assert(sizeof(LActionUtilFuncLibrary_GetDeathInfo) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetDeathInfo");
static_assert(offsetof(LActionUtilFuncLibrary_GetDeathInfo, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetDeathInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDeathInfo, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetDeathInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetDebuffResistStat
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_GetDebuffResistStat final
{
public:
	ELAbnormalAbstateClass                        InAbnormalAbstateClass;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetDebuffResistStat) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_GetDebuffResistStat");
static_assert(sizeof(LActionUtilFuncLibrary_GetDebuffResistStat) == 0x000002, "Wrong size on LActionUtilFuncLibrary_GetDebuffResistStat");
static_assert(offsetof(LActionUtilFuncLibrary_GetDebuffResistStat, InAbnormalAbstateClass) == 0x000000, "Member 'LActionUtilFuncLibrary_GetDebuffResistStat::InAbnormalAbstateClass' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDebuffResistStat, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_GetDebuffResistStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetDieAnim
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetDieAnim final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class ULReasonForDeathInfo*             ReasonInfo;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetDieAnim) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetDieAnim");
static_assert(sizeof(LActionUtilFuncLibrary_GetDieAnim) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetDieAnim");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnim, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetDieAnim::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnim, ReasonInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_GetDieAnim::ReasonInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnim, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetDieAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetDieAnimEx
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetDieAnimEx final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class ULReasonForDeathInfo*             ReasonInfo;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOverrideMontageBlendIn;                         // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetDieAnimEx) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetDieAnimEx");
static_assert(sizeof(LActionUtilFuncLibrary_GetDieAnimEx) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetDieAnimEx");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnimEx, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetDieAnimEx::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnimEx, ReasonInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_GetDieAnimEx::ReasonInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnimEx, OutOverrideMontageBlendIn) == 0x000010, "Member 'LActionUtilFuncLibrary_GetDieAnimEx::OutOverrideMontageBlendIn' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetDieAnimEx, ReturnValue) == 0x000018, "Member 'LActionUtilFuncLibrary_GetDieAnimEx::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetElementalStat
// 0x0003 (0x0003 - 0x0000)
struct LActionUtilFuncLibrary_GetElementalStat final
{
public:
	ELElementDamageType                           ElementalType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELDamageBranchType                            ElementalStatType;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetElementalStat) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_GetElementalStat");
static_assert(sizeof(LActionUtilFuncLibrary_GetElementalStat) == 0x000003, "Wrong size on LActionUtilFuncLibrary_GetElementalStat");
static_assert(offsetof(LActionUtilFuncLibrary_GetElementalStat, ElementalType) == 0x000000, "Member 'LActionUtilFuncLibrary_GetElementalStat::ElementalType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetElementalStat, ElementalStatType) == 0x000001, "Member 'LActionUtilFuncLibrary_GetElementalStat::ElementalStatType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetElementalStat, ReturnValue) == 0x000002, "Member 'LActionUtilFuncLibrary_GetElementalStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetEndCommonAnimBP
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetEndCommonAnimBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonCodeName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0014(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetEndCommonAnimBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetEndCommonAnimBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetEndCommonAnimBP) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetEndCommonAnimBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetEndCommonAnimBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetEndCommonAnimBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetEndCommonAnimBP, CommonCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetEndCommonAnimBP::CommonCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetEndCommonAnimBP, Branches) == 0x000010, "Member 'LActionUtilFuncLibrary_GetEndCommonAnimBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetEndCommonAnimBP, ReturnValue) == 0x000014, "Member 'LActionUtilFuncLibrary_GetEndCommonAnimBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetFallingAnim
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetFallingAnim final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetFallingAnim) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetFallingAnim");
static_assert(sizeof(LActionUtilFuncLibrary_GetFallingAnim) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetFallingAnim");
static_assert(offsetof(LActionUtilFuncLibrary_GetFallingAnim, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetFallingAnim::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetFallingAnim, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetFallingAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetFallingAnimEx
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetFallingAnimEx final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOverrideMontageBlendIn;                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetFallingAnimEx) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetFallingAnimEx");
static_assert(sizeof(LActionUtilFuncLibrary_GetFallingAnimEx) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetFallingAnimEx");
static_assert(offsetof(LActionUtilFuncLibrary_GetFallingAnimEx, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetFallingAnimEx::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetFallingAnimEx, OutOverrideMontageBlendIn) == 0x000008, "Member 'LActionUtilFuncLibrary_GetFallingAnimEx::OutOverrideMontageBlendIn' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetFallingAnimEx, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetFallingAnimEx::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetGrabAttackerBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetGrabAttackerBP final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetGrabAttackerBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetGrabAttackerBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetGrabAttackerBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetGrabAttackerBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetGrabAttackerBP, Victim) == 0x000000, "Member 'LActionUtilFuncLibrary_GetGrabAttackerBP::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetGrabAttackerBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetGrabAttackerBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetGrabAttackerBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetGrabAttackerBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetGrabVictimBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetGrabVictimBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetGrabVictimBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetGrabVictimBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetGrabVictimBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetGrabVictimBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetGrabVictimBP, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_GetGrabVictimBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetGrabVictimBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetGrabVictimBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetGrabVictimBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetGrabVictimBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetHairCategoryType
// 0x0001 (0x0001 - 0x0000)
struct LActionUtilFuncLibrary_GetHairCategoryType final
{
public:
	ELHairCategoryType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetHairCategoryType) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_GetHairCategoryType");
static_assert(sizeof(LActionUtilFuncLibrary_GetHairCategoryType) == 0x000001, "Wrong size on LActionUtilFuncLibrary_GetHairCategoryType");
static_assert(offsetof(LActionUtilFuncLibrary_GetHairCategoryType, ReturnValue) == 0x000000, "Member 'LActionUtilFuncLibrary_GetHairCategoryType::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetHitProcComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetHitProcComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitProcComponent*                     ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetHitProcComponentBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetHitProcComponentBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetHitProcComponentBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetHitProcComponentBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetHitProcComponentBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetHitProcComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetHitProcComponentBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetHitProcComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetHitProcComponentBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetHitProcComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetInputKeyForAction
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetInputKeyForAction final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gamepad;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetInputKeyForAction) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetInputKeyForAction");
static_assert(sizeof(LActionUtilFuncLibrary_GetInputKeyForAction) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetInputKeyForAction");
static_assert(offsetof(LActionUtilFuncLibrary_GetInputKeyForAction, InputAction) == 0x000000, "Member 'LActionUtilFuncLibrary_GetInputKeyForAction::InputAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetInputKeyForAction, Gamepad) == 0x000008, "Member 'LActionUtilFuncLibrary_GetInputKeyForAction::Gamepad' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetInputKeyForAction, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetInputKeyForAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetInputKeyForAxis
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_GetInputKeyForAxis final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gamepad;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetInputKeyForAxis) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetInputKeyForAxis");
static_assert(sizeof(LActionUtilFuncLibrary_GetInputKeyForAxis) == 0x000020, "Wrong size on LActionUtilFuncLibrary_GetInputKeyForAxis");
static_assert(offsetof(LActionUtilFuncLibrary_GetInputKeyForAxis, InputAction) == 0x000000, "Member 'LActionUtilFuncLibrary_GetInputKeyForAxis::InputAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetInputKeyForAxis, Gamepad) == 0x000008, "Member 'LActionUtilFuncLibrary_GetInputKeyForAxis::Gamepad' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetInputKeyForAxis, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetInputKeyForAxis::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetLandingAnim
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetLandingAnim final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetLandingAnim) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetLandingAnim");
static_assert(sizeof(LActionUtilFuncLibrary_GetLandingAnim) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetLandingAnim");
static_assert(offsetof(LActionUtilFuncLibrary_GetLandingAnim, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetLandingAnim::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLandingAnim, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetLandingAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetLandingAnimEx
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetLandingAnimEx final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOverrideMontageBlendIn;                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetLandingAnimEx) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetLandingAnimEx");
static_assert(sizeof(LActionUtilFuncLibrary_GetLandingAnimEx) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetLandingAnimEx");
static_assert(offsetof(LActionUtilFuncLibrary_GetLandingAnimEx, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetLandingAnimEx::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLandingAnimEx, OutOverrideMontageBlendIn) == 0x000008, "Member 'LActionUtilFuncLibrary_GetLandingAnimEx::OutOverrideMontageBlendIn' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLandingAnimEx, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetLandingAnimEx::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetLastPlayingAction
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetLastPlayingAction final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExceptHitAction;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetLastPlayingAction) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetLastPlayingAction");
static_assert(sizeof(LActionUtilFuncLibrary_GetLastPlayingAction) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetLastPlayingAction");
static_assert(offsetof(LActionUtilFuncLibrary_GetLastPlayingAction, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetLastPlayingAction::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLastPlayingAction, ExceptHitAction) == 0x000008, "Member 'LActionUtilFuncLibrary_GetLastPlayingAction::ExceptHitAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLastPlayingAction, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetLastPlayingAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetLCharacterMovementComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetLCharacterMovementComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULCharacterMovementComponent*           ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetLCharacterMovementComponentBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetLCharacterMovementComponentBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetLCharacterMovementComponentBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetLCharacterMovementComponentBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetLCharacterMovementComponentBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetLCharacterMovementComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLCharacterMovementComponentBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetLCharacterMovementComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetLCharacterMovementComponentBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetLCharacterMovementComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetMeshSelectionTypeByWeaponAttachType
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType final
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType");
static_assert(sizeof(LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType) == 0x000002, "Wrong size on LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType");
static_assert(offsetof(LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType, WeaponAttachPointType) == 0x000000, "Member 'LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetMontage_CurrentPlayPositionBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP, Branches) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetMontage_CurrentSectionBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetMontage_CurrentSectionBP final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetMontage_CurrentSectionBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetMontage_CurrentSectionBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetMontage_CurrentSectionBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetMontage_CurrentSectionBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentSectionBP, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentSectionBP::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentSectionBP, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentSectionBP::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentSectionBP, Branches) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentSectionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_CurrentSectionBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetMontage_CurrentSectionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetMontage_PlayLengthWithRateScaleBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP, Montage) == 0x000000, "Member 'LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP::Montage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetMontage_PlayRateBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetMontage_PlayRateBP final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetMontage_PlayRateBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetMontage_PlayRateBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetMontage_PlayRateBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetMontage_PlayRateBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_PlayRateBP, Montage) == 0x000000, "Member 'LActionUtilFuncLibrary_GetMontage_PlayRateBP::Montage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_PlayRateBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetMontage_PlayRateBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_PlayRateBP, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetMontage_PlayRateBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetMontage_SectionLength
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetMontage_SectionLength final
{
public:
	class UAnimMontage*                           InMontage;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InSection;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetMontage_SectionLength) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetMontage_SectionLength");
static_assert(sizeof(LActionUtilFuncLibrary_GetMontage_SectionLength) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetMontage_SectionLength");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_SectionLength, InMontage) == 0x000000, "Member 'LActionUtilFuncLibrary_GetMontage_SectionLength::InMontage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_SectionLength, InSection) == 0x000008, "Member 'LActionUtilFuncLibrary_GetMontage_SectionLength::InSection' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetMontage_SectionLength, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetMontage_SectionLength::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetPhysicalAnimationComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPhysicalAnimationComponent*           ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP");
static_assert(sizeof(LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP");
static_assert(offsetof(LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetPhysicalStat
// 0x0003 (0x0003 - 0x0000)
struct LActionUtilFuncLibrary_GetPhysicalStat final
{
public:
	ELPhysicalDamageType                          PhysicalType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELDamageBranchType                            ElementalStatType;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetPhysicalStat) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_GetPhysicalStat");
static_assert(sizeof(LActionUtilFuncLibrary_GetPhysicalStat) == 0x000003, "Wrong size on LActionUtilFuncLibrary_GetPhysicalStat");
static_assert(offsetof(LActionUtilFuncLibrary_GetPhysicalStat, PhysicalType) == 0x000000, "Member 'LActionUtilFuncLibrary_GetPhysicalStat::PhysicalType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetPhysicalStat, ElementalStatType) == 0x000001, "Member 'LActionUtilFuncLibrary_GetPhysicalStat::ElementalStatType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetPhysicalStat, ReturnValue) == 0x000002, "Member 'LActionUtilFuncLibrary_GetPhysicalStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetSkillAnim
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetSkillAnim final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetSkillAnim) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetSkillAnim");
static_assert(sizeof(LActionUtilFuncLibrary_GetSkillAnim) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetSkillAnim");
static_assert(offsetof(LActionUtilFuncLibrary_GetSkillAnim, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetSkillAnim::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetSkillAnim, SkillCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetSkillAnim::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetSkillAnim, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetSkillAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetWeapon
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetWeapon final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetWeapon) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetWeapon");
static_assert(sizeof(LActionUtilFuncLibrary_GetWeapon) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetWeapon");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeapon, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetWeapon::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeapon, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetWeaponAttachPointSocket
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetWeaponAttachPointSocket final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_GetWeaponAttachPointSocket) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetWeaponAttachPointSocket");
static_assert(sizeof(LActionUtilFuncLibrary_GetWeaponAttachPointSocket) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetWeaponAttachPointSocket");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponAttachPointSocket, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetWeaponAttachPointSocket::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponAttachPointSocket, AttachPointType) == 0x000008, "Member 'LActionUtilFuncLibrary_GetWeaponAttachPointSocket::AttachPointType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponAttachPointSocket, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_GetWeaponAttachPointSocket::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetWeaponAttachTypeByMeshSelectionType
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType final
{
public:
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType");
static_assert(sizeof(LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType) == 0x000002, "Wrong size on LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType, MeshSelectionType) == 0x000000, "Member 'LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetWeaponByAttachPoint
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetWeaponByAttachPoint final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetWeaponByAttachPoint) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetWeaponByAttachPoint");
static_assert(sizeof(LActionUtilFuncLibrary_GetWeaponByAttachPoint) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetWeaponByAttachPoint");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponByAttachPoint, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetWeaponByAttachPoint::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponByAttachPoint, AttachPointType) == 0x000008, "Member 'LActionUtilFuncLibrary_GetWeaponByAttachPoint::AttachPointType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponByAttachPoint, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetWeaponByAttachPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetWeaponByItem
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_GetWeaponByItem final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetWeaponByItem) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetWeaponByItem");
static_assert(sizeof(LActionUtilFuncLibrary_GetWeaponByItem) == 0x000010, "Wrong size on LActionUtilFuncLibrary_GetWeaponByItem");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponByItem, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetWeaponByItem::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponByItem, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_GetWeaponByItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.GetWeaponBySkillHit
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_GetWeaponBySkillHit final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_GetWeaponBySkillHit) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_GetWeaponBySkillHit");
static_assert(sizeof(LActionUtilFuncLibrary_GetWeaponBySkillHit) == 0x000018, "Wrong size on LActionUtilFuncLibrary_GetWeaponBySkillHit");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponBySkillHit, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_GetWeaponBySkillHit::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponBySkillHit, SkillHitCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_GetWeaponBySkillHit::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_GetWeaponBySkillHit, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_GetWeaponBySkillHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsAttackAction
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_IsAttackAction final
{
public:
	ELActionCategory                              ActionCategory;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_IsAttackAction) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_IsAttackAction");
static_assert(sizeof(LActionUtilFuncLibrary_IsAttackAction) == 0x000002, "Wrong size on LActionUtilFuncLibrary_IsAttackAction");
static_assert(offsetof(LActionUtilFuncLibrary_IsAttackAction, ActionCategory) == 0x000000, "Member 'LActionUtilFuncLibrary_IsAttackAction::ActionCategory' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsAttackAction, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_IsAttackAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsCommandPressed
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_IsCommandPressed final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_IsCommandPressed) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_IsCommandPressed");
static_assert(sizeof(LActionUtilFuncLibrary_IsCommandPressed) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_IsCommandPressed");
static_assert(offsetof(LActionUtilFuncLibrary_IsCommandPressed, Command) == 0x000000, "Member 'LActionUtilFuncLibrary_IsCommandPressed::Command' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsCommandPressed, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_IsCommandPressed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsCounterAlwaysBP
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_IsCounterAlwaysBP final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_IsCounterAlwaysBP) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_IsCounterAlwaysBP");
static_assert(sizeof(LActionUtilFuncLibrary_IsCounterAlwaysBP) == 0x000002, "Wrong size on LActionUtilFuncLibrary_IsCounterAlwaysBP");
static_assert(offsetof(LActionUtilFuncLibrary_IsCounterAlwaysBP, Branches) == 0x000000, "Member 'LActionUtilFuncLibrary_IsCounterAlwaysBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsCounterAlwaysBP, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_IsCounterAlwaysBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsDashAction
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_IsDashAction final
{
public:
	ELActionCategory                              ActionCategory;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_IsDashAction) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_IsDashAction");
static_assert(sizeof(LActionUtilFuncLibrary_IsDashAction) == 0x000002, "Wrong size on LActionUtilFuncLibrary_IsDashAction");
static_assert(offsetof(LActionUtilFuncLibrary_IsDashAction, ActionCategory) == 0x000000, "Member 'LActionUtilFuncLibrary_IsDashAction::ActionCategory' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsDashAction, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_IsDashAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsFatalHitActionClassName
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_IsFatalHitActionClassName final
{
public:
	class FName                                   ActionClassName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_IsFatalHitActionClassName) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_IsFatalHitActionClassName");
static_assert(sizeof(LActionUtilFuncLibrary_IsFatalHitActionClassName) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_IsFatalHitActionClassName");
static_assert(offsetof(LActionUtilFuncLibrary_IsFatalHitActionClassName, ActionClassName) == 0x000000, "Member 'LActionUtilFuncLibrary_IsFatalHitActionClassName::ActionClassName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsFatalHitActionClassName, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_IsFatalHitActionClassName::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsHitAction
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_IsHitAction final
{
public:
	ELActionCategory                              ActionCategory;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_IsHitAction) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_IsHitAction");
static_assert(sizeof(LActionUtilFuncLibrary_IsHitAction) == 0x000002, "Wrong size on LActionUtilFuncLibrary_IsHitAction");
static_assert(offsetof(LActionUtilFuncLibrary_IsHitAction, ActionCategory) == 0x000000, "Member 'LActionUtilFuncLibrary_IsHitAction::ActionCategory' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsHitAction, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_IsHitAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsInGrabProcessBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_IsInGrabProcessBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_IsInGrabProcessBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_IsInGrabProcessBP");
static_assert(sizeof(LActionUtilFuncLibrary_IsInGrabProcessBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_IsInGrabProcessBP");
static_assert(offsetof(LActionUtilFuncLibrary_IsInGrabProcessBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_IsInGrabProcessBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsInGrabProcessBP, Branches) == 0x000008, "Member 'LActionUtilFuncLibrary_IsInGrabProcessBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsInGrabProcessBP, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_IsInGrabProcessBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsInIdleMoveState
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_IsInIdleMoveState final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_IsInIdleMoveState) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_IsInIdleMoveState");
static_assert(sizeof(LActionUtilFuncLibrary_IsInIdleMoveState) == 0x000010, "Wrong size on LActionUtilFuncLibrary_IsInIdleMoveState");
static_assert(offsetof(LActionUtilFuncLibrary_IsInIdleMoveState, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_IsInIdleMoveState::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsInIdleMoveState, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_IsInIdleMoveState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsLandWalkable
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_IsLandWalkable final
{
public:
	struct FVector                                LandNormal;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_IsLandWalkable) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_IsLandWalkable");
static_assert(sizeof(LActionUtilFuncLibrary_IsLandWalkable) == 0x000010, "Wrong size on LActionUtilFuncLibrary_IsLandWalkable");
static_assert(offsetof(LActionUtilFuncLibrary_IsLandWalkable, LandNormal) == 0x000000, "Member 'LActionUtilFuncLibrary_IsLandWalkable::LandNormal' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsLandWalkable, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_IsLandWalkable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsPlayingSequence
// 0x0001 (0x0001 - 0x0000)
struct LActionUtilFuncLibrary_IsPlayingSequence final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_IsPlayingSequence) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_IsPlayingSequence");
static_assert(sizeof(LActionUtilFuncLibrary_IsPlayingSequence) == 0x000001, "Wrong size on LActionUtilFuncLibrary_IsPlayingSequence");
static_assert(offsetof(LActionUtilFuncLibrary_IsPlayingSequence, ReturnValue) == 0x000000, "Member 'LActionUtilFuncLibrary_IsPlayingSequence::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsSkillHitTypeWeapon
// 0x0002 (0x0002 - 0x0000)
struct LActionUtilFuncLibrary_IsSkillHitTypeWeapon final
{
public:
	ELSkillHitType                                SkillHitType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_IsSkillHitTypeWeapon) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_IsSkillHitTypeWeapon");
static_assert(sizeof(LActionUtilFuncLibrary_IsSkillHitTypeWeapon) == 0x000002, "Wrong size on LActionUtilFuncLibrary_IsSkillHitTypeWeapon");
static_assert(offsetof(LActionUtilFuncLibrary_IsSkillHitTypeWeapon, SkillHitType) == 0x000000, "Member 'LActionUtilFuncLibrary_IsSkillHitTypeWeapon::SkillHitType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsSkillHitTypeWeapon, ReturnValue) == 0x000001, "Member 'LActionUtilFuncLibrary_IsSkillHitTypeWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.IsValidGameObjectHandle
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_IsValidGameObjectHandle final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_IsValidGameObjectHandle) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_IsValidGameObjectHandle");
static_assert(sizeof(LActionUtilFuncLibrary_IsValidGameObjectHandle) == 0x000008, "Wrong size on LActionUtilFuncLibrary_IsValidGameObjectHandle");
static_assert(offsetof(LActionUtilFuncLibrary_IsValidGameObjectHandle, Handle) == 0x000000, "Member 'LActionUtilFuncLibrary_IsValidGameObjectHandle::Handle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_IsValidGameObjectHandle, ReturnValue) == 0x000004, "Member 'LActionUtilFuncLibrary_IsValidGameObjectHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.LaunchHitCollisionDynamic
// 0x0110 (0x0110 - 0x0000)
struct LActionUtilFuncLibrary_LaunchHitCollisionDynamic final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitCollisionInfo                     HitColInfo;                                        // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitContext                           HitContext;                                        // 0x0090(0x0074)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALHitCollisionDynamic*                  ReturnValue;                                       // 0x0108(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_LaunchHitCollisionDynamic) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_LaunchHitCollisionDynamic");
static_assert(sizeof(LActionUtilFuncLibrary_LaunchHitCollisionDynamic) == 0x000110, "Wrong size on LActionUtilFuncLibrary_LaunchHitCollisionDynamic");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamic, Instigator) == 0x000000, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamic::Instigator' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamic, HitColInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamic::HitColInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamic, HitContext) == 0x000090, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamic::HitContext' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamic, ReturnValue) == 0x000108, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamic::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.LaunchHitCollisionDynamicWithGrab
// 0x0178 (0x0178 - 0x0000)
struct LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitCollisionInfo                     HitColInfo;                                        // 0x0008(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitContext                           HitContext;                                        // 0x0090(0x0074)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGrabInfo                             GrabInfo;                                          // 0x0108(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class ALHitCollisionDynamic*                  ReturnValue;                                       // 0x0170(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab");
static_assert(sizeof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab) == 0x000178, "Wrong size on LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab, Instigator) == 0x000000, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab::Instigator' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab, HitColInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab::HitColInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab, HitContext) == 0x000090, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab::HitContext' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab, GrabInfo) == 0x000108, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab::GrabInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab, ReturnValue) == 0x000170, "Member 'LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.LaunchTraceAttack
// 0x0028 (0x0028 - 0x0000)
struct LActionUtilFuncLibrary_LaunchTraceAttack final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSocketTraceType                             SocketTraceType;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBroken;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                LifeOwner;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_LaunchTraceAttack) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_LaunchTraceAttack");
static_assert(sizeof(LActionUtilFuncLibrary_LaunchTraceAttack) == 0x000028, "Wrong size on LActionUtilFuncLibrary_LaunchTraceAttack");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack, SkillHitName) == 0x000008, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack::SkillHitName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack, SocketTraceType) == 0x000010, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack::SocketTraceType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack, IsBroken) == 0x000011, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack::IsBroken' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack, LifeOwner) == 0x000018, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack::LifeOwner' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack, ReturnValue) == 0x000020, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.LaunchTraceAttack_by_NonHitNotify
// 0x0040 (0x0040 - 0x0000)
struct LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               WeaponActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSocketTraceType                             SocketTraceType;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocket;                                  // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocket;                                    // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSphereRadius;                                 // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBroken;                                          // 0x002D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                LifeOwner;                                         // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify");
static_assert(sizeof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify) == 0x000040, "Wrong size on LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, WeaponActor) == 0x000008, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::WeaponActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, SocketTraceType) == 0x000010, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::SocketTraceType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, TraceStartSocket) == 0x000014, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::TraceStartSocket' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, TraceEndSocket) == 0x00001C, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::TraceEndSocket' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, TraceSphereRadius) == 0x000024, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, LifeSpan) == 0x000028, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::LifeSpan' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, PhysicalSurface) == 0x00002C, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, IsBroken) == 0x00002D, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::IsBroken' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, LifeOwner) == 0x000030, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::LifeOwner' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify, ReturnValue) == 0x000038, "Member 'LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.LockPCActions
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_LockPCActions final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowMoveOnly;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_LockPCActions) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_LockPCActions");
static_assert(sizeof(LActionUtilFuncLibrary_LockPCActions) == 0x000010, "Wrong size on LActionUtilFuncLibrary_LockPCActions");
static_assert(offsetof(LActionUtilFuncLibrary_LockPCActions, WorldContextObject) == 0x000000, "Member 'LActionUtilFuncLibrary_LockPCActions::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LockPCActions, AllowMoveOnly) == 0x000008, "Member 'LActionUtilFuncLibrary_LockPCActions::AllowMoveOnly' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_LockPCActions, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_LockPCActions::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.OnStartFatalAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_OnStartFatalAttack final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_OnStartFatalAttack) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_OnStartFatalAttack");
static_assert(sizeof(LActionUtilFuncLibrary_OnStartFatalAttack) == 0x000008, "Wrong size on LActionUtilFuncLibrary_OnStartFatalAttack");
static_assert(offsetof(LActionUtilFuncLibrary_OnStartFatalAttack, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_OnStartFatalAttack::Attacker' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.OnStopFatalAttack
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_OnStopFatalAttack final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_OnStopFatalAttack) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_OnStopFatalAttack");
static_assert(sizeof(LActionUtilFuncLibrary_OnStopFatalAttack) == 0x000008, "Wrong size on LActionUtilFuncLibrary_OnStopFatalAttack");
static_assert(offsetof(LActionUtilFuncLibrary_OnStopFatalAttack, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_OnStopFatalAttack::Attacker' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.OverrideAnimationAssetBP
// 0x0028 (0x0028 - 0x0000)
struct LActionUtilFuncLibrary_OverrideAnimationAssetBP final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimationAsset;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MachineName;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateName;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_OverrideAnimationAssetBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_OverrideAnimationAssetBP");
static_assert(sizeof(LActionUtilFuncLibrary_OverrideAnimationAssetBP) == 0x000028, "Wrong size on LActionUtilFuncLibrary_OverrideAnimationAssetBP");
static_assert(offsetof(LActionUtilFuncLibrary_OverrideAnimationAssetBP, AnimInstance) == 0x000000, "Member 'LActionUtilFuncLibrary_OverrideAnimationAssetBP::AnimInstance' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_OverrideAnimationAssetBP, AnimationAsset) == 0x000008, "Member 'LActionUtilFuncLibrary_OverrideAnimationAssetBP::AnimationAsset' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_OverrideAnimationAssetBP, MachineName) == 0x000010, "Member 'LActionUtilFuncLibrary_OverrideAnimationAssetBP::MachineName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_OverrideAnimationAssetBP, StateName) == 0x000018, "Member 'LActionUtilFuncLibrary_OverrideAnimationAssetBP::StateName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_OverrideAnimationAssetBP, Branches) == 0x000020, "Member 'LActionUtilFuncLibrary_OverrideAnimationAssetBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_OverrideAnimationAssetBP, ReturnValue) == 0x000021, "Member 'LActionUtilFuncLibrary_OverrideAnimationAssetBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PauseMontage
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_PauseMontage final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pause;                                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_PauseMontage) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PauseMontage");
static_assert(sizeof(LActionUtilFuncLibrary_PauseMontage) == 0x000010, "Wrong size on LActionUtilFuncLibrary_PauseMontage");
static_assert(offsetof(LActionUtilFuncLibrary_PauseMontage, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_PauseMontage::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PauseMontage, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_PauseMontage::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PauseMontage, Pause) == 0x00000C, "Member 'LActionUtilFuncLibrary_PauseMontage::Pause' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PauseMontage, ReturnValue) == 0x00000D, "Member 'LActionUtilFuncLibrary_PauseMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlayActionClass
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_PlayActionClass final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionClassCodeName;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActPayloadBase*                       Payload;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_PlayActionClass) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlayActionClass");
static_assert(sizeof(LActionUtilFuncLibrary_PlayActionClass) == 0x000020, "Wrong size on LActionUtilFuncLibrary_PlayActionClass");
static_assert(offsetof(LActionUtilFuncLibrary_PlayActionClass, Target) == 0x000000, "Member 'LActionUtilFuncLibrary_PlayActionClass::Target' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayActionClass, ActionClassCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_PlayActionClass::ActionClassCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayActionClass, Payload) == 0x000010, "Member 'LActionUtilFuncLibrary_PlayActionClass::Payload' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayActionClass, ReturnValue) == 0x000018, "Member 'LActionUtilFuncLibrary_PlayActionClass::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlayAnimAsDynamicMontage
// 0x0040 (0x0040 - 0x0000)
struct LActionUtilFuncLibrary_PlayAnimAsDynamicMontage final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Anim;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSlotNodeName;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           OutMontage;                                        // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeToStartMontageAt;                            // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlayAnimAsDynamicMontage");
static_assert(sizeof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage) == 0x000040, "Wrong size on LActionUtilFuncLibrary_PlayAnimAsDynamicMontage");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, Anim) == 0x000008, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::Anim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, InSlotNodeName) == 0x000010, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::InSlotNodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, OutMontage) == 0x000018, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::OutMontage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, BlendInTime) == 0x000020, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::BlendInTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, BlendOutTime) == 0x000024, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::BlendOutTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, InPlayRate) == 0x000028, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::InPlayRate' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, LoopCount) == 0x00002C, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::LoopCount' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, BlendOutTriggerTime) == 0x000030, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, InTimeToStartMontageAt) == 0x000034, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::InTimeToStartMontageAt' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayAnimAsDynamicMontage, ReturnValue) == 0x000038, "Member 'LActionUtilFuncLibrary_PlayAnimAsDynamicMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlayCommonMontage
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_PlayCommonMontage final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonMontageCodeName;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_PlayCommonMontage) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlayCommonMontage");
static_assert(sizeof(LActionUtilFuncLibrary_PlayCommonMontage) == 0x000018, "Wrong size on LActionUtilFuncLibrary_PlayCommonMontage");
static_assert(offsetof(LActionUtilFuncLibrary_PlayCommonMontage, Target) == 0x000000, "Member 'LActionUtilFuncLibrary_PlayCommonMontage::Target' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayCommonMontage, CommonMontageCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_PlayCommonMontage::CommonMontageCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayCommonMontage, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_PlayCommonMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlayHitActionBP
// 0x0178 (0x0178 - 0x0000)
struct LActionUtilFuncLibrary_PlayHitActionBP final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitActionClassCodeName;                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0018(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0168(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0170(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_PlayHitActionBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlayHitActionBP");
static_assert(sizeof(LActionUtilFuncLibrary_PlayHitActionBP) == 0x000178, "Wrong size on LActionUtilFuncLibrary_PlayHitActionBP");
static_assert(offsetof(LActionUtilFuncLibrary_PlayHitActionBP, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_PlayHitActionBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayHitActionBP, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_PlayHitActionBP::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayHitActionBP, HitActionClassCodeName) == 0x000010, "Member 'LActionUtilFuncLibrary_PlayHitActionBP::HitActionClassCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayHitActionBP, HitInfo) == 0x000018, "Member 'LActionUtilFuncLibrary_PlayHitActionBP::HitInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayHitActionBP, Branches) == 0x000168, "Member 'LActionUtilFuncLibrary_PlayHitActionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayHitActionBP, ReturnValue) == 0x000170, "Member 'LActionUtilFuncLibrary_PlayHitActionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlayLoopAnimAsDynamicMontage
// 0x0050 (0x0050 - 0x0000)
struct LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      StartAnim;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LoopAnim;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      EndAnim;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSlotNodeName;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           OutMontage;                                        // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeToStartMontageAt;                            // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0048(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage");
static_assert(sizeof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage) == 0x000050, "Wrong size on LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, StartAnim) == 0x000008, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::StartAnim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, LoopAnim) == 0x000010, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::LoopAnim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, EndAnim) == 0x000018, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::EndAnim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, InSlotNodeName) == 0x000020, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::InSlotNodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, OutMontage) == 0x000028, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::OutMontage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, BlendInTime) == 0x000030, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::BlendInTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, BlendOutTime) == 0x000034, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::BlendOutTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, InPlayRate) == 0x000038, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::InPlayRate' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, LoopCount) == 0x00003C, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::LoopCount' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, BlendOutTriggerTime) == 0x000040, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, InTimeToStartMontageAt) == 0x000044, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::InTimeToStartMontageAt' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage, ReturnValue) == 0x000048, "Member 'LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlayMontage
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_PlayMontage final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeToStartMontageAt;                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAllMontages;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_PlayMontage) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlayMontage");
static_assert(sizeof(LActionUtilFuncLibrary_PlayMontage) == 0x000020, "Wrong size on LActionUtilFuncLibrary_PlayMontage");
static_assert(offsetof(LActionUtilFuncLibrary_PlayMontage, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_PlayMontage::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayMontage, Montage) == 0x000008, "Member 'LActionUtilFuncLibrary_PlayMontage::Montage' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayMontage, InPlayRate) == 0x000010, "Member 'LActionUtilFuncLibrary_PlayMontage::InPlayRate' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayMontage, InTimeToStartMontageAt) == 0x000014, "Member 'LActionUtilFuncLibrary_PlayMontage::InTimeToStartMontageAt' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayMontage, bStopAllMontages) == 0x000018, "Member 'LActionUtilFuncLibrary_PlayMontage::bStopAllMontages' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlayMontage, ReturnValue) == 0x00001C, "Member 'LActionUtilFuncLibrary_PlayMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlaySkillActionBP
// 0x0050 (0x0050 - 0x0000)
struct LActionUtilFuncLibrary_PlaySkillActionBP final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAction_StartRotationInfo             StartRotationInfo;                                 // 0x0010(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class ULActPayloadBase*                       Payload;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_PlaySkillActionBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlaySkillActionBP");
static_assert(sizeof(LActionUtilFuncLibrary_PlaySkillActionBP) == 0x000050, "Wrong size on LActionUtilFuncLibrary_PlaySkillActionBP");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySkillActionBP, Target) == 0x000000, "Member 'LActionUtilFuncLibrary_PlaySkillActionBP::Target' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySkillActionBP, SkillCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_PlaySkillActionBP::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySkillActionBP, StartRotationInfo) == 0x000010, "Member 'LActionUtilFuncLibrary_PlaySkillActionBP::StartRotationInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySkillActionBP, Payload) == 0x000038, "Member 'LActionUtilFuncLibrary_PlaySkillActionBP::Payload' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySkillActionBP, Branches) == 0x000040, "Member 'LActionUtilFuncLibrary_PlaySkillActionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySkillActionBP, ReturnValue) == 0x000048, "Member 'LActionUtilFuncLibrary_PlaySkillActionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PlaySocketTracerFx
// 0x01A0 (0x01A0 - 0x0000)
struct LActionUtilFuncLibrary_PlaySocketTracerFx final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFxSocketTracerInfo                   FxSocketTracerInfo;                                // 0x0008(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0110(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bPlayFx;                                           // 0x0198(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySound;                                        // 0x0199(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A[0x6];                                      // 0x019A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_PlaySocketTracerFx) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PlaySocketTracerFx");
static_assert(sizeof(LActionUtilFuncLibrary_PlaySocketTracerFx) == 0x0001A0, "Wrong size on LActionUtilFuncLibrary_PlaySocketTracerFx");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySocketTracerFx, OwnerActor) == 0x000000, "Member 'LActionUtilFuncLibrary_PlaySocketTracerFx::OwnerActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySocketTracerFx, FxSocketTracerInfo) == 0x000008, "Member 'LActionUtilFuncLibrary_PlaySocketTracerFx::FxSocketTracerInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySocketTracerFx, HitResult) == 0x000110, "Member 'LActionUtilFuncLibrary_PlaySocketTracerFx::HitResult' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySocketTracerFx, bPlayFx) == 0x000198, "Member 'LActionUtilFuncLibrary_PlaySocketTracerFx::bPlayFx' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PlaySocketTracerFx, bPlaySound) == 0x000199, "Member 'LActionUtilFuncLibrary_PlaySocketTracerFx::bPlaySound' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ProcessHit
// 0x01F8 (0x01F8 - 0x0000)
struct LActionUtilFuncLibrary_ProcessHit final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0098(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class ULHitColMgrComponent*                   LHitColMgrComponent;                               // 0x01E8(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01F0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_ProcessHit) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_ProcessHit");
static_assert(sizeof(LActionUtilFuncLibrary_ProcessHit) == 0x0001F8, "Wrong size on LActionUtilFuncLibrary_ProcessHit");
static_assert(offsetof(LActionUtilFuncLibrary_ProcessHit, Attacker) == 0x000000, "Member 'LActionUtilFuncLibrary_ProcessHit::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ProcessHit, Victim) == 0x000008, "Member 'LActionUtilFuncLibrary_ProcessHit::Victim' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ProcessHit, HitResult) == 0x000010, "Member 'LActionUtilFuncLibrary_ProcessHit::HitResult' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ProcessHit, HitInfo) == 0x000098, "Member 'LActionUtilFuncLibrary_ProcessHit::HitInfo' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ProcessHit, LHitColMgrComponent) == 0x0001E8, "Member 'LActionUtilFuncLibrary_ProcessHit::LHitColMgrComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_ProcessHit, ReturnValue) == 0x0001F0, "Member 'LActionUtilFuncLibrary_ProcessHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.PutOnBuff
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_PutOnBuff final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuffCodeName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InInstigator;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_PutOnBuff) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_PutOnBuff");
static_assert(sizeof(LActionUtilFuncLibrary_PutOnBuff) == 0x000018, "Wrong size on LActionUtilFuncLibrary_PutOnBuff");
static_assert(offsetof(LActionUtilFuncLibrary_PutOnBuff, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_PutOnBuff::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PutOnBuff, BuffCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_PutOnBuff::BuffCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_PutOnBuff, InInstigator) == 0x000010, "Member 'LActionUtilFuncLibrary_PutOnBuff::InInstigator' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.RecordDieCauseHitDirectionBP
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Attacker;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP");
static_assert(sizeof(LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP) == 0x000018, "Wrong size on LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP");
static_assert(offsetof(LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP, Attacker) == 0x000008, "Member 'LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP::Attacker' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP, Branches) == 0x000010, "Member 'LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP, ReturnValue) == 0x000011, "Member 'LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.RecreateClothingActors
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_RecreateClothingActors final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_RecreateClothingActors) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_RecreateClothingActors");
static_assert(sizeof(LActionUtilFuncLibrary_RecreateClothingActors) == 0x000010, "Wrong size on LActionUtilFuncLibrary_RecreateClothingActors");
static_assert(offsetof(LActionUtilFuncLibrary_RecreateClothingActors, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_RecreateClothingActors::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RecreateClothingActors, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_RecreateClothingActors::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.RemoveInputActionKeyMapping
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_RemoveInputActionKeyMapping final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGamePad;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_RemoveInputActionKeyMapping) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_RemoveInputActionKeyMapping");
static_assert(sizeof(LActionUtilFuncLibrary_RemoveInputActionKeyMapping) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_RemoveInputActionKeyMapping");
static_assert(offsetof(LActionUtilFuncLibrary_RemoveInputActionKeyMapping, InputAction) == 0x000000, "Member 'LActionUtilFuncLibrary_RemoveInputActionKeyMapping::InputAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RemoveInputActionKeyMapping, IsGamePad) == 0x000008, "Member 'LActionUtilFuncLibrary_RemoveInputActionKeyMapping::IsGamePad' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RemoveInputActionKeyMapping, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_RemoveInputActionKeyMapping::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.RemoveInputAxisKeyMapping
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_RemoveInputAxisKeyMapping final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGamePad;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_RemoveInputAxisKeyMapping) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_RemoveInputAxisKeyMapping");
static_assert(sizeof(LActionUtilFuncLibrary_RemoveInputAxisKeyMapping) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_RemoveInputAxisKeyMapping");
static_assert(offsetof(LActionUtilFuncLibrary_RemoveInputAxisKeyMapping, InputAction) == 0x000000, "Member 'LActionUtilFuncLibrary_RemoveInputAxisKeyMapping::InputAction' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RemoveInputAxisKeyMapping, IsGamePad) == 0x000008, "Member 'LActionUtilFuncLibrary_RemoveInputAxisKeyMapping::IsGamePad' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_RemoveInputAxisKeyMapping, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_RemoveInputAxisKeyMapping::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.ResetInputKeyMapping
// 0x0001 (0x0001 - 0x0000)
struct LActionUtilFuncLibrary_ResetInputKeyMapping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_ResetInputKeyMapping) == 0x000001, "Wrong alignment on LActionUtilFuncLibrary_ResetInputKeyMapping");
static_assert(sizeof(LActionUtilFuncLibrary_ResetInputKeyMapping) == 0x000001, "Wrong size on LActionUtilFuncLibrary_ResetInputKeyMapping");
static_assert(offsetof(LActionUtilFuncLibrary_ResetInputKeyMapping, ReturnValue) == 0x000000, "Member 'LActionUtilFuncLibrary_ResetInputKeyMapping::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SelectCommonActionMontageCodeNameByHitMotionBP
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionType                               HitMotionType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionDirectionType                      HitMotionDirectionType;                            // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TryExcludeCodeName;                                // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP");
static_assert(sizeof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP) == 0x000020, "Wrong size on LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP");
static_assert(offsetof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP, HitMotionType) == 0x000008, "Member 'LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP::HitMotionType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP, HitMotionDirectionType) == 0x000009, "Member 'LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP::HitMotionDirectionType' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP, TryExcludeCodeName) == 0x00000C, "Member 'LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP::TryExcludeCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP, Branches) == 0x000014, "Member 'LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP, ReturnValue) == 0x000018, "Member 'LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetAllPhysicsAngularVelocityInRadians
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewVel;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians");
static_assert(sizeof(LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians) == 0x000018, "Wrong size on LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians");
static_assert(offsetof(LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians, SkeletalMeshComponent) == 0x000000, "Member 'LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians, NewVel) == 0x000008, "Member 'LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians::NewVel' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians, bAddToCurrent) == 0x000014, "Member 'LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians::bAddToCurrent' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetAllPhysicsLinearVelocity
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewVel;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity");
static_assert(sizeof(LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity) == 0x000018, "Wrong size on LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity");
static_assert(offsetof(LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity, SkeletalMeshComponent) == 0x000000, "Member 'LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity, NewVel) == 0x000008, "Member 'LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity::NewVel' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity, bAddToCurrent) == 0x000014, "Member 'LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity::bAddToCurrent' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetAxisValueUpperLimit
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetAxisValueUpperLimit final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limit;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetAxisValueUpperLimit) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetAxisValueUpperLimit");
static_assert(sizeof(LActionUtilFuncLibrary_SetAxisValueUpperLimit) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetAxisValueUpperLimit");
static_assert(offsetof(LActionUtilFuncLibrary_SetAxisValueUpperLimit, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SetAxisValueUpperLimit::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetAxisValueUpperLimit, Limit) == 0x000008, "Member 'LActionUtilFuncLibrary_SetAxisValueUpperLimit::Limit' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetAxisValueUpperLimit, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_SetAxisValueUpperLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetCommandConsumed
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_SetCommandConsumed final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Consumed;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetCommandConsumed) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_SetCommandConsumed");
static_assert(sizeof(LActionUtilFuncLibrary_SetCommandConsumed) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_SetCommandConsumed");
static_assert(offsetof(LActionUtilFuncLibrary_SetCommandConsumed, Command) == 0x000000, "Member 'LActionUtilFuncLibrary_SetCommandConsumed::Command' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetCommandConsumed, Consumed) == 0x000008, "Member 'LActionUtilFuncLibrary_SetCommandConsumed::Consumed' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetFullBodyWhenMoveStopped
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped");
static_assert(sizeof(LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped");
static_assert(offsetof(LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped, bEnable) == 0x000008, "Member 'LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped::bEnable' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetMainAnimFSMState
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetMainAnimFSMState final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAnimFSMState                                MainAnimFSMState;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetMainAnimFSMState) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetMainAnimFSMState");
static_assert(sizeof(LActionUtilFuncLibrary_SetMainAnimFSMState) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetMainAnimFSMState");
static_assert(offsetof(LActionUtilFuncLibrary_SetMainAnimFSMState, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SetMainAnimFSMState::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMainAnimFSMState, MainAnimFSMState) == 0x000008, "Member 'LActionUtilFuncLibrary_SetMainAnimFSMState::MainAnimFSMState' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMainAnimFSMState, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_SetMainAnimFSMState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetMontage_AutoBlendOut
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetMontage_AutoBlendOut final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAutoBlendOut;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetMontage_AutoBlendOut) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetMontage_AutoBlendOut");
static_assert(sizeof(LActionUtilFuncLibrary_SetMontage_AutoBlendOut) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetMontage_AutoBlendOut");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_AutoBlendOut, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_SetMontage_AutoBlendOut::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_AutoBlendOut, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_SetMontage_AutoBlendOut::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_AutoBlendOut, UseAutoBlendOut) == 0x00000C, "Member 'LActionUtilFuncLibrary_SetMontage_AutoBlendOut::UseAutoBlendOut' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_AutoBlendOut, ReturnValue) == 0x00000D, "Member 'LActionUtilFuncLibrary_SetMontage_AutoBlendOut::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000E(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP");
static_assert(sizeof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP, Value) == 0x00000C, "Member 'LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP::Value' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP, Branches) == 0x00000D, "Member 'LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP::Branches' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP, ReturnValue) == 0x00000E, "Member 'LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetMontage_NextSection
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_SetMontage_NextSection final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionNameToChange;                               // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSection;                                       // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetMontage_NextSection) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetMontage_NextSection");
static_assert(sizeof(LActionUtilFuncLibrary_SetMontage_NextSection) == 0x000020, "Wrong size on LActionUtilFuncLibrary_SetMontage_NextSection");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_NextSection, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_SetMontage_NextSection::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_NextSection, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_SetMontage_NextSection::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_NextSection, SectionNameToChange) == 0x00000C, "Member 'LActionUtilFuncLibrary_SetMontage_NextSection::SectionNameToChange' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_NextSection, NextSection) == 0x000014, "Member 'LActionUtilFuncLibrary_SetMontage_NextSection::NextSection' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMontage_NextSection, ReturnValue) == 0x00001C, "Member 'LActionUtilFuncLibrary_SetMontage_NextSection::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetMoveIgnoreMask_Monster
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster final
{
public:
	class ACharacter*                             TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster");
static_assert(sizeof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster");
static_assert(offsetof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster, TargetCharacter) == 0x000000, "Member 'LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster::TargetCharacter' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster, Ignore) == 0x000008, "Member 'LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster::Ignore' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetMoveIgnoreMask_Movement_Related
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related final
{
public:
	class ACharacter*                             TargetCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related");
static_assert(sizeof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related");
static_assert(offsetof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related, TargetCharacter) == 0x000000, "Member 'LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related::TargetCharacter' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related, Ignore) == 0x000008, "Member 'LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related::Ignore' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetNoSkeletonUpdate
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetNoSkeletonUpdate final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnOff;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetNoSkeletonUpdate) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetNoSkeletonUpdate");
static_assert(sizeof(LActionUtilFuncLibrary_SetNoSkeletonUpdate) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetNoSkeletonUpdate");
static_assert(offsetof(LActionUtilFuncLibrary_SetNoSkeletonUpdate, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SetNoSkeletonUpdate::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetNoSkeletonUpdate, TurnOff) == 0x000008, "Member 'LActionUtilFuncLibrary_SetNoSkeletonUpdate::TurnOff' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetNoSkeletonUpdate, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_SetNoSkeletonUpdate::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetPerBoneMotionBlur
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetPerBoneMotionBlur final
{
public:
	class USkinnedMeshComponent*                  SkinnedMeshComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnOn;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetPerBoneMotionBlur) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetPerBoneMotionBlur");
static_assert(sizeof(LActionUtilFuncLibrary_SetPerBoneMotionBlur) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetPerBoneMotionBlur");
static_assert(offsetof(LActionUtilFuncLibrary_SetPerBoneMotionBlur, SkinnedMeshComponent) == 0x000000, "Member 'LActionUtilFuncLibrary_SetPerBoneMotionBlur::SkinnedMeshComponent' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetPerBoneMotionBlur, TurnOn) == 0x000008, "Member 'LActionUtilFuncLibrary_SetPerBoneMotionBlur::TurnOn' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetPerBoneMotionBlur, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_SetPerBoneMotionBlur::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetStaminaSprintStatus
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetStaminaSprintStatus final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Status;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetStaminaSprintStatus) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetStaminaSprintStatus");
static_assert(sizeof(LActionUtilFuncLibrary_SetStaminaSprintStatus) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetStaminaSprintStatus");
static_assert(offsetof(LActionUtilFuncLibrary_SetStaminaSprintStatus, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SetStaminaSprintStatus::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetStaminaSprintStatus, Status) == 0x000008, "Member 'LActionUtilFuncLibrary_SetStaminaSprintStatus::Status' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SetUpdateOverlapsOnAnimationFinalize
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOverlap;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize");
static_assert(sizeof(LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize");
static_assert(offsetof(LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize, bUpdateOverlap) == 0x000008, "Member 'LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize::bUpdateOverlap' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SpawnDynamicDamageVolumeActor
// 0x0050 (0x0050 - 0x0000)
struct LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DynamicDamageVolumeCodeName;                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ALDynamicDamageVolumeActor*             ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor) == 0x000010, "Wrong alignment on LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor");
static_assert(sizeof(LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor) == 0x000050, "Wrong size on LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor");
static_assert(offsetof(LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor, Instigator) == 0x000000, "Member 'LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor::Instigator' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor, DynamicDamageVolumeCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor::DynamicDamageVolumeCodeName' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor, SpawnTransform) == 0x000010, "Member 'LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor, ReturnValue) == 0x000040, "Member 'LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.StartHide
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_StartHide final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDissolveEffect;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_StartHide) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_StartHide");
static_assert(sizeof(LActionUtilFuncLibrary_StartHide) == 0x000010, "Wrong size on LActionUtilFuncLibrary_StartHide");
static_assert(offsetof(LActionUtilFuncLibrary_StartHide, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_StartHide::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_StartHide, bUseDissolveEffect) == 0x000008, "Member 'LActionUtilFuncLibrary_StartHide::bUseDissolveEffect' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.StopHide
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_StopHide final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDissolveEffect;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_StopHide) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_StopHide");
static_assert(sizeof(LActionUtilFuncLibrary_StopHide) == 0x000010, "Wrong size on LActionUtilFuncLibrary_StopHide");
static_assert(offsetof(LActionUtilFuncLibrary_StopHide, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_StopHide::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_StopHide, bUseDissolveEffect) == 0x000008, "Member 'LActionUtilFuncLibrary_StopHide::bUseDissolveEffect' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.StopMontage
// 0x0018 (0x0018 - 0x0000)
struct LActionUtilFuncLibrary_StopMontage final
{
public:
	class UAnimInstance*                          AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MontageInstanceID;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_StopMontage) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_StopMontage");
static_assert(sizeof(LActionUtilFuncLibrary_StopMontage) == 0x000018, "Wrong size on LActionUtilFuncLibrary_StopMontage");
static_assert(offsetof(LActionUtilFuncLibrary_StopMontage, AnimInst) == 0x000000, "Member 'LActionUtilFuncLibrary_StopMontage::AnimInst' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_StopMontage, MontageInstanceID) == 0x000008, "Member 'LActionUtilFuncLibrary_StopMontage::MontageInstanceID' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_StopMontage, BlendOutTime) == 0x00000C, "Member 'LActionUtilFuncLibrary_StopMontage::BlendOutTime' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_StopMontage, ReturnValue) == 0x000010, "Member 'LActionUtilFuncLibrary_StopMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SwitchAngleToType
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SwitchAngleToType final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAngleRangeType                              ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SwitchAngleToType) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SwitchAngleToType");
static_assert(sizeof(LActionUtilFuncLibrary_SwitchAngleToType) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SwitchAngleToType");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SwitchAngleToType::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType, Angle) == 0x000008, "Member 'LActionUtilFuncLibrary_SwitchAngleToType::Angle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_SwitchAngleToType::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SwitchAngleToType_2Way
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SwitchAngleToType_2Way final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAngleRangeType_2Way                         ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SwitchAngleToType_2Way) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SwitchAngleToType_2Way");
static_assert(sizeof(LActionUtilFuncLibrary_SwitchAngleToType_2Way) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SwitchAngleToType_2Way");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType_2Way, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SwitchAngleToType_2Way::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType_2Way, Angle) == 0x000008, "Member 'LActionUtilFuncLibrary_SwitchAngleToType_2Way::Angle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType_2Way, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_SwitchAngleToType_2Way::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.SwitchAngleToType_4Way
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_SwitchAngleToType_4Way final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAngleRangeType_4Way                         ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_SwitchAngleToType_4Way) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_SwitchAngleToType_4Way");
static_assert(sizeof(LActionUtilFuncLibrary_SwitchAngleToType_4Way) == 0x000010, "Wrong size on LActionUtilFuncLibrary_SwitchAngleToType_4Way");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType_4Way, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_SwitchAngleToType_4Way::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType_4Way, Angle) == 0x000008, "Member 'LActionUtilFuncLibrary_SwitchAngleToType_4Way::Angle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_SwitchAngleToType_4Way, ReturnValue) == 0x00000C, "Member 'LActionUtilFuncLibrary_SwitchAngleToType_4Way::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.TakeOffBuff
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_TakeOffBuff final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuffCodeName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_TakeOffBuff) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_TakeOffBuff");
static_assert(sizeof(LActionUtilFuncLibrary_TakeOffBuff) == 0x000010, "Wrong size on LActionUtilFuncLibrary_TakeOffBuff");
static_assert(offsetof(LActionUtilFuncLibrary_TakeOffBuff, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_TakeOffBuff::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_TakeOffBuff, BuffCodeName) == 0x000008, "Member 'LActionUtilFuncLibrary_TakeOffBuff::BuffCodeName' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.Test_ContentCommand
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_Test_ContentCommand final
{
public:
	class FName                                   CommandCodeName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_Test_ContentCommand) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_Test_ContentCommand");
static_assert(sizeof(LActionUtilFuncLibrary_Test_ContentCommand) == 0x000008, "Wrong size on LActionUtilFuncLibrary_Test_ContentCommand");
static_assert(offsetof(LActionUtilFuncLibrary_Test_ContentCommand, CommandCodeName) == 0x000000, "Member 'LActionUtilFuncLibrary_Test_ContentCommand::CommandCodeName' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.Test_DeadCharacter
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_Test_DeadCharacter final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_Test_DeadCharacter) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_Test_DeadCharacter");
static_assert(sizeof(LActionUtilFuncLibrary_Test_DeadCharacter) == 0x000008, "Wrong size on LActionUtilFuncLibrary_Test_DeadCharacter");
static_assert(offsetof(LActionUtilFuncLibrary_Test_DeadCharacter, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_Test_DeadCharacter::TargetActor' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.Test_ForceToggleCommmand
// 0x000C (0x000C - 0x0000)
struct LActionUtilFuncLibrary_Test_ForceToggleCommmand final
{
public:
	class FName                                   ToggleCommand;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnOn;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_Test_ForceToggleCommmand) == 0x000004, "Wrong alignment on LActionUtilFuncLibrary_Test_ForceToggleCommmand");
static_assert(sizeof(LActionUtilFuncLibrary_Test_ForceToggleCommmand) == 0x00000C, "Wrong size on LActionUtilFuncLibrary_Test_ForceToggleCommmand");
static_assert(offsetof(LActionUtilFuncLibrary_Test_ForceToggleCommmand, ToggleCommand) == 0x000000, "Member 'LActionUtilFuncLibrary_Test_ForceToggleCommmand::ToggleCommand' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_Test_ForceToggleCommmand, TurnOn) == 0x000008, "Member 'LActionUtilFuncLibrary_Test_ForceToggleCommmand::TurnOn' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.UndoLastChangeCharBlockType
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_UndoLastChangeCharBlockType final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UndoToOrigin;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_UndoLastChangeCharBlockType) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_UndoLastChangeCharBlockType");
static_assert(sizeof(LActionUtilFuncLibrary_UndoLastChangeCharBlockType) == 0x000010, "Wrong size on LActionUtilFuncLibrary_UndoLastChangeCharBlockType");
static_assert(offsetof(LActionUtilFuncLibrary_UndoLastChangeCharBlockType, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_UndoLastChangeCharBlockType::TargetActor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_UndoLastChangeCharBlockType, UndoToOrigin) == 0x000008, "Member 'LActionUtilFuncLibrary_UndoLastChangeCharBlockType::UndoToOrigin' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_UndoLastChangeCharBlockType, ReturnValue) == 0x000009, "Member 'LActionUtilFuncLibrary_UndoLastChangeCharBlockType::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.UnlockPCActions
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_UnlockPCActions final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_UnlockPCActions) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_UnlockPCActions");
static_assert(sizeof(LActionUtilFuncLibrary_UnlockPCActions) == 0x000010, "Wrong size on LActionUtilFuncLibrary_UnlockPCActions");
static_assert(offsetof(LActionUtilFuncLibrary_UnlockPCActions, WorldContextObject) == 0x000000, "Member 'LActionUtilFuncLibrary_UnlockPCActions::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_UnlockPCActions, ReturnValue) == 0x000008, "Member 'LActionUtilFuncLibrary_UnlockPCActions::ReturnValue' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.UpdateWeaponOnOffByBareHand
// 0x0008 (0x0008 - 0x0000)
struct LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand");
static_assert(sizeof(LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand) == 0x000008, "Wrong size on LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand");
static_assert(offsetof(LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand, TargetActor) == 0x000000, "Member 'LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand::TargetActor' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.WeaponDestructDurabilityDisable
// 0x0010 (0x0010 - 0x0000)
struct LActionUtilFuncLibrary_WeaponDestructDurabilityDisable final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPoint;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsageGuard;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_WeaponDestructDurabilityDisable) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_WeaponDestructDurabilityDisable");
static_assert(sizeof(LActionUtilFuncLibrary_WeaponDestructDurabilityDisable) == 0x000010, "Wrong size on LActionUtilFuncLibrary_WeaponDestructDurabilityDisable");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityDisable, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityDisable::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityDisable, WeaponAttachPoint) == 0x000008, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityDisable::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityDisable, bUsageGuard) == 0x000009, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityDisable::bUsageGuard' has a wrong offset!");

// Function ProjectP.LActionUtilFuncLibrary.WeaponDestructDurabilityEnable
// 0x0020 (0x0020 - 0x0000)
struct LActionUtilFuncLibrary_WeaponDestructDurabilityEnable final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttackPoint;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartAngle;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAngle;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsageGuard;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable) == 0x000008, "Wrong alignment on LActionUtilFuncLibrary_WeaponDestructDurabilityEnable");
static_assert(sizeof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable) == 0x000020, "Wrong size on LActionUtilFuncLibrary_WeaponDestructDurabilityEnable");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable, Actor) == 0x000000, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityEnable::Actor' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable, WeaponAttackPoint) == 0x000008, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityEnable::WeaponAttackPoint' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable, StartAngle) == 0x00000C, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityEnable::StartAngle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable, EndAngle) == 0x000010, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityEnable::EndAngle' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable, Distance) == 0x000014, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityEnable::Distance' has a wrong offset!");
static_assert(offsetof(LActionUtilFuncLibrary_WeaponDestructDurabilityEnable, bUsageGuard) == 0x000018, "Member 'LActionUtilFuncLibrary_WeaponDestructDurabilityEnable::bUsageGuard' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddActionState
// 0x0040 (0x0040 - 0x0000)
struct LActMgrComponent_AddActionState final
{
public:
	class FName                                   State;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePair;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              OwnerAction;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELImmuneSourceType                            ImmuneSourceType;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugInfo;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AddActionState) == 0x000008, "Wrong alignment on LActMgrComponent_AddActionState");
static_assert(sizeof(LActMgrComponent_AddActionState) == 0x000040, "Wrong size on LActMgrComponent_AddActionState");
static_assert(offsetof(LActMgrComponent_AddActionState, State) == 0x000000, "Member 'LActMgrComponent_AddActionState::State' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState, UsePair) == 0x000008, "Member 'LActMgrComponent_AddActionState::UsePair' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState, Instigator) == 0x000010, "Member 'LActMgrComponent_AddActionState::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState, OwnerAction) == 0x000018, "Member 'LActMgrComponent_AddActionState::OwnerAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState, ImmuneSourceType) == 0x000020, "Member 'LActMgrComponent_AddActionState::ImmuneSourceType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState, DebugInfo) == 0x000028, "Member 'LActMgrComponent_AddActionState::DebugInfo' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState, ReturnValue) == 0x000038, "Member 'LActMgrComponent_AddActionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddActionState_AutoRemove
// 0x0040 (0x0040 - 0x0000)
struct LActMgrComponent_AddActionState_AutoRemove final
{
public:
	float                                         LifeSpan;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   State;                                             // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePair;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              OwnerAction;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELImmuneSourceType                            ImmuneSourceType;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExpirationTime;                                    // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DebugInfo;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AddActionState_AutoRemove) == 0x000008, "Wrong alignment on LActMgrComponent_AddActionState_AutoRemove");
static_assert(sizeof(LActMgrComponent_AddActionState_AutoRemove) == 0x000040, "Wrong size on LActMgrComponent_AddActionState_AutoRemove");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, LifeSpan) == 0x000000, "Member 'LActMgrComponent_AddActionState_AutoRemove::LifeSpan' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, State) == 0x000004, "Member 'LActMgrComponent_AddActionState_AutoRemove::State' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, UsePair) == 0x00000C, "Member 'LActMgrComponent_AddActionState_AutoRemove::UsePair' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, Instigator) == 0x000010, "Member 'LActMgrComponent_AddActionState_AutoRemove::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, OwnerAction) == 0x000018, "Member 'LActMgrComponent_AddActionState_AutoRemove::OwnerAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, ImmuneSourceType) == 0x000020, "Member 'LActMgrComponent_AddActionState_AutoRemove::ImmuneSourceType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, ExpirationTime) == 0x000024, "Member 'LActMgrComponent_AddActionState_AutoRemove::ExpirationTime' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, DebugInfo) == 0x000028, "Member 'LActMgrComponent_AddActionState_AutoRemove::DebugInfo' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionState_AutoRemove, ReturnValue) == 0x000038, "Member 'LActMgrComponent_AddActionState_AutoRemove::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddActionStateArray
// 0x0048 (0x0048 - 0x0000)
struct LActMgrComponent_AddActionStateArray final
{
public:
	TArray<class FName>                           StateArray;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UsePair;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              OwnerAction;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELImmuneSourceType                            ImmuneSourceType;                                  // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugInfo;                                         // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AddActionStateArray) == 0x000008, "Wrong alignment on LActMgrComponent_AddActionStateArray");
static_assert(sizeof(LActMgrComponent_AddActionStateArray) == 0x000048, "Wrong size on LActMgrComponent_AddActionStateArray");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, StateArray) == 0x000000, "Member 'LActMgrComponent_AddActionStateArray::StateArray' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, UsePair) == 0x000010, "Member 'LActMgrComponent_AddActionStateArray::UsePair' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, Instigator) == 0x000018, "Member 'LActMgrComponent_AddActionStateArray::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, OwnerAction) == 0x000020, "Member 'LActMgrComponent_AddActionStateArray::OwnerAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, ImmuneSourceType) == 0x000028, "Member 'LActMgrComponent_AddActionStateArray::ImmuneSourceType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, DebugInfo) == 0x000030, "Member 'LActMgrComponent_AddActionStateArray::DebugInfo' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddActionStateArray, ReturnValue) == 0x000040, "Member 'LActMgrComponent_AddActionStateArray::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddAnimRateScale
// 0x0030 (0x0030 - 0x0000)
struct LActMgrComponent_AddAnimRateScale final
{
public:
	ELAnimRateScaleOperationType                  OperationType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RateScale;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AddAnimRateScale) == 0x000008, "Wrong alignment on LActMgrComponent_AddAnimRateScale");
static_assert(sizeof(LActMgrComponent_AddAnimRateScale) == 0x000030, "Wrong size on LActMgrComponent_AddAnimRateScale");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, OperationType) == 0x000000, "Member 'LActMgrComponent_AddAnimRateScale::OperationType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, RateScale) == 0x000004, "Member 'LActMgrComponent_AddAnimRateScale::RateScale' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, Duration) == 0x000008, "Member 'LActMgrComponent_AddAnimRateScale::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, Instigator) == 0x000010, "Member 'LActMgrComponent_AddAnimRateScale::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, SkeletalMeshComponent) == 0x000018, "Member 'LActMgrComponent_AddAnimRateScale::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, AnimMontage) == 0x000020, "Member 'LActMgrComponent_AddAnimRateScale::AnimMontage' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRateScale, ReturnValue) == 0x000028, "Member 'LActMgrComponent_AddAnimRateScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddAnimRootMotionTranslationScale
// 0x0028 (0x0028 - 0x0000)
struct LActMgrComponent_AddAnimRootMotionTranslationScale final
{
public:
	ELAnimRootMotionScaleOperationType            OperationType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RateScale;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateScale_Vertical;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateScale_Horizontal;                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AddAnimRootMotionTranslationScale) == 0x000008, "Wrong alignment on LActMgrComponent_AddAnimRootMotionTranslationScale");
static_assert(sizeof(LActMgrComponent_AddAnimRootMotionTranslationScale) == 0x000028, "Wrong size on LActMgrComponent_AddAnimRootMotionTranslationScale");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, OperationType) == 0x000000, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::OperationType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, RateScale) == 0x000004, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::RateScale' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, Duration) == 0x000008, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, Instigator) == 0x000010, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, RateScale_Vertical) == 0x000018, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::RateScale_Vertical' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, RateScale_Horizontal) == 0x00001C, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::RateScale_Horizontal' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddAnimRootMotionTranslationScale, ReturnValue) == 0x000020, "Member 'LActMgrComponent_AddAnimRootMotionTranslationScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddFxSocketTracer
// 0x0110 (0x0110 - 0x0000)
struct LActMgrComponent_AddFxSocketTracer final
{
public:
	struct FLFxSocketTracerInfo                   Info;                                              // 0x0000(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          StartCheck;                                        // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x010C(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_AddFxSocketTracer) == 0x000008, "Wrong alignment on LActMgrComponent_AddFxSocketTracer");
static_assert(sizeof(LActMgrComponent_AddFxSocketTracer) == 0x000110, "Wrong size on LActMgrComponent_AddFxSocketTracer");
static_assert(offsetof(LActMgrComponent_AddFxSocketTracer, Info) == 0x000000, "Member 'LActMgrComponent_AddFxSocketTracer::Info' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddFxSocketTracer, StartCheck) == 0x000108, "Member 'LActMgrComponent_AddFxSocketTracer::StartCheck' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddFxSocketTracer, ReturnValue) == 0x00010C, "Member 'LActMgrComponent_AddFxSocketTracer::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddPreInputCommand
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_AddPreInputCommand final
{
public:
	struct FLReservedCommand                      ReservedCommand;                                   // 0x0000(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_AddPreInputCommand) == 0x000004, "Wrong alignment on LActMgrComponent_AddPreInputCommand");
static_assert(sizeof(LActMgrComponent_AddPreInputCommand) == 0x000018, "Wrong size on LActMgrComponent_AddPreInputCommand");
static_assert(offsetof(LActMgrComponent_AddPreInputCommand, ReservedCommand) == 0x000000, "Member 'LActMgrComponent_AddPreInputCommand::ReservedCommand' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AddToHitGroup
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_AddToHitGroup final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitGroup;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AddToHitGroup) == 0x000008, "Wrong alignment on LActMgrComponent_AddToHitGroup");
static_assert(sizeof(LActMgrComponent_AddToHitGroup) == 0x000010, "Wrong size on LActMgrComponent_AddToHitGroup");
static_assert(offsetof(LActMgrComponent_AddToHitGroup, Victim) == 0x000000, "Member 'LActMgrComponent_AddToHitGroup::Victim' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AddToHitGroup, HitGroup) == 0x000008, "Member 'LActMgrComponent_AddToHitGroup::HitGroup' has a wrong offset!");

// Function ProjectP.LActMgrComponent.BindTransformModifierToAction
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_BindTransformModifierToAction final
{
public:
	class ULActBase*                              OwnerAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Handle;                                            // 0x0008(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_BindTransformModifierToAction) == 0x000008, "Wrong alignment on LActMgrComponent_BindTransformModifierToAction");
static_assert(sizeof(LActMgrComponent_BindTransformModifierToAction) == 0x000010, "Wrong size on LActMgrComponent_BindTransformModifierToAction");
static_assert(offsetof(LActMgrComponent_BindTransformModifierToAction, OwnerAction) == 0x000000, "Member 'LActMgrComponent_BindTransformModifierToAction::OwnerAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_BindTransformModifierToAction, Handle) == 0x000008, "Member 'LActMgrComponent_BindTransformModifierToAction::Handle' has a wrong offset!");

// Function ProjectP.LActMgrComponent.CachePlayedHitCommonActionMontageCodeName
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_CachePlayedHitCommonActionMontageCodeName final
{
public:
	class FName                                   HitCommonActionMontageCodeName;                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_CachePlayedHitCommonActionMontageCodeName) == 0x000004, "Wrong alignment on LActMgrComponent_CachePlayedHitCommonActionMontageCodeName");
static_assert(sizeof(LActMgrComponent_CachePlayedHitCommonActionMontageCodeName) == 0x000008, "Wrong size on LActMgrComponent_CachePlayedHitCommonActionMontageCodeName");
static_assert(offsetof(LActMgrComponent_CachePlayedHitCommonActionMontageCodeName, HitCommonActionMontageCodeName) == 0x000000, "Member 'LActMgrComponent_CachePlayedHitCommonActionMontageCodeName::HitCommonActionMontageCodeName' has a wrong offset!");

// Function ProjectP.LActMgrComponent.CheckFxSocketTracer_Redo
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_CheckFxSocketTracer_Redo final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_CheckFxSocketTracer_Redo) == 0x000004, "Wrong alignment on LActMgrComponent_CheckFxSocketTracer_Redo");
static_assert(sizeof(LActMgrComponent_CheckFxSocketTracer_Redo) == 0x000008, "Wrong size on LActMgrComponent_CheckFxSocketTracer_Redo");
static_assert(offsetof(LActMgrComponent_CheckFxSocketTracer_Redo, Handle) == 0x000000, "Member 'LActMgrComponent_CheckFxSocketTracer_Redo::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_CheckFxSocketTracer_Redo, ReturnValue) == 0x000004, "Member 'LActMgrComponent_CheckFxSocketTracer_Redo::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.CheckFxSocketTracer_Stop
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_CheckFxSocketTracer_Stop final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_CheckFxSocketTracer_Stop) == 0x000004, "Wrong alignment on LActMgrComponent_CheckFxSocketTracer_Stop");
static_assert(sizeof(LActMgrComponent_CheckFxSocketTracer_Stop) == 0x000008, "Wrong size on LActMgrComponent_CheckFxSocketTracer_Stop");
static_assert(offsetof(LActMgrComponent_CheckFxSocketTracer_Stop, Handle) == 0x000000, "Member 'LActMgrComponent_CheckFxSocketTracer_Stop::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_CheckFxSocketTracer_Stop, ReturnValue) == 0x000004, "Member 'LActMgrComponent_CheckFxSocketTracer_Stop::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.ClearActionState
// 0x000C (0x000C - 0x0000)
struct LActMgrComponent_ClearActionState final
{
public:
	class FName                                   State;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_ClearActionState) == 0x000004, "Wrong alignment on LActMgrComponent_ClearActionState");
static_assert(sizeof(LActMgrComponent_ClearActionState) == 0x00000C, "Wrong size on LActMgrComponent_ClearActionState");
static_assert(offsetof(LActMgrComponent_ClearActionState, State) == 0x000000, "Member 'LActMgrComponent_ClearActionState::State' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ClearActionState, ReturnValue) == 0x000008, "Member 'LActMgrComponent_ClearActionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.FuncForClearPreInputCommand
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_FuncForClearPreInputCommand final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Interrupted;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_FuncForClearPreInputCommand) == 0x000008, "Wrong alignment on LActMgrComponent_FuncForClearPreInputCommand");
static_assert(sizeof(LActMgrComponent_FuncForClearPreInputCommand) == 0x000010, "Wrong size on LActMgrComponent_FuncForClearPreInputCommand");
static_assert(offsetof(LActMgrComponent_FuncForClearPreInputCommand, Montage) == 0x000000, "Member 'LActMgrComponent_FuncForClearPreInputCommand::Montage' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_FuncForClearPreInputCommand, Interrupted) == 0x000008, "Member 'LActMgrComponent_FuncForClearPreInputCommand::Interrupted' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetActionFromAssetName
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_GetActionFromAssetName final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BaseActionClassCodeName;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetName;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetActionFromAssetName) == 0x000008, "Wrong alignment on LActMgrComponent_GetActionFromAssetName");
static_assert(sizeof(LActMgrComponent_GetActionFromAssetName) == 0x000020, "Wrong size on LActMgrComponent_GetActionFromAssetName");
static_assert(offsetof(LActMgrComponent_GetActionFromAssetName, TargetActor) == 0x000000, "Member 'LActMgrComponent_GetActionFromAssetName::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetActionFromAssetName, BaseActionClassCodeName) == 0x000008, "Member 'LActMgrComponent_GetActionFromAssetName::BaseActionClassCodeName' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetActionFromAssetName, AssetName) == 0x000010, "Member 'LActMgrComponent_GetActionFromAssetName::AssetName' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetActionFromAssetName, ReturnValue) == 0x000018, "Member 'LActMgrComponent_GetActionFromAssetName::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetActionFromTable
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_GetActionFromTable final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CodeName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetActionFromTable) == 0x000008, "Wrong alignment on LActMgrComponent_GetActionFromTable");
static_assert(sizeof(LActMgrComponent_GetActionFromTable) == 0x000018, "Wrong size on LActMgrComponent_GetActionFromTable");
static_assert(offsetof(LActMgrComponent_GetActionFromTable, TargetActor) == 0x000000, "Member 'LActMgrComponent_GetActionFromTable::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetActionFromTable, CodeName) == 0x000008, "Member 'LActMgrComponent_GetActionFromTable::CodeName' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetActionFromTable, ReturnValue) == 0x000010, "Member 'LActMgrComponent_GetActionFromTable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetAvailableAction
// 0x0038 (0x0038 - 0x0000)
struct LActMgrComponent_GetAvailableAction final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Type;                                              // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetAvailableAction) == 0x000008, "Wrong alignment on LActMgrComponent_GetAvailableAction");
static_assert(sizeof(LActMgrComponent_GetAvailableAction) == 0x000038, "Wrong size on LActMgrComponent_GetAvailableAction");
static_assert(offsetof(LActMgrComponent_GetAvailableAction, TargetActor) == 0x000000, "Member 'LActMgrComponent_GetAvailableAction::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetAvailableAction, Type) == 0x000008, "Member 'LActMgrComponent_GetAvailableAction::Type' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetAvailableAction, ReturnValue) == 0x000030, "Member 'LActMgrComponent_GetAvailableAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetDefaultSpawnedGuardCollisionDynamic
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic final
{
public:
	class ALHitCollisionDynamic*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic) == 0x000008, "Wrong alignment on LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic");
static_assert(sizeof(LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic) == 0x000008, "Wrong size on LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic");
static_assert(offsetof(LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic, ReturnValue) == 0x000000, "Member 'LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetPlayingAction
// 0x0030 (0x0030 - 0x0000)
struct LActMgrComponent_GetPlayingAction final
{
public:
	TSoftClassPtr<class UClass>                   Type;                                              // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetPlayingAction) == 0x000008, "Wrong alignment on LActMgrComponent_GetPlayingAction");
static_assert(sizeof(LActMgrComponent_GetPlayingAction) == 0x000030, "Wrong size on LActMgrComponent_GetPlayingAction");
static_assert(offsetof(LActMgrComponent_GetPlayingAction, Type) == 0x000000, "Member 'LActMgrComponent_GetPlayingAction::Type' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetPlayingAction, ReturnValue) == 0x000028, "Member 'LActMgrComponent_GetPlayingAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetSlaveArmActionForVisualActionBP
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_GetSlaveArmActionForVisualActionBP final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULAction_SlaveArmVisual*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetSlaveArmActionForVisualActionBP) == 0x000008, "Wrong alignment on LActMgrComponent_GetSlaveArmActionForVisualActionBP");
static_assert(sizeof(LActMgrComponent_GetSlaveArmActionForVisualActionBP) == 0x000010, "Wrong size on LActMgrComponent_GetSlaveArmActionForVisualActionBP");
static_assert(offsetof(LActMgrComponent_GetSlaveArmActionForVisualActionBP, Branches) == 0x000000, "Member 'LActMgrComponent_GetSlaveArmActionForVisualActionBP::Branches' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetSlaveArmActionForVisualActionBP, ReturnValue) == 0x000008, "Member 'LActMgrComponent_GetSlaveArmActionForVisualActionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.PlayAction_Die
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_PlayAction_Die final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_PlayAction_Die) == 0x000008, "Wrong alignment on LActMgrComponent_PlayAction_Die");
static_assert(sizeof(LActMgrComponent_PlayAction_Die) == 0x000010, "Wrong size on LActMgrComponent_PlayAction_Die");
static_assert(offsetof(LActMgrComponent_PlayAction_Die, TargetActor) == 0x000000, "Member 'LActMgrComponent_PlayAction_Die::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_PlayAction_Die, ReturnValue) == 0x000008, "Member 'LActMgrComponent_PlayAction_Die::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.PlayAction_SkillFailed
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_PlayAction_SkillFailed final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailedSkillCodeName;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_PlayAction_SkillFailed) == 0x000008, "Wrong alignment on LActMgrComponent_PlayAction_SkillFailed");
static_assert(sizeof(LActMgrComponent_PlayAction_SkillFailed) == 0x000018, "Wrong size on LActMgrComponent_PlayAction_SkillFailed");
static_assert(offsetof(LActMgrComponent_PlayAction_SkillFailed, TargetActor) == 0x000000, "Member 'LActMgrComponent_PlayAction_SkillFailed::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_PlayAction_SkillFailed, FailedSkillCodeName) == 0x000008, "Member 'LActMgrComponent_PlayAction_SkillFailed::FailedSkillCodeName' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_PlayAction_SkillFailed, ReturnValue) == 0x000010, "Member 'LActMgrComponent_PlayAction_SkillFailed::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.PreProcessCommand
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_PreProcessCommand final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Command;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_PreProcessCommand) == 0x000008, "Wrong alignment on LActMgrComponent_PreProcessCommand");
static_assert(sizeof(LActMgrComponent_PreProcessCommand) == 0x000020, "Wrong size on LActMgrComponent_PreProcessCommand");
static_assert(offsetof(LActMgrComponent_PreProcessCommand, TargetActor) == 0x000000, "Member 'LActMgrComponent_PreProcessCommand::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_PreProcessCommand, Command) == 0x000008, "Member 'LActMgrComponent_PreProcessCommand::Command' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_PreProcessCommand, Lever) == 0x000010, "Member 'LActMgrComponent_PreProcessCommand::Lever' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_PreProcessCommand, ReturnValue) == 0x00001C, "Member 'LActMgrComponent_PreProcessCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.ProcessAction
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_ProcessAction final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              TargetAction;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActPayloadBase*                       Payload;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_ProcessAction) == 0x000008, "Wrong alignment on LActMgrComponent_ProcessAction");
static_assert(sizeof(LActMgrComponent_ProcessAction) == 0x000020, "Wrong size on LActMgrComponent_ProcessAction");
static_assert(offsetof(LActMgrComponent_ProcessAction, TargetActor) == 0x000000, "Member 'LActMgrComponent_ProcessAction::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessAction, TargetAction) == 0x000008, "Member 'LActMgrComponent_ProcessAction::TargetAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessAction, Payload) == 0x000010, "Member 'LActMgrComponent_ProcessAction::Payload' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessAction, ReturnValue) == 0x000018, "Member 'LActMgrComponent_ProcessAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.ProcessCommand
// 0x0030 (0x0030 - 0x0000)
struct LActMgrComponent_ProcessCommand final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Command;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipCommandPrerequisitiesCheck;                    // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CommandEventTime;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceQueryCommand;                                 // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReserved;                                        // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_ProcessCommand) == 0x000008, "Wrong alignment on LActMgrComponent_ProcessCommand");
static_assert(sizeof(LActMgrComponent_ProcessCommand) == 0x000030, "Wrong size on LActMgrComponent_ProcessCommand");
static_assert(offsetof(LActMgrComponent_ProcessCommand, TargetActor) == 0x000000, "Member 'LActMgrComponent_ProcessCommand::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, Command) == 0x000008, "Member 'LActMgrComponent_ProcessCommand::Command' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, Lever) == 0x000010, "Member 'LActMgrComponent_ProcessCommand::Lever' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, SkipCommandPrerequisitiesCheck) == 0x00001C, "Member 'LActMgrComponent_ProcessCommand::SkipCommandPrerequisitiesCheck' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, CommandEventTime) == 0x000020, "Member 'LActMgrComponent_ProcessCommand::CommandEventTime' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, ForceQueryCommand) == 0x000024, "Member 'LActMgrComponent_ProcessCommand::ForceQueryCommand' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, IsReserved) == 0x000025, "Member 'LActMgrComponent_ProcessCommand::IsReserved' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_ProcessCommand, ReturnValue) == 0x000028, "Member 'LActMgrComponent_ProcessCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.QueryNextAction
// 0x00A0 (0x00A0 - 0x0000)
struct LActMgrComponent_QueryNextAction final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Command;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              CurrAction;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutActionClass;                                    // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLActionInfo                           OutActionInfo;                                     // 0x0030(0x0060)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class ULActPayloadBase*                       OutPayload;                                        // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_QueryNextAction) == 0x000008, "Wrong alignment on LActMgrComponent_QueryNextAction");
static_assert(sizeof(LActMgrComponent_QueryNextAction) == 0x0000A0, "Wrong size on LActMgrComponent_QueryNextAction");
static_assert(offsetof(LActMgrComponent_QueryNextAction, TargetActor) == 0x000000, "Member 'LActMgrComponent_QueryNextAction::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, Command) == 0x000008, "Member 'LActMgrComponent_QueryNextAction::Command' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, Lever) == 0x000010, "Member 'LActMgrComponent_QueryNextAction::Lever' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, CurrAction) == 0x000020, "Member 'LActMgrComponent_QueryNextAction::CurrAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, OutActionClass) == 0x000028, "Member 'LActMgrComponent_QueryNextAction::OutActionClass' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, OutActionInfo) == 0x000030, "Member 'LActMgrComponent_QueryNextAction::OutActionInfo' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, OutPayload) == 0x000090, "Member 'LActMgrComponent_QueryNextAction::OutPayload' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_QueryNextAction, ReturnValue) == 0x000098, "Member 'LActMgrComponent_QueryNextAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RegisterFxSocketTracerEvent
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_RegisterFxSocketTracerEvent final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)> SocketTraceEvent;                                  // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RegisterFxSocketTracerEvent) == 0x000004, "Wrong alignment on LActMgrComponent_RegisterFxSocketTracerEvent");
static_assert(sizeof(LActMgrComponent_RegisterFxSocketTracerEvent) == 0x000018, "Wrong size on LActMgrComponent_RegisterFxSocketTracerEvent");
static_assert(offsetof(LActMgrComponent_RegisterFxSocketTracerEvent, Handle) == 0x000000, "Member 'LActMgrComponent_RegisterFxSocketTracerEvent::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RegisterFxSocketTracerEvent, SocketTraceEvent) == 0x000004, "Member 'LActMgrComponent_RegisterFxSocketTracerEvent::SocketTraceEvent' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RegisterFxSocketTracerEvent, ReturnValue) == 0x000014, "Member 'LActMgrComponent_RegisterFxSocketTracerEvent::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RegisterWatchingCommand
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_RegisterWatchingCommand final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckReservedCommand;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              OwnerAction;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RegisterWatchingCommand) == 0x000008, "Wrong alignment on LActMgrComponent_RegisterWatchingCommand");
static_assert(sizeof(LActMgrComponent_RegisterWatchingCommand) == 0x000020, "Wrong size on LActMgrComponent_RegisterWatchingCommand");
static_assert(offsetof(LActMgrComponent_RegisterWatchingCommand, Command) == 0x000000, "Member 'LActMgrComponent_RegisterWatchingCommand::Command' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RegisterWatchingCommand, CheckReservedCommand) == 0x000008, "Member 'LActMgrComponent_RegisterWatchingCommand::CheckReservedCommand' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RegisterWatchingCommand, OwnerAction) == 0x000010, "Member 'LActMgrComponent_RegisterWatchingCommand::OwnerAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RegisterWatchingCommand, ReturnValue) == 0x000018, "Member 'LActMgrComponent_RegisterWatchingCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveActionState
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_RemoveActionState final
{
public:
	class FName                                   State;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePair;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELImmuneSourceType                            ImmuneSourceType;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ValidOnThisFrame;                                  // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveActionState) == 0x000008, "Wrong alignment on LActMgrComponent_RemoveActionState");
static_assert(sizeof(LActMgrComponent_RemoveActionState) == 0x000020, "Wrong size on LActMgrComponent_RemoveActionState");
static_assert(offsetof(LActMgrComponent_RemoveActionState, State) == 0x000000, "Member 'LActMgrComponent_RemoveActionState::State' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionState, UsePair) == 0x000008, "Member 'LActMgrComponent_RemoveActionState::UsePair' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionState, Instigator) == 0x000010, "Member 'LActMgrComponent_RemoveActionState::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionState, ImmuneSourceType) == 0x000018, "Member 'LActMgrComponent_RemoveActionState::ImmuneSourceType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionState, ValidOnThisFrame) == 0x000019, "Member 'LActMgrComponent_RemoveActionState::ValidOnThisFrame' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionState, ReturnValue) == 0x00001A, "Member 'LActMgrComponent_RemoveActionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveActionState_AutoRemove
// 0x0004 (0x0004 - 0x0000)
struct LActMgrComponent_RemoveActionState_AutoRemove final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_RemoveActionState_AutoRemove) == 0x000004, "Wrong alignment on LActMgrComponent_RemoveActionState_AutoRemove");
static_assert(sizeof(LActMgrComponent_RemoveActionState_AutoRemove) == 0x000004, "Wrong size on LActMgrComponent_RemoveActionState_AutoRemove");
static_assert(offsetof(LActMgrComponent_RemoveActionState_AutoRemove, Handle) == 0x000000, "Member 'LActMgrComponent_RemoveActionState_AutoRemove::Handle' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveActionStateArray
// 0x0028 (0x0028 - 0x0000)
struct LActMgrComponent_RemoveActionStateArray final
{
public:
	TArray<class FName>                           StateArray;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UsePair;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELImmuneSourceType                            ImmuneSourceType;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ValidOnThisFrame;                                  // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0022(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveActionStateArray) == 0x000008, "Wrong alignment on LActMgrComponent_RemoveActionStateArray");
static_assert(sizeof(LActMgrComponent_RemoveActionStateArray) == 0x000028, "Wrong size on LActMgrComponent_RemoveActionStateArray");
static_assert(offsetof(LActMgrComponent_RemoveActionStateArray, StateArray) == 0x000000, "Member 'LActMgrComponent_RemoveActionStateArray::StateArray' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionStateArray, UsePair) == 0x000010, "Member 'LActMgrComponent_RemoveActionStateArray::UsePair' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionStateArray, Instigator) == 0x000018, "Member 'LActMgrComponent_RemoveActionStateArray::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionStateArray, ImmuneSourceType) == 0x000020, "Member 'LActMgrComponent_RemoveActionStateArray::ImmuneSourceType' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionStateArray, ValidOnThisFrame) == 0x000021, "Member 'LActMgrComponent_RemoveActionStateArray::ValidOnThisFrame' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveActionStateArray, ReturnValue) == 0x000022, "Member 'LActMgrComponent_RemoveActionStateArray::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAllAnimRateScale
// 0x0001 (0x0001 - 0x0000)
struct LActMgrComponent_RemoveAllAnimRateScale final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_RemoveAllAnimRateScale) == 0x000001, "Wrong alignment on LActMgrComponent_RemoveAllAnimRateScale");
static_assert(sizeof(LActMgrComponent_RemoveAllAnimRateScale) == 0x000001, "Wrong size on LActMgrComponent_RemoveAllAnimRateScale");
static_assert(offsetof(LActMgrComponent_RemoveAllAnimRateScale, ReturnValue) == 0x000000, "Member 'LActMgrComponent_RemoveAllAnimRateScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAllAnimRootMotionTranslationScale
// 0x0001 (0x0001 - 0x0000)
struct LActMgrComponent_RemoveAllAnimRootMotionTranslationScale final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_RemoveAllAnimRootMotionTranslationScale) == 0x000001, "Wrong alignment on LActMgrComponent_RemoveAllAnimRootMotionTranslationScale");
static_assert(sizeof(LActMgrComponent_RemoveAllAnimRootMotionTranslationScale) == 0x000001, "Wrong size on LActMgrComponent_RemoveAllAnimRootMotionTranslationScale");
static_assert(offsetof(LActMgrComponent_RemoveAllAnimRootMotionTranslationScale, ReturnValue) == 0x000000, "Member 'LActMgrComponent_RemoveAllAnimRootMotionTranslationScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAllFxSocketTracer
// 0x0001 (0x0001 - 0x0000)
struct LActMgrComponent_RemoveAllFxSocketTracer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_RemoveAllFxSocketTracer) == 0x000001, "Wrong alignment on LActMgrComponent_RemoveAllFxSocketTracer");
static_assert(sizeof(LActMgrComponent_RemoveAllFxSocketTracer) == 0x000001, "Wrong size on LActMgrComponent_RemoveAllFxSocketTracer");
static_assert(offsetof(LActMgrComponent_RemoveAllFxSocketTracer, ReturnValue) == 0x000000, "Member 'LActMgrComponent_RemoveAllFxSocketTracer::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAnimRateScale
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_RemoveAnimRateScale final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveAnimRateScale) == 0x000004, "Wrong alignment on LActMgrComponent_RemoveAnimRateScale");
static_assert(sizeof(LActMgrComponent_RemoveAnimRateScale) == 0x000008, "Wrong size on LActMgrComponent_RemoveAnimRateScale");
static_assert(offsetof(LActMgrComponent_RemoveAnimRateScale, Handle) == 0x000000, "Member 'LActMgrComponent_RemoveAnimRateScale::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveAnimRateScale, ReturnValue) == 0x000004, "Member 'LActMgrComponent_RemoveAnimRateScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAnimRateScaleByInstigator
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_RemoveAnimRateScaleByInstigator final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveAnimRateScaleByInstigator) == 0x000008, "Wrong alignment on LActMgrComponent_RemoveAnimRateScaleByInstigator");
static_assert(sizeof(LActMgrComponent_RemoveAnimRateScaleByInstigator) == 0x000010, "Wrong size on LActMgrComponent_RemoveAnimRateScaleByInstigator");
static_assert(offsetof(LActMgrComponent_RemoveAnimRateScaleByInstigator, Instigator) == 0x000000, "Member 'LActMgrComponent_RemoveAnimRateScaleByInstigator::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveAnimRateScaleByInstigator, ReturnValue) == 0x000008, "Member 'LActMgrComponent_RemoveAnimRateScaleByInstigator::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAnimRootMotionTranslationScale
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_RemoveAnimRootMotionTranslationScale final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveAnimRootMotionTranslationScale) == 0x000004, "Wrong alignment on LActMgrComponent_RemoveAnimRootMotionTranslationScale");
static_assert(sizeof(LActMgrComponent_RemoveAnimRootMotionTranslationScale) == 0x000008, "Wrong size on LActMgrComponent_RemoveAnimRootMotionTranslationScale");
static_assert(offsetof(LActMgrComponent_RemoveAnimRootMotionTranslationScale, Handle) == 0x000000, "Member 'LActMgrComponent_RemoveAnimRootMotionTranslationScale::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveAnimRootMotionTranslationScale, ReturnValue) == 0x000004, "Member 'LActMgrComponent_RemoveAnimRootMotionTranslationScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveAnimRootMotionTranslationScaleByInstigator
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator) == 0x000008, "Wrong alignment on LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator");
static_assert(sizeof(LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator) == 0x000010, "Wrong size on LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator");
static_assert(offsetof(LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator, Instigator) == 0x000000, "Member 'LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator::Instigator' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator, ReturnValue) == 0x000008, "Member 'LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.RemoveFxSocketTracer
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_RemoveFxSocketTracer final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_RemoveFxSocketTracer) == 0x000004, "Wrong alignment on LActMgrComponent_RemoveFxSocketTracer");
static_assert(sizeof(LActMgrComponent_RemoveFxSocketTracer) == 0x000008, "Wrong size on LActMgrComponent_RemoveFxSocketTracer");
static_assert(offsetof(LActMgrComponent_RemoveFxSocketTracer, Handle) == 0x000000, "Member 'LActMgrComponent_RemoveFxSocketTracer::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_RemoveFxSocketTracer, ReturnValue) == 0x000004, "Member 'LActMgrComponent_RemoveFxSocketTracer::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.SetComboTable
// 0x0030 (0x0030 - 0x0000)
struct LActMgrComponent_SetComboTable final
{
public:
	TSoftClassPtr<class UClass>                   Type;                                              // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_SetComboTable) == 0x000008, "Wrong alignment on LActMgrComponent_SetComboTable");
static_assert(sizeof(LActMgrComponent_SetComboTable) == 0x000030, "Wrong size on LActMgrComponent_SetComboTable");
static_assert(offsetof(LActMgrComponent_SetComboTable, Type) == 0x000000, "Member 'LActMgrComponent_SetComboTable::Type' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_SetComboTable, ReturnValue) == 0x000028, "Member 'LActMgrComponent_SetComboTable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.SetSkillTarget
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_SetSkillTarget final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_SetSkillTarget) == 0x000008, "Wrong alignment on LActMgrComponent_SetSkillTarget");
static_assert(sizeof(LActMgrComponent_SetSkillTarget) == 0x000008, "Wrong size on LActMgrComponent_SetSkillTarget");
static_assert(offsetof(LActMgrComponent_SetSkillTarget, Target) == 0x000000, "Member 'LActMgrComponent_SetSkillTarget::Target' has a wrong offset!");

// Function ProjectP.LActMgrComponent.SetSkillTargetLocation
// 0x000C (0x000C - 0x0000)
struct LActMgrComponent_SetSkillTargetLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_SetSkillTargetLocation) == 0x000004, "Wrong alignment on LActMgrComponent_SetSkillTargetLocation");
static_assert(sizeof(LActMgrComponent_SetSkillTargetLocation) == 0x00000C, "Wrong size on LActMgrComponent_SetSkillTargetLocation");
static_assert(offsetof(LActMgrComponent_SetSkillTargetLocation, Location) == 0x000000, "Member 'LActMgrComponent_SetSkillTargetLocation::Location' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartMeshRotatingOnFloor
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_StartMeshRotatingOnFloor final
{
public:
	float                                         RotSpeed;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StartMeshRotatingOnFloor) == 0x000004, "Wrong alignment on LActMgrComponent_StartMeshRotatingOnFloor");
static_assert(sizeof(LActMgrComponent_StartMeshRotatingOnFloor) == 0x000008, "Wrong size on LActMgrComponent_StartMeshRotatingOnFloor");
static_assert(offsetof(LActMgrComponent_StartMeshRotatingOnFloor, RotSpeed) == 0x000000, "Member 'LActMgrComponent_StartMeshRotatingOnFloor::RotSpeed' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartMeshRotatingOnFloor, ReturnValue) == 0x000004, "Member 'LActMgrComponent_StartMeshRotatingOnFloor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartSkillMove
// 0x000C (0x000C - 0x0000)
struct LActMgrComponent_StartSkillMove final
{
public:
	class FName                                   SkillMoveID;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StartSkillMove) == 0x000004, "Wrong alignment on LActMgrComponent_StartSkillMove");
static_assert(sizeof(LActMgrComponent_StartSkillMove) == 0x00000C, "Wrong size on LActMgrComponent_StartSkillMove");
static_assert(offsetof(LActMgrComponent_StartSkillMove, SkillMoveID) == 0x000000, "Member 'LActMgrComponent_StartSkillMove::SkillMoveID' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartSkillMove, Duration) == 0x000008, "Member 'LActMgrComponent_StartSkillMove::Duration' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartSyncTransformToTarget
// 0x0044 (0x0044 - 0x0000)
struct LActMgrComponent_StartSyncTransformToTarget final
{
public:
	struct FLSyncTransformToTargetInfo            Info;                                              // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartSyncTransformToTarget) == 0x000004, "Wrong alignment on LActMgrComponent_StartSyncTransformToTarget");
static_assert(sizeof(LActMgrComponent_StartSyncTransformToTarget) == 0x000044, "Wrong size on LActMgrComponent_StartSyncTransformToTarget");
static_assert(offsetof(LActMgrComponent_StartSyncTransformToTarget, Info) == 0x000000, "Member 'LActMgrComponent_StartSyncTransformToTarget::Info' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartSyncTransformToTarget, ReturnValue) == 0x000040, "Member 'LActMgrComponent_StartSyncTransformToTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor
// 0x0040 (0x0040 - 0x0000)
struct LActMgrComponent_StartTransformModifier_MoveActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FixedDir;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStepUp;                                         // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MoveCurve;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MoveRot;                                           // 0x0028(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CheckNavPath;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvokeBlockEvent;                                  // 0x0035(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckFloor;                                        // 0x0036(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_MoveActor) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_MoveActor");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_MoveActor) == 0x000040, "Wrong size on LActMgrComponent_StartTransformModifier_MoveActor");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, Movement) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::Movement' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, Duration) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, FixedDir) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::FixedDir' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, UseStepUp) == 0x000019, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::UseStepUp' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, MoveCurve) == 0x000020, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::MoveCurve' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, MoveRot) == 0x000028, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::MoveRot' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, CheckNavPath) == 0x000034, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::CheckNavPath' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, InvokeBlockEvent) == 0x000035, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::InvokeBlockEvent' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, CheckFloor) == 0x000036, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::CheckFloor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor, ReturnValue) == 0x000038, "Member 'LActMgrComponent_StartTransformModifier_MoveActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_MoveOnly
// 0x0038 (0x0038 - 0x0000)
struct LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStepUp;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MoveCurve;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckNavPath;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApplyFakeVelocity;                                 // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvokeBlockEvent;                                  // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckFloor;                                        // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly) == 0x000038, "Wrong size on LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, Movement) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::Movement' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, Duration) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, UseStepUp) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::UseStepUp' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, MoveCurve) == 0x000020, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::MoveCurve' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, CheckNavPath) == 0x000028, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::CheckNavPath' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, ApplyFakeVelocity) == 0x00002C, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::ApplyFakeVelocity' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, InvokeBlockEvent) == 0x000030, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::InvokeBlockEvent' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, CheckFloor) == 0x000031, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::CheckFloor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly, ReturnValue) == 0x000034, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_Walking
// 0x0040 (0x0040 - 0x0000)
struct LActMgrComponent_StartTransformModifier_MoveActor_Walking final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FixedDir;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MoveCurve;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MoveRot;                                           // 0x0028(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CheckNavPath;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckFloor;                                        // 0x0035(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_MoveActor_Walking) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_MoveActor_Walking");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_MoveActor_Walking) == 0x000040, "Wrong size on LActMgrComponent_StartTransformModifier_MoveActor_Walking");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, Movement) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::Movement' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, Duration) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, FixedDir) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::FixedDir' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, MoveCurve) == 0x000020, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::MoveCurve' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, MoveRot) == 0x000028, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::MoveRot' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, CheckNavPath) == 0x000034, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::CheckNavPath' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, CheckFloor) == 0x000035, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::CheckFloor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking, ReturnValue) == 0x000038, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_Walking_MoveOnly
// 0x0030 (0x0030 - 0x0000)
struct LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           MoveCurve;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckNavPath;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ApplyFakeVelocity;                                 // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckFloor;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x002C(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly) == 0x000030, "Wrong size on LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, Movement) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::Movement' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, Duration) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, MoveCurve) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::MoveCurve' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, CheckNavPath) == 0x000020, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::CheckNavPath' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, ApplyFakeVelocity) == 0x000024, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::ApplyFakeVelocity' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, CheckFloor) == 0x000028, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::CheckFloor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly, ReturnValue) == 0x00002C, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_Walking_Tracking
// 0x0068 (0x0068 - 0x0000)
struct LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLTransformModifierInfo_MoveActor_Walking_Tracking Info;                                              // 0x0008(0x0058)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0060(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking) == 0x000068, "Wrong size on LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking, Info) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking::Info' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking, ReturnValue) == 0x000060, "Member 'LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor
// 0x0028 (0x0028 - 0x0000)
struct LActMgrComponent_StartTransformModifier_RotateActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotSpeedCurve;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_RotateActor) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_RotateActor");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_RotateActor) == 0x000028, "Wrong size on LActMgrComponent_StartTransformModifier_RotateActor");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_RotateActor::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor, Rot) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_RotateActor::Rot' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor, Duration) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_RotateActor::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor, RotSpeedCurve) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_RotateActor::RotSpeedCurve' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor, ReturnValue) == 0x000020, "Member 'LActMgrComponent_StartTransformModifier_RotateActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_AddYaw
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_StartTransformModifier_RotateActor_AddYaw final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYaw;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotSpeedCurve;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_RotateActor_AddYaw");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw) == 0x000020, "Wrong size on LActMgrComponent_StartTransformModifier_RotateActor_AddYaw");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_AddYaw::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw, AddYaw) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_AddYaw::AddYaw' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw, Duration) == 0x00000C, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_AddYaw::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw, RotSpeedCurve) == 0x000010, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_AddYaw::RotSpeedCurve' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_AddYaw, ReturnValue) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_AddYaw::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_ToLocation
// 0x0020 (0x0020 - 0x0000)
struct LActMgrComponent_StartTransformModifier_RotateActor_ToLocation final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FaceToLocation;                                    // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_RotateActor_ToLocation) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_RotateActor_ToLocation");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_RotateActor_ToLocation) == 0x000020, "Wrong size on LActMgrComponent_StartTransformModifier_RotateActor_ToLocation");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToLocation, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToLocation::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToLocation, FaceToLocation) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToLocation::FaceToLocation' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToLocation, Duration) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToLocation::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToLocation, ReturnValue) == 0x000018, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_ToYaw
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_StartTransformModifier_RotateActor_ToYaw final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalYaw;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawSpeed;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_RotateActor_ToYaw");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw) == 0x000018, "Wrong size on LActMgrComponent_StartTransformModifier_RotateActor_ToYaw");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToYaw::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw, FinalYaw) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToYaw::FinalYaw' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw, YawSpeed) == 0x00000C, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToYaw::YawSpeed' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw, Duration) == 0x000010, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToYaw::Duration' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_ToYaw, ReturnValue) == 0x000014, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_ToYaw::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_Tracking
// 0x0040 (0x0040 - 0x0000)
struct LActMgrComponent_StartTransformModifier_RotateActor_Tracking final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLTransformModifierInfo_RotateActor_Tracking Info;                                              // 0x0008(0x0034)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     ReturnValue;                                       // 0x003C(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StartTransformModifier_RotateActor_Tracking) == 0x000008, "Wrong alignment on LActMgrComponent_StartTransformModifier_RotateActor_Tracking");
static_assert(sizeof(LActMgrComponent_StartTransformModifier_RotateActor_Tracking) == 0x000040, "Wrong size on LActMgrComponent_StartTransformModifier_RotateActor_Tracking");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_Tracking, TargetActor) == 0x000000, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_Tracking::TargetActor' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_Tracking, Info) == 0x000008, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_Tracking::Info' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StartTransformModifier_RotateActor_Tracking, ReturnValue) == 0x00003C, "Member 'LActMgrComponent_StartTransformModifier_RotateActor_Tracking::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StopAction
// 0x0038 (0x0038 - 0x0000)
struct LActMgrComponent_StopAction final
{
public:
	TSoftClassPtr<class UClass>                   Type;                                              // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReasonAction;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StopAction) == 0x000008, "Wrong alignment on LActMgrComponent_StopAction");
static_assert(sizeof(LActMgrComponent_StopAction) == 0x000038, "Wrong size on LActMgrComponent_StopAction");
static_assert(offsetof(LActMgrComponent_StopAction, Type) == 0x000000, "Member 'LActMgrComponent_StopAction::Type' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopAction, ReasonAction) == 0x000028, "Member 'LActMgrComponent_StopAction::ReasonAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopAction, Reason) == 0x000030, "Member 'LActMgrComponent_StopAction::Reason' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StopAllAction
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_StopAllAction final
{
public:
	class ULActBase*                              ReasonAction;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeDecorateAction;                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_StopAllAction) == 0x000008, "Wrong alignment on LActMgrComponent_StopAllAction");
static_assert(sizeof(LActMgrComponent_StopAllAction) == 0x000018, "Wrong size on LActMgrComponent_StopAllAction");
static_assert(offsetof(LActMgrComponent_StopAllAction, ReasonAction) == 0x000000, "Member 'LActMgrComponent_StopAllAction::ReasonAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopAllAction, Reason) == 0x000008, "Member 'LActMgrComponent_StopAllAction::Reason' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopAllAction, IncludeDecorateAction) == 0x000010, "Member 'LActMgrComponent_StopAllAction::IncludeDecorateAction' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StopAllTransformModifier
// 0x0004 (0x0004 - 0x0000)
struct LActMgrComponent_StopAllTransformModifier final
{
public:
	float                                         CompensationTime;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StopAllTransformModifier) == 0x000004, "Wrong alignment on LActMgrComponent_StopAllTransformModifier");
static_assert(sizeof(LActMgrComponent_StopAllTransformModifier) == 0x000004, "Wrong size on LActMgrComponent_StopAllTransformModifier");
static_assert(offsetof(LActMgrComponent_StopAllTransformModifier, CompensationTime) == 0x000000, "Member 'LActMgrComponent_StopAllTransformModifier::CompensationTime' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StopMeshRotatingOnFloor
// 0x000C (0x000C - 0x0000)
struct LActMgrComponent_StopMeshRotatingOnFloor final
{
public:
	float                                         RotSpeed;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopImmediate;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StopMeshRotatingOnFloor) == 0x000004, "Wrong alignment on LActMgrComponent_StopMeshRotatingOnFloor");
static_assert(sizeof(LActMgrComponent_StopMeshRotatingOnFloor) == 0x00000C, "Wrong size on LActMgrComponent_StopMeshRotatingOnFloor");
static_assert(offsetof(LActMgrComponent_StopMeshRotatingOnFloor, RotSpeed) == 0x000000, "Member 'LActMgrComponent_StopMeshRotatingOnFloor::RotSpeed' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopMeshRotatingOnFloor, StopImmediate) == 0x000004, "Member 'LActMgrComponent_StopMeshRotatingOnFloor::StopImmediate' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopMeshRotatingOnFloor, ReturnValue) == 0x000008, "Member 'LActMgrComponent_StopMeshRotatingOnFloor::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.StopTransformModifier
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_StopTransformModifier final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CompensationTime;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_StopTransformModifier) == 0x000004, "Wrong alignment on LActMgrComponent_StopTransformModifier");
static_assert(sizeof(LActMgrComponent_StopTransformModifier) == 0x000008, "Wrong size on LActMgrComponent_StopTransformModifier");
static_assert(offsetof(LActMgrComponent_StopTransformModifier, Handle) == 0x000000, "Member 'LActMgrComponent_StopTransformModifier::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_StopTransformModifier, CompensationTime) == 0x000004, "Member 'LActMgrComponent_StopTransformModifier::CompensationTime' has a wrong offset!");

// Function ProjectP.LActMgrComponent.UnregisterFxSocketTracerEvent
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_UnregisterFxSocketTracerEvent final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)> SocketTraceEvent;                                  // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_UnregisterFxSocketTracerEvent) == 0x000004, "Wrong alignment on LActMgrComponent_UnregisterFxSocketTracerEvent");
static_assert(sizeof(LActMgrComponent_UnregisterFxSocketTracerEvent) == 0x000018, "Wrong size on LActMgrComponent_UnregisterFxSocketTracerEvent");
static_assert(offsetof(LActMgrComponent_UnregisterFxSocketTracerEvent, Handle) == 0x000000, "Member 'LActMgrComponent_UnregisterFxSocketTracerEvent::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_UnregisterFxSocketTracerEvent, SocketTraceEvent) == 0x000004, "Member 'LActMgrComponent_UnregisterFxSocketTracerEvent::SocketTraceEvent' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_UnregisterFxSocketTracerEvent, ReturnValue) == 0x000014, "Member 'LActMgrComponent_UnregisterFxSocketTracerEvent::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.UnregisterWatchingCommand
// 0x0004 (0x0004 - 0x0000)
struct LActMgrComponent_UnregisterWatchingCommand final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_UnregisterWatchingCommand) == 0x000004, "Wrong alignment on LActMgrComponent_UnregisterWatchingCommand");
static_assert(sizeof(LActMgrComponent_UnregisterWatchingCommand) == 0x000004, "Wrong size on LActMgrComponent_UnregisterWatchingCommand");
static_assert(offsetof(LActMgrComponent_UnregisterWatchingCommand, Handle) == 0x000000, "Member 'LActMgrComponent_UnregisterWatchingCommand::Handle' has a wrong offset!");

// Function ProjectP.LActMgrComponent.AleadyInHitGroup
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_AleadyInHitGroup final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitGroup;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_AleadyInHitGroup) == 0x000008, "Wrong alignment on LActMgrComponent_AleadyInHitGroup");
static_assert(sizeof(LActMgrComponent_AleadyInHitGroup) == 0x000010, "Wrong size on LActMgrComponent_AleadyInHitGroup");
static_assert(offsetof(LActMgrComponent_AleadyInHitGroup, Victim) == 0x000000, "Member 'LActMgrComponent_AleadyInHitGroup::Victim' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AleadyInHitGroup, HitGroup) == 0x000008, "Member 'LActMgrComponent_AleadyInHitGroup::HitGroup' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_AleadyInHitGroup, ReturnValue) == 0x00000C, "Member 'LActMgrComponent_AleadyInHitGroup::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.CheckLastPlayingActionClass
// 0x0030 (0x0030 - 0x0000)
struct LActMgrComponent_CheckLastPlayingActionClass final
{
public:
	TSoftClassPtr<class UClass>                   Type;                                              // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_CheckLastPlayingActionClass) == 0x000008, "Wrong alignment on LActMgrComponent_CheckLastPlayingActionClass");
static_assert(sizeof(LActMgrComponent_CheckLastPlayingActionClass) == 0x000030, "Wrong size on LActMgrComponent_CheckLastPlayingActionClass");
static_assert(offsetof(LActMgrComponent_CheckLastPlayingActionClass, Type) == 0x000000, "Member 'LActMgrComponent_CheckLastPlayingActionClass::Type' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_CheckLastPlayingActionClass, ReturnValue) == 0x000028, "Member 'LActMgrComponent_CheckLastPlayingActionClass::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.FindActionState
// 0x000C (0x000C - 0x0000)
struct LActMgrComponent_FindActionState final
{
public:
	class FName                                   State;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_FindActionState) == 0x000004, "Wrong alignment on LActMgrComponent_FindActionState");
static_assert(sizeof(LActMgrComponent_FindActionState) == 0x00000C, "Wrong size on LActMgrComponent_FindActionState");
static_assert(offsetof(LActMgrComponent_FindActionState, State) == 0x000000, "Member 'LActMgrComponent_FindActionState::State' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_FindActionState, ReturnValue) == 0x000008, "Member 'LActMgrComponent_FindActionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.FindActionStateAny
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_FindActionStateAny final
{
public:
	TArray<class FName>                           StateArray;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_FindActionStateAny) == 0x000008, "Wrong alignment on LActMgrComponent_FindActionStateAny");
static_assert(sizeof(LActMgrComponent_FindActionStateAny) == 0x000018, "Wrong size on LActMgrComponent_FindActionStateAny");
static_assert(offsetof(LActMgrComponent_FindActionStateAny, StateArray) == 0x000000, "Member 'LActMgrComponent_FindActionStateAny::StateArray' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_FindActionStateAny, ReturnValue) == 0x000010, "Member 'LActMgrComponent_FindActionStateAny::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetActionFrameCount
// 0x0004 (0x0004 - 0x0000)
struct LActMgrComponent_GetActionFrameCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetActionFrameCount) == 0x000004, "Wrong alignment on LActMgrComponent_GetActionFrameCount");
static_assert(sizeof(LActMgrComponent_GetActionFrameCount) == 0x000004, "Wrong size on LActMgrComponent_GetActionFrameCount");
static_assert(offsetof(LActMgrComponent_GetActionFrameCount, ReturnValue) == 0x000000, "Member 'LActMgrComponent_GetActionFrameCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetComboTable
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_GetComboTable final
{
public:
	class ULComboTableBase*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetComboTable) == 0x000008, "Wrong alignment on LActMgrComponent_GetComboTable");
static_assert(sizeof(LActMgrComponent_GetComboTable) == 0x000008, "Wrong size on LActMgrComponent_GetComboTable");
static_assert(offsetof(LActMgrComponent_GetComboTable, ReturnValue) == 0x000000, "Member 'LActMgrComponent_GetComboTable::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetLastPlayingAction
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_GetLastPlayingAction final
{
public:
	bool                                          ExceptHitAction;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeJustStopped;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExcludeDecorateAction;                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludePendingOnStart;                             // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetLastPlayingAction) == 0x000008, "Wrong alignment on LActMgrComponent_GetLastPlayingAction");
static_assert(sizeof(LActMgrComponent_GetLastPlayingAction) == 0x000010, "Wrong size on LActMgrComponent_GetLastPlayingAction");
static_assert(offsetof(LActMgrComponent_GetLastPlayingAction, ExceptHitAction) == 0x000000, "Member 'LActMgrComponent_GetLastPlayingAction::ExceptHitAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetLastPlayingAction, IncludeJustStopped) == 0x000001, "Member 'LActMgrComponent_GetLastPlayingAction::IncludeJustStopped' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetLastPlayingAction, ExcludeDecorateAction) == 0x000002, "Member 'LActMgrComponent_GetLastPlayingAction::ExcludeDecorateAction' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetLastPlayingAction, IncludePendingOnStart) == 0x000003, "Member 'LActMgrComponent_GetLastPlayingAction::IncludePendingOnStart' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetLastPlayingAction, ReturnValue) == 0x000008, "Member 'LActMgrComponent_GetLastPlayingAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetLastPlayingDecorateAction
// 0x0010 (0x0010 - 0x0000)
struct LActMgrComponent_GetLastPlayingDecorateAction final
{
public:
	bool                                          IncludePendingOnStart;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetLastPlayingDecorateAction) == 0x000008, "Wrong alignment on LActMgrComponent_GetLastPlayingDecorateAction");
static_assert(sizeof(LActMgrComponent_GetLastPlayingDecorateAction) == 0x000010, "Wrong size on LActMgrComponent_GetLastPlayingDecorateAction");
static_assert(offsetof(LActMgrComponent_GetLastPlayingDecorateAction, IncludePendingOnStart) == 0x000000, "Member 'LActMgrComponent_GetLastPlayingDecorateAction::IncludePendingOnStart' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetLastPlayingDecorateAction, ReturnValue) == 0x000008, "Member 'LActMgrComponent_GetLastPlayingDecorateAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetLastPreInputCommand
// 0x0018 (0x0018 - 0x0000)
struct LActMgrComponent_GetLastPreInputCommand final
{
public:
	struct FLReservedCommand                      ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetLastPreInputCommand) == 0x000004, "Wrong alignment on LActMgrComponent_GetLastPreInputCommand");
static_assert(sizeof(LActMgrComponent_GetLastPreInputCommand) == 0x000018, "Wrong size on LActMgrComponent_GetLastPreInputCommand");
static_assert(offsetof(LActMgrComponent_GetLastPreInputCommand, ReturnValue) == 0x000000, "Member 'LActMgrComponent_GetLastPreInputCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetSkillTargetLocation
// 0x000C (0x000C - 0x0000)
struct LActMgrComponent_GetSkillTargetLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetSkillTargetLocation) == 0x000004, "Wrong alignment on LActMgrComponent_GetSkillTargetLocation");
static_assert(sizeof(LActMgrComponent_GetSkillTargetLocation) == 0x00000C, "Wrong size on LActMgrComponent_GetSkillTargetLocation");
static_assert(offsetof(LActMgrComponent_GetSkillTargetLocation, ReturnValue) == 0x000000, "Member 'LActMgrComponent_GetSkillTargetLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.GetStandGuardRangeAngle
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_GetStandGuardRangeAngle final
{
public:
	int32                                         RangeAngleStart;                                   // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangeAngleEnd;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_GetStandGuardRangeAngle) == 0x000004, "Wrong alignment on LActMgrComponent_GetStandGuardRangeAngle");
static_assert(sizeof(LActMgrComponent_GetStandGuardRangeAngle) == 0x000008, "Wrong size on LActMgrComponent_GetStandGuardRangeAngle");
static_assert(offsetof(LActMgrComponent_GetStandGuardRangeAngle, RangeAngleStart) == 0x000000, "Member 'LActMgrComponent_GetStandGuardRangeAngle::RangeAngleStart' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_GetStandGuardRangeAngle, RangeAngleEnd) == 0x000004, "Member 'LActMgrComponent_GetStandGuardRangeAngle::RangeAngleEnd' has a wrong offset!");

// Function ProjectP.LActMgrComponent.IsInSkillMove
// 0x0001 (0x0001 - 0x0000)
struct LActMgrComponent_IsInSkillMove final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_IsInSkillMove) == 0x000001, "Wrong alignment on LActMgrComponent_IsInSkillMove");
static_assert(sizeof(LActMgrComponent_IsInSkillMove) == 0x000001, "Wrong size on LActMgrComponent_IsInSkillMove");
static_assert(offsetof(LActMgrComponent_IsInSkillMove, ReturnValue) == 0x000000, "Member 'LActMgrComponent_IsInSkillMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.IsTransformModifierActive
// 0x0008 (0x0008 - 0x0000)
struct LActMgrComponent_IsTransformModifierActive final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LActMgrComponent_IsTransformModifierActive) == 0x000004, "Wrong alignment on LActMgrComponent_IsTransformModifierActive");
static_assert(sizeof(LActMgrComponent_IsTransformModifierActive) == 0x000008, "Wrong size on LActMgrComponent_IsTransformModifierActive");
static_assert(offsetof(LActMgrComponent_IsTransformModifierActive, Handle) == 0x000000, "Member 'LActMgrComponent_IsTransformModifierActive::Handle' has a wrong offset!");
static_assert(offsetof(LActMgrComponent_IsTransformModifierActive, ReturnValue) == 0x000004, "Member 'LActMgrComponent_IsTransformModifierActive::ReturnValue' has a wrong offset!");

// Function ProjectP.LActMgrComponent.IsValidSkillTarget
// 0x0001 (0x0001 - 0x0000)
struct LActMgrComponent_IsValidSkillTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LActMgrComponent_IsValidSkillTarget) == 0x000001, "Wrong alignment on LActMgrComponent_IsValidSkillTarget");
static_assert(sizeof(LActMgrComponent_IsValidSkillTarget) == 0x000001, "Wrong size on LActMgrComponent_IsValidSkillTarget");
static_assert(offsetof(LActMgrComponent_IsValidSkillTarget, ReturnValue) == 0x000000, "Member 'LActMgrComponent_IsValidSkillTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.AddMoveSpeedRate
// 0x000C (0x000C - 0x0000)
struct LAIController_AddMoveSpeedRate final
{
public:
	class FName                                   MoveSpeedRateName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRate;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_AddMoveSpeedRate) == 0x000004, "Wrong alignment on LAIController_AddMoveSpeedRate");
static_assert(sizeof(LAIController_AddMoveSpeedRate) == 0x00000C, "Wrong size on LAIController_AddMoveSpeedRate");
static_assert(offsetof(LAIController_AddMoveSpeedRate, MoveSpeedRateName) == 0x000000, "Member 'LAIController_AddMoveSpeedRate::MoveSpeedRateName' has a wrong offset!");
static_assert(offsetof(LAIController_AddMoveSpeedRate, SpeedRate) == 0x000008, "Member 'LAIController_AddMoveSpeedRate::SpeedRate' has a wrong offset!");

// Function ProjectP.LAIController.AddPauseAI
// 0x000C (0x000C - 0x0000)
struct LAIController_AddPauseAI final
{
public:
	class FName                                   PauseName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintain;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_AddPauseAI) == 0x000004, "Wrong alignment on LAIController_AddPauseAI");
static_assert(sizeof(LAIController_AddPauseAI) == 0x00000C, "Wrong size on LAIController_AddPauseAI");
static_assert(offsetof(LAIController_AddPauseAI, PauseName) == 0x000000, "Member 'LAIController_AddPauseAI::PauseName' has a wrong offset!");
static_assert(offsetof(LAIController_AddPauseAI, bMaintain) == 0x000008, "Member 'LAIController_AddPauseAI::bMaintain' has a wrong offset!");

// Function ProjectP.LAIController.CalculatePathLength
// 0x0038 (0x0038 - 0x0000)
struct LAIController_CalculatePathLength final
{
public:
	class FName                                   CalculateName;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPaths;                                // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathLength;                                        // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CalculatePathLength) == 0x000004, "Wrong alignment on LAIController_CalculatePathLength");
static_assert(sizeof(LAIController_CalculatePathLength) == 0x000038, "Wrong size on LAIController_CalculatePathLength");
static_assert(offsetof(LAIController_CalculatePathLength, CalculateName) == 0x000000, "Member 'LAIController_CalculatePathLength::CalculateName' has a wrong offset!");
static_assert(offsetof(LAIController_CalculatePathLength, StartLocation) == 0x000008, "Member 'LAIController_CalculatePathLength::StartLocation' has a wrong offset!");
static_assert(offsetof(LAIController_CalculatePathLength, EndLocation) == 0x000014, "Member 'LAIController_CalculatePathLength::EndLocation' has a wrong offset!");
static_assert(offsetof(LAIController_CalculatePathLength, bAllowPartialPaths) == 0x000020, "Member 'LAIController_CalculatePathLength::bAllowPartialPaths' has a wrong offset!");
static_assert(offsetof(LAIController_CalculatePathLength, PathLength) == 0x000024, "Member 'LAIController_CalculatePathLength::PathLength' has a wrong offset!");
static_assert(offsetof(LAIController_CalculatePathLength, DestLocation) == 0x000028, "Member 'LAIController_CalculatePathLength::DestLocation' has a wrong offset!");
static_assert(offsetof(LAIController_CalculatePathLength, ReturnValue) == 0x000034, "Member 'LAIController_CalculatePathLength::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CanReachHome
// 0x0001 (0x0001 - 0x0000)
struct LAIController_CanReachHome final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_CanReachHome) == 0x000001, "Wrong alignment on LAIController_CanReachHome");
static_assert(sizeof(LAIController_CanReachHome) == 0x000001, "Wrong size on LAIController_CanReachHome");
static_assert(offsetof(LAIController_CanReachHome, ReturnValue) == 0x000000, "Member 'LAIController_CanReachHome::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CanReachTarget
// 0x0003 (0x0003 - 0x0000)
struct LAIController_CanReachTarget final
{
public:
	ELAITargetType                                TargetType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckHeight;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_CanReachTarget) == 0x000001, "Wrong alignment on LAIController_CanReachTarget");
static_assert(sizeof(LAIController_CanReachTarget) == 0x000003, "Wrong size on LAIController_CanReachTarget");
static_assert(offsetof(LAIController_CanReachTarget, TargetType) == 0x000000, "Member 'LAIController_CanReachTarget::TargetType' has a wrong offset!");
static_assert(offsetof(LAIController_CanReachTarget, bCheckHeight) == 0x000001, "Member 'LAIController_CanReachTarget::bCheckHeight' has a wrong offset!");
static_assert(offsetof(LAIController_CanReachTarget, ReturnValue) == 0x000002, "Member 'LAIController_CanReachTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.ChangeBehaviorTreeState
// 0x0008 (0x0008 - 0x0000)
struct LAIController_ChangeBehaviorTreeState final
{
public:
	class FName                                   InStateName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_ChangeBehaviorTreeState) == 0x000004, "Wrong alignment on LAIController_ChangeBehaviorTreeState");
static_assert(sizeof(LAIController_ChangeBehaviorTreeState) == 0x000008, "Wrong size on LAIController_ChangeBehaviorTreeState");
static_assert(offsetof(LAIController_ChangeBehaviorTreeState, InStateName) == 0x000000, "Member 'LAIController_ChangeBehaviorTreeState::InStateName' has a wrong offset!");

// Function ProjectP.LAIController.ChangeBehaviorTreeStateForce
// 0x0008 (0x0008 - 0x0000)
struct LAIController_ChangeBehaviorTreeStateForce final
{
public:
	class FName                                   InStateName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_ChangeBehaviorTreeStateForce) == 0x000004, "Wrong alignment on LAIController_ChangeBehaviorTreeStateForce");
static_assert(sizeof(LAIController_ChangeBehaviorTreeStateForce) == 0x000008, "Wrong size on LAIController_ChangeBehaviorTreeStateForce");
static_assert(offsetof(LAIController_ChangeBehaviorTreeStateForce, InStateName) == 0x000000, "Member 'LAIController_ChangeBehaviorTreeStateForce::InStateName' has a wrong offset!");

// Function ProjectP.LAIController.ChangeMoveSpeedRate
// 0x0004 (0x0004 - 0x0000)
struct LAIController_ChangeMoveSpeedRate final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_ChangeMoveSpeedRate) == 0x000004, "Wrong alignment on LAIController_ChangeMoveSpeedRate");
static_assert(sizeof(LAIController_ChangeMoveSpeedRate) == 0x000004, "Wrong size on LAIController_ChangeMoveSpeedRate");
static_assert(offsetof(LAIController_ChangeMoveSpeedRate, Rate) == 0x000000, "Member 'LAIController_ChangeMoveSpeedRate::Rate' has a wrong offset!");

// Function ProjectP.LAIController.ChangeReverseMoveDirection
// 0x0001 (0x0001 - 0x0000)
struct LAIController_ChangeReverseMoveDirection final
{
public:
	bool                                          bReverse;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_ChangeReverseMoveDirection) == 0x000001, "Wrong alignment on LAIController_ChangeReverseMoveDirection");
static_assert(sizeof(LAIController_ChangeReverseMoveDirection) == 0x000001, "Wrong size on LAIController_ChangeReverseMoveDirection");
static_assert(offsetof(LAIController_ChangeReverseMoveDirection, bReverse) == 0x000000, "Member 'LAIController_ChangeReverseMoveDirection::bReverse' has a wrong offset!");

// Function ProjectP.LAIController.CheckActionCategoryAndConsume
// 0x0018 (0x0018 - 0x0000)
struct LAIController_CheckActionCategoryAndConsume final
{
public:
	ELAITargetType                                TargetType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHostileType                                 HostileTargetType;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetCheckRange;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELActionCategory                              CheckActionCategory;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionCategory_AnyCodeName;                        // 0x000C(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckActionCategoryAndConsume) == 0x000004, "Wrong alignment on LAIController_CheckActionCategoryAndConsume");
static_assert(sizeof(LAIController_CheckActionCategoryAndConsume) == 0x000018, "Wrong size on LAIController_CheckActionCategoryAndConsume");
static_assert(offsetof(LAIController_CheckActionCategoryAndConsume, TargetType) == 0x000000, "Member 'LAIController_CheckActionCategoryAndConsume::TargetType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckActionCategoryAndConsume, HostileTargetType) == 0x000001, "Member 'LAIController_CheckActionCategoryAndConsume::HostileTargetType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckActionCategoryAndConsume, TargetCheckRange) == 0x000004, "Member 'LAIController_CheckActionCategoryAndConsume::TargetCheckRange' has a wrong offset!");
static_assert(offsetof(LAIController_CheckActionCategoryAndConsume, CheckActionCategory) == 0x000008, "Member 'LAIController_CheckActionCategoryAndConsume::CheckActionCategory' has a wrong offset!");
static_assert(offsetof(LAIController_CheckActionCategoryAndConsume, ActionCategory_AnyCodeName) == 0x00000C, "Member 'LAIController_CheckActionCategoryAndConsume::ActionCategory_AnyCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_CheckActionCategoryAndConsume, ReturnValue) == 0x000014, "Member 'LAIController_CheckActionCategoryAndConsume::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckMoveReduced
// 0x000C (0x000C - 0x0000)
struct LAIController_CheckMoveReduced final
{
public:
	float                                         ThresholdMoveAmount;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldingTime;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckMoveReduced) == 0x000004, "Wrong alignment on LAIController_CheckMoveReduced");
static_assert(sizeof(LAIController_CheckMoveReduced) == 0x00000C, "Wrong size on LAIController_CheckMoveReduced");
static_assert(offsetof(LAIController_CheckMoveReduced, ThresholdMoveAmount) == 0x000000, "Member 'LAIController_CheckMoveReduced::ThresholdMoveAmount' has a wrong offset!");
static_assert(offsetof(LAIController_CheckMoveReduced, HoldingTime) == 0x000004, "Member 'LAIController_CheckMoveReduced::HoldingTime' has a wrong offset!");
static_assert(offsetof(LAIController_CheckMoveReduced, ReturnValue) == 0x000008, "Member 'LAIController_CheckMoveReduced::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckOnceCondition
// 0x000C (0x000C - 0x0000)
struct LAIController_CheckOnceCondition final
{
public:
	class FName                                   ConditionName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckOnceCondition) == 0x000004, "Wrong alignment on LAIController_CheckOnceCondition");
static_assert(sizeof(LAIController_CheckOnceCondition) == 0x00000C, "Wrong size on LAIController_CheckOnceCondition");
static_assert(offsetof(LAIController_CheckOnceCondition, ConditionName) == 0x000000, "Member 'LAIController_CheckOnceCondition::ConditionName' has a wrong offset!");
static_assert(offsetof(LAIController_CheckOnceCondition, ReturnValue) == 0x000008, "Member 'LAIController_CheckOnceCondition::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckSelectedSkillRangeAngle
// 0x0010 (0x0010 - 0x0000)
struct LAIController_CheckSelectedSkillRangeAngle final
{
public:
	class AActor*                                 CheckActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckDistance;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckAngle;                                       // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckHeight;                                      // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckType                            OverrideRangeCheckType;                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckSelectedSkillRangeAngle) == 0x000008, "Wrong alignment on LAIController_CheckSelectedSkillRangeAngle");
static_assert(sizeof(LAIController_CheckSelectedSkillRangeAngle) == 0x000010, "Wrong size on LAIController_CheckSelectedSkillRangeAngle");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, CheckActor) == 0x000000, "Member 'LAIController_CheckSelectedSkillRangeAngle::CheckActor' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, MinMaxType) == 0x000008, "Member 'LAIController_CheckSelectedSkillRangeAngle::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, bCheckDistance) == 0x000009, "Member 'LAIController_CheckSelectedSkillRangeAngle::bCheckDistance' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, bCheckAngle) == 0x00000A, "Member 'LAIController_CheckSelectedSkillRangeAngle::bCheckAngle' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, bCheckHeight) == 0x00000B, "Member 'LAIController_CheckSelectedSkillRangeAngle::bCheckHeight' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, OverrideRangeCheckType) == 0x00000C, "Member 'LAIController_CheckSelectedSkillRangeAngle::OverrideRangeCheckType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSelectedSkillRangeAngle, ReturnValue) == 0x00000D, "Member 'LAIController_CheckSelectedSkillRangeAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckSkillApproachDist
// 0x0018 (0x0018 - 0x0000)
struct LAIController_CheckSkillApproachDist final
{
public:
	class AActor*                                 CheckActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDist;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDist;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckSkillApproachDist) == 0x000008, "Wrong alignment on LAIController_CheckSkillApproachDist");
static_assert(sizeof(LAIController_CheckSkillApproachDist) == 0x000018, "Wrong size on LAIController_CheckSkillApproachDist");
static_assert(offsetof(LAIController_CheckSkillApproachDist, CheckActor) == 0x000000, "Member 'LAIController_CheckSkillApproachDist::CheckActor' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSkillApproachDist, MinMaxType) == 0x000008, "Member 'LAIController_CheckSkillApproachDist::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSkillApproachDist, MinDist) == 0x00000C, "Member 'LAIController_CheckSkillApproachDist::MinDist' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSkillApproachDist, MaxDist) == 0x000010, "Member 'LAIController_CheckSkillApproachDist::MaxDist' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSkillApproachDist, ReturnValue) == 0x000014, "Member 'LAIController_CheckSkillApproachDist::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckSkillUseCount
// 0x000C (0x000C - 0x0000)
struct LAIController_CheckSkillUseCount final
{
public:
	ELAIUseSkillCountType                         UseSkillCountType;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckSkillUseCount) == 0x000004, "Wrong alignment on LAIController_CheckSkillUseCount");
static_assert(sizeof(LAIController_CheckSkillUseCount) == 0x00000C, "Wrong size on LAIController_CheckSkillUseCount");
static_assert(offsetof(LAIController_CheckSkillUseCount, UseSkillCountType) == 0x000000, "Member 'LAIController_CheckSkillUseCount::UseSkillCountType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSkillUseCount, Count) == 0x000004, "Member 'LAIController_CheckSkillUseCount::Count' has a wrong offset!");
static_assert(offsetof(LAIController_CheckSkillUseCount, ReturnValue) == 0x000008, "Member 'LAIController_CheckSkillUseCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckTargetAngleDeviation
// 0x0014 (0x0014 - 0x0000)
struct LAIController_CheckTargetAngleDeviation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeviationAngle;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckTargetAngleDeviation) == 0x000004, "Wrong alignment on LAIController_CheckTargetAngleDeviation");
static_assert(sizeof(LAIController_CheckTargetAngleDeviation) == 0x000014, "Wrong size on LAIController_CheckTargetAngleDeviation");
static_assert(offsetof(LAIController_CheckTargetAngleDeviation, TargetLocation) == 0x000000, "Member 'LAIController_CheckTargetAngleDeviation::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetAngleDeviation, DeviationAngle) == 0x00000C, "Member 'LAIController_CheckTargetAngleDeviation::DeviationAngle' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetAngleDeviation, ReturnValue) == 0x000010, "Member 'LAIController_CheckTargetAngleDeviation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckTargetRangeHeightAngleDist_PrimaryAngle
// 0x002C (0x002C - 0x0000)
struct LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle final
{
public:
	float                                         MinRange;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginDegree;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDegree;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckHeight;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckType                            RangeCheckType;                                    // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryTarget_StartAngle;                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrimaryTarget_EndAngle;                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideTargetToSelf_Angle;                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideTargetToSelf_Distance;                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle) == 0x000004, "Wrong alignment on LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle");
static_assert(sizeof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle) == 0x00002C, "Wrong size on LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, MinRange) == 0x000000, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::MinRange' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, MaxRange) == 0x000004, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, BeginDegree) == 0x000008, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::BeginDegree' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, EndDegree) == 0x00000C, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::EndDegree' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, CheckHeight) == 0x000010, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::CheckHeight' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, RangeCheckType) == 0x000014, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::RangeCheckType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, PrimaryTarget_StartAngle) == 0x000018, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::PrimaryTarget_StartAngle' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, PrimaryTarget_EndAngle) == 0x00001C, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::PrimaryTarget_EndAngle' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, OverrideTargetToSelf_Angle) == 0x000020, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::OverrideTargetToSelf_Angle' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, OverrideTargetToSelf_Distance) == 0x000024, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::OverrideTargetToSelf_Distance' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle, ReturnValue) == 0x000028, "Member 'LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckTargetRangeInAround
// 0x0018 (0x0018 - 0x0000)
struct LAIController_CheckTargetRangeInAround final
{
public:
	ELAIActorClassType                            ActorClassType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckDistance;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHostileType                                 TargetHostileType;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetCodeName;                                    // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckTargetRangeInAround) == 0x000004, "Wrong alignment on LAIController_CheckTargetRangeInAround");
static_assert(sizeof(LAIController_CheckTargetRangeInAround) == 0x000018, "Wrong size on LAIController_CheckTargetRangeInAround");
static_assert(offsetof(LAIController_CheckTargetRangeInAround, ActorClassType) == 0x000000, "Member 'LAIController_CheckTargetRangeInAround::ActorClassType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeInAround, CheckDistance) == 0x000004, "Member 'LAIController_CheckTargetRangeInAround::CheckDistance' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeInAround, TargetHostileType) == 0x000008, "Member 'LAIController_CheckTargetRangeInAround::TargetHostileType' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeInAround, TargetCodeName) == 0x00000C, "Member 'LAIController_CheckTargetRangeInAround::TargetCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_CheckTargetRangeInAround, ReturnValue) == 0x000014, "Member 'LAIController_CheckTargetRangeInAround::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.CheckWorldTriggerVolatile
// 0x0018 (0x0018 - 0x0000)
struct LAIController_CheckWorldTriggerVolatile final
{
public:
	class FString                                 TriggerName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_CheckWorldTriggerVolatile) == 0x000008, "Wrong alignment on LAIController_CheckWorldTriggerVolatile");
static_assert(sizeof(LAIController_CheckWorldTriggerVolatile) == 0x000018, "Wrong size on LAIController_CheckWorldTriggerVolatile");
static_assert(offsetof(LAIController_CheckWorldTriggerVolatile, TriggerName) == 0x000000, "Member 'LAIController_CheckWorldTriggerVolatile::TriggerName' has a wrong offset!");
static_assert(offsetof(LAIController_CheckWorldTriggerVolatile, ReturnValue) == 0x000010, "Member 'LAIController_CheckWorldTriggerVolatile::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.ChooseUseSkill
// 0x0020 (0x0020 - 0x0000)
struct LAIController_ChooseUseSkill final
{
public:
	bool                                          bCheckRange;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckAngle;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           RangeMinMaxType;                                   // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLNPCStandbySkill>              CustomSkillList;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bReselectIncludeCooltime;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_ChooseUseSkill) == 0x000008, "Wrong alignment on LAIController_ChooseUseSkill");
static_assert(sizeof(LAIController_ChooseUseSkill) == 0x000020, "Wrong size on LAIController_ChooseUseSkill");
static_assert(offsetof(LAIController_ChooseUseSkill, bCheckRange) == 0x000000, "Member 'LAIController_ChooseUseSkill::bCheckRange' has a wrong offset!");
static_assert(offsetof(LAIController_ChooseUseSkill, bCheckAngle) == 0x000001, "Member 'LAIController_ChooseUseSkill::bCheckAngle' has a wrong offset!");
static_assert(offsetof(LAIController_ChooseUseSkill, RangeMinMaxType) == 0x000002, "Member 'LAIController_ChooseUseSkill::RangeMinMaxType' has a wrong offset!");
static_assert(offsetof(LAIController_ChooseUseSkill, CustomSkillList) == 0x000008, "Member 'LAIController_ChooseUseSkill::CustomSkillList' has a wrong offset!");
static_assert(offsetof(LAIController_ChooseUseSkill, bReselectIncludeCooltime) == 0x000018, "Member 'LAIController_ChooseUseSkill::bReselectIncludeCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_ChooseUseSkill, ReturnValue) == 0x000019, "Member 'LAIController_ChooseUseSkill::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.ContinueSkill
// 0x000C (0x000C - 0x0000)
struct LAIController_ContinueSkill final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkillCooltime;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_ContinueSkill) == 0x000004, "Wrong alignment on LAIController_ContinueSkill");
static_assert(sizeof(LAIController_ContinueSkill) == 0x00000C, "Wrong size on LAIController_ContinueSkill");
static_assert(offsetof(LAIController_ContinueSkill, SkillCodeName) == 0x000000, "Member 'LAIController_ContinueSkill::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_ContinueSkill, bUseSkillCooltime) == 0x000008, "Member 'LAIController_ContinueSkill::bUseSkillCooltime' has a wrong offset!");

// Function ProjectP.LAIController.DoTeleport
// 0x0014 (0x0014 - 0x0000)
struct LAIController_DoTeleport final
{
public:
	ELAITargetType                                LocationTargetType;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITargetType                                DirectionTargetType;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLFloatInterval                        Distance;                                          // 0x0004(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFloatInterval                        Angle;                                             // 0x000C(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_DoTeleport) == 0x000004, "Wrong alignment on LAIController_DoTeleport");
static_assert(sizeof(LAIController_DoTeleport) == 0x000014, "Wrong size on LAIController_DoTeleport");
static_assert(offsetof(LAIController_DoTeleport, LocationTargetType) == 0x000000, "Member 'LAIController_DoTeleport::LocationTargetType' has a wrong offset!");
static_assert(offsetof(LAIController_DoTeleport, DirectionTargetType) == 0x000001, "Member 'LAIController_DoTeleport::DirectionTargetType' has a wrong offset!");
static_assert(offsetof(LAIController_DoTeleport, DirectionType) == 0x000002, "Member 'LAIController_DoTeleport::DirectionType' has a wrong offset!");
static_assert(offsetof(LAIController_DoTeleport, Distance) == 0x000004, "Member 'LAIController_DoTeleport::Distance' has a wrong offset!");
static_assert(offsetof(LAIController_DoTeleport, Angle) == 0x00000C, "Member 'LAIController_DoTeleport::Angle' has a wrong offset!");

// Function ProjectP.LAIController.ExecuteSkillTask
// 0x0018 (0x0018 - 0x0000)
struct LAIController_ExecuteSkillTask final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkillCooltime;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGlobalCooltime;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckCooltime;                                    // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckGlobalCooltime;                              // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceExecute;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNPCSkillLaunchResult                 OutResult;                                         // 0x0010(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_ExecuteSkillTask) == 0x000008, "Wrong alignment on LAIController_ExecuteSkillTask");
static_assert(sizeof(LAIController_ExecuteSkillTask) == 0x000018, "Wrong size on LAIController_ExecuteSkillTask");
static_assert(offsetof(LAIController_ExecuteSkillTask, SkillCodeName) == 0x000000, "Member 'LAIController_ExecuteSkillTask::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_ExecuteSkillTask, bUseSkillCooltime) == 0x000008, "Member 'LAIController_ExecuteSkillTask::bUseSkillCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_ExecuteSkillTask, bUseGlobalCooltime) == 0x000009, "Member 'LAIController_ExecuteSkillTask::bUseGlobalCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_ExecuteSkillTask, bCheckCooltime) == 0x00000A, "Member 'LAIController_ExecuteSkillTask::bCheckCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_ExecuteSkillTask, bCheckGlobalCooltime) == 0x00000B, "Member 'LAIController_ExecuteSkillTask::bCheckGlobalCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_ExecuteSkillTask, bForceExecute) == 0x00000C, "Member 'LAIController_ExecuteSkillTask::bForceExecute' has a wrong offset!");
static_assert(offsetof(LAIController_ExecuteSkillTask, OutResult) == 0x000010, "Member 'LAIController_ExecuteSkillTask::OutResult' has a wrong offset!");

// Function ProjectP.LAIController.GetCurrentBehaviorTree
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetCurrentBehaviorTree final
{
public:
	class UBehaviorTree*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetCurrentBehaviorTree) == 0x000008, "Wrong alignment on LAIController_GetCurrentBehaviorTree");
static_assert(sizeof(LAIController_GetCurrentBehaviorTree) == 0x000008, "Wrong size on LAIController_GetCurrentBehaviorTree");
static_assert(offsetof(LAIController_GetCurrentBehaviorTree, ReturnValue) == 0x000000, "Member 'LAIController_GetCurrentBehaviorTree::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetHomeLocation
// 0x000C (0x000C - 0x0000)
struct LAIController_GetHomeLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetHomeLocation) == 0x000004, "Wrong alignment on LAIController_GetHomeLocation");
static_assert(sizeof(LAIController_GetHomeLocation) == 0x00000C, "Wrong size on LAIController_GetHomeLocation");
static_assert(offsetof(LAIController_GetHomeLocation, ReturnValue) == 0x000000, "Member 'LAIController_GetHomeLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetLastUsedSkillCodeName
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetLastUsedSkillCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetLastUsedSkillCodeName) == 0x000004, "Wrong alignment on LAIController_GetLastUsedSkillCodeName");
static_assert(sizeof(LAIController_GetLastUsedSkillCodeName) == 0x000008, "Wrong size on LAIController_GetLastUsedSkillCodeName");
static_assert(offsetof(LAIController_GetLastUsedSkillCodeName, ReturnValue) == 0x000000, "Member 'LAIController_GetLastUsedSkillCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetMasterActor
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetMasterActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetMasterActor) == 0x000008, "Wrong alignment on LAIController_GetMasterActor");
static_assert(sizeof(LAIController_GetMasterActor) == 0x000008, "Wrong size on LAIController_GetMasterActor");
static_assert(offsetof(LAIController_GetMasterActor, ReturnValue) == 0x000000, "Member 'LAIController_GetMasterActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetNpcInfo
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetNpcInfo final
{
public:
	struct FNPCInfoPtr                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetNpcInfo) == 0x000008, "Wrong alignment on LAIController_GetNpcInfo");
static_assert(sizeof(LAIController_GetNpcInfo) == 0x000008, "Wrong size on LAIController_GetNpcInfo");
static_assert(offsetof(LAIController_GetNpcInfo, ReturnValue) == 0x000000, "Member 'LAIController_GetNpcInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetPrimaryTarget
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetPrimaryTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetPrimaryTarget) == 0x000008, "Wrong alignment on LAIController_GetPrimaryTarget");
static_assert(sizeof(LAIController_GetPrimaryTarget) == 0x000008, "Wrong size on LAIController_GetPrimaryTarget");
static_assert(offsetof(LAIController_GetPrimaryTarget, ReturnValue) == 0x000000, "Member 'LAIController_GetPrimaryTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetRandomPointInStrafe
// 0x0038 (0x0038 - 0x0000)
struct LAIController_GetRandomPointInStrafe final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomLocation;                                    // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_GetRandomPointInStrafe) == 0x000008, "Wrong alignment on LAIController_GetRandomPointInStrafe");
static_assert(sizeof(LAIController_GetRandomPointInStrafe) == 0x000038, "Wrong size on LAIController_GetRandomPointInStrafe");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, TargetActor) == 0x000000, "Member 'LAIController_GetRandomPointInStrafe::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, MinDistance) == 0x000008, "Member 'LAIController_GetRandomPointInStrafe::MinDistance' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, MaxDistance) == 0x00000C, "Member 'LAIController_GetRandomPointInStrafe::MaxDistance' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, MinAngle) == 0x000010, "Member 'LAIController_GetRandomPointInStrafe::MinAngle' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, MaxAngle) == 0x000014, "Member 'LAIController_GetRandomPointInStrafe::MaxAngle' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, RandomLocation) == 0x000018, "Member 'LAIController_GetRandomPointInStrafe::RandomLocation' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, FilterClass) == 0x000028, "Member 'LAIController_GetRandomPointInStrafe::FilterClass' has a wrong offset!");
static_assert(offsetof(LAIController_GetRandomPointInStrafe, ReturnValue) == 0x000030, "Member 'LAIController_GetRandomPointInStrafe::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetSelectedSkillCodeName
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetSelectedSkillCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetSelectedSkillCodeName) == 0x000004, "Wrong alignment on LAIController_GetSelectedSkillCodeName");
static_assert(sizeof(LAIController_GetSelectedSkillCodeName) == 0x000008, "Wrong size on LAIController_GetSelectedSkillCodeName");
static_assert(offsetof(LAIController_GetSelectedSkillCodeName, ReturnValue) == 0x000000, "Member 'LAIController_GetSelectedSkillCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetWarningLocation
// 0x000C (0x000C - 0x0000)
struct LAIController_GetWarningLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetWarningLocation) == 0x000004, "Wrong alignment on LAIController_GetWarningLocation");
static_assert(sizeof(LAIController_GetWarningLocation) == 0x00000C, "Wrong size on LAIController_GetWarningLocation");
static_assert(offsetof(LAIController_GetWarningLocation, ReturnValue) == 0x000000, "Member 'LAIController_GetWarningLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.HasMoveGoalReached
// 0x0038 (0x0038 - 0x0000)
struct LAIController_HasMoveGoalReached final
{
public:
	struct FLAIMovementGoal                       Goal;                                              // 0x0000(0x002C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bProjectPoint;                                     // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustumAcceptibleRadius;                            // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_HasMoveGoalReached) == 0x000004, "Wrong alignment on LAIController_HasMoveGoalReached");
static_assert(sizeof(LAIController_HasMoveGoalReached) == 0x000038, "Wrong size on LAIController_HasMoveGoalReached");
static_assert(offsetof(LAIController_HasMoveGoalReached, Goal) == 0x000000, "Member 'LAIController_HasMoveGoalReached::Goal' has a wrong offset!");
static_assert(offsetof(LAIController_HasMoveGoalReached, bProjectPoint) == 0x00002C, "Member 'LAIController_HasMoveGoalReached::bProjectPoint' has a wrong offset!");
static_assert(offsetof(LAIController_HasMoveGoalReached, CustumAcceptibleRadius) == 0x000030, "Member 'LAIController_HasMoveGoalReached::CustumAcceptibleRadius' has a wrong offset!");
static_assert(offsetof(LAIController_HasMoveGoalReached, ReturnValue) == 0x000034, "Member 'LAIController_HasMoveGoalReached::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.HasMoveReached
// 0x0030 (0x0030 - 0x0000)
struct LAIController_HasMoveReached final
{
public:
	struct FLAIObjective                          Target;                                            // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bProjectPoint;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustumAcceptibleRadius;                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_HasMoveReached) == 0x000004, "Wrong alignment on LAIController_HasMoveReached");
static_assert(sizeof(LAIController_HasMoveReached) == 0x000030, "Wrong size on LAIController_HasMoveReached");
static_assert(offsetof(LAIController_HasMoveReached, Target) == 0x000000, "Member 'LAIController_HasMoveReached::Target' has a wrong offset!");
static_assert(offsetof(LAIController_HasMoveReached, bProjectPoint) == 0x000024, "Member 'LAIController_HasMoveReached::bProjectPoint' has a wrong offset!");
static_assert(offsetof(LAIController_HasMoveReached, CustumAcceptibleRadius) == 0x000028, "Member 'LAIController_HasMoveReached::CustumAcceptibleRadius' has a wrong offset!");
static_assert(offsetof(LAIController_HasMoveReached, ReturnValue) == 0x00002C, "Member 'LAIController_HasMoveReached::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.InitBehaviorTree
// 0x0008 (0x0008 - 0x0000)
struct LAIController_InitBehaviorTree final
{
public:
	class UBehaviorTree*                          BTree;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_InitBehaviorTree) == 0x000008, "Wrong alignment on LAIController_InitBehaviorTree");
static_assert(sizeof(LAIController_InitBehaviorTree) == 0x000008, "Wrong size on LAIController_InitBehaviorTree");
static_assert(offsetof(LAIController_InitBehaviorTree, BTree) == 0x000000, "Member 'LAIController_InitBehaviorTree::BTree' has a wrong offset!");

// Function ProjectP.LAIController.InitBehaviorTreeState
// 0x0008 (0x0008 - 0x0000)
struct LAIController_InitBehaviorTreeState final
{
public:
	class FName                                   InStateName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_InitBehaviorTreeState) == 0x000004, "Wrong alignment on LAIController_InitBehaviorTreeState");
static_assert(sizeof(LAIController_InitBehaviorTreeState) == 0x000008, "Wrong size on LAIController_InitBehaviorTreeState");
static_assert(offsetof(LAIController_InitBehaviorTreeState, InStateName) == 0x000000, "Member 'LAIController_InitBehaviorTreeState::InStateName' has a wrong offset!");

// Function ProjectP.LAIController.IsApplyBoostAI
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsApplyBoostAI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsApplyBoostAI) == 0x000001, "Wrong alignment on LAIController_IsApplyBoostAI");
static_assert(sizeof(LAIController_IsApplyBoostAI) == 0x000001, "Wrong size on LAIController_IsApplyBoostAI");
static_assert(offsetof(LAIController_IsApplyBoostAI, ReturnValue) == 0x000000, "Member 'LAIController_IsApplyBoostAI::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsExistDamageEvent
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsExistDamageEvent final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsExistDamageEvent) == 0x000001, "Wrong alignment on LAIController_IsExistDamageEvent");
static_assert(sizeof(LAIController_IsExistDamageEvent) == 0x000001, "Wrong size on LAIController_IsExistDamageEvent");
static_assert(offsetof(LAIController_IsExistDamageEvent, ReturnValue) == 0x000000, "Member 'LAIController_IsExistDamageEvent::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsLaunchSkill
// 0x0010 (0x0010 - 0x0000)
struct LAIController_IsLaunchSkill final
{
public:
	class ULActBase*                              Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_IsLaunchSkill) == 0x000008, "Wrong alignment on LAIController_IsLaunchSkill");
static_assert(sizeof(LAIController_IsLaunchSkill) == 0x000010, "Wrong size on LAIController_IsLaunchSkill");
static_assert(offsetof(LAIController_IsLaunchSkill, Action) == 0x000000, "Member 'LAIController_IsLaunchSkill::Action' has a wrong offset!");
static_assert(offsetof(LAIController_IsLaunchSkill, ReturnValue) == 0x000008, "Member 'LAIController_IsLaunchSkill::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsPathWayMoving
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsPathWayMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsPathWayMoving) == 0x000001, "Wrong alignment on LAIController_IsPathWayMoving");
static_assert(sizeof(LAIController_IsPathWayMoving) == 0x000001, "Wrong size on LAIController_IsPathWayMoving");
static_assert(offsetof(LAIController_IsPathWayMoving, ReturnValue) == 0x000000, "Member 'LAIController_IsPathWayMoving::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsSkillCooltime
// 0x000C (0x000C - 0x0000)
struct LAIController_IsSkillCooltime final
{
public:
	class FName                                   SkillId;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_IsSkillCooltime) == 0x000004, "Wrong alignment on LAIController_IsSkillCooltime");
static_assert(sizeof(LAIController_IsSkillCooltime) == 0x00000C, "Wrong size on LAIController_IsSkillCooltime");
static_assert(offsetof(LAIController_IsSkillCooltime, SkillId) == 0x000000, "Member 'LAIController_IsSkillCooltime::SkillId' has a wrong offset!");
static_assert(offsetof(LAIController_IsSkillCooltime, ReturnValue) == 0x000008, "Member 'LAIController_IsSkillCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsSkillGlobalCooltime
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsSkillGlobalCooltime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsSkillGlobalCooltime) == 0x000001, "Wrong alignment on LAIController_IsSkillGlobalCooltime");
static_assert(sizeof(LAIController_IsSkillGlobalCooltime) == 0x000001, "Wrong size on LAIController_IsSkillGlobalCooltime");
static_assert(offsetof(LAIController_IsSkillGlobalCooltime, ReturnValue) == 0x000000, "Member 'LAIController_IsSkillGlobalCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsStrafeMove
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsStrafeMove final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsStrafeMove) == 0x000001, "Wrong alignment on LAIController_IsStrafeMove");
static_assert(sizeof(LAIController_IsStrafeMove) == 0x000001, "Wrong size on LAIController_IsStrafeMove");
static_assert(offsetof(LAIController_IsStrafeMove, ReturnValue) == 0x000000, "Member 'LAIController_IsStrafeMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsWaitOrFinishWayPoint
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsWaitOrFinishWayPoint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsWaitOrFinishWayPoint) == 0x000001, "Wrong alignment on LAIController_IsWaitOrFinishWayPoint");
static_assert(sizeof(LAIController_IsWaitOrFinishWayPoint) == 0x000001, "Wrong size on LAIController_IsWaitOrFinishWayPoint");
static_assert(offsetof(LAIController_IsWaitOrFinishWayPoint, ReturnValue) == 0x000000, "Member 'LAIController_IsWaitOrFinishWayPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.ManipulateTimer
// 0x000C (0x000C - 0x0000)
struct LAIController_ManipulateTimer final
{
public:
	class FName                                   TimerCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITimerFunctionType                         FunctionType;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_ManipulateTimer) == 0x000004, "Wrong alignment on LAIController_ManipulateTimer");
static_assert(sizeof(LAIController_ManipulateTimer) == 0x00000C, "Wrong size on LAIController_ManipulateTimer");
static_assert(offsetof(LAIController_ManipulateTimer, TimerCodeName) == 0x000000, "Member 'LAIController_ManipulateTimer::TimerCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_ManipulateTimer, FunctionType) == 0x000008, "Member 'LAIController_ManipulateTimer::FunctionType' has a wrong offset!");

// Function ProjectP.LAIController.ModifyCooltime
// 0x0020 (0x0020 - 0x0000)
struct LAIController_ModifyCooltime final
{
public:
	ELModifyCooltimeChangeType                    ChangeType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELModifyCooltimeTargetType                    TargetType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SkillCodeNames;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bExceptSkillCodeNames;                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIFloatValueType                            ValueType;                                         // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolTime;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_ModifyCooltime) == 0x000008, "Wrong alignment on LAIController_ModifyCooltime");
static_assert(sizeof(LAIController_ModifyCooltime) == 0x000020, "Wrong size on LAIController_ModifyCooltime");
static_assert(offsetof(LAIController_ModifyCooltime, ChangeType) == 0x000000, "Member 'LAIController_ModifyCooltime::ChangeType' has a wrong offset!");
static_assert(offsetof(LAIController_ModifyCooltime, TargetType) == 0x000001, "Member 'LAIController_ModifyCooltime::TargetType' has a wrong offset!");
static_assert(offsetof(LAIController_ModifyCooltime, SkillCodeNames) == 0x000008, "Member 'LAIController_ModifyCooltime::SkillCodeNames' has a wrong offset!");
static_assert(offsetof(LAIController_ModifyCooltime, bExceptSkillCodeNames) == 0x000018, "Member 'LAIController_ModifyCooltime::bExceptSkillCodeNames' has a wrong offset!");
static_assert(offsetof(LAIController_ModifyCooltime, ValueType) == 0x000019, "Member 'LAIController_ModifyCooltime::ValueType' has a wrong offset!");
static_assert(offsetof(LAIController_ModifyCooltime, CoolTime) == 0x00001C, "Member 'LAIController_ModifyCooltime::CoolTime' has a wrong offset!");

// Function ProjectP.LAIController.MoveToGoal
// 0x00EC (0x00EC - 0x0000)
struct LAIController_MoveToGoal final
{
public:
	struct FLAIMovementID                         CurrMovementID;                                    // 0x0000(0x004C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIMovementGoal                       Goal;                                              // 0x004C(0x002C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIMovementDirection                  Direction;                                         // 0x0078(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIMovementID                         ReturnValue;                                       // 0x00A0(0x004C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToGoal) == 0x000004, "Wrong alignment on LAIController_MoveToGoal");
static_assert(sizeof(LAIController_MoveToGoal) == 0x0000EC, "Wrong size on LAIController_MoveToGoal");
static_assert(offsetof(LAIController_MoveToGoal, CurrMovementID) == 0x000000, "Member 'LAIController_MoveToGoal::CurrMovementID' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToGoal, Goal) == 0x00004C, "Member 'LAIController_MoveToGoal::Goal' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToGoal, Direction) == 0x000078, "Member 'LAIController_MoveToGoal::Direction' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToGoal, ReturnValue) == 0x0000A0, "Member 'LAIController_MoveToGoal::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToPosition
// 0x0048 (0x0048 - 0x0000)
struct LAIController_MoveToPosition final
{
public:
	struct FLAIMovementGoal                       Goal;                                              // 0x0000(0x002C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationRate;                                      // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTurnAround;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RotateAngleOverride;                               // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIMoveSpeedType                             MoveSpeedType;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeed;                                         // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationCooltime;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMoveBehaviorID                     ReturnValue;                                       // 0x0044(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToPosition) == 0x000004, "Wrong alignment on LAIController_MoveToPosition");
static_assert(sizeof(LAIController_MoveToPosition) == 0x000048, "Wrong size on LAIController_MoveToPosition");
static_assert(offsetof(LAIController_MoveToPosition, Goal) == 0x000000, "Member 'LAIController_MoveToPosition::Goal' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, RotationRate) == 0x00002C, "Member 'LAIController_MoveToPosition::RotationRate' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, bUseTurnAround) == 0x000030, "Member 'LAIController_MoveToPosition::bUseTurnAround' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, RotateAngleOverride) == 0x000034, "Member 'LAIController_MoveToPosition::RotateAngleOverride' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, MoveSpeedType) == 0x000038, "Member 'LAIController_MoveToPosition::MoveSpeedType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, MoveSpeed) == 0x00003C, "Member 'LAIController_MoveToPosition::MoveSpeed' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, RotationCooltime) == 0x000040, "Member 'LAIController_MoveToPosition::RotationCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPosition, ReturnValue) == 0x000044, "Member 'LAIController_MoveToPosition::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToPositionBack
// 0x003C (0x003C - 0x0000)
struct LAIController_MoveToPositionBack final
{
public:
	struct FLAIMovementGoal                       Goal;                                              // 0x0000(0x002C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationRate;                                      // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIMoveSpeedType                             MoveSpeedType;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeed;                                         // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMoveBehaviorID                     ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToPositionBack) == 0x000004, "Wrong alignment on LAIController_MoveToPositionBack");
static_assert(sizeof(LAIController_MoveToPositionBack) == 0x00003C, "Wrong size on LAIController_MoveToPositionBack");
static_assert(offsetof(LAIController_MoveToPositionBack, Goal) == 0x000000, "Member 'LAIController_MoveToPositionBack::Goal' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPositionBack, RotationRate) == 0x00002C, "Member 'LAIController_MoveToPositionBack::RotationRate' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPositionBack, MoveSpeedType) == 0x000030, "Member 'LAIController_MoveToPositionBack::MoveSpeedType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPositionBack, MoveSpeed) == 0x000034, "Member 'LAIController_MoveToPositionBack::MoveSpeed' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToPositionBack, ReturnValue) == 0x000038, "Member 'LAIController_MoveToPositionBack::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToRandomRoamSelf
// 0x00A0 (0x00A0 - 0x0000)
struct LAIController_MoveToRandomRoamSelf final
{
public:
	struct FLAIMovementID                         CurrMovementID;                                    // 0x0000(0x004C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMovementID                         ReturnValue;                                       // 0x0054(0x004C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToRandomRoamSelf) == 0x000004, "Wrong alignment on LAIController_MoveToRandomRoamSelf");
static_assert(sizeof(LAIController_MoveToRandomRoamSelf) == 0x0000A0, "Wrong size on LAIController_MoveToRandomRoamSelf");
static_assert(offsetof(LAIController_MoveToRandomRoamSelf, CurrMovementID) == 0x000000, "Member 'LAIController_MoveToRandomRoamSelf::CurrMovementID' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamSelf, DirectionType) == 0x00004C, "Member 'LAIController_MoveToRandomRoamSelf::DirectionType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamSelf, Distance) == 0x000050, "Member 'LAIController_MoveToRandomRoamSelf::Distance' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamSelf, ReturnValue) == 0x000054, "Member 'LAIController_MoveToRandomRoamSelf::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToRandomRoamStrafe
// 0x00B8 (0x00B8 - 0x0000)
struct LAIController_MoveToRandomRoamStrafe final
{
public:
	struct FLAIMovementID                         CurrMovementID;                                    // 0x0000(0x004C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMovementID                         ReturnValue;                                       // 0x0068(0x004C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_MoveToRandomRoamStrafe) == 0x000008, "Wrong alignment on LAIController_MoveToRandomRoamStrafe");
static_assert(sizeof(LAIController_MoveToRandomRoamStrafe) == 0x0000B8, "Wrong size on LAIController_MoveToRandomRoamStrafe");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, CurrMovementID) == 0x000000, "Member 'LAIController_MoveToRandomRoamStrafe::CurrMovementID' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, DirectionType) == 0x00004C, "Member 'LAIController_MoveToRandomRoamStrafe::DirectionType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, TargetActor) == 0x000050, "Member 'LAIController_MoveToRandomRoamStrafe::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, MinDistance) == 0x000058, "Member 'LAIController_MoveToRandomRoamStrafe::MinDistance' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, MaxDistance) == 0x00005C, "Member 'LAIController_MoveToRandomRoamStrafe::MaxDistance' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, MinAngle) == 0x000060, "Member 'LAIController_MoveToRandomRoamStrafe::MinAngle' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, MaxAngle) == 0x000064, "Member 'LAIController_MoveToRandomRoamStrafe::MaxAngle' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToRandomRoamStrafe, ReturnValue) == 0x000068, "Member 'LAIController_MoveToRandomRoamStrafe::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToSkill
// 0x009C (0x009C - 0x0000)
struct LAIController_MoveToSkill final
{
public:
	struct FLAIMovementID                         CurrMovementID;                                    // 0x0000(0x004C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x004D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAIMovementID                         ReturnValue;                                       // 0x0050(0x004C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToSkill) == 0x000004, "Wrong alignment on LAIController_MoveToSkill");
static_assert(sizeof(LAIController_MoveToSkill) == 0x00009C, "Wrong size on LAIController_MoveToSkill");
static_assert(offsetof(LAIController_MoveToSkill, CurrMovementID) == 0x000000, "Member 'LAIController_MoveToSkill::CurrMovementID' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToSkill, TargetType) == 0x00004C, "Member 'LAIController_MoveToSkill::TargetType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToSkill, DirectionType) == 0x00004D, "Member 'LAIController_MoveToSkill::DirectionType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToSkill, ReturnValue) == 0x000050, "Member 'LAIController_MoveToSkill::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToStrafe
// 0x0014 (0x0014 - 0x0000)
struct LAIController_MoveToStrafe final
{
public:
	ELAIMoveDirection                             MoveDirection;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveTime;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIMoveSpeedType                             MoveSpeedType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeed;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMoveBehaviorID                     ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToStrafe) == 0x000004, "Wrong alignment on LAIController_MoveToStrafe");
static_assert(sizeof(LAIController_MoveToStrafe) == 0x000014, "Wrong size on LAIController_MoveToStrafe");
static_assert(offsetof(LAIController_MoveToStrafe, MoveDirection) == 0x000000, "Member 'LAIController_MoveToStrafe::MoveDirection' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToStrafe, MoveTime) == 0x000004, "Member 'LAIController_MoveToStrafe::MoveTime' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToStrafe, MoveSpeedType) == 0x000008, "Member 'LAIController_MoveToStrafe::MoveSpeedType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToStrafe, MoveSpeed) == 0x00000C, "Member 'LAIController_MoveToStrafe::MoveSpeed' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToStrafe, ReturnValue) == 0x000010, "Member 'LAIController_MoveToStrafe::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.MoveToType
// 0x009C (0x009C - 0x0000)
struct LAIController_MoveToType final
{
public:
	struct FLAIMovementID                         CurrMovementID;                                    // 0x0000(0x004C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x004D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAIMovementID                         ReturnValue;                                       // 0x0050(0x004C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_MoveToType) == 0x000004, "Wrong alignment on LAIController_MoveToType");
static_assert(sizeof(LAIController_MoveToType) == 0x00009C, "Wrong size on LAIController_MoveToType");
static_assert(offsetof(LAIController_MoveToType, CurrMovementID) == 0x000000, "Member 'LAIController_MoveToType::CurrMovementID' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToType, TargetType) == 0x00004C, "Member 'LAIController_MoveToType::TargetType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToType, DirectionType) == 0x00004D, "Member 'LAIController_MoveToType::DirectionType' has a wrong offset!");
static_assert(offsetof(LAIController_MoveToType, ReturnValue) == 0x000050, "Member 'LAIController_MoveToType::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.OnMovementNavigationQueryFilter
// 0x0008 (0x0008 - 0x0000)
struct LAIController_OnMovementNavigationQueryFilter final
{
public:
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_OnMovementNavigationQueryFilter) == 0x000008, "Wrong alignment on LAIController_OnMovementNavigationQueryFilter");
static_assert(sizeof(LAIController_OnMovementNavigationQueryFilter) == 0x000008, "Wrong size on LAIController_OnMovementNavigationQueryFilter");
static_assert(offsetof(LAIController_OnMovementNavigationQueryFilter, FilterClass) == 0x000000, "Member 'LAIController_OnMovementNavigationQueryFilter::FilterClass' has a wrong offset!");

// Function ProjectP.LAIController.QueryTargetCondition
// 0x0002 (0x0002 - 0x0000)
struct LAIController_QueryTargetCondition final
{
public:
	ELQueryTargetConditionType                    ConditionType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_QueryTargetCondition) == 0x000001, "Wrong alignment on LAIController_QueryTargetCondition");
static_assert(sizeof(LAIController_QueryTargetCondition) == 0x000002, "Wrong size on LAIController_QueryTargetCondition");
static_assert(offsetof(LAIController_QueryTargetCondition, ConditionType) == 0x000000, "Member 'LAIController_QueryTargetCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(LAIController_QueryTargetCondition, ReturnValue) == 0x000001, "Member 'LAIController_QueryTargetCondition::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.RemoveMoveSpeedRate
// 0x0008 (0x0008 - 0x0000)
struct LAIController_RemoveMoveSpeedRate final
{
public:
	class FName                                   MoveSpeedRateName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_RemoveMoveSpeedRate) == 0x000004, "Wrong alignment on LAIController_RemoveMoveSpeedRate");
static_assert(sizeof(LAIController_RemoveMoveSpeedRate) == 0x000008, "Wrong size on LAIController_RemoveMoveSpeedRate");
static_assert(offsetof(LAIController_RemoveMoveSpeedRate, MoveSpeedRateName) == 0x000000, "Member 'LAIController_RemoveMoveSpeedRate::MoveSpeedRateName' has a wrong offset!");

// Function ProjectP.LAIController.RemovePauseAI
// 0x000C (0x000C - 0x0000)
struct LAIController_RemovePauseAI final
{
public:
	class FName                                   PauseName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintain;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_RemovePauseAI) == 0x000004, "Wrong alignment on LAIController_RemovePauseAI");
static_assert(sizeof(LAIController_RemovePauseAI) == 0x00000C, "Wrong size on LAIController_RemovePauseAI");
static_assert(offsetof(LAIController_RemovePauseAI, PauseName) == 0x000000, "Member 'LAIController_RemovePauseAI::PauseName' has a wrong offset!");
static_assert(offsetof(LAIController_RemovePauseAI, bMaintain) == 0x000008, "Member 'LAIController_RemovePauseAI::bMaintain' has a wrong offset!");

// Function ProjectP.LAIController.RequestMoveToWayPoint
// 0x0014 (0x0014 - 0x0000)
struct LAIController_RequestMoveToWayPoint final
{
public:
	class FName                                   PathWayCodeName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RotateActionDeviationAngle;                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIMoveSpeedType                             MoveSpeedType;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeedRate;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_RequestMoveToWayPoint) == 0x000004, "Wrong alignment on LAIController_RequestMoveToWayPoint");
static_assert(sizeof(LAIController_RequestMoveToWayPoint) == 0x000014, "Wrong size on LAIController_RequestMoveToWayPoint");
static_assert(offsetof(LAIController_RequestMoveToWayPoint, PathWayCodeName) == 0x000000, "Member 'LAIController_RequestMoveToWayPoint::PathWayCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_RequestMoveToWayPoint, RotateActionDeviationAngle) == 0x000008, "Member 'LAIController_RequestMoveToWayPoint::RotateActionDeviationAngle' has a wrong offset!");
static_assert(offsetof(LAIController_RequestMoveToWayPoint, MoveSpeedType) == 0x00000C, "Member 'LAIController_RequestMoveToWayPoint::MoveSpeedType' has a wrong offset!");
static_assert(offsetof(LAIController_RequestMoveToWayPoint, MoveSpeedRate) == 0x000010, "Member 'LAIController_RequestMoveToWayPoint::MoveSpeedRate' has a wrong offset!");

// Function ProjectP.LAIController.SendWorldTrigger
// 0x0028 (0x0028 - 0x0000)
struct LAIController_SendWorldTrigger final
{
public:
	ELAISendWorldTriggerType                      TriggerType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TriggerString;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendRadius;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCCodeName;                                       // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_SendWorldTrigger) == 0x000008, "Wrong alignment on LAIController_SendWorldTrigger");
static_assert(sizeof(LAIController_SendWorldTrigger) == 0x000028, "Wrong size on LAIController_SendWorldTrigger");
static_assert(offsetof(LAIController_SendWorldTrigger, TriggerType) == 0x000000, "Member 'LAIController_SendWorldTrigger::TriggerType' has a wrong offset!");
static_assert(offsetof(LAIController_SendWorldTrigger, TriggerString) == 0x000008, "Member 'LAIController_SendWorldTrigger::TriggerString' has a wrong offset!");
static_assert(offsetof(LAIController_SendWorldTrigger, SendRadius) == 0x000018, "Member 'LAIController_SendWorldTrigger::SendRadius' has a wrong offset!");
static_assert(offsetof(LAIController_SendWorldTrigger, NPCCodeName) == 0x00001C, "Member 'LAIController_SendWorldTrigger::NPCCodeName' has a wrong offset!");

// Function ProjectP.LAIController.SenseEvent
// 0x0018 (0x0018 - 0x0000)
struct LAIController_SenseEvent final
{
public:
	struct FLAISenseTakeLocation                  TakeLocation;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_SenseEvent) == 0x000004, "Wrong alignment on LAIController_SenseEvent");
static_assert(sizeof(LAIController_SenseEvent) == 0x000018, "Wrong size on LAIController_SenseEvent");
static_assert(offsetof(LAIController_SenseEvent, TakeLocation) == 0x000000, "Member 'LAIController_SenseEvent::TakeLocation' has a wrong offset!");

// Function ProjectP.LAIController.SetForcePrimaryTarget
// 0x0008 (0x0008 - 0x0000)
struct LAIController_SetForcePrimaryTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_SetForcePrimaryTarget) == 0x000008, "Wrong alignment on LAIController_SetForcePrimaryTarget");
static_assert(sizeof(LAIController_SetForcePrimaryTarget) == 0x000008, "Wrong size on LAIController_SetForcePrimaryTarget");
static_assert(offsetof(LAIController_SetForcePrimaryTarget, TargetActor) == 0x000000, "Member 'LAIController_SetForcePrimaryTarget::TargetActor' has a wrong offset!");

// Function ProjectP.LAIController.SetRotationCooltime
// 0x0004 (0x0004 - 0x0000)
struct LAIController_SetRotationCooltime final
{
public:
	float                                         CoolTime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_SetRotationCooltime) == 0x000004, "Wrong alignment on LAIController_SetRotationCooltime");
static_assert(sizeof(LAIController_SetRotationCooltime) == 0x000004, "Wrong size on LAIController_SetRotationCooltime");
static_assert(offsetof(LAIController_SetRotationCooltime, CoolTime) == 0x000000, "Member 'LAIController_SetRotationCooltime::CoolTime' has a wrong offset!");

// Function ProjectP.LAIController.SetSenseEnabled
// 0x0002 (0x0002 - 0x0000)
struct LAIController_SetSenseEnabled final
{
public:
	ELAISense                                     Sense;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_SetSenseEnabled) == 0x000001, "Wrong alignment on LAIController_SetSenseEnabled");
static_assert(sizeof(LAIController_SetSenseEnabled) == 0x000002, "Wrong size on LAIController_SetSenseEnabled");
static_assert(offsetof(LAIController_SetSenseEnabled, Sense) == 0x000000, "Member 'LAIController_SetSenseEnabled::Sense' has a wrong offset!");
static_assert(offsetof(LAIController_SetSenseEnabled, bEnable) == 0x000001, "Member 'LAIController_SetSenseEnabled::bEnable' has a wrong offset!");

// Function ProjectP.LAIController.SetSkillGlobalCooltime
// 0x0008 (0x0008 - 0x0000)
struct LAIController_SetSkillGlobalCooltime final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_SetSkillGlobalCooltime) == 0x000004, "Wrong alignment on LAIController_SetSkillGlobalCooltime");
static_assert(sizeof(LAIController_SetSkillGlobalCooltime) == 0x000008, "Wrong size on LAIController_SetSkillGlobalCooltime");
static_assert(offsetof(LAIController_SetSkillGlobalCooltime, Min) == 0x000000, "Member 'LAIController_SetSkillGlobalCooltime::Min' has a wrong offset!");
static_assert(offsetof(LAIController_SetSkillGlobalCooltime, Max) == 0x000004, "Member 'LAIController_SetSkillGlobalCooltime::Max' has a wrong offset!");

// Function ProjectP.LAIController.SetSkillList
// 0x0018 (0x0018 - 0x0000)
struct LAIController_SetSkillList final
{
public:
	TArray<struct FLNPCStandbySkill>              SkillList;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bResetSkillCooltime;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_SetSkillList) == 0x000008, "Wrong alignment on LAIController_SetSkillList");
static_assert(sizeof(LAIController_SetSkillList) == 0x000018, "Wrong size on LAIController_SetSkillList");
static_assert(offsetof(LAIController_SetSkillList, SkillList) == 0x000000, "Member 'LAIController_SetSkillList::SkillList' has a wrong offset!");
static_assert(offsetof(LAIController_SetSkillList, bResetSkillCooltime) == 0x000010, "Member 'LAIController_SetSkillList::bResetSkillCooltime' has a wrong offset!");

// Function ProjectP.LAIController.Sight_Check
// 0x0010 (0x0010 - 0x0000)
struct LAIController_Sight_Check final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddSightDistance;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_Sight_Check) == 0x000008, "Wrong alignment on LAIController_Sight_Check");
static_assert(sizeof(LAIController_Sight_Check) == 0x000010, "Wrong size on LAIController_Sight_Check");
static_assert(offsetof(LAIController_Sight_Check, Actor) == 0x000000, "Member 'LAIController_Sight_Check::Actor' has a wrong offset!");
static_assert(offsetof(LAIController_Sight_Check, AddSightDistance) == 0x000008, "Member 'LAIController_Sight_Check::AddSightDistance' has a wrong offset!");
static_assert(offsetof(LAIController_Sight_Check, ReturnValue) == 0x00000C, "Member 'LAIController_Sight_Check::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.UseSkill
// 0x0018 (0x0018 - 0x0000)
struct LAIController_UseSkill final
{
public:
	class FName                                   SkillId;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkillCooltime;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGlobalCooltime;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceToLaunch;                                    // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNPCSkillLaunchResult                 OutResult;                                         // 0x0010(0x0008)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_UseSkill) == 0x000008, "Wrong alignment on LAIController_UseSkill");
static_assert(sizeof(LAIController_UseSkill) == 0x000018, "Wrong size on LAIController_UseSkill");
static_assert(offsetof(LAIController_UseSkill, SkillId) == 0x000000, "Member 'LAIController_UseSkill::SkillId' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkill, bUseSkillCooltime) == 0x000008, "Member 'LAIController_UseSkill::bUseSkillCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkill, bUseGlobalCooltime) == 0x000009, "Member 'LAIController_UseSkill::bUseGlobalCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkill, bForceToLaunch) == 0x00000A, "Member 'LAIController_UseSkill::bForceToLaunch' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkill, OutResult) == 0x000010, "Member 'LAIController_UseSkill::OutResult' has a wrong offset!");

// Function ProjectP.LAIController.UseSkillForce
// 0x0018 (0x0018 - 0x0000)
struct LAIController_UseSkillForce final
{
public:
	class FName                                   SkillId;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkillCooltime;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGlobalCooltime;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_UseSkillForce) == 0x000008, "Wrong alignment on LAIController_UseSkillForce");
static_assert(sizeof(LAIController_UseSkillForce) == 0x000018, "Wrong size on LAIController_UseSkillForce");
static_assert(offsetof(LAIController_UseSkillForce, SkillId) == 0x000000, "Member 'LAIController_UseSkillForce::SkillId' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkillForce, bUseSkillCooltime) == 0x000008, "Member 'LAIController_UseSkillForce::bUseSkillCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkillForce, bUseGlobalCooltime) == 0x000009, "Member 'LAIController_UseSkillForce::bUseGlobalCooltime' has a wrong offset!");
static_assert(offsetof(LAIController_UseSkillForce, ReturnValue) == 0x000010, "Member 'LAIController_UseSkillForce::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.FindPause
// 0x000C (0x000C - 0x0000)
struct LAIController_FindPause final
{
public:
	class FName                                   PauseName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_FindPause) == 0x000004, "Wrong alignment on LAIController_FindPause");
static_assert(sizeof(LAIController_FindPause) == 0x00000C, "Wrong size on LAIController_FindPause");
static_assert(offsetof(LAIController_FindPause, PauseName) == 0x000000, "Member 'LAIController_FindPause::PauseName' has a wrong offset!");
static_assert(offsetof(LAIController_FindPause, ReturnValue) == 0x000008, "Member 'LAIController_FindPause::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.FindPauseMetaName
// 0x000C (0x000C - 0x0000)
struct LAIController_FindPauseMetaName final
{
public:
	class FName                                   MetaName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_FindPauseMetaName) == 0x000004, "Wrong alignment on LAIController_FindPauseMetaName");
static_assert(sizeof(LAIController_FindPauseMetaName) == 0x00000C, "Wrong size on LAIController_FindPauseMetaName");
static_assert(offsetof(LAIController_FindPauseMetaName, MetaName) == 0x000000, "Member 'LAIController_FindPauseMetaName::MetaName' has a wrong offset!");
static_assert(offsetof(LAIController_FindPauseMetaName, ReturnValue) == 0x000008, "Member 'LAIController_FindPauseMetaName::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.FindPauseOnlyMetaName
// 0x000C (0x000C - 0x0000)
struct LAIController_FindPauseOnlyMetaName final
{
public:
	class FName                                   MetaName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_FindPauseOnlyMetaName) == 0x000004, "Wrong alignment on LAIController_FindPauseOnlyMetaName");
static_assert(sizeof(LAIController_FindPauseOnlyMetaName) == 0x00000C, "Wrong size on LAIController_FindPauseOnlyMetaName");
static_assert(offsetof(LAIController_FindPauseOnlyMetaName, MetaName) == 0x000000, "Member 'LAIController_FindPauseOnlyMetaName::MetaName' has a wrong offset!");
static_assert(offsetof(LAIController_FindPauseOnlyMetaName, ReturnValue) == 0x000008, "Member 'LAIController_FindPauseOnlyMetaName::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetElapsedTimer
// 0x000C (0x000C - 0x0000)
struct LAIController_GetElapsedTimer final
{
public:
	class FName                                   TimerCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetElapsedTimer) == 0x000004, "Wrong alignment on LAIController_GetElapsedTimer");
static_assert(sizeof(LAIController_GetElapsedTimer) == 0x00000C, "Wrong size on LAIController_GetElapsedTimer");
static_assert(offsetof(LAIController_GetElapsedTimer, TimerCodeName) == 0x000000, "Member 'LAIController_GetElapsedTimer::TimerCodeName' has a wrong offset!");
static_assert(offsetof(LAIController_GetElapsedTimer, ReturnValue) == 0x000008, "Member 'LAIController_GetElapsedTimer::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetGlobalSkillCooltime
// 0x0004 (0x0004 - 0x0000)
struct LAIController_GetGlobalSkillCooltime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetGlobalSkillCooltime) == 0x000004, "Wrong alignment on LAIController_GetGlobalSkillCooltime");
static_assert(sizeof(LAIController_GetGlobalSkillCooltime) == 0x000004, "Wrong size on LAIController_GetGlobalSkillCooltime");
static_assert(offsetof(LAIController_GetGlobalSkillCooltime, ReturnValue) == 0x000000, "Member 'LAIController_GetGlobalSkillCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetLastMoveDestLocation
// 0x000C (0x000C - 0x0000)
struct LAIController_GetLastMoveDestLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetLastMoveDestLocation) == 0x000004, "Wrong alignment on LAIController_GetLastMoveDestLocation");
static_assert(sizeof(LAIController_GetLastMoveDestLocation) == 0x00000C, "Wrong size on LAIController_GetLastMoveDestLocation");
static_assert(offsetof(LAIController_GetLastMoveDestLocation, ReturnValue) == 0x000000, "Member 'LAIController_GetLastMoveDestLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetLastMovementID
// 0x004C (0x004C - 0x0000)
struct LAIController_GetLastMovementID final
{
public:
	struct FLAIMovementID                         ReturnValue;                                       // 0x0000(0x004C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetLastMovementID) == 0x000004, "Wrong alignment on LAIController_GetLastMovementID");
static_assert(sizeof(LAIController_GetLastMovementID) == 0x00004C, "Wrong size on LAIController_GetLastMovementID");
static_assert(offsetof(LAIController_GetLastMovementID, ReturnValue) == 0x000000, "Member 'LAIController_GetLastMovementID::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetNavData
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetNavData final
{
public:
	const class ANavigationData*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetNavData) == 0x000008, "Wrong alignment on LAIController_GetNavData");
static_assert(sizeof(LAIController_GetNavData) == 0x000008, "Wrong size on LAIController_GetNavData");
static_assert(offsetof(LAIController_GetNavData, ReturnValue) == 0x000000, "Member 'LAIController_GetNavData::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetRotationCooltime
// 0x0004 (0x0004 - 0x0000)
struct LAIController_GetRotationCooltime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetRotationCooltime) == 0x000004, "Wrong alignment on LAIController_GetRotationCooltime");
static_assert(sizeof(LAIController_GetRotationCooltime) == 0x000004, "Wrong size on LAIController_GetRotationCooltime");
static_assert(offsetof(LAIController_GetRotationCooltime, ReturnValue) == 0x000000, "Member 'LAIController_GetRotationCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetSelectedSkillApproachDist
// 0x0004 (0x0004 - 0x0000)
struct LAIController_GetSelectedSkillApproachDist final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetSelectedSkillApproachDist) == 0x000004, "Wrong alignment on LAIController_GetSelectedSkillApproachDist");
static_assert(sizeof(LAIController_GetSelectedSkillApproachDist) == 0x000004, "Wrong size on LAIController_GetSelectedSkillApproachDist");
static_assert(offsetof(LAIController_GetSelectedSkillApproachDist, ReturnValue) == 0x000000, "Member 'LAIController_GetSelectedSkillApproachDist::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetSkillCooltimes
// 0x0050 (0x0050 - 0x0000)
struct LAIController_GetSkillCooltimes final
{
public:
	TMap<class FName, float>                      ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetSkillCooltimes) == 0x000008, "Wrong alignment on LAIController_GetSkillCooltimes");
static_assert(sizeof(LAIController_GetSkillCooltimes) == 0x000050, "Wrong size on LAIController_GetSkillCooltimes");
static_assert(offsetof(LAIController_GetSkillCooltimes, ReturnValue) == 0x000000, "Member 'LAIController_GetSkillCooltimes::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetSkillTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct LAIController_GetSkillTargetLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_GetSkillTargetLocation) == 0x000004, "Wrong alignment on LAIController_GetSkillTargetLocation");
static_assert(sizeof(LAIController_GetSkillTargetLocation) == 0x000010, "Wrong size on LAIController_GetSkillTargetLocation");
static_assert(offsetof(LAIController_GetSkillTargetLocation, Location) == 0x000000, "Member 'LAIController_GetSkillTargetLocation::Location' has a wrong offset!");
static_assert(offsetof(LAIController_GetSkillTargetLocation, ReturnValue) == 0x00000C, "Member 'LAIController_GetSkillTargetLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.GetTargetNearAllyNum
// 0x0008 (0x0008 - 0x0000)
struct LAIController_GetTargetNearAllyNum final
{
public:
	bool                                          bCheckDistance;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_GetTargetNearAllyNum) == 0x000004, "Wrong alignment on LAIController_GetTargetNearAllyNum");
static_assert(sizeof(LAIController_GetTargetNearAllyNum) == 0x000008, "Wrong size on LAIController_GetTargetNearAllyNum");
static_assert(offsetof(LAIController_GetTargetNearAllyNum, bCheckDistance) == 0x000000, "Member 'LAIController_GetTargetNearAllyNum::bCheckDistance' has a wrong offset!");
static_assert(offsetof(LAIController_GetTargetNearAllyNum, ReturnValue) == 0x000004, "Member 'LAIController_GetTargetNearAllyNum::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsMasterExist
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsMasterExist final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsMasterExist) == 0x000001, "Wrong alignment on LAIController_IsMasterExist");
static_assert(sizeof(LAIController_IsMasterExist) == 0x000001, "Wrong size on LAIController_IsMasterExist");
static_assert(offsetof(LAIController_IsMasterExist, ReturnValue) == 0x000000, "Member 'LAIController_IsMasterExist::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsMoveBlocking
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsMoveBlocking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsMoveBlocking) == 0x000001, "Wrong alignment on LAIController_IsMoveBlocking");
static_assert(sizeof(LAIController_IsMoveBlocking) == 0x000001, "Wrong size on LAIController_IsMoveBlocking");
static_assert(offsetof(LAIController_IsMoveBlocking, ReturnValue) == 0x000000, "Member 'LAIController_IsMoveBlocking::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsMoving
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsMoving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsMoving) == 0x000001, "Wrong alignment on LAIController_IsMoving");
static_assert(sizeof(LAIController_IsMoving) == 0x000001, "Wrong size on LAIController_IsMoving");
static_assert(offsetof(LAIController_IsMoving, ReturnValue) == 0x000000, "Member 'LAIController_IsMoving::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsPauseAI
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsPauseAI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsPauseAI) == 0x000001, "Wrong alignment on LAIController_IsPauseAI");
static_assert(sizeof(LAIController_IsPauseAI) == 0x000001, "Wrong size on LAIController_IsPauseAI");
static_assert(offsetof(LAIController_IsPauseAI, ReturnValue) == 0x000000, "Member 'LAIController_IsPauseAI::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsRequestMovement
// 0x0050 (0x0050 - 0x0000)
struct LAIController_IsRequestMovement final
{
public:
	struct FLAIMovementID                         MovementID;                                        // 0x0000(0x004C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_IsRequestMovement) == 0x000004, "Wrong alignment on LAIController_IsRequestMovement");
static_assert(sizeof(LAIController_IsRequestMovement) == 0x000050, "Wrong size on LAIController_IsRequestMovement");
static_assert(offsetof(LAIController_IsRequestMovement, MovementID) == 0x000000, "Member 'LAIController_IsRequestMovement::MovementID' has a wrong offset!");
static_assert(offsetof(LAIController_IsRequestMovement, ReturnValue) == 0x00004C, "Member 'LAIController_IsRequestMovement::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsRunningAI
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsRunningAI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsRunningAI) == 0x000001, "Wrong alignment on LAIController_IsRunningAI");
static_assert(sizeof(LAIController_IsRunningAI) == 0x000001, "Wrong size on LAIController_IsRunningAI");
static_assert(offsetof(LAIController_IsRunningAI, ReturnValue) == 0x000000, "Member 'LAIController_IsRunningAI::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsRunningMoveBehavior
// 0x0008 (0x0008 - 0x0000)
struct LAIController_IsRunningMoveBehavior final
{
public:
	struct FLAIMoveBehaviorID                     BehaviorID;                                        // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIController_IsRunningMoveBehavior) == 0x000004, "Wrong alignment on LAIController_IsRunningMoveBehavior");
static_assert(sizeof(LAIController_IsRunningMoveBehavior) == 0x000008, "Wrong size on LAIController_IsRunningMoveBehavior");
static_assert(offsetof(LAIController_IsRunningMoveBehavior, BehaviorID) == 0x000000, "Member 'LAIController_IsRunningMoveBehavior::BehaviorID' has a wrong offset!");
static_assert(offsetof(LAIController_IsRunningMoveBehavior, ReturnValue) == 0x000004, "Member 'LAIController_IsRunningMoveBehavior::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsSkillMoveApproachDistReached
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsSkillMoveApproachDistReached final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsSkillMoveApproachDistReached) == 0x000001, "Wrong alignment on LAIController_IsSkillMoveApproachDistReached");
static_assert(sizeof(LAIController_IsSkillMoveApproachDistReached) == 0x000001, "Wrong size on LAIController_IsSkillMoveApproachDistReached");
static_assert(offsetof(LAIController_IsSkillMoveApproachDistReached, ReturnValue) == 0x000000, "Member 'LAIController_IsSkillMoveApproachDistReached::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsTargetExist
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsTargetExist final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsTargetExist) == 0x000001, "Wrong alignment on LAIController_IsTargetExist");
static_assert(sizeof(LAIController_IsTargetExist) == 0x000001, "Wrong size on LAIController_IsTargetExist");
static_assert(offsetof(LAIController_IsTargetExist, ReturnValue) == 0x000000, "Member 'LAIController_IsTargetExist::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsTicketMove
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsTicketMove final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsTicketMove) == 0x000001, "Wrong alignment on LAIController_IsTicketMove");
static_assert(sizeof(LAIController_IsTicketMove) == 0x000001, "Wrong size on LAIController_IsTicketMove");
static_assert(offsetof(LAIController_IsTicketMove, ReturnValue) == 0x000000, "Member 'LAIController_IsTicketMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIController.IsWarningExist
// 0x0001 (0x0001 - 0x0000)
struct LAIController_IsWarningExist final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIController_IsWarningExist) == 0x000001, "Wrong alignment on LAIController_IsWarningExist");
static_assert(sizeof(LAIController_IsWarningExist) == 0x000001, "Wrong size on LAIController_IsWarningExist");
static_assert(offsetof(LAIController_IsWarningExist, ReturnValue) == 0x000000, "Member 'LAIController_IsWarningExist::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.AddPauseAI
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_AddPauseAI final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PauseName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintain;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_AddPauseAI) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_AddPauseAI");
static_assert(sizeof(LAIUtilFuncLibrary_AddPauseAI) == 0x000018, "Wrong size on LAIUtilFuncLibrary_AddPauseAI");
static_assert(offsetof(LAIUtilFuncLibrary_AddPauseAI, Actor) == 0x000000, "Member 'LAIUtilFuncLibrary_AddPauseAI::Actor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_AddPauseAI, PauseName) == 0x000008, "Member 'LAIUtilFuncLibrary_AddPauseAI::PauseName' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_AddPauseAI, bMaintain) == 0x000010, "Member 'LAIUtilFuncLibrary_AddPauseAI::bMaintain' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CanMoveToLocation_Nav
// 0x0040 (0x0040 - 0x0000)
struct LAIUtilFuncLibrary_CanMoveToLocation_Nav final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CanMoveToLocation_Nav) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CanMoveToLocation_Nav");
static_assert(sizeof(LAIUtilFuncLibrary_CanMoveToLocation_Nav) == 0x000040, "Wrong size on LAIUtilFuncLibrary_CanMoveToLocation_Nav");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Nav, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Nav::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Nav, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Nav::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Nav, HitLocation) == 0x000030, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Nav::HitLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Nav, ReturnValue) == 0x00003C, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Nav::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CanMoveToLocation_Trace
// 0x0034 (0x0034 - 0x0000)
struct LAIUtilFuncLibrary_CanMoveToLocation_Trace final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSubtractTargetCapsuleSize;                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0031(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CanMoveToLocation_Trace) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CanMoveToLocation_Trace");
static_assert(sizeof(LAIUtilFuncLibrary_CanMoveToLocation_Trace) == 0x000034, "Wrong size on LAIUtilFuncLibrary_CanMoveToLocation_Trace");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Trace, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Trace::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Trace, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Trace::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Trace, bSubtractTargetCapsuleSize) == 0x000030, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Trace::bSubtractTargetCapsuleSize' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CanMoveToLocation_Trace, ReturnValue) == 0x000031, "Member 'LAIUtilFuncLibrary_CanMoveToLocation_Trace::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckAngleBetween
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_CheckAngleBetween final
{
public:
	struct FVector                                CriterionLocation;                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CriterionRotation;                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginDegree;                                       // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDegree;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckAngleBetween) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckAngleBetween");
static_assert(sizeof(LAIUtilFuncLibrary_CheckAngleBetween) == 0x000030, "Wrong size on LAIUtilFuncLibrary_CheckAngleBetween");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetween, CriterionLocation) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckAngleBetween::CriterionLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetween, CriterionRotation) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckAngleBetween::CriterionRotation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetween, TargetLocation) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckAngleBetween::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetween, BeginDegree) == 0x000024, "Member 'LAIUtilFuncLibrary_CheckAngleBetween::BeginDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetween, EndDegree) == 0x000028, "Member 'LAIUtilFuncLibrary_CheckAngleBetween::EndDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetween, ReturnValue) == 0x00002C, "Member 'LAIUtilFuncLibrary_CheckAngleBetween::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckAngleBetweenActor
// 0x0020 (0x0020 - 0x0000)
struct LAIUtilFuncLibrary_CheckAngleBetweenActor final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginDegree;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDegree;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckAngleBetweenActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckAngleBetweenActor");
static_assert(sizeof(LAIUtilFuncLibrary_CheckAngleBetweenActor) == 0x000020, "Wrong size on LAIUtilFuncLibrary_CheckAngleBetweenActor");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenActor, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenActor::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenActor, TargetActor) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenActor::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenActor, BeginDegree) == 0x000010, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenActor::BeginDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenActor, EndDegree) == 0x000014, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenActor::EndDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenActor, ReturnValue) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckAngleBetweenDeviation
// 0x002C (0x002C - 0x0000)
struct LAIUtilFuncLibrary_CheckAngleBetweenDeviation final
{
public:
	struct FVector                                CriterionLocation;                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CriterionRotation;                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeviationAngle;                                    // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckAngleBetweenDeviation");
static_assert(sizeof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation) == 0x00002C, "Wrong size on LAIUtilFuncLibrary_CheckAngleBetweenDeviation");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation, CriterionLocation) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenDeviation::CriterionLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation, CriterionRotation) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenDeviation::CriterionRotation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation, TargetLocation) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenDeviation::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation, DeviationAngle) == 0x000024, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenDeviation::DeviationAngle' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckAngleBetweenDeviation, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_CheckAngleBetweenDeviation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckBackSideLocation2D
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_CheckBackSideLocation2D final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AroundActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckBackSideLocation2D) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckBackSideLocation2D");
static_assert(sizeof(LAIUtilFuncLibrary_CheckBackSideLocation2D) == 0x000018, "Wrong size on LAIUtilFuncLibrary_CheckBackSideLocation2D");
static_assert(offsetof(LAIUtilFuncLibrary_CheckBackSideLocation2D, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckBackSideLocation2D::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckBackSideLocation2D, AroundActor) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckBackSideLocation2D::AroundActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckBackSideLocation2D, ReturnValue) == 0x000010, "Member 'LAIUtilFuncLibrary_CheckBackSideLocation2D::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckEnemyAttack
// 0x0010 (0x0010 - 0x0000)
struct LAIUtilFuncLibrary_CheckEnemyAttack final
{
public:
	class AActor*                                 EnemyActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckEnemyAttack) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckEnemyAttack");
static_assert(sizeof(LAIUtilFuncLibrary_CheckEnemyAttack) == 0x000010, "Wrong size on LAIUtilFuncLibrary_CheckEnemyAttack");
static_assert(offsetof(LAIUtilFuncLibrary_CheckEnemyAttack, EnemyActor) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckEnemyAttack::EnemyActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckEnemyAttack, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckEnemyAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckHostileType
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_CheckHostileType final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHostileType                                 HostileType;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckHostileType) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckHostileType");
static_assert(sizeof(LAIUtilFuncLibrary_CheckHostileType) == 0x000018, "Wrong size on LAIUtilFuncLibrary_CheckHostileType");
static_assert(offsetof(LAIUtilFuncLibrary_CheckHostileType, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckHostileType::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckHostileType, TargetActor) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckHostileType::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckHostileType, HostileType) == 0x000010, "Member 'LAIUtilFuncLibrary_CheckHostileType::HostileType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckHostileType, ReturnValue) == 0x000011, "Member 'LAIUtilFuncLibrary_CheckHostileType::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckInCameraView
// 0x0010 (0x0010 - 0x0000)
struct LAIUtilFuncLibrary_CheckInCameraView final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckInCameraView) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckInCameraView");
static_assert(sizeof(LAIUtilFuncLibrary_CheckInCameraView) == 0x000010, "Wrong size on LAIUtilFuncLibrary_CheckInCameraView");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInCameraView, Target) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckInCameraView::Target' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInCameraView, Distance) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckInCameraView::Distance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInCameraView, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckInCameraView::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckInsideDistance
// 0x0020 (0x0020 - 0x0000)
struct LAIUtilFuncLibrary_CheckInsideDistance final
{
public:
	struct FVector                                P1;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P2;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideLength;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckInsideDistance) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckInsideDistance");
static_assert(sizeof(LAIUtilFuncLibrary_CheckInsideDistance) == 0x000020, "Wrong size on LAIUtilFuncLibrary_CheckInsideDistance");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance, P1) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckInsideDistance::P1' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance, P2) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckInsideDistance::P2' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance, InsideLength) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckInsideDistance::InsideLength' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance, ReturnValue) == 0x00001C, "Member 'LAIUtilFuncLibrary_CheckInsideDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckInsideDistance2D
// 0x0020 (0x0020 - 0x0000)
struct LAIUtilFuncLibrary_CheckInsideDistance2D final
{
public:
	struct FVector                                P1;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P2;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideLength;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckInsideDistance2D) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckInsideDistance2D");
static_assert(sizeof(LAIUtilFuncLibrary_CheckInsideDistance2D) == 0x000020, "Wrong size on LAIUtilFuncLibrary_CheckInsideDistance2D");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2D, P1) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2D::P1' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2D, P2) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2D::P2' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2D, InsideLength) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2D::InsideLength' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2D, ReturnValue) == 0x00001C, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2D::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckInsideDistance2DAndHeight
// 0x0024 (0x0024 - 0x0000)
struct LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight final
{
public:
	struct FVector                                P1;                                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P2;                                                // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideLength;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideHeight;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight");
static_assert(sizeof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight) == 0x000024, "Wrong size on LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight, P1) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight::P1' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight, P2) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight::P2' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight, InsideLength) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight::InsideLength' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight, InsideHeight) == 0x00001C, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight::InsideHeight' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight, ReturnValue) == 0x000020, "Member 'LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckInsidePathDistance
// 0x0020 (0x0020 - 0x0000)
struct LAIUtilFuncLibrary_CheckInsidePathDistance final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AroundActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideLength;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CacheName;                                         // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckInsidePathDistance) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckInsidePathDistance");
static_assert(sizeof(LAIUtilFuncLibrary_CheckInsidePathDistance) == 0x000020, "Wrong size on LAIUtilFuncLibrary_CheckInsidePathDistance");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsidePathDistance, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckInsidePathDistance::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsidePathDistance, AroundActor) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckInsidePathDistance::AroundActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsidePathDistance, InsideLength) == 0x000010, "Member 'LAIUtilFuncLibrary_CheckInsidePathDistance::InsideLength' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsidePathDistance, CacheName) == 0x000014, "Member 'LAIUtilFuncLibrary_CheckInsidePathDistance::CacheName' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckInsidePathDistance, ReturnValue) == 0x00001C, "Member 'LAIUtilFuncLibrary_CheckInsidePathDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckMoveHeight
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_CheckMoveHeight final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceDelta;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckMoveHeight) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckMoveHeight");
static_assert(sizeof(LAIUtilFuncLibrary_CheckMoveHeight) == 0x000018, "Wrong size on LAIUtilFuncLibrary_CheckMoveHeight");
static_assert(offsetof(LAIUtilFuncLibrary_CheckMoveHeight, Character) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckMoveHeight::Character' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckMoveHeight, TraceDelta) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckMoveHeight::TraceDelta' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckMoveHeight, bDebug) == 0x000014, "Member 'LAIUtilFuncLibrary_CheckMoveHeight::bDebug' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckMoveHeight, ReturnValue) == 0x000015, "Member 'LAIUtilFuncLibrary_CheckMoveHeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirect
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_CheckPathDirect final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckPathDirect) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckPathDirect");
static_assert(sizeof(LAIUtilFuncLibrary_CheckPathDirect) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_CheckPathDirect");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckPathDirect::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckPathDirect::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckPathDirect::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckPathDirect::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckPathDirect::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, FailReason) == 0x000039, "Member 'LAIUtilFuncLibrary_CheckPathDirect::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirect, ReturnValue) == 0x00003A, "Member 'LAIUtilFuncLibrary_CheckPathDirect::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirectNavi
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_CheckPathDirectNavi final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckPathDirectNavi) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckPathDirectNavi");
static_assert(sizeof(LAIUtilFuncLibrary_CheckPathDirectNavi) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_CheckPathDirectNavi");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, FailReason) == 0x000039, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi, ReturnValue) == 0x00003A, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirectNavi_Lagacy
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy");
static_assert(sizeof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy, ReturnValue) == 0x000039, "Member 'LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirectProjectile
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_CheckPathDirectProjectile final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckPathDirectProjectile) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckPathDirectProjectile");
static_assert(sizeof(LAIUtilFuncLibrary_CheckPathDirectProjectile) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_CheckPathDirectProjectile");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, FailReason) == 0x000039, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathDirectProjectile, ReturnValue) == 0x00003A, "Member 'LAIUtilFuncLibrary_CheckPathDirectProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckPathNavi
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_CheckPathNavi final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckPathNavi) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckPathNavi");
static_assert(sizeof(LAIUtilFuncLibrary_CheckPathNavi) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_CheckPathNavi");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckPathNavi::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckPathNavi::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckPathNavi::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckPathNavi::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckPathNavi::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, FailReason) == 0x000039, "Member 'LAIUtilFuncLibrary_CheckPathNavi::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckPathNavi, ReturnValue) == 0x00003A, "Member 'LAIUtilFuncLibrary_CheckPathNavi::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckRangeAngleBetween
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_CheckRangeAngleBetween final
{
public:
	struct FVector                                CriterionLocation;                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CriterionRotation;                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginDegree;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDegree;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckRangeAngleBetween) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckRangeAngleBetween");
static_assert(sizeof(LAIUtilFuncLibrary_CheckRangeAngleBetween) == 0x000038, "Wrong size on LAIUtilFuncLibrary_CheckRangeAngleBetween");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, CriterionLocation) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::CriterionLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, CriterionRotation) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::CriterionRotation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, TargetLocation) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, MinRange) == 0x000024, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, MaxRange) == 0x000028, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, BeginDegree) == 0x00002C, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::BeginDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, EndDegree) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::EndDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeAngleBetween, ReturnValue) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckRangeAngleBetween::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckRangeBetween
// 0x0024 (0x0024 - 0x0000)
struct LAIUtilFuncLibrary_CheckRangeBetween final
{
public:
	struct FVector                                CriterionLocation;                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckRangeBetween) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckRangeBetween");
static_assert(sizeof(LAIUtilFuncLibrary_CheckRangeBetween) == 0x000024, "Wrong size on LAIUtilFuncLibrary_CheckRangeBetween");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetween, CriterionLocation) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckRangeBetween::CriterionLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetween, TargetLocation) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckRangeBetween::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetween, MinRange) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckRangeBetween::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetween, MaxRange) == 0x00001C, "Member 'LAIUtilFuncLibrary_CheckRangeBetween::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetween, ReturnValue) == 0x000020, "Member 'LAIUtilFuncLibrary_CheckRangeBetween::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckRangeBetweenActor
// 0x0020 (0x0020 - 0x0000)
struct LAIUtilFuncLibrary_CheckRangeBetweenActor final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckRangeBetweenActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_CheckRangeBetweenActor");
static_assert(sizeof(LAIUtilFuncLibrary_CheckRangeBetweenActor) == 0x000020, "Wrong size on LAIUtilFuncLibrary_CheckRangeBetweenActor");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetweenActor, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckRangeBetweenActor::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetweenActor, TargetActor) == 0x000008, "Member 'LAIUtilFuncLibrary_CheckRangeBetweenActor::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetweenActor, MinRange) == 0x000010, "Member 'LAIUtilFuncLibrary_CheckRangeBetweenActor::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetweenActor, MaxRange) == 0x000014, "Member 'LAIUtilFuncLibrary_CheckRangeBetweenActor::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckRangeBetweenActor, ReturnValue) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckRangeBetweenActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckTargetAngle
// 0x0024 (0x0024 - 0x0000)
struct LAIUtilFuncLibrary_CheckTargetAngle final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginDegree;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDegree;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckTargetAngle) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckTargetAngle");
static_assert(sizeof(LAIUtilFuncLibrary_CheckTargetAngle) == 0x000024, "Wrong size on LAIUtilFuncLibrary_CheckTargetAngle");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetAngle, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckTargetAngle::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetAngle, TargetLocation) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckTargetAngle::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetAngle, BeginDegree) == 0x000018, "Member 'LAIUtilFuncLibrary_CheckTargetAngle::BeginDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetAngle, EndDegree) == 0x00001C, "Member 'LAIUtilFuncLibrary_CheckTargetAngle::EndDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetAngle, ReturnValue) == 0x000020, "Member 'LAIUtilFuncLibrary_CheckTargetAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckTargetHeight
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_CheckTargetHeight final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckTargetHeight) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckTargetHeight");
static_assert(sizeof(LAIUtilFuncLibrary_CheckTargetHeight) == 0x000038, "Wrong size on LAIUtilFuncLibrary_CheckTargetHeight");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetHeight, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckTargetHeight::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetHeight, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckTargetHeight::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetHeight, Height) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckTargetHeight::Height' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetHeight, ReturnValue) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckTargetHeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckTargetRangeHeightAngleDist
// 0x0048 (0x0048 - 0x0000)
struct LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CheckHeight;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeginDegree;                                       // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndDegree;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckType                            RangeCheckType;                                    // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0045(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0046(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist");
static_assert(sizeof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist) == 0x000048, "Wrong size on LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, CheckHeight) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::CheckHeight' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, BeginDegree) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::BeginDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, EndDegree) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::EndDegree' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, MinRange) == 0x00003C, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, MaxRange) == 0x000040, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, RangeCheckType) == 0x000044, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::RangeCheckType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, FailReason) == 0x000045, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist, ReturnValue) == 0x000046, "Member 'LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CheckTargetRangeType
// 0x0040 (0x0040 - 0x0000)
struct LAIUtilFuncLibrary_CheckTargetRangeType final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	ELAIRangeCheckType                            RangeCheckType;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x003D(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003E(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CheckTargetRangeType) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CheckTargetRangeType");
static_assert(sizeof(LAIUtilFuncLibrary_CheckTargetRangeType) == 0x000040, "Wrong size on LAIUtilFuncLibrary_CheckTargetRangeType");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, RangeCheckType) == 0x000030, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::RangeCheckType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, MinRange) == 0x000034, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, MaxRange) == 0x000038, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, MinMaxType) == 0x00003C, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, FailReason) == 0x00003D, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CheckTargetRangeType, ReturnValue) == 0x00003E, "Member 'LAIUtilFuncLibrary_CheckTargetRangeType::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.CollideCeiling
// 0x0014 (0x0014 - 0x0000)
struct LAIUtilFuncLibrary_CollideCeiling final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CheckHeight;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_CollideCeiling) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_CollideCeiling");
static_assert(sizeof(LAIUtilFuncLibrary_CollideCeiling) == 0x000014, "Wrong size on LAIUtilFuncLibrary_CollideCeiling");
static_assert(offsetof(LAIUtilFuncLibrary_CollideCeiling, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_CollideCeiling::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CollideCeiling, CheckHeight) == 0x00000C, "Member 'LAIUtilFuncLibrary_CollideCeiling::CheckHeight' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_CollideCeiling, ReturnValue) == 0x000010, "Member 'LAIUtilFuncLibrary_CollideCeiling::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.DirectionAsActor
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_DirectionAsActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMovementDirection                  ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_DirectionAsActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_DirectionAsActor");
static_assert(sizeof(LAIUtilFuncLibrary_DirectionAsActor) == 0x000030, "Wrong size on LAIUtilFuncLibrary_DirectionAsActor");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsActor, Actor) == 0x000000, "Member 'LAIUtilFuncLibrary_DirectionAsActor::Actor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsActor, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_DirectionAsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.DirectionAsLocation
// 0x0034 (0x0034 - 0x0000)
struct LAIUtilFuncLibrary_DirectionAsLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMovementDirection                  ReturnValue;                                       // 0x000C(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_DirectionAsLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_DirectionAsLocation");
static_assert(sizeof(LAIUtilFuncLibrary_DirectionAsLocation) == 0x000034, "Wrong size on LAIUtilFuncLibrary_DirectionAsLocation");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsLocation, Location) == 0x000000, "Member 'LAIUtilFuncLibrary_DirectionAsLocation::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsLocation, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_DirectionAsLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.DirectionAsType
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_DirectionAsType final
{
public:
	class ALAIController*                         Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAIMovementDirection                  ReturnValue;                                       // 0x000C(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_DirectionAsType) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_DirectionAsType");
static_assert(sizeof(LAIUtilFuncLibrary_DirectionAsType) == 0x000038, "Wrong size on LAIUtilFuncLibrary_DirectionAsType");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsType, Controller) == 0x000000, "Member 'LAIUtilFuncLibrary_DirectionAsType::Controller' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsType, DirectionType) == 0x000008, "Member 'LAIUtilFuncLibrary_DirectionAsType::DirectionType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_DirectionAsType, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_DirectionAsType::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.EmptyMovementID
// 0x004C (0x004C - 0x0000)
struct LAIUtilFuncLibrary_EmptyMovementID final
{
public:
	struct FLAIMovementID                         MovementID;                                        // 0x0000(0x004C)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_EmptyMovementID) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_EmptyMovementID");
static_assert(sizeof(LAIUtilFuncLibrary_EmptyMovementID) == 0x00004C, "Wrong size on LAIUtilFuncLibrary_EmptyMovementID");
static_assert(offsetof(LAIUtilFuncLibrary_EmptyMovementID, MovementID) == 0x000000, "Member 'LAIUtilFuncLibrary_EmptyMovementID::MovementID' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetAgentDeltaLocation
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_GetAgentDeltaLocation final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetAgentDeltaLocation) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetAgentDeltaLocation");
static_assert(sizeof(LAIUtilFuncLibrary_GetAgentDeltaLocation) == 0x000018, "Wrong size on LAIUtilFuncLibrary_GetAgentDeltaLocation");
static_assert(offsetof(LAIUtilFuncLibrary_GetAgentDeltaLocation, Character) == 0x000000, "Member 'LAIUtilFuncLibrary_GetAgentDeltaLocation::Character' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetAgentDeltaLocation, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_GetAgentDeltaLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetAIController
// 0x0010 (0x0010 - 0x0000)
struct LAIUtilFuncLibrary_GetAIController final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCController*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_GetAIController) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetAIController");
static_assert(sizeof(LAIUtilFuncLibrary_GetAIController) == 0x000010, "Wrong size on LAIUtilFuncLibrary_GetAIController");
static_assert(offsetof(LAIUtilFuncLibrary_GetAIController, Actor) == 0x000000, "Member 'LAIUtilFuncLibrary_GetAIController::Actor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetAIController, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_GetAIController::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetAIEnabled
// 0x0010 (0x0010 - 0x0000)
struct LAIUtilFuncLibrary_GetAIEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetAIEnabled) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetAIEnabled");
static_assert(sizeof(LAIUtilFuncLibrary_GetAIEnabled) == 0x000010, "Wrong size on LAIUtilFuncLibrary_GetAIEnabled");
static_assert(offsetof(LAIUtilFuncLibrary_GetAIEnabled, WorldContextObject) == 0x000000, "Member 'LAIUtilFuncLibrary_GetAIEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetAIEnabled, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_GetAIEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetBlackboardValueAsLocation
// 0x0040 (0x0040 - 0x0000)
struct LAIUtilFuncLibrary_GetBlackboardValueAsLocation final
{
public:
	class UBTNode*                                NodeOwner;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Key;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetBlackboardValueAsLocation) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetBlackboardValueAsLocation");
static_assert(sizeof(LAIUtilFuncLibrary_GetBlackboardValueAsLocation) == 0x000040, "Wrong size on LAIUtilFuncLibrary_GetBlackboardValueAsLocation");
static_assert(offsetof(LAIUtilFuncLibrary_GetBlackboardValueAsLocation, NodeOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_GetBlackboardValueAsLocation::NodeOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetBlackboardValueAsLocation, Key) == 0x000008, "Member 'LAIUtilFuncLibrary_GetBlackboardValueAsLocation::Key' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetBlackboardValueAsLocation, ReturnValue) == 0x000030, "Member 'LAIUtilFuncLibrary_GetBlackboardValueAsLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetRandomInInterval
// 0x000C (0x000C - 0x0000)
struct LAIUtilFuncLibrary_GetRandomInInterval final
{
public:
	struct FLFloatInterval                        Interval;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_GetRandomInInterval) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_GetRandomInInterval");
static_assert(sizeof(LAIUtilFuncLibrary_GetRandomInInterval) == 0x00000C, "Wrong size on LAIUtilFuncLibrary_GetRandomInInterval");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomInInterval, Interval) == 0x000000, "Member 'LAIUtilFuncLibrary_GetRandomInInterval::Interval' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomInInterval, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_GetRandomInInterval::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocation
// 0x0040 (0x0040 - 0x0000)
struct LAIUtilFuncLibrary_GetRandomLocation final
{
public:
	struct FLAILocationSampler                    Sampler;                                           // 0x0000(0x0030)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetRandomLocation) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetRandomLocation");
static_assert(sizeof(LAIUtilFuncLibrary_GetRandomLocation) == 0x000040, "Wrong size on LAIUtilFuncLibrary_GetRandomLocation");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocation, Sampler) == 0x000000, "Member 'LAIUtilFuncLibrary_GetRandomLocation::Sampler' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocation, Location) == 0x000030, "Member 'LAIUtilFuncLibrary_GetRandomLocation::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocation, ReturnValue) == 0x00003C, "Member 'LAIUtilFuncLibrary_GetRandomLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocationCriterionDistanceAngle
// 0x0068 (0x0068 - 0x0000)
struct LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle final
{
public:
	struct FLAILocationSampler                    Sampler;                                           // 0x0000(0x0030)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CriterionLocation;                                 // 0x003C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CriterionRotation;                                 // 0x0048(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginAngle;                                        // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAngle;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0064(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle");
static_assert(sizeof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle) == 0x000068, "Wrong size on LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, Sampler) == 0x000000, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::Sampler' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, Location) == 0x000030, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, CriterionLocation) == 0x00003C, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::CriterionLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, CriterionRotation) == 0x000048, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::CriterionRotation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, MinDistance) == 0x000054, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::MinDistance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, MaxDistance) == 0x000058, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::MaxDistance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, BeginAngle) == 0x00005C, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::BeginAngle' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, EndAngle) == 0x000060, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::EndAngle' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle, ReturnValue) == 0x000064, "Member 'LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocationInDistance
// 0x0048 (0x0048 - 0x0000)
struct LAIUtilFuncLibrary_GetRandomLocationInDistance final
{
public:
	struct FLAILocationSampler                    Sampler;                                           // 0x0000(0x0030)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetRandomLocationInDistance) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetRandomLocationInDistance");
static_assert(sizeof(LAIUtilFuncLibrary_GetRandomLocationInDistance) == 0x000048, "Wrong size on LAIUtilFuncLibrary_GetRandomLocationInDistance");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationInDistance, Sampler) == 0x000000, "Member 'LAIUtilFuncLibrary_GetRandomLocationInDistance::Sampler' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationInDistance, Location) == 0x000030, "Member 'LAIUtilFuncLibrary_GetRandomLocationInDistance::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationInDistance, Distance) == 0x00003C, "Member 'LAIUtilFuncLibrary_GetRandomLocationInDistance::Distance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationInDistance, ReturnValue) == 0x000040, "Member 'LAIUtilFuncLibrary_GetRandomLocationInDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocationTargetBaseDistanceAngle
// 0x0078 (0x0078 - 0x0000)
struct LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle final
{
public:
	struct FLAILocationSampler                    Sampler;                                           // 0x0000(0x0030)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIObjective                          Target;                                            // 0x003C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginAngle;                                        // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAngle;                                          // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHeight;                                       // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0074(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle");
static_assert(sizeof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle) == 0x000078, "Wrong size on LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, Sampler) == 0x000000, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::Sampler' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, Location) == 0x000030, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, Target) == 0x00003C, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::Target' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, MinDistance) == 0x000060, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::MinDistance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, MaxDistance) == 0x000064, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::MaxDistance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, BeginAngle) == 0x000068, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::BeginAngle' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, EndAngle) == 0x00006C, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::EndAngle' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, TraceHeight) == 0x000070, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::TraceHeight' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle, ReturnValue) == 0x000074, "Member 'LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetReachedCylinderExtent
// 0x0040 (0x0040 - 0x0000)
struct LAIUtilFuncLibrary_GetReachedCylinderExtent final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OwnerRadiusScaleFactor;                            // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0034(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_GetReachedCylinderExtent) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_GetReachedCylinderExtent");
static_assert(sizeof(LAIUtilFuncLibrary_GetReachedCylinderExtent) == 0x000040, "Wrong size on LAIUtilFuncLibrary_GetReachedCylinderExtent");
static_assert(offsetof(LAIUtilFuncLibrary_GetReachedCylinderExtent, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_GetReachedCylinderExtent::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetReachedCylinderExtent, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_GetReachedCylinderExtent::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetReachedCylinderExtent, OwnerRadiusScaleFactor) == 0x000030, "Member 'LAIUtilFuncLibrary_GetReachedCylinderExtent::OwnerRadiusScaleFactor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetReachedCylinderExtent, ReturnValue) == 0x000034, "Member 'LAIUtilFuncLibrary_GetReachedCylinderExtent::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetTraceCharacterMoveObstacleStartLocation
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation");
static_assert(sizeof(LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation) == 0x000018, "Wrong size on LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation");
static_assert(offsetof(LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation, Character) == 0x000000, "Member 'LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation::Character' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GetTraceStartEndLocation
// 0x0060 (0x0060 - 0x0000)
struct LAIUtilFuncLibrary_GetTraceStartEndLocation final
{
public:
	struct FVector                                StartTrace;                                        // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIObjective                          StartActor;                                        // 0x0018(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          EndActor;                                          // 0x003C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_GetTraceStartEndLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_GetTraceStartEndLocation");
static_assert(sizeof(LAIUtilFuncLibrary_GetTraceStartEndLocation) == 0x000060, "Wrong size on LAIUtilFuncLibrary_GetTraceStartEndLocation");
static_assert(offsetof(LAIUtilFuncLibrary_GetTraceStartEndLocation, StartTrace) == 0x000000, "Member 'LAIUtilFuncLibrary_GetTraceStartEndLocation::StartTrace' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetTraceStartEndLocation, EndTrace) == 0x00000C, "Member 'LAIUtilFuncLibrary_GetTraceStartEndLocation::EndTrace' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetTraceStartEndLocation, StartActor) == 0x000018, "Member 'LAIUtilFuncLibrary_GetTraceStartEndLocation::StartActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GetTraceStartEndLocation, EndActor) == 0x00003C, "Member 'LAIUtilFuncLibrary_GetTraceStartEndLocation::EndActor' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GoalAsActor
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_GoalAsActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMovementGoal                       ReturnValue;                                       // 0x0008(0x002C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_GoalAsActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GoalAsActor");
static_assert(sizeof(LAIUtilFuncLibrary_GoalAsActor) == 0x000038, "Wrong size on LAIUtilFuncLibrary_GoalAsActor");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsActor, Actor) == 0x000000, "Member 'LAIUtilFuncLibrary_GoalAsActor::Actor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsActor, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_GoalAsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GoalAsLocation
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_GoalAsLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIMovementGoal                       ReturnValue;                                       // 0x000C(0x002C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_GoalAsLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_GoalAsLocation");
static_assert(sizeof(LAIUtilFuncLibrary_GoalAsLocation) == 0x000038, "Wrong size on LAIUtilFuncLibrary_GoalAsLocation");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsLocation, Location) == 0x000000, "Member 'LAIUtilFuncLibrary_GoalAsLocation::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsLocation, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_GoalAsLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.GoalAsType
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_GoalAsType final
{
public:
	class ALAIController*                         Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAIMovementGoal                       ReturnValue;                                       // 0x000C(0x002C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_GoalAsType) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_GoalAsType");
static_assert(sizeof(LAIUtilFuncLibrary_GoalAsType) == 0x000038, "Wrong size on LAIUtilFuncLibrary_GoalAsType");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsType, Controller) == 0x000000, "Member 'LAIUtilFuncLibrary_GoalAsType::Controller' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsType, TargetType) == 0x000008, "Member 'LAIUtilFuncLibrary_GoalAsType::TargetType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_GoalAsType, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_GoalAsType::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.IsAttackable
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_IsAttackable final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_IsAttackable) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_IsAttackable");
static_assert(sizeof(LAIUtilFuncLibrary_IsAttackable) == 0x000018, "Wrong size on LAIUtilFuncLibrary_IsAttackable");
static_assert(offsetof(LAIUtilFuncLibrary_IsAttackable, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_IsAttackable::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsAttackable, TargetActor) == 0x000008, "Member 'LAIUtilFuncLibrary_IsAttackable::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsAttackable, ReturnValue) == 0x000010, "Member 'LAIUtilFuncLibrary_IsAttackable::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.IsEnemy
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_IsEnemy final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_IsEnemy) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_IsEnemy");
static_assert(sizeof(LAIUtilFuncLibrary_IsEnemy) == 0x000018, "Wrong size on LAIUtilFuncLibrary_IsEnemy");
static_assert(offsetof(LAIUtilFuncLibrary_IsEnemy, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_IsEnemy::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsEnemy, TargetActor) == 0x000008, "Member 'LAIUtilFuncLibrary_IsEnemy::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsEnemy, ReturnValue) == 0x000010, "Member 'LAIUtilFuncLibrary_IsEnemy::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.IsEnemyFaction
// 0x0003 (0x0003 - 0x0000)
struct LAIUtilFuncLibrary_IsEnemyFaction final
{
public:
	EFactionType                                  CritrionFaction;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFactionType                                  TargetFaction;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_IsEnemyFaction) == 0x000001, "Wrong alignment on LAIUtilFuncLibrary_IsEnemyFaction");
static_assert(sizeof(LAIUtilFuncLibrary_IsEnemyFaction) == 0x000003, "Wrong size on LAIUtilFuncLibrary_IsEnemyFaction");
static_assert(offsetof(LAIUtilFuncLibrary_IsEnemyFaction, CritrionFaction) == 0x000000, "Member 'LAIUtilFuncLibrary_IsEnemyFaction::CritrionFaction' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsEnemyFaction, TargetFaction) == 0x000001, "Member 'LAIUtilFuncLibrary_IsEnemyFaction::TargetFaction' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsEnemyFaction, ReturnValue) == 0x000002, "Member 'LAIUtilFuncLibrary_IsEnemyFaction::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.IsInsideCylinder
// 0x0028 (0x0028 - 0x0000)
struct LAIUtilFuncLibrary_IsInsideCylinder final
{
public:
	struct FVector                                CylinderExtent;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CylinderOrigin;                                    // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_IsInsideCylinder) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_IsInsideCylinder");
static_assert(sizeof(LAIUtilFuncLibrary_IsInsideCylinder) == 0x000028, "Wrong size on LAIUtilFuncLibrary_IsInsideCylinder");
static_assert(offsetof(LAIUtilFuncLibrary_IsInsideCylinder, CylinderExtent) == 0x000000, "Member 'LAIUtilFuncLibrary_IsInsideCylinder::CylinderExtent' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsInsideCylinder, CylinderOrigin) == 0x00000C, "Member 'LAIUtilFuncLibrary_IsInsideCylinder::CylinderOrigin' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsInsideCylinder, TargetLocation) == 0x000018, "Member 'LAIUtilFuncLibrary_IsInsideCylinder::TargetLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsInsideCylinder, ReturnValue) == 0x000024, "Member 'LAIUtilFuncLibrary_IsInsideCylinder::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.IsMonsterFactionActor
// 0x0010 (0x0010 - 0x0000)
struct LAIUtilFuncLibrary_IsMonsterFactionActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_IsMonsterFactionActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_IsMonsterFactionActor");
static_assert(sizeof(LAIUtilFuncLibrary_IsMonsterFactionActor) == 0x000010, "Wrong size on LAIUtilFuncLibrary_IsMonsterFactionActor");
static_assert(offsetof(LAIUtilFuncLibrary_IsMonsterFactionActor, TargetActor) == 0x000000, "Member 'LAIUtilFuncLibrary_IsMonsterFactionActor::TargetActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_IsMonsterFactionActor, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_IsMonsterFactionActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetActor
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_MovementDirectionGetActor final
{
public:
	struct FLAIMovementDirection                  MovementDirection;                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementDirectionGetActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_MovementDirectionGetActor");
static_assert(sizeof(LAIUtilFuncLibrary_MovementDirectionGetActor) == 0x000030, "Wrong size on LAIUtilFuncLibrary_MovementDirectionGetActor");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetActor, MovementDirection) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementDirectionGetActor::MovementDirection' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetActor, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_MovementDirectionGetActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetCharacter
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_MovementDirectionGetCharacter final
{
public:
	struct FLAIMovementDirection                  MovementDirection;                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class ALCharacter*                            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementDirectionGetCharacter) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_MovementDirectionGetCharacter");
static_assert(sizeof(LAIUtilFuncLibrary_MovementDirectionGetCharacter) == 0x000030, "Wrong size on LAIUtilFuncLibrary_MovementDirectionGetCharacter");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetCharacter, MovementDirection) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementDirectionGetCharacter::MovementDirection' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetCharacter, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_MovementDirectionGetCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetLocation
// 0x0034 (0x0034 - 0x0000)
struct LAIUtilFuncLibrary_MovementDirectionGetLocation final
{
public:
	struct FLAIMovementDirection                  MovementDirection;                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementDirectionGetLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementDirectionGetLocation");
static_assert(sizeof(LAIUtilFuncLibrary_MovementDirectionGetLocation) == 0x000034, "Wrong size on LAIUtilFuncLibrary_MovementDirectionGetLocation");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetLocation, MovementDirection) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementDirectionGetLocation::MovementDirection' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetLocation, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_MovementDirectionGetLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetRotation
// 0x0034 (0x0034 - 0x0000)
struct LAIUtilFuncLibrary_MovementDirectionGetRotation final
{
public:
	struct FLAIMovementDirection                  MovementDirection;                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementDirectionGetRotation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementDirectionGetRotation");
static_assert(sizeof(LAIUtilFuncLibrary_MovementDirectionGetRotation) == 0x000034, "Wrong size on LAIUtilFuncLibrary_MovementDirectionGetRotation");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetRotation, MovementDirection) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementDirectionGetRotation::MovementDirection' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionGetRotation, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_MovementDirectionGetRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionIsValid
// 0x002C (0x002C - 0x0000)
struct LAIUtilFuncLibrary_MovementDirectionIsValid final
{
public:
	struct FLAIMovementDirection                  MovementDirection;                                 // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_MovementDirectionIsValid) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementDirectionIsValid");
static_assert(sizeof(LAIUtilFuncLibrary_MovementDirectionIsValid) == 0x00002C, "Wrong size on LAIUtilFuncLibrary_MovementDirectionIsValid");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionIsValid, MovementDirection) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementDirectionIsValid::MovementDirection' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementDirectionIsValid, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_MovementDirectionIsValid::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetActor
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_MovementGoalGetActor final
{
public:
	struct FLAIMovementGoal                       MovementGoal;                                      // 0x0000(0x002C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementGoalGetActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_MovementGoalGetActor");
static_assert(sizeof(LAIUtilFuncLibrary_MovementGoalGetActor) == 0x000038, "Wrong size on LAIUtilFuncLibrary_MovementGoalGetActor");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetActor, MovementGoal) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementGoalGetActor::MovementGoal' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetActor, ReturnValue) == 0x000030, "Member 'LAIUtilFuncLibrary_MovementGoalGetActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetCharacter
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_MovementGoalGetCharacter final
{
public:
	struct FLAIMovementGoal                       MovementGoal;                                      // 0x0000(0x002C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALCharacter*                            ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementGoalGetCharacter) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_MovementGoalGetCharacter");
static_assert(sizeof(LAIUtilFuncLibrary_MovementGoalGetCharacter) == 0x000038, "Wrong size on LAIUtilFuncLibrary_MovementGoalGetCharacter");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetCharacter, MovementGoal) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementGoalGetCharacter::MovementGoal' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetCharacter, ReturnValue) == 0x000030, "Member 'LAIUtilFuncLibrary_MovementGoalGetCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetLocation
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_MovementGoalGetLocation final
{
public:
	struct FLAIMovementGoal                       MovementGoal;                                      // 0x0000(0x002C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x002C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementGoalGetLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementGoalGetLocation");
static_assert(sizeof(LAIUtilFuncLibrary_MovementGoalGetLocation) == 0x000038, "Wrong size on LAIUtilFuncLibrary_MovementGoalGetLocation");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetLocation, MovementGoal) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementGoalGetLocation::MovementGoal' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetLocation, ReturnValue) == 0x00002C, "Member 'LAIUtilFuncLibrary_MovementGoalGetLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetRotation
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_MovementGoalGetRotation final
{
public:
	struct FLAIMovementGoal                       MovementGoal;                                      // 0x0000(0x002C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x002C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementGoalGetRotation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementGoalGetRotation");
static_assert(sizeof(LAIUtilFuncLibrary_MovementGoalGetRotation) == 0x000038, "Wrong size on LAIUtilFuncLibrary_MovementGoalGetRotation");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetRotation, MovementGoal) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementGoalGetRotation::MovementGoal' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalGetRotation, ReturnValue) == 0x00002C, "Member 'LAIUtilFuncLibrary_MovementGoalGetRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementGoalIsValid
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_MovementGoalIsValid final
{
public:
	struct FLAIMovementGoal                       MovementGoal;                                      // 0x0000(0x002C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_MovementGoalIsValid) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementGoalIsValid");
static_assert(sizeof(LAIUtilFuncLibrary_MovementGoalIsValid) == 0x000030, "Wrong size on LAIUtilFuncLibrary_MovementGoalIsValid");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalIsValid, MovementGoal) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementGoalIsValid::MovementGoal' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalIsValid, ReturnValue) == 0x00002C, "Member 'LAIUtilFuncLibrary_MovementGoalIsValid::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.MovementGoalSetCustomArriveDistance
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance final
{
public:
	struct FLAIMovementGoal                       MovementGoal;                                      // 0x0000(0x002C)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArriveDistance;                                    // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance");
static_assert(sizeof(LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance) == 0x000030, "Wrong size on LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance, MovementGoal) == 0x000000, "Member 'LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance::MovementGoal' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance, ArriveDistance) == 0x00002C, "Member 'LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance::ArriveDistance' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveAsActor
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveAsActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIObjective                          ReturnValue;                                       // 0x0008(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveAsActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveAsActor");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveAsActor) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveAsActor");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsActor, Actor) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveAsActor::Actor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsActor, ReturnValue) == 0x000008, "Member 'LAIUtilFuncLibrary_ObjectiveAsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveAsLocation
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveAsLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAIObjective                          ReturnValue;                                       // 0x000C(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveAsLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveAsLocation");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveAsLocation) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveAsLocation");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsLocation, Location) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveAsLocation::Location' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsLocation, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_ObjectiveAsLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveAsType
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveAsType final
{
public:
	class ALAIController*                         Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAIObjective                          ReturnValue;                                       // 0x000C(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveAsType) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveAsType");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveAsType) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveAsType");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsType, Controller) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveAsType::Controller' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsType, TargetType) == 0x000008, "Member 'LAIUtilFuncLibrary_ObjectiveAsType::TargetType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveAsType, ReturnValue) == 0x00000C, "Member 'LAIUtilFuncLibrary_ObjectiveAsType::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetActor
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveGetActor final
{
public:
	struct FLAIObjective                          Objective;                                         // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveGetActor) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveGetActor");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveGetActor) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveGetActor");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetActor, Objective) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveGetActor::Objective' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetActor, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_ObjectiveGetActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetAgentLocation
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveGetAgentLocation final
{
public:
	struct FLAIObjective                          Objective;                                         // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveGetAgentLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveGetAgentLocation");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveGetAgentLocation) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveGetAgentLocation");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetAgentLocation, Objective) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveGetAgentLocation::Objective' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetAgentLocation, ReturnValue) == 0x000024, "Member 'LAIUtilFuncLibrary_ObjectiveGetAgentLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetCharacter
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveGetCharacter final
{
public:
	struct FLAIObjective                          Objective;                                         // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALCharacter*                            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveGetCharacter) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveGetCharacter");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveGetCharacter) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveGetCharacter");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetCharacter, Objective) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveGetCharacter::Objective' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetCharacter, ReturnValue) == 0x000028, "Member 'LAIUtilFuncLibrary_ObjectiveGetCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetLocation
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveGetLocation final
{
public:
	struct FLAIObjective                          Objective;                                         // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveGetLocation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveGetLocation");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveGetLocation) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveGetLocation");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetLocation, Objective) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveGetLocation::Objective' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetLocation, ReturnValue) == 0x000024, "Member 'LAIUtilFuncLibrary_ObjectiveGetLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetRotation
// 0x0030 (0x0030 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveGetRotation final
{
public:
	struct FLAIObjective                          Objective;                                         // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveGetRotation) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveGetRotation");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveGetRotation) == 0x000030, "Wrong size on LAIUtilFuncLibrary_ObjectiveGetRotation");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetRotation, Objective) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveGetRotation::Objective' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveGetRotation, ReturnValue) == 0x000024, "Member 'LAIUtilFuncLibrary_ObjectiveGetRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.ObjectiveIsValid
// 0x0028 (0x0028 - 0x0000)
struct LAIUtilFuncLibrary_ObjectiveIsValid final
{
public:
	struct FLAIObjective                          Objective;                                         // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_ObjectiveIsValid) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_ObjectiveIsValid");
static_assert(sizeof(LAIUtilFuncLibrary_ObjectiveIsValid) == 0x000028, "Wrong size on LAIUtilFuncLibrary_ObjectiveIsValid");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveIsValid, Objective) == 0x000000, "Member 'LAIUtilFuncLibrary_ObjectiveIsValid::Objective' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_ObjectiveIsValid, ReturnValue) == 0x000024, "Member 'LAIUtilFuncLibrary_ObjectiveIsValid::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.PropagationTest
// 0x0028 (0x0028 - 0x0000)
struct LAIUtilFuncLibrary_PropagationTest final
{
public:
	class AActor*                                 CriterionActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AroundLocation;                                    // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsideLength;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CacheName;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestVertAndHoriTrace;                             // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_PropagationTest) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_PropagationTest");
static_assert(sizeof(LAIUtilFuncLibrary_PropagationTest) == 0x000028, "Wrong size on LAIUtilFuncLibrary_PropagationTest");
static_assert(offsetof(LAIUtilFuncLibrary_PropagationTest, CriterionActor) == 0x000000, "Member 'LAIUtilFuncLibrary_PropagationTest::CriterionActor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_PropagationTest, AroundLocation) == 0x000008, "Member 'LAIUtilFuncLibrary_PropagationTest::AroundLocation' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_PropagationTest, InsideLength) == 0x000014, "Member 'LAIUtilFuncLibrary_PropagationTest::InsideLength' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_PropagationTest, CacheName) == 0x000018, "Member 'LAIUtilFuncLibrary_PropagationTest::CacheName' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_PropagationTest, bTestVertAndHoriTrace) == 0x000020, "Member 'LAIUtilFuncLibrary_PropagationTest::bTestVertAndHoriTrace' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_PropagationTest, ReturnValue) == 0x000021, "Member 'LAIUtilFuncLibrary_PropagationTest::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.RangeCheck_AllDistance
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_RangeCheck_AllDistance final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_RangeCheck_AllDistance) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_RangeCheck_AllDistance");
static_assert(sizeof(LAIUtilFuncLibrary_RangeCheck_AllDistance) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_RangeCheck_AllDistance");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, FailReason) == 0x000039, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_AllDistance, ReturnValue) == 0x00003A, "Member 'LAIUtilFuncLibrary_RangeCheck_AllDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.RangeCheck_Distance2D
// 0x003C (0x003C - 0x0000)
struct LAIUtilFuncLibrary_RangeCheck_Distance2D final
{
public:
	struct FLAICheckOwner                         CheckOwner;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAIObjective                          CheckTarget;                                       // 0x000C(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeMinMaxType                           MinMaxType;                                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIRangeCheckFailReason                      FailReason;                                        // 0x0039(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_RangeCheck_Distance2D) == 0x000004, "Wrong alignment on LAIUtilFuncLibrary_RangeCheck_Distance2D");
static_assert(sizeof(LAIUtilFuncLibrary_RangeCheck_Distance2D) == 0x00003C, "Wrong size on LAIUtilFuncLibrary_RangeCheck_Distance2D");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, CheckOwner) == 0x000000, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, CheckTarget) == 0x00000C, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::CheckTarget' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, MinRange) == 0x000030, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::MinRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, MaxRange) == 0x000034, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::MaxRange' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, MinMaxType) == 0x000038, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::MinMaxType' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, FailReason) == 0x000039, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::FailReason' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RangeCheck_Distance2D, ReturnValue) == 0x00003A, "Member 'LAIUtilFuncLibrary_RangeCheck_Distance2D::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.RemovePauseAI
// 0x0018 (0x0018 - 0x0000)
struct LAIUtilFuncLibrary_RemovePauseAI final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PauseName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintain;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_RemovePauseAI) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_RemovePauseAI");
static_assert(sizeof(LAIUtilFuncLibrary_RemovePauseAI) == 0x000018, "Wrong size on LAIUtilFuncLibrary_RemovePauseAI");
static_assert(offsetof(LAIUtilFuncLibrary_RemovePauseAI, Actor) == 0x000000, "Member 'LAIUtilFuncLibrary_RemovePauseAI::Actor' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RemovePauseAI, PauseName) == 0x000008, "Member 'LAIUtilFuncLibrary_RemovePauseAI::PauseName' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_RemovePauseAI, bMaintain) == 0x000010, "Member 'LAIUtilFuncLibrary_RemovePauseAI::bMaintain' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.SampleLocations
// 0x0058 (0x0058 - 0x0000)
struct LAIUtilFuncLibrary_SampleLocations final
{
public:
	struct FLAILocationSampler                    Sampler;                                           // 0x0000(0x0030)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class ALAIController*                         Querier;                                           // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SampleOrigin;                                      // 0x0038(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReSampleDistance;                                  // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleDistance;                                    // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpaceBetween;                                      // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_SampleLocations) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_SampleLocations");
static_assert(sizeof(LAIUtilFuncLibrary_SampleLocations) == 0x000058, "Wrong size on LAIUtilFuncLibrary_SampleLocations");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, Sampler) == 0x000000, "Member 'LAIUtilFuncLibrary_SampleLocations::Sampler' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, Querier) == 0x000030, "Member 'LAIUtilFuncLibrary_SampleLocations::Querier' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, SampleOrigin) == 0x000038, "Member 'LAIUtilFuncLibrary_SampleLocations::SampleOrigin' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, ReSampleDistance) == 0x000044, "Member 'LAIUtilFuncLibrary_SampleLocations::ReSampleDistance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, SampleDistance) == 0x000048, "Member 'LAIUtilFuncLibrary_SampleLocations::SampleDistance' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, SpaceBetween) == 0x00004C, "Member 'LAIUtilFuncLibrary_SampleLocations::SpaceBetween' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SampleLocations, ReturnValue) == 0x000050, "Member 'LAIUtilFuncLibrary_SampleLocations::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.SetAIEnabled
// 0x0010 (0x0010 - 0x0000)
struct LAIUtilFuncLibrary_SetAIEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_SetAIEnabled) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_SetAIEnabled");
static_assert(sizeof(LAIUtilFuncLibrary_SetAIEnabled) == 0x000010, "Wrong size on LAIUtilFuncLibrary_SetAIEnabled");
static_assert(offsetof(LAIUtilFuncLibrary_SetAIEnabled, WorldContextObject) == 0x000000, "Member 'LAIUtilFuncLibrary_SetAIEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_SetAIEnabled, bEnable) == 0x000008, "Member 'LAIUtilFuncLibrary_SetAIEnabled::bEnable' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.TestCanWalkOnNavi
// 0x0028 (0x0028 - 0x0000)
struct LAIUtilFuncLibrary_TestCanWalkOnNavi final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_TestCanWalkOnNavi) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_TestCanWalkOnNavi");
static_assert(sizeof(LAIUtilFuncLibrary_TestCanWalkOnNavi) == 0x000028, "Wrong size on LAIUtilFuncLibrary_TestCanWalkOnNavi");
static_assert(offsetof(LAIUtilFuncLibrary_TestCanWalkOnNavi, Character) == 0x000000, "Member 'LAIUtilFuncLibrary_TestCanWalkOnNavi::Character' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TestCanWalkOnNavi, Start) == 0x000008, "Member 'LAIUtilFuncLibrary_TestCanWalkOnNavi::Start' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TestCanWalkOnNavi, End) == 0x000014, "Member 'LAIUtilFuncLibrary_TestCanWalkOnNavi::End' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TestCanWalkOnNavi, ReturnValue) == 0x000020, "Member 'LAIUtilFuncLibrary_TestCanWalkOnNavi::ReturnValue' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.TraceMidpointWall
// 0x0038 (0x0038 - 0x0000)
struct LAIUtilFuncLibrary_TraceMidpointWall final
{
public:
	bool                                          bHasWall;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMidpointWall;                                  // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CheckOwner;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x001C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0028(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAIUtilFuncLibrary_TraceMidpointWall) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_TraceMidpointWall");
static_assert(sizeof(LAIUtilFuncLibrary_TraceMidpointWall) == 0x000038, "Wrong size on LAIUtilFuncLibrary_TraceMidpointWall");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, bHasWall) == 0x000000, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::bHasWall' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, bHasMidpointWall) == 0x000001, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::bHasMidpointWall' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, bDebug) == 0x000002, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::bDebug' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, CheckOwner) == 0x000008, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::CheckOwner' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, TraceStart) == 0x000010, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::TraceStart' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, TraceEnd) == 0x00001C, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::TraceEnd' has a wrong offset!");
static_assert(offsetof(LAIUtilFuncLibrary_TraceMidpointWall, GoalLocation) == 0x000028, "Member 'LAIUtilFuncLibrary_TraceMidpointWall::GoalLocation' has a wrong offset!");

// Function ProjectP.LAIUtilFuncLibrary.UpdateAIEnabled
// 0x0008 (0x0008 - 0x0000)
struct LAIUtilFuncLibrary_UpdateAIEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAIUtilFuncLibrary_UpdateAIEnabled) == 0x000008, "Wrong alignment on LAIUtilFuncLibrary_UpdateAIEnabled");
static_assert(sizeof(LAIUtilFuncLibrary_UpdateAIEnabled) == 0x000008, "Wrong size on LAIUtilFuncLibrary_UpdateAIEnabled");
static_assert(offsetof(LAIUtilFuncLibrary_UpdateAIEnabled, WorldContextObject) == 0x000000, "Member 'LAIUtilFuncLibrary_UpdateAIEnabled::WorldContextObject' has a wrong offset!");

// Function ProjectP.LAnimInstance.BindAnimFSMEvent
// 0x0018 (0x0018 - 0x0000)
struct LAnimInstance_BindAnimFSMEvent final
{
public:
	class FName                                   MachineName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           StateNameArray;                                    // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_BindAnimFSMEvent) == 0x000008, "Wrong alignment on LAnimInstance_BindAnimFSMEvent");
static_assert(sizeof(LAnimInstance_BindAnimFSMEvent) == 0x000018, "Wrong size on LAnimInstance_BindAnimFSMEvent");
static_assert(offsetof(LAnimInstance_BindAnimFSMEvent, MachineName) == 0x000000, "Member 'LAnimInstance_BindAnimFSMEvent::MachineName' has a wrong offset!");
static_assert(offsetof(LAnimInstance_BindAnimFSMEvent, StateNameArray) == 0x000008, "Member 'LAnimInstance_BindAnimFSMEvent::StateNameArray' has a wrong offset!");

// Function ProjectP.LAnimInstance.DoRagdollFreezeEnable
// 0x0001 (0x0001 - 0x0000)
struct LAnimInstance_DoRagdollFreezeEnable final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_DoRagdollFreezeEnable) == 0x000001, "Wrong alignment on LAnimInstance_DoRagdollFreezeEnable");
static_assert(sizeof(LAnimInstance_DoRagdollFreezeEnable) == 0x000001, "Wrong size on LAnimInstance_DoRagdollFreezeEnable");
static_assert(offsetof(LAnimInstance_DoRagdollFreezeEnable, Enable) == 0x000000, "Member 'LAnimInstance_DoRagdollFreezeEnable::Enable' has a wrong offset!");

// Function ProjectP.LAnimInstance.GetEmptyBoneRotation
// 0x0040 (0x0040 - 0x0000)
struct LAnimInstance_GetEmptyBoneRotation final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelativeTransformSpace                       TransformSpace;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_GetEmptyBoneRotation) == 0x000010, "Wrong alignment on LAnimInstance_GetEmptyBoneRotation");
static_assert(sizeof(LAnimInstance_GetEmptyBoneRotation) == 0x000040, "Wrong size on LAnimInstance_GetEmptyBoneRotation");
static_assert(offsetof(LAnimInstance_GetEmptyBoneRotation, BoneName) == 0x000000, "Member 'LAnimInstance_GetEmptyBoneRotation::BoneName' has a wrong offset!");
static_assert(offsetof(LAnimInstance_GetEmptyBoneRotation, TransformSpace) == 0x000008, "Member 'LAnimInstance_GetEmptyBoneRotation::TransformSpace' has a wrong offset!");
static_assert(offsetof(LAnimInstance_GetEmptyBoneRotation, ReturnValue) == 0x000010, "Member 'LAnimInstance_GetEmptyBoneRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAnimInstance.GetOwnerBaseRotation
// 0x0018 (0x0018 - 0x0000)
struct LAnimInstance_GetOwnerBaseRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_GetOwnerBaseRotation) == 0x000004, "Wrong alignment on LAnimInstance_GetOwnerBaseRotation");
static_assert(sizeof(LAnimInstance_GetOwnerBaseRotation) == 0x000018, "Wrong size on LAnimInstance_GetOwnerBaseRotation");
static_assert(offsetof(LAnimInstance_GetOwnerBaseRotation, Rotation) == 0x000000, "Member 'LAnimInstance_GetOwnerBaseRotation::Rotation' has a wrong offset!");
static_assert(offsetof(LAnimInstance_GetOwnerBaseRotation, ReturnValue) == 0x00000C, "Member 'LAnimInstance_GetOwnerBaseRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LAnimInstance.OnGraphStateChanged_Entry
// 0x00C0 (0x00C0 - 0x0000)
struct LAnimInstance_OnGraphStateChanged_Entry final
{
public:
	struct FAnimNode_StateMachine                 Machine;                                           // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         PrevStateIndex;                                    // 0x00B0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextStateIndex;                                    // 0x00B4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MachineName;                                       // 0x00B8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_OnGraphStateChanged_Entry) == 0x000008, "Wrong alignment on LAnimInstance_OnGraphStateChanged_Entry");
static_assert(sizeof(LAnimInstance_OnGraphStateChanged_Entry) == 0x0000C0, "Wrong size on LAnimInstance_OnGraphStateChanged_Entry");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Entry, Machine) == 0x000000, "Member 'LAnimInstance_OnGraphStateChanged_Entry::Machine' has a wrong offset!");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Entry, PrevStateIndex) == 0x0000B0, "Member 'LAnimInstance_OnGraphStateChanged_Entry::PrevStateIndex' has a wrong offset!");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Entry, NextStateIndex) == 0x0000B4, "Member 'LAnimInstance_OnGraphStateChanged_Entry::NextStateIndex' has a wrong offset!");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Entry, MachineName) == 0x0000B8, "Member 'LAnimInstance_OnGraphStateChanged_Entry::MachineName' has a wrong offset!");

// Function ProjectP.LAnimInstance.OnGraphStateChanged_Exit
// 0x00C0 (0x00C0 - 0x0000)
struct LAnimInstance_OnGraphStateChanged_Exit final
{
public:
	struct FAnimNode_StateMachine                 Machine;                                           // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         PrevStateIndex;                                    // 0x00B0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextStateIndex;                                    // 0x00B4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MachineName;                                       // 0x00B8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_OnGraphStateChanged_Exit) == 0x000008, "Wrong alignment on LAnimInstance_OnGraphStateChanged_Exit");
static_assert(sizeof(LAnimInstance_OnGraphStateChanged_Exit) == 0x0000C0, "Wrong size on LAnimInstance_OnGraphStateChanged_Exit");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Exit, Machine) == 0x000000, "Member 'LAnimInstance_OnGraphStateChanged_Exit::Machine' has a wrong offset!");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Exit, PrevStateIndex) == 0x0000B0, "Member 'LAnimInstance_OnGraphStateChanged_Exit::PrevStateIndex' has a wrong offset!");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Exit, NextStateIndex) == 0x0000B4, "Member 'LAnimInstance_OnGraphStateChanged_Exit::NextStateIndex' has a wrong offset!");
static_assert(offsetof(LAnimInstance_OnGraphStateChanged_Exit, MachineName) == 0x0000B8, "Member 'LAnimInstance_OnGraphStateChanged_Exit::MachineName' has a wrong offset!");

// Function ProjectP.LAnimInstance.PlaySlotStartLoopEndAnimationAsDynamicMontage
// 0x0040 (0x0040 - 0x0000)
struct LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage final
{
public:
	class FName                                   SlotNodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      StartAsset;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LoopAsset;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      EndAsset;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeToStartMontageAt;                            // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage) == 0x000008, "Wrong alignment on LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage");
static_assert(sizeof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage) == 0x000040, "Wrong size on LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, SlotNodeName) == 0x000000, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::SlotNodeName' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, StartAsset) == 0x000008, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::StartAsset' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, LoopAsset) == 0x000010, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::LoopAsset' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, EndAsset) == 0x000018, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::EndAsset' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, BlendInTime) == 0x000020, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::BlendInTime' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, BlendOutTime) == 0x000024, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::BlendOutTime' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, InPlayRate) == 0x000028, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::InPlayRate' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, LoopCount) == 0x00002C, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::LoopCount' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, BlendOutTriggerTime) == 0x000030, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, InTimeToStartMontageAt) == 0x000034, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::InTimeToStartMontageAt' has a wrong offset!");
static_assert(offsetof(LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage, ReturnValue) == 0x000038, "Member 'LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LAnimInstance.SetAdditiveHitType
// 0x0001 (0x0001 - 0x0000)
struct LAnimInstance_SetAdditiveHitType final
{
public:
	ELAdditiveHitType                             AdditiveHitType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_SetAdditiveHitType) == 0x000001, "Wrong alignment on LAnimInstance_SetAdditiveHitType");
static_assert(sizeof(LAnimInstance_SetAdditiveHitType) == 0x000001, "Wrong size on LAnimInstance_SetAdditiveHitType");
static_assert(offsetof(LAnimInstance_SetAdditiveHitType, AdditiveHitType) == 0x000000, "Member 'LAnimInstance_SetAdditiveHitType::AdditiveHitType' has a wrong offset!");

// Function ProjectP.LAnimInstance.SetSequenceBindingPlaying
// 0x0001 (0x0001 - 0x0000)
struct LAnimInstance_SetSequenceBindingPlaying final
{
public:
	bool                                          InPlaying;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_SetSequenceBindingPlaying) == 0x000001, "Wrong alignment on LAnimInstance_SetSequenceBindingPlaying");
static_assert(sizeof(LAnimInstance_SetSequenceBindingPlaying) == 0x000001, "Wrong size on LAnimInstance_SetSequenceBindingPlaying");
static_assert(offsetof(LAnimInstance_SetSequenceBindingPlaying, InPlaying) == 0x000000, "Member 'LAnimInstance_SetSequenceBindingPlaying::InPlaying' has a wrong offset!");

// Function ProjectP.LAnimInstance.GetAnimSwitchOnOff
// 0x000C (0x000C - 0x0000)
struct LAnimInstance_GetAnimSwitchOnOff final
{
public:
	class FName                                   SwitchName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LAnimInstance_GetAnimSwitchOnOff) == 0x000004, "Wrong alignment on LAnimInstance_GetAnimSwitchOnOff");
static_assert(sizeof(LAnimInstance_GetAnimSwitchOnOff) == 0x00000C, "Wrong size on LAnimInstance_GetAnimSwitchOnOff");
static_assert(offsetof(LAnimInstance_GetAnimSwitchOnOff, SwitchName) == 0x000000, "Member 'LAnimInstance_GetAnimSwitchOnOff::SwitchName' has a wrong offset!");
static_assert(offsetof(LAnimInstance_GetAnimSwitchOnOff, ReturnValue) == 0x000008, "Member 'LAnimInstance_GetAnimSwitchOnOff::ReturnValue' has a wrong offset!");

// Function ProjectP.LAnimInstance.GetBoneNames
// 0x0050 (0x0050 - 0x0000)
struct LAnimInstance_GetBoneNames final
{
public:
	struct FLDefinedBoneNames                     ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_GetBoneNames) == 0x000008, "Wrong alignment on LAnimInstance_GetBoneNames");
static_assert(sizeof(LAnimInstance_GetBoneNames) == 0x000050, "Wrong size on LAnimInstance_GetBoneNames");
static_assert(offsetof(LAnimInstance_GetBoneNames, ReturnValue) == 0x000000, "Member 'LAnimInstance_GetBoneNames::ReturnValue' has a wrong offset!");

// Function ProjectP.LAnimInstance.GetRigStretchBoneDistance
// 0x0014 (0x0014 - 0x0000)
struct LAnimInstance_GetRigStretchBoneDistance final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLRigStretchBone                       ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_GetRigStretchBoneDistance) == 0x000004, "Wrong alignment on LAnimInstance_GetRigStretchBoneDistance");
static_assert(sizeof(LAnimInstance_GetRigStretchBoneDistance) == 0x000014, "Wrong size on LAnimInstance_GetRigStretchBoneDistance");
static_assert(offsetof(LAnimInstance_GetRigStretchBoneDistance, BoneName) == 0x000000, "Member 'LAnimInstance_GetRigStretchBoneDistance::BoneName' has a wrong offset!");
static_assert(offsetof(LAnimInstance_GetRigStretchBoneDistance, ReturnValue) == 0x000008, "Member 'LAnimInstance_GetRigStretchBoneDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LAnimInstance.GetStretchBoneDistance
// 0x000C (0x000C - 0x0000)
struct LAnimInstance_GetStretchBoneDistance final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimInstance_GetStretchBoneDistance) == 0x000004, "Wrong alignment on LAnimInstance_GetStretchBoneDistance");
static_assert(sizeof(LAnimInstance_GetStretchBoneDistance) == 0x00000C, "Wrong size on LAnimInstance_GetStretchBoneDistance");
static_assert(offsetof(LAnimInstance_GetStretchBoneDistance, BoneName) == 0x000000, "Member 'LAnimInstance_GetStretchBoneDistance::BoneName' has a wrong offset!");
static_assert(offsetof(LAnimInstance_GetStretchBoneDistance, ReturnValue) == 0x000008, "Member 'LAnimInstance_GetStretchBoneDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LIKUtilFuncLibrary.FootIK_CalcuateOffset
// 0x00C0 (0x00C0 - 0x0000)
struct LIKUtilFuncLibrary_FootIK_CalcuateOffset final
{
public:
	class ULAnimInstance*                         AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLInverseKinemetic                     IK;                                                // 0x0008(0x0040)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLFootIKContext                        FootIKContext;                                     // 0x0048(0x0074)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x00BC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LIKUtilFuncLibrary_FootIK_CalcuateOffset) == 0x000008, "Wrong alignment on LIKUtilFuncLibrary_FootIK_CalcuateOffset");
static_assert(sizeof(LIKUtilFuncLibrary_FootIK_CalcuateOffset) == 0x0000C0, "Wrong size on LIKUtilFuncLibrary_FootIK_CalcuateOffset");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_CalcuateOffset, AnimInstance) == 0x000000, "Member 'LIKUtilFuncLibrary_FootIK_CalcuateOffset::AnimInstance' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_CalcuateOffset, IK) == 0x000008, "Member 'LIKUtilFuncLibrary_FootIK_CalcuateOffset::IK' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_CalcuateOffset, FootIKContext) == 0x000048, "Member 'LIKUtilFuncLibrary_FootIK_CalcuateOffset::FootIKContext' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_CalcuateOffset, DeltaTime) == 0x0000BC, "Member 'LIKUtilFuncLibrary_FootIK_CalcuateOffset::DeltaTime' has a wrong offset!");

// Function ProjectP.LIKUtilFuncLibrary.FootIK_GetPelvisOffset
// 0x0060 (0x0060 - 0x0000)
struct LIKUtilFuncLibrary_FootIK_GetPelvisOffset final
{
public:
	class ULAnimInstance*                         AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLInverseKinemetic                     IK;                                                // 0x0008(0x0040)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FLFootIKContext>                FootIKContexts;                                    // 0x0048(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LIKUtilFuncLibrary_FootIK_GetPelvisOffset) == 0x000008, "Wrong alignment on LIKUtilFuncLibrary_FootIK_GetPelvisOffset");
static_assert(sizeof(LIKUtilFuncLibrary_FootIK_GetPelvisOffset) == 0x000060, "Wrong size on LIKUtilFuncLibrary_FootIK_GetPelvisOffset");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_GetPelvisOffset, AnimInstance) == 0x000000, "Member 'LIKUtilFuncLibrary_FootIK_GetPelvisOffset::AnimInstance' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_GetPelvisOffset, IK) == 0x000008, "Member 'LIKUtilFuncLibrary_FootIK_GetPelvisOffset::IK' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_GetPelvisOffset, FootIKContexts) == 0x000048, "Member 'LIKUtilFuncLibrary_FootIK_GetPelvisOffset::FootIKContexts' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_GetPelvisOffset, DeltaTime) == 0x000058, "Member 'LIKUtilFuncLibrary_FootIK_GetPelvisOffset::DeltaTime' has a wrong offset!");

// Function ProjectP.LIKUtilFuncLibrary.FootIK_Trace
// 0x00C0 (0x00C0 - 0x0000)
struct LIKUtilFuncLibrary_FootIK_Trace final
{
public:
	class ULAnimInstance*                         AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLInverseKinemetic                     IK;                                                // 0x0008(0x0040)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLFootIKContext                        FootIKContext;                                     // 0x0048(0x0074)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x00BC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LIKUtilFuncLibrary_FootIK_Trace) == 0x000008, "Wrong alignment on LIKUtilFuncLibrary_FootIK_Trace");
static_assert(sizeof(LIKUtilFuncLibrary_FootIK_Trace) == 0x0000C0, "Wrong size on LIKUtilFuncLibrary_FootIK_Trace");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_Trace, AnimInstance) == 0x000000, "Member 'LIKUtilFuncLibrary_FootIK_Trace::AnimInstance' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_Trace, IK) == 0x000008, "Member 'LIKUtilFuncLibrary_FootIK_Trace::IK' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_Trace, FootIKContext) == 0x000048, "Member 'LIKUtilFuncLibrary_FootIK_Trace::FootIKContext' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_FootIK_Trace, DeltaTime) == 0x0000BC, "Member 'LIKUtilFuncLibrary_FootIK_Trace::DeltaTime' has a wrong offset!");

// Function ProjectP.LIKUtilFuncLibrary.IK_Update
// 0x0050 (0x0050 - 0x0000)
struct LIKUtilFuncLibrary_IK_Update final
{
public:
	class ULAnimInstance*                         AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLInverseKinemetic                     IK;                                                // 0x0008(0x0040)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LIKUtilFuncLibrary_IK_Update) == 0x000008, "Wrong alignment on LIKUtilFuncLibrary_IK_Update");
static_assert(sizeof(LIKUtilFuncLibrary_IK_Update) == 0x000050, "Wrong size on LIKUtilFuncLibrary_IK_Update");
static_assert(offsetof(LIKUtilFuncLibrary_IK_Update, AnimInstance) == 0x000000, "Member 'LIKUtilFuncLibrary_IK_Update::AnimInstance' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_IK_Update, IK) == 0x000008, "Member 'LIKUtilFuncLibrary_IK_Update::IK' has a wrong offset!");
static_assert(offsetof(LIKUtilFuncLibrary_IK_Update, DeltaTime) == 0x000048, "Member 'LIKUtilFuncLibrary_IK_Update::DeltaTime' has a wrong offset!");

// Function ProjectP.LAnimNotifyState_Trail_Inner.OverridePSTemplate
// 0x0018 (0x0018 - 0x0000)
struct LAnimNotifyState_Trail_Inner_OverridePSTemplate final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAnimNotifyState_Trail_Inner_OverridePSTemplate) == 0x000008, "Wrong alignment on LAnimNotifyState_Trail_Inner_OverridePSTemplate");
static_assert(sizeof(LAnimNotifyState_Trail_Inner_OverridePSTemplate) == 0x000018, "Wrong size on LAnimNotifyState_Trail_Inner_OverridePSTemplate");
static_assert(offsetof(LAnimNotifyState_Trail_Inner_OverridePSTemplate, MeshComp) == 0x000000, "Member 'LAnimNotifyState_Trail_Inner_OverridePSTemplate::MeshComp' has a wrong offset!");
static_assert(offsetof(LAnimNotifyState_Trail_Inner_OverridePSTemplate, Animation) == 0x000008, "Member 'LAnimNotifyState_Trail_Inner_OverridePSTemplate::Animation' has a wrong offset!");
static_assert(offsetof(LAnimNotifyState_Trail_Inner_OverridePSTemplate, ReturnValue) == 0x000010, "Member 'LAnimNotifyState_Trail_Inner_OverridePSTemplate::ReturnValue' has a wrong offset!");

// Function ProjectP.LAssetLoader.FindOrLoadAssetSlowly
// 0x0030 (0x0030 - 0x0000)
struct LAssetLoader_FindOrLoadAssetSlowly final
{
public:
	TSoftObjectPtr<class UObject>                 Asset;                                             // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAssetLoader_FindOrLoadAssetSlowly) == 0x000008, "Wrong alignment on LAssetLoader_FindOrLoadAssetSlowly");
static_assert(sizeof(LAssetLoader_FindOrLoadAssetSlowly) == 0x000030, "Wrong size on LAssetLoader_FindOrLoadAssetSlowly");
static_assert(offsetof(LAssetLoader_FindOrLoadAssetSlowly, Asset) == 0x000000, "Member 'LAssetLoader_FindOrLoadAssetSlowly::Asset' has a wrong offset!");
static_assert(offsetof(LAssetLoader_FindOrLoadAssetSlowly, ReturnValue) == 0x000028, "Member 'LAssetLoader_FindOrLoadAssetSlowly::ReturnValue' has a wrong offset!");

// Function ProjectP.LAssetLoader.FindOrLoadClassSlowly
// 0x0030 (0x0030 - 0x0000)
struct LAssetLoader_FindOrLoadClassSlowly final
{
public:
	TSoftClassPtr<class UClass>                   AssetClass;                                        // 0x0000(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LAssetLoader_FindOrLoadClassSlowly) == 0x000008, "Wrong alignment on LAssetLoader_FindOrLoadClassSlowly");
static_assert(sizeof(LAssetLoader_FindOrLoadClassSlowly) == 0x000030, "Wrong size on LAssetLoader_FindOrLoadClassSlowly");
static_assert(offsetof(LAssetLoader_FindOrLoadClassSlowly, AssetClass) == 0x000000, "Member 'LAssetLoader_FindOrLoadClassSlowly::AssetClass' has a wrong offset!");
static_assert(offsetof(LAssetLoader_FindOrLoadClassSlowly, ReturnValue) == 0x000028, "Member 'LAssetLoader_FindOrLoadClassSlowly::ReturnValue' has a wrong offset!");

// Function ProjectP.LBDecorator_BlueprintBase.GetBehaivorTreeNodeName
// 0x0010 (0x0010 - 0x0000)
struct LBDecorator_BlueprintBase_GetBehaivorTreeNodeName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBDecorator_BlueprintBase_GetBehaivorTreeNodeName) == 0x000008, "Wrong alignment on LBDecorator_BlueprintBase_GetBehaivorTreeNodeName");
static_assert(sizeof(LBDecorator_BlueprintBase_GetBehaivorTreeNodeName) == 0x000010, "Wrong size on LBDecorator_BlueprintBase_GetBehaivorTreeNodeName");
static_assert(offsetof(LBDecorator_BlueprintBase_GetBehaivorTreeNodeName, ReturnValue) == 0x000000, "Member 'LBDecorator_BlueprintBase_GetBehaivorTreeNodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LBDecorator_BlueprintBase.SetBehaivorTreeNodeName
// 0x0010 (0x0010 - 0x0000)
struct LBDecorator_BlueprintBase_SetBehaivorTreeNodeName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBDecorator_BlueprintBase_SetBehaivorTreeNodeName) == 0x000008, "Wrong alignment on LBDecorator_BlueprintBase_SetBehaivorTreeNodeName");
static_assert(sizeof(LBDecorator_BlueprintBase_SetBehaivorTreeNodeName) == 0x000010, "Wrong size on LBDecorator_BlueprintBase_SetBehaivorTreeNodeName");
static_assert(offsetof(LBDecorator_BlueprintBase_SetBehaivorTreeNodeName, Name_0) == 0x000000, "Member 'LBDecorator_BlueprintBase_SetBehaivorTreeNodeName::Name_0' has a wrong offset!");

// Function ProjectP.LBodyStain_Common.Initialize
// 0x0058 (0x0058 - 0x0000)
struct LBodyStain_Common_Initialize final
{
public:
	class ALCharacter*                            InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InCodeName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyStainCategory                           InCategory;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InPriority;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULMaterialVarying>       InMaterialVaryingRef;                              // 0x0018(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStartTimeDelay;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRemainTimeForRewind;                             // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForwardTimeScale;                                // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRewindTimeScale;                                 // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InRewindOnRemove;                                  // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStain_Common_Initialize) == 0x000008, "Wrong alignment on LBodyStain_Common_Initialize");
static_assert(sizeof(LBodyStain_Common_Initialize) == 0x000058, "Wrong size on LBodyStain_Common_Initialize");
static_assert(offsetof(LBodyStain_Common_Initialize, InOwner) == 0x000000, "Member 'LBodyStain_Common_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InCodeName) == 0x000008, "Member 'LBodyStain_Common_Initialize::InCodeName' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InCategory) == 0x000010, "Member 'LBodyStain_Common_Initialize::InCategory' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InPriority) == 0x000014, "Member 'LBodyStain_Common_Initialize::InPriority' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InMaterialVaryingRef) == 0x000018, "Member 'LBodyStain_Common_Initialize::InMaterialVaryingRef' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InStartTimeDelay) == 0x000040, "Member 'LBodyStain_Common_Initialize::InStartTimeDelay' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InRemainTimeForRewind) == 0x000044, "Member 'LBodyStain_Common_Initialize::InRemainTimeForRewind' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InForwardTimeScale) == 0x000048, "Member 'LBodyStain_Common_Initialize::InForwardTimeScale' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InRewindTimeScale) == 0x00004C, "Member 'LBodyStain_Common_Initialize::InRewindTimeScale' has a wrong offset!");
static_assert(offsetof(LBodyStain_Common_Initialize, InRewindOnRemove) == 0x000050, "Member 'LBodyStain_Common_Initialize::InRewindOnRemove' has a wrong offset!");

// Function ProjectP.LBodyStain_Common.IsRewinding
// 0x0001 (0x0001 - 0x0000)
struct LBodyStain_Common_IsRewinding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Common_IsRewinding) == 0x000001, "Wrong alignment on LBodyStain_Common_IsRewinding");
static_assert(sizeof(LBodyStain_Common_IsRewinding) == 0x000001, "Wrong size on LBodyStain_Common_IsRewinding");
static_assert(offsetof(LBodyStain_Common_IsRewinding, ReturnValue) == 0x000000, "Member 'LBodyStain_Common_IsRewinding::ReturnValue' has a wrong offset!");

// Function ProjectP.LBodyStain_Blood.Initialize
// 0x0038 (0x0038 - 0x0000)
struct LBodyStain_Blood_Initialize final
{
public:
	class ALCharacter*                            InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyStainCategory                           InCategory;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InPriority;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InLevel;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAmount;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InWetColor;                                        // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeApplyWet;                                    // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeRemainWet;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeRewindWet;                                   // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStain_Blood_Initialize) == 0x000008, "Wrong alignment on LBodyStain_Blood_Initialize");
static_assert(sizeof(LBodyStain_Blood_Initialize) == 0x000038, "Wrong size on LBodyStain_Blood_Initialize");
static_assert(offsetof(LBodyStain_Blood_Initialize, InOwner) == 0x000000, "Member 'LBodyStain_Blood_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InCategory) == 0x000008, "Member 'LBodyStain_Blood_Initialize::InCategory' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InPriority) == 0x00000C, "Member 'LBodyStain_Blood_Initialize::InPriority' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InLevel) == 0x000010, "Member 'LBodyStain_Blood_Initialize::InLevel' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InAmount) == 0x000014, "Member 'LBodyStain_Blood_Initialize::InAmount' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InWetColor) == 0x000018, "Member 'LBodyStain_Blood_Initialize::InWetColor' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InTimeApplyWet) == 0x000028, "Member 'LBodyStain_Blood_Initialize::InTimeApplyWet' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InTimeRemainWet) == 0x00002C, "Member 'LBodyStain_Blood_Initialize::InTimeRemainWet' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_Initialize, InTimeRewindWet) == 0x000030, "Member 'LBodyStain_Blood_Initialize::InTimeRewindWet' has a wrong offset!");

// Function ProjectP.LBodyStain_Blood.UpdateColorAndAmount
// 0x0018 (0x0018 - 0x0000)
struct LBodyStain_Blood_UpdateColorAndAmount final
{
public:
	int32                                         InLevel;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InBloodColor;                                      // 0x0004(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAmount;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Blood_UpdateColorAndAmount) == 0x000004, "Wrong alignment on LBodyStain_Blood_UpdateColorAndAmount");
static_assert(sizeof(LBodyStain_Blood_UpdateColorAndAmount) == 0x000018, "Wrong size on LBodyStain_Blood_UpdateColorAndAmount");
static_assert(offsetof(LBodyStain_Blood_UpdateColorAndAmount, InLevel) == 0x000000, "Member 'LBodyStain_Blood_UpdateColorAndAmount::InLevel' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_UpdateColorAndAmount, InBloodColor) == 0x000004, "Member 'LBodyStain_Blood_UpdateColorAndAmount::InBloodColor' has a wrong offset!");
static_assert(offsetof(LBodyStain_Blood_UpdateColorAndAmount, InAmount) == 0x000014, "Member 'LBodyStain_Blood_UpdateColorAndAmount::InAmount' has a wrong offset!");

// Function ProjectP.LBodyStain_Wet_Body.Initialize
// 0x0018 (0x0018 - 0x0000)
struct LBodyStain_Wet_Body_Initialize final
{
public:
	class ALCharacter*                            InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeApplyWet_by_Sink;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeApplyWet_by_WaterDrop;                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeRemainWet;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeRewindWet;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Wet_Body_Initialize) == 0x000008, "Wrong alignment on LBodyStain_Wet_Body_Initialize");
static_assert(sizeof(LBodyStain_Wet_Body_Initialize) == 0x000018, "Wrong size on LBodyStain_Wet_Body_Initialize");
static_assert(offsetof(LBodyStain_Wet_Body_Initialize, InOwner) == 0x000000, "Member 'LBodyStain_Wet_Body_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Body_Initialize, InTimeApplyWet_by_Sink) == 0x000008, "Member 'LBodyStain_Wet_Body_Initialize::InTimeApplyWet_by_Sink' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Body_Initialize, InTimeApplyWet_by_WaterDrop) == 0x00000C, "Member 'LBodyStain_Wet_Body_Initialize::InTimeApplyWet_by_WaterDrop' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Body_Initialize, InTimeRemainWet) == 0x000010, "Member 'LBodyStain_Wet_Body_Initialize::InTimeRemainWet' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Body_Initialize, InTimeRewindWet) == 0x000014, "Member 'LBodyStain_Wet_Body_Initialize::InTimeRewindWet' has a wrong offset!");

// Function ProjectP.LBodyStain_Wet_Body.SetTargetAmount
// 0x0008 (0x0008 - 0x0000)
struct LBodyStain_Wet_Body_SetTargetAmount final
{
public:
	float                                         InAmount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyWetReasonType                           WetReason;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStain_Wet_Body_SetTargetAmount) == 0x000004, "Wrong alignment on LBodyStain_Wet_Body_SetTargetAmount");
static_assert(sizeof(LBodyStain_Wet_Body_SetTargetAmount) == 0x000008, "Wrong size on LBodyStain_Wet_Body_SetTargetAmount");
static_assert(offsetof(LBodyStain_Wet_Body_SetTargetAmount, InAmount) == 0x000000, "Member 'LBodyStain_Wet_Body_SetTargetAmount::InAmount' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Body_SetTargetAmount, WetReason) == 0x000004, "Member 'LBodyStain_Wet_Body_SetTargetAmount::WetReason' has a wrong offset!");

// Function ProjectP.LBodyStain_Wet_Body.SetTargetColor
// 0x0014 (0x0014 - 0x0000)
struct LBodyStain_Wet_Body_SetTargetColor final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyWetReasonType                           WetReason;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStain_Wet_Body_SetTargetColor) == 0x000004, "Wrong alignment on LBodyStain_Wet_Body_SetTargetColor");
static_assert(sizeof(LBodyStain_Wet_Body_SetTargetColor) == 0x000014, "Wrong size on LBodyStain_Wet_Body_SetTargetColor");
static_assert(offsetof(LBodyStain_Wet_Body_SetTargetColor, InColor) == 0x000000, "Member 'LBodyStain_Wet_Body_SetTargetColor::InColor' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Body_SetTargetColor, WetReason) == 0x000010, "Member 'LBodyStain_Wet_Body_SetTargetColor::WetReason' has a wrong offset!");

// Function ProjectP.LBodyStain_Wet_Leg.Initialize
// 0x0028 (0x0028 - 0x0000)
struct LBodyStain_Wet_Leg_Initialize final
{
public:
	class ALCharacter*                            InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InPhysicalSurface;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           InWetColor;                                        // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPriority_Wet_Leg;                                // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeRemainWet;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDrySpeed;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Wet_Leg_Initialize) == 0x000008, "Wrong alignment on LBodyStain_Wet_Leg_Initialize");
static_assert(sizeof(LBodyStain_Wet_Leg_Initialize) == 0x000028, "Wrong size on LBodyStain_Wet_Leg_Initialize");
static_assert(offsetof(LBodyStain_Wet_Leg_Initialize, InOwner) == 0x000000, "Member 'LBodyStain_Wet_Leg_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Leg_Initialize, InPhysicalSurface) == 0x000008, "Member 'LBodyStain_Wet_Leg_Initialize::InPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Leg_Initialize, InWetColor) == 0x00000C, "Member 'LBodyStain_Wet_Leg_Initialize::InWetColor' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Leg_Initialize, InPriority_Wet_Leg) == 0x00001C, "Member 'LBodyStain_Wet_Leg_Initialize::InPriority_Wet_Leg' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Leg_Initialize, InTimeRemainWet) == 0x000020, "Member 'LBodyStain_Wet_Leg_Initialize::InTimeRemainWet' has a wrong offset!");
static_assert(offsetof(LBodyStain_Wet_Leg_Initialize, InDrySpeed) == 0x000024, "Member 'LBodyStain_Wet_Leg_Initialize::InDrySpeed' has a wrong offset!");

// Function ProjectP.LBodyStain_Wet_Leg.SetTargetColor
// 0x0010 (0x0010 - 0x0000)
struct LBodyStain_Wet_Leg_SetTargetColor final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Wet_Leg_SetTargetColor) == 0x000004, "Wrong alignment on LBodyStain_Wet_Leg_SetTargetColor");
static_assert(sizeof(LBodyStain_Wet_Leg_SetTargetColor) == 0x000010, "Wrong size on LBodyStain_Wet_Leg_SetTargetColor");
static_assert(offsetof(LBodyStain_Wet_Leg_SetTargetColor, InColor) == 0x000000, "Member 'LBodyStain_Wet_Leg_SetTargetColor::InColor' has a wrong offset!");

// Function ProjectP.LBodyStain_Wet_Leg.SetTargetHeight
// 0x0004 (0x0004 - 0x0000)
struct LBodyStain_Wet_Leg_SetTargetHeight final
{
public:
	float                                         InHeight;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Wet_Leg_SetTargetHeight) == 0x000004, "Wrong alignment on LBodyStain_Wet_Leg_SetTargetHeight");
static_assert(sizeof(LBodyStain_Wet_Leg_SetTargetHeight) == 0x000004, "Wrong size on LBodyStain_Wet_Leg_SetTargetHeight");
static_assert(offsetof(LBodyStain_Wet_Leg_SetTargetHeight, InHeight) == 0x000000, "Member 'LBodyStain_Wet_Leg_SetTargetHeight::InHeight' has a wrong offset!");

// Function ProjectP.LBodyStain_Burn.Initialize
// 0x0030 (0x0030 - 0x0000)
struct LBodyStain_Burn_Initialize final
{
public:
	class ALCharacter*                            InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InCodeName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyStainCategory                           InType;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InPriority;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBurnAmount;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InEmissiveFade;                                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime_Apply_Burn;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime_Rewind_Burn;                                // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime_Remain_Dust;                                // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime_Rewind_Dust;                                // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStain_Burn_Initialize) == 0x000008, "Wrong alignment on LBodyStain_Burn_Initialize");
static_assert(sizeof(LBodyStain_Burn_Initialize) == 0x000030, "Wrong size on LBodyStain_Burn_Initialize");
static_assert(offsetof(LBodyStain_Burn_Initialize, InOwner) == 0x000000, "Member 'LBodyStain_Burn_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InCodeName) == 0x000008, "Member 'LBodyStain_Burn_Initialize::InCodeName' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InType) == 0x000010, "Member 'LBodyStain_Burn_Initialize::InType' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InPriority) == 0x000014, "Member 'LBodyStain_Burn_Initialize::InPriority' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InBurnAmount) == 0x000018, "Member 'LBodyStain_Burn_Initialize::InBurnAmount' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InEmissiveFade) == 0x00001C, "Member 'LBodyStain_Burn_Initialize::InEmissiveFade' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InTime_Apply_Burn) == 0x000020, "Member 'LBodyStain_Burn_Initialize::InTime_Apply_Burn' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InTime_Rewind_Burn) == 0x000024, "Member 'LBodyStain_Burn_Initialize::InTime_Rewind_Burn' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InTime_Remain_Dust) == 0x000028, "Member 'LBodyStain_Burn_Initialize::InTime_Remain_Dust' has a wrong offset!");
static_assert(offsetof(LBodyStain_Burn_Initialize, InTime_Rewind_Dust) == 0x00002C, "Member 'LBodyStain_Burn_Initialize::InTime_Rewind_Dust' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.AddLoopWetBodyInfo
// 0x0018 (0x0018 - 0x0000)
struct LBodyStainComponent_AddLoopWetBodyInfo final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InAmount;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWaterDrop;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStainComponent_AddLoopWetBodyInfo) == 0x000008, "Wrong alignment on LBodyStainComponent_AddLoopWetBodyInfo");
static_assert(sizeof(LBodyStainComponent_AddLoopWetBodyInfo) == 0x000018, "Wrong size on LBodyStainComponent_AddLoopWetBodyInfo");
static_assert(offsetof(LBodyStainComponent_AddLoopWetBodyInfo, Instigator) == 0x000000, "Member 'LBodyStainComponent_AddLoopWetBodyInfo::Instigator' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_AddLoopWetBodyInfo, PhysicalSurface) == 0x000008, "Member 'LBodyStainComponent_AddLoopWetBodyInfo::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_AddLoopWetBodyInfo, InAmount) == 0x00000C, "Member 'LBodyStainComponent_AddLoopWetBodyInfo::InAmount' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_AddLoopWetBodyInfo, IsWaterDrop) == 0x000010, "Member 'LBodyStainComponent_AddLoopWetBodyInfo::IsWaterDrop' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.ApplyBodyStainData
// 0x0010 (0x0010 - 0x0000)
struct LBodyStainComponent_ApplyBodyStainData final
{
public:
	class ULBodyStain_Base*                       BodyStain;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimePlayFrom;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStainComponent_ApplyBodyStainData) == 0x000008, "Wrong alignment on LBodyStainComponent_ApplyBodyStainData");
static_assert(sizeof(LBodyStainComponent_ApplyBodyStainData) == 0x000010, "Wrong size on LBodyStainComponent_ApplyBodyStainData");
static_assert(offsetof(LBodyStainComponent_ApplyBodyStainData, BodyStain) == 0x000000, "Member 'LBodyStainComponent_ApplyBodyStainData::BodyStain' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_ApplyBodyStainData, TimePlayFrom) == 0x000008, "Member 'LBodyStainComponent_ApplyBodyStainData::TimePlayFrom' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.GetBodyStain
// 0x0010 (0x0010 - 0x0000)
struct LBodyStainComponent_GetBodyStain final
{
public:
	ELBodyStainCategory                           InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULBodyStain_Base*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_GetBodyStain) == 0x000008, "Wrong alignment on LBodyStainComponent_GetBodyStain");
static_assert(sizeof(LBodyStainComponent_GetBodyStain) == 0x000010, "Wrong size on LBodyStainComponent_GetBodyStain");
static_assert(offsetof(LBodyStainComponent_GetBodyStain, InType) == 0x000000, "Member 'LBodyStainComponent_GetBodyStain::InType' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_GetBodyStain, ReturnValue) == 0x000008, "Member 'LBodyStainComponent_GetBodyStain::ReturnValue' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.GetBodyStain_by_CodeName
// 0x0010 (0x0010 - 0x0000)
struct LBodyStainComponent_GetBodyStain_by_CodeName final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULBodyStain_Base*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_GetBodyStain_by_CodeName) == 0x000008, "Wrong alignment on LBodyStainComponent_GetBodyStain_by_CodeName");
static_assert(sizeof(LBodyStainComponent_GetBodyStain_by_CodeName) == 0x000010, "Wrong size on LBodyStainComponent_GetBodyStain_by_CodeName");
static_assert(offsetof(LBodyStainComponent_GetBodyStain_by_CodeName, InCodeName) == 0x000000, "Member 'LBodyStainComponent_GetBodyStain_by_CodeName::InCodeName' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_GetBodyStain_by_CodeName, ReturnValue) == 0x000008, "Member 'LBodyStainComponent_GetBodyStain_by_CodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.OnBloodOptionChanged
// 0x0001 (0x0001 - 0x0000)
struct LBodyStainComponent_OnBloodOptionChanged final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_OnBloodOptionChanged) == 0x000001, "Wrong alignment on LBodyStainComponent_OnBloodOptionChanged");
static_assert(sizeof(LBodyStainComponent_OnBloodOptionChanged) == 0x000001, "Wrong size on LBodyStainComponent_OnBloodOptionChanged");
static_assert(offsetof(LBodyStainComponent_OnBloodOptionChanged, bEnable) == 0x000000, "Member 'LBodyStainComponent_OnBloodOptionChanged::bEnable' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.OnRemoveBodyStain
// 0x000C (0x000C - 0x0000)
struct LBodyStainComponent_OnRemoveBodyStain final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyStainCategory                           InCategory;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStainComponent_OnRemoveBodyStain) == 0x000004, "Wrong alignment on LBodyStainComponent_OnRemoveBodyStain");
static_assert(sizeof(LBodyStainComponent_OnRemoveBodyStain) == 0x00000C, "Wrong size on LBodyStainComponent_OnRemoveBodyStain");
static_assert(offsetof(LBodyStainComponent_OnRemoveBodyStain, InCodeName) == 0x000000, "Member 'LBodyStainComponent_OnRemoveBodyStain::InCodeName' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_OnRemoveBodyStain, InCategory) == 0x000008, "Member 'LBodyStainComponent_OnRemoveBodyStain::InCategory' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.OnRewindBodyStain
// 0x000C (0x000C - 0x0000)
struct LBodyStainComponent_OnRewindBodyStain final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBodyStainCategory                           InCategory;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStainComponent_OnRewindBodyStain) == 0x000004, "Wrong alignment on LBodyStainComponent_OnRewindBodyStain");
static_assert(sizeof(LBodyStainComponent_OnRewindBodyStain) == 0x00000C, "Wrong size on LBodyStainComponent_OnRewindBodyStain");
static_assert(offsetof(LBodyStainComponent_OnRewindBodyStain, InCodeName) == 0x000000, "Member 'LBodyStainComponent_OnRewindBodyStain::InCodeName' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_OnRewindBodyStain, InCategory) == 0x000008, "Member 'LBodyStainComponent_OnRewindBodyStain::InCategory' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.PlayStain_Abnormal
// 0x0008 (0x0008 - 0x0000)
struct LBodyStainComponent_PlayStain_Abnormal final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_PlayStain_Abnormal) == 0x000004, "Wrong alignment on LBodyStainComponent_PlayStain_Abnormal");
static_assert(sizeof(LBodyStainComponent_PlayStain_Abnormal) == 0x000008, "Wrong size on LBodyStainComponent_PlayStain_Abnormal");
static_assert(offsetof(LBodyStainComponent_PlayStain_Abnormal, EventName) == 0x000000, "Member 'LBodyStainComponent_PlayStain_Abnormal::EventName' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.PlayStain_Blood
// 0x000C (0x000C - 0x0000)
struct LBodyStainComponent_PlayStain_Blood final
{
public:
	ELBloodEffectType                             BloodType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InBloodLevel;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApplyTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_PlayStain_Blood) == 0x000004, "Wrong alignment on LBodyStainComponent_PlayStain_Blood");
static_assert(sizeof(LBodyStainComponent_PlayStain_Blood) == 0x00000C, "Wrong size on LBodyStainComponent_PlayStain_Blood");
static_assert(offsetof(LBodyStainComponent_PlayStain_Blood, BloodType) == 0x000000, "Member 'LBodyStainComponent_PlayStain_Blood::BloodType' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_PlayStain_Blood, InBloodLevel) == 0x000004, "Member 'LBodyStainComponent_PlayStain_Blood::InBloodLevel' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_PlayStain_Blood, ApplyTime) == 0x000008, "Member 'LBodyStainComponent_PlayStain_Blood::ApplyTime' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.PlayStain_Wet_Body
// 0x000C (0x000C - 0x0000)
struct LBodyStainComponent_PlayStain_Wet_Body final
{
public:
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InAmount;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWaterDrop;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LBodyStainComponent_PlayStain_Wet_Body) == 0x000004, "Wrong alignment on LBodyStainComponent_PlayStain_Wet_Body");
static_assert(sizeof(LBodyStainComponent_PlayStain_Wet_Body) == 0x00000C, "Wrong size on LBodyStainComponent_PlayStain_Wet_Body");
static_assert(offsetof(LBodyStainComponent_PlayStain_Wet_Body, PhysicalSurface) == 0x000000, "Member 'LBodyStainComponent_PlayStain_Wet_Body::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_PlayStain_Wet_Body, InAmount) == 0x000004, "Member 'LBodyStainComponent_PlayStain_Wet_Body::InAmount' has a wrong offset!");
static_assert(offsetof(LBodyStainComponent_PlayStain_Wet_Body, IsWaterDrop) == 0x000008, "Member 'LBodyStainComponent_PlayStain_Wet_Body::IsWaterDrop' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.PlayStain_Wet_Leg
// 0x0001 (0x0001 - 0x0000)
struct LBodyStainComponent_PlayStain_Wet_Leg final
{
public:
	ELPhysicalSurfaceType                         SurfaceType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_PlayStain_Wet_Leg) == 0x000001, "Wrong alignment on LBodyStainComponent_PlayStain_Wet_Leg");
static_assert(sizeof(LBodyStainComponent_PlayStain_Wet_Leg) == 0x000001, "Wrong size on LBodyStainComponent_PlayStain_Wet_Leg");
static_assert(offsetof(LBodyStainComponent_PlayStain_Wet_Leg, SurfaceType) == 0x000000, "Member 'LBodyStainComponent_PlayStain_Wet_Leg::SurfaceType' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.Refresh
// 0x0008 (0x0008 - 0x0000)
struct LBodyStainComponent_Refresh final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_Refresh) == 0x000008, "Wrong alignment on LBodyStainComponent_Refresh");
static_assert(sizeof(LBodyStainComponent_Refresh) == 0x000008, "Wrong size on LBodyStainComponent_Refresh");
static_assert(offsetof(LBodyStainComponent_Refresh, SkeletalMeshComponent) == 0x000000, "Member 'LBodyStainComponent_Refresh::SkeletalMeshComponent' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.RemoveBodyStain
// 0x0008 (0x0008 - 0x0000)
struct LBodyStainComponent_RemoveBodyStain final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_RemoveBodyStain) == 0x000004, "Wrong alignment on LBodyStainComponent_RemoveBodyStain");
static_assert(sizeof(LBodyStainComponent_RemoveBodyStain) == 0x000008, "Wrong size on LBodyStainComponent_RemoveBodyStain");
static_assert(offsetof(LBodyStainComponent_RemoveBodyStain, InCodeName) == 0x000000, "Member 'LBodyStainComponent_RemoveBodyStain::InCodeName' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.RemoveLoopWetBodyInfo
// 0x0008 (0x0008 - 0x0000)
struct LBodyStainComponent_RemoveLoopWetBodyInfo final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_RemoveLoopWetBodyInfo) == 0x000008, "Wrong alignment on LBodyStainComponent_RemoveLoopWetBodyInfo");
static_assert(sizeof(LBodyStainComponent_RemoveLoopWetBodyInfo) == 0x000008, "Wrong size on LBodyStainComponent_RemoveLoopWetBodyInfo");
static_assert(offsetof(LBodyStainComponent_RemoveLoopWetBodyInfo, Instigator) == 0x000000, "Member 'LBodyStainComponent_RemoveLoopWetBodyInfo::Instigator' has a wrong offset!");

// Function ProjectP.LBodyStainComponent.RewindBodyStain
// 0x0008 (0x0008 - 0x0000)
struct LBodyStainComponent_RewindBodyStain final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LBodyStainComponent_RewindBodyStain) == 0x000004, "Wrong alignment on LBodyStainComponent_RewindBodyStain");
static_assert(sizeof(LBodyStainComponent_RewindBodyStain) == 0x000008, "Wrong size on LBodyStainComponent_RewindBodyStain");
static_assert(offsetof(LBodyStainComponent_RewindBodyStain, InCodeName) == 0x000000, "Member 'LBodyStainComponent_RewindBodyStain::InCodeName' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.CalculateCameraLocationFromPC
// 0x0028 (0x0028 - 0x0000)
struct LCameraUtilFuncLibrary_CalculateCameraLocationFromPC final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmLength;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation;                                   // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraUtilFuncLibrary_CalculateCameraLocationFromPC) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_CalculateCameraLocationFromPC");
static_assert(sizeof(LCameraUtilFuncLibrary_CalculateCameraLocationFromPC) == 0x000028, "Wrong size on LCameraUtilFuncLibrary_CalculateCameraLocationFromPC");
static_assert(offsetof(LCameraUtilFuncLibrary_CalculateCameraLocationFromPC, CameraWork) == 0x000000, "Member 'LCameraUtilFuncLibrary_CalculateCameraLocationFromPC::CameraWork' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_CalculateCameraLocationFromPC, ArmLength) == 0x000008, "Member 'LCameraUtilFuncLibrary_CalculateCameraLocationFromPC::ArmLength' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_CalculateCameraLocationFromPC, ControlRotation) == 0x00000C, "Member 'LCameraUtilFuncLibrary_CalculateCameraLocationFromPC::ControlRotation' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_CalculateCameraLocationFromPC, ReturnValue) == 0x000018, "Member 'LCameraUtilFuncLibrary_CalculateCameraLocationFromPC::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCameraCharacter
// 0x0010 (0x0010 - 0x0000)
struct LCameraUtilFuncLibrary_GetCameraCharacter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPCCharacter*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCameraCharacter) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_GetCameraCharacter");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCameraCharacter) == 0x000010, "Wrong size on LCameraUtilFuncLibrary_GetCameraCharacter");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraCharacter, WorldContextObject) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCameraCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraCharacter, ReturnValue) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCameraCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCameraManager
// 0x0010 (0x0010 - 0x0000)
struct LCameraUtilFuncLibrary_GetCameraManager final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALCameraManager*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCameraManager) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_GetCameraManager");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCameraManager) == 0x000010, "Wrong size on LCameraUtilFuncLibrary_GetCameraManager");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraManager, WorldContextObject) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCameraManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraManager, ReturnValue) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCameraManager::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCameraSocketLocation
// 0x0020 (0x0020 - 0x0000)
struct LCameraUtilFuncLibrary_GetCameraSocketLocation final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCameraSocketLocation) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_GetCameraSocketLocation");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCameraSocketLocation) == 0x000020, "Wrong size on LCameraUtilFuncLibrary_GetCameraSocketLocation");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraSocketLocation, CameraWork) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCameraSocketLocation::CameraWork' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraSocketLocation, SocketName) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCameraSocketLocation::SocketName' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraSocketLocation, ReturnValue) == 0x000010, "Member 'LCameraUtilFuncLibrary_GetCameraSocketLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCameraSocketRotation
// 0x0020 (0x0020 - 0x0000)
struct LCameraUtilFuncLibrary_GetCameraSocketRotation final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCameraSocketRotation) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_GetCameraSocketRotation");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCameraSocketRotation) == 0x000020, "Wrong size on LCameraUtilFuncLibrary_GetCameraSocketRotation");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraSocketRotation, CameraWork) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCameraSocketRotation::CameraWork' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraSocketRotation, SocketName) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCameraSocketRotation::SocketName' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraSocketRotation, ReturnValue) == 0x000010, "Member 'LCameraUtilFuncLibrary_GetCameraSocketRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCameraTargetArmLength
// 0x0010 (0x0010 - 0x0000)
struct LCameraUtilFuncLibrary_GetCameraTargetArmLength final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCameraTargetArmLength) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_GetCameraTargetArmLength");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCameraTargetArmLength) == 0x000010, "Wrong size on LCameraUtilFuncLibrary_GetCameraTargetArmLength");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraTargetArmLength, CameraWork) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCameraTargetArmLength::CameraWork' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraTargetArmLength, ReturnValue) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCameraTargetArmLength::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCameraTargetArmLocation
// 0x0018 (0x0018 - 0x0000)
struct LCameraUtilFuncLibrary_GetCameraTargetArmLocation final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCameraTargetArmLocation) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_GetCameraTargetArmLocation");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCameraTargetArmLocation) == 0x000018, "Wrong size on LCameraUtilFuncLibrary_GetCameraTargetArmLocation");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraTargetArmLocation, CameraWork) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCameraTargetArmLocation::CameraWork' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCameraTargetArmLocation, ReturnValue) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCameraTargetArmLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.GetCharacterSocketTransform
// 0x0040 (0x0040 - 0x0000)
struct LCameraUtilFuncLibrary_GetCharacterSocketTransform final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraUtilFuncLibrary_GetCharacterSocketTransform) == 0x000010, "Wrong alignment on LCameraUtilFuncLibrary_GetCharacterSocketTransform");
static_assert(sizeof(LCameraUtilFuncLibrary_GetCharacterSocketTransform) == 0x000040, "Wrong size on LCameraUtilFuncLibrary_GetCharacterSocketTransform");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCharacterSocketTransform, Character) == 0x000000, "Member 'LCameraUtilFuncLibrary_GetCharacterSocketTransform::Character' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCharacterSocketTransform, SocketName) == 0x000008, "Member 'LCameraUtilFuncLibrary_GetCharacterSocketTransform::SocketName' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_GetCharacterSocketTransform, OutTransform) == 0x000010, "Member 'LCameraUtilFuncLibrary_GetCharacterSocketTransform::OutTransform' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.LinearStep
// 0x0010 (0x0010 - 0x0000)
struct LCameraUtilFuncLibrary_LinearStep final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraUtilFuncLibrary_LinearStep) == 0x000004, "Wrong alignment on LCameraUtilFuncLibrary_LinearStep");
static_assert(sizeof(LCameraUtilFuncLibrary_LinearStep) == 0x000010, "Wrong size on LCameraUtilFuncLibrary_LinearStep");
static_assert(offsetof(LCameraUtilFuncLibrary_LinearStep, Min) == 0x000000, "Member 'LCameraUtilFuncLibrary_LinearStep::Min' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_LinearStep, Max) == 0x000004, "Member 'LCameraUtilFuncLibrary_LinearStep::Max' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_LinearStep, Value) == 0x000008, "Member 'LCameraUtilFuncLibrary_LinearStep::Value' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_LinearStep, ReturnValue) == 0x00000C, "Member 'LCameraUtilFuncLibrary_LinearStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.MakeLookatCharacter
// 0x0050 (0x0050 - 0x0000)
struct LCameraUtilFuncLibrary_MakeLookatCharacter final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ActorRotation;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x0020(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraUtilFuncLibrary_MakeLookatCharacter) == 0x000010, "Wrong alignment on LCameraUtilFuncLibrary_MakeLookatCharacter");
static_assert(sizeof(LCameraUtilFuncLibrary_MakeLookatCharacter) == 0x000050, "Wrong size on LCameraUtilFuncLibrary_MakeLookatCharacter");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatCharacter, Character) == 0x000000, "Member 'LCameraUtilFuncLibrary_MakeLookatCharacter::Character' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatCharacter, SocketName) == 0x000008, "Member 'LCameraUtilFuncLibrary_MakeLookatCharacter::SocketName' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatCharacter, ActorRotation) == 0x000010, "Member 'LCameraUtilFuncLibrary_MakeLookatCharacter::ActorRotation' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatCharacter, Distance) == 0x00001C, "Member 'LCameraUtilFuncLibrary_MakeLookatCharacter::Distance' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatCharacter, OutTransform) == 0x000020, "Member 'LCameraUtilFuncLibrary_MakeLookatCharacter::OutTransform' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.MakeLookatTargetLocation
// 0x0050 (0x0050 - 0x0000)
struct LCameraUtilFuncLibrary_MakeLookatTargetLocation final
{
public:
	struct FVector                                CameraLocation;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTransform;                                      // 0x0020(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraUtilFuncLibrary_MakeLookatTargetLocation) == 0x000010, "Wrong alignment on LCameraUtilFuncLibrary_MakeLookatTargetLocation");
static_assert(sizeof(LCameraUtilFuncLibrary_MakeLookatTargetLocation) == 0x000050, "Wrong size on LCameraUtilFuncLibrary_MakeLookatTargetLocation");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatTargetLocation, CameraLocation) == 0x000000, "Member 'LCameraUtilFuncLibrary_MakeLookatTargetLocation::CameraLocation' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatTargetLocation, TargetLocation) == 0x00000C, "Member 'LCameraUtilFuncLibrary_MakeLookatTargetLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatTargetLocation, Distance) == 0x000018, "Member 'LCameraUtilFuncLibrary_MakeLookatTargetLocation::Distance' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_MakeLookatTargetLocation, OutTransform) == 0x000020, "Member 'LCameraUtilFuncLibrary_MakeLookatTargetLocation::OutTransform' has a wrong offset!");

// Function ProjectP.LCameraUtilFuncLibrary.SetCameraCharacterControlRotation
// 0x0018 (0x0018 - 0x0000)
struct LCameraUtilFuncLibrary_SetCameraCharacterControlRotation final
{
public:
	class ALCameraWork*                           CameraWork;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation;                                   // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraUtilFuncLibrary_SetCameraCharacterControlRotation) == 0x000008, "Wrong alignment on LCameraUtilFuncLibrary_SetCameraCharacterControlRotation");
static_assert(sizeof(LCameraUtilFuncLibrary_SetCameraCharacterControlRotation) == 0x000018, "Wrong size on LCameraUtilFuncLibrary_SetCameraCharacterControlRotation");
static_assert(offsetof(LCameraUtilFuncLibrary_SetCameraCharacterControlRotation, CameraWork) == 0x000000, "Member 'LCameraUtilFuncLibrary_SetCameraCharacterControlRotation::CameraWork' has a wrong offset!");
static_assert(offsetof(LCameraUtilFuncLibrary_SetCameraCharacterControlRotation, ControlRotation) == 0x000008, "Member 'LCameraUtilFuncLibrary_SetCameraCharacterControlRotation::ControlRotation' has a wrong offset!");

// Function ProjectP.LLevelObject.GetDelayInteractTime
// 0x0004 (0x0004 - 0x0000)
struct LLevelObject_GetDelayInteractTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_GetDelayInteractTime) == 0x000004, "Wrong alignment on LLevelObject_GetDelayInteractTime");
static_assert(sizeof(LLevelObject_GetDelayInteractTime) == 0x000004, "Wrong size on LLevelObject_GetDelayInteractTime");
static_assert(offsetof(LLevelObject_GetDelayInteractTime, ReturnValue) == 0x000000, "Member 'LLevelObject_GetDelayInteractTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LLevelObject.GetInteractTime
// 0x0004 (0x0004 - 0x0000)
struct LLevelObject_GetInteractTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_GetInteractTime) == 0x000004, "Wrong alignment on LLevelObject_GetInteractTime");
static_assert(sizeof(LLevelObject_GetInteractTime) == 0x000004, "Wrong size on LLevelObject_GetInteractTime");
static_assert(offsetof(LLevelObject_GetInteractTime, ReturnValue) == 0x000000, "Member 'LLevelObject_GetInteractTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LLevelObject.OnChangeState
// 0x0004 (0x0004 - 0x0000)
struct LLevelObject_OnChangeState final
{
public:
	int32                                         TargetState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_OnChangeState) == 0x000004, "Wrong alignment on LLevelObject_OnChangeState");
static_assert(sizeof(LLevelObject_OnChangeState) == 0x000004, "Wrong size on LLevelObject_OnChangeState");
static_assert(offsetof(LLevelObject_OnChangeState, TargetState) == 0x000000, "Member 'LLevelObject_OnChangeState::TargetState' has a wrong offset!");

// Function ProjectP.LLevelObject.OnLevelObjectCommand
// 0x0008 (0x0008 - 0x0000)
struct LLevelObject_OnLevelObjectCommand final
{
public:
	class FName                                   CommandName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_OnLevelObjectCommand) == 0x000004, "Wrong alignment on LLevelObject_OnLevelObjectCommand");
static_assert(sizeof(LLevelObject_OnLevelObjectCommand) == 0x000008, "Wrong size on LLevelObject_OnLevelObjectCommand");
static_assert(offsetof(LLevelObject_OnLevelObjectCommand, CommandName) == 0x000000, "Member 'LLevelObject_OnLevelObjectCommand::CommandName' has a wrong offset!");

// Function ProjectP.LLevelObject.OwnerSpotChangePropState
// 0x0004 (0x0004 - 0x0000)
struct LLevelObject_OwnerSpotChangePropState final
{
public:
	int32                                         TargetState;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_OwnerSpotChangePropState) == 0x000004, "Wrong alignment on LLevelObject_OwnerSpotChangePropState");
static_assert(sizeof(LLevelObject_OwnerSpotChangePropState) == 0x000004, "Wrong size on LLevelObject_OwnerSpotChangePropState");
static_assert(offsetof(LLevelObject_OwnerSpotChangePropState, TargetState) == 0x000000, "Member 'LLevelObject_OwnerSpotChangePropState::TargetState' has a wrong offset!");

// Function ProjectP.LLevelObject.OwnerSpotCheckLinkedNpcSpot
// 0x0001 (0x0001 - 0x0000)
struct LLevelObject_OwnerSpotCheckLinkedNpcSpot final
{
public:
	ELLinkedNpcSpotExecuteType                    ExecuteType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_OwnerSpotCheckLinkedNpcSpot) == 0x000001, "Wrong alignment on LLevelObject_OwnerSpotCheckLinkedNpcSpot");
static_assert(sizeof(LLevelObject_OwnerSpotCheckLinkedNpcSpot) == 0x000001, "Wrong size on LLevelObject_OwnerSpotCheckLinkedNpcSpot");
static_assert(offsetof(LLevelObject_OwnerSpotCheckLinkedNpcSpot, ExecuteType) == 0x000000, "Member 'LLevelObject_OwnerSpotCheckLinkedNpcSpot::ExecuteType' has a wrong offset!");

// Function ProjectP.LLevelObject.RemovePropProjectile
// 0x0008 (0x0008 - 0x0000)
struct LLevelObject_RemovePropProjectile final
{
public:
	int64                                         ProjectileHandleId;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_RemovePropProjectile) == 0x000008, "Wrong alignment on LLevelObject_RemovePropProjectile");
static_assert(sizeof(LLevelObject_RemovePropProjectile) == 0x000008, "Wrong size on LLevelObject_RemovePropProjectile");
static_assert(offsetof(LLevelObject_RemovePropProjectile, ProjectileHandleId) == 0x000000, "Member 'LLevelObject_RemovePropProjectile::ProjectileHandleId' has a wrong offset!");

// Function ProjectP.LLevelObject.SpawnPropProjectile
// 0x0020 (0x0020 - 0x0000)
struct LLevelObject_SpawnPropProjectile final
{
public:
	class FName                                   ProjectileCodeName;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MuzzleSocket;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelObject_SpawnPropProjectile) == 0x000008, "Wrong alignment on LLevelObject_SpawnPropProjectile");
static_assert(sizeof(LLevelObject_SpawnPropProjectile) == 0x000020, "Wrong size on LLevelObject_SpawnPropProjectile");
static_assert(offsetof(LLevelObject_SpawnPropProjectile, ProjectileCodeName) == 0x000000, "Member 'LLevelObject_SpawnPropProjectile::ProjectileCodeName' has a wrong offset!");
static_assert(offsetof(LLevelObject_SpawnPropProjectile, MuzzleSocket) == 0x000008, "Member 'LLevelObject_SpawnPropProjectile::MuzzleSocket' has a wrong offset!");
static_assert(offsetof(LLevelObject_SpawnPropProjectile, TargetActor) == 0x000010, "Member 'LLevelObject_SpawnPropProjectile::TargetActor' has a wrong offset!");
static_assert(offsetof(LLevelObject_SpawnPropProjectile, ReturnValue) == 0x000018, "Member 'LLevelObject_SpawnPropProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.CheckIsSafe
// 0x0010 (0x0010 - 0x0000)
struct LCarcassBodyObject_CheckIsSafe final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCarcassBodyObject_CheckIsSafe) == 0x000004, "Wrong alignment on LCarcassBodyObject_CheckIsSafe");
static_assert(sizeof(LCarcassBodyObject_CheckIsSafe) == 0x000010, "Wrong size on LCarcassBodyObject_CheckIsSafe");
static_assert(offsetof(LCarcassBodyObject_CheckIsSafe, InLocation) == 0x000000, "Member 'LCarcassBodyObject_CheckIsSafe::InLocation' has a wrong offset!");
static_assert(offsetof(LCarcassBodyObject_CheckIsSafe, ReturnValue) == 0x00000C, "Member 'LCarcassBodyObject_CheckIsSafe::ReturnValue' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.GetFluidDepth
// 0x0004 (0x0004 - 0x0000)
struct LCarcassBodyObject_GetFluidDepth final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCarcassBodyObject_GetFluidDepth) == 0x000004, "Wrong alignment on LCarcassBodyObject_GetFluidDepth");
static_assert(sizeof(LCarcassBodyObject_GetFluidDepth) == 0x000004, "Wrong size on LCarcassBodyObject_GetFluidDepth");
static_assert(offsetof(LCarcassBodyObject_GetFluidDepth, ReturnValue) == 0x000000, "Member 'LCarcassBodyObject_GetFluidDepth::ReturnValue' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.GetSurfaceHeight
// 0x0010 (0x0010 - 0x0000)
struct LCarcassBodyObject_GetSurfaceHeight final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCarcassBodyObject_GetSurfaceHeight) == 0x000004, "Wrong alignment on LCarcassBodyObject_GetSurfaceHeight");
static_assert(sizeof(LCarcassBodyObject_GetSurfaceHeight) == 0x000010, "Wrong size on LCarcassBodyObject_GetSurfaceHeight");
static_assert(offsetof(LCarcassBodyObject_GetSurfaceHeight, InLocation) == 0x000000, "Member 'LCarcassBodyObject_GetSurfaceHeight::InLocation' has a wrong offset!");
static_assert(offsetof(LCarcassBodyObject_GetSurfaceHeight, ReturnValue) == 0x00000C, "Member 'LCarcassBodyObject_GetSurfaceHeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.OnProcessHit
// 0x0120 (0x0120 - 0x0000)
struct LCarcassBodyObject_OnProcessHit final
{
public:
	struct FLProjectileHitInfo                    HitInfo;                                           // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0090(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCarcassBodyObject_OnProcessHit) == 0x000010, "Wrong alignment on LCarcassBodyObject_OnProcessHit");
static_assert(sizeof(LCarcassBodyObject_OnProcessHit) == 0x000120, "Wrong size on LCarcassBodyObject_OnProcessHit");
static_assert(offsetof(LCarcassBodyObject_OnProcessHit, HitInfo) == 0x000000, "Member 'LCarcassBodyObject_OnProcessHit::HitInfo' has a wrong offset!");
static_assert(offsetof(LCarcassBodyObject_OnProcessHit, HitResult) == 0x000090, "Member 'LCarcassBodyObject_OnProcessHit::HitResult' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.RemoveCharacterOverlapState
// 0x0008 (0x0008 - 0x0000)
struct LCarcassBodyObject_RemoveCharacterOverlapState final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCarcassBodyObject_RemoveCharacterOverlapState) == 0x000008, "Wrong alignment on LCarcassBodyObject_RemoveCharacterOverlapState");
static_assert(sizeof(LCarcassBodyObject_RemoveCharacterOverlapState) == 0x000008, "Wrong size on LCarcassBodyObject_RemoveCharacterOverlapState");
static_assert(offsetof(LCarcassBodyObject_RemoveCharacterOverlapState, Character) == 0x000000, "Member 'LCarcassBodyObject_RemoveCharacterOverlapState::Character' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.SetCharacterOverlapState
// 0x0010 (0x0010 - 0x0000)
struct LCarcassBodyObject_SetCharacterOverlapState final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCarcassBodyObjectOverlapState               OverlapState;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCarcassBodyObject_SetCharacterOverlapState) == 0x000008, "Wrong alignment on LCarcassBodyObject_SetCharacterOverlapState");
static_assert(sizeof(LCarcassBodyObject_SetCharacterOverlapState) == 0x000010, "Wrong size on LCarcassBodyObject_SetCharacterOverlapState");
static_assert(offsetof(LCarcassBodyObject_SetCharacterOverlapState, Character) == 0x000000, "Member 'LCarcassBodyObject_SetCharacterOverlapState::Character' has a wrong offset!");
static_assert(offsetof(LCarcassBodyObject_SetCharacterOverlapState, OverlapState) == 0x000008, "Member 'LCarcassBodyObject_SetCharacterOverlapState::OverlapState' has a wrong offset!");

// Function ProjectP.LCarcassBodyObject.GetCharacterOverlapState
// 0x0010 (0x0010 - 0x0000)
struct LCarcassBodyObject_GetCharacterOverlapState final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCarcassBodyObjectOverlapState               ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCarcassBodyObject_GetCharacterOverlapState) == 0x000008, "Wrong alignment on LCarcassBodyObject_GetCharacterOverlapState");
static_assert(sizeof(LCarcassBodyObject_GetCharacterOverlapState) == 0x000010, "Wrong size on LCarcassBodyObject_GetCharacterOverlapState");
static_assert(offsetof(LCarcassBodyObject_GetCharacterOverlapState, Character) == 0x000000, "Member 'LCarcassBodyObject_GetCharacterOverlapState::Character' has a wrong offset!");
static_assert(offsetof(LCarcassBodyObject_GetCharacterOverlapState, ReturnValue) == 0x000008, "Member 'LCarcassBodyObject_GetCharacterOverlapState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.AddManagedParticle
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_AddManagedParticle final
{
public:
	class UFXSystemComponent*                     Particle;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_AddManagedParticle) == 0x000008, "Wrong alignment on LCharacter_AddManagedParticle");
static_assert(sizeof(LCharacter_AddManagedParticle) == 0x000008, "Wrong size on LCharacter_AddManagedParticle");
static_assert(offsetof(LCharacter_AddManagedParticle, Particle) == 0x000000, "Member 'LCharacter_AddManagedParticle::Particle' has a wrong offset!");

// Function ProjectP.LCharacter.AddRadialImpulseToBody
// 0x0020 (0x0020 - 0x0000)
struct LCharacter_AddRadialImpulseToBody final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERadialImpulseFalloff                         Falloff;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MarginFromPrevious;                                // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_AddRadialImpulseToBody) == 0x000004, "Wrong alignment on LCharacter_AddRadialImpulseToBody");
static_assert(sizeof(LCharacter_AddRadialImpulseToBody) == 0x000020, "Wrong size on LCharacter_AddRadialImpulseToBody");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, Origin) == 0x000000, "Member 'LCharacter_AddRadialImpulseToBody::Origin' has a wrong offset!");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, Radius) == 0x00000C, "Member 'LCharacter_AddRadialImpulseToBody::Radius' has a wrong offset!");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, Strength) == 0x000010, "Member 'LCharacter_AddRadialImpulseToBody::Strength' has a wrong offset!");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, Falloff) == 0x000014, "Member 'LCharacter_AddRadialImpulseToBody::Falloff' has a wrong offset!");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, bVelChange) == 0x000015, "Member 'LCharacter_AddRadialImpulseToBody::bVelChange' has a wrong offset!");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, MarginFromPrevious) == 0x000018, "Member 'LCharacter_AddRadialImpulseToBody::MarginFromPrevious' has a wrong offset!");
static_assert(offsetof(LCharacter_AddRadialImpulseToBody, ReturnValue) == 0x00001C, "Member 'LCharacter_AddRadialImpulseToBody::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.AddStat
// 0x000C (0x000C - 0x0000)
struct LCharacter_AddStat final
{
public:
	ELSecondStat                                  InStat;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AdditionalStat;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_AddStat) == 0x000004, "Wrong alignment on LCharacter_AddStat");
static_assert(sizeof(LCharacter_AddStat) == 0x00000C, "Wrong size on LCharacter_AddStat");
static_assert(offsetof(LCharacter_AddStat, InStat) == 0x000000, "Member 'LCharacter_AddStat::InStat' has a wrong offset!");
static_assert(offsetof(LCharacter_AddStat, AdditionalStat) == 0x000004, "Member 'LCharacter_AddStat::AdditionalStat' has a wrong offset!");
static_assert(offsetof(LCharacter_AddStat, ReturnValue) == 0x000008, "Member 'LCharacter_AddStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.ApplyMeshScale
// 0x0004 (0x0004 - 0x0000)
struct LCharacter_ApplyMeshScale final
{
public:
	float                                         MeshScale;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_ApplyMeshScale) == 0x000004, "Wrong alignment on LCharacter_ApplyMeshScale");
static_assert(sizeof(LCharacter_ApplyMeshScale) == 0x000004, "Wrong size on LCharacter_ApplyMeshScale");
static_assert(offsetof(LCharacter_ApplyMeshScale, MeshScale) == 0x000000, "Member 'LCharacter_ApplyMeshScale::MeshScale' has a wrong offset!");

// Function ProjectP.LCharacter.ChangeActionGroup
// 0x000C (0x000C - 0x0000)
struct LCharacter_ChangeActionGroup final
{
public:
	class FName                                   ActionGroupTableCodeName;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_ChangeActionGroup) == 0x000004, "Wrong alignment on LCharacter_ChangeActionGroup");
static_assert(sizeof(LCharacter_ChangeActionGroup) == 0x00000C, "Wrong size on LCharacter_ChangeActionGroup");
static_assert(offsetof(LCharacter_ChangeActionGroup, ActionGroupTableCodeName) == 0x000000, "Member 'LCharacter_ChangeActionGroup::ActionGroupTableCodeName' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeActionGroup, ReturnValue) == 0x000008, "Member 'LCharacter_ChangeActionGroup::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.ChangeCollisionState
// 0x0003 (0x0003 - 0x0000)
struct LCharacter_ChangeCollisionState final
{
public:
	ELCollisionState                              InCollisionState;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceChange;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_ChangeCollisionState) == 0x000001, "Wrong alignment on LCharacter_ChangeCollisionState");
static_assert(sizeof(LCharacter_ChangeCollisionState) == 0x000003, "Wrong size on LCharacter_ChangeCollisionState");
static_assert(offsetof(LCharacter_ChangeCollisionState, InCollisionState) == 0x000000, "Member 'LCharacter_ChangeCollisionState::InCollisionState' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeCollisionState, ForceChange) == 0x000001, "Member 'LCharacter_ChangeCollisionState::ForceChange' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeCollisionState, ReturnValue) == 0x000002, "Member 'LCharacter_ChangeCollisionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.ChangeCommonActionGroup
// 0x0014 (0x0014 - 0x0000)
struct LCharacter_ChangeCommonActionGroup final
{
public:
	class FName                                   CommonActionGroup;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocomotionActionGroup;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_ChangeCommonActionGroup) == 0x000004, "Wrong alignment on LCharacter_ChangeCommonActionGroup");
static_assert(sizeof(LCharacter_ChangeCommonActionGroup) == 0x000014, "Wrong size on LCharacter_ChangeCommonActionGroup");
static_assert(offsetof(LCharacter_ChangeCommonActionGroup, CommonActionGroup) == 0x000000, "Member 'LCharacter_ChangeCommonActionGroup::CommonActionGroup' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeCommonActionGroup, LocomotionActionGroup) == 0x000008, "Member 'LCharacter_ChangeCommonActionGroup::LocomotionActionGroup' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeCommonActionGroup, ReturnValue) == 0x000010, "Member 'LCharacter_ChangeCommonActionGroup::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.ChangeLocomotion
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_ChangeLocomotion final
{
public:
	class FName                                   ActionGroup;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_ChangeLocomotion) == 0x000004, "Wrong alignment on LCharacter_ChangeLocomotion");
static_assert(sizeof(LCharacter_ChangeLocomotion) == 0x000008, "Wrong size on LCharacter_ChangeLocomotion");
static_assert(offsetof(LCharacter_ChangeLocomotion, ActionGroup) == 0x000000, "Member 'LCharacter_ChangeLocomotion::ActionGroup' has a wrong offset!");

// Function ProjectP.LCharacter.ChangeWeaponAnimState
// 0x000C (0x000C - 0x0000)
struct LCharacter_ChangeWeaponAnimState final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponPartType                              PartType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimState;                                         // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_ChangeWeaponAnimState) == 0x000004, "Wrong alignment on LCharacter_ChangeWeaponAnimState");
static_assert(sizeof(LCharacter_ChangeWeaponAnimState) == 0x00000C, "Wrong size on LCharacter_ChangeWeaponAnimState");
static_assert(offsetof(LCharacter_ChangeWeaponAnimState, AttachPointType) == 0x000000, "Member 'LCharacter_ChangeWeaponAnimState::AttachPointType' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeWeaponAnimState, PartType) == 0x000001, "Member 'LCharacter_ChangeWeaponAnimState::PartType' has a wrong offset!");
static_assert(offsetof(LCharacter_ChangeWeaponAnimState, AnimState) == 0x000004, "Member 'LCharacter_ChangeWeaponAnimState::AnimState' has a wrong offset!");

// Function ProjectP.LCharacter.ClearWeaponAnimState
// 0x0002 (0x0002 - 0x0000)
struct LCharacter_ClearWeaponAnimState final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponPartType                              PartType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_ClearWeaponAnimState) == 0x000001, "Wrong alignment on LCharacter_ClearWeaponAnimState");
static_assert(sizeof(LCharacter_ClearWeaponAnimState) == 0x000002, "Wrong size on LCharacter_ClearWeaponAnimState");
static_assert(offsetof(LCharacter_ClearWeaponAnimState, AttachPointType) == 0x000000, "Member 'LCharacter_ClearWeaponAnimState::AttachPointType' has a wrong offset!");
static_assert(offsetof(LCharacter_ClearWeaponAnimState, PartType) == 0x000001, "Member 'LCharacter_ClearWeaponAnimState::PartType' has a wrong offset!");

// Function ProjectP.LCharacter.EventHitStart
// 0x01E8 (0x01E8 - 0x0000)
struct LCharacter_EventHitStart final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0160(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_EventHitStart) == 0x000008, "Wrong alignment on LCharacter_EventHitStart");
static_assert(sizeof(LCharacter_EventHitStart) == 0x0001E8, "Wrong size on LCharacter_EventHitStart");
static_assert(offsetof(LCharacter_EventHitStart, Attacker) == 0x000000, "Member 'LCharacter_EventHitStart::Attacker' has a wrong offset!");
static_assert(offsetof(LCharacter_EventHitStart, Victim) == 0x000008, "Member 'LCharacter_EventHitStart::Victim' has a wrong offset!");
static_assert(offsetof(LCharacter_EventHitStart, HitInfo) == 0x000010, "Member 'LCharacter_EventHitStart::HitInfo' has a wrong offset!");
static_assert(offsetof(LCharacter_EventHitStart, HitResult) == 0x000160, "Member 'LCharacter_EventHitStart::HitResult' has a wrong offset!");

// Function ProjectP.LCharacter.GameObject_RegisterStateManagedComponent
// 0x0010 (0x0010 - 0x0000)
struct LCharacter_GameObject_RegisterStateManagedComponent final
{
public:
	class UActorComponent*                        TargetActorComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_GameObject_RegisterStateManagedComponent) == 0x000008, "Wrong alignment on LCharacter_GameObject_RegisterStateManagedComponent");
static_assert(sizeof(LCharacter_GameObject_RegisterStateManagedComponent) == 0x000010, "Wrong size on LCharacter_GameObject_RegisterStateManagedComponent");
static_assert(offsetof(LCharacter_GameObject_RegisterStateManagedComponent, TargetActorComponent) == 0x000000, "Member 'LCharacter_GameObject_RegisterStateManagedComponent::TargetActorComponent' has a wrong offset!");
static_assert(offsetof(LCharacter_GameObject_RegisterStateManagedComponent, ReturnValue) == 0x000008, "Member 'LCharacter_GameObject_RegisterStateManagedComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GameObject_UnregisterStateManagedComponent
// 0x0010 (0x0010 - 0x0000)
struct LCharacter_GameObject_UnregisterStateManagedComponent final
{
public:
	class UActorComponent*                        TargetActorComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_GameObject_UnregisterStateManagedComponent) == 0x000008, "Wrong alignment on LCharacter_GameObject_UnregisterStateManagedComponent");
static_assert(sizeof(LCharacter_GameObject_UnregisterStateManagedComponent) == 0x000010, "Wrong size on LCharacter_GameObject_UnregisterStateManagedComponent");
static_assert(offsetof(LCharacter_GameObject_UnregisterStateManagedComponent, TargetActorComponent) == 0x000000, "Member 'LCharacter_GameObject_UnregisterStateManagedComponent::TargetActorComponent' has a wrong offset!");
static_assert(offsetof(LCharacter_GameObject_UnregisterStateManagedComponent, ReturnValue) == 0x000008, "Member 'LCharacter_GameObject_UnregisterStateManagedComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GetFocusRotation
// 0x000C (0x000C - 0x0000)
struct LCharacter_GetFocusRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetFocusRotation) == 0x000004, "Wrong alignment on LCharacter_GetFocusRotation");
static_assert(sizeof(LCharacter_GetFocusRotation) == 0x00000C, "Wrong size on LCharacter_GetFocusRotation");
static_assert(offsetof(LCharacter_GetFocusRotation, ReturnValue) == 0x000000, "Member 'LCharacter_GetFocusRotation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GetFocusTarget
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_GetFocusTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetFocusTarget) == 0x000008, "Wrong alignment on LCharacter_GetFocusTarget");
static_assert(sizeof(LCharacter_GetFocusTarget) == 0x000008, "Wrong size on LCharacter_GetFocusTarget");
static_assert(offsetof(LCharacter_GetFocusTarget, ReturnValue) == 0x000000, "Member 'LCharacter_GetFocusTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GetHPPercent
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_GetHPPercent final
{
public:
	float                                         HPPercent;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegainHPPercent;                                   // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetHPPercent) == 0x000004, "Wrong alignment on LCharacter_GetHPPercent");
static_assert(sizeof(LCharacter_GetHPPercent) == 0x000008, "Wrong size on LCharacter_GetHPPercent");
static_assert(offsetof(LCharacter_GetHPPercent, HPPercent) == 0x000000, "Member 'LCharacter_GetHPPercent::HPPercent' has a wrong offset!");
static_assert(offsetof(LCharacter_GetHPPercent, RegainHPPercent) == 0x000004, "Member 'LCharacter_GetHPPercent::RegainHPPercent' has a wrong offset!");

// Function ProjectP.LCharacter.GetSimplePhysicalSurface
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_GetSimplePhysicalSurface final
{
public:
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetSimplePhysicalSurface) == 0x000008, "Wrong alignment on LCharacter_GetSimplePhysicalSurface");
static_assert(sizeof(LCharacter_GetSimplePhysicalSurface) == 0x000008, "Wrong size on LCharacter_GetSimplePhysicalSurface");
static_assert(offsetof(LCharacter_GetSimplePhysicalSurface, ReturnValue) == 0x000000, "Member 'LCharacter_GetSimplePhysicalSurface::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.IsAboveNavigation
// 0x0002 (0x0002 - 0x0000)
struct LCharacter_IsAboveNavigation final
{
public:
	bool                                          bForceUpdate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_IsAboveNavigation) == 0x000001, "Wrong alignment on LCharacter_IsAboveNavigation");
static_assert(sizeof(LCharacter_IsAboveNavigation) == 0x000002, "Wrong size on LCharacter_IsAboveNavigation");
static_assert(offsetof(LCharacter_IsAboveNavigation, bForceUpdate) == 0x000000, "Member 'LCharacter_IsAboveNavigation::bForceUpdate' has a wrong offset!");
static_assert(offsetof(LCharacter_IsAboveNavigation, ReturnValue) == 0x000001, "Member 'LCharacter_IsAboveNavigation::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.IsDead
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_IsDead) == 0x000001, "Wrong alignment on LCharacter_IsDead");
static_assert(sizeof(LCharacter_IsDead) == 0x000001, "Wrong size on LCharacter_IsDead");
static_assert(offsetof(LCharacter_IsDead, ReturnValue) == 0x000000, "Member 'LCharacter_IsDead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.MoveMeshComponentToCapsuleBottom
// 0x0010 (0x0010 - 0x0000)
struct LCharacter_MoveMeshComponentToCapsuleBottom final
{
public:
	struct FVector                                MeshOffset;                                        // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainMeshView;                                 // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_MoveMeshComponentToCapsuleBottom) == 0x000004, "Wrong alignment on LCharacter_MoveMeshComponentToCapsuleBottom");
static_assert(sizeof(LCharacter_MoveMeshComponentToCapsuleBottom) == 0x000010, "Wrong size on LCharacter_MoveMeshComponentToCapsuleBottom");
static_assert(offsetof(LCharacter_MoveMeshComponentToCapsuleBottom, MeshOffset) == 0x000000, "Member 'LCharacter_MoveMeshComponentToCapsuleBottom::MeshOffset' has a wrong offset!");
static_assert(offsetof(LCharacter_MoveMeshComponentToCapsuleBottom, bMaintainMeshView) == 0x00000C, "Member 'LCharacter_MoveMeshComponentToCapsuleBottom::bMaintainMeshView' has a wrong offset!");

// Function ProjectP.LCharacter.OnActionStarted
// 0x0010 (0x0010 - 0x0000)
struct LCharacter_OnActionStarted final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              StartedAction;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnActionStarted) == 0x000008, "Wrong alignment on LCharacter_OnActionStarted");
static_assert(sizeof(LCharacter_OnActionStarted) == 0x000010, "Wrong size on LCharacter_OnActionStarted");
static_assert(offsetof(LCharacter_OnActionStarted, InActMgrComponent) == 0x000000, "Member 'LCharacter_OnActionStarted::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LCharacter_OnActionStarted, StartedAction) == 0x000008, "Member 'LCharacter_OnActionStarted::StartedAction' has a wrong offset!");

// Function ProjectP.LCharacter.OnActionStopCalled
// 0x0018 (0x0018 - 0x0000)
struct LCharacter_OnActionStopCalled final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              StoppingAction;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReasonAction;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnActionStopCalled) == 0x000008, "Wrong alignment on LCharacter_OnActionStopCalled");
static_assert(sizeof(LCharacter_OnActionStopCalled) == 0x000018, "Wrong size on LCharacter_OnActionStopCalled");
static_assert(offsetof(LCharacter_OnActionStopCalled, InActMgrComponent) == 0x000000, "Member 'LCharacter_OnActionStopCalled::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LCharacter_OnActionStopCalled, StoppingAction) == 0x000008, "Member 'LCharacter_OnActionStopCalled::StoppingAction' has a wrong offset!");
static_assert(offsetof(LCharacter_OnActionStopCalled, ReasonAction) == 0x000010, "Member 'LCharacter_OnActionStopCalled::ReasonAction' has a wrong offset!");

// Function ProjectP.LCharacter.OnApplyRunningAbnormal
// 0x000C (0x000C - 0x0000)
struct LCharacter_OnApplyRunningAbnormal final
{
public:
	bool                                          IsApply;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbnormalCodeName;                                  // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnApplyRunningAbnormal) == 0x000004, "Wrong alignment on LCharacter_OnApplyRunningAbnormal");
static_assert(sizeof(LCharacter_OnApplyRunningAbnormal) == 0x00000C, "Wrong size on LCharacter_OnApplyRunningAbnormal");
static_assert(offsetof(LCharacter_OnApplyRunningAbnormal, IsApply) == 0x000000, "Member 'LCharacter_OnApplyRunningAbnormal::IsApply' has a wrong offset!");
static_assert(offsetof(LCharacter_OnApplyRunningAbnormal, AbnormalCodeName) == 0x000004, "Member 'LCharacter_OnApplyRunningAbnormal::AbnormalCodeName' has a wrong offset!");

// Function ProjectP.LCharacter.OnCanHitOccurDecoMesh
// 0x00A0 (0x00A0 - 0x0000)
struct LCharacter_OnCanHitOccurDecoMesh final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_OnCanHitOccurDecoMesh) == 0x000008, "Wrong alignment on LCharacter_OnCanHitOccurDecoMesh");
static_assert(sizeof(LCharacter_OnCanHitOccurDecoMesh) == 0x0000A0, "Wrong size on LCharacter_OnCanHitOccurDecoMesh");
static_assert(offsetof(LCharacter_OnCanHitOccurDecoMesh, Attacker) == 0x000000, "Member 'LCharacter_OnCanHitOccurDecoMesh::Attacker' has a wrong offset!");
static_assert(offsetof(LCharacter_OnCanHitOccurDecoMesh, Victim) == 0x000008, "Member 'LCharacter_OnCanHitOccurDecoMesh::Victim' has a wrong offset!");
static_assert(offsetof(LCharacter_OnCanHitOccurDecoMesh, HitResult) == 0x000010, "Member 'LCharacter_OnCanHitOccurDecoMesh::HitResult' has a wrong offset!");
static_assert(offsetof(LCharacter_OnCanHitOccurDecoMesh, ReturnValue) == 0x000098, "Member 'LCharacter_OnCanHitOccurDecoMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.OnEquipmentWeaponStateChanged
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_OnEquipmentWeaponStateChanged final
{
public:
	ELWeaponStateChangeType                       WeaponStateChangeType;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnEquipmentWeaponStateChanged) == 0x000001, "Wrong alignment on LCharacter_OnEquipmentWeaponStateChanged");
static_assert(sizeof(LCharacter_OnEquipmentWeaponStateChanged) == 0x000001, "Wrong size on LCharacter_OnEquipmentWeaponStateChanged");
static_assert(offsetof(LCharacter_OnEquipmentWeaponStateChanged, WeaponStateChangeType) == 0x000000, "Member 'LCharacter_OnEquipmentWeaponStateChanged::WeaponStateChangeType' has a wrong offset!");

// Function ProjectP.LCharacter.OnRagdoll
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_OnRagdoll final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnRagdoll) == 0x000001, "Wrong alignment on LCharacter_OnRagdoll");
static_assert(sizeof(LCharacter_OnRagdoll) == 0x000001, "Wrong size on LCharacter_OnRagdoll");
static_assert(offsetof(LCharacter_OnRagdoll, bEnable) == 0x000000, "Member 'LCharacter_OnRagdoll::bEnable' has a wrong offset!");

// Function ProjectP.LCharacter.OnStaminaConsume
// 0x0004 (0x0004 - 0x0000)
struct LCharacter_OnStaminaConsume final
{
public:
	int32                                         InAmount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnStaminaConsume) == 0x000004, "Wrong alignment on LCharacter_OnStaminaConsume");
static_assert(sizeof(LCharacter_OnStaminaConsume) == 0x000004, "Wrong size on LCharacter_OnStaminaConsume");
static_assert(offsetof(LCharacter_OnStaminaConsume, InAmount) == 0x000000, "Member 'LCharacter_OnStaminaConsume::InAmount' has a wrong offset!");

// Function ProjectP.LCharacter.OnStatChanged
// 0x000C (0x000C - 0x0000)
struct LCharacter_OnStatChanged final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AddedValue;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevStatValue;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OnStatChanged) == 0x000004, "Wrong alignment on LCharacter_OnStatChanged");
static_assert(sizeof(LCharacter_OnStatChanged) == 0x00000C, "Wrong size on LCharacter_OnStatChanged");
static_assert(offsetof(LCharacter_OnStatChanged, StatType) == 0x000000, "Member 'LCharacter_OnStatChanged::StatType' has a wrong offset!");
static_assert(offsetof(LCharacter_OnStatChanged, AddedValue) == 0x000004, "Member 'LCharacter_OnStatChanged::AddedValue' has a wrong offset!");
static_assert(offsetof(LCharacter_OnStatChanged, PrevStatValue) == 0x000008, "Member 'LCharacter_OnStatChanged::PrevStatValue' has a wrong offset!");

// Function ProjectP.LCharacter.OverwriteFallingStartHeight
// 0x0004 (0x0004 - 0x0000)
struct LCharacter_OverwriteFallingStartHeight final
{
public:
	float                                         Height;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_OverwriteFallingStartHeight) == 0x000004, "Wrong alignment on LCharacter_OverwriteFallingStartHeight");
static_assert(sizeof(LCharacter_OverwriteFallingStartHeight) == 0x000004, "Wrong size on LCharacter_OverwriteFallingStartHeight");
static_assert(offsetof(LCharacter_OverwriteFallingStartHeight, Height) == 0x000000, "Member 'LCharacter_OverwriteFallingStartHeight::Height' has a wrong offset!");

// Function ProjectP.LCharacter.PlayMaterialParam
// 0x0038 (0x0038 - 0x0000)
struct LCharacter_PlayMaterialParam final
{
public:
	struct FLMaterialParamCollection              ParamCollection;                                   // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           SelectType;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_PlayMaterialParam) == 0x000008, "Wrong alignment on LCharacter_PlayMaterialParam");
static_assert(sizeof(LCharacter_PlayMaterialParam) == 0x000038, "Wrong size on LCharacter_PlayMaterialParam");
static_assert(offsetof(LCharacter_PlayMaterialParam, ParamCollection) == 0x000000, "Member 'LCharacter_PlayMaterialParam::ParamCollection' has a wrong offset!");
static_assert(offsetof(LCharacter_PlayMaterialParam, SelectType) == 0x000030, "Member 'LCharacter_PlayMaterialParam::SelectType' has a wrong offset!");

// Function ProjectP.LCharacter.PlayMaterialVarying
// 0x0018 (0x0018 - 0x0000)
struct LCharacter_PlayMaterialVarying final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           SelectionType;                                     // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayName;                                          // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_PlayMaterialVarying) == 0x000008, "Wrong alignment on LCharacter_PlayMaterialVarying");
static_assert(sizeof(LCharacter_PlayMaterialVarying) == 0x000018, "Wrong size on LCharacter_PlayMaterialVarying");
static_assert(offsetof(LCharacter_PlayMaterialVarying, MaterialVarying) == 0x000000, "Member 'LCharacter_PlayMaterialVarying::MaterialVarying' has a wrong offset!");
static_assert(offsetof(LCharacter_PlayMaterialVarying, PlayType) == 0x000008, "Member 'LCharacter_PlayMaterialVarying::PlayType' has a wrong offset!");
static_assert(offsetof(LCharacter_PlayMaterialVarying, SelectionType) == 0x000009, "Member 'LCharacter_PlayMaterialVarying::SelectionType' has a wrong offset!");
static_assert(offsetof(LCharacter_PlayMaterialVarying, PlayName) == 0x00000C, "Member 'LCharacter_PlayMaterialVarying::PlayName' has a wrong offset!");

// Function ProjectP.LCharacter.PostHitProcess
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_PostHitProcess final
{
public:
	class ULHitProcContext*                       HitProcContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_PostHitProcess) == 0x000008, "Wrong alignment on LCharacter_PostHitProcess");
static_assert(sizeof(LCharacter_PostHitProcess) == 0x000008, "Wrong size on LCharacter_PostHitProcess");
static_assert(offsetof(LCharacter_PostHitProcess, HitProcContext) == 0x000000, "Member 'LCharacter_PostHitProcess::HitProcContext' has a wrong offset!");

// Function ProjectP.LCharacter.ProcessHitContextDeliver
// 0x0010 (0x0010 - 0x0000)
struct LCharacter_ProcessHitContextDeliver final
{
public:
	class ULHitProcContext*                       LHitProcContext;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_ProcessHitContextDeliver) == 0x000008, "Wrong alignment on LCharacter_ProcessHitContextDeliver");
static_assert(sizeof(LCharacter_ProcessHitContextDeliver) == 0x000010, "Wrong size on LCharacter_ProcessHitContextDeliver");
static_assert(offsetof(LCharacter_ProcessHitContextDeliver, LHitProcContext) == 0x000000, "Member 'LCharacter_ProcessHitContextDeliver::LHitProcContext' has a wrong offset!");
static_assert(offsetof(LCharacter_ProcessHitContextDeliver, Branches) == 0x000008, "Member 'LCharacter_ProcessHitContextDeliver::Branches' has a wrong offset!");

// Function ProjectP.LCharacter.ReceiveDamage
// 0x00E8 (0x00E8 - 0x0000)
struct LCharacter_ReceiveDamage final
{
public:
	struct FLReceiveDamageParams                  Params_0;                                          // 0x0000(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLReceiveDamageResults                 ReturnValue;                                       // 0x00D0(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_ReceiveDamage) == 0x000008, "Wrong alignment on LCharacter_ReceiveDamage");
static_assert(sizeof(LCharacter_ReceiveDamage) == 0x0000E8, "Wrong size on LCharacter_ReceiveDamage");
static_assert(offsetof(LCharacter_ReceiveDamage, Params_0) == 0x000000, "Member 'LCharacter_ReceiveDamage::Params_0' has a wrong offset!");
static_assert(offsetof(LCharacter_ReceiveDamage, ReturnValue) == 0x0000D0, "Member 'LCharacter_ReceiveDamage::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.ReceivePartsDamage
// 0x0018 (0x0018 - 0x0000)
struct LCharacter_ReceivePartsDamage final
{
public:
	class ULPartsComponent*                       PartsComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestructionIndexDestoryed;                        // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitProcContext*                       HitProcContext;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_ReceivePartsDamage) == 0x000008, "Wrong alignment on LCharacter_ReceivePartsDamage");
static_assert(sizeof(LCharacter_ReceivePartsDamage) == 0x000018, "Wrong size on LCharacter_ReceivePartsDamage");
static_assert(offsetof(LCharacter_ReceivePartsDamage, PartsComponent) == 0x000000, "Member 'LCharacter_ReceivePartsDamage::PartsComponent' has a wrong offset!");
static_assert(offsetof(LCharacter_ReceivePartsDamage, Damage) == 0x000008, "Member 'LCharacter_ReceivePartsDamage::Damage' has a wrong offset!");
static_assert(offsetof(LCharacter_ReceivePartsDamage, bDestructionIndexDestoryed) == 0x00000C, "Member 'LCharacter_ReceivePartsDamage::bDestructionIndexDestoryed' has a wrong offset!");
static_assert(offsetof(LCharacter_ReceivePartsDamage, HitProcContext) == 0x000010, "Member 'LCharacter_ReceivePartsDamage::HitProcContext' has a wrong offset!");

// Function ProjectP.LCharacter.RegisterNavigationInvoker
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_RegisterNavigationInvoker final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_RegisterNavigationInvoker) == 0x000004, "Wrong alignment on LCharacter_RegisterNavigationInvoker");
static_assert(sizeof(LCharacter_RegisterNavigationInvoker) == 0x000008, "Wrong size on LCharacter_RegisterNavigationInvoker");
static_assert(offsetof(LCharacter_RegisterNavigationInvoker, StateName) == 0x000000, "Member 'LCharacter_RegisterNavigationInvoker::StateName' has a wrong offset!");

// Function ProjectP.LCharacter.SetReverseDirection
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_SetReverseDirection final
{
public:
	bool                                          bReverse;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_SetReverseDirection) == 0x000001, "Wrong alignment on LCharacter_SetReverseDirection");
static_assert(sizeof(LCharacter_SetReverseDirection) == 0x000001, "Wrong size on LCharacter_SetReverseDirection");
static_assert(offsetof(LCharacter_SetReverseDirection, bReverse) == 0x000000, "Member 'LCharacter_SetReverseDirection::bReverse' has a wrong offset!");

// Function ProjectP.LCharacter.SetRuntimeRootMotionEnabled
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_SetRuntimeRootMotionEnabled final
{
public:
	bool                                          bRootMotion;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_SetRuntimeRootMotionEnabled) == 0x000001, "Wrong alignment on LCharacter_SetRuntimeRootMotionEnabled");
static_assert(sizeof(LCharacter_SetRuntimeRootMotionEnabled) == 0x000001, "Wrong size on LCharacter_SetRuntimeRootMotionEnabled");
static_assert(offsetof(LCharacter_SetRuntimeRootMotionEnabled, bRootMotion) == 0x000000, "Member 'LCharacter_SetRuntimeRootMotionEnabled::bRootMotion' has a wrong offset!");

// Function ProjectP.LCharacter.StopMaterialVarying
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_StopMaterialVarying final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_StopMaterialVarying) == 0x000008, "Wrong alignment on LCharacter_StopMaterialVarying");
static_assert(sizeof(LCharacter_StopMaterialVarying) == 0x000008, "Wrong size on LCharacter_StopMaterialVarying");
static_assert(offsetof(LCharacter_StopMaterialVarying, MaterialVarying) == 0x000000, "Member 'LCharacter_StopMaterialVarying::MaterialVarying' has a wrong offset!");

// Function ProjectP.LCharacter.TraceFloatingCeiling
// 0x0020 (0x0020 - 0x0000)
struct LCharacter_TraceFloatingCeiling final
{
public:
	struct FVector                                TestLocation;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestCapsuleHalfHeight;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ResultLocation;                                    // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_TraceFloatingCeiling) == 0x000004, "Wrong alignment on LCharacter_TraceFloatingCeiling");
static_assert(sizeof(LCharacter_TraceFloatingCeiling) == 0x000020, "Wrong size on LCharacter_TraceFloatingCeiling");
static_assert(offsetof(LCharacter_TraceFloatingCeiling, TestLocation) == 0x000000, "Member 'LCharacter_TraceFloatingCeiling::TestLocation' has a wrong offset!");
static_assert(offsetof(LCharacter_TraceFloatingCeiling, TestCapsuleHalfHeight) == 0x00000C, "Member 'LCharacter_TraceFloatingCeiling::TestCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(LCharacter_TraceFloatingCeiling, ResultLocation) == 0x000010, "Member 'LCharacter_TraceFloatingCeiling::ResultLocation' has a wrong offset!");
static_assert(offsetof(LCharacter_TraceFloatingCeiling, ReturnValue) == 0x00001C, "Member 'LCharacter_TraceFloatingCeiling::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.TryConsumeElementalGauge
// 0x000C (0x000C - 0x0000)
struct LCharacter_TryConsumeElementalGauge final
{
public:
	ELSecondStat                                  ElementType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConsumePoint;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_TryConsumeElementalGauge) == 0x000004, "Wrong alignment on LCharacter_TryConsumeElementalGauge");
static_assert(sizeof(LCharacter_TryConsumeElementalGauge) == 0x00000C, "Wrong size on LCharacter_TryConsumeElementalGauge");
static_assert(offsetof(LCharacter_TryConsumeElementalGauge, ElementType) == 0x000000, "Member 'LCharacter_TryConsumeElementalGauge::ElementType' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeElementalGauge, ConsumePoint) == 0x000004, "Member 'LCharacter_TryConsumeElementalGauge::ConsumePoint' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeElementalGauge, ReturnValue) == 0x000008, "Member 'LCharacter_TryConsumeElementalGauge::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.TryConsumeTough
// 0x0178 (0x0178 - 0x0000)
struct LCharacter_TryConsumeTough final
{
public:
	int32                                         InAmount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Attacker;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          CheckOnly;                                         // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitProcContext*                       HitProcContext;                                    // 0x0168(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0170(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacter_TryConsumeTough) == 0x000008, "Wrong alignment on LCharacter_TryConsumeTough");
static_assert(sizeof(LCharacter_TryConsumeTough) == 0x000178, "Wrong size on LCharacter_TryConsumeTough");
static_assert(offsetof(LCharacter_TryConsumeTough, InAmount) == 0x000000, "Member 'LCharacter_TryConsumeTough::InAmount' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeTough, Attacker) == 0x000008, "Member 'LCharacter_TryConsumeTough::Attacker' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeTough, HitInfo) == 0x000010, "Member 'LCharacter_TryConsumeTough::HitInfo' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeTough, CheckOnly) == 0x000160, "Member 'LCharacter_TryConsumeTough::CheckOnly' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeTough, HitProcContext) == 0x000168, "Member 'LCharacter_TryConsumeTough::HitProcContext' has a wrong offset!");
static_assert(offsetof(LCharacter_TryConsumeTough, ReturnValue) == 0x000170, "Member 'LCharacter_TryConsumeTough::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.TrySuppressTough
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_TrySuppressTough final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_TrySuppressTough) == 0x000001, "Wrong alignment on LCharacter_TrySuppressTough");
static_assert(sizeof(LCharacter_TrySuppressTough) == 0x000001, "Wrong size on LCharacter_TrySuppressTough");
static_assert(offsetof(LCharacter_TrySuppressTough, ReturnValue) == 0x000000, "Member 'LCharacter_TrySuppressTough::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.UnregisterNavInvoker
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_UnregisterNavInvoker final
{
public:
	class FName                                   StateName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_UnregisterNavInvoker) == 0x000004, "Wrong alignment on LCharacter_UnregisterNavInvoker");
static_assert(sizeof(LCharacter_UnregisterNavInvoker) == 0x000008, "Wrong size on LCharacter_UnregisterNavInvoker");
static_assert(offsetof(LCharacter_UnregisterNavInvoker, StateName) == 0x000000, "Member 'LCharacter_UnregisterNavInvoker::StateName' has a wrong offset!");

// Function ProjectP.LCharacter.GetActionGroup
// 0x0018 (0x0018 - 0x0000)
struct LCharacter_GetActionGroup final
{
public:
	class FName                                   ActionGroup;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonActionGroup;                                 // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocomotionActionGroup;                             // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetActionGroup) == 0x000004, "Wrong alignment on LCharacter_GetActionGroup");
static_assert(sizeof(LCharacter_GetActionGroup) == 0x000018, "Wrong size on LCharacter_GetActionGroup");
static_assert(offsetof(LCharacter_GetActionGroup, ActionGroup) == 0x000000, "Member 'LCharacter_GetActionGroup::ActionGroup' has a wrong offset!");
static_assert(offsetof(LCharacter_GetActionGroup, CommonActionGroup) == 0x000008, "Member 'LCharacter_GetActionGroup::CommonActionGroup' has a wrong offset!");
static_assert(offsetof(LCharacter_GetActionGroup, LocomotionActionGroup) == 0x000010, "Member 'LCharacter_GetActionGroup::LocomotionActionGroup' has a wrong offset!");

// Function ProjectP.LCharacter.GetCurrCollisionState
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_GetCurrCollisionState final
{
public:
	ELCollisionState                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetCurrCollisionState) == 0x000001, "Wrong alignment on LCharacter_GetCurrCollisionState");
static_assert(sizeof(LCharacter_GetCurrCollisionState) == 0x000001, "Wrong size on LCharacter_GetCurrCollisionState");
static_assert(offsetof(LCharacter_GetCurrCollisionState, ReturnValue) == 0x000000, "Member 'LCharacter_GetCurrCollisionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GetFloorPhysicalSurface
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_GetFloorPhysicalSurface final
{
public:
	EPhysicalSurface                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetFloorPhysicalSurface) == 0x000001, "Wrong alignment on LCharacter_GetFloorPhysicalSurface");
static_assert(sizeof(LCharacter_GetFloorPhysicalSurface) == 0x000001, "Wrong size on LCharacter_GetFloorPhysicalSurface");
static_assert(offsetof(LCharacter_GetFloorPhysicalSurface, ReturnValue) == 0x000000, "Member 'LCharacter_GetFloorPhysicalSurface::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GetNavData
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_GetNavData final
{
public:
	const class ANavigationData*                  ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetNavData) == 0x000008, "Wrong alignment on LCharacter_GetNavData");
static_assert(sizeof(LCharacter_GetNavData) == 0x000008, "Wrong size on LCharacter_GetNavData");
static_assert(offsetof(LCharacter_GetNavData, ReturnValue) == 0x000000, "Member 'LCharacter_GetNavData::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.GetNavInvokerRadius
// 0x0008 (0x0008 - 0x0000)
struct LCharacter_GetNavInvokerRadius final
{
public:
	float                                         TileGenerationRadius;                              // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileRemovalRadius;                                 // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetNavInvokerRadius) == 0x000004, "Wrong alignment on LCharacter_GetNavInvokerRadius");
static_assert(sizeof(LCharacter_GetNavInvokerRadius) == 0x000008, "Wrong size on LCharacter_GetNavInvokerRadius");
static_assert(offsetof(LCharacter_GetNavInvokerRadius, TileGenerationRadius) == 0x000000, "Member 'LCharacter_GetNavInvokerRadius::TileGenerationRadius' has a wrong offset!");
static_assert(offsetof(LCharacter_GetNavInvokerRadius, TileRemovalRadius) == 0x000004, "Member 'LCharacter_GetNavInvokerRadius::TileRemovalRadius' has a wrong offset!");

// Function ProjectP.LCharacter.GetOriginTransform
// 0x0030 (0x0030 - 0x0000)
struct LCharacter_GetOriginTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_GetOriginTransform) == 0x000010, "Wrong alignment on LCharacter_GetOriginTransform");
static_assert(sizeof(LCharacter_GetOriginTransform) == 0x000030, "Wrong size on LCharacter_GetOriginTransform");
static_assert(offsetof(LCharacter_GetOriginTransform, ReturnValue) == 0x000000, "Member 'LCharacter_GetOriginTransform::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.IsRespawnInProgress
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_IsRespawnInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_IsRespawnInProgress) == 0x000001, "Wrong alignment on LCharacter_IsRespawnInProgress");
static_assert(sizeof(LCharacter_IsRespawnInProgress) == 0x000001, "Wrong size on LCharacter_IsRespawnInProgress");
static_assert(offsetof(LCharacter_IsRespawnInProgress, ReturnValue) == 0x000000, "Member 'LCharacter_IsRespawnInProgress::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacter.IsRuntimeRootMotionEnabled
// 0x0001 (0x0001 - 0x0000)
struct LCharacter_IsRuntimeRootMotionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacter_IsRuntimeRootMotionEnabled) == 0x000001, "Wrong alignment on LCharacter_IsRuntimeRootMotionEnabled");
static_assert(sizeof(LCharacter_IsRuntimeRootMotionEnabled) == 0x000001, "Wrong size on LCharacter_IsRuntimeRootMotionEnabled");
static_assert(offsetof(LCharacter_IsRuntimeRootMotionEnabled, ReturnValue) == 0x000000, "Member 'LCharacter_IsRuntimeRootMotionEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.AddAccumulatedMovement
// 0x0010 (0x0010 - 0x0000)
struct LCharacterMovementComponent_AddAccumulatedMovement final
{
public:
	struct FVector                                AccumulatedMovement;                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyWalkingOnly;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InSetUseCanWalkOnNaviOnly;                         // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InSetUseCanWalkOnFloorOnly;                        // 0x000E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacterMovementComponent_AddAccumulatedMovement) == 0x000004, "Wrong alignment on LCharacterMovementComponent_AddAccumulatedMovement");
static_assert(sizeof(LCharacterMovementComponent_AddAccumulatedMovement) == 0x000010, "Wrong size on LCharacterMovementComponent_AddAccumulatedMovement");
static_assert(offsetof(LCharacterMovementComponent_AddAccumulatedMovement, AccumulatedMovement) == 0x000000, "Member 'LCharacterMovementComponent_AddAccumulatedMovement::AccumulatedMovement' has a wrong offset!");
static_assert(offsetof(LCharacterMovementComponent_AddAccumulatedMovement, ApplyWalkingOnly) == 0x00000C, "Member 'LCharacterMovementComponent_AddAccumulatedMovement::ApplyWalkingOnly' has a wrong offset!");
static_assert(offsetof(LCharacterMovementComponent_AddAccumulatedMovement, InSetUseCanWalkOnNaviOnly) == 0x00000D, "Member 'LCharacterMovementComponent_AddAccumulatedMovement::InSetUseCanWalkOnNaviOnly' has a wrong offset!");
static_assert(offsetof(LCharacterMovementComponent_AddAccumulatedMovement, InSetUseCanWalkOnFloorOnly) == 0x00000E, "Member 'LCharacterMovementComponent_AddAccumulatedMovement::InSetUseCanWalkOnFloorOnly' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.SetBrakingDecelerationOverride
// 0x0004 (0x0004 - 0x0000)
struct LCharacterMovementComponent_SetBrakingDecelerationOverride final
{
public:
	float                                         InBrakingDecelerationOverride;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacterMovementComponent_SetBrakingDecelerationOverride) == 0x000004, "Wrong alignment on LCharacterMovementComponent_SetBrakingDecelerationOverride");
static_assert(sizeof(LCharacterMovementComponent_SetBrakingDecelerationOverride) == 0x000004, "Wrong size on LCharacterMovementComponent_SetBrakingDecelerationOverride");
static_assert(offsetof(LCharacterMovementComponent_SetBrakingDecelerationOverride, InBrakingDecelerationOverride) == 0x000000, "Member 'LCharacterMovementComponent_SetBrakingDecelerationOverride::InBrakingDecelerationOverride' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.SetFrictionOverride
// 0x0004 (0x0004 - 0x0000)
struct LCharacterMovementComponent_SetFrictionOverride final
{
public:
	float                                         InFrictionOverride;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacterMovementComponent_SetFrictionOverride) == 0x000004, "Wrong alignment on LCharacterMovementComponent_SetFrictionOverride");
static_assert(sizeof(LCharacterMovementComponent_SetFrictionOverride) == 0x000004, "Wrong size on LCharacterMovementComponent_SetFrictionOverride");
static_assert(offsetof(LCharacterMovementComponent_SetFrictionOverride, InFrictionOverride) == 0x000000, "Member 'LCharacterMovementComponent_SetFrictionOverride::InFrictionOverride' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.SetIgnoreRootmotionVelocity
// 0x0001 (0x0001 - 0x0000)
struct LCharacterMovementComponent_SetIgnoreRootmotionVelocity final
{
public:
	bool                                          DoIgnore;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacterMovementComponent_SetIgnoreRootmotionVelocity) == 0x000001, "Wrong alignment on LCharacterMovementComponent_SetIgnoreRootmotionVelocity");
static_assert(sizeof(LCharacterMovementComponent_SetIgnoreRootmotionVelocity) == 0x000001, "Wrong size on LCharacterMovementComponent_SetIgnoreRootmotionVelocity");
static_assert(offsetof(LCharacterMovementComponent_SetIgnoreRootmotionVelocity, DoIgnore) == 0x000000, "Member 'LCharacterMovementComponent_SetIgnoreRootmotionVelocity::DoIgnore' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.SetUseVelocityControl
// 0x0008 (0x0008 - 0x0000)
struct LCharacterMovementComponent_SetUseVelocityControl final
{
public:
	bool                                          InUseVelocityControl;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InMaxWalkSpeed;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacterMovementComponent_SetUseVelocityControl) == 0x000004, "Wrong alignment on LCharacterMovementComponent_SetUseVelocityControl");
static_assert(sizeof(LCharacterMovementComponent_SetUseVelocityControl) == 0x000008, "Wrong size on LCharacterMovementComponent_SetUseVelocityControl");
static_assert(offsetof(LCharacterMovementComponent_SetUseVelocityControl, InUseVelocityControl) == 0x000000, "Member 'LCharacterMovementComponent_SetUseVelocityControl::InUseVelocityControl' has a wrong offset!");
static_assert(offsetof(LCharacterMovementComponent_SetUseVelocityControl, InMaxWalkSpeed) == 0x000004, "Member 'LCharacterMovementComponent_SetUseVelocityControl::InMaxWalkSpeed' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.CheckIsValidLandingSpot
// 0x0098 (0x0098 - 0x0000)
struct LCharacterMovementComponent_CheckIsValidLandingSpot final
{
public:
	struct FVector                                CapsuleLocation;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x000C(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0094(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCharacterMovementComponent_CheckIsValidLandingSpot) == 0x000004, "Wrong alignment on LCharacterMovementComponent_CheckIsValidLandingSpot");
static_assert(sizeof(LCharacterMovementComponent_CheckIsValidLandingSpot) == 0x000098, "Wrong size on LCharacterMovementComponent_CheckIsValidLandingSpot");
static_assert(offsetof(LCharacterMovementComponent_CheckIsValidLandingSpot, CapsuleLocation) == 0x000000, "Member 'LCharacterMovementComponent_CheckIsValidLandingSpot::CapsuleLocation' has a wrong offset!");
static_assert(offsetof(LCharacterMovementComponent_CheckIsValidLandingSpot, Hit) == 0x00000C, "Member 'LCharacterMovementComponent_CheckIsValidLandingSpot::Hit' has a wrong offset!");
static_assert(offsetof(LCharacterMovementComponent_CheckIsValidLandingSpot, ReturnValue) == 0x000094, "Member 'LCharacterMovementComponent_CheckIsValidLandingSpot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCharacterMovementComponent.GetUseVelocityControl
// 0x0001 (0x0001 - 0x0000)
struct LCharacterMovementComponent_GetUseVelocityControl final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCharacterMovementComponent_GetUseVelocityControl) == 0x000001, "Wrong alignment on LCharacterMovementComponent_GetUseVelocityControl");
static_assert(sizeof(LCharacterMovementComponent_GetUseVelocityControl) == 0x000001, "Wrong size on LCharacterMovementComponent_GetUseVelocityControl");
static_assert(offsetof(LCharacterMovementComponent_GetUseVelocityControl, ReturnValue) == 0x000000, "Member 'LCharacterMovementComponent_GetUseVelocityControl::ReturnValue' has a wrong offset!");

// Function ProjectP.LLevelPreloadBoxComponent.OnComponentBeginOverlapProjectile
// 0x00A8 (0x00A8 - 0x0000)
struct LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile) == 0x000008, "Wrong alignment on LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile");
static_assert(sizeof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile) == 0x0000A8, "Wrong size on LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile, OverlappedComponent) == 0x000000, "Member 'LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile, OtherActor) == 0x000008, "Member 'LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile::OtherActor' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile, OtherComp) == 0x000010, "Member 'LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile::OtherComp' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile, OtherBodyIndex) == 0x000018, "Member 'LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile, bFromSweep) == 0x00001C, "Member 'LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile::bFromSweep' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile, SweepResult) == 0x000020, "Member 'LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile::SweepResult' has a wrong offset!");

// Function ProjectP.LLevelPreloadBoxComponent.OnComponentEndOverlapProjectlie
// 0x0020 (0x0020 - 0x0000)
struct LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie) == 0x000008, "Wrong alignment on LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie");
static_assert(sizeof(LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie) == 0x000020, "Wrong size on LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie, OverlappedComponent) == 0x000000, "Member 'LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie, OtherActor) == 0x000008, "Member 'LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie::OtherActor' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie, OtherComp) == 0x000010, "Member 'LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie::OtherComp' has a wrong offset!");
static_assert(offsetof(LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie, OtherBodyIndex) == 0x000018, "Member 'LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LCheatManager.DisableNotify
// 0x0010 (0x0010 - 0x0000)
struct LCheatManager_DisableNotify final
{
public:
	class FString                                 NotifyType;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCheatManager_DisableNotify) == 0x000008, "Wrong alignment on LCheatManager_DisableNotify");
static_assert(sizeof(LCheatManager_DisableNotify) == 0x000010, "Wrong size on LCheatManager_DisableNotify");
static_assert(offsetof(LCheatManager_DisableNotify, NotifyType) == 0x000000, "Member 'LCheatManager_DisableNotify::NotifyType' has a wrong offset!");

// Function ProjectP.LCheatManager.EnableNotify
// 0x0010 (0x0010 - 0x0000)
struct LCheatManager_EnableNotify final
{
public:
	class FString                                 NotifyType;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCheatManager_EnableNotify) == 0x000008, "Wrong alignment on LCheatManager_EnableNotify");
static_assert(sizeof(LCheatManager_EnableNotify) == 0x000010, "Wrong size on LCheatManager_EnableNotify");
static_assert(offsetof(LCheatManager_EnableNotify, NotifyType) == 0x000000, "Member 'LCheatManager_EnableNotify::NotifyType' has a wrong offset!");

// Function ProjectP.LCheatManager.GetActivePlayerController
// 0x0008 (0x0008 - 0x0000)
struct LCheatManager_GetActivePlayerController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCheatManager_GetActivePlayerController) == 0x000008, "Wrong alignment on LCheatManager_GetActivePlayerController");
static_assert(sizeof(LCheatManager_GetActivePlayerController) == 0x000008, "Wrong size on LCheatManager_GetActivePlayerController");
static_assert(offsetof(LCheatManager_GetActivePlayerController, ReturnValue) == 0x000000, "Member 'LCheatManager_GetActivePlayerController::ReturnValue' has a wrong offset!");

// Function ProjectP.LCheatManager.IsActiveDebugCamera
// 0x0001 (0x0001 - 0x0000)
struct LCheatManager_IsActiveDebugCamera final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCheatManager_IsActiveDebugCamera) == 0x000001, "Wrong alignment on LCheatManager_IsActiveDebugCamera");
static_assert(sizeof(LCheatManager_IsActiveDebugCamera) == 0x000001, "Wrong size on LCheatManager_IsActiveDebugCamera");
static_assert(offsetof(LCheatManager_IsActiveDebugCamera, ReturnValue) == 0x000000, "Member 'LCheatManager_IsActiveDebugCamera::ReturnValue' has a wrong offset!");

// Function ProjectP.LCheatManager.SetDebugCameraSpeedScale
// 0x0004 (0x0004 - 0x0000)
struct LCheatManager_SetDebugCameraSpeedScale final
{
public:
	float                                         InSpeedScale;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCheatManager_SetDebugCameraSpeedScale) == 0x000004, "Wrong alignment on LCheatManager_SetDebugCameraSpeedScale");
static_assert(sizeof(LCheatManager_SetDebugCameraSpeedScale) == 0x000004, "Wrong size on LCheatManager_SetDebugCameraSpeedScale");
static_assert(offsetof(LCheatManager_SetDebugCameraSpeedScale, InSpeedScale) == 0x000000, "Member 'LCheatManager_SetDebugCameraSpeedScale::InSpeedScale' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckCurrAction_ActionState
// 0x000C (0x000C - 0x0000)
struct LComboTableBase_CheckCurrAction_ActionState final
{
public:
	class FName                                   State;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LComboTableBase_CheckCurrAction_ActionState) == 0x000004, "Wrong alignment on LComboTableBase_CheckCurrAction_ActionState");
static_assert(sizeof(LComboTableBase_CheckCurrAction_ActionState) == 0x00000C, "Wrong size on LComboTableBase_CheckCurrAction_ActionState");
static_assert(offsetof(LComboTableBase_CheckCurrAction_ActionState, State) == 0x000000, "Member 'LComboTableBase_CheckCurrAction_ActionState::State' has a wrong offset!");
static_assert(offsetof(LComboTableBase_CheckCurrAction_ActionState, ReturnValue) == 0x000008, "Member 'LComboTableBase_CheckCurrAction_ActionState::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckCurrAction_Category
// 0x0002 (0x0002 - 0x0000)
struct LComboTableBase_CheckCurrAction_Category final
{
public:
	ELActionCategory                              Category;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_CheckCurrAction_Category) == 0x000001, "Wrong alignment on LComboTableBase_CheckCurrAction_Category");
static_assert(sizeof(LComboTableBase_CheckCurrAction_Category) == 0x000002, "Wrong size on LComboTableBase_CheckCurrAction_Category");
static_assert(offsetof(LComboTableBase_CheckCurrAction_Category, Category) == 0x000000, "Member 'LComboTableBase_CheckCurrAction_Category::Category' has a wrong offset!");
static_assert(offsetof(LComboTableBase_CheckCurrAction_Category, ReturnValue) == 0x000001, "Member 'LComboTableBase_CheckCurrAction_Category::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckCurrAction_Class
// 0x0030 (0x0030 - 0x0000)
struct LComboTableBase_CheckCurrAction_Class final
{
public:
	TSoftClassPtr<class UClass>                   Type;                                              // 0x0000(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LComboTableBase_CheckCurrAction_Class) == 0x000008, "Wrong alignment on LComboTableBase_CheckCurrAction_Class");
static_assert(sizeof(LComboTableBase_CheckCurrAction_Class) == 0x000030, "Wrong size on LComboTableBase_CheckCurrAction_Class");
static_assert(offsetof(LComboTableBase_CheckCurrAction_Class, Type) == 0x000000, "Member 'LComboTableBase_CheckCurrAction_Class::Type' has a wrong offset!");
static_assert(offsetof(LComboTableBase_CheckCurrAction_Class, ReturnValue) == 0x000028, "Member 'LComboTableBase_CheckCurrAction_Class::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckCurrAction_SkillID
// 0x000C (0x000C - 0x0000)
struct LComboTableBase_CheckCurrAction_SkillID final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LComboTableBase_CheckCurrAction_SkillID) == 0x000004, "Wrong alignment on LComboTableBase_CheckCurrAction_SkillID");
static_assert(sizeof(LComboTableBase_CheckCurrAction_SkillID) == 0x00000C, "Wrong size on LComboTableBase_CheckCurrAction_SkillID");
static_assert(offsetof(LComboTableBase_CheckCurrAction_SkillID, ID) == 0x000000, "Member 'LComboTableBase_CheckCurrAction_SkillID::ID' has a wrong offset!");
static_assert(offsetof(LComboTableBase_CheckCurrAction_SkillID, ReturnValue) == 0x000008, "Member 'LComboTableBase_CheckCurrAction_SkillID::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckCurrAction_Valid
// 0x0001 (0x0001 - 0x0000)
struct LComboTableBase_CheckCurrAction_Valid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_CheckCurrAction_Valid) == 0x000001, "Wrong alignment on LComboTableBase_CheckCurrAction_Valid");
static_assert(sizeof(LComboTableBase_CheckCurrAction_Valid) == 0x000001, "Wrong size on LComboTableBase_CheckCurrAction_Valid");
static_assert(offsetof(LComboTableBase_CheckCurrAction_Valid, ReturnValue) == 0x000000, "Member 'LComboTableBase_CheckCurrAction_Valid::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckCurrActor_Moving
// 0x0001 (0x0001 - 0x0000)
struct LComboTableBase_CheckCurrActor_Moving final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_CheckCurrActor_Moving) == 0x000001, "Wrong alignment on LComboTableBase_CheckCurrActor_Moving");
static_assert(sizeof(LComboTableBase_CheckCurrActor_Moving) == 0x000001, "Wrong size on LComboTableBase_CheckCurrActor_Moving");
static_assert(offsetof(LComboTableBase_CheckCurrActor_Moving, ReturnValue) == 0x000000, "Member 'LComboTableBase_CheckCurrActor_Moving::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.CheckLever_Neutral
// 0x0002 (0x0002 - 0x0000)
struct LComboTableBase_CheckLever_Neutral final
{
public:
	bool                                          CheckInputted;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_CheckLever_Neutral) == 0x000001, "Wrong alignment on LComboTableBase_CheckLever_Neutral");
static_assert(sizeof(LComboTableBase_CheckLever_Neutral) == 0x000002, "Wrong size on LComboTableBase_CheckLever_Neutral");
static_assert(offsetof(LComboTableBase_CheckLever_Neutral, CheckInputted) == 0x000000, "Member 'LComboTableBase_CheckLever_Neutral::CheckInputted' has a wrong offset!");
static_assert(offsetof(LComboTableBase_CheckLever_Neutral, ReturnValue) == 0x000001, "Member 'LComboTableBase_CheckLever_Neutral::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.QueryNextAction
// 0x00A0 (0x00A0 - 0x0000)
struct LComboTableBase_QueryNextAction final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Command;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              CurrAction;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutActionClass;                                    // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLActionInfo                           ActionInfo;                                        // 0x0030(0x0060)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class ULActPayloadBase*                       OutPayload;                                        // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LComboTableBase_QueryNextAction) == 0x000008, "Wrong alignment on LComboTableBase_QueryNextAction");
static_assert(sizeof(LComboTableBase_QueryNextAction) == 0x0000A0, "Wrong size on LComboTableBase_QueryNextAction");
static_assert(offsetof(LComboTableBase_QueryNextAction, TargetActor) == 0x000000, "Member 'LComboTableBase_QueryNextAction::TargetActor' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, Command) == 0x000008, "Member 'LComboTableBase_QueryNextAction::Command' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, Lever) == 0x000010, "Member 'LComboTableBase_QueryNextAction::Lever' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, CurrAction) == 0x000020, "Member 'LComboTableBase_QueryNextAction::CurrAction' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, OutActionClass) == 0x000028, "Member 'LComboTableBase_QueryNextAction::OutActionClass' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, ActionInfo) == 0x000030, "Member 'LComboTableBase_QueryNextAction::ActionInfo' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, OutPayload) == 0x000090, "Member 'LComboTableBase_QueryNextAction::OutPayload' has a wrong offset!");
static_assert(offsetof(LComboTableBase_QueryNextAction, ReturnValue) == 0x000098, "Member 'LComboTableBase_QueryNextAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LComboTableBase.Select_Skill
// 0x0008 (0x0008 - 0x0000)
struct LComboTableBase_Select_Skill final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_Select_Skill) == 0x000004, "Wrong alignment on LComboTableBase_Select_Skill");
static_assert(sizeof(LComboTableBase_Select_Skill) == 0x000008, "Wrong size on LComboTableBase_Select_Skill");
static_assert(offsetof(LComboTableBase_Select_Skill, SkillCodeName) == 0x000000, "Member 'LComboTableBase_Select_Skill::SkillCodeName' has a wrong offset!");

// Function ProjectP.LComboTableBase.SelectDir_CurrentLever
// 0x0004 (0x0004 - 0x0000)
struct LComboTableBase_SelectDir_CurrentLever final
{
public:
	float                                         RotationTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_SelectDir_CurrentLever) == 0x000004, "Wrong alignment on LComboTableBase_SelectDir_CurrentLever");
static_assert(sizeof(LComboTableBase_SelectDir_CurrentLever) == 0x000004, "Wrong size on LComboTableBase_SelectDir_CurrentLever");
static_assert(offsetof(LComboTableBase_SelectDir_CurrentLever, RotationTime) == 0x000000, "Member 'LComboTableBase_SelectDir_CurrentLever::RotationTime' has a wrong offset!");

// Function ProjectP.LComboTableBase.SelectDir_InputttedLever
// 0x0004 (0x0004 - 0x0000)
struct LComboTableBase_SelectDir_InputttedLever final
{
public:
	float                                         RotationTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_SelectDir_InputttedLever) == 0x000004, "Wrong alignment on LComboTableBase_SelectDir_InputttedLever");
static_assert(sizeof(LComboTableBase_SelectDir_InputttedLever) == 0x000004, "Wrong size on LComboTableBase_SelectDir_InputttedLever");
static_assert(offsetof(LComboTableBase_SelectDir_InputttedLever, RotationTime) == 0x000000, "Member 'LComboTableBase_SelectDir_InputttedLever::RotationTime' has a wrong offset!");

// Function ProjectP.LComboTableBase.SelectDir_LockOnDir
// 0x0004 (0x0004 - 0x0000)
struct LComboTableBase_SelectDir_LockOnDir final
{
public:
	float                                         RotationTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_SelectDir_LockOnDir) == 0x000004, "Wrong alignment on LComboTableBase_SelectDir_LockOnDir");
static_assert(sizeof(LComboTableBase_SelectDir_LockOnDir) == 0x000004, "Wrong size on LComboTableBase_SelectDir_LockOnDir");
static_assert(offsetof(LComboTableBase_SelectDir_LockOnDir, RotationTime) == 0x000000, "Member 'LComboTableBase_SelectDir_LockOnDir::RotationTime' has a wrong offset!");

// Function ProjectP.LComboTableBase.Traverse
// 0x0028 (0x0028 - 0x0000)
struct LComboTableBase_Traverse final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Command;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              CurrAction;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComboTableBase_Traverse) == 0x000008, "Wrong alignment on LComboTableBase_Traverse");
static_assert(sizeof(LComboTableBase_Traverse) == 0x000028, "Wrong size on LComboTableBase_Traverse");
static_assert(offsetof(LComboTableBase_Traverse, TargetActor) == 0x000000, "Member 'LComboTableBase_Traverse::TargetActor' has a wrong offset!");
static_assert(offsetof(LComboTableBase_Traverse, Command) == 0x000008, "Member 'LComboTableBase_Traverse::Command' has a wrong offset!");
static_assert(offsetof(LComboTableBase_Traverse, Lever) == 0x000010, "Member 'LComboTableBase_Traverse::Lever' has a wrong offset!");
static_assert(offsetof(LComboTableBase_Traverse, CurrAction) == 0x000020, "Member 'LComboTableBase_Traverse::CurrAction' has a wrong offset!");

// Function ProjectP.LSequenceActorData.ExecuteSkipUIControl
// 0x0001 (0x0001 - 0x0000)
struct LSequenceActorData_ExecuteSkipUIControl final
{
public:
	bool                                          Visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSequenceActorData_ExecuteSkipUIControl) == 0x000001, "Wrong alignment on LSequenceActorData_ExecuteSkipUIControl");
static_assert(sizeof(LSequenceActorData_ExecuteSkipUIControl) == 0x000001, "Wrong size on LSequenceActorData_ExecuteSkipUIControl");
static_assert(offsetof(LSequenceActorData_ExecuteSkipUIControl, Visible) == 0x000000, "Member 'LSequenceActorData_ExecuteSkipUIControl::Visible' has a wrong offset!");

// Function ProjectP.LLiftObject.OnActorBeginOverlapToAudioVolume
// 0x0010 (0x0010 - 0x0000)
struct LLiftObject_OnActorBeginOverlapToAudioVolume final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLiftObject_OnActorBeginOverlapToAudioVolume) == 0x000008, "Wrong alignment on LLiftObject_OnActorBeginOverlapToAudioVolume");
static_assert(sizeof(LLiftObject_OnActorBeginOverlapToAudioVolume) == 0x000010, "Wrong size on LLiftObject_OnActorBeginOverlapToAudioVolume");
static_assert(offsetof(LLiftObject_OnActorBeginOverlapToAudioVolume, OverlappedActor) == 0x000000, "Member 'LLiftObject_OnActorBeginOverlapToAudioVolume::OverlappedActor' has a wrong offset!");
static_assert(offsetof(LLiftObject_OnActorBeginOverlapToAudioVolume, OtherActor) == 0x000008, "Member 'LLiftObject_OnActorBeginOverlapToAudioVolume::OtherActor' has a wrong offset!");

// Function ProjectP.LLiftObject.OnActorEndOverlapToAudioVolume
// 0x0010 (0x0010 - 0x0000)
struct LLiftObject_OnActorEndOverlapToAudioVolume final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLiftObject_OnActorEndOverlapToAudioVolume) == 0x000008, "Wrong alignment on LLiftObject_OnActorEndOverlapToAudioVolume");
static_assert(sizeof(LLiftObject_OnActorEndOverlapToAudioVolume) == 0x000010, "Wrong size on LLiftObject_OnActorEndOverlapToAudioVolume");
static_assert(offsetof(LLiftObject_OnActorEndOverlapToAudioVolume, OverlappedActor) == 0x000000, "Member 'LLiftObject_OnActorEndOverlapToAudioVolume::OverlappedActor' has a wrong offset!");
static_assert(offsetof(LLiftObject_OnActorEndOverlapToAudioVolume, OtherActor) == 0x000008, "Member 'LLiftObject_OnActorEndOverlapToAudioVolume::OtherActor' has a wrong offset!");

// Function ProjectP.LLiftObject.PlayInteractMotion
// 0x0004 (0x0004 - 0x0000)
struct LLiftObject_PlayInteractMotion final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLiftObject_PlayInteractMotion) == 0x000004, "Wrong alignment on LLiftObject_PlayInteractMotion");
static_assert(sizeof(LLiftObject_PlayInteractMotion) == 0x000004, "Wrong size on LLiftObject_PlayInteractMotion");
static_assert(offsetof(LLiftObject_PlayInteractMotion, ReturnValue) == 0x000000, "Member 'LLiftObject_PlayInteractMotion::ReturnValue' has a wrong offset!");

// Function ProjectP.LLiftObject.SetDoorState
// 0x0001 (0x0001 - 0x0000)
struct LLiftObject_SetDoorState final
{
public:
	ELDoorState                                   StateData;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLiftObject_SetDoorState) == 0x000001, "Wrong alignment on LLiftObject_SetDoorState");
static_assert(sizeof(LLiftObject_SetDoorState) == 0x000001, "Wrong size on LLiftObject_SetDoorState");
static_assert(offsetof(LLiftObject_SetDoorState, StateData) == 0x000000, "Member 'LLiftObject_SetDoorState::StateData' has a wrong offset!");

// Function ProjectP.LLiftObject.SetLiftObjectState
// 0x0001 (0x0001 - 0x0000)
struct LLiftObject_SetLiftObjectState final
{
public:
	ELLiftObjectState                             StateData;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLiftObject_SetLiftObjectState) == 0x000001, "Wrong alignment on LLiftObject_SetLiftObjectState");
static_assert(sizeof(LLiftObject_SetLiftObjectState) == 0x000001, "Wrong size on LLiftObject_SetLiftObjectState");
static_assert(offsetof(LLiftObject_SetLiftObjectState, StateData) == 0x000000, "Member 'LLiftObject_SetLiftObjectState::StateData' has a wrong offset!");

// Function ProjectP.LLiftObject.SetPropLiftState
// 0x0001 (0x0001 - 0x0000)
struct LLiftObject_SetPropLiftState final
{
public:
	ELPropLiftStateType                           StateData;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLiftObject_SetPropLiftState) == 0x000001, "Wrong alignment on LLiftObject_SetPropLiftState");
static_assert(sizeof(LLiftObject_SetPropLiftState) == 0x000001, "Wrong size on LLiftObject_SetPropLiftState");
static_assert(offsetof(LLiftObject_SetPropLiftState, StateData) == 0x000000, "Member 'LLiftObject_SetPropLiftState::StateData' has a wrong offset!");

// Function ProjectP.LQuartzPocket.InstallSlotFromUI
// 0x0010 (0x0010 - 0x0000)
struct LQuartzPocket_InstallSlotFromUI final
{
public:
	int32                                         InSlotIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuartzEffectCodeName;                              // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LQuartzPocket_InstallSlotFromUI) == 0x000004, "Wrong alignment on LQuartzPocket_InstallSlotFromUI");
static_assert(sizeof(LQuartzPocket_InstallSlotFromUI) == 0x000010, "Wrong size on LQuartzPocket_InstallSlotFromUI");
static_assert(offsetof(LQuartzPocket_InstallSlotFromUI, InSlotIndex) == 0x000000, "Member 'LQuartzPocket_InstallSlotFromUI::InSlotIndex' has a wrong offset!");
static_assert(offsetof(LQuartzPocket_InstallSlotFromUI, QuartzEffectCodeName) == 0x000004, "Member 'LQuartzPocket_InstallSlotFromUI::QuartzEffectCodeName' has a wrong offset!");
static_assert(offsetof(LQuartzPocket_InstallSlotFromUI, ReturnValue) == 0x00000C, "Member 'LQuartzPocket_InstallSlotFromUI::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzPocket.GetPocketLevel
// 0x0004 (0x0004 - 0x0000)
struct LQuartzPocket_GetPocketLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzPocket_GetPocketLevel) == 0x000004, "Wrong alignment on LQuartzPocket_GetPocketLevel");
static_assert(sizeof(LQuartzPocket_GetPocketLevel) == 0x000004, "Wrong size on LQuartzPocket_GetPocketLevel");
static_assert(offsetof(LQuartzPocket_GetPocketLevel, ReturnValue) == 0x000000, "Member 'LQuartzPocket_GetPocketLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzPocket.IsPocketUnlocked
// 0x0001 (0x0001 - 0x0000)
struct LQuartzPocket_IsPocketUnlocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzPocket_IsPocketUnlocked) == 0x000001, "Wrong alignment on LQuartzPocket_IsPocketUnlocked");
static_assert(sizeof(LQuartzPocket_IsPocketUnlocked) == 0x000001, "Wrong size on LQuartzPocket_IsPocketUnlocked");
static_assert(offsetof(LQuartzPocket_IsPocketUnlocked, ReturnValue) == 0x000000, "Member 'LQuartzPocket_IsPocketUnlocked::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.CheckTargetHittable
// 0x0018 (0x0018 - 0x0000)
struct LProjectile_CheckTargetHittable final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_CheckTargetHittable) == 0x000008, "Wrong alignment on LProjectile_CheckTargetHittable");
static_assert(sizeof(LProjectile_CheckTargetHittable) == 0x000018, "Wrong size on LProjectile_CheckTargetHittable");
static_assert(offsetof(LProjectile_CheckTargetHittable, Victim) == 0x000000, "Member 'LProjectile_CheckTargetHittable::Victim' has a wrong offset!");
static_assert(offsetof(LProjectile_CheckTargetHittable, SkillHitCodeName) == 0x000008, "Member 'LProjectile_CheckTargetHittable::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LProjectile_CheckTargetHittable, ReturnValue) == 0x000010, "Member 'LProjectile_CheckTargetHittable::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.CheckValidFaction
// 0x0010 (0x0010 - 0x0000)
struct LProjectile_CheckValidFaction final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_CheckValidFaction) == 0x000008, "Wrong alignment on LProjectile_CheckValidFaction");
static_assert(sizeof(LProjectile_CheckValidFaction) == 0x000010, "Wrong size on LProjectile_CheckValidFaction");
static_assert(offsetof(LProjectile_CheckValidFaction, Victim) == 0x000000, "Member 'LProjectile_CheckValidFaction::Victim' has a wrong offset!");
static_assert(offsetof(LProjectile_CheckValidFaction, ReturnValue) == 0x000008, "Member 'LProjectile_CheckValidFaction::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.CheckValidOverlapTarget
// 0x0010 (0x0010 - 0x0000)
struct LProjectile_CheckValidOverlapTarget final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_CheckValidOverlapTarget) == 0x000008, "Wrong alignment on LProjectile_CheckValidOverlapTarget");
static_assert(sizeof(LProjectile_CheckValidOverlapTarget) == 0x000010, "Wrong size on LProjectile_CheckValidOverlapTarget");
static_assert(offsetof(LProjectile_CheckValidOverlapTarget, Victim) == 0x000000, "Member 'LProjectile_CheckValidOverlapTarget::Victim' has a wrong offset!");
static_assert(offsetof(LProjectile_CheckValidOverlapTarget, ReturnValue) == 0x000008, "Member 'LProjectile_CheckValidOverlapTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.CheckValidTargetType
// 0x0010 (0x0010 - 0x0000)
struct LProjectile_CheckValidTargetType final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_CheckValidTargetType) == 0x000008, "Wrong alignment on LProjectile_CheckValidTargetType");
static_assert(sizeof(LProjectile_CheckValidTargetType) == 0x000010, "Wrong size on LProjectile_CheckValidTargetType");
static_assert(offsetof(LProjectile_CheckValidTargetType, Victim) == 0x000000, "Member 'LProjectile_CheckValidTargetType::Victim' has a wrong offset!");
static_assert(offsetof(LProjectile_CheckValidTargetType, ReturnValue) == 0x000008, "Member 'LProjectile_CheckValidTargetType::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.GenerateHit
// 0x00A0 (0x00A0 - 0x0000)
struct LProjectile_GenerateHit final
{
public:
	struct FLProjectileHitInfo                    HitInfo;                                           // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0090(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_GenerateHit) == 0x000010, "Wrong alignment on LProjectile_GenerateHit");
static_assert(sizeof(LProjectile_GenerateHit) == 0x0000A0, "Wrong size on LProjectile_GenerateHit");
static_assert(offsetof(LProjectile_GenerateHit, HitInfo) == 0x000000, "Member 'LProjectile_GenerateHit::HitInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_GenerateHit, Location) == 0x000090, "Member 'LProjectile_GenerateHit::Location' has a wrong offset!");

// Function ProjectP.LProjectile.GenerateHit_TargetOnly
// 0x0120 (0x0120 - 0x0000)
struct LProjectile_GenerateHit_TargetOnly final
{
public:
	struct FLProjectileHitInfo                    ProjectileHitInfo;                                 // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0090(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_GenerateHit_TargetOnly) == 0x000010, "Wrong alignment on LProjectile_GenerateHit_TargetOnly");
static_assert(sizeof(LProjectile_GenerateHit_TargetOnly) == 0x000120, "Wrong size on LProjectile_GenerateHit_TargetOnly");
static_assert(offsetof(LProjectile_GenerateHit_TargetOnly, ProjectileHitInfo) == 0x000000, "Member 'LProjectile_GenerateHit_TargetOnly::ProjectileHitInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_GenerateHit_TargetOnly, HitResult) == 0x000090, "Member 'LProjectile_GenerateHit_TargetOnly::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.GenerateHit_TargetOnly_V2
// 0x00B8 (0x00B8 - 0x0000)
struct LProjectile_GenerateHit_TargetOnly_V2 final
{
public:
	struct FLProjectileHitInfo_V2                 ProjectileHitInfo;                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0030(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_GenerateHit_TargetOnly_V2) == 0x000008, "Wrong alignment on LProjectile_GenerateHit_TargetOnly_V2");
static_assert(sizeof(LProjectile_GenerateHit_TargetOnly_V2) == 0x0000B8, "Wrong size on LProjectile_GenerateHit_TargetOnly_V2");
static_assert(offsetof(LProjectile_GenerateHit_TargetOnly_V2, ProjectileHitInfo) == 0x000000, "Member 'LProjectile_GenerateHit_TargetOnly_V2::ProjectileHitInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_GenerateHit_TargetOnly_V2, HitResult) == 0x000030, "Member 'LProjectile_GenerateHit_TargetOnly_V2::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.GenerateHit_V2
// 0x0040 (0x0040 - 0x0000)
struct LProjectile_GenerateHit_V2 final
{
public:
	struct FLProjectileHitInfo_V2                 HitInfo;                                           // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_GenerateHit_V2) == 0x000008, "Wrong alignment on LProjectile_GenerateHit_V2");
static_assert(sizeof(LProjectile_GenerateHit_V2) == 0x000040, "Wrong size on LProjectile_GenerateHit_V2");
static_assert(offsetof(LProjectile_GenerateHit_V2, HitInfo) == 0x000000, "Member 'LProjectile_GenerateHit_V2::HitInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_GenerateHit_V2, Location) == 0x000030, "Member 'LProjectile_GenerateHit_V2::Location' has a wrong offset!");

// Function ProjectP.LProjectile.GetOverlappedActorList
// 0x0010 (0x0010 - 0x0000)
struct LProjectile_GetOverlappedActorList final
{
public:
	TArray<class AActor*>                         OutList;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_GetOverlappedActorList) == 0x000008, "Wrong alignment on LProjectile_GetOverlappedActorList");
static_assert(sizeof(LProjectile_GetOverlappedActorList) == 0x000010, "Wrong size on LProjectile_GetOverlappedActorList");
static_assert(offsetof(LProjectile_GetOverlappedActorList, OutList) == 0x000000, "Member 'LProjectile_GetOverlappedActorList::OutList' has a wrong offset!");

// Function ProjectP.LProjectile.InitProjectile
// 0x00B0 (0x00B0 - 0x0000)
struct LProjectile_InitProjectile final
{
public:
	struct FProjectileInfoPtr                     InInfo;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLProjectileSpawnParameter             SpawnParameters;                                   // 0x0010(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_InitProjectile) == 0x000010, "Wrong alignment on LProjectile_InitProjectile");
static_assert(sizeof(LProjectile_InitProjectile) == 0x0000B0, "Wrong size on LProjectile_InitProjectile");
static_assert(offsetof(LProjectile_InitProjectile, InInfo) == 0x000000, "Member 'LProjectile_InitProjectile::InInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_InitProjectile, SpawnParameters) == 0x000010, "Member 'LProjectile_InitProjectile::SpawnParameters' has a wrong offset!");
static_assert(offsetof(LProjectile_InitProjectile, ReturnValue) == 0x0000A0, "Member 'LProjectile_InitProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.IsStopByNotify
// 0x0001 (0x0001 - 0x0000)
struct LProjectile_IsStopByNotify final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_IsStopByNotify) == 0x000001, "Wrong alignment on LProjectile_IsStopByNotify");
static_assert(sizeof(LProjectile_IsStopByNotify) == 0x000001, "Wrong size on LProjectile_IsStopByNotify");
static_assert(offsetof(LProjectile_IsStopByNotify, ReturnValue) == 0x000000, "Member 'LProjectile_IsStopByNotify::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.IsStopByRootOwnerDie
// 0x0001 (0x0001 - 0x0000)
struct LProjectile_IsStopByRootOwnerDie final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_IsStopByRootOwnerDie) == 0x000001, "Wrong alignment on LProjectile_IsStopByRootOwnerDie");
static_assert(sizeof(LProjectile_IsStopByRootOwnerDie) == 0x000001, "Wrong size on LProjectile_IsStopByRootOwnerDie");
static_assert(offsetof(LProjectile_IsStopByRootOwnerDie, ReturnValue) == 0x000000, "Member 'LProjectile_IsStopByRootOwnerDie::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.OnAttachedActorEndPlay
// 0x0010 (0x0010 - 0x0000)
struct LProjectile_OnAttachedActorEndPlay final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEndPlayReason                                EndPlayReason;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_OnAttachedActorEndPlay) == 0x000008, "Wrong alignment on LProjectile_OnAttachedActorEndPlay");
static_assert(sizeof(LProjectile_OnAttachedActorEndPlay) == 0x000010, "Wrong size on LProjectile_OnAttachedActorEndPlay");
static_assert(offsetof(LProjectile_OnAttachedActorEndPlay, Actor) == 0x000000, "Member 'LProjectile_OnAttachedActorEndPlay::Actor' has a wrong offset!");
static_assert(offsetof(LProjectile_OnAttachedActorEndPlay, EndPlayReason) == 0x000008, "Member 'LProjectile_OnAttachedActorEndPlay::EndPlayReason' has a wrong offset!");

// Function ProjectP.LProjectile.OnAttackedByOther
// 0x0010 (0x0010 - 0x0000)
struct LProjectile_OnAttackedByOther final
{
public:
	class AActor*                                 Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_OnAttackedByOther) == 0x000008, "Wrong alignment on LProjectile_OnAttackedByOther");
static_assert(sizeof(LProjectile_OnAttackedByOther) == 0x000010, "Wrong size on LProjectile_OnAttackedByOther");
static_assert(offsetof(LProjectile_OnAttackedByOther, Other) == 0x000000, "Member 'LProjectile_OnAttackedByOther::Other' has a wrong offset!");
static_assert(offsetof(LProjectile_OnAttackedByOther, SkillHitCodeName) == 0x000008, "Member 'LProjectile_OnAttackedByOther::SkillHitCodeName' has a wrong offset!");

// Function ProjectP.LProjectile.OnCollisionBeginOverlap
// 0x00A0 (0x00A0 - 0x0000)
struct LProjectile_OnCollisionBeginOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             SweepResult;                                       // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_OnCollisionBeginOverlap) == 0x000008, "Wrong alignment on LProjectile_OnCollisionBeginOverlap");
static_assert(sizeof(LProjectile_OnCollisionBeginOverlap) == 0x0000A0, "Wrong size on LProjectile_OnCollisionBeginOverlap");
static_assert(offsetof(LProjectile_OnCollisionBeginOverlap, OverlappedComponent) == 0x000000, "Member 'LProjectile_OnCollisionBeginOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LProjectile_OnCollisionBeginOverlap, OtherActor) == 0x000008, "Member 'LProjectile_OnCollisionBeginOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(LProjectile_OnCollisionBeginOverlap, OtherComp) == 0x000010, "Member 'LProjectile_OnCollisionBeginOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(LProjectile_OnCollisionBeginOverlap, SweepResult) == 0x000018, "Member 'LProjectile_OnCollisionBeginOverlap::SweepResult' has a wrong offset!");

// Function ProjectP.LProjectile.OnCollisionHit
// 0x00A0 (0x00A0 - 0x0000)
struct LProjectile_OnCollisionHit final
{
public:
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_OnCollisionHit) == 0x000008, "Wrong alignment on LProjectile_OnCollisionHit");
static_assert(sizeof(LProjectile_OnCollisionHit) == 0x0000A0, "Wrong size on LProjectile_OnCollisionHit");
static_assert(offsetof(LProjectile_OnCollisionHit, HitComponent) == 0x000000, "Member 'LProjectile_OnCollisionHit::HitComponent' has a wrong offset!");
static_assert(offsetof(LProjectile_OnCollisionHit, OtherActor) == 0x000008, "Member 'LProjectile_OnCollisionHit::OtherActor' has a wrong offset!");
static_assert(offsetof(LProjectile_OnCollisionHit, OtherComp) == 0x000010, "Member 'LProjectile_OnCollisionHit::OtherComp' has a wrong offset!");
static_assert(offsetof(LProjectile_OnCollisionHit, HitResult) == 0x000018, "Member 'LProjectile_OnCollisionHit::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.OnDeadParentCharacter
// 0x0008 (0x0008 - 0x0000)
struct LProjectile_OnDeadParentCharacter final
{
public:
	class ALCharacter*                            DeadCharacter;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_OnDeadParentCharacter) == 0x000008, "Wrong alignment on LProjectile_OnDeadParentCharacter");
static_assert(sizeof(LProjectile_OnDeadParentCharacter) == 0x000008, "Wrong size on LProjectile_OnDeadParentCharacter");
static_assert(offsetof(LProjectile_OnDeadParentCharacter, DeadCharacter) == 0x000000, "Member 'LProjectile_OnDeadParentCharacter::DeadCharacter' has a wrong offset!");

// Function ProjectP.LProjectile.OnDisappear
// 0x008C (0x008C - 0x0000)
struct LProjectile_OnDisappear final
{
public:
	ELProjectileDestroyReason                     Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0004(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_OnDisappear) == 0x000004, "Wrong alignment on LProjectile_OnDisappear");
static_assert(sizeof(LProjectile_OnDisappear) == 0x00008C, "Wrong size on LProjectile_OnDisappear");
static_assert(offsetof(LProjectile_OnDisappear, Reason) == 0x000000, "Member 'LProjectile_OnDisappear::Reason' has a wrong offset!");
static_assert(offsetof(LProjectile_OnDisappear, HitResult) == 0x000004, "Member 'LProjectile_OnDisappear::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.OnExplode
// 0x008C (0x008C - 0x0000)
struct LProjectile_OnExplode final
{
public:
	ELProjectileDestroyReason                     Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0004(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_OnExplode) == 0x000004, "Wrong alignment on LProjectile_OnExplode");
static_assert(sizeof(LProjectile_OnExplode) == 0x00008C, "Wrong size on LProjectile_OnExplode");
static_assert(offsetof(LProjectile_OnExplode, Reason) == 0x000000, "Member 'LProjectile_OnExplode::Reason' has a wrong offset!");
static_assert(offsetof(LProjectile_OnExplode, HitResult) == 0x000004, "Member 'LProjectile_OnExplode::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.ProcessHit
// 0x0120 (0x0120 - 0x0000)
struct LProjectile_ProcessHit final
{
public:
	struct FLProjectileHitInfo                    HitInfo;                                           // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0090(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_ProcessHit) == 0x000010, "Wrong alignment on LProjectile_ProcessHit");
static_assert(sizeof(LProjectile_ProcessHit) == 0x000120, "Wrong size on LProjectile_ProcessHit");
static_assert(offsetof(LProjectile_ProcessHit, HitInfo) == 0x000000, "Member 'LProjectile_ProcessHit::HitInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_ProcessHit, HitResult) == 0x000090, "Member 'LProjectile_ProcessHit::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.ProcessHitProp
// 0x0120 (0x0120 - 0x0000)
struct LProjectile_ProcessHitProp final
{
public:
	struct FLProjectileHitInfo                    ProjectileHitInfo;                                 // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0090(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectile_ProcessHitProp) == 0x000010, "Wrong alignment on LProjectile_ProcessHitProp");
static_assert(sizeof(LProjectile_ProcessHitProp) == 0x000120, "Wrong size on LProjectile_ProcessHitProp");
static_assert(offsetof(LProjectile_ProcessHitProp, ProjectileHitInfo) == 0x000000, "Member 'LProjectile_ProcessHitProp::ProjectileHitInfo' has a wrong offset!");
static_assert(offsetof(LProjectile_ProcessHitProp, HitResult) == 0x000090, "Member 'LProjectile_ProcessHitProp::HitResult' has a wrong offset!");

// Function ProjectP.LProjectile.SpawnChildren
// 0x0050 (0x0050 - 0x0000)
struct LProjectile_SpawnChildren final
{
public:
	struct FLChildProjectileSpawnInfo             ChildSpawnInfo;                                    // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_SpawnChildren) == 0x000010, "Wrong alignment on LProjectile_SpawnChildren");
static_assert(sizeof(LProjectile_SpawnChildren) == 0x000050, "Wrong size on LProjectile_SpawnChildren");
static_assert(offsetof(LProjectile_SpawnChildren, ChildSpawnInfo) == 0x000000, "Member 'LProjectile_SpawnChildren::ChildSpawnInfo' has a wrong offset!");

// Function ProjectP.LProjectile.SpawnProjectileDesignActor
// 0x0001 (0x0001 - 0x0000)
struct LProjectile_SpawnProjectileDesignActor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_SpawnProjectileDesignActor) == 0x000001, "Wrong alignment on LProjectile_SpawnProjectileDesignActor");
static_assert(sizeof(LProjectile_SpawnProjectileDesignActor) == 0x000001, "Wrong size on LProjectile_SpawnProjectileDesignActor");
static_assert(offsetof(LProjectile_SpawnProjectileDesignActor, ReturnValue) == 0x000000, "Member 'LProjectile_SpawnProjectileDesignActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectile.UpdateOverlapEvents
// 0x0004 (0x0004 - 0x0000)
struct LProjectile_UpdateOverlapEvents final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_UpdateOverlapEvents) == 0x000004, "Wrong alignment on LProjectile_UpdateOverlapEvents");
static_assert(sizeof(LProjectile_UpdateOverlapEvents) == 0x000004, "Wrong size on LProjectile_UpdateOverlapEvents");
static_assert(offsetof(LProjectile_UpdateOverlapEvents, DeltaTime) == 0x000000, "Member 'LProjectile_UpdateOverlapEvents::DeltaTime' has a wrong offset!");

// Function ProjectP.LProjectileHit_PeriodicHandler_V2.Initialize
// 0x0038 (0x0038 - 0x0000)
struct LProjectileHit_PeriodicHandler_V2_Initialize final
{
public:
	class ALProjectile*                           InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectileHitInfo_V2                 InHitInfo;                                         // 0x0008(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileHit_PeriodicHandler_V2_Initialize) == 0x000008, "Wrong alignment on LProjectileHit_PeriodicHandler_V2_Initialize");
static_assert(sizeof(LProjectileHit_PeriodicHandler_V2_Initialize) == 0x000038, "Wrong size on LProjectileHit_PeriodicHandler_V2_Initialize");
static_assert(offsetof(LProjectileHit_PeriodicHandler_V2_Initialize, InOwner) == 0x000000, "Member 'LProjectileHit_PeriodicHandler_V2_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LProjectileHit_PeriodicHandler_V2_Initialize, InHitInfo) == 0x000008, "Member 'LProjectileHit_PeriodicHandler_V2_Initialize::InHitInfo' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.AbandonItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_AbandonItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemoveCount;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_AbandonItem) == 0x000008, "Wrong alignment on LPlayerItemLocker_AbandonItem");
static_assert(sizeof(LPlayerItemLocker_AbandonItem) == 0x000010, "Wrong size on LPlayerItemLocker_AbandonItem");
static_assert(offsetof(LPlayerItemLocker_AbandonItem, Item) == 0x000000, "Member 'LPlayerItemLocker_AbandonItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_AbandonItem, RemoveCount) == 0x000008, "Member 'LPlayerItemLocker_AbandonItem::RemoveCount' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_AbandonItem, ReturnValue) == 0x00000C, "Member 'LPlayerItemLocker_AbandonItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.AddItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_AddItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_AddItem) == 0x000008, "Wrong alignment on LPlayerItemLocker_AddItem");
static_assert(sizeof(LPlayerItemLocker_AddItem) == 0x000010, "Wrong size on LPlayerItemLocker_AddItem");
static_assert(offsetof(LPlayerItemLocker_AddItem, Item) == 0x000000, "Member 'LPlayerItemLocker_AddItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_AddItem, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_AddItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.FindCategoryItems
// 0x0018 (0x0018 - 0x0000)
struct LPlayerItemLocker_FindCategoryItems final
{
public:
	ELItemSecondCategory                          Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_FindCategoryItems) == 0x000008, "Wrong alignment on LPlayerItemLocker_FindCategoryItems");
static_assert(sizeof(LPlayerItemLocker_FindCategoryItems) == 0x000018, "Wrong size on LPlayerItemLocker_FindCategoryItems");
static_assert(offsetof(LPlayerItemLocker_FindCategoryItems, Category) == 0x000000, "Member 'LPlayerItemLocker_FindCategoryItems::Category' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_FindCategoryItems, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_FindCategoryItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.FindItemByCodeName
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_FindItemByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_FindItemByCodeName) == 0x000008, "Wrong alignment on LPlayerItemLocker_FindItemByCodeName");
static_assert(sizeof(LPlayerItemLocker_FindItemByCodeName) == 0x000010, "Wrong size on LPlayerItemLocker_FindItemByCodeName");
static_assert(offsetof(LPlayerItemLocker_FindItemByCodeName, CodeName) == 0x000000, "Member 'LPlayerItemLocker_FindItemByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_FindItemByCodeName, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_FindItemByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.FindItemsByCodeName
// 0x0018 (0x0018 - 0x0000)
struct LPlayerItemLocker_FindItemsByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_FindItemsByCodeName) == 0x000008, "Wrong alignment on LPlayerItemLocker_FindItemsByCodeName");
static_assert(sizeof(LPlayerItemLocker_FindItemsByCodeName) == 0x000018, "Wrong size on LPlayerItemLocker_FindItemsByCodeName");
static_assert(offsetof(LPlayerItemLocker_FindItemsByCodeName, CodeName) == 0x000000, "Member 'LPlayerItemLocker_FindItemsByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_FindItemsByCodeName, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_FindItemsByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.FindUICategoryItems
// 0x0018 (0x0018 - 0x0000)
struct LPlayerItemLocker_FindUICategoryItems final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_FindUICategoryItems) == 0x000008, "Wrong alignment on LPlayerItemLocker_FindUICategoryItems");
static_assert(sizeof(LPlayerItemLocker_FindUICategoryItems) == 0x000018, "Wrong size on LPlayerItemLocker_FindUICategoryItems");
static_assert(offsetof(LPlayerItemLocker_FindUICategoryItems, Category) == 0x000000, "Member 'LPlayerItemLocker_FindUICategoryItems::Category' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_FindUICategoryItems, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_FindUICategoryItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetAllItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_GetAllItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetAllItems) == 0x000008, "Wrong alignment on LPlayerItemLocker_GetAllItems");
static_assert(sizeof(LPlayerItemLocker_GetAllItems) == 0x000010, "Wrong size on LPlayerItemLocker_GetAllItems");
static_assert(offsetof(LPlayerItemLocker_GetAllItems, ReturnValue) == 0x000000, "Member 'LPlayerItemLocker_GetAllItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetCommonItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_GetCommonItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetCommonItems) == 0x000008, "Wrong alignment on LPlayerItemLocker_GetCommonItems");
static_assert(sizeof(LPlayerItemLocker_GetCommonItems) == 0x000010, "Wrong size on LPlayerItemLocker_GetCommonItems");
static_assert(offsetof(LPlayerItemLocker_GetCommonItems, ReturnValue) == 0x000000, "Member 'LPlayerItemLocker_GetCommonItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetItemCategoryMap
// 0x0050 (0x0050 - 0x0000)
struct LPlayerItemLocker_GetItemCategoryMap final
{
public:
	TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetItemCategoryMap) == 0x000008, "Wrong alignment on LPlayerItemLocker_GetItemCategoryMap");
static_assert(sizeof(LPlayerItemLocker_GetItemCategoryMap) == 0x000050, "Wrong size on LPlayerItemLocker_GetItemCategoryMap");
static_assert(offsetof(LPlayerItemLocker_GetItemCategoryMap, ReturnValue) == 0x000000, "Member 'LPlayerItemLocker_GetItemCategoryMap::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetItemTotalCountByCodeName
// 0x000C (0x000C - 0x0000)
struct LPlayerItemLocker_GetItemTotalCountByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetItemTotalCountByCodeName) == 0x000004, "Wrong alignment on LPlayerItemLocker_GetItemTotalCountByCodeName");
static_assert(sizeof(LPlayerItemLocker_GetItemTotalCountByCodeName) == 0x00000C, "Wrong size on LPlayerItemLocker_GetItemTotalCountByCodeName");
static_assert(offsetof(LPlayerItemLocker_GetItemTotalCountByCodeName, CodeName) == 0x000000, "Member 'LPlayerItemLocker_GetItemTotalCountByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_GetItemTotalCountByCodeName, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_GetItemTotalCountByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetMaxItemCountMovableToInventory
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_GetMaxItemCountMovableToInventory final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_GetMaxItemCountMovableToInventory) == 0x000008, "Wrong alignment on LPlayerItemLocker_GetMaxItemCountMovableToInventory");
static_assert(sizeof(LPlayerItemLocker_GetMaxItemCountMovableToInventory) == 0x000010, "Wrong size on LPlayerItemLocker_GetMaxItemCountMovableToInventory");
static_assert(offsetof(LPlayerItemLocker_GetMaxItemCountMovableToInventory, Item) == 0x000000, "Member 'LPlayerItemLocker_GetMaxItemCountMovableToInventory::Item' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_GetMaxItemCountMovableToInventory, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_GetMaxItemCountMovableToInventory::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetRequirementItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_GetRequirementItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetRequirementItems) == 0x000008, "Wrong alignment on LPlayerItemLocker_GetRequirementItems");
static_assert(sizeof(LPlayerItemLocker_GetRequirementItems) == 0x000010, "Wrong size on LPlayerItemLocker_GetRequirementItems");
static_assert(offsetof(LPlayerItemLocker_GetRequirementItems, ReturnValue) == 0x000000, "Member 'LPlayerItemLocker_GetRequirementItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetWeaponItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_GetWeaponItems final
{
public:
	TArray<class ULWeaponItem*>                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetWeaponItems) == 0x000008, "Wrong alignment on LPlayerItemLocker_GetWeaponItems");
static_assert(sizeof(LPlayerItemLocker_GetWeaponItems) == 0x000010, "Wrong size on LPlayerItemLocker_GetWeaponItems");
static_assert(offsetof(LPlayerItemLocker_GetWeaponItems, ReturnValue) == 0x000000, "Member 'LPlayerItemLocker_GetWeaponItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.GetWeaponTotalCountByCodeName
// 0x0014 (0x0014 - 0x0000)
struct LPlayerItemLocker_GetWeaponTotalCountByCodeName final
{
public:
	class FName                                   HandleCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BladeCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerItemLocker_GetWeaponTotalCountByCodeName) == 0x000004, "Wrong alignment on LPlayerItemLocker_GetWeaponTotalCountByCodeName");
static_assert(sizeof(LPlayerItemLocker_GetWeaponTotalCountByCodeName) == 0x000014, "Wrong size on LPlayerItemLocker_GetWeaponTotalCountByCodeName");
static_assert(offsetof(LPlayerItemLocker_GetWeaponTotalCountByCodeName, HandleCodeName) == 0x000000, "Member 'LPlayerItemLocker_GetWeaponTotalCountByCodeName::HandleCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_GetWeaponTotalCountByCodeName, BladeCodeName) == 0x000008, "Member 'LPlayerItemLocker_GetWeaponTotalCountByCodeName::BladeCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_GetWeaponTotalCountByCodeName, ReturnValue) == 0x000010, "Member 'LPlayerItemLocker_GetWeaponTotalCountByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.HasItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_HasItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_HasItem) == 0x000008, "Wrong alignment on LPlayerItemLocker_HasItem");
static_assert(sizeof(LPlayerItemLocker_HasItem) == 0x000010, "Wrong size on LPlayerItemLocker_HasItem");
static_assert(offsetof(LPlayerItemLocker_HasItem, Item) == 0x000000, "Member 'LPlayerItemLocker_HasItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_HasItem, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_HasItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.MoveItemToInventory
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_MoveItemToInventory final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualMove;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_MoveItemToInventory) == 0x000008, "Wrong alignment on LPlayerItemLocker_MoveItemToInventory");
static_assert(sizeof(LPlayerItemLocker_MoveItemToInventory) == 0x000010, "Wrong size on LPlayerItemLocker_MoveItemToInventory");
static_assert(offsetof(LPlayerItemLocker_MoveItemToInventory, Item) == 0x000000, "Member 'LPlayerItemLocker_MoveItemToInventory::Item' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_MoveItemToInventory, ItemCount) == 0x000008, "Member 'LPlayerItemLocker_MoveItemToInventory::ItemCount' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_MoveItemToInventory, bManualMove) == 0x00000C, "Member 'LPlayerItemLocker_MoveItemToInventory::bManualMove' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_MoveItemToInventory, ReturnValue) == 0x00000D, "Member 'LPlayerItemLocker_MoveItemToInventory::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.RemoveItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerItemLocker_RemoveItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_RemoveItem) == 0x000008, "Wrong alignment on LPlayerItemLocker_RemoveItem");
static_assert(sizeof(LPlayerItemLocker_RemoveItem) == 0x000010, "Wrong size on LPlayerItemLocker_RemoveItem");
static_assert(offsetof(LPlayerItemLocker_RemoveItem, Item) == 0x000000, "Member 'LPlayerItemLocker_RemoveItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_RemoveItem, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_RemoveItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerItemLocker.HasSameItem
// 0x000C (0x000C - 0x0000)
struct LPlayerItemLocker_HasSameItem final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerItemLocker_HasSameItem) == 0x000004, "Wrong alignment on LPlayerItemLocker_HasSameItem");
static_assert(sizeof(LPlayerItemLocker_HasSameItem) == 0x00000C, "Wrong size on LPlayerItemLocker_HasSameItem");
static_assert(offsetof(LPlayerItemLocker_HasSameItem, ItemCodeName) == 0x000000, "Member 'LPlayerItemLocker_HasSameItem::ItemCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerItemLocker_HasSameItem, ReturnValue) == 0x000008, "Member 'LPlayerItemLocker_HasSameItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.CanStackCount
// 0x0001 (0x0001 - 0x0000)
struct LProduct_CanStackCount final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_CanStackCount) == 0x000001, "Wrong alignment on LProduct_CanStackCount");
static_assert(sizeof(LProduct_CanStackCount) == 0x000001, "Wrong size on LProduct_CanStackCount");
static_assert(offsetof(LProduct_CanStackCount, ReturnValue) == 0x000000, "Member 'LProduct_CanStackCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.GetItem
// 0x0008 (0x0008 - 0x0000)
struct LProduct_GetItem final
{
public:
	class ULItem*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_GetItem) == 0x000008, "Wrong alignment on LProduct_GetItem");
static_assert(sizeof(LProduct_GetItem) == 0x000008, "Wrong size on LProduct_GetItem");
static_assert(offsetof(LProduct_GetItem, ReturnValue) == 0x000000, "Member 'LProduct_GetItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.Price
// 0x0004 (0x0004 - 0x0000)
struct LProduct_Price final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_Price) == 0x000004, "Wrong alignment on LProduct_Price");
static_assert(sizeof(LProduct_Price) == 0x000004, "Wrong size on LProduct_Price");
static_assert(offsetof(LProduct_Price, ReturnValue) == 0x000000, "Member 'LProduct_Price::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.StockCount
// 0x0004 (0x0004 - 0x0000)
struct LProduct_StockCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_StockCount) == 0x000004, "Wrong alignment on LProduct_StockCount");
static_assert(sizeof(LProduct_StockCount) == 0x000004, "Wrong size on LProduct_StockCount");
static_assert(offsetof(LProduct_StockCount, ReturnValue) == 0x000000, "Member 'LProduct_StockCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.BuyNumMax
// 0x0004 (0x0004 - 0x0000)
struct LProduct_BuyNumMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_BuyNumMax) == 0x000004, "Wrong alignment on LProduct_BuyNumMax");
static_assert(sizeof(LProduct_BuyNumMax) == 0x000004, "Wrong size on LProduct_BuyNumMax");
static_assert(offsetof(LProduct_BuyNumMax, ReturnValue) == 0x000000, "Member 'LProduct_BuyNumMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.CanBuyInfinity
// 0x0001 (0x0001 - 0x0000)
struct LProduct_CanBuyInfinity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_CanBuyInfinity) == 0x000001, "Wrong alignment on LProduct_CanBuyInfinity");
static_assert(sizeof(LProduct_CanBuyInfinity) == 0x000001, "Wrong size on LProduct_CanBuyInfinity");
static_assert(offsetof(LProduct_CanBuyInfinity, ReturnValue) == 0x000000, "Member 'LProduct_CanBuyInfinity::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.CanDisplayOn
// 0x0001 (0x0001 - 0x0000)
struct LProduct_CanDisplayOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_CanDisplayOn) == 0x000001, "Wrong alignment on LProduct_CanDisplayOn");
static_assert(sizeof(LProduct_CanDisplayOn) == 0x000001, "Wrong size on LProduct_CanDisplayOn");
static_assert(offsetof(LProduct_CanDisplayOn, ReturnValue) == 0x000000, "Member 'LProduct_CanDisplayOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.GetProductType
// 0x0001 (0x0001 - 0x0000)
struct LProduct_GetProductType final
{
public:
	ELShopProductType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_GetProductType) == 0x000001, "Wrong alignment on LProduct_GetProductType");
static_assert(sizeof(LProduct_GetProductType) == 0x000001, "Wrong size on LProduct_GetProductType");
static_assert(offsetof(LProduct_GetProductType, ReturnValue) == 0x000000, "Member 'LProduct_GetProductType::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.IsWeapon
// 0x0001 (0x0001 - 0x0000)
struct LProduct_IsWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_IsWeapon) == 0x000001, "Wrong alignment on LProduct_IsWeapon");
static_assert(sizeof(LProduct_IsWeapon) == 0x000001, "Wrong size on LProduct_IsWeapon");
static_assert(offsetof(LProduct_IsWeapon, ReturnValue) == 0x000000, "Member 'LProduct_IsWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.Needs
// 0x0018 (0x0018 - 0x0000)
struct LProduct_Needs final
{
public:
	struct FLSpecialShopExchangeNeeds             ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_Needs) == 0x000008, "Wrong alignment on LProduct_Needs");
static_assert(sizeof(LProduct_Needs) == 0x000018, "Wrong size on LProduct_Needs");
static_assert(offsetof(LProduct_Needs, ReturnValue) == 0x000000, "Member 'LProduct_Needs::ReturnValue' has a wrong offset!");

// Function ProjectP.LProduct.OriginStockCount
// 0x0004 (0x0004 - 0x0000)
struct LProduct_OriginStockCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProduct_OriginStockCount) == 0x000004, "Wrong alignment on LProduct_OriginStockCount");
static_assert(sizeof(LProduct_OriginStockCount) == 0x000004, "Wrong size on LProduct_OriginStockCount");
static_assert(offsetof(LProduct_OriginStockCount, ReturnValue) == 0x000000, "Member 'LProduct_OriginStockCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSpecialShop.Buy
// 0x0010 (0x0010 - 0x0000)
struct LProductSpecialShop_Buy final
{
public:
	class ULProduct*                              InProduct;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProductSpecialShop_Buy) == 0x000008, "Wrong alignment on LProductSpecialShop_Buy");
static_assert(sizeof(LProductSpecialShop_Buy) == 0x000010, "Wrong size on LProductSpecialShop_Buy");
static_assert(offsetof(LProductSpecialShop_Buy, InProduct) == 0x000000, "Member 'LProductSpecialShop_Buy::InProduct' has a wrong offset!");
static_assert(offsetof(LProductSpecialShop_Buy, InCount) == 0x000008, "Member 'LProductSpecialShop_Buy::InCount' has a wrong offset!");
static_assert(offsetof(LProductSpecialShop_Buy, ReturnValue) == 0x00000C, "Member 'LProductSpecialShop_Buy::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSpecialShop.GetBuyCategorys
// 0x0050 (0x0050 - 0x0000)
struct LProductSpecialShop_GetBuyCategorys final
{
public:
	TSet<ELItemFirstCategory>                     ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProductSpecialShop_GetBuyCategorys) == 0x000008, "Wrong alignment on LProductSpecialShop_GetBuyCategorys");
static_assert(sizeof(LProductSpecialShop_GetBuyCategorys) == 0x000050, "Wrong size on LProductSpecialShop_GetBuyCategorys");
static_assert(offsetof(LProductSpecialShop_GetBuyCategorys, ReturnValue) == 0x000000, "Member 'LProductSpecialShop_GetBuyCategorys::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSpecialShop.GetBuyList
// 0x0018 (0x0018 - 0x0000)
struct LProductSpecialShop_GetBuyList final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULProduct*>                      ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProductSpecialShop_GetBuyList) == 0x000008, "Wrong alignment on LProductSpecialShop_GetBuyList");
static_assert(sizeof(LProductSpecialShop_GetBuyList) == 0x000018, "Wrong size on LProductSpecialShop_GetBuyList");
static_assert(offsetof(LProductSpecialShop_GetBuyList, Category) == 0x000000, "Member 'LProductSpecialShop_GetBuyList::Category' has a wrong offset!");
static_assert(offsetof(LProductSpecialShop_GetBuyList, ReturnValue) == 0x000008, "Member 'LProductSpecialShop_GetBuyList::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.GetHarvestRemainSec
// 0x0004 (0x0004 - 0x0000)
struct LGoldenTree_GetHarvestRemainSec final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_GetHarvestRemainSec) == 0x000004, "Wrong alignment on LGoldenTree_GetHarvestRemainSec");
static_assert(sizeof(LGoldenTree_GetHarvestRemainSec) == 0x000004, "Wrong size on LGoldenTree_GetHarvestRemainSec");
static_assert(offsetof(LGoldenTree_GetHarvestRemainSec, ReturnValue) == 0x000000, "Member 'LGoldenTree_GetHarvestRemainSec::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LGoldenTree_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGoldenTree_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LGoldenTree_OnGameDataCharacterSync");
static_assert(sizeof(LGoldenTree_OnGameDataCharacterSync) == 0x000010, "Wrong size on LGoldenTree_OnGameDataCharacterSync");
static_assert(offsetof(LGoldenTree_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LGoldenTree_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LGoldenTree_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LGoldenTree_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LGoldenTree.GetBoostExcelGoalSec
// 0x0004 (0x0004 - 0x0000)
struct LGoldenTree_GetBoostExcelGoalSec final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_GetBoostExcelGoalSec) == 0x000004, "Wrong alignment on LGoldenTree_GetBoostExcelGoalSec");
static_assert(sizeof(LGoldenTree_GetBoostExcelGoalSec) == 0x000004, "Wrong size on LGoldenTree_GetBoostExcelGoalSec");
static_assert(offsetof(LGoldenTree_GetBoostExcelGoalSec, ReturnValue) == 0x000000, "Member 'LGoldenTree_GetBoostExcelGoalSec::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.GetBoostExcelSec
// 0x0004 (0x0004 - 0x0000)
struct LGoldenTree_GetBoostExcelSec final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_GetBoostExcelSec) == 0x000004, "Wrong alignment on LGoldenTree_GetBoostExcelSec");
static_assert(sizeof(LGoldenTree_GetBoostExcelSec) == 0x000004, "Wrong size on LGoldenTree_GetBoostExcelSec");
static_assert(offsetof(LGoldenTree_GetBoostExcelSec, ReturnValue) == 0x000000, "Member 'LGoldenTree_GetBoostExcelSec::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.GetGoldStackLimit
// 0x0004 (0x0004 - 0x0000)
struct LGoldenTree_GetGoldStackLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_GetGoldStackLimit) == 0x000004, "Wrong alignment on LGoldenTree_GetGoldStackLimit");
static_assert(sizeof(LGoldenTree_GetGoldStackLimit) == 0x000004, "Wrong size on LGoldenTree_GetGoldStackLimit");
static_assert(offsetof(LGoldenTree_GetGoldStackLimit, ReturnValue) == 0x000000, "Member 'LGoldenTree_GetGoldStackLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.GetHarvestableCount
// 0x0004 (0x0004 - 0x0000)
struct LGoldenTree_GetHarvestableCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_GetHarvestableCount) == 0x000004, "Wrong alignment on LGoldenTree_GetHarvestableCount");
static_assert(sizeof(LGoldenTree_GetHarvestableCount) == 0x000004, "Wrong size on LGoldenTree_GetHarvestableCount");
static_assert(offsetof(LGoldenTree_GetHarvestableCount, ReturnValue) == 0x000000, "Member 'LGoldenTree_GetHarvestableCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.GetState
// 0x0001 (0x0001 - 0x0000)
struct LGoldenTree_GetState final
{
public:
	ELGoldenTreeState                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_GetState) == 0x000001, "Wrong alignment on LGoldenTree_GetState");
static_assert(sizeof(LGoldenTree_GetState) == 0x000001, "Wrong size on LGoldenTree_GetState");
static_assert(offsetof(LGoldenTree_GetState, ReturnValue) == 0x000000, "Member 'LGoldenTree_GetState::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.IsBoostNow
// 0x0001 (0x0001 - 0x0000)
struct LGoldenTree_IsBoostNow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_IsBoostNow) == 0x000001, "Wrong alignment on LGoldenTree_IsBoostNow");
static_assert(sizeof(LGoldenTree_IsBoostNow) == 0x000001, "Wrong size on LGoldenTree_IsBoostNow");
static_assert(offsetof(LGoldenTree_IsBoostNow, ReturnValue) == 0x000000, "Member 'LGoldenTree_IsBoostNow::ReturnValue' has a wrong offset!");

// Function ProjectP.LGoldenTree.IsPlayerReached
// 0x0001 (0x0001 - 0x0000)
struct LGoldenTree_IsPlayerReached final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGoldenTree_IsPlayerReached) == 0x000001, "Wrong alignment on LGoldenTree_IsPlayerReached");
static_assert(sizeof(LGoldenTree_IsPlayerReached) == 0x000001, "Wrong size on LGoldenTree_IsPlayerReached");
static_assert(offsetof(LGoldenTree_IsPlayerReached, ReturnValue) == 0x000000, "Member 'LGoldenTree_IsPlayerReached::ReturnValue' has a wrong offset!");

// Function ProjectP.LPropHelpMateSpot.OnUIHelpMatePopupResult
// 0x0001 (0x0001 - 0x0000)
struct LPropHelpMateSpot_OnUIHelpMatePopupResult final
{
public:
	bool                                          PopupResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropHelpMateSpot_OnUIHelpMatePopupResult) == 0x000001, "Wrong alignment on LPropHelpMateSpot_OnUIHelpMatePopupResult");
static_assert(sizeof(LPropHelpMateSpot_OnUIHelpMatePopupResult) == 0x000001, "Wrong size on LPropHelpMateSpot_OnUIHelpMatePopupResult");
static_assert(offsetof(LPropHelpMateSpot_OnUIHelpMatePopupResult, PopupResult) == 0x000000, "Member 'LPropHelpMateSpot_OnUIHelpMatePopupResult::PopupResult' has a wrong offset!");

// Function ProjectP.LProductBuyShop.Buy
// 0x0010 (0x0010 - 0x0000)
struct LProductBuyShop_Buy final
{
public:
	class ULProduct*                              InProduct;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProductBuyShop_Buy) == 0x000008, "Wrong alignment on LProductBuyShop_Buy");
static_assert(sizeof(LProductBuyShop_Buy) == 0x000010, "Wrong size on LProductBuyShop_Buy");
static_assert(offsetof(LProductBuyShop_Buy, InProduct) == 0x000000, "Member 'LProductBuyShop_Buy::InProduct' has a wrong offset!");
static_assert(offsetof(LProductBuyShop_Buy, InCount) == 0x000008, "Member 'LProductBuyShop_Buy::InCount' has a wrong offset!");
static_assert(offsetof(LProductBuyShop_Buy, ReturnValue) == 0x00000C, "Member 'LProductBuyShop_Buy::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductBuyShop.GetBuyCategorys
// 0x0050 (0x0050 - 0x0000)
struct LProductBuyShop_GetBuyCategorys final
{
public:
	TSet<ELItemFirstCategory>                     ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProductBuyShop_GetBuyCategorys) == 0x000008, "Wrong alignment on LProductBuyShop_GetBuyCategorys");
static_assert(sizeof(LProductBuyShop_GetBuyCategorys) == 0x000050, "Wrong size on LProductBuyShop_GetBuyCategorys");
static_assert(offsetof(LProductBuyShop_GetBuyCategorys, ReturnValue) == 0x000000, "Member 'LProductBuyShop_GetBuyCategorys::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductBuyShop.GetBuyList
// 0x0018 (0x0018 - 0x0000)
struct LProductBuyShop_GetBuyList final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULProduct*>                      ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProductBuyShop_GetBuyList) == 0x000008, "Wrong alignment on LProductBuyShop_GetBuyList");
static_assert(sizeof(LProductBuyShop_GetBuyList) == 0x000018, "Wrong size on LProductBuyShop_GetBuyList");
static_assert(offsetof(LProductBuyShop_GetBuyList, Category) == 0x000000, "Member 'LProductBuyShop_GetBuyList::Category' has a wrong offset!");
static_assert(offsetof(LProductBuyShop_GetBuyList, ReturnValue) == 0x000008, "Member 'LProductBuyShop_GetBuyList::ReturnValue' has a wrong offset!");

// Function ProjectP.LTalker.GetCodeName
// 0x0008 (0x0008 - 0x0000)
struct LTalker_GetCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTalker_GetCodeName) == 0x000004, "Wrong alignment on LTalker_GetCodeName");
static_assert(sizeof(LTalker_GetCodeName) == 0x000008, "Wrong size on LTalker_GetCodeName");
static_assert(offsetof(LTalker_GetCodeName, ReturnValue) == 0x000000, "Member 'LTalker_GetCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LTileView.GetScrollOffset
// 0x0004 (0x0004 - 0x0000)
struct LTileView_GetScrollOffset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTileView_GetScrollOffset) == 0x000004, "Wrong alignment on LTileView_GetScrollOffset");
static_assert(sizeof(LTileView_GetScrollOffset) == 0x000004, "Wrong size on LTileView_GetScrollOffset");
static_assert(offsetof(LTileView_GetScrollOffset, ReturnValue) == 0x000000, "Member 'LTileView_GetScrollOffset::ReturnValue' has a wrong offset!");

// Function ProjectP.LTutorialSystem.EndTutorialUI
// 0x0008 (0x0008 - 0x0000)
struct LTutorialSystem_EndTutorialUI final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_EndTutorialUI) == 0x000004, "Wrong alignment on LTutorialSystem_EndTutorialUI");
static_assert(sizeof(LTutorialSystem_EndTutorialUI) == 0x000008, "Wrong size on LTutorialSystem_EndTutorialUI");
static_assert(offsetof(LTutorialSystem_EndTutorialUI, TutorialCodeName) == 0x000000, "Member 'LTutorialSystem_EndTutorialUI::TutorialCodeName' has a wrong offset!");

// Function ProjectP.LTutorialSystem.ExecuteTutorial
// 0x000C (0x000C - 0x0000)
struct LTutorialSystem_ExecuteTutorial final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PriorityPendingData;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LTutorialSystem_ExecuteTutorial) == 0x000004, "Wrong alignment on LTutorialSystem_ExecuteTutorial");
static_assert(sizeof(LTutorialSystem_ExecuteTutorial) == 0x00000C, "Wrong size on LTutorialSystem_ExecuteTutorial");
static_assert(offsetof(LTutorialSystem_ExecuteTutorial, TutorialCodeName) == 0x000000, "Member 'LTutorialSystem_ExecuteTutorial::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_ExecuteTutorial, PriorityPendingData) == 0x000008, "Member 'LTutorialSystem_ExecuteTutorial::PriorityPendingData' has a wrong offset!");

// Function ProjectP.LTutorialSystem.GetCurrentTutorialList
// 0x0010 (0x0010 - 0x0000)
struct LTutorialSystem_GetCurrentTutorialList final
{
public:
	TArray<class FName>                           OutTutorialList;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_GetCurrentTutorialList) == 0x000008, "Wrong alignment on LTutorialSystem_GetCurrentTutorialList");
static_assert(sizeof(LTutorialSystem_GetCurrentTutorialList) == 0x000010, "Wrong size on LTutorialSystem_GetCurrentTutorialList");
static_assert(offsetof(LTutorialSystem_GetCurrentTutorialList, OutTutorialList) == 0x000000, "Member 'LTutorialSystem_GetCurrentTutorialList::OutTutorialList' has a wrong offset!");

// Function ProjectP.LTutorialSystem.GetDescriptionText
// 0x0028 (0x0028 - 0x0000)
struct LTutorialSystem_GetDescriptionText final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepNum;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_GetDescriptionText) == 0x000008, "Wrong alignment on LTutorialSystem_GetDescriptionText");
static_assert(sizeof(LTutorialSystem_GetDescriptionText) == 0x000028, "Wrong size on LTutorialSystem_GetDescriptionText");
static_assert(offsetof(LTutorialSystem_GetDescriptionText, TutorialCodeName) == 0x000000, "Member 'LTutorialSystem_GetDescriptionText::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetDescriptionText, StepNum) == 0x000008, "Member 'LTutorialSystem_GetDescriptionText::StepNum' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetDescriptionText, ReturnValue) == 0x000010, "Member 'LTutorialSystem_GetDescriptionText::ReturnValue' has a wrong offset!");

// Function ProjectP.LTutorialSystem.GetTitleText
// 0x0028 (0x0028 - 0x0000)
struct LTutorialSystem_GetTitleText final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepNum;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_GetTitleText) == 0x000008, "Wrong alignment on LTutorialSystem_GetTitleText");
static_assert(sizeof(LTutorialSystem_GetTitleText) == 0x000028, "Wrong size on LTutorialSystem_GetTitleText");
static_assert(offsetof(LTutorialSystem_GetTitleText, TutorialCodeName) == 0x000000, "Member 'LTutorialSystem_GetTitleText::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetTitleText, StepNum) == 0x000008, "Member 'LTutorialSystem_GetTitleText::StepNum' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetTitleText, ReturnValue) == 0x000010, "Member 'LTutorialSystem_GetTitleText::ReturnValue' has a wrong offset!");

// Function ProjectP.LTutorialSystem.GetTutorialMaxStep
// 0x000C (0x000C - 0x0000)
struct LTutorialSystem_GetTutorialMaxStep final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_GetTutorialMaxStep) == 0x000004, "Wrong alignment on LTutorialSystem_GetTutorialMaxStep");
static_assert(sizeof(LTutorialSystem_GetTutorialMaxStep) == 0x00000C, "Wrong size on LTutorialSystem_GetTutorialMaxStep");
static_assert(offsetof(LTutorialSystem_GetTutorialMaxStep, TutorialCodeName) == 0x000000, "Member 'LTutorialSystem_GetTutorialMaxStep::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetTutorialMaxStep, ReturnValue) == 0x000008, "Member 'LTutorialSystem_GetTutorialMaxStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LTutorialSystem.GetWindowTutorialCodeName
// 0x0008 (0x0008 - 0x0000)
struct LTutorialSystem_GetWindowTutorialCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_GetWindowTutorialCodeName) == 0x000004, "Wrong alignment on LTutorialSystem_GetWindowTutorialCodeName");
static_assert(sizeof(LTutorialSystem_GetWindowTutorialCodeName) == 0x000008, "Wrong size on LTutorialSystem_GetWindowTutorialCodeName");
static_assert(offsetof(LTutorialSystem_GetWindowTutorialCodeName, ReturnValue) == 0x000000, "Member 'LTutorialSystem_GetWindowTutorialCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LTutorialSystem.GetTutorialDB_TutorialInfo
// 0x0018 (0x0018 - 0x0000)
struct LTutorialSystem_GetTutorialDB_TutorialInfo final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TutorialStep;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTutorialInfoPtr                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTutorialSystem_GetTutorialDB_TutorialInfo) == 0x000008, "Wrong alignment on LTutorialSystem_GetTutorialDB_TutorialInfo");
static_assert(sizeof(LTutorialSystem_GetTutorialDB_TutorialInfo) == 0x000018, "Wrong size on LTutorialSystem_GetTutorialDB_TutorialInfo");
static_assert(offsetof(LTutorialSystem_GetTutorialDB_TutorialInfo, TutorialCodeName) == 0x000000, "Member 'LTutorialSystem_GetTutorialDB_TutorialInfo::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetTutorialDB_TutorialInfo, TutorialStep) == 0x000008, "Member 'LTutorialSystem_GetTutorialDB_TutorialInfo::TutorialStep' has a wrong offset!");
static_assert(offsetof(LTutorialSystem_GetTutorialDB_TutorialInfo, ReturnValue) == 0x000010, "Member 'LTutorialSystem_GetTutorialDB_TutorialInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmTree.ActivateTreeFromUI
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmTree_ActivateTreeFromUI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmTree_ActivateTreeFromUI) == 0x000001, "Wrong alignment on LSlaveArmTree_ActivateTreeFromUI");
static_assert(sizeof(LSlaveArmTree_ActivateTreeFromUI) == 0x000001, "Wrong size on LSlaveArmTree_ActivateTreeFromUI");
static_assert(offsetof(LSlaveArmTree_ActivateTreeFromUI, ReturnValue) == 0x000000, "Member 'LSlaveArmTree_ActivateTreeFromUI::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmTree.SetActivate
// 0x0002 (0x0002 - 0x0000)
struct LSlaveArmTree_SetActivate final
{
public:
	bool                                          bNewActivate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedCalcPlayerStat;                               // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmTree_SetActivate) == 0x000001, "Wrong alignment on LSlaveArmTree_SetActivate");
static_assert(sizeof(LSlaveArmTree_SetActivate) == 0x000002, "Wrong size on LSlaveArmTree_SetActivate");
static_assert(offsetof(LSlaveArmTree_SetActivate, bNewActivate) == 0x000000, "Member 'LSlaveArmTree_SetActivate::bNewActivate' has a wrong offset!");
static_assert(offsetof(LSlaveArmTree_SetActivate, bNeedCalcPlayerStat) == 0x000001, "Member 'LSlaveArmTree_SetActivate::bNeedCalcPlayerStat' has a wrong offset!");

// Function ProjectP.LSoundControlComponent.OnBossRoomDestroyed
// 0x0010 (0x0010 - 0x0000)
struct LSoundControlComponent_OnBossRoomDestroyed final
{
public:
	class FString                                 BossRoomUniqueId;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundControlComponent_OnBossRoomDestroyed) == 0x000008, "Wrong alignment on LSoundControlComponent_OnBossRoomDestroyed");
static_assert(sizeof(LSoundControlComponent_OnBossRoomDestroyed) == 0x000010, "Wrong size on LSoundControlComponent_OnBossRoomDestroyed");
static_assert(offsetof(LSoundControlComponent_OnBossRoomDestroyed, BossRoomUniqueId) == 0x000000, "Member 'LSoundControlComponent_OnBossRoomDestroyed::BossRoomUniqueId' has a wrong offset!");

// Function ProjectP.LSoundControlComponent.OnGlobalVariableChanged
// 0x000C (0x000C - 0x0000)
struct LSoundControlComponent_OnGlobalVariableChanged final
{
public:
	class FName                                   InGlobalVariable;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundControlComponent_OnGlobalVariableChanged) == 0x000004, "Wrong alignment on LSoundControlComponent_OnGlobalVariableChanged");
static_assert(sizeof(LSoundControlComponent_OnGlobalVariableChanged) == 0x00000C, "Wrong size on LSoundControlComponent_OnGlobalVariableChanged");
static_assert(offsetof(LSoundControlComponent_OnGlobalVariableChanged, InGlobalVariable) == 0x000000, "Member 'LSoundControlComponent_OnGlobalVariableChanged::InGlobalVariable' has a wrong offset!");
static_assert(offsetof(LSoundControlComponent_OnGlobalVariableChanged, InValue) == 0x000008, "Member 'LSoundControlComponent_OnGlobalVariableChanged::InValue' has a wrong offset!");

// Function ProjectP.LSoundControlComponent.OnNpcDead
// 0x0010 (0x0010 - 0x0000)
struct LSoundControlComponent_OnNpcDead final
{
public:
	class FString                                 NpcSpotUniqueID;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundControlComponent_OnNpcDead) == 0x000008, "Wrong alignment on LSoundControlComponent_OnNpcDead");
static_assert(sizeof(LSoundControlComponent_OnNpcDead) == 0x000010, "Wrong size on LSoundControlComponent_OnNpcDead");
static_assert(offsetof(LSoundControlComponent_OnNpcDead, NpcSpotUniqueID) == 0x000000, "Member 'LSoundControlComponent_OnNpcDead::NpcSpotUniqueID' has a wrong offset!");

// Function ProjectP.LSoundControlComponent.OnPlayStateChanged
// 0x0001 (0x0001 - 0x0000)
struct LSoundControlComponent_OnPlayStateChanged final
{
public:
	EAudioComponentPlayState                      PlayState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundControlComponent_OnPlayStateChanged) == 0x000001, "Wrong alignment on LSoundControlComponent_OnPlayStateChanged");
static_assert(sizeof(LSoundControlComponent_OnPlayStateChanged) == 0x000001, "Wrong size on LSoundControlComponent_OnPlayStateChanged");
static_assert(offsetof(LSoundControlComponent_OnPlayStateChanged, PlayState) == 0x000000, "Member 'LSoundControlComponent_OnPlayStateChanged::PlayState' has a wrong offset!");

// Function ProjectP.LSoundControlComponent.OnWeatherChanged
// 0x0008 (0x0008 - 0x0000)
struct LSoundControlComponent_OnWeatherChanged final
{
public:
	class FName                                   InWeatherCodeName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundControlComponent_OnWeatherChanged) == 0x000004, "Wrong alignment on LSoundControlComponent_OnWeatherChanged");
static_assert(sizeof(LSoundControlComponent_OnWeatherChanged) == 0x000008, "Wrong size on LSoundControlComponent_OnWeatherChanged");
static_assert(offsetof(LSoundControlComponent_OnWeatherChanged, InWeatherCodeName) == 0x000000, "Member 'LSoundControlComponent_OnWeatherChanged::InWeatherCodeName' has a wrong offset!");

// Function ProjectP.LProjectileDesign.CheckCustomOverlapDestroyCondition
// 0x0010 (0x0010 - 0x0000)
struct LProjectileDesign_CheckCustomOverlapDestroyCondition final
{
public:
	class AActor*                                 OverlappedActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectileDesign_CheckCustomOverlapDestroyCondition) == 0x000008, "Wrong alignment on LProjectileDesign_CheckCustomOverlapDestroyCondition");
static_assert(sizeof(LProjectileDesign_CheckCustomOverlapDestroyCondition) == 0x000010, "Wrong size on LProjectileDesign_CheckCustomOverlapDestroyCondition");
static_assert(offsetof(LProjectileDesign_CheckCustomOverlapDestroyCondition, OverlappedActor) == 0x000000, "Member 'LProjectileDesign_CheckCustomOverlapDestroyCondition::OverlappedActor' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_CheckCustomOverlapDestroyCondition, ReturnValue) == 0x000008, "Member 'LProjectileDesign_CheckCustomOverlapDestroyCondition::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileDesign.CheckUseSubstituteSkillHit
// 0x0120 (0x0120 - 0x0000)
struct LProjectileDesign_CheckUseSubstituteSkillHit final
{
public:
	struct FLProjectileHitInfo                    ProjectileHitInfo;                                 // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0090(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0118(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_CheckUseSubstituteSkillHit) == 0x000010, "Wrong alignment on LProjectileDesign_CheckUseSubstituteSkillHit");
static_assert(sizeof(LProjectileDesign_CheckUseSubstituteSkillHit) == 0x000120, "Wrong size on LProjectileDesign_CheckUseSubstituteSkillHit");
static_assert(offsetof(LProjectileDesign_CheckUseSubstituteSkillHit, ProjectileHitInfo) == 0x000000, "Member 'LProjectileDesign_CheckUseSubstituteSkillHit::ProjectileHitInfo' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_CheckUseSubstituteSkillHit, HitResult) == 0x000090, "Member 'LProjectileDesign_CheckUseSubstituteSkillHit::HitResult' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_CheckUseSubstituteSkillHit, ReturnValue) == 0x000118, "Member 'LProjectileDesign_CheckUseSubstituteSkillHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileDesign.GetProjectile
// 0x0008 (0x0008 - 0x0000)
struct LProjectileDesign_GetProjectile final
{
public:
	class ALProjectile*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_GetProjectile) == 0x000008, "Wrong alignment on LProjectileDesign_GetProjectile");
static_assert(sizeof(LProjectileDesign_GetProjectile) == 0x000008, "Wrong size on LProjectileDesign_GetProjectile");
static_assert(offsetof(LProjectileDesign_GetProjectile, ReturnValue) == 0x000000, "Member 'LProjectileDesign_GetProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileDesign.OnAttakedByOther
// 0x0010 (0x0010 - 0x0000)
struct LProjectileDesign_OnAttakedByOther final
{
public:
	class AActor*                                 Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_OnAttakedByOther) == 0x000008, "Wrong alignment on LProjectileDesign_OnAttakedByOther");
static_assert(sizeof(LProjectileDesign_OnAttakedByOther) == 0x000010, "Wrong size on LProjectileDesign_OnAttakedByOther");
static_assert(offsetof(LProjectileDesign_OnAttakedByOther, Other) == 0x000000, "Member 'LProjectileDesign_OnAttakedByOther::Other' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_OnAttakedByOther, SkillHitCodeName) == 0x000008, "Member 'LProjectileDesign_OnAttakedByOther::SkillHitCodeName' has a wrong offset!");

// Function ProjectP.LProjectileDesign.OnDisappear
// 0x008C (0x008C - 0x0000)
struct LProjectileDesign_OnDisappear final
{
public:
	ELProjectileDestroyReason                     Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0004(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_OnDisappear) == 0x000004, "Wrong alignment on LProjectileDesign_OnDisappear");
static_assert(sizeof(LProjectileDesign_OnDisappear) == 0x00008C, "Wrong size on LProjectileDesign_OnDisappear");
static_assert(offsetof(LProjectileDesign_OnDisappear, Reason) == 0x000000, "Member 'LProjectileDesign_OnDisappear::Reason' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_OnDisappear, HitResult) == 0x000004, "Member 'LProjectileDesign_OnDisappear::HitResult' has a wrong offset!");

// Function ProjectP.LProjectileDesign.OnExplode
// 0x008C (0x008C - 0x0000)
struct LProjectileDesign_OnExplode final
{
public:
	ELProjectileDestroyReason                     Reason;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0004(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_OnExplode) == 0x000004, "Wrong alignment on LProjectileDesign_OnExplode");
static_assert(sizeof(LProjectileDesign_OnExplode) == 0x00008C, "Wrong size on LProjectileDesign_OnExplode");
static_assert(offsetof(LProjectileDesign_OnExplode, Reason) == 0x000000, "Member 'LProjectileDesign_OnExplode::Reason' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_OnExplode, HitResult) == 0x000004, "Member 'LProjectileDesign_OnExplode::HitResult' has a wrong offset!");

// Function ProjectP.LProjectileDesign.OnSpawnChildren
// 0x0008 (0x0008 - 0x0000)
struct LProjectileDesign_OnSpawnChildren final
{
public:
	class ALProjectile*                           ChildProjectile;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_OnSpawnChildren) == 0x000008, "Wrong alignment on LProjectileDesign_OnSpawnChildren");
static_assert(sizeof(LProjectileDesign_OnSpawnChildren) == 0x000008, "Wrong size on LProjectileDesign_OnSpawnChildren");
static_assert(offsetof(LProjectileDesign_OnSpawnChildren, ChildProjectile) == 0x000000, "Member 'LProjectileDesign_OnSpawnChildren::ChildProjectile' has a wrong offset!");

// Function ProjectP.LProjectileDesign.Pause
// 0x0001 (0x0001 - 0x0000)
struct LProjectileDesign_Pause final
{
public:
	bool                                          bPauseFlag;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_Pause) == 0x000001, "Wrong alignment on LProjectileDesign_Pause");
static_assert(sizeof(LProjectileDesign_Pause) == 0x000001, "Wrong size on LProjectileDesign_Pause");
static_assert(offsetof(LProjectileDesign_Pause, bPauseFlag) == 0x000000, "Member 'LProjectileDesign_Pause::bPauseFlag' has a wrong offset!");

// Function ProjectP.LProjectileDesign.RefineHitTarget
// 0x0020 (0x0020 - 0x0000)
struct LProjectileDesign_RefineHitTarget final
{
public:
	TArray<struct FHitResult>                     InHitResults;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileDesign_RefineHitTarget) == 0x000008, "Wrong alignment on LProjectileDesign_RefineHitTarget");
static_assert(sizeof(LProjectileDesign_RefineHitTarget) == 0x000020, "Wrong size on LProjectileDesign_RefineHitTarget");
static_assert(offsetof(LProjectileDesign_RefineHitTarget, InHitResults) == 0x000000, "Member 'LProjectileDesign_RefineHitTarget::InHitResults' has a wrong offset!");
static_assert(offsetof(LProjectileDesign_RefineHitTarget, ReturnValue) == 0x000010, "Member 'LProjectileDesign_RefineHitTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuff.GetOwner
// 0x0008 (0x0008 - 0x0000)
struct LSpecialBuff_GetOwner final
{
public:
	class ALCharacter*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuff_GetOwner) == 0x000008, "Wrong alignment on LSpecialBuff_GetOwner");
static_assert(sizeof(LSpecialBuff_GetOwner) == 0x000008, "Wrong size on LSpecialBuff_GetOwner");
static_assert(offsetof(LSpecialBuff_GetOwner, ReturnValue) == 0x000000, "Member 'LSpecialBuff_GetOwner::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuff.Tick
// 0x0004 (0x0004 - 0x0000)
struct LSpecialBuff_Tick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuff_Tick) == 0x000004, "Wrong alignment on LSpecialBuff_Tick");
static_assert(sizeof(LSpecialBuff_Tick) == 0x000004, "Wrong size on LSpecialBuff_Tick");
static_assert(offsetof(LSpecialBuff_Tick, DeltaTime) == 0x000000, "Member 'LSpecialBuff_Tick::DeltaTime' has a wrong offset!");

// Function ProjectP.LStargazerObject.SetStargazerType
// 0x0001 (0x0001 - 0x0000)
struct LStargazerObject_SetStargazerType final
{
public:
	ELStargazerType                               StateData;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStargazerObject_SetStargazerType) == 0x000001, "Wrong alignment on LStargazerObject_SetStargazerType");
static_assert(sizeof(LStargazerObject_SetStargazerType) == 0x000001, "Wrong size on LStargazerObject_SetStargazerType");
static_assert(offsetof(LStargazerObject_SetStargazerType, StateData) == 0x000000, "Member 'LStargazerObject_SetStargazerType::StateData' has a wrong offset!");

// Function ProjectP.LStargazerObject.SetStargazerUnstable
// 0x0001 (0x0001 - 0x0000)
struct LStargazerObject_SetStargazerUnstable final
{
public:
	bool                                          Unstable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStargazerObject_SetStargazerUnstable) == 0x000001, "Wrong alignment on LStargazerObject_SetStargazerUnstable");
static_assert(sizeof(LStargazerObject_SetStargazerUnstable) == 0x000001, "Wrong size on LStargazerObject_SetStargazerUnstable");
static_assert(offsetof(LStargazerObject_SetStargazerUnstable, Unstable) == 0x000000, "Member 'LStargazerObject_SetStargazerUnstable::Unstable' has a wrong offset!");

// Function ProjectP.LStargazerObject.UpdateDilationTime
// 0x0008 (0x0008 - 0x0000)
struct LStargazerObject_UpdateDilationTime final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DilationScale;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStargazerObject_UpdateDilationTime) == 0x000004, "Wrong alignment on LStargazerObject_UpdateDilationTime");
static_assert(sizeof(LStargazerObject_UpdateDilationTime) == 0x000008, "Wrong size on LStargazerObject_UpdateDilationTime");
static_assert(offsetof(LStargazerObject_UpdateDilationTime, DeltaTime) == 0x000000, "Member 'LStargazerObject_UpdateDilationTime::DeltaTime' has a wrong offset!");
static_assert(offsetof(LStargazerObject_UpdateDilationTime, DilationScale) == 0x000004, "Member 'LStargazerObject_UpdateDilationTime::DilationScale' has a wrong offset!");

// Function ProjectP.LMonologControl.GetScriptText
// 0x0018 (0x0018 - 0x0000)
struct LMonologControl_GetScriptText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMonologControl_GetScriptText) == 0x000008, "Wrong alignment on LMonologControl_GetScriptText");
static_assert(sizeof(LMonologControl_GetScriptText) == 0x000018, "Wrong size on LMonologControl_GetScriptText");
static_assert(offsetof(LMonologControl_GetScriptText, ReturnValue) == 0x000000, "Member 'LMonologControl_GetScriptText::ReturnValue' has a wrong offset!");

// Function ProjectP.LMonologControl.IsValid
// 0x0001 (0x0001 - 0x0000)
struct LMonologControl_IsValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMonologControl_IsValid) == 0x000001, "Wrong alignment on LMonologControl_IsValid");
static_assert(sizeof(LMonologControl_IsValid) == 0x000001, "Wrong size on LMonologControl_IsValid");
static_assert(offsetof(LMonologControl_IsValid, ReturnValue) == 0x000000, "Member 'LMonologControl_IsValid::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.CanKeep
// 0x0001 (0x0001 - 0x0000)
struct LItem_CanKeep final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_CanKeep) == 0x000001, "Wrong alignment on LItem_CanKeep");
static_assert(sizeof(LItem_CanKeep) == 0x000001, "Wrong size on LItem_CanKeep");
static_assert(offsetof(LItem_CanKeep, ReturnValue) == 0x000000, "Member 'LItem_CanKeep::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.ChangeCorrection
// 0x0002 (0x0002 - 0x0000)
struct LItem_ChangeCorrection final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_ChangeCorrection) == 0x000001, "Wrong alignment on LItem_ChangeCorrection");
static_assert(sizeof(LItem_ChangeCorrection) == 0x000002, "Wrong size on LItem_ChangeCorrection");
static_assert(offsetof(LItem_ChangeCorrection, Type) == 0x000000, "Member 'LItem_ChangeCorrection::Type' has a wrong offset!");
static_assert(offsetof(LItem_ChangeCorrection, ReturnValue) == 0x000001, "Member 'LItem_ChangeCorrection::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetAssistUseSlotType
// 0x0001 (0x0001 - 0x0000)
struct LItem_GetAssistUseSlotType final
{
public:
	ELAssistUseItemSlotType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetAssistUseSlotType) == 0x000001, "Wrong alignment on LItem_GetAssistUseSlotType");
static_assert(sizeof(LItem_GetAssistUseSlotType) == 0x000001, "Wrong size on LItem_GetAssistUseSlotType");
static_assert(offsetof(LItem_GetAssistUseSlotType, ReturnValue) == 0x000000, "Member 'LItem_GetAssistUseSlotType::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetEquipSlotType
// 0x0001 (0x0001 - 0x0000)
struct LItem_GetEquipSlotType final
{
public:
	ELEquipSlotType                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetEquipSlotType) == 0x000001, "Wrong alignment on LItem_GetEquipSlotType");
static_assert(sizeof(LItem_GetEquipSlotType) == 0x000001, "Wrong size on LItem_GetEquipSlotType");
static_assert(offsetof(LItem_GetEquipSlotType, ReturnValue) == 0x000000, "Member 'LItem_GetEquipSlotType::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetMaxStackCount
// 0x0004 (0x0004 - 0x0000)
struct LItem_GetMaxStackCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetMaxStackCount) == 0x000004, "Wrong alignment on LItem_GetMaxStackCount");
static_assert(sizeof(LItem_GetMaxStackCount) == 0x000004, "Wrong size on LItem_GetMaxStackCount");
static_assert(offsetof(LItem_GetMaxStackCount, ReturnValue) == 0x000000, "Member 'LItem_GetMaxStackCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetRawSlaveArmStat
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetRawSlaveArmStat final
{
public:
	ELSecondStat                                  InStat;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetRawSlaveArmStat) == 0x000004, "Wrong alignment on LItem_GetRawSlaveArmStat");
static_assert(sizeof(LItem_GetRawSlaveArmStat) == 0x000008, "Wrong size on LItem_GetRawSlaveArmStat");
static_assert(offsetof(LItem_GetRawSlaveArmStat, InStat) == 0x000000, "Member 'LItem_GetRawSlaveArmStat::InStat' has a wrong offset!");
static_assert(offsetof(LItem_GetRawSlaveArmStat, ReturnValue) == 0x000004, "Member 'LItem_GetRawSlaveArmStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetSlavearmAlteredItem
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetSlavearmAlteredItem final
{
public:
	class ULItem*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetSlavearmAlteredItem) == 0x000008, "Wrong alignment on LItem_GetSlavearmAlteredItem");
static_assert(sizeof(LItem_GetSlavearmAlteredItem) == 0x000008, "Wrong size on LItem_GetSlavearmAlteredItem");
static_assert(offsetof(LItem_GetSlavearmAlteredItem, ReturnValue) == 0x000000, "Member 'LItem_GetSlavearmAlteredItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetSlaveArmStat
// 0x0010 (0x0010 - 0x0000)
struct LItem_GetSlaveArmStat final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVirtual;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetSlaveArmStat) == 0x000008, "Wrong alignment on LItem_GetSlaveArmStat");
static_assert(sizeof(LItem_GetSlaveArmStat) == 0x000010, "Wrong size on LItem_GetSlaveArmStat");
static_assert(offsetof(LItem_GetSlaveArmStat, InOwner) == 0x000000, "Member 'LItem_GetSlaveArmStat::InOwner' has a wrong offset!");
static_assert(offsetof(LItem_GetSlaveArmStat, InStat) == 0x000008, "Member 'LItem_GetSlaveArmStat::InStat' has a wrong offset!");
static_assert(offsetof(LItem_GetSlaveArmStat, IsVirtual) == 0x000009, "Member 'LItem_GetSlaveArmStat::IsVirtual' has a wrong offset!");
static_assert(offsetof(LItem_GetSlaveArmStat, ReturnValue) == 0x00000C, "Member 'LItem_GetSlaveArmStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetSlaveArmStatBonus
// 0x0010 (0x0010 - 0x0000)
struct LItem_GetSlaveArmStatBonus final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVirtual;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetSlaveArmStatBonus) == 0x000008, "Wrong alignment on LItem_GetSlaveArmStatBonus");
static_assert(sizeof(LItem_GetSlaveArmStatBonus) == 0x000010, "Wrong size on LItem_GetSlaveArmStatBonus");
static_assert(offsetof(LItem_GetSlaveArmStatBonus, InOwner) == 0x000000, "Member 'LItem_GetSlaveArmStatBonus::InOwner' has a wrong offset!");
static_assert(offsetof(LItem_GetSlaveArmStatBonus, InStat) == 0x000008, "Member 'LItem_GetSlaveArmStatBonus::InStat' has a wrong offset!");
static_assert(offsetof(LItem_GetSlaveArmStatBonus, IsVirtual) == 0x000009, "Member 'LItem_GetSlaveArmStatBonus::IsVirtual' has a wrong offset!");
static_assert(offsetof(LItem_GetSlaveArmStatBonus, ReturnValue) == 0x00000C, "Member 'LItem_GetSlaveArmStatBonus::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetUseSlotIndex
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetUseSlotIndex final
{
public:
	bool                                          FirstLine;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetUseSlotIndex) == 0x000004, "Wrong alignment on LItem_GetUseSlotIndex");
static_assert(sizeof(LItem_GetUseSlotIndex) == 0x000008, "Wrong size on LItem_GetUseSlotIndex");
static_assert(offsetof(LItem_GetUseSlotIndex, FirstLine) == 0x000000, "Member 'LItem_GetUseSlotIndex::FirstLine' has a wrong offset!");
static_assert(offsetof(LItem_GetUseSlotIndex, ReturnValue) == 0x000004, "Member 'LItem_GetUseSlotIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsEquipped
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsEquipped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsEquipped) == 0x000001, "Wrong alignment on LItem_IsEquipped");
static_assert(sizeof(LItem_IsEquipped) == 0x000001, "Wrong size on LItem_IsEquipped");
static_assert(offsetof(LItem_IsEquipped, ReturnValue) == 0x000000, "Member 'LItem_IsEquipped::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsEquippedAssistUseItem
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsEquippedAssistUseItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsEquippedAssistUseItem) == 0x000001, "Wrong alignment on LItem_IsEquippedAssistUseItem");
static_assert(sizeof(LItem_IsEquippedAssistUseItem) == 0x000001, "Wrong size on LItem_IsEquippedAssistUseItem");
static_assert(offsetof(LItem_IsEquippedAssistUseItem, ReturnValue) == 0x000000, "Member 'LItem_IsEquippedAssistUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsEquippedUseItem
// 0x0002 (0x0002 - 0x0000)
struct LItem_IsEquippedUseItem final
{
public:
	bool                                          OutIsFirstLine;                                    // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsEquippedUseItem) == 0x000001, "Wrong alignment on LItem_IsEquippedUseItem");
static_assert(sizeof(LItem_IsEquippedUseItem) == 0x000002, "Wrong size on LItem_IsEquippedUseItem");
static_assert(offsetof(LItem_IsEquippedUseItem, OutIsFirstLine) == 0x000000, "Member 'LItem_IsEquippedUseItem::OutIsFirstLine' has a wrong offset!");
static_assert(offsetof(LItem_IsEquippedUseItem, ReturnValue) == 0x000001, "Member 'LItem_IsEquippedUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.Reinforce
// 0x0001 (0x0001 - 0x0000)
struct LItem_Reinforce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_Reinforce) == 0x000001, "Wrong alignment on LItem_Reinforce");
static_assert(sizeof(LItem_Reinforce) == 0x000001, "Wrong size on LItem_Reinforce");
static_assert(offsetof(LItem_Reinforce, ReturnValue) == 0x000000, "Member 'LItem_Reinforce::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.SetComplexItem_UseMainInstead
// 0x0001 (0x0001 - 0x0000)
struct LItem_SetComplexItem_UseMainInstead final
{
public:
	bool                                          UseMainInstead;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_SetComplexItem_UseMainInstead) == 0x000001, "Wrong alignment on LItem_SetComplexItem_UseMainInstead");
static_assert(sizeof(LItem_SetComplexItem_UseMainInstead) == 0x000001, "Wrong size on LItem_SetComplexItem_UseMainInstead");
static_assert(offsetof(LItem_SetComplexItem_UseMainInstead, UseMainInstead) == 0x000000, "Member 'LItem_SetComplexItem_UseMainInstead::UseMainInstead' has a wrong offset!");

// Function ProjectP.LItem.SetCount
// 0x0004 (0x0004 - 0x0000)
struct LItem_SetCount final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_SetCount) == 0x000004, "Wrong alignment on LItem_SetCount");
static_assert(sizeof(LItem_SetCount) == 0x000004, "Wrong size on LItem_SetCount");
static_assert(offsetof(LItem_SetCount, Count) == 0x000000, "Member 'LItem_SetCount::Count' has a wrong offset!");

// Function ProjectP.LItem.SetSlavearmAlteredItem
// 0x0008 (0x0008 - 0x0000)
struct LItem_SetSlavearmAlteredItem final
{
public:
	class ULItem*                                 InAlteredItem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_SetSlavearmAlteredItem) == 0x000008, "Wrong alignment on LItem_SetSlavearmAlteredItem");
static_assert(sizeof(LItem_SetSlavearmAlteredItem) == 0x000008, "Wrong size on LItem_SetSlavearmAlteredItem");
static_assert(offsetof(LItem_SetSlavearmAlteredItem, InAlteredItem) == 0x000000, "Member 'LItem_SetSlavearmAlteredItem::InAlteredItem' has a wrong offset!");

// Function ProjectP.LItem.CanChangeCorrection
// 0x0002 (0x0002 - 0x0000)
struct LItem_CanChangeCorrection final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_CanChangeCorrection) == 0x000001, "Wrong alignment on LItem_CanChangeCorrection");
static_assert(sizeof(LItem_CanChangeCorrection) == 0x000002, "Wrong size on LItem_CanChangeCorrection");
static_assert(offsetof(LItem_CanChangeCorrection, Type) == 0x000000, "Member 'LItem_CanChangeCorrection::Type' has a wrong offset!");
static_assert(offsetof(LItem_CanChangeCorrection, ReturnValue) == 0x000001, "Member 'LItem_CanChangeCorrection::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.CanCombineBlade
// 0x0002 (0x0002 - 0x0000)
struct LItem_CanCombineBlade final
{
public:
	ELBladeShapeType                              BladeShapeType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_CanCombineBlade) == 0x000001, "Wrong alignment on LItem_CanCombineBlade");
static_assert(sizeof(LItem_CanCombineBlade) == 0x000002, "Wrong size on LItem_CanCombineBlade");
static_assert(offsetof(LItem_CanCombineBlade, BladeShapeType) == 0x000000, "Member 'LItem_CanCombineBlade::BladeShapeType' has a wrong offset!");
static_assert(offsetof(LItem_CanCombineBlade, ReturnValue) == 0x000001, "Member 'LItem_CanCombineBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.CanReinforce
// 0x0001 (0x0001 - 0x0000)
struct LItem_CanReinforce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_CanReinforce) == 0x000001, "Wrong alignment on LItem_CanReinforce");
static_assert(sizeof(LItem_CanReinforce) == 0x000001, "Wrong size on LItem_CanReinforce");
static_assert(offsetof(LItem_CanReinforce, ReturnValue) == 0x000000, "Member 'LItem_CanReinforce::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.CanStackCount
// 0x0001 (0x0001 - 0x0000)
struct LItem_CanStackCount final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_CanStackCount) == 0x000001, "Wrong alignment on LItem_CanStackCount");
static_assert(sizeof(LItem_CanStackCount) == 0x000001, "Wrong size on LItem_CanStackCount");
static_assert(offsetof(LItem_CanStackCount, ReturnValue) == 0x000000, "Member 'LItem_CanStackCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetChangeCorrectionInfo
// 0x0010 (0x0010 - 0x0000)
struct LItem_GetChangeCorrectionInfo final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHandleStatCorrectionChangeInfoPtr     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetChangeCorrectionInfo) == 0x000008, "Wrong alignment on LItem_GetChangeCorrectionInfo");
static_assert(sizeof(LItem_GetChangeCorrectionInfo) == 0x000010, "Wrong size on LItem_GetChangeCorrectionInfo");
static_assert(offsetof(LItem_GetChangeCorrectionInfo, Type) == 0x000000, "Member 'LItem_GetChangeCorrectionInfo::Type' has a wrong offset!");
static_assert(offsetof(LItem_GetChangeCorrectionInfo, ReturnValue) == 0x000008, "Member 'LItem_GetChangeCorrectionInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetChangedCorrectionType
// 0x0001 (0x0001 - 0x0000)
struct LItem_GetChangedCorrectionType final
{
public:
	ELStatCorrectChangeType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetChangedCorrectionType) == 0x000001, "Wrong alignment on LItem_GetChangedCorrectionType");
static_assert(sizeof(LItem_GetChangedCorrectionType) == 0x000001, "Wrong size on LItem_GetChangedCorrectionType");
static_assert(offsetof(LItem_GetChangedCorrectionType, ReturnValue) == 0x000000, "Member 'LItem_GetChangedCorrectionType::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetCodeName
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetCodeName) == 0x000004, "Wrong alignment on LItem_GetCodeName");
static_assert(sizeof(LItem_GetCodeName) == 0x000008, "Wrong size on LItem_GetCodeName");
static_assert(offsetof(LItem_GetCodeName, ReturnValue) == 0x000000, "Member 'LItem_GetCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetCollectionInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetCollectionInfo final
{
public:
	struct FItemCollectionInfoPtr                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetCollectionInfo) == 0x000008, "Wrong alignment on LItem_GetCollectionInfo");
static_assert(sizeof(LItem_GetCollectionInfo) == 0x000008, "Wrong size on LItem_GetCollectionInfo");
static_assert(offsetof(LItem_GetCollectionInfo, ReturnValue) == 0x000000, "Member 'LItem_GetCollectionInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetCommonInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetCommonInfo final
{
public:
	struct FItemCommonInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetCommonInfo) == 0x000008, "Wrong alignment on LItem_GetCommonInfo");
static_assert(sizeof(LItem_GetCommonInfo) == 0x000008, "Wrong size on LItem_GetCommonInfo");
static_assert(offsetof(LItem_GetCommonInfo, ReturnValue) == 0x000000, "Member 'LItem_GetCommonInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetComplexItem_Main
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetComplexItem_Main final
{
public:
	class ULItem*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetComplexItem_Main) == 0x000008, "Wrong alignment on LItem_GetComplexItem_Main");
static_assert(sizeof(LItem_GetComplexItem_Main) == 0x000008, "Wrong size on LItem_GetComplexItem_Main");
static_assert(offsetof(LItem_GetComplexItem_Main, ReturnValue) == 0x000000, "Member 'LItem_GetComplexItem_Main::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetComplexItem_Unit
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetComplexItem_Unit final
{
public:
	class ULItem*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetComplexItem_Unit) == 0x000008, "Wrong alignment on LItem_GetComplexItem_Unit");
static_assert(sizeof(LItem_GetComplexItem_Unit) == 0x000008, "Wrong size on LItem_GetComplexItem_Unit");
static_assert(offsetof(LItem_GetComplexItem_Unit, ReturnValue) == 0x000000, "Member 'LItem_GetComplexItem_Unit::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetConsumeInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetConsumeInfo final
{
public:
	struct FItemConsumeInfoPtr                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetConsumeInfo) == 0x000008, "Wrong alignment on LItem_GetConsumeInfo");
static_assert(sizeof(LItem_GetConsumeInfo) == 0x000008, "Wrong size on LItem_GetConsumeInfo");
static_assert(offsetof(LItem_GetConsumeInfo, ReturnValue) == 0x000000, "Member 'LItem_GetConsumeInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetCorrectionGrade
// 0x000C (0x000C - 0x0000)
struct LItem_GetCorrectionGrade final
{
public:
	ELFirstStat                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStatCorrectChangeType                       WillBeChangeCorrection;                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OutStackLevel;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHandleCorrectResultGrade                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItem_GetCorrectionGrade) == 0x000004, "Wrong alignment on LItem_GetCorrectionGrade");
static_assert(sizeof(LItem_GetCorrectionGrade) == 0x00000C, "Wrong size on LItem_GetCorrectionGrade");
static_assert(offsetof(LItem_GetCorrectionGrade, Type) == 0x000000, "Member 'LItem_GetCorrectionGrade::Type' has a wrong offset!");
static_assert(offsetof(LItem_GetCorrectionGrade, WillBeChangeCorrection) == 0x000001, "Member 'LItem_GetCorrectionGrade::WillBeChangeCorrection' has a wrong offset!");
static_assert(offsetof(LItem_GetCorrectionGrade, OutStackLevel) == 0x000004, "Member 'LItem_GetCorrectionGrade::OutStackLevel' has a wrong offset!");
static_assert(offsetof(LItem_GetCorrectionGrade, ReturnValue) == 0x000008, "Member 'LItem_GetCorrectionGrade::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetCount
// 0x0004 (0x0004 - 0x0000)
struct LItem_GetCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetCount) == 0x000004, "Wrong alignment on LItem_GetCount");
static_assert(sizeof(LItem_GetCount) == 0x000004, "Wrong size on LItem_GetCount");
static_assert(offsetof(LItem_GetCount, ReturnValue) == 0x000000, "Member 'LItem_GetCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetDurabilityAmount
// 0x0004 (0x0004 - 0x0000)
struct LItem_GetDurabilityAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetDurabilityAmount) == 0x000004, "Wrong alignment on LItem_GetDurabilityAmount");
static_assert(sizeof(LItem_GetDurabilityAmount) == 0x000004, "Wrong size on LItem_GetDurabilityAmount");
static_assert(offsetof(LItem_GetDurabilityAmount, ReturnValue) == 0x000000, "Member 'LItem_GetDurabilityAmount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetFirstCategory
// 0x0001 (0x0001 - 0x0000)
struct LItem_GetFirstCategory final
{
public:
	ELItemFirstCategory                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetFirstCategory) == 0x000001, "Wrong alignment on LItem_GetFirstCategory");
static_assert(sizeof(LItem_GetFirstCategory) == 0x000001, "Wrong size on LItem_GetFirstCategory");
static_assert(offsetof(LItem_GetFirstCategory, ReturnValue) == 0x000000, "Member 'LItem_GetFirstCategory::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetImageResource
// 0x0028 (0x0028 - 0x0000)
struct LItem_GetImageResource final
{
public:
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetImageResource) == 0x000008, "Wrong alignment on LItem_GetImageResource");
static_assert(sizeof(LItem_GetImageResource) == 0x000028, "Wrong size on LItem_GetImageResource");
static_assert(offsetof(LItem_GetImageResource, ReturnValue) == 0x000000, "Member 'LItem_GetImageResource::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetItemId
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetItemId final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetItemId) == 0x000008, "Wrong alignment on LItem_GetItemId");
static_assert(sizeof(LItem_GetItemId) == 0x000008, "Wrong size on LItem_GetItemId");
static_assert(offsetof(LItem_GetItemId, ReturnValue) == 0x000000, "Member 'LItem_GetItemId::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetMaxSharpnessPoint
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetMaxSharpnessPoint final
{
public:
	bool                                          bIncludeSharpnessStatBonus;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeGrindingReducement;                        // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetMaxSharpnessPoint) == 0x000004, "Wrong alignment on LItem_GetMaxSharpnessPoint");
static_assert(sizeof(LItem_GetMaxSharpnessPoint) == 0x000008, "Wrong size on LItem_GetMaxSharpnessPoint");
static_assert(offsetof(LItem_GetMaxSharpnessPoint, bIncludeSharpnessStatBonus) == 0x000000, "Member 'LItem_GetMaxSharpnessPoint::bIncludeSharpnessStatBonus' has a wrong offset!");
static_assert(offsetof(LItem_GetMaxSharpnessPoint, WillReinforceDiffStat) == 0x000001, "Member 'LItem_GetMaxSharpnessPoint::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetMaxSharpnessPoint, bIncludeGrindingReducement) == 0x000002, "Member 'LItem_GetMaxSharpnessPoint::bIncludeGrindingReducement' has a wrong offset!");
static_assert(offsetof(LItem_GetMaxSharpnessPoint, ReturnValue) == 0x000004, "Member 'LItem_GetMaxSharpnessPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetMaxSharpnessPointByType
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetMaxSharpnessPointByType final
{
public:
	ELBladeSharpnessType                          Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSharpnessStatBonus;                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetMaxSharpnessPointByType) == 0x000004, "Wrong alignment on LItem_GetMaxSharpnessPointByType");
static_assert(sizeof(LItem_GetMaxSharpnessPointByType) == 0x000008, "Wrong size on LItem_GetMaxSharpnessPointByType");
static_assert(offsetof(LItem_GetMaxSharpnessPointByType, Type) == 0x000000, "Member 'LItem_GetMaxSharpnessPointByType::Type' has a wrong offset!");
static_assert(offsetof(LItem_GetMaxSharpnessPointByType, bIncludeSharpnessStatBonus) == 0x000001, "Member 'LItem_GetMaxSharpnessPointByType::bIncludeSharpnessStatBonus' has a wrong offset!");
static_assert(offsetof(LItem_GetMaxSharpnessPointByType, WillReinforceDiffStat) == 0x000002, "Member 'LItem_GetMaxSharpnessPointByType::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetMaxSharpnessPointByType, ReturnValue) == 0x000004, "Member 'LItem_GetMaxSharpnessPointByType::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetNextReinforceInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetNextReinforceInfo final
{
public:
	struct FItemWeaponReinforceInfoPtr            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetNextReinforceInfo) == 0x000008, "Wrong alignment on LItem_GetNextReinforceInfo");
static_assert(sizeof(LItem_GetNextReinforceInfo) == 0x000008, "Wrong size on LItem_GetNextReinforceInfo");
static_assert(offsetof(LItem_GetNextReinforceInfo, ReturnValue) == 0x000000, "Member 'LItem_GetNextReinforceInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetPartsInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetPartsInfo final
{
public:
	struct FItemPartsInfoPtr                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetPartsInfo) == 0x000008, "Wrong alignment on LItem_GetPartsInfo");
static_assert(sizeof(LItem_GetPartsInfo) == 0x000008, "Wrong size on LItem_GetPartsInfo");
static_assert(offsetof(LItem_GetPartsInfo, ReturnValue) == 0x000000, "Member 'LItem_GetPartsInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetRawWeaponStat
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetRawWeaponStat final
{
public:
	ELSecondStat                                  InStat;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStatCorrectChangeType                       WillHandleDiffStat;                                // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetRawWeaponStat) == 0x000004, "Wrong alignment on LItem_GetRawWeaponStat");
static_assert(sizeof(LItem_GetRawWeaponStat) == 0x000008, "Wrong size on LItem_GetRawWeaponStat");
static_assert(offsetof(LItem_GetRawWeaponStat, InStat) == 0x000000, "Member 'LItem_GetRawWeaponStat::InStat' has a wrong offset!");
static_assert(offsetof(LItem_GetRawWeaponStat, WillReinforceDiffStat) == 0x000001, "Member 'LItem_GetRawWeaponStat::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetRawWeaponStat, WillHandleDiffStat) == 0x000002, "Member 'LItem_GetRawWeaponStat::WillHandleDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetRawWeaponStat, ReturnValue) == 0x000004, "Member 'LItem_GetRawWeaponStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetReinforceInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetReinforceInfo final
{
public:
	struct FItemWeaponReinforceInfoPtr            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetReinforceInfo) == 0x000008, "Wrong alignment on LItem_GetReinforceInfo");
static_assert(sizeof(LItem_GetReinforceInfo) == 0x000008, "Wrong size on LItem_GetReinforceInfo");
static_assert(offsetof(LItem_GetReinforceInfo, ReturnValue) == 0x000000, "Member 'LItem_GetReinforceInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetReinforceLevel
// 0x0004 (0x0004 - 0x0000)
struct LItem_GetReinforceLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetReinforceLevel) == 0x000004, "Wrong alignment on LItem_GetReinforceLevel");
static_assert(sizeof(LItem_GetReinforceLevel) == 0x000004, "Wrong size on LItem_GetReinforceLevel");
static_assert(offsetof(LItem_GetReinforceLevel, ReturnValue) == 0x000000, "Member 'LItem_GetReinforceLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetSecondCategory
// 0x0001 (0x0001 - 0x0000)
struct LItem_GetSecondCategory final
{
public:
	ELItemSecondCategory                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetSecondCategory) == 0x000001, "Wrong alignment on LItem_GetSecondCategory");
static_assert(sizeof(LItem_GetSecondCategory) == 0x000001, "Wrong size on LItem_GetSecondCategory");
static_assert(offsetof(LItem_GetSecondCategory, ReturnValue) == 0x000000, "Member 'LItem_GetSecondCategory::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetSlaveArmInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetSlaveArmInfo final
{
public:
	struct FItemSlaveArmInfoPtr                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetSlaveArmInfo) == 0x000008, "Wrong alignment on LItem_GetSlaveArmInfo");
static_assert(sizeof(LItem_GetSlaveArmInfo) == 0x000008, "Wrong size on LItem_GetSlaveArmInfo");
static_assert(offsetof(LItem_GetSlaveArmInfo, ReturnValue) == 0x000000, "Member 'LItem_GetSlaveArmInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetWeaponBladeInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetWeaponBladeInfo final
{
public:
	struct FItemBladeInfoPtr                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetWeaponBladeInfo) == 0x000008, "Wrong alignment on LItem_GetWeaponBladeInfo");
static_assert(sizeof(LItem_GetWeaponBladeInfo) == 0x000008, "Wrong size on LItem_GetWeaponBladeInfo");
static_assert(offsetof(LItem_GetWeaponBladeInfo, ReturnValue) == 0x000000, "Member 'LItem_GetWeaponBladeInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetWeaponHandleInfo
// 0x0008 (0x0008 - 0x0000)
struct LItem_GetWeaponHandleInfo final
{
public:
	struct FItemHandleInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetWeaponHandleInfo) == 0x000008, "Wrong alignment on LItem_GetWeaponHandleInfo");
static_assert(sizeof(LItem_GetWeaponHandleInfo) == 0x000008, "Wrong size on LItem_GetWeaponHandleInfo");
static_assert(offsetof(LItem_GetWeaponHandleInfo, ReturnValue) == 0x000000, "Member 'LItem_GetWeaponHandleInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetWeaponStat
// 0x0010 (0x0010 - 0x0000)
struct LItem_GetWeaponStat final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStatCorrectChangeType                       WillHandleDiffStat;                                // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetWeaponStat) == 0x000008, "Wrong alignment on LItem_GetWeaponStat");
static_assert(sizeof(LItem_GetWeaponStat) == 0x000010, "Wrong size on LItem_GetWeaponStat");
static_assert(offsetof(LItem_GetWeaponStat, InOwner) == 0x000000, "Member 'LItem_GetWeaponStat::InOwner' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStat, InStat) == 0x000008, "Member 'LItem_GetWeaponStat::InStat' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStat, WillReinforceDiffStat) == 0x000009, "Member 'LItem_GetWeaponStat::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStat, WillHandleDiffStat) == 0x00000A, "Member 'LItem_GetWeaponStat::WillHandleDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStat, ReturnValue) == 0x00000C, "Member 'LItem_GetWeaponStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetWeaponStatBonus
// 0x0010 (0x0010 - 0x0000)
struct LItem_GetWeaponStatBonus final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStatCorrectChangeType                       WillHandleDiffStat;                                // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetWeaponStatBonus) == 0x000008, "Wrong alignment on LItem_GetWeaponStatBonus");
static_assert(sizeof(LItem_GetWeaponStatBonus) == 0x000010, "Wrong size on LItem_GetWeaponStatBonus");
static_assert(offsetof(LItem_GetWeaponStatBonus, InOwner) == 0x000000, "Member 'LItem_GetWeaponStatBonus::InOwner' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStatBonus, InStat) == 0x000008, "Member 'LItem_GetWeaponStatBonus::InStat' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStatBonus, WillReinforceDiffStat) == 0x000009, "Member 'LItem_GetWeaponStatBonus::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStatBonus, WillHandleDiffStat) == 0x00000A, "Member 'LItem_GetWeaponStatBonus::WillHandleDiffStat' has a wrong offset!");
static_assert(offsetof(LItem_GetWeaponStatBonus, ReturnValue) == 0x00000C, "Member 'LItem_GetWeaponStatBonus::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.GetWeight
// 0x0004 (0x0004 - 0x0000)
struct LItem_GetWeight final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_GetWeight) == 0x000004, "Wrong alignment on LItem_GetWeight");
static_assert(sizeof(LItem_GetWeight) == 0x000004, "Wrong size on LItem_GetWeight");
static_assert(offsetof(LItem_GetWeight, ReturnValue) == 0x000000, "Member 'LItem_GetWeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsBladeItem
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsBladeItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsBladeItem) == 0x000001, "Wrong alignment on LItem_IsBladeItem");
static_assert(sizeof(LItem_IsBladeItem) == 0x000001, "Wrong size on LItem_IsBladeItem");
static_assert(offsetof(LItem_IsBladeItem, ReturnValue) == 0x000000, "Member 'LItem_IsBladeItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsChangedCorrection
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsChangedCorrection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsChangedCorrection) == 0x000001, "Wrong alignment on LItem_IsChangedCorrection");
static_assert(sizeof(LItem_IsChangedCorrection) == 0x000001, "Wrong size on LItem_IsChangedCorrection");
static_assert(offsetof(LItem_IsChangedCorrection, ReturnValue) == 0x000000, "Member 'LItem_IsChangedCorrection::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsComplexItem
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsComplexItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsComplexItem) == 0x000001, "Wrong alignment on LItem_IsComplexItem");
static_assert(sizeof(LItem_IsComplexItem) == 0x000001, "Wrong size on LItem_IsComplexItem");
static_assert(offsetof(LItem_IsComplexItem, ReturnValue) == 0x000000, "Member 'LItem_IsComplexItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsHandleItem
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsHandleItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsHandleItem) == 0x000001, "Wrong alignment on LItem_IsHandleItem");
static_assert(sizeof(LItem_IsHandleItem) == 0x000001, "Wrong size on LItem_IsHandleItem");
static_assert(offsetof(LItem_IsHandleItem, ReturnValue) == 0x000000, "Member 'LItem_IsHandleItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsOnToggled
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsOnToggled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsOnToggled) == 0x000001, "Wrong alignment on LItem_IsOnToggled");
static_assert(sizeof(LItem_IsOnToggled) == 0x000001, "Wrong size on LItem_IsOnToggled");
static_assert(offsetof(LItem_IsOnToggled, ReturnValue) == 0x000000, "Member 'LItem_IsOnToggled::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsReinforced
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsReinforced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsReinforced) == 0x000001, "Wrong alignment on LItem_IsReinforced");
static_assert(sizeof(LItem_IsReinforced) == 0x000001, "Wrong size on LItem_IsReinforced");
static_assert(offsetof(LItem_IsReinforced, ReturnValue) == 0x000000, "Member 'LItem_IsReinforced::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsSameGroup
// 0x0010 (0x0010 - 0x0000)
struct LItem_IsSameGroup final
{
public:
	class ULItem*                                 In;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItem_IsSameGroup) == 0x000008, "Wrong alignment on LItem_IsSameGroup");
static_assert(sizeof(LItem_IsSameGroup) == 0x000010, "Wrong size on LItem_IsSameGroup");
static_assert(offsetof(LItem_IsSameGroup, In) == 0x000000, "Member 'LItem_IsSameGroup::In' has a wrong offset!");
static_assert(offsetof(LItem_IsSameGroup, ReturnValue) == 0x000008, "Member 'LItem_IsSameGroup::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsSameItem
// 0x0010 (0x0010 - 0x0000)
struct LItem_IsSameItem final
{
public:
	class ULItem*                                 In;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItem_IsSameItem) == 0x000008, "Wrong alignment on LItem_IsSameItem");
static_assert(sizeof(LItem_IsSameItem) == 0x000010, "Wrong size on LItem_IsSameItem");
static_assert(offsetof(LItem_IsSameItem, In) == 0x000000, "Member 'LItem_IsSameItem::In' has a wrong offset!");
static_assert(offsetof(LItem_IsSameItem, ReturnValue) == 0x000008, "Member 'LItem_IsSameItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsToggleItem
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsToggleItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsToggleItem) == 0x000001, "Wrong alignment on LItem_IsToggleItem");
static_assert(sizeof(LItem_IsToggleItem) == 0x000001, "Wrong size on LItem_IsToggleItem");
static_assert(offsetof(LItem_IsToggleItem, ReturnValue) == 0x000000, "Member 'LItem_IsToggleItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsWeapon
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsWeapon) == 0x000001, "Wrong alignment on LItem_IsWeapon");
static_assert(sizeof(LItem_IsWeapon) == 0x000001, "Wrong size on LItem_IsWeapon");
static_assert(offsetof(LItem_IsWeapon, ReturnValue) == 0x000000, "Member 'LItem_IsWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsWeaponBlade
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsWeaponBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsWeaponBlade) == 0x000001, "Wrong alignment on LItem_IsWeaponBlade");
static_assert(sizeof(LItem_IsWeaponBlade) == 0x000001, "Wrong size on LItem_IsWeaponBlade");
static_assert(offsetof(LItem_IsWeaponBlade, ReturnValue) == 0x000000, "Member 'LItem_IsWeaponBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsWeaponHandle
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsWeaponHandle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsWeaponHandle) == 0x000001, "Wrong alignment on LItem_IsWeaponHandle");
static_assert(sizeof(LItem_IsWeaponHandle) == 0x000001, "Wrong size on LItem_IsWeaponHandle");
static_assert(offsetof(LItem_IsWeaponHandle, ReturnValue) == 0x000000, "Member 'LItem_IsWeaponHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LItem.IsWeaponSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LItem_IsWeaponSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItem_IsWeaponSlaveArm) == 0x000001, "Wrong alignment on LItem_IsWeaponSlaveArm");
static_assert(sizeof(LItem_IsWeaponSlaveArm) == 0x000001, "Wrong size on LItem_IsWeaponSlaveArm");
static_assert(offsetof(LItem_IsWeaponSlaveArm, ReturnValue) == 0x000000, "Member 'LItem_IsWeaponSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LListView.GetScrollOffset
// 0x0004 (0x0004 - 0x0000)
struct LListView_GetScrollOffset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LListView_GetScrollOffset) == 0x000004, "Wrong alignment on LListView_GetScrollOffset");
static_assert(sizeof(LListView_GetScrollOffset) == 0x000004, "Wrong size on LListView_GetScrollOffset");
static_assert(offsetof(LListView_GetScrollOffset, ReturnValue) == 0x000000, "Member 'LListView_GetScrollOffset::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.ChangeShotGunAmmo
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_ChangeShotGunAmmo final
{
public:
	ELShotGunAmmoType                             InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_ChangeShotGunAmmo) == 0x000001, "Wrong alignment on LSlaveArmItem_ChangeShotGunAmmo");
static_assert(sizeof(LSlaveArmItem_ChangeShotGunAmmo) == 0x000001, "Wrong size on LSlaveArmItem_ChangeShotGunAmmo");
static_assert(offsetof(LSlaveArmItem_ChangeShotGunAmmo, InType) == 0x000000, "Member 'LSlaveArmItem_ChangeShotGunAmmo::InType' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.ChangeSpreadingMode
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_ChangeSpreadingMode final
{
public:
	ELAcidSpreadingModeType                       InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_ChangeSpreadingMode) == 0x000001, "Wrong alignment on LSlaveArmItem_ChangeSpreadingMode");
static_assert(sizeof(LSlaveArmItem_ChangeSpreadingMode) == 0x000001, "Wrong size on LSlaveArmItem_ChangeSpreadingMode");
static_assert(offsetof(LSlaveArmItem_ChangeSpreadingMode, InMode) == 0x000000, "Member 'LSlaveArmItem_ChangeSpreadingMode::InMode' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.ConsumeAmmo
// 0x0004 (0x0004 - 0x0000)
struct LSlaveArmItem_ConsumeAmmo final
{
public:
	int32                                         ConsumeAmmoCount;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_ConsumeAmmo) == 0x000004, "Wrong alignment on LSlaveArmItem_ConsumeAmmo");
static_assert(sizeof(LSlaveArmItem_ConsumeAmmo) == 0x000004, "Wrong size on LSlaveArmItem_ConsumeAmmo");
static_assert(offsetof(LSlaveArmItem_ConsumeAmmo, ConsumeAmmoCount) == 0x000000, "Member 'LSlaveArmItem_ConsumeAmmo::ConsumeAmmoCount' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.CanCombinedKeyActionEnable
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_CanCombinedKeyActionEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_CanCombinedKeyActionEnable) == 0x000001, "Wrong alignment on LSlaveArmItem_CanCombinedKeyActionEnable");
static_assert(sizeof(LSlaveArmItem_CanCombinedKeyActionEnable) == 0x000001, "Wrong size on LSlaveArmItem_CanCombinedKeyActionEnable");
static_assert(offsetof(LSlaveArmItem_CanCombinedKeyActionEnable, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_CanCombinedKeyActionEnable::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsAcidSpreaderSlavearm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsAcidSpreaderSlavearm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsAcidSpreaderSlavearm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsAcidSpreaderSlavearm");
static_assert(sizeof(LSlaveArmItem_IsAcidSpreaderSlavearm) == 0x000001, "Wrong size on LSlaveArmItem_IsAcidSpreaderSlavearm");
static_assert(offsetof(LSlaveArmItem_IsAcidSpreaderSlavearm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsAcidSpreaderSlavearm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsAegisInCooltime
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsAegisInCooltime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsAegisInCooltime) == 0x000001, "Wrong alignment on LSlaveArmItem_IsAegisInCooltime");
static_assert(sizeof(LSlaveArmItem_IsAegisInCooltime) == 0x000001, "Wrong size on LSlaveArmItem_IsAegisInCooltime");
static_assert(offsetof(LSlaveArmItem_IsAegisInCooltime, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsAegisInCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsAegisSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsAegisSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsAegisSlaveArm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsAegisSlaveArm");
static_assert(sizeof(LSlaveArmItem_IsAegisSlaveArm) == 0x000001, "Wrong size on LSlaveArmItem_IsAegisSlaveArm");
static_assert(offsetof(LSlaveArmItem_IsAegisSlaveArm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsAegisSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsFlameThrowerSlavearm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsFlameThrowerSlavearm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsFlameThrowerSlavearm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsFlameThrowerSlavearm");
static_assert(sizeof(LSlaveArmItem_IsFlameThrowerSlavearm) == 0x000001, "Wrong size on LSlaveArmItem_IsFlameThrowerSlavearm");
static_assert(offsetof(LSlaveArmItem_IsFlameThrowerSlavearm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsFlameThrowerSlavearm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsFulminisSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsFulminisSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsFulminisSlaveArm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsFulminisSlaveArm");
static_assert(sizeof(LSlaveArmItem_IsFulminisSlaveArm) == 0x000001, "Wrong size on LSlaveArmItem_IsFulminisSlaveArm");
static_assert(offsetof(LSlaveArmItem_IsFulminisSlaveArm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsFulminisSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsNormalSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsNormalSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsNormalSlaveArm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsNormalSlaveArm");
static_assert(sizeof(LSlaveArmItem_IsNormalSlaveArm) == 0x000001, "Wrong size on LSlaveArmItem_IsNormalSlaveArm");
static_assert(offsetof(LSlaveArmItem_IsNormalSlaveArm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsNormalSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsPileBunkerSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsPileBunkerSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsPileBunkerSlaveArm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsPileBunkerSlaveArm");
static_assert(sizeof(LSlaveArmItem_IsPileBunkerSlaveArm) == 0x000001, "Wrong size on LSlaveArmItem_IsPileBunkerSlaveArm");
static_assert(offsetof(LSlaveArmItem_IsPileBunkerSlaveArm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsPileBunkerSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsPuppetStringSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsPuppetStringSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsPuppetStringSlaveArm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsPuppetStringSlaveArm");
static_assert(sizeof(LSlaveArmItem_IsPuppetStringSlaveArm) == 0x000001, "Wrong size on LSlaveArmItem_IsPuppetStringSlaveArm");
static_assert(offsetof(LSlaveArmItem_IsPuppetStringSlaveArm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsPuppetStringSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsShotGunSlavearm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsShotGunSlavearm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsShotGunSlavearm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsShotGunSlavearm");
static_assert(sizeof(LSlaveArmItem_IsShotGunSlavearm) == 0x000001, "Wrong size on LSlaveArmItem_IsShotGunSlavearm");
static_assert(offsetof(LSlaveArmItem_IsShotGunSlavearm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsShotGunSlavearm::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmItem.IsSniperCannonSlaveArm
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmItem_IsSniperCannonSlaveArm final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmItem_IsSniperCannonSlaveArm) == 0x000001, "Wrong alignment on LSlaveArmItem_IsSniperCannonSlaveArm");
static_assert(sizeof(LSlaveArmItem_IsSniperCannonSlaveArm) == 0x000001, "Wrong size on LSlaveArmItem_IsSniperCannonSlaveArm");
static_assert(offsetof(LSlaveArmItem_IsSniperCannonSlaveArm, ReturnValue) == 0x000000, "Member 'LSlaveArmItem_IsSniperCannonSlaveArm::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogDebugInfo.ToString
// 0x0010 (0x0010 - 0x0000)
struct LDialogDebugInfo_ToString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogDebugInfo_ToString) == 0x000008, "Wrong alignment on LDialogDebugInfo_ToString");
static_assert(sizeof(LDialogDebugInfo_ToString) == 0x000010, "Wrong size on LDialogDebugInfo_ToString");
static_assert(offsetof(LDialogDebugInfo_ToString, ReturnValue) == 0x000000, "Member 'LDialogDebugInfo_ToString::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemDropSystem.GainDropErgoData
// 0x0010 (0x0010 - 0x0000)
struct LItemDropSystem_GainDropErgoData final
{
public:
	class FString                                 SpotUniqueID;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemDropSystem_GainDropErgoData) == 0x000008, "Wrong alignment on LItemDropSystem_GainDropErgoData");
static_assert(sizeof(LItemDropSystem_GainDropErgoData) == 0x000010, "Wrong size on LItemDropSystem_GainDropErgoData");
static_assert(offsetof(LItemDropSystem_GainDropErgoData, SpotUniqueID) == 0x000000, "Member 'LItemDropSystem_GainDropErgoData::SpotUniqueID' has a wrong offset!");

// Function ProjectP.LHitProcContext.AttackerActionAtHitStarted
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_AttackerActionAtHitStarted final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              OutActionAtHitStarted;                             // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_AttackerActionAtHitStarted) == 0x000008, "Wrong alignment on LHitProcContext_AttackerActionAtHitStarted");
static_assert(sizeof(LHitProcContext_AttackerActionAtHitStarted) == 0x000010, "Wrong size on LHitProcContext_AttackerActionAtHitStarted");
static_assert(offsetof(LHitProcContext_AttackerActionAtHitStarted, Branches) == 0x000000, "Member 'LHitProcContext_AttackerActionAtHitStarted::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerActionAtHitStarted, OutActionAtHitStarted) == 0x000008, "Member 'LHitProcContext_AttackerActionAtHitStarted::OutActionAtHitStarted' has a wrong offset!");

// Function ProjectP.LHitProcContext.AttackerActMgrComp
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_AttackerActMgrComp final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActMgrComponent*                      OutActMgrComponent;                                // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_AttackerActMgrComp) == 0x000008, "Wrong alignment on LHitProcContext_AttackerActMgrComp");
static_assert(sizeof(LHitProcContext_AttackerActMgrComp) == 0x000010, "Wrong size on LHitProcContext_AttackerActMgrComp");
static_assert(offsetof(LHitProcContext_AttackerActMgrComp, Branches) == 0x000000, "Member 'LHitProcContext_AttackerActMgrComp::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerActMgrComp, OutActMgrComponent) == 0x000008, "Member 'LHitProcContext_AttackerActMgrComp::OutActMgrComponent' has a wrong offset!");

// Function ProjectP.LHitProcContext.AttackerAs
// 0x0030 (0x0030 - 0x0000)
struct LHitProcContext_AttackerAs final
{
public:
	ELHitProcObjectType                           Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALCharacter*                            OutCharacter;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPCCharacter*                          OutPC;                                             // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCCharacter*                         OutNPC;                                            // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALDynamicDamageVolumeActor*             OutDamageVolume;                                   // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALProjectile*                           OutProjectile;                                     // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_AttackerAs) == 0x000008, "Wrong alignment on LHitProcContext_AttackerAs");
static_assert(sizeof(LHitProcContext_AttackerAs) == 0x000030, "Wrong size on LHitProcContext_AttackerAs");
static_assert(offsetof(LHitProcContext_AttackerAs, Branches) == 0x000000, "Member 'LHitProcContext_AttackerAs::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerAs, OutCharacter) == 0x000008, "Member 'LHitProcContext_AttackerAs::OutCharacter' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerAs, OutPC) == 0x000010, "Member 'LHitProcContext_AttackerAs::OutPC' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerAs, OutNPC) == 0x000018, "Member 'LHitProcContext_AttackerAs::OutNPC' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerAs, OutDamageVolume) == 0x000020, "Member 'LHitProcContext_AttackerAs::OutDamageVolume' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerAs, OutProjectile) == 0x000028, "Member 'LHitProcContext_AttackerAs::OutProjectile' has a wrong offset!");

// Function ProjectP.LHitProcContext.AttackerHitProcComp
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_AttackerHitProcComp final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitProcComponent*                     OutHitProcComponent;                               // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_AttackerHitProcComp) == 0x000008, "Wrong alignment on LHitProcContext_AttackerHitProcComp");
static_assert(sizeof(LHitProcContext_AttackerHitProcComp) == 0x000010, "Wrong size on LHitProcContext_AttackerHitProcComp");
static_assert(offsetof(LHitProcContext_AttackerHitProcComp, Branches) == 0x000000, "Member 'LHitProcContext_AttackerHitProcComp::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerHitProcComp, OutHitProcComponent) == 0x000008, "Member 'LHitProcContext_AttackerHitProcComp::OutHitProcComponent' has a wrong offset!");

// Function ProjectP.LHitProcContext.AttackerStatComp
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_AttackerStatComp final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULStatComponent*                        OutStatComponent;                                  // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_AttackerStatComp) == 0x000008, "Wrong alignment on LHitProcContext_AttackerStatComp");
static_assert(sizeof(LHitProcContext_AttackerStatComp) == 0x000010, "Wrong size on LHitProcContext_AttackerStatComp");
static_assert(offsetof(LHitProcContext_AttackerStatComp, Branches) == 0x000000, "Member 'LHitProcContext_AttackerStatComp::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerStatComp, OutStatComponent) == 0x000008, "Member 'LHitProcContext_AttackerStatComp::OutStatComponent' has a wrong offset!");

// Function ProjectP.LHitProcContext.AttackerWeapon
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_AttackerWeapon final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               OutWeapon;                                         // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_AttackerWeapon) == 0x000008, "Wrong alignment on LHitProcContext_AttackerWeapon");
static_assert(sizeof(LHitProcContext_AttackerWeapon) == 0x000010, "Wrong size on LHitProcContext_AttackerWeapon");
static_assert(offsetof(LHitProcContext_AttackerWeapon, Branches) == 0x000000, "Member 'LHitProcContext_AttackerWeapon::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_AttackerWeapon, OutWeapon) == 0x000008, "Member 'LHitProcContext_AttackerWeapon::OutWeapon' has a wrong offset!");

// Function ProjectP.LHitProcContext.ChangeSkillHitBP
// 0x000C (0x000C - 0x0000)
struct LHitProcContext_ChangeSkillHitBP final
{
public:
	class FName                                   InSkillHitCodeName;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LHitProcContext_ChangeSkillHitBP) == 0x000004, "Wrong alignment on LHitProcContext_ChangeSkillHitBP");
static_assert(sizeof(LHitProcContext_ChangeSkillHitBP) == 0x00000C, "Wrong size on LHitProcContext_ChangeSkillHitBP");
static_assert(offsetof(LHitProcContext_ChangeSkillHitBP, InSkillHitCodeName) == 0x000000, "Member 'LHitProcContext_ChangeSkillHitBP::InSkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LHitProcContext_ChangeSkillHitBP, Branches) == 0x000008, "Member 'LHitProcContext_ChangeSkillHitBP::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_ChangeSkillHitBP, ReturnValue) == 0x000009, "Member 'LHitProcContext_ChangeSkillHitBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitProcContext.OnPrepareBP
// 0x0001 (0x0001 - 0x0000)
struct LHitProcContext_OnPrepareBP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_OnPrepareBP) == 0x000001, "Wrong alignment on LHitProcContext_OnPrepareBP");
static_assert(sizeof(LHitProcContext_OnPrepareBP) == 0x000001, "Wrong size on LHitProcContext_OnPrepareBP");
static_assert(offsetof(LHitProcContext_OnPrepareBP, ReturnValue) == 0x000000, "Member 'LHitProcContext_OnPrepareBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitProcContext.PrepareBP
// 0x01F0 (0x01F0 - 0x0000)
struct LHitProcContext_PrepareBP final
{
public:
	class AActor*                                 InAttacker;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InVictim;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InHitResult;                                       // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              InHitInfo;                                         // 0x0098(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x01E8(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x01E9(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA[0x6];                                      // 0x01EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LHitProcContext_PrepareBP) == 0x000008, "Wrong alignment on LHitProcContext_PrepareBP");
static_assert(sizeof(LHitProcContext_PrepareBP) == 0x0001F0, "Wrong size on LHitProcContext_PrepareBP");
static_assert(offsetof(LHitProcContext_PrepareBP, InAttacker) == 0x000000, "Member 'LHitProcContext_PrepareBP::InAttacker' has a wrong offset!");
static_assert(offsetof(LHitProcContext_PrepareBP, InVictim) == 0x000008, "Member 'LHitProcContext_PrepareBP::InVictim' has a wrong offset!");
static_assert(offsetof(LHitProcContext_PrepareBP, InHitResult) == 0x000010, "Member 'LHitProcContext_PrepareBP::InHitResult' has a wrong offset!");
static_assert(offsetof(LHitProcContext_PrepareBP, InHitInfo) == 0x000098, "Member 'LHitProcContext_PrepareBP::InHitInfo' has a wrong offset!");
static_assert(offsetof(LHitProcContext_PrepareBP, Branches) == 0x0001E8, "Member 'LHitProcContext_PrepareBP::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_PrepareBP, ReturnValue) == 0x0001E9, "Member 'LHitProcContext_PrepareBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitProcContext.VictimActionAtHitStarted
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_VictimActionAtHitStarted final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              OutActionAtHitStarted;                             // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_VictimActionAtHitStarted) == 0x000008, "Wrong alignment on LHitProcContext_VictimActionAtHitStarted");
static_assert(sizeof(LHitProcContext_VictimActionAtHitStarted) == 0x000010, "Wrong size on LHitProcContext_VictimActionAtHitStarted");
static_assert(offsetof(LHitProcContext_VictimActionAtHitStarted, Branches) == 0x000000, "Member 'LHitProcContext_VictimActionAtHitStarted::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimActionAtHitStarted, OutActionAtHitStarted) == 0x000008, "Member 'LHitProcContext_VictimActionAtHitStarted::OutActionAtHitStarted' has a wrong offset!");

// Function ProjectP.LHitProcContext.VictimActMgrComp
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_VictimActMgrComp final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActMgrComponent*                      OutActMgrComponent;                                // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_VictimActMgrComp) == 0x000008, "Wrong alignment on LHitProcContext_VictimActMgrComp");
static_assert(sizeof(LHitProcContext_VictimActMgrComp) == 0x000010, "Wrong size on LHitProcContext_VictimActMgrComp");
static_assert(offsetof(LHitProcContext_VictimActMgrComp, Branches) == 0x000000, "Member 'LHitProcContext_VictimActMgrComp::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimActMgrComp, OutActMgrComponent) == 0x000008, "Member 'LHitProcContext_VictimActMgrComp::OutActMgrComponent' has a wrong offset!");

// Function ProjectP.LHitProcContext.VictimAs
// 0x0030 (0x0030 - 0x0000)
struct LHitProcContext_VictimAs final
{
public:
	ELHitProcObjectType                           Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALCharacter*                            OutCharacter;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPCCharacter*                          OutPC;                                             // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCCharacter*                         OutNPC;                                            // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALDynamicDamageVolumeActor*             OutDamageVolume;                                   // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALProjectile*                           OutProjectile;                                     // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_VictimAs) == 0x000008, "Wrong alignment on LHitProcContext_VictimAs");
static_assert(sizeof(LHitProcContext_VictimAs) == 0x000030, "Wrong size on LHitProcContext_VictimAs");
static_assert(offsetof(LHitProcContext_VictimAs, Branches) == 0x000000, "Member 'LHitProcContext_VictimAs::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimAs, OutCharacter) == 0x000008, "Member 'LHitProcContext_VictimAs::OutCharacter' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimAs, OutPC) == 0x000010, "Member 'LHitProcContext_VictimAs::OutPC' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimAs, OutNPC) == 0x000018, "Member 'LHitProcContext_VictimAs::OutNPC' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimAs, OutDamageVolume) == 0x000020, "Member 'LHitProcContext_VictimAs::OutDamageVolume' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimAs, OutProjectile) == 0x000028, "Member 'LHitProcContext_VictimAs::OutProjectile' has a wrong offset!");

// Function ProjectP.LHitProcContext.VictimHitProcComp
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_VictimHitProcComp final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitProcComponent*                     OutHitProcComponent;                               // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_VictimHitProcComp) == 0x000008, "Wrong alignment on LHitProcContext_VictimHitProcComp");
static_assert(sizeof(LHitProcContext_VictimHitProcComp) == 0x000010, "Wrong size on LHitProcContext_VictimHitProcComp");
static_assert(offsetof(LHitProcContext_VictimHitProcComp, Branches) == 0x000000, "Member 'LHitProcContext_VictimHitProcComp::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimHitProcComp, OutHitProcComponent) == 0x000008, "Member 'LHitProcContext_VictimHitProcComp::OutHitProcComponent' has a wrong offset!");

// Function ProjectP.LHitProcContext.VictimStatComp
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_VictimStatComp final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULStatComponent*                        OutStatComponent;                                  // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_VictimStatComp) == 0x000008, "Wrong alignment on LHitProcContext_VictimStatComp");
static_assert(sizeof(LHitProcContext_VictimStatComp) == 0x000010, "Wrong size on LHitProcContext_VictimStatComp");
static_assert(offsetof(LHitProcContext_VictimStatComp, Branches) == 0x000000, "Member 'LHitProcContext_VictimStatComp::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimStatComp, OutStatComponent) == 0x000008, "Member 'LHitProcContext_VictimStatComp::OutStatComponent' has a wrong offset!");

// Function ProjectP.LHitProcContext.VictimWeapon
// 0x0010 (0x0010 - 0x0000)
struct LHitProcContext_VictimWeapon final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               OutWeapon;                                         // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcContext_VictimWeapon) == 0x000008, "Wrong alignment on LHitProcContext_VictimWeapon");
static_assert(sizeof(LHitProcContext_VictimWeapon) == 0x000010, "Wrong size on LHitProcContext_VictimWeapon");
static_assert(offsetof(LHitProcContext_VictimWeapon, Branches) == 0x000000, "Member 'LHitProcContext_VictimWeapon::Branches' has a wrong offset!");
static_assert(offsetof(LHitProcContext_VictimWeapon, OutWeapon) == 0x000008, "Member 'LHitProcContext_VictimWeapon::OutWeapon' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefault_EnableAlignmentToCamera
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefault_EnableAlignmentToCamera final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefault_EnableAlignmentToCamera) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefault_EnableAlignmentToCamera");
static_assert(sizeof(LOptionSystemData_GetDefault_EnableAlignmentToCamera) == 0x000001, "Wrong size on LOptionSystemData_GetDefault_EnableAlignmentToCamera");
static_assert(offsetof(LOptionSystemData_GetDefault_EnableAlignmentToCamera, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefault_EnableAlignmentToCamera::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefault_EnableCameraShake
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefault_EnableCameraShake final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefault_EnableCameraShake) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefault_EnableCameraShake");
static_assert(sizeof(LOptionSystemData_GetDefault_EnableCameraShake) == 0x000001, "Wrong size on LOptionSystemData_GetDefault_EnableCameraShake");
static_assert(offsetof(LOptionSystemData_GetDefault_EnableCameraShake, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefault_EnableCameraShake::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefault_EnableMoveCameraUpDown
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefault_EnableMoveCameraUpDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefault_EnableMoveCameraUpDown) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefault_EnableMoveCameraUpDown");
static_assert(sizeof(LOptionSystemData_GetDefault_EnableMoveCameraUpDown) == 0x000001, "Wrong size on LOptionSystemData_GetDefault_EnableMoveCameraUpDown");
static_assert(offsetof(LOptionSystemData_GetDefault_EnableMoveCameraUpDown, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefault_EnableMoveCameraUpDown::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultCameraInvert
// 0x0002 (0x0002 - 0x0000)
struct LOptionSystemData_GetDefaultCameraInvert final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultCameraInvert) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultCameraInvert");
static_assert(sizeof(LOptionSystemData_GetDefaultCameraInvert) == 0x000002, "Wrong size on LOptionSystemData_GetDefaultCameraInvert");
static_assert(offsetof(LOptionSystemData_GetDefaultCameraInvert, InRotator) == 0x000000, "Member 'LOptionSystemData_GetDefaultCameraInvert::InRotator' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetDefaultCameraInvert, ReturnValue) == 0x000001, "Member 'LOptionSystemData_GetDefaultCameraInvert::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultCameraSpeedIdx
// 0x0008 (0x0008 - 0x0000)
struct LOptionSystemData_GetDefaultCameraSpeedIdx final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultCameraSpeedIdx) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultCameraSpeedIdx");
static_assert(sizeof(LOptionSystemData_GetDefaultCameraSpeedIdx) == 0x000008, "Wrong size on LOptionSystemData_GetDefaultCameraSpeedIdx");
static_assert(offsetof(LOptionSystemData_GetDefaultCameraSpeedIdx, InRotator) == 0x000000, "Member 'LOptionSystemData_GetDefaultCameraSpeedIdx::InRotator' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetDefaultCameraSpeedIdx, ReturnValue) == 0x000004, "Member 'LOptionSystemData_GetDefaultCameraSpeedIdx::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultDeadZoneIdx
// 0x0008 (0x0008 - 0x0000)
struct LOptionSystemData_GetDefaultDeadZoneIdx final
{
public:
	bool                                          LeftStick;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultDeadZoneIdx) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultDeadZoneIdx");
static_assert(sizeof(LOptionSystemData_GetDefaultDeadZoneIdx) == 0x000008, "Wrong size on LOptionSystemData_GetDefaultDeadZoneIdx");
static_assert(offsetof(LOptionSystemData_GetDefaultDeadZoneIdx, LeftStick) == 0x000000, "Member 'LOptionSystemData_GetDefaultDeadZoneIdx::LeftStick' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetDefaultDeadZoneIdx, ReturnValue) == 0x000004, "Member 'LOptionSystemData_GetDefaultDeadZoneIdx::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultEnableBloodExpression
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultEnableBloodExpression final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultEnableBloodExpression) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultEnableBloodExpression");
static_assert(sizeof(LOptionSystemData_GetDefaultEnableBloodExpression) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultEnableBloodExpression");
static_assert(offsetof(LOptionSystemData_GetDefaultEnableBloodExpression, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultEnableBloodExpression::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultEnableMotionBlur
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultEnableMotionBlur final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultEnableMotionBlur) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultEnableMotionBlur");
static_assert(sizeof(LOptionSystemData_GetDefaultEnableMotionBlur) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultEnableMotionBlur");
static_assert(offsetof(LOptionSystemData_GetDefaultEnableMotionBlur, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultEnableMotionBlur::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultEnableTutorialPopup
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultEnableTutorialPopup final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultEnableTutorialPopup) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultEnableTutorialPopup");
static_assert(sizeof(LOptionSystemData_GetDefaultEnableTutorialPopup) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultEnableTutorialPopup");
static_assert(offsetof(LOptionSystemData_GetDefaultEnableTutorialPopup, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultEnableTutorialPopup::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultEnableVideoSubtitle
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultEnableVideoSubtitle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultEnableVideoSubtitle) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultEnableVideoSubtitle");
static_assert(sizeof(LOptionSystemData_GetDefaultEnableVideoSubtitle) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultEnableVideoSubtitle");
static_assert(offsetof(LOptionSystemData_GetDefaultEnableVideoSubtitle, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultEnableVideoSubtitle::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultForceFeedbackIdx
// 0x0004 (0x0004 - 0x0000)
struct LOptionSystemData_GetDefaultForceFeedbackIdx final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultForceFeedbackIdx) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultForceFeedbackIdx");
static_assert(sizeof(LOptionSystemData_GetDefaultForceFeedbackIdx) == 0x000004, "Wrong size on LOptionSystemData_GetDefaultForceFeedbackIdx");
static_assert(offsetof(LOptionSystemData_GetDefaultForceFeedbackIdx, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultForceFeedbackIdx::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultFramerateLimit
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultFramerateLimit final
{
public:
	ELFramerateLimit                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultFramerateLimit) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultFramerateLimit");
static_assert(sizeof(LOptionSystemData_GetDefaultFramerateLimit) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultFramerateLimit");
static_assert(offsetof(LOptionSystemData_GetDefaultFramerateLimit, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultFramerateLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultFullscreenMode final
{
public:
	EWindowMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultFullscreenMode) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultFullscreenMode");
static_assert(sizeof(LOptionSystemData_GetDefaultFullscreenMode) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultFullscreenMode");
static_assert(offsetof(LOptionSystemData_GetDefaultFullscreenMode, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultFullscreenMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultHUDVisibility
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultHUDVisibility final
{
public:
	ELHUDVisible                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultHUDVisibility) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultHUDVisibility");
static_assert(sizeof(LOptionSystemData_GetDefaultHUDVisibility) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultHUDVisibility");
static_assert(offsetof(LOptionSystemData_GetDefaultHUDVisibility, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultHUDVisibility::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultInputPresetName
// 0x000C (0x000C - 0x0000)
struct LOptionSystemData_GetDefaultInputPresetName final
{
public:
	bool                                          IsGamePad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultInputPresetName) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultInputPresetName");
static_assert(sizeof(LOptionSystemData_GetDefaultInputPresetName) == 0x00000C, "Wrong size on LOptionSystemData_GetDefaultInputPresetName");
static_assert(offsetof(LOptionSystemData_GetDefaultInputPresetName, IsGamePad) == 0x000000, "Member 'LOptionSystemData_GetDefaultInputPresetName::IsGamePad' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetDefaultInputPresetName, ReturnValue) == 0x000004, "Member 'LOptionSystemData_GetDefaultInputPresetName::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultLanguage
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystemData_GetDefaultLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultLanguage) == 0x000008, "Wrong alignment on LOptionSystemData_GetDefaultLanguage");
static_assert(sizeof(LOptionSystemData_GetDefaultLanguage) == 0x000010, "Wrong size on LOptionSystemData_GetDefaultLanguage");
static_assert(offsetof(LOptionSystemData_GetDefaultLanguage, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultLanguage::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultLockOnImportanceWeightMultiply
// 0x0004 (0x0004 - 0x0000)
struct LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply");
static_assert(sizeof(LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply) == 0x000004, "Wrong size on LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply");
static_assert(offsetof(LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultPlayStyleOption
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultPlayStyleOption final
{
public:
	EPlayStyleOption                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultPlayStyleOption) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultPlayStyleOption");
static_assert(sizeof(LOptionSystemData_GetDefaultPlayStyleOption) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultPlayStyleOption");
static_assert(offsetof(LOptionSystemData_GetDefaultPlayStyleOption, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultPlayStyleOption::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultScalabilityLevel
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultScalabilityLevel final
{
public:
	ELScalabilityLevel                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultScalabilityLevel) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultScalabilityLevel");
static_assert(sizeof(LOptionSystemData_GetDefaultScalabilityLevel) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultScalabilityLevel");
static_assert(offsetof(LOptionSystemData_GetDefaultScalabilityLevel, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultScalabilityLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct LOptionSystemData_GetDefaultScreenResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultScreenResolution) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultScreenResolution");
static_assert(sizeof(LOptionSystemData_GetDefaultScreenResolution) == 0x000008, "Wrong size on LOptionSystemData_GetDefaultScreenResolution");
static_assert(offsetof(LOptionSystemData_GetDefaultScreenResolution, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultScreenResolution::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultSelectableMouseSensitivityMultiplyIdx
// 0x0004 (0x0004 - 0x0000)
struct LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx");
static_assert(sizeof(LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx) == 0x000004, "Wrong size on LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx");
static_assert(offsetof(LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultSubtitleSize
// 0x0004 (0x0004 - 0x0000)
struct LOptionSystemData_GetDefaultSubtitleSize final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultSubtitleSize) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultSubtitleSize");
static_assert(sizeof(LOptionSystemData_GetDefaultSubtitleSize) == 0x000004, "Wrong size on LOptionSystemData_GetDefaultSubtitleSize");
static_assert(offsetof(LOptionSystemData_GetDefaultSubtitleSize, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultSubtitleSize::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultUseAutoNewTargetLockOn
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultUseAutoNewTargetLockOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultUseAutoNewTargetLockOn) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultUseAutoNewTargetLockOn");
static_assert(sizeof(LOptionSystemData_GetDefaultUseAutoNewTargetLockOn) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultUseAutoNewTargetLockOn");
static_assert(offsetof(LOptionSystemData_GetDefaultUseAutoNewTargetLockOn, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultUseAutoNewTargetLockOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultUseAutoTargeting
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultUseAutoTargeting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultUseAutoTargeting) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultUseAutoTargeting");
static_assert(sizeof(LOptionSystemData_GetDefaultUseAutoTargeting) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultUseAutoTargeting");
static_assert(offsetof(LOptionSystemData_GetDefaultUseAutoTargeting, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultUseAutoTargeting::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultUseHDR
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultUseHDR final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultUseHDR) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultUseHDR");
static_assert(sizeof(LOptionSystemData_GetDefaultUseHDR) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultUseHDR");
static_assert(offsetof(LOptionSystemData_GetDefaultUseHDR, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultUseHDR::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultVolumeIdx
// 0x0008 (0x0008 - 0x0000)
struct LOptionSystemData_GetDefaultVolumeIdx final
{
public:
	ELVolumeType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultVolumeIdx) == 0x000004, "Wrong alignment on LOptionSystemData_GetDefaultVolumeIdx");
static_assert(sizeof(LOptionSystemData_GetDefaultVolumeIdx) == 0x000008, "Wrong size on LOptionSystemData_GetDefaultVolumeIdx");
static_assert(offsetof(LOptionSystemData_GetDefaultVolumeIdx, InType) == 0x000000, "Member 'LOptionSystemData_GetDefaultVolumeIdx::InType' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetDefaultVolumeIdx, ReturnValue) == 0x000004, "Member 'LOptionSystemData_GetDefaultVolumeIdx::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetDefaultVSyncEnabled
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystemData_GetDefaultVSyncEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetDefaultVSyncEnabled) == 0x000001, "Wrong alignment on LOptionSystemData_GetDefaultVSyncEnabled");
static_assert(sizeof(LOptionSystemData_GetDefaultVSyncEnabled) == 0x000001, "Wrong size on LOptionSystemData_GetDefaultVSyncEnabled");
static_assert(offsetof(LOptionSystemData_GetDefaultVSyncEnabled, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetDefaultVSyncEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableCameraSpeeds
// 0x0018 (0x0018 - 0x0000)
struct LOptionSystemData_GetSelectableCameraSpeeds final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPad;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableCameraSpeeds) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableCameraSpeeds");
static_assert(sizeof(LOptionSystemData_GetSelectableCameraSpeeds) == 0x000018, "Wrong size on LOptionSystemData_GetSelectableCameraSpeeds");
static_assert(offsetof(LOptionSystemData_GetSelectableCameraSpeeds, InRotator) == 0x000000, "Member 'LOptionSystemData_GetSelectableCameraSpeeds::InRotator' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetSelectableCameraSpeeds, IsPad) == 0x000001, "Member 'LOptionSystemData_GetSelectableCameraSpeeds::IsPad' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetSelectableCameraSpeeds, ReturnValue) == 0x000008, "Member 'LOptionSystemData_GetSelectableCameraSpeeds::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableDeadZone
// 0x0018 (0x0018 - 0x0000)
struct LOptionSystemData_GetSelectableDeadZone final
{
public:
	bool                                          LeftStick;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableDeadZone) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableDeadZone");
static_assert(sizeof(LOptionSystemData_GetSelectableDeadZone) == 0x000018, "Wrong size on LOptionSystemData_GetSelectableDeadZone");
static_assert(offsetof(LOptionSystemData_GetSelectableDeadZone, LeftStick) == 0x000000, "Member 'LOptionSystemData_GetSelectableDeadZone::LeftStick' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetSelectableDeadZone, ReturnValue) == 0x000008, "Member 'LOptionSystemData_GetSelectableDeadZone::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableForceFeedback
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystemData_GetSelectableForceFeedback final
{
public:
	TArray<float>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableForceFeedback) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableForceFeedback");
static_assert(sizeof(LOptionSystemData_GetSelectableForceFeedback) == 0x000010, "Wrong size on LOptionSystemData_GetSelectableForceFeedback");
static_assert(offsetof(LOptionSystemData_GetSelectableForceFeedback, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetSelectableForceFeedback::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableFramerateLimits
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystemData_GetSelectableFramerateLimits final
{
public:
	TArray<float>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableFramerateLimits) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableFramerateLimits");
static_assert(sizeof(LOptionSystemData_GetSelectableFramerateLimits) == 0x000010, "Wrong size on LOptionSystemData_GetSelectableFramerateLimits");
static_assert(offsetof(LOptionSystemData_GetSelectableFramerateLimits, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetSelectableFramerateLimits::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableLanguages
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystemData_GetSelectableLanguages final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableLanguages) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableLanguages");
static_assert(sizeof(LOptionSystemData_GetSelectableLanguages) == 0x000010, "Wrong size on LOptionSystemData_GetSelectableLanguages");
static_assert(offsetof(LOptionSystemData_GetSelectableLanguages, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetSelectableLanguages::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableLockOnImportanceWeightMultiply
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply final
{
public:
	TArray<struct FLLockOnImportanceWeight>       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply");
static_assert(sizeof(LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply) == 0x000010, "Wrong size on LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply");
static_assert(offsetof(LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableMouseSensitivityMultiply
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystemData_GetSelectableMouseSensitivityMultiply final
{
public:
	TArray<float>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableMouseSensitivityMultiply) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableMouseSensitivityMultiply");
static_assert(sizeof(LOptionSystemData_GetSelectableMouseSensitivityMultiply) == 0x000010, "Wrong size on LOptionSystemData_GetSelectableMouseSensitivityMultiply");
static_assert(offsetof(LOptionSystemData_GetSelectableMouseSensitivityMultiply, ReturnValue) == 0x000000, "Member 'LOptionSystemData_GetSelectableMouseSensitivityMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystemData.GetSelectableVolumes
// 0x0018 (0x0018 - 0x0000)
struct LOptionSystemData_GetSelectableVolumes final
{
public:
	ELVolumeType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystemData_GetSelectableVolumes) == 0x000008, "Wrong alignment on LOptionSystemData_GetSelectableVolumes");
static_assert(sizeof(LOptionSystemData_GetSelectableVolumes) == 0x000018, "Wrong size on LOptionSystemData_GetSelectableVolumes");
static_assert(offsetof(LOptionSystemData_GetSelectableVolumes, InType) == 0x000000, "Member 'LOptionSystemData_GetSelectableVolumes::InType' has a wrong offset!");
static_assert(offsetof(LOptionSystemData_GetSelectableVolumes, ReturnValue) == 0x000008, "Member 'LOptionSystemData_GetSelectableVolumes::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.ChangeCorrectionHandle
// 0x0002 (0x0002 - 0x0000)
struct LWeaponItem_ChangeCorrectionHandle final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_ChangeCorrectionHandle) == 0x000001, "Wrong alignment on LWeaponItem_ChangeCorrectionHandle");
static_assert(sizeof(LWeaponItem_ChangeCorrectionHandle) == 0x000002, "Wrong size on LWeaponItem_ChangeCorrectionHandle");
static_assert(offsetof(LWeaponItem_ChangeCorrectionHandle, Type) == 0x000000, "Member 'LWeaponItem_ChangeCorrectionHandle::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_ChangeCorrectionHandle, ReturnValue) == 0x000001, "Member 'LWeaponItem_ChangeCorrectionHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.ConsumeSharpness
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_ConsumeSharpness final
{
public:
	int32                                         InConsumePoint;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBreakWeapon;                                    // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConsumed;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               TargetWeaponActor;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_ConsumeSharpness) == 0x000008, "Wrong alignment on LWeaponItem_ConsumeSharpness");
static_assert(sizeof(LWeaponItem_ConsumeSharpness) == 0x000010, "Wrong size on LWeaponItem_ConsumeSharpness");
static_assert(offsetof(LWeaponItem_ConsumeSharpness, InConsumePoint) == 0x000000, "Member 'LWeaponItem_ConsumeSharpness::InConsumePoint' has a wrong offset!");
static_assert(offsetof(LWeaponItem_ConsumeSharpness, CanBreakWeapon) == 0x000004, "Member 'LWeaponItem_ConsumeSharpness::CanBreakWeapon' has a wrong offset!");
static_assert(offsetof(LWeaponItem_ConsumeSharpness, bIsConsumed) == 0x000005, "Member 'LWeaponItem_ConsumeSharpness::bIsConsumed' has a wrong offset!");
static_assert(offsetof(LWeaponItem_ConsumeSharpness, TargetWeaponActor) == 0x000008, "Member 'LWeaponItem_ConsumeSharpness::TargetWeaponActor' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetSharpnessAbnormalStateCodeName
// 0x000C (0x000C - 0x0000)
struct LWeaponItem_GetSharpnessAbnormalStateCodeName final
{
public:
	ELBladeSharpnessType                          Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetSharpnessAbnormalStateCodeName) == 0x000004, "Wrong alignment on LWeaponItem_GetSharpnessAbnormalStateCodeName");
static_assert(sizeof(LWeaponItem_GetSharpnessAbnormalStateCodeName) == 0x00000C, "Wrong size on LWeaponItem_GetSharpnessAbnormalStateCodeName");
static_assert(offsetof(LWeaponItem_GetSharpnessAbnormalStateCodeName, Type) == 0x000000, "Member 'LWeaponItem_GetSharpnessAbnormalStateCodeName::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetSharpnessAbnormalStateCodeName, ReturnValue) == 0x000004, "Member 'LWeaponItem_GetSharpnessAbnormalStateCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetSharpnessDamageRatio
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetSharpnessDamageRatio final
{
public:
	ELBladeSharpnessType                          Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetSharpnessDamageRatio) == 0x000004, "Wrong alignment on LWeaponItem_GetSharpnessDamageRatio");
static_assert(sizeof(LWeaponItem_GetSharpnessDamageRatio) == 0x000008, "Wrong size on LWeaponItem_GetSharpnessDamageRatio");
static_assert(offsetof(LWeaponItem_GetSharpnessDamageRatio, Type) == 0x000000, "Member 'LWeaponItem_GetSharpnessDamageRatio::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetSharpnessDamageRatio, ReturnValue) == 0x000004, "Member 'LWeaponItem_GetSharpnessDamageRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetSharpnessDestructionRatio
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetSharpnessDestructionRatio final
{
public:
	ELBladeSharpnessType                          Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetSharpnessDestructionRatio) == 0x000004, "Wrong alignment on LWeaponItem_GetSharpnessDestructionRatio");
static_assert(sizeof(LWeaponItem_GetSharpnessDestructionRatio) == 0x000008, "Wrong size on LWeaponItem_GetSharpnessDestructionRatio");
static_assert(offsetof(LWeaponItem_GetSharpnessDestructionRatio, Type) == 0x000000, "Member 'LWeaponItem_GetSharpnessDestructionRatio::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetSharpnessDestructionRatio, ReturnValue) == 0x000004, "Member 'LWeaponItem_GetSharpnessDestructionRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetSharpnessRepulseLevel
// 0x0004 (0x0004 - 0x0000)
struct LWeaponItem_GetSharpnessRepulseLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetSharpnessRepulseLevel) == 0x000004, "Wrong alignment on LWeaponItem_GetSharpnessRepulseLevel");
static_assert(sizeof(LWeaponItem_GetSharpnessRepulseLevel) == 0x000004, "Wrong size on LWeaponItem_GetSharpnessRepulseLevel");
static_assert(offsetof(LWeaponItem_GetSharpnessRepulseLevel, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetSharpnessRepulseLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.IsOnHand
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_IsOnHand final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_IsOnHand) == 0x000001, "Wrong alignment on LWeaponItem_IsOnHand");
static_assert(sizeof(LWeaponItem_IsOnHand) == 0x000001, "Wrong size on LWeaponItem_IsOnHand");
static_assert(offsetof(LWeaponItem_IsOnHand, ReturnValue) == 0x000000, "Member 'LWeaponItem_IsOnHand::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.ReinforceBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_ReinforceBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_ReinforceBlade) == 0x000001, "Wrong alignment on LWeaponItem_ReinforceBlade");
static_assert(sizeof(LWeaponItem_ReinforceBlade) == 0x000001, "Wrong size on LWeaponItem_ReinforceBlade");
static_assert(offsetof(LWeaponItem_ReinforceBlade, ReturnValue) == 0x000000, "Member 'LWeaponItem_ReinforceBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.RestoreSharpness
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_RestoreSharpness final
{
public:
	int32                                         InPoint;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGrinding;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeaponItem_RestoreSharpness) == 0x000004, "Wrong alignment on LWeaponItem_RestoreSharpness");
static_assert(sizeof(LWeaponItem_RestoreSharpness) == 0x000008, "Wrong size on LWeaponItem_RestoreSharpness");
static_assert(offsetof(LWeaponItem_RestoreSharpness, InPoint) == 0x000000, "Member 'LWeaponItem_RestoreSharpness::InPoint' has a wrong offset!");
static_assert(offsetof(LWeaponItem_RestoreSharpness, IsGrinding) == 0x000004, "Member 'LWeaponItem_RestoreSharpness::IsGrinding' has a wrong offset!");

// Function ProjectP.LWeaponItem.SetHeroicWeapon
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_SetHeroicWeapon final
{
public:
	bool                                          bHeroic;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_SetHeroicWeapon) == 0x000001, "Wrong alignment on LWeaponItem_SetHeroicWeapon");
static_assert(sizeof(LWeaponItem_SetHeroicWeapon) == 0x000001, "Wrong size on LWeaponItem_SetHeroicWeapon");
static_assert(offsetof(LWeaponItem_SetHeroicWeapon, bHeroic) == 0x000000, "Member 'LWeaponItem_SetHeroicWeapon::bHeroic' has a wrong offset!");

// Function ProjectP.LWeaponItem.SetSharpnessPoint
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_SetSharpnessPoint final
{
public:
	int32                                         InSharpnessPoint;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGrinding;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeaponItem_SetSharpnessPoint) == 0x000004, "Wrong alignment on LWeaponItem_SetSharpnessPoint");
static_assert(sizeof(LWeaponItem_SetSharpnessPoint) == 0x000008, "Wrong size on LWeaponItem_SetSharpnessPoint");
static_assert(offsetof(LWeaponItem_SetSharpnessPoint, InSharpnessPoint) == 0x000000, "Member 'LWeaponItem_SetSharpnessPoint::InSharpnessPoint' has a wrong offset!");
static_assert(offsetof(LWeaponItem_SetSharpnessPoint, IsGrinding) == 0x000004, "Member 'LWeaponItem_SetSharpnessPoint::IsGrinding' has a wrong offset!");

// Function ProjectP.LWeaponItem.CanChangeCorrectionHandle
// 0x0002 (0x0002 - 0x0000)
struct LWeaponItem_CanChangeCorrectionHandle final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_CanChangeCorrectionHandle) == 0x000001, "Wrong alignment on LWeaponItem_CanChangeCorrectionHandle");
static_assert(sizeof(LWeaponItem_CanChangeCorrectionHandle) == 0x000002, "Wrong size on LWeaponItem_CanChangeCorrectionHandle");
static_assert(offsetof(LWeaponItem_CanChangeCorrectionHandle, Type) == 0x000000, "Member 'LWeaponItem_CanChangeCorrectionHandle::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_CanChangeCorrectionHandle, ReturnValue) == 0x000001, "Member 'LWeaponItem_CanChangeCorrectionHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.CanReinforceBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_CanReinforceBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_CanReinforceBlade) == 0x000001, "Wrong alignment on LWeaponItem_CanReinforceBlade");
static_assert(sizeof(LWeaponItem_CanReinforceBlade) == 0x000001, "Wrong size on LWeaponItem_CanReinforceBlade");
static_assert(offsetof(LWeaponItem_CanReinforceBlade, ReturnValue) == 0x000000, "Member 'LWeaponItem_CanReinforceBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeCodeName
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetBladeCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeCodeName) == 0x000004, "Wrong alignment on LWeaponItem_GetBladeCodeName");
static_assert(sizeof(LWeaponItem_GetBladeCodeName) == 0x000008, "Wrong size on LWeaponItem_GetBladeCodeName");
static_assert(offsetof(LWeaponItem_GetBladeCodeName, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetBladeCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeCommonInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetBladeCommonInfo final
{
public:
	struct FItemCommonInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeCommonInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetBladeCommonInfo");
static_assert(sizeof(LWeaponItem_GetBladeCommonInfo) == 0x000008, "Wrong size on LWeaponItem_GetBladeCommonInfo");
static_assert(offsetof(LWeaponItem_GetBladeCommonInfo, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetBladeCommonInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeImageResource
// 0x0028 (0x0028 - 0x0000)
struct LWeaponItem_GetBladeImageResource final
{
public:
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeImageResource) == 0x000008, "Wrong alignment on LWeaponItem_GetBladeImageResource");
static_assert(sizeof(LWeaponItem_GetBladeImageResource) == 0x000028, "Wrong size on LWeaponItem_GetBladeImageResource");
static_assert(offsetof(LWeaponItem_GetBladeImageResource, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetBladeImageResource::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetBladeInfo final
{
public:
	struct FItemBladeInfoPtr                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetBladeInfo");
static_assert(sizeof(LWeaponItem_GetBladeInfo) == 0x000008, "Wrong size on LWeaponItem_GetBladeInfo");
static_assert(offsetof(LWeaponItem_GetBladeInfo, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetBladeInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeReinforceInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetBladeReinforceInfo final
{
public:
	struct FItemWeaponReinforceInfoPtr            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeReinforceInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetBladeReinforceInfo");
static_assert(sizeof(LWeaponItem_GetBladeReinforceInfo) == 0x000008, "Wrong size on LWeaponItem_GetBladeReinforceInfo");
static_assert(offsetof(LWeaponItem_GetBladeReinforceInfo, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetBladeReinforceInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeStat
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_GetBladeStat final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeStat) == 0x000008, "Wrong alignment on LWeaponItem_GetBladeStat");
static_assert(sizeof(LWeaponItem_GetBladeStat) == 0x000010, "Wrong size on LWeaponItem_GetBladeStat");
static_assert(offsetof(LWeaponItem_GetBladeStat, InOwner) == 0x000000, "Member 'LWeaponItem_GetBladeStat::InOwner' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetBladeStat, InStat) == 0x000008, "Member 'LWeaponItem_GetBladeStat::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetBladeStat, WillReinforceDiffStat) == 0x000009, "Member 'LWeaponItem_GetBladeStat::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetBladeStat, ReturnValue) == 0x00000C, "Member 'LWeaponItem_GetBladeStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetBladeStatBonus
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_GetBladeStatBonus final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetBladeStatBonus) == 0x000008, "Wrong alignment on LWeaponItem_GetBladeStatBonus");
static_assert(sizeof(LWeaponItem_GetBladeStatBonus) == 0x000010, "Wrong size on LWeaponItem_GetBladeStatBonus");
static_assert(offsetof(LWeaponItem_GetBladeStatBonus, InOwner) == 0x000000, "Member 'LWeaponItem_GetBladeStatBonus::InOwner' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetBladeStatBonus, InStat) == 0x000008, "Member 'LWeaponItem_GetBladeStatBonus::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetBladeStatBonus, WillReinforceDiffStat) == 0x000009, "Member 'LWeaponItem_GetBladeStatBonus::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetBladeStatBonus, ReturnValue) == 0x00000C, "Member 'LWeaponItem_GetBladeStatBonus::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetCurrentSharpnessPoint
// 0x0004 (0x0004 - 0x0000)
struct LWeaponItem_GetCurrentSharpnessPoint final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetCurrentSharpnessPoint) == 0x000004, "Wrong alignment on LWeaponItem_GetCurrentSharpnessPoint");
static_assert(sizeof(LWeaponItem_GetCurrentSharpnessPoint) == 0x000004, "Wrong size on LWeaponItem_GetCurrentSharpnessPoint");
static_assert(offsetof(LWeaponItem_GetCurrentSharpnessPoint, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetCurrentSharpnessPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetCurrentSharpnessType
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_GetCurrentSharpnessType final
{
public:
	ELBladeSharpnessType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetCurrentSharpnessType) == 0x000001, "Wrong alignment on LWeaponItem_GetCurrentSharpnessType");
static_assert(sizeof(LWeaponItem_GetCurrentSharpnessType) == 0x000001, "Wrong size on LWeaponItem_GetCurrentSharpnessType");
static_assert(offsetof(LWeaponItem_GetCurrentSharpnessType, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetCurrentSharpnessType::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleChangeCorrectionInfo
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_GetHandleChangeCorrectionInfo final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHandleStatCorrectionChangeInfoPtr     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleChangeCorrectionInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetHandleChangeCorrectionInfo");
static_assert(sizeof(LWeaponItem_GetHandleChangeCorrectionInfo) == 0x000010, "Wrong size on LWeaponItem_GetHandleChangeCorrectionInfo");
static_assert(offsetof(LWeaponItem_GetHandleChangeCorrectionInfo, Type) == 0x000000, "Member 'LWeaponItem_GetHandleChangeCorrectionInfo::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleChangeCorrectionInfo, ReturnValue) == 0x000008, "Member 'LWeaponItem_GetHandleChangeCorrectionInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleChangedCorrectionType
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_GetHandleChangedCorrectionType final
{
public:
	ELStatCorrectChangeType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleChangedCorrectionType) == 0x000001, "Wrong alignment on LWeaponItem_GetHandleChangedCorrectionType");
static_assert(sizeof(LWeaponItem_GetHandleChangedCorrectionType) == 0x000001, "Wrong size on LWeaponItem_GetHandleChangedCorrectionType");
static_assert(offsetof(LWeaponItem_GetHandleChangedCorrectionType, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetHandleChangedCorrectionType::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleCodeName
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetHandleCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleCodeName) == 0x000004, "Wrong alignment on LWeaponItem_GetHandleCodeName");
static_assert(sizeof(LWeaponItem_GetHandleCodeName) == 0x000008, "Wrong size on LWeaponItem_GetHandleCodeName");
static_assert(offsetof(LWeaponItem_GetHandleCodeName, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetHandleCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleCommonInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetHandleCommonInfo final
{
public:
	struct FItemCommonInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleCommonInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetHandleCommonInfo");
static_assert(sizeof(LWeaponItem_GetHandleCommonInfo) == 0x000008, "Wrong size on LWeaponItem_GetHandleCommonInfo");
static_assert(offsetof(LWeaponItem_GetHandleCommonInfo, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetHandleCommonInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleCorrectionGrade
// 0x000C (0x000C - 0x0000)
struct LWeaponItem_GetHandleCorrectionGrade final
{
public:
	ELFirstStat                                   Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStatCorrectChangeType                       WillBeChangeCorrection;                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OutStackLevel;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHandleCorrectResultGrade                    ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeaponItem_GetHandleCorrectionGrade) == 0x000004, "Wrong alignment on LWeaponItem_GetHandleCorrectionGrade");
static_assert(sizeof(LWeaponItem_GetHandleCorrectionGrade) == 0x00000C, "Wrong size on LWeaponItem_GetHandleCorrectionGrade");
static_assert(offsetof(LWeaponItem_GetHandleCorrectionGrade, Type) == 0x000000, "Member 'LWeaponItem_GetHandleCorrectionGrade::Type' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleCorrectionGrade, WillBeChangeCorrection) == 0x000001, "Member 'LWeaponItem_GetHandleCorrectionGrade::WillBeChangeCorrection' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleCorrectionGrade, OutStackLevel) == 0x000004, "Member 'LWeaponItem_GetHandleCorrectionGrade::OutStackLevel' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleCorrectionGrade, ReturnValue) == 0x000008, "Member 'LWeaponItem_GetHandleCorrectionGrade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleImageResource
// 0x0028 (0x0028 - 0x0000)
struct LWeaponItem_GetHandleImageResource final
{
public:
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleImageResource) == 0x000008, "Wrong alignment on LWeaponItem_GetHandleImageResource");
static_assert(sizeof(LWeaponItem_GetHandleImageResource) == 0x000028, "Wrong size on LWeaponItem_GetHandleImageResource");
static_assert(offsetof(LWeaponItem_GetHandleImageResource, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetHandleImageResource::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetHandleInfo final
{
public:
	struct FItemHandleInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetHandleInfo");
static_assert(sizeof(LWeaponItem_GetHandleInfo) == 0x000008, "Wrong size on LWeaponItem_GetHandleInfo");
static_assert(offsetof(LWeaponItem_GetHandleInfo, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetHandleInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleStat
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_GetHandleStat final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleStat) == 0x000008, "Wrong alignment on LWeaponItem_GetHandleStat");
static_assert(sizeof(LWeaponItem_GetHandleStat) == 0x000010, "Wrong size on LWeaponItem_GetHandleStat");
static_assert(offsetof(LWeaponItem_GetHandleStat, InOwner) == 0x000000, "Member 'LWeaponItem_GetHandleStat::InOwner' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleStat, InStat) == 0x000008, "Member 'LWeaponItem_GetHandleStat::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleStat, ReturnValue) == 0x00000C, "Member 'LWeaponItem_GetHandleStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHandleStatBonus
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_GetHandleStatBonus final
{
public:
	class AActor*                                 InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHandleStatBonus) == 0x000008, "Wrong alignment on LWeaponItem_GetHandleStatBonus");
static_assert(sizeof(LWeaponItem_GetHandleStatBonus) == 0x000010, "Wrong size on LWeaponItem_GetHandleStatBonus");
static_assert(offsetof(LWeaponItem_GetHandleStatBonus, InOwner) == 0x000000, "Member 'LWeaponItem_GetHandleStatBonus::InOwner' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleStatBonus, InStat) == 0x000008, "Member 'LWeaponItem_GetHandleStatBonus::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetHandleStatBonus, ReturnValue) == 0x00000C, "Member 'LWeaponItem_GetHandleStatBonus::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetHeroicImageResource
// 0x0028 (0x0028 - 0x0000)
struct LWeaponItem_GetHeroicImageResource final
{
public:
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetHeroicImageResource) == 0x000008, "Wrong alignment on LWeaponItem_GetHeroicImageResource");
static_assert(sizeof(LWeaponItem_GetHeroicImageResource) == 0x000028, "Wrong size on LWeaponItem_GetHeroicImageResource");
static_assert(offsetof(LWeaponItem_GetHeroicImageResource, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetHeroicImageResource::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetNecessityFirstStat
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetNecessityFirstStat final
{
public:
	ELFirstStat                                   InStat;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetNecessityFirstStat) == 0x000004, "Wrong alignment on LWeaponItem_GetNecessityFirstStat");
static_assert(sizeof(LWeaponItem_GetNecessityFirstStat) == 0x000008, "Wrong size on LWeaponItem_GetNecessityFirstStat");
static_assert(offsetof(LWeaponItem_GetNecessityFirstStat, InStat) == 0x000000, "Member 'LWeaponItem_GetNecessityFirstStat::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetNecessityFirstStat, ReturnValue) == 0x000004, "Member 'LWeaponItem_GetNecessityFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetNextBladeReinforceInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetNextBladeReinforceInfo final
{
public:
	struct FItemWeaponReinforceInfoPtr            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetNextBladeReinforceInfo) == 0x000008, "Wrong alignment on LWeaponItem_GetNextBladeReinforceInfo");
static_assert(sizeof(LWeaponItem_GetNextBladeReinforceInfo) == 0x000008, "Wrong size on LWeaponItem_GetNextBladeReinforceInfo");
static_assert(offsetof(LWeaponItem_GetNextBladeReinforceInfo, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetNextBladeReinforceInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetRawBladeStat
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetRawBladeStat final
{
public:
	ELSecondStat                                  InStat;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WillReinforceDiffStat;                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetRawBladeStat) == 0x000004, "Wrong alignment on LWeaponItem_GetRawBladeStat");
static_assert(sizeof(LWeaponItem_GetRawBladeStat) == 0x000008, "Wrong size on LWeaponItem_GetRawBladeStat");
static_assert(offsetof(LWeaponItem_GetRawBladeStat, InStat) == 0x000000, "Member 'LWeaponItem_GetRawBladeStat::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetRawBladeStat, WillReinforceDiffStat) == 0x000001, "Member 'LWeaponItem_GetRawBladeStat::WillReinforceDiffStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetRawBladeStat, ReturnValue) == 0x000004, "Member 'LWeaponItem_GetRawBladeStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetRawHandleStat
// 0x0008 (0x0008 - 0x0000)
struct LWeaponItem_GetRawHandleStat final
{
public:
	ELSecondStat                                  InStat;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetRawHandleStat) == 0x000004, "Wrong alignment on LWeaponItem_GetRawHandleStat");
static_assert(sizeof(LWeaponItem_GetRawHandleStat) == 0x000008, "Wrong size on LWeaponItem_GetRawHandleStat");
static_assert(offsetof(LWeaponItem_GetRawHandleStat, InStat) == 0x000000, "Member 'LWeaponItem_GetRawHandleStat::InStat' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetRawHandleStat, ReturnValue) == 0x000004, "Member 'LWeaponItem_GetRawHandleStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetSeparatedWeaponParts
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_GetSeparatedWeaponParts final
{
public:
	class ULItem*                                 OutHandleItem;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 OutBladeItem;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetSeparatedWeaponParts) == 0x000008, "Wrong alignment on LWeaponItem_GetSeparatedWeaponParts");
static_assert(sizeof(LWeaponItem_GetSeparatedWeaponParts) == 0x000010, "Wrong size on LWeaponItem_GetSeparatedWeaponParts");
static_assert(offsetof(LWeaponItem_GetSeparatedWeaponParts, OutHandleItem) == 0x000000, "Member 'LWeaponItem_GetSeparatedWeaponParts::OutHandleItem' has a wrong offset!");
static_assert(offsetof(LWeaponItem_GetSeparatedWeaponParts, OutBladeItem) == 0x000008, "Member 'LWeaponItem_GetSeparatedWeaponParts::OutBladeItem' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetSharpnessRecoverRatio
// 0x0004 (0x0004 - 0x0000)
struct LWeaponItem_GetSharpnessRecoverRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetSharpnessRecoverRatio) == 0x000004, "Wrong alignment on LWeaponItem_GetSharpnessRecoverRatio");
static_assert(sizeof(LWeaponItem_GetSharpnessRecoverRatio) == 0x000004, "Wrong size on LWeaponItem_GetSharpnessRecoverRatio");
static_assert(offsetof(LWeaponItem_GetSharpnessRecoverRatio, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetSharpnessRecoverRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetWeaponElementalType
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_GetWeaponElementalType final
{
public:
	ELElementDamageType                           ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetWeaponElementalType) == 0x000001, "Wrong alignment on LWeaponItem_GetWeaponElementalType");
static_assert(sizeof(LWeaponItem_GetWeaponElementalType) == 0x000001, "Wrong size on LWeaponItem_GetWeaponElementalType");
static_assert(offsetof(LWeaponItem_GetWeaponElementalType, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetWeaponElementalType::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.GetWeaponName
// 0x0018 (0x0018 - 0x0000)
struct LWeaponItem_GetWeaponName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_GetWeaponName) == 0x000008, "Wrong alignment on LWeaponItem_GetWeaponName");
static_assert(sizeof(LWeaponItem_GetWeaponName) == 0x000018, "Wrong size on LWeaponItem_GetWeaponName");
static_assert(offsetof(LWeaponItem_GetWeaponName, ReturnValue) == 0x000000, "Member 'LWeaponItem_GetWeaponName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.HasBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_HasBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_HasBlade) == 0x000001, "Wrong alignment on LWeaponItem_HasBlade");
static_assert(sizeof(LWeaponItem_HasBlade) == 0x000001, "Wrong size on LWeaponItem_HasBlade");
static_assert(offsetof(LWeaponItem_HasBlade, ReturnValue) == 0x000000, "Member 'LWeaponItem_HasBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.IsChangedCorrectionHandle
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_IsChangedCorrectionHandle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_IsChangedCorrectionHandle) == 0x000001, "Wrong alignment on LWeaponItem_IsChangedCorrectionHandle");
static_assert(sizeof(LWeaponItem_IsChangedCorrectionHandle) == 0x000001, "Wrong size on LWeaponItem_IsChangedCorrectionHandle");
static_assert(offsetof(LWeaponItem_IsChangedCorrectionHandle, ReturnValue) == 0x000000, "Member 'LWeaponItem_IsChangedCorrectionHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.IsHeroicWeapon
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_IsHeroicWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_IsHeroicWeapon) == 0x000001, "Wrong alignment on LWeaponItem_IsHeroicWeapon");
static_assert(sizeof(LWeaponItem_IsHeroicWeapon) == 0x000001, "Wrong size on LWeaponItem_IsHeroicWeapon");
static_assert(offsetof(LWeaponItem_IsHeroicWeapon, ReturnValue) == 0x000000, "Member 'LWeaponItem_IsHeroicWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.IsOriginalWeapon
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_IsOriginalWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_IsOriginalWeapon) == 0x000001, "Wrong alignment on LWeaponItem_IsOriginalWeapon");
static_assert(sizeof(LWeaponItem_IsOriginalWeapon) == 0x000001, "Wrong size on LWeaponItem_IsOriginalWeapon");
static_assert(offsetof(LWeaponItem_IsOriginalWeapon, ReturnValue) == 0x000000, "Member 'LWeaponItem_IsOriginalWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.IsReinforcedBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_IsReinforcedBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_IsReinforcedBlade) == 0x000001, "Wrong alignment on LWeaponItem_IsReinforcedBlade");
static_assert(sizeof(LWeaponItem_IsReinforcedBlade) == 0x000001, "Wrong size on LWeaponItem_IsReinforcedBlade");
static_assert(offsetof(LWeaponItem_IsReinforcedBlade, ReturnValue) == 0x000000, "Member 'LWeaponItem_IsReinforcedBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.IsSharpnessMax
// 0x0001 (0x0001 - 0x0000)
struct LWeaponItem_IsSharpnessMax final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_IsSharpnessMax) == 0x000001, "Wrong alignment on LWeaponItem_IsSharpnessMax");
static_assert(sizeof(LWeaponItem_IsSharpnessMax) == 0x000001, "Wrong size on LWeaponItem_IsSharpnessMax");
static_assert(offsetof(LWeaponItem_IsSharpnessMax, ReturnValue) == 0x000000, "Member 'LWeaponItem_IsSharpnessMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponItem.SeparateWeaponPart
// 0x0010 (0x0010 - 0x0000)
struct LWeaponItem_SeparateWeaponPart final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponItem_SeparateWeaponPart) == 0x000008, "Wrong alignment on LWeaponItem_SeparateWeaponPart");
static_assert(sizeof(LWeaponItem_SeparateWeaponPart) == 0x000010, "Wrong size on LWeaponItem_SeparateWeaponPart");
static_assert(offsetof(LWeaponItem_SeparateWeaponPart, ReturnValue) == 0x000000, "Member 'LWeaponItem_SeparateWeaponPart::ReturnValue' has a wrong offset!");

// Function ProjectP.LSubOption.ResetToDefault
// 0x0001 (0x0001 - 0x0000)
struct LSubOption_ResetToDefault final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSubOption_ResetToDefault) == 0x000001, "Wrong alignment on LSubOption_ResetToDefault");
static_assert(sizeof(LSubOption_ResetToDefault) == 0x000001, "Wrong size on LSubOption_ResetToDefault");
static_assert(offsetof(LSubOption_ResetToDefault, ReturnValue) == 0x000000, "Member 'LSubOption_ResetToDefault::ReturnValue' has a wrong offset!");

// Function ProjectP.LDispalySoundOption.ApplySoundOptionMultiply
// 0x0008 (0x0008 - 0x0000)
struct LDispalySoundOption_ApplySoundOptionMultiply final
{
public:
	ELVolumeType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InValue;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDispalySoundOption_ApplySoundOptionMultiply) == 0x000004, "Wrong alignment on LDispalySoundOption_ApplySoundOptionMultiply");
static_assert(sizeof(LDispalySoundOption_ApplySoundOptionMultiply) == 0x000008, "Wrong size on LDispalySoundOption_ApplySoundOptionMultiply");
static_assert(offsetof(LDispalySoundOption_ApplySoundOptionMultiply, InType) == 0x000000, "Member 'LDispalySoundOption_ApplySoundOptionMultiply::InType' has a wrong offset!");
static_assert(offsetof(LDispalySoundOption_ApplySoundOptionMultiply, InValue) == 0x000004, "Member 'LDispalySoundOption_ApplySoundOptionMultiply::InValue' has a wrong offset!");

// Function ProjectP.LDispalySoundOption.GetVolumeStep
// 0x0008 (0x0008 - 0x0000)
struct LDispalySoundOption_GetVolumeStep final
{
public:
	ELVolumeType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDispalySoundOption_GetVolumeStep) == 0x000004, "Wrong alignment on LDispalySoundOption_GetVolumeStep");
static_assert(sizeof(LDispalySoundOption_GetVolumeStep) == 0x000008, "Wrong size on LDispalySoundOption_GetVolumeStep");
static_assert(offsetof(LDispalySoundOption_GetVolumeStep, InType) == 0x000000, "Member 'LDispalySoundOption_GetVolumeStep::InType' has a wrong offset!");
static_assert(offsetof(LDispalySoundOption_GetVolumeStep, ReturnValue) == 0x000004, "Member 'LDispalySoundOption_GetVolumeStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LDispalySoundOption.SetVolumeStep
// 0x000C (0x000C - 0x0000)
struct LDispalySoundOption_SetVolumeStep final
{
public:
	ELVolumeType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InStep;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LDispalySoundOption_SetVolumeStep) == 0x000004, "Wrong alignment on LDispalySoundOption_SetVolumeStep");
static_assert(sizeof(LDispalySoundOption_SetVolumeStep) == 0x00000C, "Wrong size on LDispalySoundOption_SetVolumeStep");
static_assert(offsetof(LDispalySoundOption_SetVolumeStep, InType) == 0x000000, "Member 'LDispalySoundOption_SetVolumeStep::InType' has a wrong offset!");
static_assert(offsetof(LDispalySoundOption_SetVolumeStep, InStep) == 0x000004, "Member 'LDispalySoundOption_SetVolumeStep::InStep' has a wrong offset!");
static_assert(offsetof(LDispalySoundOption_SetVolumeStep, ReturnValue) == 0x000008, "Member 'LDispalySoundOption_SetVolumeStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_Interact
// 0x00A8 (0x00A8 - 0x0000)
struct LInteractComponent_OnComponentBeginOverlapped_Interact final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractComponent_OnComponentBeginOverlapped_Interact) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentBeginOverlapped_Interact");
static_assert(sizeof(LInteractComponent_OnComponentBeginOverlapped_Interact) == 0x0000A8, "Wrong size on LInteractComponent_OnComponentBeginOverlapped_Interact");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Interact, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentBeginOverlapped_Interact::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Interact, Other) == 0x000008, "Member 'LInteractComponent_OnComponentBeginOverlapped_Interact::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Interact, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentBeginOverlapped_Interact::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Interact, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentBeginOverlapped_Interact::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Interact, bFromSweep) == 0x00001C, "Member 'LInteractComponent_OnComponentBeginOverlapped_Interact::bFromSweep' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Interact, OverlapInfo) == 0x000020, "Member 'LInteractComponent_OnComponentBeginOverlapped_Interact::OverlapInfo' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_InteractVolume
// 0x00A8 (0x00A8 - 0x0000)
struct LInteractComponent_OnComponentBeginOverlapped_InteractVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentBeginOverlapped_InteractVolume");
static_assert(sizeof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume) == 0x0000A8, "Wrong size on LInteractComponent_OnComponentBeginOverlapped_InteractVolume");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentBeginOverlapped_InteractVolume::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume, Other) == 0x000008, "Member 'LInteractComponent_OnComponentBeginOverlapped_InteractVolume::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentBeginOverlapped_InteractVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentBeginOverlapped_InteractVolume::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume, bFromSweep) == 0x00001C, "Member 'LInteractComponent_OnComponentBeginOverlapped_InteractVolume::bFromSweep' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_InteractVolume, OverlapInfo) == 0x000020, "Member 'LInteractComponent_OnComponentBeginOverlapped_InteractVolume::OverlapInfo' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_LookAt
// 0x00A8 (0x00A8 - 0x0000)
struct LInteractComponent_OnComponentBeginOverlapped_LookAt final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractComponent_OnComponentBeginOverlapped_LookAt) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentBeginOverlapped_LookAt");
static_assert(sizeof(LInteractComponent_OnComponentBeginOverlapped_LookAt) == 0x0000A8, "Wrong size on LInteractComponent_OnComponentBeginOverlapped_LookAt");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_LookAt, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentBeginOverlapped_LookAt::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_LookAt, Other) == 0x000008, "Member 'LInteractComponent_OnComponentBeginOverlapped_LookAt::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_LookAt, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentBeginOverlapped_LookAt::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_LookAt, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentBeginOverlapped_LookAt::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_LookAt, bFromSweep) == 0x00001C, "Member 'LInteractComponent_OnComponentBeginOverlapped_LookAt::bFromSweep' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_LookAt, OverlapInfo) == 0x000020, "Member 'LInteractComponent_OnComponentBeginOverlapped_LookAt::OverlapInfo' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_Radius
// 0x00A8 (0x00A8 - 0x0000)
struct LInteractComponent_OnComponentBeginOverlapped_Radius final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractComponent_OnComponentBeginOverlapped_Radius) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentBeginOverlapped_Radius");
static_assert(sizeof(LInteractComponent_OnComponentBeginOverlapped_Radius) == 0x0000A8, "Wrong size on LInteractComponent_OnComponentBeginOverlapped_Radius");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Radius, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentBeginOverlapped_Radius::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Radius, Other) == 0x000008, "Member 'LInteractComponent_OnComponentBeginOverlapped_Radius::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Radius, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentBeginOverlapped_Radius::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Radius, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentBeginOverlapped_Radius::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Radius, bFromSweep) == 0x00001C, "Member 'LInteractComponent_OnComponentBeginOverlapped_Radius::bFromSweep' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentBeginOverlapped_Radius, OverlapInfo) == 0x000020, "Member 'LInteractComponent_OnComponentBeginOverlapped_Radius::OverlapInfo' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_Interact
// 0x0020 (0x0020 - 0x0000)
struct LInteractComponent_OnComponentEndOverlapped_Interact final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LInteractComponent_OnComponentEndOverlapped_Interact) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentEndOverlapped_Interact");
static_assert(sizeof(LInteractComponent_OnComponentEndOverlapped_Interact) == 0x000020, "Wrong size on LInteractComponent_OnComponentEndOverlapped_Interact");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Interact, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentEndOverlapped_Interact::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Interact, Other) == 0x000008, "Member 'LInteractComponent_OnComponentEndOverlapped_Interact::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Interact, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentEndOverlapped_Interact::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Interact, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentEndOverlapped_Interact::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_InteractVolume
// 0x0020 (0x0020 - 0x0000)
struct LInteractComponent_OnComponentEndOverlapped_InteractVolume final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LInteractComponent_OnComponentEndOverlapped_InteractVolume) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentEndOverlapped_InteractVolume");
static_assert(sizeof(LInteractComponent_OnComponentEndOverlapped_InteractVolume) == 0x000020, "Wrong size on LInteractComponent_OnComponentEndOverlapped_InteractVolume");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_InteractVolume, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentEndOverlapped_InteractVolume::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_InteractVolume, Other) == 0x000008, "Member 'LInteractComponent_OnComponentEndOverlapped_InteractVolume::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_InteractVolume, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentEndOverlapped_InteractVolume::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_InteractVolume, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentEndOverlapped_InteractVolume::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_LookAt
// 0x0020 (0x0020 - 0x0000)
struct LInteractComponent_OnComponentEndOverlapped_LookAt final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LInteractComponent_OnComponentEndOverlapped_LookAt) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentEndOverlapped_LookAt");
static_assert(sizeof(LInteractComponent_OnComponentEndOverlapped_LookAt) == 0x000020, "Wrong size on LInteractComponent_OnComponentEndOverlapped_LookAt");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_LookAt, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentEndOverlapped_LookAt::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_LookAt, Other) == 0x000008, "Member 'LInteractComponent_OnComponentEndOverlapped_LookAt::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_LookAt, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentEndOverlapped_LookAt::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_LookAt, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentEndOverlapped_LookAt::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_Radius
// 0x0020 (0x0020 - 0x0000)
struct LInteractComponent_OnComponentEndOverlapped_Radius final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LInteractComponent_OnComponentEndOverlapped_Radius) == 0x000008, "Wrong alignment on LInteractComponent_OnComponentEndOverlapped_Radius");
static_assert(sizeof(LInteractComponent_OnComponentEndOverlapped_Radius) == 0x000020, "Wrong size on LInteractComponent_OnComponentEndOverlapped_Radius");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Radius, OverlappedComp) == 0x000000, "Member 'LInteractComponent_OnComponentEndOverlapped_Radius::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Radius, Other) == 0x000008, "Member 'LInteractComponent_OnComponentEndOverlapped_Radius::Other' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Radius, OtherComp) == 0x000010, "Member 'LInteractComponent_OnComponentEndOverlapped_Radius::OtherComp' has a wrong offset!");
static_assert(offsetof(LInteractComponent_OnComponentEndOverlapped_Radius, OtherBodyIndex) == 0x000018, "Member 'LInteractComponent_OnComponentEndOverlapped_Radius::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LKeySettingOption.ApplyBackupCustomizedInputInfo
// 0x0001 (0x0001 - 0x0000)
struct LKeySettingOption_ApplyBackupCustomizedInputInfo final
{
public:
	ELInputOptionType                             InControllerType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeySettingOption_ApplyBackupCustomizedInputInfo) == 0x000001, "Wrong alignment on LKeySettingOption_ApplyBackupCustomizedInputInfo");
static_assert(sizeof(LKeySettingOption_ApplyBackupCustomizedInputInfo) == 0x000001, "Wrong size on LKeySettingOption_ApplyBackupCustomizedInputInfo");
static_assert(offsetof(LKeySettingOption_ApplyBackupCustomizedInputInfo, InControllerType) == 0x000000, "Member 'LKeySettingOption_ApplyBackupCustomizedInputInfo::InControllerType' has a wrong offset!");

// Function ProjectP.LKeySettingOption.ApplyCustomizedInput
// 0x0002 (0x0002 - 0x0000)
struct LKeySettingOption_ApplyCustomizedInput final
{
public:
	ELInputOptionType                             InControllerType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeySettingOption_ApplyCustomizedInput) == 0x000001, "Wrong alignment on LKeySettingOption_ApplyCustomizedInput");
static_assert(sizeof(LKeySettingOption_ApplyCustomizedInput) == 0x000002, "Wrong size on LKeySettingOption_ApplyCustomizedInput");
static_assert(offsetof(LKeySettingOption_ApplyCustomizedInput, InControllerType) == 0x000000, "Member 'LKeySettingOption_ApplyCustomizedInput::InControllerType' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_ApplyCustomizedInput, ReturnValue) == 0x000001, "Member 'LKeySettingOption_ApplyCustomizedInput::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeySettingOption.ChangeInputKey
// 0x0028 (0x0028 - 0x0000)
struct LKeySettingOption_ChangeInputKey final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LKeySettingOption_ChangeInputKey) == 0x000008, "Wrong alignment on LKeySettingOption_ChangeInputKey");
static_assert(sizeof(LKeySettingOption_ChangeInputKey) == 0x000028, "Wrong size on LKeySettingOption_ChangeInputKey");
static_assert(offsetof(LKeySettingOption_ChangeInputKey, InputAction) == 0x000000, "Member 'LKeySettingOption_ChangeInputKey::InputAction' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_ChangeInputKey, Key) == 0x000008, "Member 'LKeySettingOption_ChangeInputKey::Key' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_ChangeInputKey, ReturnValue) == 0x000020, "Member 'LKeySettingOption_ChangeInputKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeySettingOption.FindPresetInputAction
// 0x0028 (0x0028 - 0x0000)
struct LKeySettingOption_FindPresetInputAction final
{
public:
	class FName                                   InPresetName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LKeySettingOption_FindPresetInputAction) == 0x000008, "Wrong alignment on LKeySettingOption_FindPresetInputAction");
static_assert(sizeof(LKeySettingOption_FindPresetInputAction) == 0x000028, "Wrong size on LKeySettingOption_FindPresetInputAction");
static_assert(offsetof(LKeySettingOption_FindPresetInputAction, InPresetName) == 0x000000, "Member 'LKeySettingOption_FindPresetInputAction::InPresetName' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_FindPresetInputAction, Key) == 0x000008, "Member 'LKeySettingOption_FindPresetInputAction::Key' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_FindPresetInputAction, ReturnValue) == 0x000020, "Member 'LKeySettingOption_FindPresetInputAction::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeySettingOption.FindPresetInputActionKey
// 0x0028 (0x0028 - 0x0000)
struct LKeySettingOption_FindPresetInputActionKey final
{
public:
	class FName                                   InPresetName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPCActionKeyType                             KeyType;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeySettingOption_FindPresetInputActionKey) == 0x000008, "Wrong alignment on LKeySettingOption_FindPresetInputActionKey");
static_assert(sizeof(LKeySettingOption_FindPresetInputActionKey) == 0x000028, "Wrong size on LKeySettingOption_FindPresetInputActionKey");
static_assert(offsetof(LKeySettingOption_FindPresetInputActionKey, InPresetName) == 0x000000, "Member 'LKeySettingOption_FindPresetInputActionKey::InPresetName' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_FindPresetInputActionKey, KeyType) == 0x000008, "Member 'LKeySettingOption_FindPresetInputActionKey::KeyType' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_FindPresetInputActionKey, ReturnValue) == 0x000010, "Member 'LKeySettingOption_FindPresetInputActionKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeySettingOption.GetCurrentPresetName
// 0x000C (0x000C - 0x0000)
struct LKeySettingOption_GetCurrentPresetName final
{
public:
	bool                                          IsGamePad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeySettingOption_GetCurrentPresetName) == 0x000004, "Wrong alignment on LKeySettingOption_GetCurrentPresetName");
static_assert(sizeof(LKeySettingOption_GetCurrentPresetName) == 0x00000C, "Wrong size on LKeySettingOption_GetCurrentPresetName");
static_assert(offsetof(LKeySettingOption_GetCurrentPresetName, IsGamePad) == 0x000000, "Member 'LKeySettingOption_GetCurrentPresetName::IsGamePad' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_GetCurrentPresetName, ReturnValue) == 0x000004, "Member 'LKeySettingOption_GetCurrentPresetName::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeySettingOption.GetSelectablePresetNames
// 0x0018 (0x0018 - 0x0000)
struct LKeySettingOption_GetSelectablePresetNames final
{
public:
	bool                                          IsGamePad;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeySettingOption_GetSelectablePresetNames) == 0x000008, "Wrong alignment on LKeySettingOption_GetSelectablePresetNames");
static_assert(sizeof(LKeySettingOption_GetSelectablePresetNames) == 0x000018, "Wrong size on LKeySettingOption_GetSelectablePresetNames");
static_assert(offsetof(LKeySettingOption_GetSelectablePresetNames, IsGamePad) == 0x000000, "Member 'LKeySettingOption_GetSelectablePresetNames::IsGamePad' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_GetSelectablePresetNames, ReturnValue) == 0x000008, "Member 'LKeySettingOption_GetSelectablePresetNames::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeySettingOption.OnClosedWindow
// 0x0008 (0x0008 - 0x0000)
struct LKeySettingOption_OnClosedWindow final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeySettingOption_OnClosedWindow) == 0x000004, "Wrong alignment on LKeySettingOption_OnClosedWindow");
static_assert(sizeof(LKeySettingOption_OnClosedWindow) == 0x000008, "Wrong size on LKeySettingOption_OnClosedWindow");
static_assert(offsetof(LKeySettingOption_OnClosedWindow, WidgetTableName) == 0x000000, "Member 'LKeySettingOption_OnClosedWindow::WidgetTableName' has a wrong offset!");

// Function ProjectP.LKeySettingOption.SetChangePreset
// 0x000C (0x000C - 0x0000)
struct LKeySettingOption_SetChangePreset final
{
public:
	class FName                                   InPresetName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LKeySettingOption_SetChangePreset) == 0x000004, "Wrong alignment on LKeySettingOption_SetChangePreset");
static_assert(sizeof(LKeySettingOption_SetChangePreset) == 0x00000C, "Wrong size on LKeySettingOption_SetChangePreset");
static_assert(offsetof(LKeySettingOption_SetChangePreset, InPresetName) == 0x000000, "Member 'LKeySettingOption_SetChangePreset::InPresetName' has a wrong offset!");
static_assert(offsetof(LKeySettingOption_SetChangePreset, ReturnValue) == 0x000008, "Member 'LKeySettingOption_SetChangePreset::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsActor.BoneMergingSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct LPartsActor_BoneMergingSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsActor_BoneMergingSkeletalMesh) == 0x000008, "Wrong alignment on LPartsActor_BoneMergingSkeletalMesh");
static_assert(sizeof(LPartsActor_BoneMergingSkeletalMesh) == 0x000008, "Wrong size on LPartsActor_BoneMergingSkeletalMesh");
static_assert(offsetof(LPartsActor_BoneMergingSkeletalMesh, Component) == 0x000000, "Member 'LPartsActor_BoneMergingSkeletalMesh::Component' has a wrong offset!");

// Function ProjectP.LPartsActor.DropParts
// 0x000C (0x000C - 0x0000)
struct LPartsActor_DropParts final
{
public:
	struct FVector                                LastImpulseDirection;                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsActor_DropParts) == 0x000004, "Wrong alignment on LPartsActor_DropParts");
static_assert(sizeof(LPartsActor_DropParts) == 0x00000C, "Wrong size on LPartsActor_DropParts");
static_assert(offsetof(LPartsActor_DropParts, LastImpulseDirection) == 0x000000, "Member 'LPartsActor_DropParts::LastImpulseDirection' has a wrong offset!");

// Function ProjectP.LPartsActor.FindDropMeshes
// 0x0010 (0x0010 - 0x0000)
struct LPartsActor_FindDropMeshes final
{
public:
	TArray<class UMeshComponent*>                 ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsActor_FindDropMeshes) == 0x000008, "Wrong alignment on LPartsActor_FindDropMeshes");
static_assert(sizeof(LPartsActor_FindDropMeshes) == 0x000010, "Wrong size on LPartsActor_FindDropMeshes");
static_assert(offsetof(LPartsActor_FindDropMeshes, ReturnValue) == 0x000000, "Member 'LPartsActor_FindDropMeshes::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsActor.GetOwnerCharacter
// 0x0008 (0x0008 - 0x0000)
struct LPartsActor_GetOwnerCharacter final
{
public:
	class ALCharacter*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsActor_GetOwnerCharacter) == 0x000008, "Wrong alignment on LPartsActor_GetOwnerCharacter");
static_assert(sizeof(LPartsActor_GetOwnerCharacter) == 0x000008, "Wrong size on LPartsActor_GetOwnerCharacter");
static_assert(offsetof(LPartsActor_GetOwnerCharacter, ReturnValue) == 0x000000, "Member 'LPartsActor_GetOwnerCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsActor.GetPartsAttachParent
// 0x0008 (0x0008 - 0x0000)
struct LPartsActor_GetPartsAttachParent final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsActor_GetPartsAttachParent) == 0x000008, "Wrong alignment on LPartsActor_GetPartsAttachParent");
static_assert(sizeof(LPartsActor_GetPartsAttachParent) == 0x000008, "Wrong size on LPartsActor_GetPartsAttachParent");
static_assert(offsetof(LPartsActor_GetPartsAttachParent, ReturnValue) == 0x000000, "Member 'LPartsActor_GetPartsAttachParent::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsActor.GetPartsComponent
// 0x0008 (0x0008 - 0x0000)
struct LPartsActor_GetPartsComponent final
{
public:
	class ULPartsComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsActor_GetPartsComponent) == 0x000008, "Wrong alignment on LPartsActor_GetPartsComponent");
static_assert(sizeof(LPartsActor_GetPartsComponent) == 0x000008, "Wrong size on LPartsActor_GetPartsComponent");
static_assert(offsetof(LPartsActor_GetPartsComponent, ReturnValue) == 0x000000, "Member 'LPartsActor_GetPartsComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractSystem.Dev_InteractStartTransform
// 0x0001 (0x0001 - 0x0000)
struct LInteractSystem_Dev_InteractStartTransform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractSystem_Dev_InteractStartTransform) == 0x000001, "Wrong alignment on LInteractSystem_Dev_InteractStartTransform");
static_assert(sizeof(LInteractSystem_Dev_InteractStartTransform) == 0x000001, "Wrong size on LInteractSystem_Dev_InteractStartTransform");
static_assert(offsetof(LInteractSystem_Dev_InteractStartTransform, ReturnValue) == 0x000000, "Member 'LInteractSystem_Dev_InteractStartTransform::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractSystem.GetDialogDebugInfo
// 0x0008 (0x0008 - 0x0000)
struct LInteractSystem_GetDialogDebugInfo final
{
public:
	class ULDialogDebugInfo*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractSystem_GetDialogDebugInfo) == 0x000008, "Wrong alignment on LInteractSystem_GetDialogDebugInfo");
static_assert(sizeof(LInteractSystem_GetDialogDebugInfo) == 0x000008, "Wrong size on LInteractSystem_GetDialogDebugInfo");
static_assert(offsetof(LInteractSystem_GetDialogDebugInfo, ReturnValue) == 0x000000, "Member 'LInteractSystem_GetDialogDebugInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractSystem.GetLastDialogingActor
// 0x0008 (0x0008 - 0x0000)
struct LInteractSystem_GetLastDialogingActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractSystem_GetLastDialogingActor) == 0x000008, "Wrong alignment on LInteractSystem_GetLastDialogingActor");
static_assert(sizeof(LInteractSystem_GetLastDialogingActor) == 0x000008, "Wrong size on LInteractSystem_GetLastDialogingActor");
static_assert(offsetof(LInteractSystem_GetLastDialogingActor, ReturnValue) == 0x000000, "Member 'LInteractSystem_GetLastDialogingActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractSystem.OnBlockDialog
// 0x0001 (0x0001 - 0x0000)
struct LInteractSystem_OnBlockDialog final
{
public:
	bool                                          InBlock;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractSystem_OnBlockDialog) == 0x000001, "Wrong alignment on LInteractSystem_OnBlockDialog");
static_assert(sizeof(LInteractSystem_OnBlockDialog) == 0x000001, "Wrong size on LInteractSystem_OnBlockDialog");
static_assert(offsetof(LInteractSystem_OnBlockDialog, InBlock) == 0x000000, "Member 'LInteractSystem_OnBlockDialog::InBlock' has a wrong offset!");

// Function ProjectP.LInteractSystem.OnClosedDialog
// 0x0008 (0x0008 - 0x0000)
struct LInteractSystem_OnClosedDialog final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractSystem_OnClosedDialog) == 0x000004, "Wrong alignment on LInteractSystem_OnClosedDialog");
static_assert(sizeof(LInteractSystem_OnClosedDialog) == 0x000008, "Wrong size on LInteractSystem_OnClosedDialog");
static_assert(offsetof(LInteractSystem_OnClosedDialog, WidgetTableName) == 0x000000, "Member 'LInteractSystem_OnClosedDialog::WidgetTableName' has a wrong offset!");

// Function ProjectP.LDamageCollisionComponent.BeginOverlapDamageCollision
// 0x00A8 (0x00A8 - 0x0000)
struct LDamageCollisionComponent_BeginOverlapDamageCollision final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDamageCollisionComponent_BeginOverlapDamageCollision) == 0x000008, "Wrong alignment on LDamageCollisionComponent_BeginOverlapDamageCollision");
static_assert(sizeof(LDamageCollisionComponent_BeginOverlapDamageCollision) == 0x0000A8, "Wrong size on LDamageCollisionComponent_BeginOverlapDamageCollision");
static_assert(offsetof(LDamageCollisionComponent_BeginOverlapDamageCollision, OverlappedComp) == 0x000000, "Member 'LDamageCollisionComponent_BeginOverlapDamageCollision::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_BeginOverlapDamageCollision, OtherActor) == 0x000008, "Member 'LDamageCollisionComponent_BeginOverlapDamageCollision::OtherActor' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_BeginOverlapDamageCollision, OtherComp) == 0x000010, "Member 'LDamageCollisionComponent_BeginOverlapDamageCollision::OtherComp' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_BeginOverlapDamageCollision, OtherBodyIndex) == 0x000018, "Member 'LDamageCollisionComponent_BeginOverlapDamageCollision::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_BeginOverlapDamageCollision, bFromSweep) == 0x00001C, "Member 'LDamageCollisionComponent_BeginOverlapDamageCollision::bFromSweep' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_BeginOverlapDamageCollision, OverlapInfo) == 0x000020, "Member 'LDamageCollisionComponent_BeginOverlapDamageCollision::OverlapInfo' has a wrong offset!");

// Function ProjectP.LDamageCollisionComponent.EndOverlapDamageCollision
// 0x0020 (0x0020 - 0x0000)
struct LDamageCollisionComponent_EndOverlapDamageCollision final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LDamageCollisionComponent_EndOverlapDamageCollision) == 0x000008, "Wrong alignment on LDamageCollisionComponent_EndOverlapDamageCollision");
static_assert(sizeof(LDamageCollisionComponent_EndOverlapDamageCollision) == 0x000020, "Wrong size on LDamageCollisionComponent_EndOverlapDamageCollision");
static_assert(offsetof(LDamageCollisionComponent_EndOverlapDamageCollision, OverlappedComp) == 0x000000, "Member 'LDamageCollisionComponent_EndOverlapDamageCollision::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_EndOverlapDamageCollision, OtherActor) == 0x000008, "Member 'LDamageCollisionComponent_EndOverlapDamageCollision::OtherActor' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_EndOverlapDamageCollision, OtherComp) == 0x000010, "Member 'LDamageCollisionComponent_EndOverlapDamageCollision::OtherComp' has a wrong offset!");
static_assert(offsetof(LDamageCollisionComponent_EndOverlapDamageCollision, OtherBodyIndex) == 0x000018, "Member 'LDamageCollisionComponent_EndOverlapDamageCollision::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LTransformDataAsset.AddObjectTransform
// 0x0040 (0x0040 - 0x0000)
struct LTransformDataAsset_AddObjectTransform final
{
public:
	class FName                                   TargetObjectName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocationTransform;                                 // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTransformDataAsset_AddObjectTransform) == 0x000010, "Wrong alignment on LTransformDataAsset_AddObjectTransform");
static_assert(sizeof(LTransformDataAsset_AddObjectTransform) == 0x000040, "Wrong size on LTransformDataAsset_AddObjectTransform");
static_assert(offsetof(LTransformDataAsset_AddObjectTransform, TargetObjectName) == 0x000000, "Member 'LTransformDataAsset_AddObjectTransform::TargetObjectName' has a wrong offset!");
static_assert(offsetof(LTransformDataAsset_AddObjectTransform, LocationTransform) == 0x000010, "Member 'LTransformDataAsset_AddObjectTransform::LocationTransform' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_On_FrenzyAction.OnEnterActionState
// 0x0018 (0x0018 - 0x0000)
struct LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState) == 0x000008, "Wrong alignment on LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState");
static_assert(sizeof(LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState) == 0x000018, "Wrong size on LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState");
static_assert(offsetof(LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState, ActMgrComponent) == 0x000000, "Member 'LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState, ActionState) == 0x000008, "Member 'LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState::ActionState' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState, IsPair) == 0x000010, "Member 'LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState::IsPair' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_On_FrenzyAction.OnLeaveActionState
// 0x0018 (0x0018 - 0x0000)
struct LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState) == 0x000008, "Wrong alignment on LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState");
static_assert(sizeof(LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState) == 0x000018, "Wrong size on LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState");
static_assert(offsetof(LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState, ActMgrComponent) == 0x000000, "Member 'LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState, ActionState) == 0x000008, "Member 'LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState::ActionState' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState, IsPair) == 0x000010, "Member 'LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState::IsPair' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_Action_SpawnIdle
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_Action_SpawnIdle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_Action_SpawnIdle) == 0x000004, "Wrong alignment on LGeneralName_LName_Action_SpawnIdle");
static_assert(sizeof(LGeneralName_LName_Action_SpawnIdle) == 0x000008, "Wrong size on LGeneralName_LName_Action_SpawnIdle");
static_assert(offsetof(LGeneralName_LName_Action_SpawnIdle, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_Action_SpawnIdle::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_Action_TurnAround
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_Action_TurnAround final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_Action_TurnAround) == 0x000004, "Wrong alignment on LGeneralName_LName_Action_TurnAround");
static_assert(sizeof(LGeneralName_LName_Action_TurnAround) == 0x000008, "Wrong size on LGeneralName_LName_Action_TurnAround");
static_assert(offsetof(LGeneralName_LName_Action_TurnAround, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_Action_TurnAround::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_CommonAnim_Run_F
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_CommonAnim_Run_F final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_CommonAnim_Run_F) == 0x000004, "Wrong alignment on LGeneralName_LName_CommonAnim_Run_F");
static_assert(sizeof(LGeneralName_LName_CommonAnim_Run_F) == 0x000008, "Wrong size on LGeneralName_LName_CommonAnim_Run_F");
static_assert(offsetof(LGeneralName_LName_CommonAnim_Run_F, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_CommonAnim_Run_F::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_B
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_CommonAnim_Walk_B final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_CommonAnim_Walk_B) == 0x000004, "Wrong alignment on LGeneralName_LName_CommonAnim_Walk_B");
static_assert(sizeof(LGeneralName_LName_CommonAnim_Walk_B) == 0x000008, "Wrong size on LGeneralName_LName_CommonAnim_Walk_B");
static_assert(offsetof(LGeneralName_LName_CommonAnim_Walk_B, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_CommonAnim_Walk_B::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_F
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_CommonAnim_Walk_F final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_CommonAnim_Walk_F) == 0x000004, "Wrong alignment on LGeneralName_LName_CommonAnim_Walk_F");
static_assert(sizeof(LGeneralName_LName_CommonAnim_Walk_F) == 0x000008, "Wrong size on LGeneralName_LName_CommonAnim_Walk_F");
static_assert(offsetof(LGeneralName_LName_CommonAnim_Walk_F, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_CommonAnim_Walk_F::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_L
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_CommonAnim_Walk_L final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_CommonAnim_Walk_L) == 0x000004, "Wrong alignment on LGeneralName_LName_CommonAnim_Walk_L");
static_assert(sizeof(LGeneralName_LName_CommonAnim_Walk_L) == 0x000008, "Wrong size on LGeneralName_LName_CommonAnim_Walk_L");
static_assert(offsetof(LGeneralName_LName_CommonAnim_Walk_L, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_CommonAnim_Walk_L::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_R
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_CommonAnim_Walk_R final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_CommonAnim_Walk_R) == 0x000004, "Wrong alignment on LGeneralName_LName_CommonAnim_Walk_R");
static_assert(sizeof(LGeneralName_LName_CommonAnim_Walk_R) == 0x000008, "Wrong size on LGeneralName_LName_CommonAnim_Walk_R");
static_assert(offsetof(LGeneralName_LName_CommonAnim_Walk_R, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_CommonAnim_Walk_R::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_Hair
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_Hair final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_Hair) == 0x000004, "Wrong alignment on LGeneralName_LName_Hair");
static_assert(sizeof(LGeneralName_LName_Hair) == 0x000008, "Wrong size on LGeneralName_LName_Hair");
static_assert(offsetof(LGeneralName_LName_Hair, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_Hair::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_Head
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_Head final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_Head) == 0x000004, "Wrong alignment on LGeneralName_LName_Head");
static_assert(sizeof(LGeneralName_LName_Head) == 0x000008, "Wrong size on LGeneralName_LName_Head");
static_assert(offsetof(LGeneralName_LName_Head, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_Head::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_MontageSection_End
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_MontageSection_End final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_MontageSection_End) == 0x000004, "Wrong alignment on LGeneralName_LName_MontageSection_End");
static_assert(sizeof(LGeneralName_LName_MontageSection_End) == 0x000008, "Wrong size on LGeneralName_LName_MontageSection_End");
static_assert(offsetof(LGeneralName_LName_MontageSection_End, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_MontageSection_End::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_None
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_None) == 0x000004, "Wrong alignment on LGeneralName_LName_None");
static_assert(sizeof(LGeneralName_LName_None) == 0x000008, "Wrong size on LGeneralName_LName_None");
static_assert(offsetof(LGeneralName_LName_None, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_NPCPause_SpotTrigger
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_NPCPause_SpotTrigger final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_NPCPause_SpotTrigger) == 0x000004, "Wrong alignment on LGeneralName_LName_NPCPause_SpotTrigger");
static_assert(sizeof(LGeneralName_LName_NPCPause_SpotTrigger) == 0x000008, "Wrong size on LGeneralName_LName_NPCPause_SpotTrigger");
static_assert(offsetof(LGeneralName_LName_NPCPause_SpotTrigger, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_NPCPause_SpotTrigger::ReturnValue' has a wrong offset!");

// Function ProjectP.LGeneralName.LName_NPCPauseMeta_Action
// 0x0008 (0x0008 - 0x0000)
struct LGeneralName_LName_NPCPauseMeta_Action final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGeneralName_LName_NPCPauseMeta_Action) == 0x000004, "Wrong alignment on LGeneralName_LName_NPCPauseMeta_Action");
static_assert(sizeof(LGeneralName_LName_NPCPauseMeta_Action) == 0x000008, "Wrong size on LGeneralName_LName_NPCPauseMeta_Action");
static_assert(offsetof(LGeneralName_LName_NPCPauseMeta_Action, ReturnValue) == 0x000000, "Member 'LGeneralName_LName_NPCPauseMeta_Action::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitColMgrComponent.OnComponentBeginOverlapped
// 0x00A8 (0x00A8 - 0x0000)
struct LHitColMgrComponent_OnComponentBeginOverlapped final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitColMgrComponent_OnComponentBeginOverlapped) == 0x000008, "Wrong alignment on LHitColMgrComponent_OnComponentBeginOverlapped");
static_assert(sizeof(LHitColMgrComponent_OnComponentBeginOverlapped) == 0x0000A8, "Wrong size on LHitColMgrComponent_OnComponentBeginOverlapped");
static_assert(offsetof(LHitColMgrComponent_OnComponentBeginOverlapped, OverlappedComp) == 0x000000, "Member 'LHitColMgrComponent_OnComponentBeginOverlapped::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentBeginOverlapped, Other) == 0x000008, "Member 'LHitColMgrComponent_OnComponentBeginOverlapped::Other' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentBeginOverlapped, OtherComp) == 0x000010, "Member 'LHitColMgrComponent_OnComponentBeginOverlapped::OtherComp' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentBeginOverlapped, OtherBodyIndex) == 0x000018, "Member 'LHitColMgrComponent_OnComponentBeginOverlapped::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentBeginOverlapped, bFromSweep) == 0x00001C, "Member 'LHitColMgrComponent_OnComponentBeginOverlapped::bFromSweep' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentBeginOverlapped, OverlapInfo) == 0x000020, "Member 'LHitColMgrComponent_OnComponentBeginOverlapped::OverlapInfo' has a wrong offset!");

// Function ProjectP.LHitColMgrComponent.OnComponentEndOverlapped
// 0x0020 (0x0020 - 0x0000)
struct LHitColMgrComponent_OnComponentEndOverlapped final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LHitColMgrComponent_OnComponentEndOverlapped) == 0x000008, "Wrong alignment on LHitColMgrComponent_OnComponentEndOverlapped");
static_assert(sizeof(LHitColMgrComponent_OnComponentEndOverlapped) == 0x000020, "Wrong size on LHitColMgrComponent_OnComponentEndOverlapped");
static_assert(offsetof(LHitColMgrComponent_OnComponentEndOverlapped, OverlappedComp) == 0x000000, "Member 'LHitColMgrComponent_OnComponentEndOverlapped::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentEndOverlapped, Other) == 0x000008, "Member 'LHitColMgrComponent_OnComponentEndOverlapped::Other' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentEndOverlapped, OtherComp) == 0x000010, "Member 'LHitColMgrComponent_OnComponentEndOverlapped::OtherComp' has a wrong offset!");
static_assert(offsetof(LHitColMgrComponent_OnComponentEndOverlapped, OtherBodyIndex) == 0x000018, "Member 'LHitColMgrComponent_OnComponentEndOverlapped::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LAttack
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LAttack final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LAttack) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LAttack");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LAttack) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LAttack");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LAttack, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LAudio
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LAudio final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LAudio) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LAudio");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LAudio) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LAudio");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LAudio, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LAudio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LCapsuleBig
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LCapsuleBig final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LCapsuleBig) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LCapsuleBig");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LCapsuleBig) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LCapsuleBig");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LCapsuleBig, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LCapsuleBig::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LCapsuleNormal
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LCapsuleNormal final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LCapsuleNormal) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LCapsuleNormal");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LCapsuleNormal) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LCapsuleNormal");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LCapsuleNormal, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LCapsuleNormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LCapsulePC
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LCapsulePC final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LCapsulePC) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LCapsulePC");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LCapsulePC) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LCapsulePC");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LCapsulePC, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LCapsulePC::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LCloud
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LCloud final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LCloud) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LCloud");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LCloud) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LCloud");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LCloud, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LCloud::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LIK
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LIK final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LIK) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LIK");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LIK) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LIK");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LIK, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LIK::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LPhysicsBodyBig
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LPhysicsBodyBig final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LPhysicsBodyBig) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LPhysicsBodyBig");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LPhysicsBodyBig) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LPhysicsBodyBig");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LPhysicsBodyBig, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LPhysicsBodyBig::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LPhysicsBodyNormal
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LPhysicsBodyNormal final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LPhysicsBodyNormal) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LPhysicsBodyNormal");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LPhysicsBodyNormal) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LPhysicsBodyNormal");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LPhysicsBodyNormal, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LPhysicsBodyNormal::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LPhysicsBodyVisual
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LPhysicsBodyVisual final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LPhysicsBodyVisual) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LPhysicsBodyVisual");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LPhysicsBodyVisual) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LPhysicsBodyVisual");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LPhysicsBodyVisual, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LPhysicsBodyVisual::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LProjectile
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LProjectile final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LProjectile) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LProjectile");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LProjectile) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LProjectile");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LProjectile, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LRepulse
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LRepulse final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LRepulse) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LRepulse");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LRepulse) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LRepulse");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LRepulse, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LRepulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LSpark
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LSpark final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LSpark) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LSpark");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LSpark) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LSpark");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LSpark, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LSpark::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionChannel.CollisionChannel_LWaterVolume
// 0x0001 (0x0001 - 0x0000)
struct LCollisionChannel_CollisionChannel_LWaterVolume final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionChannel_CollisionChannel_LWaterVolume) == 0x000001, "Wrong alignment on LCollisionChannel_CollisionChannel_LWaterVolume");
static_assert(sizeof(LCollisionChannel_CollisionChannel_LWaterVolume) == 0x000001, "Wrong size on LCollisionChannel_CollisionChannel_LWaterVolume");
static_assert(offsetof(LCollisionChannel_CollisionChannel_LWaterVolume, ReturnValue) == 0x000000, "Member 'LCollisionChannel_CollisionChannel_LWaterVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LLevelUtilFuncLibrary.ChangePropStateBP
// 0x0010 (0x0010 - 0x0000)
struct LLevelUtilFuncLibrary_ChangePropStateBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetState;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LLevelUtilFuncLibrary_ChangePropStateBP) == 0x000008, "Wrong alignment on LLevelUtilFuncLibrary_ChangePropStateBP");
static_assert(sizeof(LLevelUtilFuncLibrary_ChangePropStateBP) == 0x000010, "Wrong size on LLevelUtilFuncLibrary_ChangePropStateBP");
static_assert(offsetof(LLevelUtilFuncLibrary_ChangePropStateBP, TargetActor) == 0x000000, "Member 'LLevelUtilFuncLibrary_ChangePropStateBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LLevelUtilFuncLibrary_ChangePropStateBP, TargetState) == 0x000008, "Member 'LLevelUtilFuncLibrary_ChangePropStateBP::TargetState' has a wrong offset!");
static_assert(offsetof(LLevelUtilFuncLibrary_ChangePropStateBP, Branches) == 0x00000C, "Member 'LLevelUtilFuncLibrary_ChangePropStateBP::Branches' has a wrong offset!");

// Function ProjectP.LLevelUtilFuncLibrary.CheckNextPropStateBP
// 0x0008 (0x0008 - 0x0000)
struct LLevelUtilFuncLibrary_CheckNextPropStateBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelUtilFuncLibrary_CheckNextPropStateBP) == 0x000008, "Wrong alignment on LLevelUtilFuncLibrary_CheckNextPropStateBP");
static_assert(sizeof(LLevelUtilFuncLibrary_CheckNextPropStateBP) == 0x000008, "Wrong size on LLevelUtilFuncLibrary_CheckNextPropStateBP");
static_assert(offsetof(LLevelUtilFuncLibrary_CheckNextPropStateBP, TargetActor) == 0x000000, "Member 'LLevelUtilFuncLibrary_CheckNextPropStateBP::TargetActor' has a wrong offset!");

// Function ProjectP.LLevelUtilFuncLibrary.GetPropComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LLevelUtilFuncLibrary_GetPropComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPropComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelUtilFuncLibrary_GetPropComponentBP) == 0x000008, "Wrong alignment on LLevelUtilFuncLibrary_GetPropComponentBP");
static_assert(sizeof(LLevelUtilFuncLibrary_GetPropComponentBP) == 0x000018, "Wrong size on LLevelUtilFuncLibrary_GetPropComponentBP");
static_assert(offsetof(LLevelUtilFuncLibrary_GetPropComponentBP, TargetActor) == 0x000000, "Member 'LLevelUtilFuncLibrary_GetPropComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LLevelUtilFuncLibrary_GetPropComponentBP, Branches) == 0x000008, "Member 'LLevelUtilFuncLibrary_GetPropComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LLevelUtilFuncLibrary_GetPropComponentBP, ReturnValue) == 0x000010, "Member 'LLevelUtilFuncLibrary_GetPropComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_BlockAll
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_BlockAll final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_BlockAll) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_BlockAll");
static_assert(sizeof(LCollisionProfile_CollisionProfile_BlockAll) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_BlockAll");
static_assert(offsetof(LCollisionProfile_CollisionProfile_BlockAll, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_BlockAll::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_BlockAllDynamic
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_BlockAllDynamic final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_BlockAllDynamic) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_BlockAllDynamic");
static_assert(sizeof(LCollisionProfile_CollisionProfile_BlockAllDynamic) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_BlockAllDynamic");
static_assert(offsetof(LCollisionProfile_CollisionProfile_BlockAllDynamic, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_BlockAllDynamic::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_CharacterMesh
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_CharacterMesh final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_CharacterMesh) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_CharacterMesh");
static_assert(sizeof(LCollisionProfile_CollisionProfile_CharacterMesh) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_CharacterMesh");
static_assert(offsetof(LCollisionProfile_CollisionProfile_CharacterMesh, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_CharacterMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_Destructible
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_Destructible final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_Destructible) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_Destructible");
static_assert(sizeof(LCollisionProfile_CollisionProfile_Destructible) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_Destructible");
static_assert(offsetof(LCollisionProfile_CollisionProfile_Destructible, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_Destructible::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_IgnoreOnlyPawn
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_IgnoreOnlyPawn final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_IgnoreOnlyPawn) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_IgnoreOnlyPawn");
static_assert(sizeof(LCollisionProfile_CollisionProfile_IgnoreOnlyPawn) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_IgnoreOnlyPawn");
static_assert(offsetof(LCollisionProfile_CollisionProfile_IgnoreOnlyPawn, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_IgnoreOnlyPawn::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_InvisibleWall
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_InvisibleWall final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_InvisibleWall) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_InvisibleWall");
static_assert(sizeof(LCollisionProfile_CollisionProfile_InvisibleWall) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_InvisibleWall");
static_assert(offsetof(LCollisionProfile_CollisionProfile_InvisibleWall, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_InvisibleWall::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_InvisibleWallDynamic
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_InvisibleWallDynamic final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_InvisibleWallDynamic) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_InvisibleWallDynamic");
static_assert(sizeof(LCollisionProfile_CollisionProfile_InvisibleWallDynamic) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_InvisibleWallDynamic");
static_assert(offsetof(LCollisionProfile_CollisionProfile_InvisibleWallDynamic, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_InvisibleWallDynamic::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LAttack_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LAttack_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LAttack_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LAttack_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LAttack_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LAttack_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LAttack_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LAttack_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LAttack_Range
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LAttack_Range final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LAttack_Range) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LAttack_Range");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LAttack_Range) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LAttack_Range");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LAttack_Range, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LAttack_Range::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LBlock_Obstacle
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LBlock_Obstacle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LBlock_Obstacle) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LBlock_Obstacle");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LBlock_Obstacle) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LBlock_Obstacle");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LBlock_Obstacle, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LBlock_Obstacle::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LBlock_Obstacle_Projectile
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LBlockAll_MovingEnvironment
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LBlockAll_ThruCamera
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LBlockingVolume
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LBlockingVolume final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LBlockingVolume) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LBlockingVolume");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LBlockingVolume) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LBlockingVolume");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LBlockingVolume, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LBlockingVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCamera_Block
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCamera_Block final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCamera_Block) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCamera_Block");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCamera_Block) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCamera_Block");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCamera_Block, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCamera_Block::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_BlockAll
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_Penetrate
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_Penetrate_Fly
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_TestOverlap
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleBig_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleBig_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleBig_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleBig_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleBig_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleBig_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleBig_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleBig_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleBig_Dead
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleBig_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleBig_Dead) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleBig_Dead");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleBig_Dead) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleBig_Dead");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleBig_Dead, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleBig_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleBig_Ghost
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNormal_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNormal_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNormal_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNormal_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Dead
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Ghost
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Ghost_Hittable
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Hittable
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Penetrate_Hittable
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNPC_TestOverlap
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsulePC_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsulePC_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsulePC_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsulePC_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsulePC_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsulePC_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsulePC_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_Dead
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsulePC_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsulePC_Dead) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsulePC_Dead");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsulePC_Dead) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsulePC_Dead");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsulePC_Dead, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsulePC_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_Ghost
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsulePC_Ghost final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsulePC_Ghost) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsulePC_Ghost");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsulePC_Ghost) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsulePC_Ghost");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsulePC_Ghost, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsulePC_Ghost::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_TestOverlap
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LDecoMesh_Attack
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LDecoMesh_Attack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LDecoMesh_Attack) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LDecoMesh_Attack");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LDecoMesh_Attack) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LDecoMesh_Attack");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LDecoMesh_Attack, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LDecoMesh_Attack::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LDecoMesh_DropEnd
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LDecoMesh_DropStart
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LDecoMesh_DropStart final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LDecoMesh_DropStart) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LDecoMesh_DropStart");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LDecoMesh_DropStart) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LDecoMesh_DropStart");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LDecoMesh_DropStart, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LDecoMesh_DropStart::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LDestructible_Chunk
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LDestructible_Chunk final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LDestructible_Chunk) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LDestructible_Chunk");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LDestructible_Chunk) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LDestructible_Chunk");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LDestructible_Chunk, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LDestructible_Chunk::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LEnvironmentVolume
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LEnvironmentVolume final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LEnvironmentVolume) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LEnvironmentVolume");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LEnvironmentVolume) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LEnvironmentVolume");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LEnvironmentVolume, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LEnvironmentVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LFloorPC
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LFloorPC final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LFloorPC) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LFloorPC");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LFloorPC) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LFloorPC");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LFloorPC, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LFloorPC::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LInteract_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LInteract_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LInteract_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LInteract_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LInteract_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LInteract_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LInteract_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LInteract_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LInteract_CapsuleBase
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LInteract_CapsuleBase final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LInteract_CapsuleBase) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LInteract_CapsuleBase");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LInteract_CapsuleBase) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LInteract_CapsuleBase");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LInteract_CapsuleBase, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LInteract_CapsuleBase::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBody_Explosion_Cut
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Dead
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Dying
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Ghost
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Penetrate
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Dead
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Dying
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Ghost
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Penetrate
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_SimulateOnly
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Dead
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Dying
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Ghost
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Penetrate
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_SimulateOnly
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyVisual_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_LProjectile_Base
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_LProjectile_Base final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_LProjectile_Base) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_LProjectile_Base");
static_assert(sizeof(LCollisionProfile_CollisionProfile_LProjectile_Base) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_LProjectile_Base");
static_assert(offsetof(LCollisionProfile_CollisionProfile_LProjectile_Base, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_LProjectile_Base::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_NoCollision
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_NoCollision final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_NoCollision) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_NoCollision");
static_assert(sizeof(LCollisionProfile_CollisionProfile_NoCollision) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_NoCollision");
static_assert(offsetof(LCollisionProfile_CollisionProfile_NoCollision, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_NoCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_None
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_None) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_None");
static_assert(sizeof(LCollisionProfile_CollisionProfile_None) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_None");
static_assert(offsetof(LCollisionProfile_CollisionProfile_None, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_OverlapAll
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_OverlapAll final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_OverlapAll) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_OverlapAll");
static_assert(sizeof(LCollisionProfile_CollisionProfile_OverlapAll) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_OverlapAll");
static_assert(offsetof(LCollisionProfile_CollisionProfile_OverlapAll, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_OverlapAll::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_OverlapAllDynamic
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_OverlapAllDynamic final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_OverlapAllDynamic) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_OverlapAllDynamic");
static_assert(sizeof(LCollisionProfile_CollisionProfile_OverlapAllDynamic) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_OverlapAllDynamic");
static_assert(offsetof(LCollisionProfile_CollisionProfile_OverlapAllDynamic, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_OverlapAllDynamic::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_OverlapOnlyPawn
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_OverlapOnlyPawn final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_OverlapOnlyPawn) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_OverlapOnlyPawn");
static_assert(sizeof(LCollisionProfile_CollisionProfile_OverlapOnlyPawn) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_OverlapOnlyPawn");
static_assert(offsetof(LCollisionProfile_CollisionProfile_OverlapOnlyPawn, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_OverlapOnlyPawn::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_Pawn
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_Pawn final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_Pawn) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_Pawn");
static_assert(sizeof(LCollisionProfile_CollisionProfile_Pawn) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_Pawn");
static_assert(offsetof(LCollisionProfile_CollisionProfile_Pawn, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_Pawn::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_PhysicsActor
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_PhysicsActor final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_PhysicsActor) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_PhysicsActor");
static_assert(sizeof(LCollisionProfile_CollisionProfile_PhysicsActor) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_PhysicsActor");
static_assert(offsetof(LCollisionProfile_CollisionProfile_PhysicsActor, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_PhysicsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_Ragdoll
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_Ragdoll final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_Ragdoll) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_Ragdoll");
static_assert(sizeof(LCollisionProfile_CollisionProfile_Ragdoll) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_Ragdoll");
static_assert(offsetof(LCollisionProfile_CollisionProfile_Ragdoll, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_Ragdoll::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_Spectator
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_Spectator final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_Spectator) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_Spectator");
static_assert(sizeof(LCollisionProfile_CollisionProfile_Spectator) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_Spectator");
static_assert(offsetof(LCollisionProfile_CollisionProfile_Spectator, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_Spectator::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_Trigger
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_Trigger final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_Trigger) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_Trigger");
static_assert(sizeof(LCollisionProfile_CollisionProfile_Trigger) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_Trigger");
static_assert(offsetof(LCollisionProfile_CollisionProfile_Trigger, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_Trigger::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_UI
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_UI final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_UI) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_UI");
static_assert(sizeof(LCollisionProfile_CollisionProfile_UI) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_UI");
static_assert(offsetof(LCollisionProfile_CollisionProfile_UI, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_UI::ReturnValue' has a wrong offset!");

// Function ProjectP.LCollisionProfile.CollisionProfile_Vehicle
// 0x0008 (0x0008 - 0x0000)
struct LCollisionProfile_CollisionProfile_Vehicle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCollisionProfile_CollisionProfile_Vehicle) == 0x000004, "Wrong alignment on LCollisionProfile_CollisionProfile_Vehicle");
static_assert(sizeof(LCollisionProfile_CollisionProfile_Vehicle) == 0x000008, "Wrong size on LCollisionProfile_CollisionProfile_Vehicle");
static_assert(offsetof(LCollisionProfile_CollisionProfile_Vehicle, ReturnValue) == 0x000000, "Member 'LCollisionProfile_CollisionProfile_Vehicle::ReturnValue' has a wrong offset!");

// Function ProjectP.LComponentTag.CollisionProfile_LFootCollision
// 0x0008 (0x0008 - 0x0000)
struct LComponentTag_CollisionProfile_LFootCollision final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComponentTag_CollisionProfile_LFootCollision) == 0x000004, "Wrong alignment on LComponentTag_CollisionProfile_LFootCollision");
static_assert(sizeof(LComponentTag_CollisionProfile_LFootCollision) == 0x000008, "Wrong size on LComponentTag_CollisionProfile_LFootCollision");
static_assert(offsetof(LComponentTag_CollisionProfile_LFootCollision, ReturnValue) == 0x000000, "Member 'LComponentTag_CollisionProfile_LFootCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LComponentTag.CollisionProfile_None
// 0x0008 (0x0008 - 0x0000)
struct LComponentTag_CollisionProfile_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LComponentTag_CollisionProfile_None) == 0x000004, "Wrong alignment on LComponentTag_CollisionProfile_None");
static_assert(sizeof(LComponentTag_CollisionProfile_None) == 0x000008, "Wrong size on LComponentTag_CollisionProfile_None");
static_assert(offsetof(LComponentTag_CollisionProfile_None, ReturnValue) == 0x000000, "Member 'LComponentTag_CollisionProfile_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructStaticMeshComponent.OnDestructOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct LDestructStaticMeshComponent_OnDestructOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructStaticMeshComponent_OnDestructOverlap) == 0x000008, "Wrong alignment on LDestructStaticMeshComponent_OnDestructOverlap");
static_assert(sizeof(LDestructStaticMeshComponent_OnDestructOverlap) == 0x0000A8, "Wrong size on LDestructStaticMeshComponent_OnDestructOverlap");
static_assert(offsetof(LDestructStaticMeshComponent_OnDestructOverlap, OverlappedComp) == 0x000000, "Member 'LDestructStaticMeshComponent_OnDestructOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LDestructStaticMeshComponent_OnDestructOverlap, Other) == 0x000008, "Member 'LDestructStaticMeshComponent_OnDestructOverlap::Other' has a wrong offset!");
static_assert(offsetof(LDestructStaticMeshComponent_OnDestructOverlap, OtherComp) == 0x000010, "Member 'LDestructStaticMeshComponent_OnDestructOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(LDestructStaticMeshComponent_OnDestructOverlap, OtherBodyIndex) == 0x000018, "Member 'LDestructStaticMeshComponent_OnDestructOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LDestructStaticMeshComponent_OnDestructOverlap, bFromSweep) == 0x00001C, "Member 'LDestructStaticMeshComponent_OnDestructOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(LDestructStaticMeshComponent_OnDestructOverlap, SweepResult) == 0x000020, "Member 'LDestructStaticMeshComponent_OnDestructOverlap::SweepResult' has a wrong offset!");

// Function ProjectP.LDestructSkeletalMeshComponent.OnDestructOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct LDestructSkeletalMeshComponent_OnDestructOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructSkeletalMeshComponent_OnDestructOverlap) == 0x000008, "Wrong alignment on LDestructSkeletalMeshComponent_OnDestructOverlap");
static_assert(sizeof(LDestructSkeletalMeshComponent_OnDestructOverlap) == 0x0000A8, "Wrong size on LDestructSkeletalMeshComponent_OnDestructOverlap");
static_assert(offsetof(LDestructSkeletalMeshComponent_OnDestructOverlap, OverlappedComp) == 0x000000, "Member 'LDestructSkeletalMeshComponent_OnDestructOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LDestructSkeletalMeshComponent_OnDestructOverlap, Other) == 0x000008, "Member 'LDestructSkeletalMeshComponent_OnDestructOverlap::Other' has a wrong offset!");
static_assert(offsetof(LDestructSkeletalMeshComponent_OnDestructOverlap, OtherComp) == 0x000010, "Member 'LDestructSkeletalMeshComponent_OnDestructOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(LDestructSkeletalMeshComponent_OnDestructOverlap, OtherBodyIndex) == 0x000018, "Member 'LDestructSkeletalMeshComponent_OnDestructOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LDestructSkeletalMeshComponent_OnDestructOverlap, bFromSweep) == 0x00001C, "Member 'LDestructSkeletalMeshComponent_OnDestructOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(LDestructSkeletalMeshComponent_OnDestructOverlap, SweepResult) == 0x000020, "Member 'LDestructSkeletalMeshComponent_OnDestructOverlap::SweepResult' has a wrong offset!");

// Function ProjectP.LDestructibleComponent.OnDestructFracture
// 0x0018 (0x0018 - 0x0000)
struct LDestructibleComponent_OnDestructFracture final
{
public:
	struct FVector                                HitPoint;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructibleComponent_OnDestructFracture) == 0x000004, "Wrong alignment on LDestructibleComponent_OnDestructFracture");
static_assert(sizeof(LDestructibleComponent_OnDestructFracture) == 0x000018, "Wrong size on LDestructibleComponent_OnDestructFracture");
static_assert(offsetof(LDestructibleComponent_OnDestructFracture, HitPoint) == 0x000000, "Member 'LDestructibleComponent_OnDestructFracture::HitPoint' has a wrong offset!");
static_assert(offsetof(LDestructibleComponent_OnDestructFracture, HitDirection) == 0x00000C, "Member 'LDestructibleComponent_OnDestructFracture::HitDirection' has a wrong offset!");

// Function ProjectP.LDestructibleComponent.OnDestructOverlap
// 0x00A8 (0x00A8 - 0x0000)
struct LDestructibleComponent_OnDestructOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructibleComponent_OnDestructOverlap) == 0x000008, "Wrong alignment on LDestructibleComponent_OnDestructOverlap");
static_assert(sizeof(LDestructibleComponent_OnDestructOverlap) == 0x0000A8, "Wrong size on LDestructibleComponent_OnDestructOverlap");
static_assert(offsetof(LDestructibleComponent_OnDestructOverlap, OverlappedComp) == 0x000000, "Member 'LDestructibleComponent_OnDestructOverlap::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LDestructibleComponent_OnDestructOverlap, Other) == 0x000008, "Member 'LDestructibleComponent_OnDestructOverlap::Other' has a wrong offset!");
static_assert(offsetof(LDestructibleComponent_OnDestructOverlap, OtherComp) == 0x000010, "Member 'LDestructibleComponent_OnDestructOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(LDestructibleComponent_OnDestructOverlap, OtherBodyIndex) == 0x000018, "Member 'LDestructibleComponent_OnDestructOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LDestructibleComponent_OnDestructOverlap, bFromSweep) == 0x00001C, "Member 'LDestructibleComponent_OnDestructOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(LDestructibleComponent_OnDestructOverlap, SweepResult) == 0x000020, "Member 'LDestructibleComponent_OnDestructOverlap::SweepResult' has a wrong offset!");

// Function ProjectP.LDestructionObject.CanRepulse
// 0x0010 (0x0010 - 0x0000)
struct LDestructionObject_CanRepulse final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LDestructionObject_CanRepulse) == 0x000008, "Wrong alignment on LDestructionObject_CanRepulse");
static_assert(sizeof(LDestructionObject_CanRepulse) == 0x000010, "Wrong size on LDestructionObject_CanRepulse");
static_assert(offsetof(LDestructionObject_CanRepulse, Attacker) == 0x000000, "Member 'LDestructionObject_CanRepulse::Attacker' has a wrong offset!");
static_assert(offsetof(LDestructionObject_CanRepulse, ReturnValue) == 0x000008, "Member 'LDestructionObject_CanRepulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.DoHitDirection
// 0x001C (0x001C - 0x0000)
struct LDestructionObject_DoHitDirection final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_DoHitDirection) == 0x000004, "Wrong alignment on LDestructionObject_DoHitDirection");
static_assert(sizeof(LDestructionObject_DoHitDirection) == 0x00001C, "Wrong size on LDestructionObject_DoHitDirection");
static_assert(offsetof(LDestructionObject_DoHitDirection, HitLocation) == 0x000000, "Member 'LDestructionObject_DoHitDirection::HitLocation' has a wrong offset!");
static_assert(offsetof(LDestructionObject_DoHitDirection, HitDirection) == 0x00000C, "Member 'LDestructionObject_DoHitDirection::HitDirection' has a wrong offset!");
static_assert(offsetof(LDestructionObject_DoHitDirection, Strength) == 0x000018, "Member 'LDestructionObject_DoHitDirection::Strength' has a wrong offset!");

// Function ProjectP.LDestructionObject.DoHitFully
// 0x0010 (0x0010 - 0x0000)
struct LDestructionObject_DoHitFully final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_DoHitFully) == 0x000004, "Wrong alignment on LDestructionObject_DoHitFully");
static_assert(sizeof(LDestructionObject_DoHitFully) == 0x000010, "Wrong size on LDestructionObject_DoHitFully");
static_assert(offsetof(LDestructionObject_DoHitFully, HitLocation) == 0x000000, "Member 'LDestructionObject_DoHitFully::HitLocation' has a wrong offset!");
static_assert(offsetof(LDestructionObject_DoHitFully, Strength) == 0x00000C, "Member 'LDestructionObject_DoHitFully::Strength' has a wrong offset!");

// Function ProjectP.LDestructionObject.DoHitRadius
// 0x0014 (0x0014 - 0x0000)
struct LDestructionObject_DoHitRadius final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_DoHitRadius) == 0x000004, "Wrong alignment on LDestructionObject_DoHitRadius");
static_assert(sizeof(LDestructionObject_DoHitRadius) == 0x000014, "Wrong size on LDestructionObject_DoHitRadius");
static_assert(offsetof(LDestructionObject_DoHitRadius, HitLocation) == 0x000000, "Member 'LDestructionObject_DoHitRadius::HitLocation' has a wrong offset!");
static_assert(offsetof(LDestructionObject_DoHitRadius, Radius) == 0x00000C, "Member 'LDestructionObject_DoHitRadius::Radius' has a wrong offset!");
static_assert(offsetof(LDestructionObject_DoHitRadius, Strength) == 0x000010, "Member 'LDestructionObject_DoHitRadius::Strength' has a wrong offset!");

// Function ProjectP.LDestructionObject.DoHitSelf
// 0x0004 (0x0004 - 0x0000)
struct LDestructionObject_DoHitSelf final
{
public:
	float                                         Strength;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_DoHitSelf) == 0x000004, "Wrong alignment on LDestructionObject_DoHitSelf");
static_assert(sizeof(LDestructionObject_DoHitSelf) == 0x000004, "Wrong size on LDestructionObject_DoHitSelf");
static_assert(offsetof(LDestructionObject_DoHitSelf, Strength) == 0x000000, "Member 'LDestructionObject_DoHitSelf::Strength' has a wrong offset!");

// Function ProjectP.LDestructionObject.GetCurrectHPDestructionProp
// 0x0004 (0x0004 - 0x0000)
struct LDestructionObject_GetCurrectHPDestructionProp final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_GetCurrectHPDestructionProp) == 0x000004, "Wrong alignment on LDestructionObject_GetCurrectHPDestructionProp");
static_assert(sizeof(LDestructionObject_GetCurrectHPDestructionProp) == 0x000004, "Wrong size on LDestructionObject_GetCurrectHPDestructionProp");
static_assert(offsetof(LDestructionObject_GetCurrectHPDestructionProp, ReturnValue) == 0x000000, "Member 'LDestructionObject_GetCurrectHPDestructionProp::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.PushCrashedChunks
// 0x000C (0x000C - 0x0000)
struct LDestructionObject_PushCrashedChunks final
{
public:
	struct FVector                                PushLocation;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_PushCrashedChunks) == 0x000004, "Wrong alignment on LDestructionObject_PushCrashedChunks");
static_assert(sizeof(LDestructionObject_PushCrashedChunks) == 0x00000C, "Wrong size on LDestructionObject_PushCrashedChunks");
static_assert(offsetof(LDestructionObject_PushCrashedChunks, PushLocation) == 0x000000, "Member 'LDestructionObject_PushCrashedChunks::PushLocation' has a wrong offset!");

// Function ProjectP.LDestructionObject.GetControlShapeObjectSpot
// 0x0010 (0x0010 - 0x0000)
struct LDestructionObject_GetControlShapeObjectSpot final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_GetControlShapeObjectSpot) == 0x000008, "Wrong alignment on LDestructionObject_GetControlShapeObjectSpot");
static_assert(sizeof(LDestructionObject_GetControlShapeObjectSpot) == 0x000010, "Wrong size on LDestructionObject_GetControlShapeObjectSpot");
static_assert(offsetof(LDestructionObject_GetControlShapeObjectSpot, Index_0) == 0x000000, "Member 'LDestructionObject_GetControlShapeObjectSpot::Index_0' has a wrong offset!");
static_assert(offsetof(LDestructionObject_GetControlShapeObjectSpot, ReturnValue) == 0x000008, "Member 'LDestructionObject_GetControlShapeObjectSpot::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.GetControlShapeObjectSpotLastIndex
// 0x0004 (0x0004 - 0x0000)
struct LDestructionObject_GetControlShapeObjectSpotLastIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_GetControlShapeObjectSpotLastIndex) == 0x000004, "Wrong alignment on LDestructionObject_GetControlShapeObjectSpotLastIndex");
static_assert(sizeof(LDestructionObject_GetControlShapeObjectSpotLastIndex) == 0x000004, "Wrong size on LDestructionObject_GetControlShapeObjectSpotLastIndex");
static_assert(offsetof(LDestructionObject_GetControlShapeObjectSpotLastIndex, ReturnValue) == 0x000000, "Member 'LDestructionObject_GetControlShapeObjectSpotLastIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.GetControlVolumeSpot
// 0x0008 (0x0008 - 0x0000)
struct LDestructionObject_GetControlVolumeSpot final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_GetControlVolumeSpot) == 0x000008, "Wrong alignment on LDestructionObject_GetControlVolumeSpot");
static_assert(sizeof(LDestructionObject_GetControlVolumeSpot) == 0x000008, "Wrong size on LDestructionObject_GetControlVolumeSpot");
static_assert(offsetof(LDestructionObject_GetControlVolumeSpot, ReturnValue) == 0x000000, "Member 'LDestructionObject_GetControlVolumeSpot::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.GetOverridePhysicalSurface
// 0x0001 (0x0001 - 0x0000)
struct LDestructionObject_GetOverridePhysicalSurface final
{
public:
	ELPhysicalSurfaceType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_GetOverridePhysicalSurface) == 0x000001, "Wrong alignment on LDestructionObject_GetOverridePhysicalSurface");
static_assert(sizeof(LDestructionObject_GetOverridePhysicalSurface) == 0x000001, "Wrong size on LDestructionObject_GetOverridePhysicalSurface");
static_assert(offsetof(LDestructionObject_GetOverridePhysicalSurface, ReturnValue) == 0x000000, "Member 'LDestructionObject_GetOverridePhysicalSurface::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.GetPhysicalSurfaceType
// 0x0001 (0x0001 - 0x0000)
struct LDestructionObject_GetPhysicalSurfaceType final
{
public:
	ELPhysicalSurfaceType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_GetPhysicalSurfaceType) == 0x000001, "Wrong alignment on LDestructionObject_GetPhysicalSurfaceType");
static_assert(sizeof(LDestructionObject_GetPhysicalSurfaceType) == 0x000001, "Wrong size on LDestructionObject_GetPhysicalSurfaceType");
static_assert(offsetof(LDestructionObject_GetPhysicalSurfaceType, ReturnValue) == 0x000000, "Member 'LDestructionObject_GetPhysicalSurfaceType::ReturnValue' has a wrong offset!");

// Function ProjectP.LDestructionObject.IsCrashedAll
// 0x0001 (0x0001 - 0x0000)
struct LDestructionObject_IsCrashedAll final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDestructionObject_IsCrashedAll) == 0x000001, "Wrong alignment on LDestructionObject_IsCrashedAll");
static_assert(sizeof(LDestructionObject_IsCrashedAll) == 0x000001, "Wrong size on LDestructionObject_IsCrashedAll");
static_assert(offsetof(LDestructionObject_IsCrashedAll, ReturnValue) == 0x000000, "Member 'LDestructionObject_IsCrashedAll::ReturnValue' has a wrong offset!");

// Function ProjectP.LDevSystem.AddUserGameCommand
// 0x0050 (0x0050 - 0x0000)
struct LDevSystem_AddUserGameCommand final
{
public:
	struct FLGameCommandBookEntity                Command;                                           // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_AddUserGameCommand) == 0x000008, "Wrong alignment on LDevSystem_AddUserGameCommand");
static_assert(sizeof(LDevSystem_AddUserGameCommand) == 0x000050, "Wrong size on LDevSystem_AddUserGameCommand");
static_assert(offsetof(LDevSystem_AddUserGameCommand, Command) == 0x000000, "Member 'LDevSystem_AddUserGameCommand::Command' has a wrong offset!");

// Function ProjectP.LDevSystem.BindGameCommandBookHotKey
// 0x0050 (0x0050 - 0x0000)
struct LDevSystem_BindGameCommandBookHotKey final
{
public:
	struct FLGameCommandBookEntity                Command;                                           // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_BindGameCommandBookHotKey) == 0x000008, "Wrong alignment on LDevSystem_BindGameCommandBookHotKey");
static_assert(sizeof(LDevSystem_BindGameCommandBookHotKey) == 0x000050, "Wrong size on LDevSystem_BindGameCommandBookHotKey");
static_assert(offsetof(LDevSystem_BindGameCommandBookHotKey, Command) == 0x000000, "Member 'LDevSystem_BindGameCommandBookHotKey::Command' has a wrong offset!");

// Function ProjectP.LDevSystem.ExecuteGameCommand
// 0x0050 (0x0050 - 0x0000)
struct LDevSystem_ExecuteGameCommand final
{
public:
	struct FLGameCommandBookEntity                Command;                                           // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_ExecuteGameCommand) == 0x000008, "Wrong alignment on LDevSystem_ExecuteGameCommand");
static_assert(sizeof(LDevSystem_ExecuteGameCommand) == 0x000050, "Wrong size on LDevSystem_ExecuteGameCommand");
static_assert(offsetof(LDevSystem_ExecuteGameCommand, Command) == 0x000000, "Member 'LDevSystem_ExecuteGameCommand::Command' has a wrong offset!");

// Function ProjectP.LDevSystem.GetDebugTargetActor
// 0x0008 (0x0008 - 0x0000)
struct LDevSystem_GetDebugTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_GetDebugTargetActor) == 0x000008, "Wrong alignment on LDevSystem_GetDebugTargetActor");
static_assert(sizeof(LDevSystem_GetDebugTargetActor) == 0x000008, "Wrong size on LDevSystem_GetDebugTargetActor");
static_assert(offsetof(LDevSystem_GetDebugTargetActor, ReturnValue) == 0x000000, "Member 'LDevSystem_GetDebugTargetActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LDevSystem.GetNpcActorOnlyOne
// 0x0008 (0x0008 - 0x0000)
struct LDevSystem_GetNpcActorOnlyOne final
{
public:
	class ALNPCCharacter*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_GetNpcActorOnlyOne) == 0x000008, "Wrong alignment on LDevSystem_GetNpcActorOnlyOne");
static_assert(sizeof(LDevSystem_GetNpcActorOnlyOne) == 0x000008, "Wrong size on LDevSystem_GetNpcActorOnlyOne");
static_assert(offsetof(LDevSystem_GetNpcActorOnlyOne, ReturnValue) == 0x000000, "Member 'LDevSystem_GetNpcActorOnlyOne::ReturnValue' has a wrong offset!");

// Function ProjectP.LDevSystem.LoadGameCommands
// 0x0040 (0x0040 - 0x0000)
struct LDevSystem_LoadGameCommands final
{
public:
	TArray<struct FLGameCommandBookEntity>        DefaultCommands;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLGameCommandBookEntity>        UserCommands;                                      // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLGameCommandBookEntity>        DefaultChapterCommands;                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLGameCommandBookEntity>        DefaultMoneyCommands;                              // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_LoadGameCommands) == 0x000008, "Wrong alignment on LDevSystem_LoadGameCommands");
static_assert(sizeof(LDevSystem_LoadGameCommands) == 0x000040, "Wrong size on LDevSystem_LoadGameCommands");
static_assert(offsetof(LDevSystem_LoadGameCommands, DefaultCommands) == 0x000000, "Member 'LDevSystem_LoadGameCommands::DefaultCommands' has a wrong offset!");
static_assert(offsetof(LDevSystem_LoadGameCommands, UserCommands) == 0x000010, "Member 'LDevSystem_LoadGameCommands::UserCommands' has a wrong offset!");
static_assert(offsetof(LDevSystem_LoadGameCommands, DefaultChapterCommands) == 0x000020, "Member 'LDevSystem_LoadGameCommands::DefaultChapterCommands' has a wrong offset!");
static_assert(offsetof(LDevSystem_LoadGameCommands, DefaultMoneyCommands) == 0x000030, "Member 'LDevSystem_LoadGameCommands::DefaultMoneyCommands' has a wrong offset!");

// Function ProjectP.LDevSystem.SaveUserGameCommands
// 0x0010 (0x0010 - 0x0000)
struct LDevSystem_SaveUserGameCommands final
{
public:
	TArray<struct FLGameCommandBookEntity>        UserCommands;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_SaveUserGameCommands) == 0x000008, "Wrong alignment on LDevSystem_SaveUserGameCommands");
static_assert(sizeof(LDevSystem_SaveUserGameCommands) == 0x000010, "Wrong size on LDevSystem_SaveUserGameCommands");
static_assert(offsetof(LDevSystem_SaveUserGameCommands, UserCommands) == 0x000000, "Member 'LDevSystem_SaveUserGameCommands::UserCommands' has a wrong offset!");

// Function ProjectP.LDevSystem.StartRecordCamera
// 0x0008 (0x0008 - 0x0000)
struct LDevSystem_StartRecordCamera final
{
public:
	float                                         FrameRate;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LookatZOffset;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_StartRecordCamera) == 0x000004, "Wrong alignment on LDevSystem_StartRecordCamera");
static_assert(sizeof(LDevSystem_StartRecordCamera) == 0x000008, "Wrong size on LDevSystem_StartRecordCamera");
static_assert(offsetof(LDevSystem_StartRecordCamera, FrameRate) == 0x000000, "Member 'LDevSystem_StartRecordCamera::FrameRate' has a wrong offset!");
static_assert(offsetof(LDevSystem_StartRecordCamera, LookatZOffset) == 0x000004, "Member 'LDevSystem_StartRecordCamera::LookatZOffset' has a wrong offset!");

// Function ProjectP.LDevSystem.UnbindGameCommandBookHotKey
// 0x0050 (0x0050 - 0x0000)
struct LDevSystem_UnbindGameCommandBookHotKey final
{
public:
	struct FLGameCommandBookEntity                Command;                                           // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDevSystem_UnbindGameCommandBookHotKey) == 0x000008, "Wrong alignment on LDevSystem_UnbindGameCommandBookHotKey");
static_assert(sizeof(LDevSystem_UnbindGameCommandBookHotKey) == 0x000050, "Wrong size on LDevSystem_UnbindGameCommandBookHotKey");
static_assert(offsetof(LDevSystem_UnbindGameCommandBookHotKey, Command) == 0x000000, "Member 'LDevSystem_UnbindGameCommandBookHotKey::Command' has a wrong offset!");

// Function ProjectP.LDLCSystem.PopOutPendingDLC_Account
// 0x0002 (0x0002 - 0x0000)
struct LDLCSystem_PopOutPendingDLC_Account final
{
public:
	ELRewardType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDLCSystem_PopOutPendingDLC_Account) == 0x000001, "Wrong alignment on LDLCSystem_PopOutPendingDLC_Account");
static_assert(sizeof(LDLCSystem_PopOutPendingDLC_Account) == 0x000002, "Wrong size on LDLCSystem_PopOutPendingDLC_Account");
static_assert(offsetof(LDLCSystem_PopOutPendingDLC_Account, InType) == 0x000000, "Member 'LDLCSystem_PopOutPendingDLC_Account::InType' has a wrong offset!");
static_assert(offsetof(LDLCSystem_PopOutPendingDLC_Account, ReturnValue) == 0x000001, "Member 'LDLCSystem_PopOutPendingDLC_Account::ReturnValue' has a wrong offset!");

// Function ProjectP.LDLCSystem.PopOutPendingDLC_Character
// 0x0002 (0x0002 - 0x0000)
struct LDLCSystem_PopOutPendingDLC_Character final
{
public:
	ELRewardType                                  InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDLCSystem_PopOutPendingDLC_Character) == 0x000001, "Wrong alignment on LDLCSystem_PopOutPendingDLC_Character");
static_assert(sizeof(LDLCSystem_PopOutPendingDLC_Character) == 0x000002, "Wrong size on LDLCSystem_PopOutPendingDLC_Character");
static_assert(offsetof(LDLCSystem_PopOutPendingDLC_Character, InType) == 0x000000, "Member 'LDLCSystem_PopOutPendingDLC_Character::InType' has a wrong offset!");
static_assert(offsetof(LDLCSystem_PopOutPendingDLC_Character, ReturnValue) == 0x000001, "Member 'LDLCSystem_PopOutPendingDLC_Character::ReturnValue' has a wrong offset!");

// Function ProjectP.LDLCSystem.GetPendingDLCList
// 0x0010 (0x0010 - 0x0000)
struct LDLCSystem_GetPendingDLCList final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDLCSystem_GetPendingDLCList) == 0x000008, "Wrong alignment on LDLCSystem_GetPendingDLCList");
static_assert(sizeof(LDLCSystem_GetPendingDLCList) == 0x000010, "Wrong size on LDLCSystem_GetPendingDLCList");
static_assert(offsetof(LDLCSystem_GetPendingDLCList, ReturnValue) == 0x000000, "Member 'LDLCSystem_GetPendingDLCList::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCSpot.OnComponentBeginOverlapPathway
// 0x00A8 (0x00A8 - 0x0000)
struct LNPCSpot_OnComponentBeginOverlapPathway final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCSpot_OnComponentBeginOverlapPathway) == 0x000008, "Wrong alignment on LNPCSpot_OnComponentBeginOverlapPathway");
static_assert(sizeof(LNPCSpot_OnComponentBeginOverlapPathway) == 0x0000A8, "Wrong size on LNPCSpot_OnComponentBeginOverlapPathway");
static_assert(offsetof(LNPCSpot_OnComponentBeginOverlapPathway, OverlappedComponent) == 0x000000, "Member 'LNPCSpot_OnComponentBeginOverlapPathway::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LNPCSpot_OnComponentBeginOverlapPathway, OtherActor) == 0x000008, "Member 'LNPCSpot_OnComponentBeginOverlapPathway::OtherActor' has a wrong offset!");
static_assert(offsetof(LNPCSpot_OnComponentBeginOverlapPathway, OtherComp) == 0x000010, "Member 'LNPCSpot_OnComponentBeginOverlapPathway::OtherComp' has a wrong offset!");
static_assert(offsetof(LNPCSpot_OnComponentBeginOverlapPathway, OtherBodyIndex) == 0x000018, "Member 'LNPCSpot_OnComponentBeginOverlapPathway::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LNPCSpot_OnComponentBeginOverlapPathway, bFromSweep) == 0x00001C, "Member 'LNPCSpot_OnComponentBeginOverlapPathway::bFromSweep' has a wrong offset!");
static_assert(offsetof(LNPCSpot_OnComponentBeginOverlapPathway, SweepResult) == 0x000020, "Member 'LNPCSpot_OnComponentBeginOverlapPathway::SweepResult' has a wrong offset!");

// Function ProjectP.LPlatformSystem.ConfirmNeowizAuth
// 0x0028 (0x0028 - 0x0000)
struct LPlatformSystem_ConfirmNeowizAuth final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PW;                                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExternalAccount;                                   // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlatformSystem_ConfirmNeowizAuth) == 0x000008, "Wrong alignment on LPlatformSystem_ConfirmNeowizAuth");
static_assert(sizeof(LPlatformSystem_ConfirmNeowizAuth) == 0x000028, "Wrong size on LPlatformSystem_ConfirmNeowizAuth");
static_assert(offsetof(LPlatformSystem_ConfirmNeowizAuth, ID) == 0x000000, "Member 'LPlatformSystem_ConfirmNeowizAuth::ID' has a wrong offset!");
static_assert(offsetof(LPlatformSystem_ConfirmNeowizAuth, PW) == 0x000010, "Member 'LPlatformSystem_ConfirmNeowizAuth::PW' has a wrong offset!");
static_assert(offsetof(LPlatformSystem_ConfirmNeowizAuth, ExternalAccount) == 0x000020, "Member 'LPlatformSystem_ConfirmNeowizAuth::ExternalAccount' has a wrong offset!");

// Function ProjectP.LPlatformSystem.GetChunkInstallProgress
// 0x0004 (0x0004 - 0x0000)
struct LPlatformSystem_GetChunkInstallProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_GetChunkInstallProgress) == 0x000004, "Wrong alignment on LPlatformSystem_GetChunkInstallProgress");
static_assert(sizeof(LPlatformSystem_GetChunkInstallProgress) == 0x000004, "Wrong size on LPlatformSystem_GetChunkInstallProgress");
static_assert(offsetof(LPlatformSystem_GetChunkInstallProgress, ReturnValue) == 0x000000, "Member 'LPlatformSystem_GetChunkInstallProgress::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.GetGameVersionString
// 0x0010 (0x0010 - 0x0000)
struct LPlatformSystem_GetGameVersionString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_GetGameVersionString) == 0x000008, "Wrong alignment on LPlatformSystem_GetGameVersionString");
static_assert(sizeof(LPlatformSystem_GetGameVersionString) == 0x000010, "Wrong size on LPlatformSystem_GetGameVersionString");
static_assert(offsetof(LPlatformSystem_GetGameVersionString, ReturnValue) == 0x000000, "Member 'LPlatformSystem_GetGameVersionString::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.GetLaunchActivityErrortype
// 0x0001 (0x0001 - 0x0000)
struct LPlatformSystem_GetLaunchActivityErrortype final
{
public:
	ELLaunchActivityErrorType                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_GetLaunchActivityErrortype) == 0x000001, "Wrong alignment on LPlatformSystem_GetLaunchActivityErrortype");
static_assert(sizeof(LPlatformSystem_GetLaunchActivityErrortype) == 0x000001, "Wrong size on LPlatformSystem_GetLaunchActivityErrortype");
static_assert(offsetof(LPlatformSystem_GetLaunchActivityErrortype, ReturnValue) == 0x000000, "Member 'LPlatformSystem_GetLaunchActivityErrortype::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.GetPlatformName
// 0x0010 (0x0010 - 0x0000)
struct LPlatformSystem_GetPlatformName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_GetPlatformName) == 0x000008, "Wrong alignment on LPlatformSystem_GetPlatformName");
static_assert(sizeof(LPlatformSystem_GetPlatformName) == 0x000010, "Wrong size on LPlatformSystem_GetPlatformName");
static_assert(offsetof(LPlatformSystem_GetPlatformName, ReturnValue) == 0x000000, "Member 'LPlatformSystem_GetPlatformName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.GetPlayerNickName
// 0x0010 (0x0010 - 0x0000)
struct LPlatformSystem_GetPlayerNickName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_GetPlayerNickName) == 0x000008, "Wrong alignment on LPlatformSystem_GetPlayerNickName");
static_assert(sizeof(LPlatformSystem_GetPlayerNickName) == 0x000010, "Wrong size on LPlatformSystem_GetPlayerNickName");
static_assert(offsetof(LPlatformSystem_GetPlayerNickName, ReturnValue) == 0x000000, "Member 'LPlatformSystem_GetPlayerNickName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.IsChunkInstallComplete
// 0x0001 (0x0001 - 0x0000)
struct LPlatformSystem_IsChunkInstallComplete final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_IsChunkInstallComplete) == 0x000001, "Wrong alignment on LPlatformSystem_IsChunkInstallComplete");
static_assert(sizeof(LPlatformSystem_IsChunkInstallComplete) == 0x000001, "Wrong size on LPlatformSystem_IsChunkInstallComplete");
static_assert(offsetof(LPlatformSystem_IsChunkInstallComplete, ReturnValue) == 0x000000, "Member 'LPlatformSystem_IsChunkInstallComplete::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.IsLaunchActivity
// 0x0001 (0x0001 - 0x0000)
struct LPlatformSystem_IsLaunchActivity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_IsLaunchActivity) == 0x000001, "Wrong alignment on LPlatformSystem_IsLaunchActivity");
static_assert(sizeof(LPlatformSystem_IsLaunchActivity) == 0x000001, "Wrong size on LPlatformSystem_IsLaunchActivity");
static_assert(offsetof(LPlatformSystem_IsLaunchActivity, ReturnValue) == 0x000000, "Member 'LPlatformSystem_IsLaunchActivity::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.IsNeowizAuthExternalAccount
// 0x0001 (0x0001 - 0x0000)
struct LPlatformSystem_IsNeowizAuthExternalAccount final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_IsNeowizAuthExternalAccount) == 0x000001, "Wrong alignment on LPlatformSystem_IsNeowizAuthExternalAccount");
static_assert(sizeof(LPlatformSystem_IsNeowizAuthExternalAccount) == 0x000001, "Wrong size on LPlatformSystem_IsNeowizAuthExternalAccount");
static_assert(offsetof(LPlatformSystem_IsNeowizAuthExternalAccount, ReturnValue) == 0x000000, "Member 'LPlatformSystem_IsNeowizAuthExternalAccount::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.IsValidNeowizAuth
// 0x0001 (0x0001 - 0x0000)
struct LPlatformSystem_IsValidNeowizAuth final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_IsValidNeowizAuth) == 0x000001, "Wrong alignment on LPlatformSystem_IsValidNeowizAuth");
static_assert(sizeof(LPlatformSystem_IsValidNeowizAuth) == 0x000001, "Wrong size on LPlatformSystem_IsValidNeowizAuth");
static_assert(offsetof(LPlatformSystem_IsValidNeowizAuth, ReturnValue) == 0x000000, "Member 'LPlatformSystem_IsValidNeowizAuth::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.ResetActivity
// 0x0001 (0x0001 - 0x0000)
struct LPlatformSystem_ResetActivity final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlatformSystem_ResetActivity) == 0x000001, "Wrong alignment on LPlatformSystem_ResetActivity");
static_assert(sizeof(LPlatformSystem_ResetActivity) == 0x000001, "Wrong size on LPlatformSystem_ResetActivity");
static_assert(offsetof(LPlatformSystem_ResetActivity, ReturnValue) == 0x000000, "Member 'LPlatformSystem_ResetActivity::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlatformSystem.ResumeActivity
// 0x0008 (0x0008 - 0x0000)
struct LPlatformSystem_ResumeActivity final
{
public:
	int32                                         InProgress;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlatformSystem_ResumeActivity) == 0x000004, "Wrong alignment on LPlatformSystem_ResumeActivity");
static_assert(sizeof(LPlatformSystem_ResumeActivity) == 0x000008, "Wrong size on LPlatformSystem_ResumeActivity");
static_assert(offsetof(LPlatformSystem_ResumeActivity, InProgress) == 0x000000, "Member 'LPlatformSystem_ResumeActivity::InProgress' has a wrong offset!");
static_assert(offsetof(LPlatformSystem_ResumeActivity, ReturnValue) == 0x000004, "Member 'LPlatformSystem_ResumeActivity::ReturnValue' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.EnableShadowDistanceFading
// 0x0001 (0x0001 - 0x0000)
struct LGlobalEnvActor_EnableShadowDistanceFading final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGlobalEnvActor_EnableShadowDistanceFading) == 0x000001, "Wrong alignment on LGlobalEnvActor_EnableShadowDistanceFading");
static_assert(sizeof(LGlobalEnvActor_EnableShadowDistanceFading) == 0x000001, "Wrong size on LGlobalEnvActor_EnableShadowDistanceFading");
static_assert(offsetof(LGlobalEnvActor_EnableShadowDistanceFading, Enable) == 0x000000, "Member 'LGlobalEnvActor_EnableShadowDistanceFading::Enable' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.GetEditorCameraPosition
// 0x0010 (0x0010 - 0x0000)
struct LGlobalEnvActor_GetEditorCameraPosition final
{
public:
	struct FVector                                OutCameraPostion;                                  // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGlobalEnvActor_GetEditorCameraPosition) == 0x000004, "Wrong alignment on LGlobalEnvActor_GetEditorCameraPosition");
static_assert(sizeof(LGlobalEnvActor_GetEditorCameraPosition) == 0x000010, "Wrong size on LGlobalEnvActor_GetEditorCameraPosition");
static_assert(offsetof(LGlobalEnvActor_GetEditorCameraPosition, OutCameraPostion) == 0x000000, "Member 'LGlobalEnvActor_GetEditorCameraPosition::OutCameraPostion' has a wrong offset!");
static_assert(offsetof(LGlobalEnvActor_GetEditorCameraPosition, ReturnValue) == 0x00000C, "Member 'LGlobalEnvActor_GetEditorCameraPosition::ReturnValue' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.IsBlending
// 0x0001 (0x0001 - 0x0000)
struct LGlobalEnvActor_IsBlending final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGlobalEnvActor_IsBlending) == 0x000001, "Wrong alignment on LGlobalEnvActor_IsBlending");
static_assert(sizeof(LGlobalEnvActor_IsBlending) == 0x000001, "Wrong size on LGlobalEnvActor_IsBlending");
static_assert(offsetof(LGlobalEnvActor_IsBlending, ReturnValue) == 0x000000, "Member 'LGlobalEnvActor_IsBlending::ReturnValue' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.OnSetActiveEnvironment
// 0x0001 (0x0001 - 0x0000)
struct LGlobalEnvActor_OnSetActiveEnvironment final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGlobalEnvActor_OnSetActiveEnvironment) == 0x000001, "Wrong alignment on LGlobalEnvActor_OnSetActiveEnvironment");
static_assert(sizeof(LGlobalEnvActor_OnSetActiveEnvironment) == 0x000001, "Wrong size on LGlobalEnvActor_OnSetActiveEnvironment");
static_assert(offsetof(LGlobalEnvActor_OnSetActiveEnvironment, Active) == 0x000000, "Member 'LGlobalEnvActor_OnSetActiveEnvironment::Active' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.SetPreviewTarget
// 0x0004 (0x0004 - 0x0000)
struct LGlobalEnvActor_SetPreviewTarget final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGlobalEnvActor_SetPreviewTarget) == 0x000004, "Wrong alignment on LGlobalEnvActor_SetPreviewTarget");
static_assert(sizeof(LGlobalEnvActor_SetPreviewTarget) == 0x000004, "Wrong size on LGlobalEnvActor_SetPreviewTarget");
static_assert(offsetof(LGlobalEnvActor_SetPreviewTarget, Index_0) == 0x000000, "Member 'LGlobalEnvActor_SetPreviewTarget::Index_0' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.SpawnCustomLightning
// 0x0014 (0x0014 - 0x0000)
struct LGlobalEnvActor_SpawnCustomLightning final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGlobalEnvActor_SpawnCustomLightning) == 0x000004, "Wrong alignment on LGlobalEnvActor_SpawnCustomLightning");
static_assert(sizeof(LGlobalEnvActor_SpawnCustomLightning) == 0x000014, "Wrong size on LGlobalEnvActor_SpawnCustomLightning");
static_assert(offsetof(LGlobalEnvActor_SpawnCustomLightning, Delay) == 0x000000, "Member 'LGlobalEnvActor_SpawnCustomLightning::Delay' has a wrong offset!");
static_assert(offsetof(LGlobalEnvActor_SpawnCustomLightning, Direction) == 0x000004, "Member 'LGlobalEnvActor_SpawnCustomLightning::Direction' has a wrong offset!");
static_assert(offsetof(LGlobalEnvActor_SpawnCustomLightning, Intensity) == 0x000008, "Member 'LGlobalEnvActor_SpawnCustomLightning::Intensity' has a wrong offset!");
static_assert(offsetof(LGlobalEnvActor_SpawnCustomLightning, Distance) == 0x00000C, "Member 'LGlobalEnvActor_SpawnCustomLightning::Distance' has a wrong offset!");
static_assert(offsetof(LGlobalEnvActor_SpawnCustomLightning, Height) == 0x000010, "Member 'LGlobalEnvActor_SpawnCustomLightning::Height' has a wrong offset!");

// Function ProjectP.LGlobalEnvActor.StartBlend
// 0x000C (0x000C - 0x0000)
struct LGlobalEnvActor_StartBlend final
{
public:
	class FName                                   TargetName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGlobalEnvActor_StartBlend) == 0x000004, "Wrong alignment on LGlobalEnvActor_StartBlend");
static_assert(sizeof(LGlobalEnvActor_StartBlend) == 0x00000C, "Wrong size on LGlobalEnvActor_StartBlend");
static_assert(offsetof(LGlobalEnvActor_StartBlend, TargetName) == 0x000000, "Member 'LGlobalEnvActor_StartBlend::TargetName' has a wrong offset!");
static_assert(offsetof(LGlobalEnvActor_StartBlend, Duration) == 0x000008, "Member 'LGlobalEnvActor_StartBlend::Duration' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.AddNpcHitParts
// 0x0020 (0x0020 - 0x0000)
struct LEquipmentComponent_AddNpcHitParts final
{
public:
	class FName                                   NpcPartsCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillCodeNameOnDestroy;                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Primitive;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartsEnableWhenSpawn;                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_AddNpcHitParts) == 0x000008, "Wrong alignment on LEquipmentComponent_AddNpcHitParts");
static_assert(sizeof(LEquipmentComponent_AddNpcHitParts) == 0x000020, "Wrong size on LEquipmentComponent_AddNpcHitParts");
static_assert(offsetof(LEquipmentComponent_AddNpcHitParts, NpcPartsCodeName) == 0x000000, "Member 'LEquipmentComponent_AddNpcHitParts::NpcPartsCodeName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_AddNpcHitParts, SkillCodeNameOnDestroy) == 0x000008, "Member 'LEquipmentComponent_AddNpcHitParts::SkillCodeNameOnDestroy' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_AddNpcHitParts, Primitive) == 0x000010, "Member 'LEquipmentComponent_AddNpcHitParts::Primitive' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_AddNpcHitParts, bPartsEnableWhenSpawn) == 0x000018, "Member 'LEquipmentComponent_AddNpcHitParts::bPartsEnableWhenSpawn' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.ChangeTransformWeapon
// 0x0028 (0x0028 - 0x0000)
struct LEquipmentComponent_ChangeTransformWeapon final
{
public:
	ELWeaponAttachPointType                       MasterWeaponAttachPoint;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPoint1;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHandleCodeName1;                             // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBladeCodeName1;                              // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPoint2;                                // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHandleCodeName2;                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBladeCodeName2;                              // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_ChangeTransformWeapon) == 0x000004, "Wrong alignment on LEquipmentComponent_ChangeTransformWeapon");
static_assert(sizeof(LEquipmentComponent_ChangeTransformWeapon) == 0x000028, "Wrong size on LEquipmentComponent_ChangeTransformWeapon");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, MasterWeaponAttachPoint) == 0x000000, "Member 'LEquipmentComponent_ChangeTransformWeapon::MasterWeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, WeaponAttachPoint1) == 0x000001, "Member 'LEquipmentComponent_ChangeTransformWeapon::WeaponAttachPoint1' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, WeaponHandleCodeName1) == 0x000004, "Member 'LEquipmentComponent_ChangeTransformWeapon::WeaponHandleCodeName1' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, WeaponBladeCodeName1) == 0x00000C, "Member 'LEquipmentComponent_ChangeTransformWeapon::WeaponBladeCodeName1' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, WeaponAttachPoint2) == 0x000014, "Member 'LEquipmentComponent_ChangeTransformWeapon::WeaponAttachPoint2' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, WeaponHandleCodeName2) == 0x000018, "Member 'LEquipmentComponent_ChangeTransformWeapon::WeaponHandleCodeName2' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ChangeTransformWeapon, WeaponBladeCodeName2) == 0x000020, "Member 'LEquipmentComponent_ChangeTransformWeapon::WeaponBladeCodeName2' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.CheckHitPartsWeakElement
// 0x0120 (0x0120 - 0x0000)
struct LEquipmentComponent_CheckHitPartsWeakElement final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLCalcDamageData                       CalcDamageData;                                    // 0x0008(0x0110)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0118(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_CheckHitPartsWeakElement) == 0x000008, "Wrong alignment on LEquipmentComponent_CheckHitPartsWeakElement");
static_assert(sizeof(LEquipmentComponent_CheckHitPartsWeakElement) == 0x000120, "Wrong size on LEquipmentComponent_CheckHitPartsWeakElement");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsWeakElement, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_CheckHitPartsWeakElement::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsWeakElement, CalcDamageData) == 0x000008, "Member 'LEquipmentComponent_CheckHitPartsWeakElement::CalcDamageData' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsWeakElement, ReturnValue) == 0x000118, "Member 'LEquipmentComponent_CheckHitPartsWeakElement::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.CreateDecoShape
// 0x0038 (0x0038 - 0x0000)
struct LEquipmentComponent_CreateDecoShape final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bResponseCollision;                                // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_CreateDecoShape) == 0x000008, "Wrong alignment on LEquipmentComponent_CreateDecoShape");
static_assert(sizeof(LEquipmentComponent_CreateDecoShape) == 0x000038, "Wrong size on LEquipmentComponent_CreateDecoShape");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, MeshName) == 0x000000, "Member 'LEquipmentComponent_CreateDecoShape::MeshName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, Size) == 0x000008, "Member 'LEquipmentComponent_CreateDecoShape::Size' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, AttachSocketName) == 0x000014, "Member 'LEquipmentComponent_CreateDecoShape::AttachSocketName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, Rotation) == 0x00001C, "Member 'LEquipmentComponent_CreateDecoShape::Rotation' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, bResponseCollision) == 0x000028, "Member 'LEquipmentComponent_CreateDecoShape::bResponseCollision' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, bDebugDraw) == 0x000029, "Member 'LEquipmentComponent_CreateDecoShape::bDebugDraw' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoShape, ReturnValue) == 0x000030, "Member 'LEquipmentComponent_CreateDecoShape::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.CreateDecoStaticMesh
// 0x0028 (0x0028 - 0x0000)
struct LEquipmentComponent_CreateDecoStaticMesh final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResponseCollision;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisappear;                                        // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_CreateDecoStaticMesh) == 0x000008, "Wrong alignment on LEquipmentComponent_CreateDecoStaticMesh");
static_assert(sizeof(LEquipmentComponent_CreateDecoStaticMesh) == 0x000028, "Wrong size on LEquipmentComponent_CreateDecoStaticMesh");
static_assert(offsetof(LEquipmentComponent_CreateDecoStaticMesh, MeshName) == 0x000000, "Member 'LEquipmentComponent_CreateDecoStaticMesh::MeshName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoStaticMesh, StaticMesh) == 0x000008, "Member 'LEquipmentComponent_CreateDecoStaticMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoStaticMesh, AttachSocketName) == 0x000010, "Member 'LEquipmentComponent_CreateDecoStaticMesh::AttachSocketName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoStaticMesh, bResponseCollision) == 0x000018, "Member 'LEquipmentComponent_CreateDecoStaticMesh::bResponseCollision' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoStaticMesh, bDisappear) == 0x000019, "Member 'LEquipmentComponent_CreateDecoStaticMesh::bDisappear' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CreateDecoStaticMesh, ReturnValue) == 0x000020, "Member 'LEquipmentComponent_CreateDecoStaticMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.DestroyDecoMesh
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_DestroyDecoMesh final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_DestroyDecoMesh) == 0x000004, "Wrong alignment on LEquipmentComponent_DestroyDecoMesh");
static_assert(sizeof(LEquipmentComponent_DestroyDecoMesh) == 0x000008, "Wrong size on LEquipmentComponent_DestroyDecoMesh");
static_assert(offsetof(LEquipmentComponent_DestroyDecoMesh, MeshName) == 0x000000, "Member 'LEquipmentComponent_DestroyDecoMesh::MeshName' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.DoHeadCostumeOff
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_DoHeadCostumeOff final
{
public:
	bool                                          DoOff;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_DoHeadCostumeOff) == 0x000001, "Wrong alignment on LEquipmentComponent_DoHeadCostumeOff");
static_assert(sizeof(LEquipmentComponent_DoHeadCostumeOff) == 0x000001, "Wrong size on LEquipmentComponent_DoHeadCostumeOff");
static_assert(offsetof(LEquipmentComponent_DoHeadCostumeOff, DoOff) == 0x000000, "Member 'LEquipmentComponent_DoHeadCostumeOff::DoOff' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.DropPhysicsDecoStaticMesh
// 0x0018 (0x0018 - 0x0000)
struct LEquipmentComponent_DropPhysicsDecoStaticMesh final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnorePawn;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_DropPhysicsDecoStaticMesh) == 0x000008, "Wrong alignment on LEquipmentComponent_DropPhysicsDecoStaticMesh");
static_assert(sizeof(LEquipmentComponent_DropPhysicsDecoStaticMesh) == 0x000018, "Wrong size on LEquipmentComponent_DropPhysicsDecoStaticMesh");
static_assert(offsetof(LEquipmentComponent_DropPhysicsDecoStaticMesh, MeshName) == 0x000000, "Member 'LEquipmentComponent_DropPhysicsDecoStaticMesh::MeshName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_DropPhysicsDecoStaticMesh, IgnorePawn) == 0x000008, "Member 'LEquipmentComponent_DropPhysicsDecoStaticMesh::IgnorePawn' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_DropPhysicsDecoStaticMesh, ReturnValue) == 0x000010, "Member 'LEquipmentComponent_DropPhysicsDecoStaticMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.DropPickedWeapon
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_DropPickedWeapon final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_DropPickedWeapon) == 0x000001, "Wrong alignment on LEquipmentComponent_DropPickedWeapon");
static_assert(sizeof(LEquipmentComponent_DropPickedWeapon) == 0x000001, "Wrong size on LEquipmentComponent_DropPickedWeapon");
static_assert(offsetof(LEquipmentComponent_DropPickedWeapon, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_DropPickedWeapon::AttachPointType' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.FindDecoStaticMesh
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_FindDecoStaticMesh final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_FindDecoStaticMesh) == 0x000008, "Wrong alignment on LEquipmentComponent_FindDecoStaticMesh");
static_assert(sizeof(LEquipmentComponent_FindDecoStaticMesh) == 0x000010, "Wrong size on LEquipmentComponent_FindDecoStaticMesh");
static_assert(offsetof(LEquipmentComponent_FindDecoStaticMesh, MeshName) == 0x000000, "Member 'LEquipmentComponent_FindDecoStaticMesh::MeshName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_FindDecoStaticMesh, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_FindDecoStaticMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.FindPartsActor
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_FindPartsActor final
{
public:
	int32                                         PartsIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALPartsActor*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_FindPartsActor) == 0x000008, "Wrong alignment on LEquipmentComponent_FindPartsActor");
static_assert(sizeof(LEquipmentComponent_FindPartsActor) == 0x000010, "Wrong size on LEquipmentComponent_FindPartsActor");
static_assert(offsetof(LEquipmentComponent_FindPartsActor, PartsIndex) == 0x000000, "Member 'LEquipmentComponent_FindPartsActor::PartsIndex' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_FindPartsActor, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_FindPartsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.FindPartsCompByAttachPoint
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_FindPartsCompByAttachPoint final
{
public:
	ELPartsAttachPointType                        AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPartsComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_FindPartsCompByAttachPoint) == 0x000008, "Wrong alignment on LEquipmentComponent_FindPartsCompByAttachPoint");
static_assert(sizeof(LEquipmentComponent_FindPartsCompByAttachPoint) == 0x000010, "Wrong size on LEquipmentComponent_FindPartsCompByAttachPoint");
static_assert(offsetof(LEquipmentComponent_FindPartsCompByAttachPoint, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_FindPartsCompByAttachPoint::AttachPointType' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_FindPartsCompByAttachPoint, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_FindPartsCompByAttachPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.FindPartsCompByLinkBodyBone
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_FindPartsCompByLinkBodyBone final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_FindPartsCompByLinkBodyBone) == 0x000008, "Wrong alignment on LEquipmentComponent_FindPartsCompByLinkBodyBone");
static_assert(sizeof(LEquipmentComponent_FindPartsCompByLinkBodyBone) == 0x000010, "Wrong size on LEquipmentComponent_FindPartsCompByLinkBodyBone");
static_assert(offsetof(LEquipmentComponent_FindPartsCompByLinkBodyBone, BoneName) == 0x000000, "Member 'LEquipmentComponent_FindPartsCompByLinkBodyBone::BoneName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_FindPartsCompByLinkBodyBone, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_FindPartsCompByLinkBodyBone::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.FindPartsCompByNPCPartsCodeName
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_FindPartsCompByNPCPartsCodeName final
{
public:
	class FName                                   NpcPartsCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_FindPartsCompByNPCPartsCodeName) == 0x000008, "Wrong alignment on LEquipmentComponent_FindPartsCompByNPCPartsCodeName");
static_assert(sizeof(LEquipmentComponent_FindPartsCompByNPCPartsCodeName) == 0x000010, "Wrong size on LEquipmentComponent_FindPartsCompByNPCPartsCodeName");
static_assert(offsetof(LEquipmentComponent_FindPartsCompByNPCPartsCodeName, NpcPartsCodeName) == 0x000000, "Member 'LEquipmentComponent_FindPartsCompByNPCPartsCodeName::NpcPartsCodeName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_FindPartsCompByNPCPartsCodeName, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_FindPartsCompByNPCPartsCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetHitPartsNameByPrimitive
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetHitPartsNameByPrimitive final
{
public:
	class UPrimitiveComponent*                    Primitive;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetHitPartsNameByPrimitive) == 0x000008, "Wrong alignment on LEquipmentComponent_GetHitPartsNameByPrimitive");
static_assert(sizeof(LEquipmentComponent_GetHitPartsNameByPrimitive) == 0x000010, "Wrong size on LEquipmentComponent_GetHitPartsNameByPrimitive");
static_assert(offsetof(LEquipmentComponent_GetHitPartsNameByPrimitive, Primitive) == 0x000000, "Member 'LEquipmentComponent_GetHitPartsNameByPrimitive::Primitive' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetHitPartsNameByPrimitive, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetHitPartsNameByPrimitive::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetPartsComp
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetPartsComp final
{
public:
	int32                                         PartsIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPartsComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetPartsComp) == 0x000008, "Wrong alignment on LEquipmentComponent_GetPartsComp");
static_assert(sizeof(LEquipmentComponent_GetPartsComp) == 0x000010, "Wrong size on LEquipmentComponent_GetPartsComp");
static_assert(offsetof(LEquipmentComponent_GetPartsComp, PartsIndex) == 0x000000, "Member 'LEquipmentComponent_GetPartsComp::PartsIndex' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetPartsComp, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetPartsComp::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetPickedWeaponActor
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetPickedWeaponActor final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetPickedWeaponActor) == 0x000008, "Wrong alignment on LEquipmentComponent_GetPickedWeaponActor");
static_assert(sizeof(LEquipmentComponent_GetPickedWeaponActor) == 0x000010, "Wrong size on LEquipmentComponent_GetPickedWeaponActor");
static_assert(offsetof(LEquipmentComponent_GetPickedWeaponActor, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_GetPickedWeaponActor::AttachPointType' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetPickedWeaponActor, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetPickedWeaponActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetSelectedWeaponActor
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_GetSelectedWeaponActor final
{
public:
	class ALWeapon*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetSelectedWeaponActor) == 0x000008, "Wrong alignment on LEquipmentComponent_GetSelectedWeaponActor");
static_assert(sizeof(LEquipmentComponent_GetSelectedWeaponActor) == 0x000008, "Wrong size on LEquipmentComponent_GetSelectedWeaponActor");
static_assert(offsetof(LEquipmentComponent_GetSelectedWeaponActor, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_GetSelectedWeaponActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetSelectedWeaponIndex
// 0x0004 (0x0004 - 0x0000)
struct LEquipmentComponent_GetSelectedWeaponIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetSelectedWeaponIndex) == 0x000004, "Wrong alignment on LEquipmentComponent_GetSelectedWeaponIndex");
static_assert(sizeof(LEquipmentComponent_GetSelectedWeaponIndex) == 0x000004, "Wrong size on LEquipmentComponent_GetSelectedWeaponIndex");
static_assert(offsetof(LEquipmentComponent_GetSelectedWeaponIndex, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_GetSelectedWeaponIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetSlaveArmInfo
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_GetSlaveArmInfo final
{
public:
	class ULSlaveArmInfo*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetSlaveArmInfo) == 0x000008, "Wrong alignment on LEquipmentComponent_GetSlaveArmInfo");
static_assert(sizeof(LEquipmentComponent_GetSlaveArmInfo) == 0x000008, "Wrong size on LEquipmentComponent_GetSlaveArmInfo");
static_assert(offsetof(LEquipmentComponent_GetSlaveArmInfo, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_GetSlaveArmInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetWeaponActor
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetWeaponActor final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetWeaponActor) == 0x000008, "Wrong alignment on LEquipmentComponent_GetWeaponActor");
static_assert(sizeof(LEquipmentComponent_GetWeaponActor) == 0x000010, "Wrong size on LEquipmentComponent_GetWeaponActor");
static_assert(offsetof(LEquipmentComponent_GetWeaponActor, Index_0) == 0x000000, "Member 'LEquipmentComponent_GetWeaponActor::Index_0' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetWeaponActor, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetWeaponActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetWeaponByComponent
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetWeaponByComponent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetWeaponByComponent) == 0x000008, "Wrong alignment on LEquipmentComponent_GetWeaponByComponent");
static_assert(sizeof(LEquipmentComponent_GetWeaponByComponent) == 0x000010, "Wrong size on LEquipmentComponent_GetWeaponByComponent");
static_assert(offsetof(LEquipmentComponent_GetWeaponByComponent, Component) == 0x000000, "Member 'LEquipmentComponent_GetWeaponByComponent::Component' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetWeaponByComponent, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetWeaponByComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetWeaponByULItem
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetWeaponByULItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetWeaponByULItem) == 0x000008, "Wrong alignment on LEquipmentComponent_GetWeaponByULItem");
static_assert(sizeof(LEquipmentComponent_GetWeaponByULItem) == 0x000010, "Wrong size on LEquipmentComponent_GetWeaponByULItem");
static_assert(offsetof(LEquipmentComponent_GetWeaponByULItem, Item) == 0x000000, "Member 'LEquipmentComponent_GetWeaponByULItem::Item' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetWeaponByULItem, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetWeaponByULItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetWeaponItem
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetWeaponItem final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULWeaponItem*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetWeaponItem) == 0x000008, "Wrong alignment on LEquipmentComponent_GetWeaponItem");
static_assert(sizeof(LEquipmentComponent_GetWeaponItem) == 0x000010, "Wrong size on LEquipmentComponent_GetWeaponItem");
static_assert(offsetof(LEquipmentComponent_GetWeaponItem, Index_0) == 0x000000, "Member 'LEquipmentComponent_GetWeaponItem::Index_0' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetWeaponItem, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetWeaponItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.HasDecoMeshResponseCollision
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_HasDecoMeshResponseCollision final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_HasDecoMeshResponseCollision) == 0x000008, "Wrong alignment on LEquipmentComponent_HasDecoMeshResponseCollision");
static_assert(sizeof(LEquipmentComponent_HasDecoMeshResponseCollision) == 0x000010, "Wrong size on LEquipmentComponent_HasDecoMeshResponseCollision");
static_assert(offsetof(LEquipmentComponent_HasDecoMeshResponseCollision, PrimitiveComponent) == 0x000000, "Member 'LEquipmentComponent_HasDecoMeshResponseCollision::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_HasDecoMeshResponseCollision, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_HasDecoMeshResponseCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.IsDecoMesh
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_IsDecoMesh final
{
public:
	class UPrimitiveComponent*                    MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_IsDecoMesh) == 0x000008, "Wrong alignment on LEquipmentComponent_IsDecoMesh");
static_assert(sizeof(LEquipmentComponent_IsDecoMesh) == 0x000010, "Wrong size on LEquipmentComponent_IsDecoMesh");
static_assert(offsetof(LEquipmentComponent_IsDecoMesh, MeshComponent) == 0x000000, "Member 'LEquipmentComponent_IsDecoMesh::MeshComponent' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_IsDecoMesh, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_IsDecoMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.IsHitPartsByPrimitive
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_IsHitPartsByPrimitive final
{
public:
	class UPrimitiveComponent*                    Primitive;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_IsHitPartsByPrimitive) == 0x000008, "Wrong alignment on LEquipmentComponent_IsHitPartsByPrimitive");
static_assert(sizeof(LEquipmentComponent_IsHitPartsByPrimitive) == 0x000010, "Wrong size on LEquipmentComponent_IsHitPartsByPrimitive");
static_assert(offsetof(LEquipmentComponent_IsHitPartsByPrimitive, Primitive) == 0x000000, "Member 'LEquipmentComponent_IsHitPartsByPrimitive::Primitive' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_IsHitPartsByPrimitive, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_IsHitPartsByPrimitive::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.PickWeapon
// 0x0018 (0x0018 - 0x0000)
struct LEquipmentComponent_PickWeapon final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPickWeaponChangeMotionType                  ChangeMotionType;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_PickWeapon) == 0x000008, "Wrong alignment on LEquipmentComponent_PickWeapon");
static_assert(sizeof(LEquipmentComponent_PickWeapon) == 0x000018, "Wrong size on LEquipmentComponent_PickWeapon");
static_assert(offsetof(LEquipmentComponent_PickWeapon, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_PickWeapon::AttachPointType' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_PickWeapon, Index_0) == 0x000004, "Member 'LEquipmentComponent_PickWeapon::Index_0' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_PickWeapon, ChangeMotionType) == 0x000008, "Member 'LEquipmentComponent_PickWeapon::ChangeMotionType' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_PickWeapon, ReturnValue) == 0x000010, "Member 'LEquipmentComponent_PickWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.ResetDeco
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_ResetDeco final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_ResetDeco) == 0x000004, "Wrong alignment on LEquipmentComponent_ResetDeco");
static_assert(sizeof(LEquipmentComponent_ResetDeco) == 0x000008, "Wrong size on LEquipmentComponent_ResetDeco");
static_assert(offsetof(LEquipmentComponent_ResetDeco, MeshName) == 0x000000, "Member 'LEquipmentComponent_ResetDeco::MeshName' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.ResetDecoStaticMesh
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_ResetDecoStaticMesh final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_ResetDecoStaticMesh) == 0x000008, "Wrong alignment on LEquipmentComponent_ResetDecoStaticMesh");
static_assert(sizeof(LEquipmentComponent_ResetDecoStaticMesh) == 0x000010, "Wrong size on LEquipmentComponent_ResetDecoStaticMesh");
static_assert(offsetof(LEquipmentComponent_ResetDecoStaticMesh, MeshName) == 0x000000, "Member 'LEquipmentComponent_ResetDecoStaticMesh::MeshName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_ResetDecoStaticMesh, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_ResetDecoStaticMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.ResetWeapon
// 0x0004 (0x0004 - 0x0000)
struct LEquipmentComponent_ResetWeapon final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_ResetWeapon) == 0x000004, "Wrong alignment on LEquipmentComponent_ResetWeapon");
static_assert(sizeof(LEquipmentComponent_ResetWeapon) == 0x000004, "Wrong size on LEquipmentComponent_ResetWeapon");
static_assert(offsetof(LEquipmentComponent_ResetWeapon, Index_0) == 0x000000, "Member 'LEquipmentComponent_ResetWeapon::Index_0' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.RespawnWeaponByItem
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_RespawnWeaponByItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_RespawnWeaponByItem) == 0x000008, "Wrong alignment on LEquipmentComponent_RespawnWeaponByItem");
static_assert(sizeof(LEquipmentComponent_RespawnWeaponByItem) == 0x000008, "Wrong size on LEquipmentComponent_RespawnWeaponByItem");
static_assert(offsetof(LEquipmentComponent_RespawnWeaponByItem, Item) == 0x000000, "Member 'LEquipmentComponent_RespawnWeaponByItem::Item' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SelectSlaveArm
// 0x0004 (0x0004 - 0x0000)
struct LEquipmentComponent_SelectSlaveArm final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SelectSlaveArm) == 0x000004, "Wrong alignment on LEquipmentComponent_SelectSlaveArm");
static_assert(sizeof(LEquipmentComponent_SelectSlaveArm) == 0x000004, "Wrong size on LEquipmentComponent_SelectSlaveArm");
static_assert(offsetof(LEquipmentComponent_SelectSlaveArm, Index_0) == 0x000000, "Member 'LEquipmentComponent_SelectSlaveArm::Index_0' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SelectWeapon
// 0x0004 (0x0004 - 0x0000)
struct LEquipmentComponent_SelectWeapon final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SelectWeapon) == 0x000004, "Wrong alignment on LEquipmentComponent_SelectWeapon");
static_assert(sizeof(LEquipmentComponent_SelectWeapon) == 0x000004, "Wrong size on LEquipmentComponent_SelectWeapon");
static_assert(offsetof(LEquipmentComponent_SelectWeapon, Index_0) == 0x000000, "Member 'LEquipmentComponent_SelectWeapon::Index_0' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SetDecoHidden
// 0x000C (0x000C - 0x0000)
struct LEquipmentComponent_SetDecoHidden final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_SetDecoHidden) == 0x000004, "Wrong alignment on LEquipmentComponent_SetDecoHidden");
static_assert(sizeof(LEquipmentComponent_SetDecoHidden) == 0x00000C, "Wrong size on LEquipmentComponent_SetDecoHidden");
static_assert(offsetof(LEquipmentComponent_SetDecoHidden, MeshName) == 0x000000, "Member 'LEquipmentComponent_SetDecoHidden::MeshName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_SetDecoHidden, bHidden) == 0x000008, "Member 'LEquipmentComponent_SetDecoHidden::bHidden' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SetDecoNoCollsion
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_SetDecoNoCollsion final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SetDecoNoCollsion) == 0x000004, "Wrong alignment on LEquipmentComponent_SetDecoNoCollsion");
static_assert(sizeof(LEquipmentComponent_SetDecoNoCollsion) == 0x000008, "Wrong size on LEquipmentComponent_SetDecoNoCollsion");
static_assert(offsetof(LEquipmentComponent_SetDecoNoCollsion, MeshName) == 0x000000, "Member 'LEquipmentComponent_SetDecoNoCollsion::MeshName' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SetParts
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_SetParts final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SetParts) == 0x000008, "Wrong alignment on LEquipmentComponent_SetParts");
static_assert(sizeof(LEquipmentComponent_SetParts) == 0x000008, "Wrong size on LEquipmentComponent_SetParts");
static_assert(offsetof(LEquipmentComponent_SetParts, Item) == 0x000000, "Member 'LEquipmentComponent_SetParts::Item' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SetSlaveArmByItem
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_SetSlaveArmByItem final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SetSlaveArmByItem) == 0x000008, "Wrong alignment on LEquipmentComponent_SetSlaveArmByItem");
static_assert(sizeof(LEquipmentComponent_SetSlaveArmByItem) == 0x000010, "Wrong size on LEquipmentComponent_SetSlaveArmByItem");
static_assert(offsetof(LEquipmentComponent_SetSlaveArmByItem, Index_0) == 0x000000, "Member 'LEquipmentComponent_SetSlaveArmByItem::Index_0' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_SetSlaveArmByItem, Item) == 0x000008, "Member 'LEquipmentComponent_SetSlaveArmByItem::Item' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SetWeaponByItem
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_SetWeaponByItem final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SetWeaponByItem) == 0x000008, "Wrong alignment on LEquipmentComponent_SetWeaponByItem");
static_assert(sizeof(LEquipmentComponent_SetWeaponByItem) == 0x000010, "Wrong size on LEquipmentComponent_SetWeaponByItem");
static_assert(offsetof(LEquipmentComponent_SetWeaponByItem, Index_0) == 0x000000, "Member 'LEquipmentComponent_SetWeaponByItem::Index_0' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_SetWeaponByItem, Item) == 0x000008, "Member 'LEquipmentComponent_SetWeaponByItem::Item' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SetWeaponByItemWeaponMonster
// 0x000C (0x000C - 0x0000)
struct LEquipmentComponent_SetWeaponByItemWeaponMonster final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemWeaponMonsterCodeName;                         // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SetWeaponByItemWeaponMonster) == 0x000004, "Wrong alignment on LEquipmentComponent_SetWeaponByItemWeaponMonster");
static_assert(sizeof(LEquipmentComponent_SetWeaponByItemWeaponMonster) == 0x00000C, "Wrong size on LEquipmentComponent_SetWeaponByItemWeaponMonster");
static_assert(offsetof(LEquipmentComponent_SetWeaponByItemWeaponMonster, Index_0) == 0x000000, "Member 'LEquipmentComponent_SetWeaponByItemWeaponMonster::Index_0' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_SetWeaponByItemWeaponMonster, ItemWeaponMonsterCodeName) == 0x000004, "Member 'LEquipmentComponent_SetWeaponByItemWeaponMonster::ItemWeaponMonsterCodeName' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SpawnWeapon
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_SpawnWeapon final
{
public:
	class ALWeapon*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SpawnWeapon) == 0x000008, "Wrong alignment on LEquipmentComponent_SpawnWeapon");
static_assert(sizeof(LEquipmentComponent_SpawnWeapon) == 0x000008, "Wrong size on LEquipmentComponent_SpawnWeapon");
static_assert(offsetof(LEquipmentComponent_SpawnWeapon, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_SpawnWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.SpawnWeaponWithClass
// 0x0018 (0x0018 - 0x0000)
struct LEquipmentComponent_SpawnWeaponWithClass final
{
public:
	TSubclassOf<class ALWeapon>                   HandleWeaponClass;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALWeapon>                   BladeWeaponClass;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_SpawnWeaponWithClass) == 0x000008, "Wrong alignment on LEquipmentComponent_SpawnWeaponWithClass");
static_assert(sizeof(LEquipmentComponent_SpawnWeaponWithClass) == 0x000018, "Wrong size on LEquipmentComponent_SpawnWeaponWithClass");
static_assert(offsetof(LEquipmentComponent_SpawnWeaponWithClass, HandleWeaponClass) == 0x000000, "Member 'LEquipmentComponent_SpawnWeaponWithClass::HandleWeaponClass' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_SpawnWeaponWithClass, BladeWeaponClass) == 0x000008, "Member 'LEquipmentComponent_SpawnWeaponWithClass::BladeWeaponClass' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_SpawnWeaponWithClass, ReturnValue) == 0x000010, "Member 'LEquipmentComponent_SpawnWeaponWithClass::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.UnChangeTransformWeapon
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_UnChangeTransformWeapon final
{
public:
	ELWeaponAttachPointType                       OriginalWeaponAttachPoint;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_UnChangeTransformWeapon) == 0x000001, "Wrong alignment on LEquipmentComponent_UnChangeTransformWeapon");
static_assert(sizeof(LEquipmentComponent_UnChangeTransformWeapon) == 0x000001, "Wrong size on LEquipmentComponent_UnChangeTransformWeapon");
static_assert(offsetof(LEquipmentComponent_UnChangeTransformWeapon, OriginalWeaponAttachPoint) == 0x000000, "Member 'LEquipmentComponent_UnChangeTransformWeapon::OriginalWeaponAttachPoint' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.UnPickWeapon
// 0x0002 (0x0002 - 0x0000)
struct LEquipmentComponent_UnPickWeapon final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPickWeaponChangeMotionType                  ChangeMotionType;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_UnPickWeapon) == 0x000001, "Wrong alignment on LEquipmentComponent_UnPickWeapon");
static_assert(sizeof(LEquipmentComponent_UnPickWeapon) == 0x000002, "Wrong size on LEquipmentComponent_UnPickWeapon");
static_assert(offsetof(LEquipmentComponent_UnPickWeapon, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_UnPickWeapon::AttachPointType' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_UnPickWeapon, ChangeMotionType) == 0x000001, "Member 'LEquipmentComponent_UnPickWeapon::ChangeMotionType' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.WeaponOff
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_WeaponOff final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_WeaponOff) == 0x000001, "Wrong alignment on LEquipmentComponent_WeaponOff");
static_assert(sizeof(LEquipmentComponent_WeaponOff) == 0x000001, "Wrong size on LEquipmentComponent_WeaponOff");
static_assert(offsetof(LEquipmentComponent_WeaponOff, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_WeaponOff::AttachPointType' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.WeaponOn
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_WeaponOn final
{
public:
	ELWeaponAttachPointType                       AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_WeaponOn) == 0x000001, "Wrong alignment on LEquipmentComponent_WeaponOn");
static_assert(sizeof(LEquipmentComponent_WeaponOn) == 0x000001, "Wrong size on LEquipmentComponent_WeaponOn");
static_assert(offsetof(LEquipmentComponent_WeaponOn, AttachPointType) == 0x000000, "Member 'LEquipmentComponent_WeaponOn::AttachPointType' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.WeaponOnOffOwnerHidden
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_WeaponOnOffOwnerHidden final
{
public:
	bool                                          bOnOff;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_WeaponOnOffOwnerHidden) == 0x000001, "Wrong alignment on LEquipmentComponent_WeaponOnOffOwnerHidden");
static_assert(sizeof(LEquipmentComponent_WeaponOnOffOwnerHidden) == 0x000001, "Wrong size on LEquipmentComponent_WeaponOnOffOwnerHidden");
static_assert(offsetof(LEquipmentComponent_WeaponOnOffOwnerHidden, bOnOff) == 0x000000, "Member 'LEquipmentComponent_WeaponOnOffOwnerHidden::bOnOff' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.CheckHitPartsRepulseHitRangeAngle
// 0x0020 (0x0020 - 0x0000)
struct LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Attacker;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle) == 0x000008, "Wrong alignment on LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle");
static_assert(sizeof(LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle) == 0x000020, "Wrong size on LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle, Attacker) == 0x000008, "Member 'LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle::Attacker' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle, Victim) == 0x000010, "Member 'LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle::Victim' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle, ReturnValue) == 0x000018, "Member 'LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.CheckHitPartsRepulseLevel
// 0x0014 (0x0014 - 0x0000)
struct LEquipmentComponent_CheckHitPartsRepulseLevel final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          InPhysicalDamageType;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InAttackRepulseLevel;                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_CheckHitPartsRepulseLevel) == 0x000004, "Wrong alignment on LEquipmentComponent_CheckHitPartsRepulseLevel");
static_assert(sizeof(LEquipmentComponent_CheckHitPartsRepulseLevel) == 0x000014, "Wrong size on LEquipmentComponent_CheckHitPartsRepulseLevel");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseLevel, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_CheckHitPartsRepulseLevel::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseLevel, InPhysicalDamageType) == 0x000008, "Member 'LEquipmentComponent_CheckHitPartsRepulseLevel::InPhysicalDamageType' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseLevel, InAttackRepulseLevel) == 0x00000C, "Member 'LEquipmentComponent_CheckHitPartsRepulseLevel::InAttackRepulseLevel' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_CheckHitPartsRepulseLevel, ReturnValue) == 0x000010, "Member 'LEquipmentComponent_CheckHitPartsRepulseLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetCurrentMeshBody
// 0x0008 (0x0008 - 0x0000)
struct LEquipmentComponent_GetCurrentMeshBody final
{
public:
	class USkeletalMesh*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetCurrentMeshBody) == 0x000008, "Wrong alignment on LEquipmentComponent_GetCurrentMeshBody");
static_assert(sizeof(LEquipmentComponent_GetCurrentMeshBody) == 0x000008, "Wrong size on LEquipmentComponent_GetCurrentMeshBody");
static_assert(offsetof(LEquipmentComponent_GetCurrentMeshBody, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_GetCurrentMeshBody::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetHitPartsSkillCodeNameOnDestory
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory) == 0x000004, "Wrong alignment on LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory");
static_assert(sizeof(LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory) == 0x000010, "Wrong size on LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory");
static_assert(offsetof(LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetPartsComponents
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetPartsComponents final
{
public:
	TArray<class ULPartsComponent*>               ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetPartsComponents) == 0x000008, "Wrong alignment on LEquipmentComponent_GetPartsComponents");
static_assert(sizeof(LEquipmentComponent_GetPartsComponents) == 0x000010, "Wrong size on LEquipmentComponent_GetPartsComponents");
static_assert(offsetof(LEquipmentComponent_GetPartsComponents, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_GetPartsComponents::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.GetWeakElementSkillCodeName
// 0x0010 (0x0010 - 0x0000)
struct LEquipmentComponent_GetWeakElementSkillCodeName final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_GetWeakElementSkillCodeName) == 0x000004, "Wrong alignment on LEquipmentComponent_GetWeakElementSkillCodeName");
static_assert(sizeof(LEquipmentComponent_GetWeakElementSkillCodeName) == 0x000010, "Wrong size on LEquipmentComponent_GetWeakElementSkillCodeName");
static_assert(offsetof(LEquipmentComponent_GetWeakElementSkillCodeName, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_GetWeakElementSkillCodeName::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_GetWeakElementSkillCodeName, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_GetWeakElementSkillCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.IsBodyNeedShrink
// 0x0001 (0x0001 - 0x0000)
struct LEquipmentComponent_IsBodyNeedShrink final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEquipmentComponent_IsBodyNeedShrink) == 0x000001, "Wrong alignment on LEquipmentComponent_IsBodyNeedShrink");
static_assert(sizeof(LEquipmentComponent_IsBodyNeedShrink) == 0x000001, "Wrong size on LEquipmentComponent_IsBodyNeedShrink");
static_assert(offsetof(LEquipmentComponent_IsBodyNeedShrink, ReturnValue) == 0x000000, "Member 'LEquipmentComponent_IsBodyNeedShrink::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.IsHitPartsDestoryed
// 0x000C (0x000C - 0x0000)
struct LEquipmentComponent_IsHitPartsDestoryed final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_IsHitPartsDestoryed) == 0x000004, "Wrong alignment on LEquipmentComponent_IsHitPartsDestoryed");
static_assert(sizeof(LEquipmentComponent_IsHitPartsDestoryed) == 0x00000C, "Wrong size on LEquipmentComponent_IsHitPartsDestoryed");
static_assert(offsetof(LEquipmentComponent_IsHitPartsDestoryed, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_IsHitPartsDestoryed::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_IsHitPartsDestoryed, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_IsHitPartsDestoryed::ReturnValue' has a wrong offset!");

// Function ProjectP.LEquipmentComponent.IsHitPartsEnabled
// 0x000C (0x000C - 0x0000)
struct LEquipmentComponent_IsHitPartsEnabled final
{
public:
	class FName                                   HitPartsName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEquipmentComponent_IsHitPartsEnabled) == 0x000004, "Wrong alignment on LEquipmentComponent_IsHitPartsEnabled");
static_assert(sizeof(LEquipmentComponent_IsHitPartsEnabled) == 0x00000C, "Wrong size on LEquipmentComponent_IsHitPartsEnabled");
static_assert(offsetof(LEquipmentComponent_IsHitPartsEnabled, HitPartsName) == 0x000000, "Member 'LEquipmentComponent_IsHitPartsEnabled::HitPartsName' has a wrong offset!");
static_assert(offsetof(LEquipmentComponent_IsHitPartsEnabled, ReturnValue) == 0x000008, "Member 'LEquipmentComponent_IsHitPartsEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.CaptureMomentCondition
// 0x0030 (0x0030 - 0x0000)
struct LEventDispatcherSystem_CaptureMomentCondition final
{
public:
	struct FMomentConditionCaptureInfo            CapturedInfo;                                      // 0x0000(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEventDispatcherSystem_CaptureMomentCondition) == 0x000008, "Wrong alignment on LEventDispatcherSystem_CaptureMomentCondition");
static_assert(sizeof(LEventDispatcherSystem_CaptureMomentCondition) == 0x000030, "Wrong size on LEventDispatcherSystem_CaptureMomentCondition");
static_assert(offsetof(LEventDispatcherSystem_CaptureMomentCondition, CapturedInfo) == 0x000000, "Member 'LEventDispatcherSystem_CaptureMomentCondition::CapturedInfo' has a wrong offset!");
static_assert(offsetof(LEventDispatcherSystem_CaptureMomentCondition, Owner) == 0x000028, "Member 'LEventDispatcherSystem_CaptureMomentCondition::Owner' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.OnUIConfirmNewGamePlus
// 0x0001 (0x0001 - 0x0000)
struct LEventDispatcherSystem_OnUIConfirmNewGamePlus final
{
public:
	bool                                          IsConfirm;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEventDispatcherSystem_OnUIConfirmNewGamePlus) == 0x000001, "Wrong alignment on LEventDispatcherSystem_OnUIConfirmNewGamePlus");
static_assert(sizeof(LEventDispatcherSystem_OnUIConfirmNewGamePlus) == 0x000001, "Wrong size on LEventDispatcherSystem_OnUIConfirmNewGamePlus");
static_assert(offsetof(LEventDispatcherSystem_OnUIConfirmNewGamePlus, IsConfirm) == 0x000000, "Member 'LEventDispatcherSystem_OnUIConfirmNewGamePlus::IsConfirm' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.RaiseSenseToActor
// 0x0020 (0x0020 - 0x0000)
struct LEventDispatcherSystem_RaiseSenseToActor final
{
public:
	class AActor*                                 Reciever;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAISenseTakeLocation                  TakeLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEventDispatcherSystem_RaiseSenseToActor) == 0x000008, "Wrong alignment on LEventDispatcherSystem_RaiseSenseToActor");
static_assert(sizeof(LEventDispatcherSystem_RaiseSenseToActor) == 0x000020, "Wrong size on LEventDispatcherSystem_RaiseSenseToActor");
static_assert(offsetof(LEventDispatcherSystem_RaiseSenseToActor, Reciever) == 0x000000, "Member 'LEventDispatcherSystem_RaiseSenseToActor::Reciever' has a wrong offset!");
static_assert(offsetof(LEventDispatcherSystem_RaiseSenseToActor, TakeLocation) == 0x000008, "Member 'LEventDispatcherSystem_RaiseSenseToActor::TakeLocation' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.RaiseSenseToActors
// 0x0018 (0x0018 - 0x0000)
struct LEventDispatcherSystem_RaiseSenseToActors final
{
public:
	struct FLAISenseTakeLocation                  TakeLocation;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEventDispatcherSystem_RaiseSenseToActors) == 0x000004, "Wrong alignment on LEventDispatcherSystem_RaiseSenseToActors");
static_assert(sizeof(LEventDispatcherSystem_RaiseSenseToActors) == 0x000018, "Wrong size on LEventDispatcherSystem_RaiseSenseToActors");
static_assert(offsetof(LEventDispatcherSystem_RaiseSenseToActors, TakeLocation) == 0x000000, "Member 'LEventDispatcherSystem_RaiseSenseToActors::TakeLocation' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.SendHelpSignal
// 0x0010 (0x0010 - 0x0000)
struct LEventDispatcherSystem_SendHelpSignal final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideRange;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LEventDispatcherSystem_SendHelpSignal) == 0x000008, "Wrong alignment on LEventDispatcherSystem_SendHelpSignal");
static_assert(sizeof(LEventDispatcherSystem_SendHelpSignal) == 0x000010, "Wrong size on LEventDispatcherSystem_SendHelpSignal");
static_assert(offsetof(LEventDispatcherSystem_SendHelpSignal, Target) == 0x000000, "Member 'LEventDispatcherSystem_SendHelpSignal::Target' has a wrong offset!");
static_assert(offsetof(LEventDispatcherSystem_SendHelpSignal, OverrideRange) == 0x000008, "Member 'LEventDispatcherSystem_SendHelpSignal::OverrideRange' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.SenseTargetToActor
// 0x0018 (0x0018 - 0x0000)
struct LEventDispatcherSystem_SenseTargetToActor final
{
public:
	class AActor*                                 Reciever;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAISense                                     Sense;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEventDispatcherSystem_SenseTargetToActor) == 0x000008, "Wrong alignment on LEventDispatcherSystem_SenseTargetToActor");
static_assert(sizeof(LEventDispatcherSystem_SenseTargetToActor) == 0x000018, "Wrong size on LEventDispatcherSystem_SenseTargetToActor");
static_assert(offsetof(LEventDispatcherSystem_SenseTargetToActor, Reciever) == 0x000000, "Member 'LEventDispatcherSystem_SenseTargetToActor::Reciever' has a wrong offset!");
static_assert(offsetof(LEventDispatcherSystem_SenseTargetToActor, Sense) == 0x000008, "Member 'LEventDispatcherSystem_SenseTargetToActor::Sense' has a wrong offset!");
static_assert(offsetof(LEventDispatcherSystem_SenseTargetToActor, Target) == 0x000010, "Member 'LEventDispatcherSystem_SenseTargetToActor::Target' has a wrong offset!");

// Function ProjectP.LEventDispatcherSystem.SenseTargetToCharacters
// 0x0010 (0x0010 - 0x0000)
struct LEventDispatcherSystem_SenseTargetToCharacters final
{
public:
	ELAISense                                     Sense;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LEventDispatcherSystem_SenseTargetToCharacters) == 0x000008, "Wrong alignment on LEventDispatcherSystem_SenseTargetToCharacters");
static_assert(sizeof(LEventDispatcherSystem_SenseTargetToCharacters) == 0x000010, "Wrong size on LEventDispatcherSystem_SenseTargetToCharacters");
static_assert(offsetof(LEventDispatcherSystem_SenseTargetToCharacters, Sense) == 0x000000, "Member 'LEventDispatcherSystem_SenseTargetToCharacters::Sense' has a wrong offset!");
static_assert(offsetof(LEventDispatcherSystem_SenseTargetToCharacters, Target) == 0x000008, "Member 'LEventDispatcherSystem_SenseTargetToCharacters::Target' has a wrong offset!");

// Function ProjectP.LExiledNpcArea.OnComponentBeginOverlapped_Warning_Inner
// 0x00A8 (0x00A8 - 0x0000)
struct LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner) == 0x000008, "Wrong alignment on LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner");
static_assert(sizeof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner) == 0x0000A8, "Wrong size on LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner, OverlappedComp) == 0x000000, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner, Other) == 0x000008, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner::Other' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner, OtherComp) == 0x000010, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner::OtherComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner, OtherBodyIndex) == 0x000018, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner, bFromSweep) == 0x00001C, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner::bFromSweep' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner, OverlapInfo) == 0x000020, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner::OverlapInfo' has a wrong offset!");

// Function ProjectP.LExiledNpcArea.OnComponentBeginOverlapped_Warning_Outer
// 0x00A8 (0x00A8 - 0x0000)
struct LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer) == 0x000008, "Wrong alignment on LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer");
static_assert(sizeof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer) == 0x0000A8, "Wrong size on LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer, OverlappedComp) == 0x000000, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer, Other) == 0x000008, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer::Other' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer, OtherComp) == 0x000010, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer::OtherComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer, OtherBodyIndex) == 0x000018, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer, bFromSweep) == 0x00001C, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer::bFromSweep' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer, OverlapInfo) == 0x000020, "Member 'LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer::OverlapInfo' has a wrong offset!");

// Function ProjectP.LExiledNpcArea.OnComponentEndOverlapped_Warning_Inner
// 0x0020 (0x0020 - 0x0000)
struct LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner) == 0x000008, "Wrong alignment on LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner");
static_assert(sizeof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner) == 0x000020, "Wrong size on LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner, OverlappedComp) == 0x000000, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner, Other) == 0x000008, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner::Other' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner, OtherComp) == 0x000010, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner::OtherComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner, OtherBodyIndex) == 0x000018, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LExiledNpcArea.OnComponentEndOverlapped_Warning_Outer
// 0x0020 (0x0020 - 0x0000)
struct LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer) == 0x000008, "Wrong alignment on LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer");
static_assert(sizeof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer) == 0x000020, "Wrong size on LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer, OverlappedComp) == 0x000000, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer, Other) == 0x000008, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer::Other' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer, OtherComp) == 0x000010, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer::OtherComp' has a wrong offset!");
static_assert(offsetof(LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer, OtherBodyIndex) == 0x000018, "Member 'LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LExiledNpcSystem.MakeNewContextBP
// 0x0001 (0x0001 - 0x0000)
struct LExiledNpcSystem_MakeNewContextBP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LExiledNpcSystem_MakeNewContextBP) == 0x000001, "Wrong alignment on LExiledNpcSystem_MakeNewContextBP");
static_assert(sizeof(LExiledNpcSystem_MakeNewContextBP) == 0x000001, "Wrong size on LExiledNpcSystem_MakeNewContextBP");
static_assert(offsetof(LExiledNpcSystem_MakeNewContextBP, ReturnValue) == 0x000000, "Member 'LExiledNpcSystem_MakeNewContextBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LFrenzyComponent.DeactivateFrenzy
// 0x0001 (0x0001 - 0x0000)
struct LFrenzyComponent_DeactivateFrenzy final
{
public:
	bool                                          bExhaustAllFrenzyPoint;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFrenzyComponent_DeactivateFrenzy) == 0x000001, "Wrong alignment on LFrenzyComponent_DeactivateFrenzy");
static_assert(sizeof(LFrenzyComponent_DeactivateFrenzy) == 0x000001, "Wrong size on LFrenzyComponent_DeactivateFrenzy");
static_assert(offsetof(LFrenzyComponent_DeactivateFrenzy, bExhaustAllFrenzyPoint) == 0x000000, "Member 'LFrenzyComponent_DeactivateFrenzy::bExhaustAllFrenzyPoint' has a wrong offset!");

// Function ProjectP.LFrenzyComponent.IsActivated
// 0x0001 (0x0001 - 0x0000)
struct LFrenzyComponent_IsActivated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFrenzyComponent_IsActivated) == 0x000001, "Wrong alignment on LFrenzyComponent_IsActivated");
static_assert(sizeof(LFrenzyComponent_IsActivated) == 0x000001, "Wrong size on LFrenzyComponent_IsActivated");
static_assert(offsetof(LFrenzyComponent_IsActivated, ReturnValue) == 0x000000, "Member 'LFrenzyComponent_IsActivated::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCSpotTriggerComponent.OnComponentBeginOverlapSpotTrigger
// 0x00A8 (0x00A8 - 0x0000)
struct LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger) == 0x000008, "Wrong alignment on LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger");
static_assert(sizeof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger) == 0x0000A8, "Wrong size on LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger");
static_assert(offsetof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger, OverlappedComponent) == 0x000000, "Member 'LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger, OtherActor) == 0x000008, "Member 'LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger::OtherActor' has a wrong offset!");
static_assert(offsetof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger, OtherComp) == 0x000010, "Member 'LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger::OtherComp' has a wrong offset!");
static_assert(offsetof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger, OtherBodyIndex) == 0x000018, "Member 'LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger, bFromSweep) == 0x00001C, "Member 'LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger::bFromSweep' has a wrong offset!");
static_assert(offsetof(LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger, SweepResult) == 0x000020, "Member 'LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger::SweepResult' has a wrong offset!");

// Function ProjectP.LFXVaryingComponent.IsPlayingVaryingName
// 0x000C (0x000C - 0x0000)
struct LFXVaryingComponent_IsPlayingVaryingName final
{
public:
	class FName                                   PlayName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXVaryingComponent_IsPlayingVaryingName) == 0x000004, "Wrong alignment on LFXVaryingComponent_IsPlayingVaryingName");
static_assert(sizeof(LFXVaryingComponent_IsPlayingVaryingName) == 0x00000C, "Wrong size on LFXVaryingComponent_IsPlayingVaryingName");
static_assert(offsetof(LFXVaryingComponent_IsPlayingVaryingName, PlayName) == 0x000000, "Member 'LFXVaryingComponent_IsPlayingVaryingName::PlayName' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_IsPlayingVaryingName, ReturnValue) == 0x000008, "Member 'LFXVaryingComponent_IsPlayingVaryingName::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXVaryingComponent.PlayVaryingWithMesh
// 0x0028 (0x0028 - 0x0000)
struct LFXVaryingComponent_PlayVaryingWithMesh final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MeshComp;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetToDefault;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayName;                                          // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXVaryingComponent_PlayVaryingWithMesh) == 0x000008, "Wrong alignment on LFXVaryingComponent_PlayVaryingWithMesh");
static_assert(sizeof(LFXVaryingComponent_PlayVaryingWithMesh) == 0x000028, "Wrong size on LFXVaryingComponent_PlayVaryingWithMesh");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMesh, MaterialVarying) == 0x000000, "Member 'LFXVaryingComponent_PlayVaryingWithMesh::MaterialVarying' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMesh, PlayType) == 0x000008, "Member 'LFXVaryingComponent_PlayVaryingWithMesh::PlayType' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMesh, MeshComp) == 0x000010, "Member 'LFXVaryingComponent_PlayVaryingWithMesh::MeshComp' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMesh, bResetToDefault) == 0x000018, "Member 'LFXVaryingComponent_PlayVaryingWithMesh::bResetToDefault' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMesh, PlayName) == 0x00001C, "Member 'LFXVaryingComponent_PlayVaryingWithMesh::PlayName' has a wrong offset!");

// Function ProjectP.LFXVaryingComponent.PlayVaryingWithMeshes
// 0x0030 (0x0030 - 0x0000)
struct LFXVaryingComponent_PlayVaryingWithMeshes final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshComponent*>                 MeshComps;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bResetToDefault;                                   // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayName;                                          // 0x0024(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXVaryingComponent_PlayVaryingWithMeshes) == 0x000008, "Wrong alignment on LFXVaryingComponent_PlayVaryingWithMeshes");
static_assert(sizeof(LFXVaryingComponent_PlayVaryingWithMeshes) == 0x000030, "Wrong size on LFXVaryingComponent_PlayVaryingWithMeshes");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMeshes, MaterialVarying) == 0x000000, "Member 'LFXVaryingComponent_PlayVaryingWithMeshes::MaterialVarying' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMeshes, PlayType) == 0x000008, "Member 'LFXVaryingComponent_PlayVaryingWithMeshes::PlayType' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMeshes, MeshComps) == 0x000010, "Member 'LFXVaryingComponent_PlayVaryingWithMeshes::MeshComps' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMeshes, bResetToDefault) == 0x000020, "Member 'LFXVaryingComponent_PlayVaryingWithMeshes::bResetToDefault' has a wrong offset!");
static_assert(offsetof(LFXVaryingComponent_PlayVaryingWithMeshes, PlayName) == 0x000024, "Member 'LFXVaryingComponent_PlayVaryingWithMeshes::PlayName' has a wrong offset!");

// Function ProjectP.LFXVaryingComponent.StopVaryingAll
// 0x0001 (0x0001 - 0x0000)
struct LFXVaryingComponent_StopVaryingAll final
{
public:
	bool                                          bResetToDefault;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXVaryingComponent_StopVaryingAll) == 0x000001, "Wrong alignment on LFXVaryingComponent_StopVaryingAll");
static_assert(sizeof(LFXVaryingComponent_StopVaryingAll) == 0x000001, "Wrong size on LFXVaryingComponent_StopVaryingAll");
static_assert(offsetof(LFXVaryingComponent_StopVaryingAll, bResetToDefault) == 0x000000, "Member 'LFXVaryingComponent_StopVaryingAll::bResetToDefault' has a wrong offset!");

// Function ProjectP.LWeaponFXVaryingComponent.ApplyMaterialFx
// 0x0010 (0x0010 - 0x0000)
struct LWeaponFXVaryingComponent_ApplyMaterialFx final
{
public:
	class FName                                   InMaterialFxCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshComp;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponFXVaryingComponent_ApplyMaterialFx) == 0x000008, "Wrong alignment on LWeaponFXVaryingComponent_ApplyMaterialFx");
static_assert(sizeof(LWeaponFXVaryingComponent_ApplyMaterialFx) == 0x000010, "Wrong size on LWeaponFXVaryingComponent_ApplyMaterialFx");
static_assert(offsetof(LWeaponFXVaryingComponent_ApplyMaterialFx, InMaterialFxCodename) == 0x000000, "Member 'LWeaponFXVaryingComponent_ApplyMaterialFx::InMaterialFxCodename' has a wrong offset!");
static_assert(offsetof(LWeaponFXVaryingComponent_ApplyMaterialFx, MeshComp) == 0x000008, "Member 'LWeaponFXVaryingComponent_ApplyMaterialFx::MeshComp' has a wrong offset!");

// Function ProjectP.LWeaponFXVaryingComponent.RemoveMaterialFx
// 0x0010 (0x0010 - 0x0000)
struct LWeaponFXVaryingComponent_RemoveMaterialFx final
{
public:
	class FName                                   InMaterialFxCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshComp;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponFXVaryingComponent_RemoveMaterialFx) == 0x000008, "Wrong alignment on LWeaponFXVaryingComponent_RemoveMaterialFx");
static_assert(sizeof(LWeaponFXVaryingComponent_RemoveMaterialFx) == 0x000010, "Wrong size on LWeaponFXVaryingComponent_RemoveMaterialFx");
static_assert(offsetof(LWeaponFXVaryingComponent_RemoveMaterialFx, InMaterialFxCodename) == 0x000000, "Member 'LWeaponFXVaryingComponent_RemoveMaterialFx::InMaterialFxCodename' has a wrong offset!");
static_assert(offsetof(LWeaponFXVaryingComponent_RemoveMaterialFx, MeshComp) == 0x000008, "Member 'LWeaponFXVaryingComponent_RemoveMaterialFx::MeshComp' has a wrong offset!");

// Function ProjectP.LNPCCharacter.ChangePhase
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_ChangePhase final
{
public:
	class FName                                   ActionGroupTableCodeName;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_ChangePhase) == 0x000004, "Wrong alignment on LNPCCharacter_ChangePhase");
static_assert(sizeof(LNPCCharacter_ChangePhase) == 0x000008, "Wrong size on LNPCCharacter_ChangePhase");
static_assert(offsetof(LNPCCharacter_ChangePhase, ActionGroupTableCodeName) == 0x000000, "Member 'LNPCCharacter_ChangePhase::ActionGroupTableCodeName' has a wrong offset!");

// Function ProjectP.LNPCCharacter.DoExitFunctionTimeDespawn
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_DoExitFunctionTimeDespawn final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_DoExitFunctionTimeDespawn) == 0x000004, "Wrong alignment on LNPCCharacter_DoExitFunctionTimeDespawn");
static_assert(sizeof(LNPCCharacter_DoExitFunctionTimeDespawn) == 0x000004, "Wrong size on LNPCCharacter_DoExitFunctionTimeDespawn");
static_assert(offsetof(LNPCCharacter_DoExitFunctionTimeDespawn, Time) == 0x000000, "Member 'LNPCCharacter_DoExitFunctionTimeDespawn::Time' has a wrong offset!");

// Function ProjectP.LNPCCharacter.DoExitFunctionTimeInvisible
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_DoExitFunctionTimeInvisible final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_DoExitFunctionTimeInvisible) == 0x000004, "Wrong alignment on LNPCCharacter_DoExitFunctionTimeInvisible");
static_assert(sizeof(LNPCCharacter_DoExitFunctionTimeInvisible) == 0x000004, "Wrong size on LNPCCharacter_DoExitFunctionTimeInvisible");
static_assert(offsetof(LNPCCharacter_DoExitFunctionTimeInvisible, Time) == 0x000000, "Member 'LNPCCharacter_DoExitFunctionTimeInvisible::Time' has a wrong offset!");

// Function ProjectP.LNPCCharacter.DoExitFunctionTimeLookHide
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_DoExitFunctionTimeLookHide final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULMaterialVarying*                      HideVarying;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_DoExitFunctionTimeLookHide) == 0x000008, "Wrong alignment on LNPCCharacter_DoExitFunctionTimeLookHide");
static_assert(sizeof(LNPCCharacter_DoExitFunctionTimeLookHide) == 0x000010, "Wrong size on LNPCCharacter_DoExitFunctionTimeLookHide");
static_assert(offsetof(LNPCCharacter_DoExitFunctionTimeLookHide, Time) == 0x000000, "Member 'LNPCCharacter_DoExitFunctionTimeLookHide::Time' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_DoExitFunctionTimeLookHide, HideVarying) == 0x000008, "Member 'LNPCCharacter_DoExitFunctionTimeLookHide::HideVarying' has a wrong offset!");

// Function ProjectP.LNPCCharacter.DoPlay_RedButterfly
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_DoPlay_RedButterfly final
{
public:
	float                                         StartDelay;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_DoPlay_RedButterfly) == 0x000004, "Wrong alignment on LNPCCharacter_DoPlay_RedButterfly");
static_assert(sizeof(LNPCCharacter_DoPlay_RedButterfly) == 0x000004, "Wrong size on LNPCCharacter_DoPlay_RedButterfly");
static_assert(offsetof(LNPCCharacter_DoPlay_RedButterfly, StartDelay) == 0x000000, "Member 'LNPCCharacter_DoPlay_RedButterfly::StartDelay' has a wrong offset!");

// Function ProjectP.LNPCCharacter.FindRootMotionJumpContext
// 0x0080 (0x0080 - 0x0000)
struct LNPCCharacter_FindRootMotionJumpContext final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLRootMotionJumpContext                OutContext;                                        // 0x0010(0x0060)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_FindRootMotionJumpContext) == 0x000010, "Wrong alignment on LNPCCharacter_FindRootMotionJumpContext");
static_assert(sizeof(LNPCCharacter_FindRootMotionJumpContext) == 0x000080, "Wrong size on LNPCCharacter_FindRootMotionJumpContext");
static_assert(offsetof(LNPCCharacter_FindRootMotionJumpContext, SkillCodeName) == 0x000000, "Member 'LNPCCharacter_FindRootMotionJumpContext::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_FindRootMotionJumpContext, OutContext) == 0x000010, "Member 'LNPCCharacter_FindRootMotionJumpContext::OutContext' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_FindRootMotionJumpContext, ReturnValue) == 0x000070, "Member 'LNPCCharacter_FindRootMotionJumpContext::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.HasShareData_Event
// 0x000C (0x000C - 0x0000)
struct LNPCCharacter_HasShareData_Event final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_HasShareData_Event) == 0x000004, "Wrong alignment on LNPCCharacter_HasShareData_Event");
static_assert(sizeof(LNPCCharacter_HasShareData_Event) == 0x00000C, "Wrong size on LNPCCharacter_HasShareData_Event");
static_assert(offsetof(LNPCCharacter_HasShareData_Event, EventName) == 0x000000, "Member 'LNPCCharacter_HasShareData_Event::EventName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_HasShareData_Event, ReturnValue) == 0x000008, "Member 'LNPCCharacter_HasShareData_Event::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.HeadTagVisibility
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_HeadTagVisibility final
{
public:
	bool                                          InVisibility;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_HeadTagVisibility) == 0x000001, "Wrong alignment on LNPCCharacter_HeadTagVisibility");
static_assert(sizeof(LNPCCharacter_HeadTagVisibility) == 0x000001, "Wrong size on LNPCCharacter_HeadTagVisibility");
static_assert(offsetof(LNPCCharacter_HeadTagVisibility, InVisibility) == 0x000000, "Member 'LNPCCharacter_HeadTagVisibility::InVisibility' has a wrong offset!");

// Function ProjectP.LNPCCharacter.IsPlaying_RedButterfly
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_IsPlaying_RedButterfly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_IsPlaying_RedButterfly) == 0x000001, "Wrong alignment on LNPCCharacter_IsPlaying_RedButterfly");
static_assert(sizeof(LNPCCharacter_IsPlaying_RedButterfly) == 0x000001, "Wrong size on LNPCCharacter_IsPlaying_RedButterfly");
static_assert(offsetof(LNPCCharacter_IsPlaying_RedButterfly, ReturnValue) == 0x000000, "Member 'LNPCCharacter_IsPlaying_RedButterfly::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnActiveGroupping_RedButterfly
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_OnActiveGroupping_RedButterfly final
{
public:
	class ALNPCSpot*                              InGrouppingPropVolume;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_OnActiveGroupping_RedButterfly) == 0x000008, "Wrong alignment on LNPCCharacter_OnActiveGroupping_RedButterfly");
static_assert(sizeof(LNPCCharacter_OnActiveGroupping_RedButterfly) == 0x000008, "Wrong size on LNPCCharacter_OnActiveGroupping_RedButterfly");
static_assert(offsetof(LNPCCharacter_OnActiveGroupping_RedButterfly, InGrouppingPropVolume) == 0x000000, "Member 'LNPCCharacter_OnActiveGroupping_RedButterfly::InGrouppingPropVolume' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnChangePhase
// 0x0018 (0x0018 - 0x0000)
struct LNPCCharacter_OnChangePhase final
{
public:
	class FName                                   ActionGroupTableCodeName;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommonActionPath;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocomotoinActionPath;                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_OnChangePhase) == 0x000004, "Wrong alignment on LNPCCharacter_OnChangePhase");
static_assert(sizeof(LNPCCharacter_OnChangePhase) == 0x000018, "Wrong size on LNPCCharacter_OnChangePhase");
static_assert(offsetof(LNPCCharacter_OnChangePhase, ActionGroupTableCodeName) == 0x000000, "Member 'LNPCCharacter_OnChangePhase::ActionGroupTableCodeName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnChangePhase, CommonActionPath) == 0x000008, "Member 'LNPCCharacter_OnChangePhase::CommonActionPath' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnChangePhase, LocomotoinActionPath) == 0x000010, "Member 'LNPCCharacter_OnChangePhase::LocomotoinActionPath' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnGroggyOccurred
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_OnGroggyOccurred final
{
public:
	bool                                          IsStarted;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_OnGroggyOccurred) == 0x000001, "Wrong alignment on LNPCCharacter_OnGroggyOccurred");
static_assert(sizeof(LNPCCharacter_OnGroggyOccurred) == 0x000001, "Wrong size on LNPCCharacter_OnGroggyOccurred");
static_assert(offsetof(LNPCCharacter_OnGroggyOccurred, IsStarted) == 0x000000, "Member 'LNPCCharacter_OnGroggyOccurred::IsStarted' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnSleepStateChanged
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_OnSleepStateChanged final
{
public:
	bool                                          bSleepState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_OnSleepStateChanged) == 0x000001, "Wrong alignment on LNPCCharacter_OnSleepStateChanged");
static_assert(sizeof(LNPCCharacter_OnSleepStateChanged) == 0x000001, "Wrong size on LNPCCharacter_OnSleepStateChanged");
static_assert(offsetof(LNPCCharacter_OnSleepStateChanged, bSleepState) == 0x000000, "Member 'LNPCCharacter_OnSleepStateChanged::bSleepState' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnSwapNPC
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_OnSwapNPC final
{
public:
	class ALNPCCharacter*                         BeforeNPC;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCCharacter*                         AfterNPC;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_OnSwapNPC) == 0x000008, "Wrong alignment on LNPCCharacter_OnSwapNPC");
static_assert(sizeof(LNPCCharacter_OnSwapNPC) == 0x000010, "Wrong size on LNPCCharacter_OnSwapNPC");
static_assert(offsetof(LNPCCharacter_OnSwapNPC, BeforeNPC) == 0x000000, "Member 'LNPCCharacter_OnSwapNPC::BeforeNPC' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnSwapNPC, AfterNPC) == 0x000008, "Member 'LNPCCharacter_OnSwapNPC::AfterNPC' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnWatchActionStateAfterRemove
// 0x0018 (0x0018 - 0x0000)
struct LNPCCharacter_OnWatchActionStateAfterRemove final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_OnWatchActionStateAfterRemove) == 0x000008, "Wrong alignment on LNPCCharacter_OnWatchActionStateAfterRemove");
static_assert(sizeof(LNPCCharacter_OnWatchActionStateAfterRemove) == 0x000018, "Wrong size on LNPCCharacter_OnWatchActionStateAfterRemove");
static_assert(offsetof(LNPCCharacter_OnWatchActionStateAfterRemove, InActMgrComponent) == 0x000000, "Member 'LNPCCharacter_OnWatchActionStateAfterRemove::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnWatchActionStateAfterRemove, ActionState) == 0x000008, "Member 'LNPCCharacter_OnWatchActionStateAfterRemove::ActionState' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnWatchActionStateAfterRemove, IsPair) == 0x000010, "Member 'LNPCCharacter_OnWatchActionStateAfterRemove::IsPair' has a wrong offset!");

// Function ProjectP.LNPCCharacter.OnWatchActionStateBeforeAdd
// 0x0018 (0x0018 - 0x0000)
struct LNPCCharacter_OnWatchActionStateBeforeAdd final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_OnWatchActionStateBeforeAdd) == 0x000008, "Wrong alignment on LNPCCharacter_OnWatchActionStateBeforeAdd");
static_assert(sizeof(LNPCCharacter_OnWatchActionStateBeforeAdd) == 0x000018, "Wrong size on LNPCCharacter_OnWatchActionStateBeforeAdd");
static_assert(offsetof(LNPCCharacter_OnWatchActionStateBeforeAdd, InActMgrComponent) == 0x000000, "Member 'LNPCCharacter_OnWatchActionStateBeforeAdd::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnWatchActionStateBeforeAdd, ActionState) == 0x000008, "Member 'LNPCCharacter_OnWatchActionStateBeforeAdd::ActionState' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_OnWatchActionStateBeforeAdd, IsPair) == 0x000010, "Member 'LNPCCharacter_OnWatchActionStateBeforeAdd::IsPair' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlayAction_CommonMontage
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_PlayAction_CommonMontage final
{
public:
	class FName                                   CommonMontageCodeName;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlayAction_CommonMontage) == 0x000008, "Wrong alignment on LNPCCharacter_PlayAction_CommonMontage");
static_assert(sizeof(LNPCCharacter_PlayAction_CommonMontage) == 0x000010, "Wrong size on LNPCCharacter_PlayAction_CommonMontage");
static_assert(offsetof(LNPCCharacter_PlayAction_CommonMontage, CommonMontageCodeName) == 0x000000, "Member 'LNPCCharacter_PlayAction_CommonMontage::CommonMontageCodeName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_PlayAction_CommonMontage, ReturnValue) == 0x000008, "Member 'LNPCCharacter_PlayAction_CommonMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlayAction_RotationToAngle
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_PlayAction_RotationToAngle final
{
public:
	float                                         YawAngle;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlayAction_RotationToAngle) == 0x000008, "Wrong alignment on LNPCCharacter_PlayAction_RotationToAngle");
static_assert(sizeof(LNPCCharacter_PlayAction_RotationToAngle) == 0x000010, "Wrong size on LNPCCharacter_PlayAction_RotationToAngle");
static_assert(offsetof(LNPCCharacter_PlayAction_RotationToAngle, YawAngle) == 0x000000, "Member 'LNPCCharacter_PlayAction_RotationToAngle::YawAngle' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_PlayAction_RotationToAngle, ReturnValue) == 0x000008, "Member 'LNPCCharacter_PlayAction_RotationToAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlayAction_RotationToHome
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_PlayAction_RotationToHome final
{
public:
	class ULActBase*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlayAction_RotationToHome) == 0x000008, "Wrong alignment on LNPCCharacter_PlayAction_RotationToHome");
static_assert(sizeof(LNPCCharacter_PlayAction_RotationToHome) == 0x000008, "Wrong size on LNPCCharacter_PlayAction_RotationToHome");
static_assert(offsetof(LNPCCharacter_PlayAction_RotationToHome, ReturnValue) == 0x000000, "Member 'LNPCCharacter_PlayAction_RotationToHome::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlayAction_RotationToTarget
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_PlayAction_RotationToTarget final
{
public:
	float                                         CoolTime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySpeed;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlayAction_RotationToTarget) == 0x000008, "Wrong alignment on LNPCCharacter_PlayAction_RotationToTarget");
static_assert(sizeof(LNPCCharacter_PlayAction_RotationToTarget) == 0x000010, "Wrong size on LNPCCharacter_PlayAction_RotationToTarget");
static_assert(offsetof(LNPCCharacter_PlayAction_RotationToTarget, CoolTime) == 0x000000, "Member 'LNPCCharacter_PlayAction_RotationToTarget::CoolTime' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_PlayAction_RotationToTarget, PlaySpeed) == 0x000004, "Member 'LNPCCharacter_PlayAction_RotationToTarget::PlaySpeed' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_PlayAction_RotationToTarget, ReturnValue) == 0x000008, "Member 'LNPCCharacter_PlayAction_RotationToTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlayAction_SpawnIdle
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_PlayAction_SpawnIdle final
{
public:
	class ULActBase*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlayAction_SpawnIdle) == 0x000008, "Wrong alignment on LNPCCharacter_PlayAction_SpawnIdle");
static_assert(sizeof(LNPCCharacter_PlayAction_SpawnIdle) == 0x000008, "Wrong size on LNPCCharacter_PlayAction_SpawnIdle");
static_assert(offsetof(LNPCCharacter_PlayAction_SpawnIdle, ReturnValue) == 0x000000, "Member 'LNPCCharacter_PlayAction_SpawnIdle::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlayAction_TalkerIdle
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_PlayAction_TalkerIdle final
{
public:
	class ULActBase*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlayAction_TalkerIdle) == 0x000008, "Wrong alignment on LNPCCharacter_PlayAction_TalkerIdle");
static_assert(sizeof(LNPCCharacter_PlayAction_TalkerIdle) == 0x000008, "Wrong size on LNPCCharacter_PlayAction_TalkerIdle");
static_assert(offsetof(LNPCCharacter_PlayAction_TalkerIdle, ReturnValue) == 0x000000, "Member 'LNPCCharacter_PlayAction_TalkerIdle::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.PlaySkill
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_PlaySkill final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_PlaySkill) == 0x000008, "Wrong alignment on LNPCCharacter_PlaySkill");
static_assert(sizeof(LNPCCharacter_PlaySkill) == 0x000010, "Wrong size on LNPCCharacter_PlaySkill");
static_assert(offsetof(LNPCCharacter_PlaySkill, SkillCodeName) == 0x000000, "Member 'LNPCCharacter_PlaySkill::SkillCodeName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_PlaySkill, ReturnValue) == 0x000008, "Member 'LNPCCharacter_PlaySkill::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.SetCombatStateBP
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_SetCombatStateBP final
{
public:
	bool                                          bCombatState;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_SetCombatStateBP) == 0x000001, "Wrong alignment on LNPCCharacter_SetCombatStateBP");
static_assert(sizeof(LNPCCharacter_SetCombatStateBP) == 0x000001, "Wrong size on LNPCCharacter_SetCombatStateBP");
static_assert(offsetof(LNPCCharacter_SetCombatStateBP, bCombatState) == 0x000000, "Member 'LNPCCharacter_SetCombatStateBP::bCombatState' has a wrong offset!");

// Function ProjectP.LNPCCharacter.SetGroggyPointAdjustRatio
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_SetGroggyPointAdjustRatio final
{
public:
	TArray<struct FLGroggyPointAdjustRatio>       Override;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_SetGroggyPointAdjustRatio) == 0x000008, "Wrong alignment on LNPCCharacter_SetGroggyPointAdjustRatio");
static_assert(sizeof(LNPCCharacter_SetGroggyPointAdjustRatio) == 0x000010, "Wrong size on LNPCCharacter_SetGroggyPointAdjustRatio");
static_assert(offsetof(LNPCCharacter_SetGroggyPointAdjustRatio, Override) == 0x000000, "Member 'LNPCCharacter_SetGroggyPointAdjustRatio::Override' has a wrong offset!");

// Function ProjectP.LNPCCharacter.SetScarecrow
// 0x0010 (0x0010 - 0x0000)
struct LNPCCharacter_SetScarecrow final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_SetScarecrow) == 0x000008, "Wrong alignment on LNPCCharacter_SetScarecrow");
static_assert(sizeof(LNPCCharacter_SetScarecrow) == 0x000010, "Wrong size on LNPCCharacter_SetScarecrow");
static_assert(offsetof(LNPCCharacter_SetScarecrow, Command) == 0x000000, "Member 'LNPCCharacter_SetScarecrow::Command' has a wrong offset!");

// Function ProjectP.LNPCCharacter.SetShareData_Event
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_SetShareData_Event final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_SetShareData_Event) == 0x000004, "Wrong alignment on LNPCCharacter_SetShareData_Event");
static_assert(sizeof(LNPCCharacter_SetShareData_Event) == 0x000008, "Wrong size on LNPCCharacter_SetShareData_Event");
static_assert(offsetof(LNPCCharacter_SetShareData_Event, EventName) == 0x000000, "Member 'LNPCCharacter_SetShareData_Event::EventName' has a wrong offset!");

// Function ProjectP.LNPCCharacter.SetVisibleHPBar
// 0x0002 (0x0002 - 0x0000)
struct LNPCCharacter_SetVisibleHPBar final
{
public:
	bool                                          IsVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCombatState;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_SetVisibleHPBar) == 0x000001, "Wrong alignment on LNPCCharacter_SetVisibleHPBar");
static_assert(sizeof(LNPCCharacter_SetVisibleHPBar) == 0x000002, "Wrong size on LNPCCharacter_SetVisibleHPBar");
static_assert(offsetof(LNPCCharacter_SetVisibleHPBar, IsVisible) == 0x000000, "Member 'LNPCCharacter_SetVisibleHPBar::IsVisible' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_SetVisibleHPBar, IsCombatState) == 0x000001, "Member 'LNPCCharacter_SetVisibleHPBar::IsCombatState' has a wrong offset!");

// Function ProjectP.LNPCCharacter.SwapNpc
// 0x0018 (0x0018 - 0x0000)
struct LNPCCharacter_SwapNpc final
{
public:
	class FName                                   NPCCodeName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnOffset;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritHP;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpawn;                                       // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetSwapAtRespawn;                               // 0x0016(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnOnSpot;                                      // 0x0017(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_SwapNpc) == 0x000004, "Wrong alignment on LNPCCharacter_SwapNpc");
static_assert(sizeof(LNPCCharacter_SwapNpc) == 0x000018, "Wrong size on LNPCCharacter_SwapNpc");
static_assert(offsetof(LNPCCharacter_SwapNpc, NPCCodeName) == 0x000000, "Member 'LNPCCharacter_SwapNpc::NPCCodeName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_SwapNpc, SpawnOffset) == 0x000008, "Member 'LNPCCharacter_SwapNpc::SpawnOffset' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_SwapNpc, bInheritHP) == 0x000014, "Member 'LNPCCharacter_SwapNpc::bInheritHP' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_SwapNpc, bForceSpawn) == 0x000015, "Member 'LNPCCharacter_SwapNpc::bForceSpawn' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_SwapNpc, bResetSwapAtRespawn) == 0x000016, "Member 'LNPCCharacter_SwapNpc::bResetSwapAtRespawn' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_SwapNpc, bSpawnOnSpot) == 0x000017, "Member 'LNPCCharacter_SwapNpc::bSpawnOnSpot' has a wrong offset!");

// Function ProjectP.LNPCCharacter.TryGroggy
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_TryGroggy final
{
public:
	int32                                         ConsumePoint;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckOnly;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_TryGroggy) == 0x000004, "Wrong alignment on LNPCCharacter_TryGroggy");
static_assert(sizeof(LNPCCharacter_TryGroggy) == 0x000008, "Wrong size on LNPCCharacter_TryGroggy");
static_assert(offsetof(LNPCCharacter_TryGroggy, ConsumePoint) == 0x000000, "Member 'LNPCCharacter_TryGroggy::ConsumePoint' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_TryGroggy, CheckOnly) == 0x000004, "Member 'LNPCCharacter_TryGroggy::CheckOnly' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_TryGroggy, ReturnValue) == 0x000005, "Member 'LNPCCharacter_TryGroggy::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.TryGroggyEnableTimeAdd
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_TryGroggyEnableTimeAdd final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_TryGroggyEnableTimeAdd) == 0x000004, "Wrong alignment on LNPCCharacter_TryGroggyEnableTimeAdd");
static_assert(sizeof(LNPCCharacter_TryGroggyEnableTimeAdd) == 0x000008, "Wrong size on LNPCCharacter_TryGroggyEnableTimeAdd");
static_assert(offsetof(LNPCCharacter_TryGroggyEnableTimeAdd, Time) == 0x000000, "Member 'LNPCCharacter_TryGroggyEnableTimeAdd::Time' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_TryGroggyEnableTimeAdd, ReturnValue) == 0x000004, "Member 'LNPCCharacter_TryGroggyEnableTimeAdd::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.TrySuppressGroggy
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_TrySuppressGroggy final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_TrySuppressGroggy) == 0x000001, "Wrong alignment on LNPCCharacter_TrySuppressGroggy");
static_assert(sizeof(LNPCCharacter_TrySuppressGroggy) == 0x000001, "Wrong size on LNPCCharacter_TrySuppressGroggy");
static_assert(offsetof(LNPCCharacter_TrySuppressGroggy, ReturnValue) == 0x000000, "Member 'LNPCCharacter_TrySuppressGroggy::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.CheckHitRepulse
// 0x000C (0x000C - 0x0000)
struct LNPCCharacter_CheckHitRepulse final
{
public:
	ELPhysicalDamageType                          InPhyscialDamageType;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InAttackRepulseLevel;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_CheckHitRepulse) == 0x000004, "Wrong alignment on LNPCCharacter_CheckHitRepulse");
static_assert(sizeof(LNPCCharacter_CheckHitRepulse) == 0x00000C, "Wrong size on LNPCCharacter_CheckHitRepulse");
static_assert(offsetof(LNPCCharacter_CheckHitRepulse, InPhyscialDamageType) == 0x000000, "Member 'LNPCCharacter_CheckHitRepulse::InPhyscialDamageType' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_CheckHitRepulse, InAttackRepulseLevel) == 0x000004, "Member 'LNPCCharacter_CheckHitRepulse::InAttackRepulseLevel' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_CheckHitRepulse, ReturnValue) == 0x000008, "Member 'LNPCCharacter_CheckHitRepulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.CheckPartsHitRepulse
// 0x0014 (0x0014 - 0x0000)
struct LNPCCharacter_CheckPartsHitRepulse final
{
public:
	ELPhysicalDamageType                          InPhyscialDamageType;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InAttackRepulseLevel;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitPartsName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LNPCCharacter_CheckPartsHitRepulse) == 0x000004, "Wrong alignment on LNPCCharacter_CheckPartsHitRepulse");
static_assert(sizeof(LNPCCharacter_CheckPartsHitRepulse) == 0x000014, "Wrong size on LNPCCharacter_CheckPartsHitRepulse");
static_assert(offsetof(LNPCCharacter_CheckPartsHitRepulse, InPhyscialDamageType) == 0x000000, "Member 'LNPCCharacter_CheckPartsHitRepulse::InPhyscialDamageType' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_CheckPartsHitRepulse, InAttackRepulseLevel) == 0x000004, "Member 'LNPCCharacter_CheckPartsHitRepulse::InAttackRepulseLevel' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_CheckPartsHitRepulse, HitPartsName) == 0x000008, "Member 'LNPCCharacter_CheckPartsHitRepulse::HitPartsName' has a wrong offset!");
static_assert(offsetof(LNPCCharacter_CheckPartsHitRepulse, ReturnValue) == 0x000010, "Member 'LNPCCharacter_CheckPartsHitRepulse::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.GetMoveSpeed
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_GetMoveSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_GetMoveSpeed) == 0x000004, "Wrong alignment on LNPCCharacter_GetMoveSpeed");
static_assert(sizeof(LNPCCharacter_GetMoveSpeed) == 0x000004, "Wrong size on LNPCCharacter_GetMoveSpeed");
static_assert(offsetof(LNPCCharacter_GetMoveSpeed, ReturnValue) == 0x000000, "Member 'LNPCCharacter_GetMoveSpeed::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.GetNPCInfoActionGroupCodeName
// 0x0008 (0x0008 - 0x0000)
struct LNPCCharacter_GetNPCInfoActionGroupCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_GetNPCInfoActionGroupCodeName) == 0x000004, "Wrong alignment on LNPCCharacter_GetNPCInfoActionGroupCodeName");
static_assert(sizeof(LNPCCharacter_GetNPCInfoActionGroupCodeName) == 0x000008, "Wrong size on LNPCCharacter_GetNPCInfoActionGroupCodeName");
static_assert(offsetof(LNPCCharacter_GetNPCInfoActionGroupCodeName, ReturnValue) == 0x000000, "Member 'LNPCCharacter_GetNPCInfoActionGroupCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.GetScaledFloatingStateCeilingCapsuleHalfHeight
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight) == 0x000004, "Wrong alignment on LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight");
static_assert(sizeof(LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight) == 0x000004, "Wrong size on LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight");
static_assert(offsetof(LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight, ReturnValue) == 0x000000, "Member 'LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.GetSightDistance
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_GetSightDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_GetSightDistance) == 0x000004, "Wrong alignment on LNPCCharacter_GetSightDistance");
static_assert(sizeof(LNPCCharacter_GetSightDistance) == 0x000004, "Wrong size on LNPCCharacter_GetSightDistance");
static_assert(offsetof(LNPCCharacter_GetSightDistance, ReturnValue) == 0x000000, "Member 'LNPCCharacter_GetSightDistance::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.GetTargetDetectRange
// 0x0004 (0x0004 - 0x0000)
struct LNPCCharacter_GetTargetDetectRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_GetTargetDetectRange) == 0x000004, "Wrong alignment on LNPCCharacter_GetTargetDetectRange");
static_assert(sizeof(LNPCCharacter_GetTargetDetectRange) == 0x000004, "Wrong size on LNPCCharacter_GetTargetDetectRange");
static_assert(offsetof(LNPCCharacter_GetTargetDetectRange, ReturnValue) == 0x000000, "Member 'LNPCCharacter_GetTargetDetectRange::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCCharacter.IsCombatState
// 0x0001 (0x0001 - 0x0000)
struct LNPCCharacter_IsCombatState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCCharacter_IsCombatState) == 0x000001, "Wrong alignment on LNPCCharacter_IsCombatState");
static_assert(sizeof(LNPCCharacter_IsCombatState) == 0x000001, "Wrong size on LNPCCharacter_IsCombatState");
static_assert(offsetof(LNPCCharacter_IsCombatState, ReturnValue) == 0x000000, "Member 'LNPCCharacter_IsCombatState::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXComponent.DelayDeactiveSystem
// 0x0010 (0x0010 - 0x0000)
struct LFXComponent_DelayDeactiveSystem final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXComponent_DelayDeactiveSystem) == 0x000008, "Wrong alignment on LFXComponent_DelayDeactiveSystem");
static_assert(sizeof(LFXComponent_DelayDeactiveSystem) == 0x000010, "Wrong size on LFXComponent_DelayDeactiveSystem");
static_assert(offsetof(LFXComponent_DelayDeactiveSystem, NiagaraComponent) == 0x000000, "Member 'LFXComponent_DelayDeactiveSystem::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(LFXComponent_DelayDeactiveSystem, DelayTime) == 0x000008, "Member 'LFXComponent_DelayDeactiveSystem::DelayTime' has a wrong offset!");

// Function ProjectP.LFXComponent.FXCommand_DeactiveTime
// 0x0018 (0x0018 - 0x0000)
struct LFXComponent_FXCommand_DeactiveTime final
{
public:
	TArray<class UFXSystemComponent*>             FXs;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DeactiveTime;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXComponent_FXCommand_DeactiveTime) == 0x000008, "Wrong alignment on LFXComponent_FXCommand_DeactiveTime");
static_assert(sizeof(LFXComponent_FXCommand_DeactiveTime) == 0x000018, "Wrong size on LFXComponent_FXCommand_DeactiveTime");
static_assert(offsetof(LFXComponent_FXCommand_DeactiveTime, FXs) == 0x000000, "Member 'LFXComponent_FXCommand_DeactiveTime::FXs' has a wrong offset!");
static_assert(offsetof(LFXComponent_FXCommand_DeactiveTime, DeactiveTime) == 0x000010, "Member 'LFXComponent_FXCommand_DeactiveTime::DeactiveTime' has a wrong offset!");

// Function ProjectP.LFXComponent.FXCommand_DoEvent
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_FXCommand_DoEvent final
{
public:
	ELFXCommandEventType                          Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_FXCommand_DoEvent) == 0x000001, "Wrong alignment on LFXComponent_FXCommand_DoEvent");
static_assert(sizeof(LFXComponent_FXCommand_DoEvent) == 0x000001, "Wrong size on LFXComponent_FXCommand_DoEvent");
static_assert(offsetof(LFXComponent_FXCommand_DoEvent, Type) == 0x000000, "Member 'LFXComponent_FXCommand_DoEvent::Type' has a wrong offset!");

// Function ProjectP.LFXComponent.FXCommands_DeactiveEvent
// 0x0018 (0x0018 - 0x0000)
struct LFXComponent_FXCommands_DeactiveEvent final
{
public:
	TArray<class UFXSystemComponent*>             FXs;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELFXCommandEventType                          Type;                                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXComponent_FXCommands_DeactiveEvent) == 0x000008, "Wrong alignment on LFXComponent_FXCommands_DeactiveEvent");
static_assert(sizeof(LFXComponent_FXCommands_DeactiveEvent) == 0x000018, "Wrong size on LFXComponent_FXCommands_DeactiveEvent");
static_assert(offsetof(LFXComponent_FXCommands_DeactiveEvent, FXs) == 0x000000, "Member 'LFXComponent_FXCommands_DeactiveEvent::FXs' has a wrong offset!");
static_assert(offsetof(LFXComponent_FXCommands_DeactiveEvent, Type) == 0x000010, "Member 'LFXComponent_FXCommands_DeactiveEvent::Type' has a wrong offset!");

// Function ProjectP.LFXComponent.HideManagedNiagaraComponents
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_HideManagedNiagaraComponents final
{
public:
	bool                                          bHide;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_HideManagedNiagaraComponents) == 0x000001, "Wrong alignment on LFXComponent_HideManagedNiagaraComponents");
static_assert(sizeof(LFXComponent_HideManagedNiagaraComponents) == 0x000001, "Wrong size on LFXComponent_HideManagedNiagaraComponents");
static_assert(offsetof(LFXComponent_HideManagedNiagaraComponents, bHide) == 0x000000, "Member 'LFXComponent_HideManagedNiagaraComponents::bHide' has a wrong offset!");

// Function ProjectP.LFXComponent.IsPlayingVaryingName
// 0x000C (0x000C - 0x0000)
struct LFXComponent_IsPlayingVaryingName final
{
public:
	class FName                                   PlayName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXComponent_IsPlayingVaryingName) == 0x000004, "Wrong alignment on LFXComponent_IsPlayingVaryingName");
static_assert(sizeof(LFXComponent_IsPlayingVaryingName) == 0x00000C, "Wrong size on LFXComponent_IsPlayingVaryingName");
static_assert(offsetof(LFXComponent_IsPlayingVaryingName, PlayName) == 0x000000, "Member 'LFXComponent_IsPlayingVaryingName::PlayName' has a wrong offset!");
static_assert(offsetof(LFXComponent_IsPlayingVaryingName, ReturnValue) == 0x000008, "Member 'LFXComponent_IsPlayingVaryingName::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayBodyDurabilityConsumeFX
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_PlayBodyDurabilityConsumeFX final
{
public:
	ELPartsAttachPointType                        AttachPointType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayBodyDurabilityConsumeFX) == 0x000001, "Wrong alignment on LFXComponent_PlayBodyDurabilityConsumeFX");
static_assert(sizeof(LFXComponent_PlayBodyDurabilityConsumeFX) == 0x000001, "Wrong size on LFXComponent_PlayBodyDurabilityConsumeFX");
static_assert(offsetof(LFXComponent_PlayBodyDurabilityConsumeFX, AttachPointType) == 0x000000, "Member 'LFXComponent_PlayBodyDurabilityConsumeFX::AttachPointType' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayDeadHide
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_PlayDeadHide final
{
public:
	bool                                          bDissolveEffect;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayDeadHide) == 0x000001, "Wrong alignment on LFXComponent_PlayDeadHide");
static_assert(sizeof(LFXComponent_PlayDeadHide) == 0x000001, "Wrong size on LFXComponent_PlayDeadHide");
static_assert(offsetof(LFXComponent_PlayDeadHide, bDissolveEffect) == 0x000000, "Member 'LFXComponent_PlayDeadHide::bDissolveEffect' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayElementPartsHitFX
// 0x0018 (0x0018 - 0x0000)
struct LFXComponent_PlayElementPartsHitFX final
{
public:
	class UNiagaraSystem*                         System;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXComponent_PlayElementPartsHitFX) == 0x000008, "Wrong alignment on LFXComponent_PlayElementPartsHitFX");
static_assert(sizeof(LFXComponent_PlayElementPartsHitFX) == 0x000018, "Wrong size on LFXComponent_PlayElementPartsHitFX");
static_assert(offsetof(LFXComponent_PlayElementPartsHitFX, System) == 0x000000, "Member 'LFXComponent_PlayElementPartsHitFX::System' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayElementPartsHitFX, HitLocation) == 0x000008, "Member 'LFXComponent_PlayElementPartsHitFX::HitLocation' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayHide
// 0x0018 (0x0018 - 0x0000)
struct LFXComponent_PlayHide final
{
public:
	bool                                          bDissolveEffect;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULMaterialVarying*                      HideVarying;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VaryingName;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayHide) == 0x000008, "Wrong alignment on LFXComponent_PlayHide");
static_assert(sizeof(LFXComponent_PlayHide) == 0x000018, "Wrong size on LFXComponent_PlayHide");
static_assert(offsetof(LFXComponent_PlayHide, bDissolveEffect) == 0x000000, "Member 'LFXComponent_PlayHide::bDissolveEffect' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayHide, HideVarying) == 0x000008, "Member 'LFXComponent_PlayHide::HideVarying' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayHide, VaryingName) == 0x000010, "Member 'LFXComponent_PlayHide::VaryingName' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayHitRegionFX
// 0x0080 (0x0080 - 0x0000)
struct LFXComponent_PlayHitRegionFX final
{
public:
	struct FLHitFXPlayData                        HitFXPlayData;                                     // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayHitRegionFX) == 0x000010, "Wrong alignment on LFXComponent_PlayHitRegionFX");
static_assert(sizeof(LFXComponent_PlayHitRegionFX) == 0x000080, "Wrong size on LFXComponent_PlayHitRegionFX");
static_assert(offsetof(LFXComponent_PlayHitRegionFX, HitFXPlayData) == 0x000000, "Member 'LFXComponent_PlayHitRegionFX::HitFXPlayData' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayMaterialParamScalar
// 0x0028 (0x0028 - 0x0000)
struct LFXComponent_PlayMaterialParamScalar final
{
public:
	class FName                                   PlayerName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FLMaterialParamScalar>          Scalar;                                            // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayMaterialParamScalar) == 0x000008, "Wrong alignment on LFXComponent_PlayMaterialParamScalar");
static_assert(sizeof(LFXComponent_PlayMaterialParamScalar) == 0x000028, "Wrong size on LFXComponent_PlayMaterialParamScalar");
static_assert(offsetof(LFXComponent_PlayMaterialParamScalar, PlayerName) == 0x000000, "Member 'LFXComponent_PlayMaterialParamScalar::PlayerName' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialParamScalar, Materials) == 0x000008, "Member 'LFXComponent_PlayMaterialParamScalar::Materials' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialParamScalar, Scalar) == 0x000018, "Member 'LFXComponent_PlayMaterialParamScalar::Scalar' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayMaterialParamScalarSingle
// 0x0040 (0x0040 - 0x0000)
struct LFXComponent_PlayMaterialParamScalarSingle final
{
public:
	class FName                                   PlayerName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLMaterialParamScalar                  Scalar;                                            // 0x0018(0x0028)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayMaterialParamScalarSingle) == 0x000008, "Wrong alignment on LFXComponent_PlayMaterialParamScalarSingle");
static_assert(sizeof(LFXComponent_PlayMaterialParamScalarSingle) == 0x000040, "Wrong size on LFXComponent_PlayMaterialParamScalarSingle");
static_assert(offsetof(LFXComponent_PlayMaterialParamScalarSingle, PlayerName) == 0x000000, "Member 'LFXComponent_PlayMaterialParamScalarSingle::PlayerName' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialParamScalarSingle, Materials) == 0x000008, "Member 'LFXComponent_PlayMaterialParamScalarSingle::Materials' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialParamScalarSingle, Scalar) == 0x000018, "Member 'LFXComponent_PlayMaterialParamScalarSingle::Scalar' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayMaterialVaryingValues
// 0x0040 (0x0040 - 0x0000)
struct LFXComponent_PlayMaterialVaryingValues final
{
public:
	TArray<struct FLMaterialVaryingScalar>        ScalarValues;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLMaterialVaryingColor>         ColorValues;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshComponent*>                 MeshComponents;                                    // 0x0028(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   PlayName;                                          // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayMaterialVaryingValues) == 0x000008, "Wrong alignment on LFXComponent_PlayMaterialVaryingValues");
static_assert(sizeof(LFXComponent_PlayMaterialVaryingValues) == 0x000040, "Wrong size on LFXComponent_PlayMaterialVaryingValues");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingValues, ScalarValues) == 0x000000, "Member 'LFXComponent_PlayMaterialVaryingValues::ScalarValues' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingValues, ColorValues) == 0x000010, "Member 'LFXComponent_PlayMaterialVaryingValues::ColorValues' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingValues, PlayType) == 0x000020, "Member 'LFXComponent_PlayMaterialVaryingValues::PlayType' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingValues, MeshComponents) == 0x000028, "Member 'LFXComponent_PlayMaterialVaryingValues::MeshComponents' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingValues, PlayName) == 0x000038, "Member 'LFXComponent_PlayMaterialVaryingValues::PlayName' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayMaterialVaryingWithMesh
// 0x0020 (0x0020 - 0x0000)
struct LFXComponent_PlayMaterialVaryingWithMesh final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MeshComp;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayName;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayMaterialVaryingWithMesh) == 0x000008, "Wrong alignment on LFXComponent_PlayMaterialVaryingWithMesh");
static_assert(sizeof(LFXComponent_PlayMaterialVaryingWithMesh) == 0x000020, "Wrong size on LFXComponent_PlayMaterialVaryingWithMesh");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMesh, MaterialVarying) == 0x000000, "Member 'LFXComponent_PlayMaterialVaryingWithMesh::MaterialVarying' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMesh, PlayType) == 0x000008, "Member 'LFXComponent_PlayMaterialVaryingWithMesh::PlayType' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMesh, MeshComp) == 0x000010, "Member 'LFXComponent_PlayMaterialVaryingWithMesh::MeshComp' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMesh, PlayName) == 0x000018, "Member 'LFXComponent_PlayMaterialVaryingWithMesh::PlayName' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayMaterialVaryingWithMeshes
// 0x0028 (0x0028 - 0x0000)
struct LFXComponent_PlayMaterialVaryingWithMeshes final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMeshComponent*>                 MeshComps;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   PlayName;                                          // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayMaterialVaryingWithMeshes) == 0x000008, "Wrong alignment on LFXComponent_PlayMaterialVaryingWithMeshes");
static_assert(sizeof(LFXComponent_PlayMaterialVaryingWithMeshes) == 0x000028, "Wrong size on LFXComponent_PlayMaterialVaryingWithMeshes");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMeshes, MaterialVarying) == 0x000000, "Member 'LFXComponent_PlayMaterialVaryingWithMeshes::MaterialVarying' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMeshes, PlayType) == 0x000008, "Member 'LFXComponent_PlayMaterialVaryingWithMeshes::PlayType' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMeshes, MeshComps) == 0x000010, "Member 'LFXComponent_PlayMaterialVaryingWithMeshes::MeshComps' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayMaterialVaryingWithMeshes, PlayName) == 0x000020, "Member 'LFXComponent_PlayMaterialVaryingWithMeshes::PlayName' has a wrong offset!");

// Function ProjectP.LFXComponent.PlayTrail
// 0x0020 (0x0020 - 0x0000)
struct LFXComponent_PlayTrail final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PSTemplate;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstSocketName;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_PlayTrail) == 0x000008, "Wrong alignment on LFXComponent_PlayTrail");
static_assert(sizeof(LFXComponent_PlayTrail) == 0x000020, "Wrong size on LFXComponent_PlayTrail");
static_assert(offsetof(LFXComponent_PlayTrail, Instigator) == 0x000000, "Member 'LFXComponent_PlayTrail::Instigator' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayTrail, PSTemplate) == 0x000008, "Member 'LFXComponent_PlayTrail::PSTemplate' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayTrail, FirstSocketName) == 0x000010, "Member 'LFXComponent_PlayTrail::FirstSocketName' has a wrong offset!");
static_assert(offsetof(LFXComponent_PlayTrail, SecondSocketName) == 0x000018, "Member 'LFXComponent_PlayTrail::SecondSocketName' has a wrong offset!");

// Function ProjectP.LFXComponent.SetUseResetToDefaultMaterial
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_SetUseResetToDefaultMaterial final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_SetUseResetToDefaultMaterial) == 0x000001, "Wrong alignment on LFXComponent_SetUseResetToDefaultMaterial");
static_assert(sizeof(LFXComponent_SetUseResetToDefaultMaterial) == 0x000001, "Wrong size on LFXComponent_SetUseResetToDefaultMaterial");
static_assert(offsetof(LFXComponent_SetUseResetToDefaultMaterial, bEnable) == 0x000000, "Member 'LFXComponent_SetUseResetToDefaultMaterial::bEnable' has a wrong offset!");

// Function ProjectP.LFXComponent.StartSplashBloodFX
// 0x0018 (0x0018 - 0x0000)
struct LFXComponent_StartSplashBloodFX final
{
public:
	class ALCharacter*                            Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               AttackerWeapon;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBloodEffectType                             BloodType;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackerStiffenDurationTime;                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_StartSplashBloodFX) == 0x000008, "Wrong alignment on LFXComponent_StartSplashBloodFX");
static_assert(sizeof(LFXComponent_StartSplashBloodFX) == 0x000018, "Wrong size on LFXComponent_StartSplashBloodFX");
static_assert(offsetof(LFXComponent_StartSplashBloodFX, Attacker) == 0x000000, "Member 'LFXComponent_StartSplashBloodFX::Attacker' has a wrong offset!");
static_assert(offsetof(LFXComponent_StartSplashBloodFX, AttackerWeapon) == 0x000008, "Member 'LFXComponent_StartSplashBloodFX::AttackerWeapon' has a wrong offset!");
static_assert(offsetof(LFXComponent_StartSplashBloodFX, BloodType) == 0x000010, "Member 'LFXComponent_StartSplashBloodFX::BloodType' has a wrong offset!");
static_assert(offsetof(LFXComponent_StartSplashBloodFX, AttackerStiffenDurationTime) == 0x000014, "Member 'LFXComponent_StartSplashBloodFX::AttackerStiffenDurationTime' has a wrong offset!");

// Function ProjectP.LFXComponent.StopHide
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_StopHide final
{
public:
	bool                                          bDissolveEffect;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_StopHide) == 0x000001, "Wrong alignment on LFXComponent_StopHide");
static_assert(sizeof(LFXComponent_StopHide) == 0x000001, "Wrong size on LFXComponent_StopHide");
static_assert(offsetof(LFXComponent_StopHide, bDissolveEffect) == 0x000000, "Member 'LFXComponent_StopHide::bDissolveEffect' has a wrong offset!");

// Function ProjectP.LFXComponent.StopMaterialParam
// 0x0008 (0x0008 - 0x0000)
struct LFXComponent_StopMaterialParam final
{
public:
	class FName                                   PlayerName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_StopMaterialParam) == 0x000004, "Wrong alignment on LFXComponent_StopMaterialParam");
static_assert(sizeof(LFXComponent_StopMaterialParam) == 0x000008, "Wrong size on LFXComponent_StopMaterialParam");
static_assert(offsetof(LFXComponent_StopMaterialParam, PlayerName) == 0x000000, "Member 'LFXComponent_StopMaterialParam::PlayerName' has a wrong offset!");

// Function ProjectP.LFXComponent.StopMaterialVarying
// 0x0008 (0x0008 - 0x0000)
struct LFXComponent_StopMaterialVarying final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_StopMaterialVarying) == 0x000008, "Wrong alignment on LFXComponent_StopMaterialVarying");
static_assert(sizeof(LFXComponent_StopMaterialVarying) == 0x000008, "Wrong size on LFXComponent_StopMaterialVarying");
static_assert(offsetof(LFXComponent_StopMaterialVarying, MaterialVarying) == 0x000000, "Member 'LFXComponent_StopMaterialVarying::MaterialVarying' has a wrong offset!");

// Function ProjectP.LFXComponent.StopMaterialVaryingAll
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_StopMaterialVaryingAll final
{
public:
	bool                                          ResetToDefault;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_StopMaterialVaryingAll) == 0x000001, "Wrong alignment on LFXComponent_StopMaterialVaryingAll");
static_assert(sizeof(LFXComponent_StopMaterialVaryingAll) == 0x000001, "Wrong size on LFXComponent_StopMaterialVaryingAll");
static_assert(offsetof(LFXComponent_StopMaterialVaryingAll, ResetToDefault) == 0x000000, "Member 'LFXComponent_StopMaterialVaryingAll::ResetToDefault' has a wrong offset!");

// Function ProjectP.LFXComponent.StopTrail
// 0x0010 (0x0010 - 0x0000)
struct LFXComponent_StopTrail final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReserveStopTime;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXComponent_StopTrail) == 0x000008, "Wrong alignment on LFXComponent_StopTrail");
static_assert(sizeof(LFXComponent_StopTrail) == 0x000010, "Wrong size on LFXComponent_StopTrail");
static_assert(offsetof(LFXComponent_StopTrail, Instigator) == 0x000000, "Member 'LFXComponent_StopTrail::Instigator' has a wrong offset!");
static_assert(offsetof(LFXComponent_StopTrail, ReserveStopTime) == 0x000008, "Member 'LFXComponent_StopTrail::ReserveStopTime' has a wrong offset!");

// Function ProjectP.LFXComponent.IsHide
// 0x0001 (0x0001 - 0x0000)
struct LFXComponent_IsHide final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXComponent_IsHide) == 0x000001, "Wrong alignment on LFXComponent_IsHide");
static_assert(sizeof(LFXComponent_IsHide) == 0x000001, "Wrong size on LFXComponent_IsHide");
static_assert(offsetof(LFXComponent_IsHide, ReturnValue) == 0x000000, "Member 'LFXComponent_IsHide::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystemData.ActiveFuryAttack
// 0x0030 (0x0030 - 0x0000)
struct LFXSystemData_ActiveFuryAttack final
{
public:
	class ALNPCCharacter*                         InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InVolumeModifier;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAttachedEffectSet                    ReturnValue;                                       // 0x0010(0x001C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystemData_ActiveFuryAttack) == 0x000008, "Wrong alignment on LFXSystemData_ActiveFuryAttack");
static_assert(sizeof(LFXSystemData_ActiveFuryAttack) == 0x000030, "Wrong size on LFXSystemData_ActiveFuryAttack");
static_assert(offsetof(LFXSystemData_ActiveFuryAttack, InTarget) == 0x000000, "Member 'LFXSystemData_ActiveFuryAttack::InTarget' has a wrong offset!");
static_assert(offsetof(LFXSystemData_ActiveFuryAttack, bActive) == 0x000008, "Member 'LFXSystemData_ActiveFuryAttack::bActive' has a wrong offset!");
static_assert(offsetof(LFXSystemData_ActiveFuryAttack, InVolumeModifier) == 0x00000C, "Member 'LFXSystemData_ActiveFuryAttack::InVolumeModifier' has a wrong offset!");
static_assert(offsetof(LFXSystemData_ActiveFuryAttack, ReturnValue) == 0x000010, "Member 'LFXSystemData_ActiveFuryAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystemData.GetWeaponMaterialVarying
// 0x0030 (0x0030 - 0x0000)
struct LFXSystemData_GetWeaponMaterialVarying final
{
public:
	class FName                                   MaterialFxCodename;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULMaterialVarying>       ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_GetWeaponMaterialVarying) == 0x000008, "Wrong alignment on LFXSystemData_GetWeaponMaterialVarying");
static_assert(sizeof(LFXSystemData_GetWeaponMaterialVarying) == 0x000030, "Wrong size on LFXSystemData_GetWeaponMaterialVarying");
static_assert(offsetof(LFXSystemData_GetWeaponMaterialVarying, MaterialFxCodename) == 0x000000, "Member 'LFXSystemData_GetWeaponMaterialVarying::MaterialFxCodename' has a wrong offset!");
static_assert(offsetof(LFXSystemData_GetWeaponMaterialVarying, ReturnValue) == 0x000008, "Member 'LFXSystemData_GetWeaponMaterialVarying::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystemData.GetWeaponTrailElementFX
// 0x0010 (0x0010 - 0x0000)
struct LFXSystemData_GetWeaponTrailElementFX final
{
public:
	class FName                                   ElementFXCodename;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_GetWeaponTrailElementFX) == 0x000008, "Wrong alignment on LFXSystemData_GetWeaponTrailElementFX");
static_assert(sizeof(LFXSystemData_GetWeaponTrailElementFX) == 0x000010, "Wrong size on LFXSystemData_GetWeaponTrailElementFX");
static_assert(offsetof(LFXSystemData_GetWeaponTrailElementFX, ElementFXCodename) == 0x000000, "Member 'LFXSystemData_GetWeaponTrailElementFX::ElementFXCodename' has a wrong offset!");
static_assert(offsetof(LFXSystemData_GetWeaponTrailElementFX, ReturnValue) == 0x000008, "Member 'LFXSystemData_GetWeaponTrailElementFX::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystemData.OnBuffEffect
// 0x0038 (0x0038 - 0x0000)
struct LFXSystemData_OnBuffEffect final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedSocketName;                                // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAttachedEffectSet                    ReturnValue;                                       // 0x001C(0x001C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_OnBuffEffect) == 0x000008, "Wrong alignment on LFXSystemData_OnBuffEffect");
static_assert(sizeof(LFXSystemData_OnBuffEffect) == 0x000038, "Wrong size on LFXSystemData_OnBuffEffect");
static_assert(offsetof(LFXSystemData_OnBuffEffect, Actor) == 0x000000, "Member 'LFXSystemData_OnBuffEffect::Actor' has a wrong offset!");
static_assert(offsetof(LFXSystemData_OnBuffEffect, EventName) == 0x000008, "Member 'LFXSystemData_OnBuffEffect::EventName' has a wrong offset!");
static_assert(offsetof(LFXSystemData_OnBuffEffect, PhysicalSurface) == 0x000010, "Member 'LFXSystemData_OnBuffEffect::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LFXSystemData_OnBuffEffect, AttachedSocketName) == 0x000014, "Member 'LFXSystemData_OnBuffEffect::AttachedSocketName' has a wrong offset!");
static_assert(offsetof(LFXSystemData_OnBuffEffect, ReturnValue) == 0x00001C, "Member 'LFXSystemData_OnBuffEffect::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystemData.OnDisappear
// 0x0008 (0x0008 - 0x0000)
struct LFXSystemData_OnDisappear final
{
public:
	class ALCharacter*                            Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_OnDisappear) == 0x000008, "Wrong alignment on LFXSystemData_OnDisappear");
static_assert(sizeof(LFXSystemData_OnDisappear) == 0x000008, "Wrong size on LFXSystemData_OnDisappear");
static_assert(offsetof(LFXSystemData_OnDisappear, Character) == 0x000000, "Member 'LFXSystemData_OnDisappear::Character' has a wrong offset!");

// Function ProjectP.LFXSystemData.OnFrenzyModeMV
// 0x0010 (0x0010 - 0x0000)
struct LFXSystemData_OnFrenzyModeMV final
{
public:
	class ALCharacter*                            InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrenzyMode;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystemData_OnFrenzyModeMV) == 0x000008, "Wrong alignment on LFXSystemData_OnFrenzyModeMV");
static_assert(sizeof(LFXSystemData_OnFrenzyModeMV) == 0x000010, "Wrong size on LFXSystemData_OnFrenzyModeMV");
static_assert(offsetof(LFXSystemData_OnFrenzyModeMV, InTarget) == 0x000000, "Member 'LFXSystemData_OnFrenzyModeMV::InTarget' has a wrong offset!");
static_assert(offsetof(LFXSystemData_OnFrenzyModeMV, bFrenzyMode) == 0x000008, "Member 'LFXSystemData_OnFrenzyModeMV::bFrenzyMode' has a wrong offset!");

// Function ProjectP.LFXSystemData.OnParalyzationOcurred
// 0x0008 (0x0008 - 0x0000)
struct LFXSystemData_OnParalyzationOcurred final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_OnParalyzationOcurred) == 0x000008, "Wrong alignment on LFXSystemData_OnParalyzationOcurred");
static_assert(sizeof(LFXSystemData_OnParalyzationOcurred) == 0x000008, "Wrong size on LFXSystemData_OnParalyzationOcurred");
static_assert(offsetof(LFXSystemData_OnParalyzationOcurred, Victim) == 0x000000, "Member 'LFXSystemData_OnParalyzationOcurred::Victim' has a wrong offset!");

// Function ProjectP.LFXSystemData.OnWeaponBladeDestroyEffect
// 0x000C (0x000C - 0x0000)
struct LFXSystemData_OnWeaponBladeDestroyEffect final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_OnWeaponBladeDestroyEffect) == 0x000004, "Wrong alignment on LFXSystemData_OnWeaponBladeDestroyEffect");
static_assert(sizeof(LFXSystemData_OnWeaponBladeDestroyEffect) == 0x00000C, "Wrong size on LFXSystemData_OnWeaponBladeDestroyEffect");
static_assert(offsetof(LFXSystemData_OnWeaponBladeDestroyEffect, Location) == 0x000000, "Member 'LFXSystemData_OnWeaponBladeDestroyEffect::Location' has a wrong offset!");

// Function ProjectP.LFXSystemData.PlayHitEffect
// 0x0080 (0x0080 - 0x0000)
struct LFXSystemData_PlayHitEffect final
{
public:
	struct FLHitFXPlayData                        HitFXPlayData;                                     // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_PlayHitEffect) == 0x000010, "Wrong alignment on LFXSystemData_PlayHitEffect");
static_assert(sizeof(LFXSystemData_PlayHitEffect) == 0x000080, "Wrong size on LFXSystemData_PlayHitEffect");
static_assert(offsetof(LFXSystemData_PlayHitEffect, HitFXPlayData) == 0x000000, "Member 'LFXSystemData_PlayHitEffect::HitFXPlayData' has a wrong offset!");

// Function ProjectP.LFXSystemData.PlaySocketTracerHitEffect_FX
// 0x0050 (0x0050 - 0x0000)
struct LFXSystemData_PlaySocketTracerHitEffect_FX final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerPhysicalSurface;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundPhysicalSurface;                             // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystemData_PlaySocketTracerHitEffect_FX) == 0x000010, "Wrong alignment on LFXSystemData_PlaySocketTracerHitEffect_FX");
static_assert(sizeof(LFXSystemData_PlaySocketTracerHitEffect_FX) == 0x000050, "Wrong size on LFXSystemData_PlaySocketTracerHitEffect_FX");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_FX, EventName) == 0x000000, "Member 'LFXSystemData_PlaySocketTracerHitEffect_FX::EventName' has a wrong offset!");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_FX, HitTransform) == 0x000010, "Member 'LFXSystemData_PlaySocketTracerHitEffect_FX::HitTransform' has a wrong offset!");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_FX, AttackerPhysicalSurface) == 0x000040, "Member 'LFXSystemData_PlaySocketTracerHitEffect_FX::AttackerPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_FX, GroundPhysicalSurface) == 0x000041, "Member 'LFXSystemData_PlaySocketTracerHitEffect_FX::GroundPhysicalSurface' has a wrong offset!");

// Function ProjectP.LFXSystemData.PlaySocketTracerHitEffect_SFX
// 0x0050 (0x0050 - 0x0000)
struct LFXSystemData_PlaySocketTracerHitEffect_SFX final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerPhysicalSurface;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundPhysicalSurface;                             // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystemData_PlaySocketTracerHitEffect_SFX) == 0x000010, "Wrong alignment on LFXSystemData_PlaySocketTracerHitEffect_SFX");
static_assert(sizeof(LFXSystemData_PlaySocketTracerHitEffect_SFX) == 0x000050, "Wrong size on LFXSystemData_PlaySocketTracerHitEffect_SFX");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_SFX, EventName) == 0x000000, "Member 'LFXSystemData_PlaySocketTracerHitEffect_SFX::EventName' has a wrong offset!");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_SFX, HitTransform) == 0x000010, "Member 'LFXSystemData_PlaySocketTracerHitEffect_SFX::HitTransform' has a wrong offset!");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_SFX, AttackerPhysicalSurface) == 0x000040, "Member 'LFXSystemData_PlaySocketTracerHitEffect_SFX::AttackerPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LFXSystemData_PlaySocketTracerHitEffect_SFX, GroundPhysicalSurface) == 0x000041, "Member 'LFXSystemData_PlaySocketTracerHitEffect_SFX::GroundPhysicalSurface' has a wrong offset!");

// Function ProjectP.LFXSystemData.SetBloodOnOff
// 0x0001 (0x0001 - 0x0000)
struct LFXSystemData_SetBloodOnOff final
{
public:
	bool                                          bOnOff;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_SetBloodOnOff) == 0x000001, "Wrong alignment on LFXSystemData_SetBloodOnOff");
static_assert(sizeof(LFXSystemData_SetBloodOnOff) == 0x000001, "Wrong size on LFXSystemData_SetBloodOnOff");
static_assert(offsetof(LFXSystemData_SetBloodOnOff, bOnOff) == 0x000000, "Member 'LFXSystemData_SetBloodOnOff::bOnOff' has a wrong offset!");

// Function ProjectP.LFXSystemData.SetFatalIndicatorState
// 0x0050 (0x0050 - 0x0000)
struct LFXSystemData_SetFatalIndicatorState final
{
public:
	class FName                                   IndicatorKey;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALCharacter*                            TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFatalIndicatorState                         PrevState;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFatalIndicatorState                         CurrentState;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FxTransform;                                       // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystemData_SetFatalIndicatorState) == 0x000010, "Wrong alignment on LFXSystemData_SetFatalIndicatorState");
static_assert(sizeof(LFXSystemData_SetFatalIndicatorState) == 0x000050, "Wrong size on LFXSystemData_SetFatalIndicatorState");
static_assert(offsetof(LFXSystemData_SetFatalIndicatorState, IndicatorKey) == 0x000000, "Member 'LFXSystemData_SetFatalIndicatorState::IndicatorKey' has a wrong offset!");
static_assert(offsetof(LFXSystemData_SetFatalIndicatorState, TargetActor) == 0x000008, "Member 'LFXSystemData_SetFatalIndicatorState::TargetActor' has a wrong offset!");
static_assert(offsetof(LFXSystemData_SetFatalIndicatorState, PrevState) == 0x000010, "Member 'LFXSystemData_SetFatalIndicatorState::PrevState' has a wrong offset!");
static_assert(offsetof(LFXSystemData_SetFatalIndicatorState, CurrentState) == 0x000011, "Member 'LFXSystemData_SetFatalIndicatorState::CurrentState' has a wrong offset!");
static_assert(offsetof(LFXSystemData_SetFatalIndicatorState, FxTransform) == 0x000020, "Member 'LFXSystemData_SetFatalIndicatorState::FxTransform' has a wrong offset!");

// Function ProjectP.LFXSystem.DetachEffectHardly
// 0x001C (0x001C - 0x0000)
struct LFXSystem_DetachEffectHardly final
{
public:
	struct FLAttachedEffectSet                    Attached;                                          // 0x0000(0x001C)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_DetachEffectHardly) == 0x000004, "Wrong alignment on LFXSystem_DetachEffectHardly");
static_assert(sizeof(LFXSystem_DetachEffectHardly) == 0x00001C, "Wrong size on LFXSystem_DetachEffectHardly");
static_assert(offsetof(LFXSystem_DetachEffectHardly, Attached) == 0x000000, "Member 'LFXSystem_DetachEffectHardly::Attached' has a wrong offset!");

// Function ProjectP.LFXSystem.DoFrenzyModeMV
// 0x0010 (0x0010 - 0x0000)
struct LFXSystem_DoFrenzyModeMV final
{
public:
	class ALCharacter*                            InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrenzyMode;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystem_DoFrenzyModeMV) == 0x000008, "Wrong alignment on LFXSystem_DoFrenzyModeMV");
static_assert(sizeof(LFXSystem_DoFrenzyModeMV) == 0x000010, "Wrong size on LFXSystem_DoFrenzyModeMV");
static_assert(offsetof(LFXSystem_DoFrenzyModeMV, InTarget) == 0x000000, "Member 'LFXSystem_DoFrenzyModeMV::InTarget' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoFrenzyModeMV, bFrenzyMode) == 0x000008, "Member 'LFXSystem_DoFrenzyModeMV::bFrenzyMode' has a wrong offset!");

// Function ProjectP.LFXSystem.DoHitEffect
// 0x0080 (0x0080 - 0x0000)
struct LFXSystem_DoHitEffect final
{
public:
	struct FLHitFXPlayData                        HitFXPlayData;                                     // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_DoHitEffect) == 0x000010, "Wrong alignment on LFXSystem_DoHitEffect");
static_assert(sizeof(LFXSystem_DoHitEffect) == 0x000080, "Wrong size on LFXSystem_DoHitEffect");
static_assert(offsetof(LFXSystem_DoHitEffect, HitFXPlayData) == 0x000000, "Member 'LFXSystem_DoHitEffect::HitFXPlayData' has a wrong offset!");

// Function ProjectP.LFXSystem.DoSmashEffect
// 0x0050 (0x0050 - 0x0000)
struct LFXSystem_DoSmashEffect final
{
public:
	struct FLSmashFXPlayData                      SmashFxPlayData;                                   // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_DoSmashEffect) == 0x000010, "Wrong alignment on LFXSystem_DoSmashEffect");
static_assert(sizeof(LFXSystem_DoSmashEffect) == 0x000050, "Wrong size on LFXSystem_DoSmashEffect");
static_assert(offsetof(LFXSystem_DoSmashEffect, SmashFxPlayData) == 0x000000, "Member 'LFXSystem_DoSmashEffect::SmashFxPlayData' has a wrong offset!");

// Function ProjectP.LFXSystem.DoSocketTracerHitEffect_FX
// 0x0050 (0x0050 - 0x0000)
struct LFXSystem_DoSocketTracerHitEffect_FX final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerPhysicalSurface;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundPhysicalSurface;                             // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystem_DoSocketTracerHitEffect_FX) == 0x000010, "Wrong alignment on LFXSystem_DoSocketTracerHitEffect_FX");
static_assert(sizeof(LFXSystem_DoSocketTracerHitEffect_FX) == 0x000050, "Wrong size on LFXSystem_DoSocketTracerHitEffect_FX");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_FX, EventName) == 0x000000, "Member 'LFXSystem_DoSocketTracerHitEffect_FX::EventName' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_FX, HitTransform) == 0x000010, "Member 'LFXSystem_DoSocketTracerHitEffect_FX::HitTransform' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_FX, AttackerPhysicalSurface) == 0x000040, "Member 'LFXSystem_DoSocketTracerHitEffect_FX::AttackerPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_FX, GroundPhysicalSurface) == 0x000041, "Member 'LFXSystem_DoSocketTracerHitEffect_FX::GroundPhysicalSurface' has a wrong offset!");

// Function ProjectP.LFXSystem.DoSocketTracerHitEffect_SFX
// 0x0050 (0x0050 - 0x0000)
struct LFXSystem_DoSocketTracerHitEffect_SFX final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerPhysicalSurface;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundPhysicalSurface;                             // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystem_DoSocketTracerHitEffect_SFX) == 0x000010, "Wrong alignment on LFXSystem_DoSocketTracerHitEffect_SFX");
static_assert(sizeof(LFXSystem_DoSocketTracerHitEffect_SFX) == 0x000050, "Wrong size on LFXSystem_DoSocketTracerHitEffect_SFX");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_SFX, EventName) == 0x000000, "Member 'LFXSystem_DoSocketTracerHitEffect_SFX::EventName' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_SFX, HitTransform) == 0x000010, "Member 'LFXSystem_DoSocketTracerHitEffect_SFX::HitTransform' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_SFX, AttackerPhysicalSurface) == 0x000040, "Member 'LFXSystem_DoSocketTracerHitEffect_SFX::AttackerPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LFXSystem_DoSocketTracerHitEffect_SFX, GroundPhysicalSurface) == 0x000041, "Member 'LFXSystem_DoSocketTracerHitEffect_SFX::GroundPhysicalSurface' has a wrong offset!");

// Function ProjectP.LFXSystem.DoWeaponBladeDestroyEffect
// 0x000C (0x000C - 0x0000)
struct LFXSystem_DoWeaponBladeDestroyEffect final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_DoWeaponBladeDestroyEffect) == 0x000004, "Wrong alignment on LFXSystem_DoWeaponBladeDestroyEffect");
static_assert(sizeof(LFXSystem_DoWeaponBladeDestroyEffect) == 0x00000C, "Wrong size on LFXSystem_DoWeaponBladeDestroyEffect");
static_assert(offsetof(LFXSystem_DoWeaponBladeDestroyEffect, Location) == 0x000000, "Member 'LFXSystem_DoWeaponBladeDestroyEffect::Location' has a wrong offset!");

// Function ProjectP.LFXSystem.GetWeaponMaterialVarying
// 0x0030 (0x0030 - 0x0000)
struct LFXSystem_GetWeaponMaterialVarying final
{
public:
	class FName                                   MaterialFxCodename;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULMaterialVarying>       ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_GetWeaponMaterialVarying) == 0x000008, "Wrong alignment on LFXSystem_GetWeaponMaterialVarying");
static_assert(sizeof(LFXSystem_GetWeaponMaterialVarying) == 0x000030, "Wrong size on LFXSystem_GetWeaponMaterialVarying");
static_assert(offsetof(LFXSystem_GetWeaponMaterialVarying, MaterialFxCodename) == 0x000000, "Member 'LFXSystem_GetWeaponMaterialVarying::MaterialFxCodename' has a wrong offset!");
static_assert(offsetof(LFXSystem_GetWeaponMaterialVarying, ReturnValue) == 0x000008, "Member 'LFXSystem_GetWeaponMaterialVarying::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystem.GetWeaponTrailElementFX
// 0x0010 (0x0010 - 0x0000)
struct LFXSystem_GetWeaponTrailElementFX final
{
public:
	class FName                                   ElementFXCodename;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_GetWeaponTrailElementFX) == 0x000008, "Wrong alignment on LFXSystem_GetWeaponTrailElementFX");
static_assert(sizeof(LFXSystem_GetWeaponTrailElementFX) == 0x000010, "Wrong size on LFXSystem_GetWeaponTrailElementFX");
static_assert(offsetof(LFXSystem_GetWeaponTrailElementFX, ElementFXCodename) == 0x000000, "Member 'LFXSystem_GetWeaponTrailElementFX::ElementFXCodename' has a wrong offset!");
static_assert(offsetof(LFXSystem_GetWeaponTrailElementFX, ReturnValue) == 0x000008, "Member 'LFXSystem_GetWeaponTrailElementFX::ReturnValue' has a wrong offset!");

// Function ProjectP.LFXSystem.OnDetachNiagaraDelegate
// 0x0008 (0x0008 - 0x0000)
struct LFXSystem_OnDetachNiagaraDelegate final
{
public:
	class UNiagaraComponent*                      InNiagaraComp;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_OnDetachNiagaraDelegate) == 0x000008, "Wrong alignment on LFXSystem_OnDetachNiagaraDelegate");
static_assert(sizeof(LFXSystem_OnDetachNiagaraDelegate) == 0x000008, "Wrong size on LFXSystem_OnDetachNiagaraDelegate");
static_assert(offsetof(LFXSystem_OnDetachNiagaraDelegate, InNiagaraComp) == 0x000000, "Member 'LFXSystem_OnDetachNiagaraDelegate::InNiagaraComp' has a wrong offset!");

// Function ProjectP.LFXSystem.OnDetachParticleDelegate
// 0x0008 (0x0008 - 0x0000)
struct LFXSystem_OnDetachParticleDelegate final
{
public:
	class UParticleSystemComponent*               InParticleComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_OnDetachParticleDelegate) == 0x000008, "Wrong alignment on LFXSystem_OnDetachParticleDelegate");
static_assert(sizeof(LFXSystem_OnDetachParticleDelegate) == 0x000008, "Wrong size on LFXSystem_OnDetachParticleDelegate");
static_assert(offsetof(LFXSystem_OnDetachParticleDelegate, InParticleComp) == 0x000000, "Member 'LFXSystem_OnDetachParticleDelegate::InParticleComp' has a wrong offset!");

// Function ProjectP.LFXSystem.OnFuryAttack
// 0x0010 (0x0010 - 0x0000)
struct LFXSystem_OnFuryAttack final
{
public:
	class ALNPCCharacter*                         InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InVolumeModifier;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LFXSystem_OnFuryAttack) == 0x000008, "Wrong alignment on LFXSystem_OnFuryAttack");
static_assert(sizeof(LFXSystem_OnFuryAttack) == 0x000010, "Wrong size on LFXSystem_OnFuryAttack");
static_assert(offsetof(LFXSystem_OnFuryAttack, InTarget) == 0x000000, "Member 'LFXSystem_OnFuryAttack::InTarget' has a wrong offset!");
static_assert(offsetof(LFXSystem_OnFuryAttack, InVolumeModifier) == 0x000008, "Member 'LFXSystem_OnFuryAttack::InVolumeModifier' has a wrong offset!");

// Function ProjectP.LFXSystem.OnParalyzationOcurred
// 0x0008 (0x0008 - 0x0000)
struct LFXSystem_OnParalyzationOcurred final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_OnParalyzationOcurred) == 0x000008, "Wrong alignment on LFXSystem_OnParalyzationOcurred");
static_assert(sizeof(LFXSystem_OnParalyzationOcurred) == 0x000008, "Wrong size on LFXSystem_OnParalyzationOcurred");
static_assert(offsetof(LFXSystem_OnParalyzationOcurred, Victim) == 0x000000, "Member 'LFXSystem_OnParalyzationOcurred::Victim' has a wrong offset!");

// Function ProjectP.LFXSystem.PlayDeadSound
// 0x0008 (0x0008 - 0x0000)
struct LFXSystem_PlayDeadSound final
{
public:
	class AActor*                                 DeadActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_PlayDeadSound) == 0x000008, "Wrong alignment on LFXSystem_PlayDeadSound");
static_assert(sizeof(LFXSystem_PlayDeadSound) == 0x000008, "Wrong size on LFXSystem_PlayDeadSound");
static_assert(offsetof(LFXSystem_PlayDeadSound, DeadActor) == 0x000000, "Member 'LFXSystem_PlayDeadSound::DeadActor' has a wrong offset!");

// Function ProjectP.LFXSystem.SetFatalIndicatorState
// 0x0050 (0x0050 - 0x0000)
struct LFXSystem_SetFatalIndicatorState final
{
public:
	class FName                                   IndicatorKey;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALCharacter*                            TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFatalIndicatorState                         PrevState;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFatalIndicatorState                         CurrentState;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FxTransform;                                       // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFXSystem_SetFatalIndicatorState) == 0x000010, "Wrong alignment on LFXSystem_SetFatalIndicatorState");
static_assert(sizeof(LFXSystem_SetFatalIndicatorState) == 0x000050, "Wrong size on LFXSystem_SetFatalIndicatorState");
static_assert(offsetof(LFXSystem_SetFatalIndicatorState, IndicatorKey) == 0x000000, "Member 'LFXSystem_SetFatalIndicatorState::IndicatorKey' has a wrong offset!");
static_assert(offsetof(LFXSystem_SetFatalIndicatorState, TargetActor) == 0x000008, "Member 'LFXSystem_SetFatalIndicatorState::TargetActor' has a wrong offset!");
static_assert(offsetof(LFXSystem_SetFatalIndicatorState, PrevState) == 0x000010, "Member 'LFXSystem_SetFatalIndicatorState::PrevState' has a wrong offset!");
static_assert(offsetof(LFXSystem_SetFatalIndicatorState, CurrentState) == 0x000011, "Member 'LFXSystem_SetFatalIndicatorState::CurrentState' has a wrong offset!");
static_assert(offsetof(LFXSystem_SetFatalIndicatorState, FxTransform) == 0x000020, "Member 'LFXSystem_SetFatalIndicatorState::FxTransform' has a wrong offset!");

// Function ProjectP.LGallerySystemData.GetSpawned
// 0x0008 (0x0008 - 0x0000)
struct LGallerySystemData_GetSpawned final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGallerySystemData_GetSpawned) == 0x000008, "Wrong alignment on LGallerySystemData_GetSpawned");
static_assert(sizeof(LGallerySystemData_GetSpawned) == 0x000008, "Wrong size on LGallerySystemData_GetSpawned");
static_assert(offsetof(LGallerySystemData_GetSpawned, ReturnValue) == 0x000000, "Member 'LGallerySystemData_GetSpawned::ReturnValue' has a wrong offset!");

// Function ProjectP.LGallerySystemData.Spawn
// 0x0028 (0x0028 - 0x0000)
struct LGallerySystemData_Spawn final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACineCameraActor*                       InPreviewCam;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPreviewCam_OriginZ;                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGallerySystemData_Spawn) == 0x000008, "Wrong alignment on LGallerySystemData_Spawn");
static_assert(sizeof(LGallerySystemData_Spawn) == 0x000028, "Wrong size on LGallerySystemData_Spawn");
static_assert(offsetof(LGallerySystemData_Spawn, CodeName) == 0x000000, "Member 'LGallerySystemData_Spawn::CodeName' has a wrong offset!");
static_assert(offsetof(LGallerySystemData_Spawn, InLocation) == 0x000008, "Member 'LGallerySystemData_Spawn::InLocation' has a wrong offset!");
static_assert(offsetof(LGallerySystemData_Spawn, InPreviewCam) == 0x000018, "Member 'LGallerySystemData_Spawn::InPreviewCam' has a wrong offset!");
static_assert(offsetof(LGallerySystemData_Spawn, InPreviewCam_OriginZ) == 0x000020, "Member 'LGallerySystemData_Spawn::InPreviewCam_OriginZ' has a wrong offset!");

// Function ProjectP.LGallerySystem.GetRecollectionAssetInfo
// 0x0060 (0x0060 - 0x0000)
struct LGallerySystem_GetRecollectionAssetInfo final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGalleryAssetTableRowType             ReturnValue;                                       // 0x0008(0x0058)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGallerySystem_GetRecollectionAssetInfo) == 0x000008, "Wrong alignment on LGallerySystem_GetRecollectionAssetInfo");
static_assert(sizeof(LGallerySystem_GetRecollectionAssetInfo) == 0x000060, "Wrong size on LGallerySystem_GetRecollectionAssetInfo");
static_assert(offsetof(LGallerySystem_GetRecollectionAssetInfo, CodeName) == 0x000000, "Member 'LGallerySystem_GetRecollectionAssetInfo::CodeName' has a wrong offset!");
static_assert(offsetof(LGallerySystem_GetRecollectionAssetInfo, ReturnValue) == 0x000008, "Member 'LGallerySystem_GetRecollectionAssetInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LGallerySystem.GetRecollections
// 0x0010 (0x0010 - 0x0000)
struct LGallerySystem_GetRecollections final
{
public:
	TArray<struct FLDiplayableGallery>            ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGallerySystem_GetRecollections) == 0x000008, "Wrong alignment on LGallerySystem_GetRecollections");
static_assert(sizeof(LGallerySystem_GetRecollections) == 0x000010, "Wrong size on LGallerySystem_GetRecollections");
static_assert(offsetof(LGallerySystem_GetRecollections, ReturnValue) == 0x000000, "Member 'LGallerySystem_GetRecollections::ReturnValue' has a wrong offset!");

// Function ProjectP.LGallerySystem.GetSpawnedModel
// 0x0008 (0x0008 - 0x0000)
struct LGallerySystem_GetSpawnedModel final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGallerySystem_GetSpawnedModel) == 0x000008, "Wrong alignment on LGallerySystem_GetSpawnedModel");
static_assert(sizeof(LGallerySystem_GetSpawnedModel) == 0x000008, "Wrong size on LGallerySystem_GetSpawnedModel");
static_assert(offsetof(LGallerySystem_GetSpawnedModel, ReturnValue) == 0x000000, "Member 'LGallerySystem_GetSpawnedModel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGallerySystem.SpawnModel
// 0x0028 (0x0028 - 0x0000)
struct LGallerySystem_SpawnModel final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACineCameraActor*                       InPreviewCam;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPreviewCam_OriginZ;                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGallerySystem_SpawnModel) == 0x000008, "Wrong alignment on LGallerySystem_SpawnModel");
static_assert(sizeof(LGallerySystem_SpawnModel) == 0x000028, "Wrong size on LGallerySystem_SpawnModel");
static_assert(offsetof(LGallerySystem_SpawnModel, CodeName) == 0x000000, "Member 'LGallerySystem_SpawnModel::CodeName' has a wrong offset!");
static_assert(offsetof(LGallerySystem_SpawnModel, InLocation) == 0x000008, "Member 'LGallerySystem_SpawnModel::InLocation' has a wrong offset!");
static_assert(offsetof(LGallerySystem_SpawnModel, InPreviewCam) == 0x000018, "Member 'LGallerySystem_SpawnModel::InPreviewCam' has a wrong offset!");
static_assert(offsetof(LGallerySystem_SpawnModel, InPreviewCam_OriginZ) == 0x000020, "Member 'LGallerySystem_SpawnModel::InPreviewCam_OriginZ' has a wrong offset!");

// Function ProjectP.LGallerySystem.SuccessSpawnModel
// 0x0008 (0x0008 - 0x0000)
struct LGallerySystem_SuccessSpawnModel final
{
public:
	class AActor*                                 InSpawnModel;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGallerySystem_SuccessSpawnModel) == 0x000008, "Wrong alignment on LGallerySystem_SuccessSpawnModel");
static_assert(sizeof(LGallerySystem_SuccessSpawnModel) == 0x000008, "Wrong size on LGallerySystem_SuccessSpawnModel");
static_assert(offsetof(LGallerySystem_SuccessSpawnModel, InSpawnModel) == 0x000000, "Member 'LGallerySystem_SuccessSpawnModel::InSpawnModel' has a wrong offset!");

// Function ProjectP.LRecordCameraData.GetSampleFrame
// 0x001C (0x001C - 0x0000)
struct LRecordCameraData_GetSampleFrame final
{
public:
	float                                         FlowTime;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LRecordCameraData_GetSampleFrame) == 0x000004, "Wrong alignment on LRecordCameraData_GetSampleFrame");
static_assert(sizeof(LRecordCameraData_GetSampleFrame) == 0x00001C, "Wrong size on LRecordCameraData_GetSampleFrame");
static_assert(offsetof(LRecordCameraData_GetSampleFrame, FlowTime) == 0x000000, "Member 'LRecordCameraData_GetSampleFrame::FlowTime' has a wrong offset!");
static_assert(offsetof(LRecordCameraData_GetSampleFrame, Location) == 0x000004, "Member 'LRecordCameraData_GetSampleFrame::Location' has a wrong offset!");
static_assert(offsetof(LRecordCameraData_GetSampleFrame, Rotation) == 0x000010, "Member 'LRecordCameraData_GetSampleFrame::Rotation' has a wrong offset!");

// Function ProjectP.LRecordCameraData.SampleFrame
// 0x001C (0x001C - 0x0000)
struct LRecordCameraData_SampleFrame final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LRecordCameraData_SampleFrame) == 0x000004, "Wrong alignment on LRecordCameraData_SampleFrame");
static_assert(sizeof(LRecordCameraData_SampleFrame) == 0x00001C, "Wrong size on LRecordCameraData_SampleFrame");
static_assert(offsetof(LRecordCameraData_SampleFrame, DeltaTime) == 0x000000, "Member 'LRecordCameraData_SampleFrame::DeltaTime' has a wrong offset!");
static_assert(offsetof(LRecordCameraData_SampleFrame, Location) == 0x000004, "Member 'LRecordCameraData_SampleFrame::Location' has a wrong offset!");
static_assert(offsetof(LRecordCameraData_SampleFrame, Rotation) == 0x000010, "Member 'LRecordCameraData_SampleFrame::Rotation' has a wrong offset!");

// Function ProjectP.LReasonForDeathInfo.IsDead
// 0x0001 (0x0001 - 0x0000)
struct LReasonForDeathInfo_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LReasonForDeathInfo_IsDead) == 0x000001, "Wrong alignment on LReasonForDeathInfo_IsDead");
static_assert(sizeof(LReasonForDeathInfo_IsDead) == 0x000001, "Wrong size on LReasonForDeathInfo_IsDead");
static_assert(offsetof(LReasonForDeathInfo_IsDead, ReturnValue) == 0x000000, "Member 'LReasonForDeathInfo_IsDead::ReturnValue' has a wrong offset!");

// Function ProjectP.LReasonForDeathInfo.MakeNewRecord
// 0x0010 (0x0010 - 0x0000)
struct LReasonForDeathInfo_MakeNewRecord final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELDieCauseType                                InDieCauseType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LReasonForDeathInfo_MakeNewRecord) == 0x000008, "Wrong alignment on LReasonForDeathInfo_MakeNewRecord");
static_assert(sizeof(LReasonForDeathInfo_MakeNewRecord) == 0x000010, "Wrong size on LReasonForDeathInfo_MakeNewRecord");
static_assert(offsetof(LReasonForDeathInfo_MakeNewRecord, TargetActor) == 0x000000, "Member 'LReasonForDeathInfo_MakeNewRecord::TargetActor' has a wrong offset!");
static_assert(offsetof(LReasonForDeathInfo_MakeNewRecord, InDieCauseType) == 0x000008, "Member 'LReasonForDeathInfo_MakeNewRecord::InDieCauseType' has a wrong offset!");
static_assert(offsetof(LReasonForDeathInfo_MakeNewRecord, ReturnValue) == 0x000009, "Member 'LReasonForDeathInfo_MakeNewRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildUpRecover
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAbnormalStateBuildUpRecover final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAbnormalStateBuildUpRecover) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAbnormalStateBuildUpRecover");
static_assert(sizeof(LCommonConstantValues_GetAbnormalStateBuildUpRecover) == 0x000004, "Wrong size on LCommonConstantValues_GetAbnormalStateBuildUpRecover");
static_assert(offsetof(LCommonConstantValues_GetAbnormalStateBuildUpRecover, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAbnormalStateBuildUpRecover::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildUpRecoverDelay
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay");
static_assert(sizeof(LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay) == 0x000004, "Wrong size on LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay");
static_assert(offsetof(LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildupRecoverRate
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAbnormalStateBuildupRecoverRate final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAbnormalStateBuildupRecoverRate) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAbnormalStateBuildupRecoverRate");
static_assert(sizeof(LCommonConstantValues_GetAbnormalStateBuildupRecoverRate) == 0x000004, "Wrong size on LCommonConstantValues_GetAbnormalStateBuildupRecoverRate");
static_assert(offsetof(LCommonConstantValues_GetAbnormalStateBuildupRecoverRate, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAbnormalStateBuildupRecoverRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildupRecoverWait
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAbnormalStateBuildupRecoverWait final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAbnormalStateBuildupRecoverWait) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAbnormalStateBuildupRecoverWait");
static_assert(sizeof(LCommonConstantValues_GetAbnormalStateBuildupRecoverWait) == 0x000004, "Wrong size on LCommonConstantValues_GetAbnormalStateBuildupRecoverWait");
static_assert(offsetof(LCommonConstantValues_GetAbnormalStateBuildupRecoverWait, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAbnormalStateBuildupRecoverWait::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAbnormalStatePenaltyBase
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAbnormalStatePenaltyBase final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAbnormalStatePenaltyBase) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAbnormalStatePenaltyBase");
static_assert(sizeof(LCommonConstantValues_GetAbnormalStatePenaltyBase) == 0x000004, "Wrong size on LCommonConstantValues_GetAbnormalStatePenaltyBase");
static_assert(offsetof(LCommonConstantValues_GetAbnormalStatePenaltyBase, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAbnormalStatePenaltyBase::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAbnormalStatePenaltyExponent
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAbnormalStatePenaltyExponent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAbnormalStatePenaltyExponent) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAbnormalStatePenaltyExponent");
static_assert(sizeof(LCommonConstantValues_GetAbnormalStatePenaltyExponent) == 0x000004, "Wrong size on LCommonConstantValues_GetAbnormalStatePenaltyExponent");
static_assert(offsetof(LCommonConstantValues_GetAbnormalStatePenaltyExponent, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAbnormalStatePenaltyExponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAfterEndingCookieMovie
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetAfterEndingCookieMovie final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAfterEndingCookieMovie) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAfterEndingCookieMovie");
static_assert(sizeof(LCommonConstantValues_GetAfterEndingCookieMovie) == 0x000008, "Wrong size on LCommonConstantValues_GetAfterEndingCookieMovie");
static_assert(offsetof(LCommonConstantValues_GetAfterEndingCookieMovie, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAfterEndingCookieMovie::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAggro_Target_Range
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAggro_Target_Range final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAggro_Target_Range) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAggro_Target_Range");
static_assert(sizeof(LCommonConstantValues_GetAggro_Target_Range) == 0x000004, "Wrong size on LCommonConstantValues_GetAggro_Target_Range");
static_assert(offsetof(LCommonConstantValues_GetAggro_Target_Range, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAggro_Target_Range::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetASZombieHPSet
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetASZombieHPSet final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetASZombieHPSet) == 0x000004, "Wrong alignment on LCommonConstantValues_GetASZombieHPSet");
static_assert(sizeof(LCommonConstantValues_GetASZombieHPSet) == 0x000004, "Wrong size on LCommonConstantValues_GetASZombieHPSet");
static_assert(offsetof(LCommonConstantValues_GetASZombieHPSet, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetASZombieHPSet::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAttackDefenceAdd
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAttackDefenceAdd final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAttackDefenceAdd) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAttackDefenceAdd");
static_assert(sizeof(LCommonConstantValues_GetAttackDefenceAdd) == 0x000004, "Wrong size on LCommonConstantValues_GetAttackDefenceAdd");
static_assert(offsetof(LCommonConstantValues_GetAttackDefenceAdd, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAttackDefenceAdd::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAttackDefenceExponent
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAttackDefenceExponent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAttackDefenceExponent) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAttackDefenceExponent");
static_assert(sizeof(LCommonConstantValues_GetAttackDefenceExponent) == 0x000004, "Wrong size on LCommonConstantValues_GetAttackDefenceExponent");
static_assert(offsetof(LCommonConstantValues_GetAttackDefenceExponent, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAttackDefenceExponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAttackDefenceScale
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAttackDefenceScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAttackDefenceScale) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAttackDefenceScale");
static_assert(sizeof(LCommonConstantValues_GetAttackDefenceScale) == 0x000004, "Wrong size on LCommonConstantValues_GetAttackDefenceScale");
static_assert(offsetof(LCommonConstantValues_GetAttackDefenceScale, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAttackDefenceScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAttackScale
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAttackScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAttackScale) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAttackScale");
static_assert(sizeof(LCommonConstantValues_GetAttackScale) == 0x000004, "Wrong size on LCommonConstantValues_GetAttackScale");
static_assert(offsetof(LCommonConstantValues_GetAttackScale, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAttackScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAttackSpeedRatioMax
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAttackSpeedRatioMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAttackSpeedRatioMax) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAttackSpeedRatioMax");
static_assert(sizeof(LCommonConstantValues_GetAttackSpeedRatioMax) == 0x000004, "Wrong size on LCommonConstantValues_GetAttackSpeedRatioMax");
static_assert(offsetof(LCommonConstantValues_GetAttackSpeedRatioMax, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAttackSpeedRatioMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetAttackSpeedRatioMin
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetAttackSpeedRatioMin final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetAttackSpeedRatioMin) == 0x000004, "Wrong alignment on LCommonConstantValues_GetAttackSpeedRatioMin");
static_assert(sizeof(LCommonConstantValues_GetAttackSpeedRatioMin) == 0x000004, "Wrong size on LCommonConstantValues_GetAttackSpeedRatioMin");
static_assert(offsetof(LCommonConstantValues_GetAttackSpeedRatioMin, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetAttackSpeedRatioMin::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBladeElementAttackBuff_Acid
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetBladeElementAttackBuff_Acid final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBladeElementAttackBuff_Acid) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBladeElementAttackBuff_Acid");
static_assert(sizeof(LCommonConstantValues_GetBladeElementAttackBuff_Acid) == 0x000008, "Wrong size on LCommonConstantValues_GetBladeElementAttackBuff_Acid");
static_assert(offsetof(LCommonConstantValues_GetBladeElementAttackBuff_Acid, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBladeElementAttackBuff_Acid::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBladeElementAttackBuff_Electric
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetBladeElementAttackBuff_Electric final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBladeElementAttackBuff_Electric) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBladeElementAttackBuff_Electric");
static_assert(sizeof(LCommonConstantValues_GetBladeElementAttackBuff_Electric) == 0x000008, "Wrong size on LCommonConstantValues_GetBladeElementAttackBuff_Electric");
static_assert(offsetof(LCommonConstantValues_GetBladeElementAttackBuff_Electric, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBladeElementAttackBuff_Electric::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBladeElementAttackBuff_Fire
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetBladeElementAttackBuff_Fire final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBladeElementAttackBuff_Fire) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBladeElementAttackBuff_Fire");
static_assert(sizeof(LCommonConstantValues_GetBladeElementAttackBuff_Fire) == 0x000008, "Wrong size on LCommonConstantValues_GetBladeElementAttackBuff_Fire");
static_assert(offsetof(LCommonConstantValues_GetBladeElementAttackBuff_Fire, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBladeElementAttackBuff_Fire::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBladeNeedStatLackAtkRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetBladeNeedStatLackAtkRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBladeNeedStatLackAtkRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBladeNeedStatLackAtkRatio");
static_assert(sizeof(LCommonConstantValues_GetBladeNeedStatLackAtkRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetBladeNeedStatLackAtkRatio");
static_assert(offsetof(LCommonConstantValues_GetBladeNeedStatLackAtkRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBladeNeedStatLackAtkRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBladeNeedStatLackDestructionRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetBladeNeedStatLackDestructionRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBladeNeedStatLackDestructionRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBladeNeedStatLackDestructionRatio");
static_assert(sizeof(LCommonConstantValues_GetBladeNeedStatLackDestructionRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetBladeNeedStatLackDestructionRatio");
static_assert(offsetof(LCommonConstantValues_GetBladeNeedStatLackDestructionRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBladeNeedStatLackDestructionRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBladeNeedStatLackStaminaRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetBladeNeedStatLackStaminaRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBladeNeedStatLackStaminaRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBladeNeedStatLackStaminaRatio");
static_assert(sizeof(LCommonConstantValues_GetBladeNeedStatLackStaminaRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetBladeNeedStatLackStaminaRatio");
static_assert(offsetof(LCommonConstantValues_GetBladeNeedStatLackStaminaRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBladeNeedStatLackStaminaRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBossRaxasiaShieldBrokenName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetBossRaxasiaShieldBrokenName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBossRaxasiaShieldBrokenName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBossRaxasiaShieldBrokenName");
static_assert(sizeof(LCommonConstantValues_GetBossRaxasiaShieldBrokenName) == 0x000008, "Wrong size on LCommonConstantValues_GetBossRaxasiaShieldBrokenName");
static_assert(offsetof(LCommonConstantValues_GetBossRaxasiaShieldBrokenName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBossRaxasiaShieldBrokenName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBossRaxasiaShieldName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetBossRaxasiaShieldName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBossRaxasiaShieldName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBossRaxasiaShieldName");
static_assert(sizeof(LCommonConstantValues_GetBossRaxasiaShieldName) == 0x000008, "Wrong size on LCommonConstantValues_GetBossRaxasiaShieldName");
static_assert(offsetof(LCommonConstantValues_GetBossRaxasiaShieldName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBossRaxasiaShieldName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBossRoom_Ergodrop_relocation_check_state
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state");
static_assert(sizeof(LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state) == 0x000008, "Wrong size on LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state");
static_assert(offsetof(LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBuildUpRecoverIncBase
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetBuildUpRecoverIncBase final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBuildUpRecoverIncBase) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBuildUpRecoverIncBase");
static_assert(sizeof(LCommonConstantValues_GetBuildUpRecoverIncBase) == 0x000004, "Wrong size on LCommonConstantValues_GetBuildUpRecoverIncBase");
static_assert(offsetof(LCommonConstantValues_GetBuildUpRecoverIncBase, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBuildUpRecoverIncBase::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetBuildUpRecoverIncExponent
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetBuildUpRecoverIncExponent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetBuildUpRecoverIncExponent) == 0x000004, "Wrong alignment on LCommonConstantValues_GetBuildUpRecoverIncExponent");
static_assert(sizeof(LCommonConstantValues_GetBuildUpRecoverIncExponent) == 0x000004, "Wrong size on LCommonConstantValues_GetBuildUpRecoverIncExponent");
static_assert(offsetof(LCommonConstantValues_GetBuildUpRecoverIncExponent, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetBuildUpRecoverIncExponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCatDustEffectRange
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetCatDustEffectRange final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCatDustEffectRange) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCatDustEffectRange");
static_assert(sizeof(LCommonConstantValues_GetCatDustEffectRange) == 0x000004, "Wrong size on LCommonConstantValues_GetCatDustEffectRange");
static_assert(offsetof(LCommonConstantValues_GetCatDustEffectRange, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCatDustEffectRange::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCatDustRangeDecreaseRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetCatDustRangeDecreaseRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCatDustRangeDecreaseRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCatDustRangeDecreaseRatio");
static_assert(sizeof(LCommonConstantValues_GetCatDustRangeDecreaseRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetCatDustRangeDecreaseRatio");
static_assert(offsetof(LCommonConstantValues_GetCatDustRangeDecreaseRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCatDustRangeDecreaseRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCatDustSensitiveDecreaseTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetCatDustSensitiveDecreaseTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCatDustSensitiveDecreaseTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCatDustSensitiveDecreaseTime");
static_assert(sizeof(LCommonConstantValues_GetCatDustSensitiveDecreaseTime) == 0x000004, "Wrong size on LCommonConstantValues_GetCatDustSensitiveDecreaseTime");
static_assert(offsetof(LCommonConstantValues_GetCatDustSensitiveDecreaseTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCatDustSensitiveDecreaseTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCH06BossKill
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetCH06BossKill final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCH06BossKill) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCH06BossKill");
static_assert(sizeof(LCommonConstantValues_GetCH06BossKill) == 0x000008, "Wrong size on LCommonConstantValues_GetCH06BossKill");
static_assert(offsetof(LCommonConstantValues_GetCH06BossKill, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCH06BossKill::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCH13BossKill
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetCH13BossKill final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCH13BossKill) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCH13BossKill");
static_assert(sizeof(LCommonConstantValues_GetCH13BossKill) == 0x000008, "Wrong size on LCommonConstantValues_GetCH13BossKill");
static_assert(offsetof(LCommonConstantValues_GetCH13BossKill, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCH13BossKill::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetConsumeReturnClockBlockCondition
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetConsumeReturnClockBlockCondition final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetConsumeReturnClockBlockCondition) == 0x000004, "Wrong alignment on LCommonConstantValues_GetConsumeReturnClockBlockCondition");
static_assert(sizeof(LCommonConstantValues_GetConsumeReturnClockBlockCondition) == 0x000008, "Wrong size on LCommonConstantValues_GetConsumeReturnClockBlockCondition");
static_assert(offsetof(LCommonConstantValues_GetConsumeReturnClockBlockCondition, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetConsumeReturnClockBlockCondition::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetConsumeReturnClockBlockMsg
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetConsumeReturnClockBlockMsg final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetConsumeReturnClockBlockMsg) == 0x000004, "Wrong alignment on LCommonConstantValues_GetConsumeReturnClockBlockMsg");
static_assert(sizeof(LCommonConstantValues_GetConsumeReturnClockBlockMsg) == 0x000008, "Wrong size on LCommonConstantValues_GetConsumeReturnClockBlockMsg");
static_assert(offsetof(LCommonConstantValues_GetConsumeReturnClockBlockMsg, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetConsumeReturnClockBlockMsg::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCopper2setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetCopper2setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCopper2setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCopper2setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetCopper2setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetCopper2setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetCopper2setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCopper2setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetCopper3setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetCopper3setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetCopper3setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetCopper3setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetCopper3setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetCopper3setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetCopper3setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetCopper3setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDashParryCooltime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDashParryCooltime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDashParryCooltime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDashParryCooltime");
static_assert(sizeof(LCommonConstantValues_GetDashParryCooltime) == 0x000004, "Wrong size on LCommonConstantValues_GetDashParryCooltime");
static_assert(offsetof(LCommonConstantValues_GetDashParryCooltime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDashParryCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDefaultCostumeCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetDefaultCostumeCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDefaultCostumeCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDefaultCostumeCodeName");
static_assert(sizeof(LCommonConstantValues_GetDefaultCostumeCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetDefaultCostumeCodeName");
static_assert(offsetof(LCommonConstantValues_GetDefaultCostumeCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDefaultCostumeCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDefenceFactor
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDefenceFactor final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDefenceFactor) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDefenceFactor");
static_assert(sizeof(LCommonConstantValues_GetDefenceFactor) == 0x000004, "Wrong size on LCommonConstantValues_GetDefenceFactor");
static_assert(offsetof(LCommonConstantValues_GetDefenceFactor, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDefenceFactor::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDefenceScale
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDefenceScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDefenceScale) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDefenceScale");
static_assert(sizeof(LCommonConstantValues_GetDefenceScale) == 0x000004, "Wrong size on LCommonConstantValues_GetDefenceScale");
static_assert(offsetof(LCommonConstantValues_GetDefenceScale, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDefenceScale::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDialogInputTerm
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDialogInputTerm final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDialogInputTerm) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDialogInputTerm");
static_assert(sizeof(LCommonConstantValues_GetDialogInputTerm) == 0x000004, "Wrong size on LCommonConstantValues_GetDialogInputTerm");
static_assert(offsetof(LCommonConstantValues_GetDialogInputTerm, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDialogInputTerm::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDialogNextSpeed
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDialogNextSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDialogNextSpeed) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDialogNextSpeed");
static_assert(sizeof(LCommonConstantValues_GetDialogNextSpeed) == 0x000004, "Wrong size on LCommonConstantValues_GetDialogNextSpeed");
static_assert(offsetof(LCommonConstantValues_GetDialogNextSpeed, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDialogNextSpeed::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDialogVoiceFadeoutSec
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDialogVoiceFadeoutSec final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDialogVoiceFadeoutSec) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDialogVoiceFadeoutSec");
static_assert(sizeof(LCommonConstantValues_GetDialogVoiceFadeoutSec) == 0x000004, "Wrong size on LCommonConstantValues_GetDialogVoiceFadeoutSec");
static_assert(offsetof(LCommonConstantValues_GetDialogVoiceFadeoutSec, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDialogVoiceFadeoutSec::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDialogVoiceTermTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDialogVoiceTermTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDialogVoiceTermTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDialogVoiceTermTime");
static_assert(sizeof(LCommonConstantValues_GetDialogVoiceTermTime) == 0x000004, "Wrong size on LCommonConstantValues_GetDialogVoiceTermTime");
static_assert(offsetof(LCommonConstantValues_GetDialogVoiceTermTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDialogVoiceTermTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDoorKeyFail
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetDoorKeyFail final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDoorKeyFail) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDoorKeyFail");
static_assert(sizeof(LCommonConstantValues_GetDoorKeyFail) == 0x000008, "Wrong size on LCommonConstantValues_GetDoorKeyFail");
static_assert(offsetof(LCommonConstantValues_GetDoorKeyFail, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDoorKeyFail::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDoorKeySuccess
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetDoorKeySuccess final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDoorKeySuccess) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDoorKeySuccess");
static_assert(sizeof(LCommonConstantValues_GetDoorKeySuccess) == 0x000008, "Wrong size on LCommonConstantValues_GetDoorKeySuccess");
static_assert(offsetof(LCommonConstantValues_GetDoorKeySuccess, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDoorKeySuccess::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetDropErgoExchangeRate
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetDropErgoExchangeRate final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetDropErgoExchangeRate) == 0x000004, "Wrong alignment on LCommonConstantValues_GetDropErgoExchangeRate");
static_assert(sizeof(LCommonConstantValues_GetDropErgoExchangeRate) == 0x000004, "Wrong size on LCommonConstantValues_GetDropErgoExchangeRate");
static_assert(offsetof(LCommonConstantValues_GetDropErgoExchangeRate, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetDropErgoExchangeRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetElementalAbStateBuildUpRecover
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetElementalAbStateBuildUpRecover final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetElementalAbStateBuildUpRecover) == 0x000004, "Wrong alignment on LCommonConstantValues_GetElementalAbStateBuildUpRecover");
static_assert(sizeof(LCommonConstantValues_GetElementalAbStateBuildUpRecover) == 0x000004, "Wrong size on LCommonConstantValues_GetElementalAbStateBuildUpRecover");
static_assert(offsetof(LCommonConstantValues_GetElementalAbStateBuildUpRecover, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetElementalAbStateBuildUpRecover::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetElementalAbStateBuildUpRecoverDelay
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay) == 0x000004, "Wrong alignment on LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay");
static_assert(sizeof(LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay) == 0x000004, "Wrong size on LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay");
static_assert(offsetof(LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetExiledNpcWarningMsgDelay
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetExiledNpcWarningMsgDelay final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetExiledNpcWarningMsgDelay) == 0x000004, "Wrong alignment on LCommonConstantValues_GetExiledNpcWarningMsgDelay");
static_assert(sizeof(LCommonConstantValues_GetExiledNpcWarningMsgDelay) == 0x000004, "Wrong size on LCommonConstantValues_GetExiledNpcWarningMsgDelay");
static_assert(offsetof(LCommonConstantValues_GetExiledNpcWarningMsgDelay, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetExiledNpcWarningMsgDelay::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetFrenzyAbnormalCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetFrenzyAbnormalCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetFrenzyAbnormalCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetFrenzyAbnormalCodeName");
static_assert(sizeof(LCommonConstantValues_GetFrenzyAbnormalCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetFrenzyAbnormalCodeName");
static_assert(offsetof(LCommonConstantValues_GetFrenzyAbnormalCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetFrenzyAbnormalCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetFrenzyPointMax
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetFrenzyPointMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetFrenzyPointMax) == 0x000004, "Wrong alignment on LCommonConstantValues_GetFrenzyPointMax");
static_assert(sizeof(LCommonConstantValues_GetFrenzyPointMax) == 0x000004, "Wrong size on LCommonConstantValues_GetFrenzyPointMax");
static_assert(offsetof(LCommonConstantValues_GetFrenzyPointMax, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetFrenzyPointMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldenTreeAccelTimes
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetGoldenTreeAccelTimes final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldenTreeAccelTimes) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGoldenTreeAccelTimes");
static_assert(sizeof(LCommonConstantValues_GetGoldenTreeAccelTimes) == 0x000004, "Wrong size on LCommonConstantValues_GetGoldenTreeAccelTimes");
static_assert(offsetof(LCommonConstantValues_GetGoldenTreeAccelTimes, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldenTreeAccelTimes::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldenTreeHarvestFirst
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetGoldenTreeHarvestFirst final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldenTreeHarvestFirst) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGoldenTreeHarvestFirst");
static_assert(sizeof(LCommonConstantValues_GetGoldenTreeHarvestFirst) == 0x000004, "Wrong size on LCommonConstantValues_GetGoldenTreeHarvestFirst");
static_assert(offsetof(LCommonConstantValues_GetGoldenTreeHarvestFirst, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldenTreeHarvestFirst::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldenTreeHarvestItem
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetGoldenTreeHarvestItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldenTreeHarvestItem) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGoldenTreeHarvestItem");
static_assert(sizeof(LCommonConstantValues_GetGoldenTreeHarvestItem) == 0x000008, "Wrong size on LCommonConstantValues_GetGoldenTreeHarvestItem");
static_assert(offsetof(LCommonConstantValues_GetGoldenTreeHarvestItem, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldenTreeHarvestItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldenTreeHarvestItemNum
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetGoldenTreeHarvestItemNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldenTreeHarvestItemNum) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGoldenTreeHarvestItemNum");
static_assert(sizeof(LCommonConstantValues_GetGoldenTreeHarvestItemNum) == 0x000004, "Wrong size on LCommonConstantValues_GetGoldenTreeHarvestItemNum");
static_assert(offsetof(LCommonConstantValues_GetGoldenTreeHarvestItemNum, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldenTreeHarvestItemNum::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldenTreePropUniqueId
// 0x0010 (0x0010 - 0x0000)
struct LCommonConstantValues_GetGoldenTreePropUniqueId final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldenTreePropUniqueId) == 0x000008, "Wrong alignment on LCommonConstantValues_GetGoldenTreePropUniqueId");
static_assert(sizeof(LCommonConstantValues_GetGoldenTreePropUniqueId) == 0x000010, "Wrong size on LCommonConstantValues_GetGoldenTreePropUniqueId");
static_assert(offsetof(LCommonConstantValues_GetGoldenTreePropUniqueId, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldenTreePropUniqueId::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldenTreeTimeToHarvesting
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetGoldenTreeTimeToHarvesting final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldenTreeTimeToHarvesting) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGoldenTreeTimeToHarvesting");
static_assert(sizeof(LCommonConstantValues_GetGoldenTreeTimeToHarvesting) == 0x000004, "Wrong size on LCommonConstantValues_GetGoldenTreeTimeToHarvesting");
static_assert(offsetof(LCommonConstantValues_GetGoldenTreeTimeToHarvesting, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldenTreeTimeToHarvesting::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGoldStackLimit
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetGoldStackLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGoldStackLimit) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGoldStackLimit");
static_assert(sizeof(LCommonConstantValues_GetGoldStackLimit) == 0x000004, "Wrong size on LCommonConstantValues_GetGoldStackLimit");
static_assert(offsetof(LCommonConstantValues_GetGoldStackLimit, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGoldStackLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGramophoneAttenuationAsset
// 0x0028 (0x0028 - 0x0000)
struct LCommonConstantValues_GetGramophoneAttenuationAsset final
{
public:
	TSoftObjectPtr<class USoundAttenuation>       ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGramophoneAttenuationAsset) == 0x000008, "Wrong alignment on LCommonConstantValues_GetGramophoneAttenuationAsset");
static_assert(sizeof(LCommonConstantValues_GetGramophoneAttenuationAsset) == 0x000028, "Wrong size on LCommonConstantValues_GetGramophoneAttenuationAsset");
static_assert(offsetof(LCommonConstantValues_GetGramophoneAttenuationAsset, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGramophoneAttenuationAsset::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetGuardParryCooltime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetGuardParryCooltime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetGuardParryCooltime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetGuardParryCooltime");
static_assert(sizeof(LCommonConstantValues_GetGuardParryCooltime) == 0x000004, "Wrong size on LCommonConstantValues_GetGuardParryCooltime");
static_assert(offsetof(LCommonConstantValues_GetGuardParryCooltime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetGuardParryCooltime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Advance
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance");
static_assert(sizeof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance) == 0x000008, "Wrong size on LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance");
static_assert(offsetof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Clear
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear");
static_assert(sizeof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear) == 0x000008, "Wrong size on LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear");
static_assert(offsetof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Motifvity
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity");
static_assert(sizeof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity) == 0x000008, "Wrong size on LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity");
static_assert(offsetof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Technique
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique");
static_assert(sizeof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique) == 0x000008, "Wrong size on LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique");
static_assert(offsetof(LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleCorrectionChange_UnderLimit
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetHandleCorrectionChange_UnderLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleCorrectionChange_UnderLimit) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleCorrectionChange_UnderLimit");
static_assert(sizeof(LCommonConstantValues_GetHandleCorrectionChange_UnderLimit) == 0x000004, "Wrong size on LCommonConstantValues_GetHandleCorrectionChange_UnderLimit");
static_assert(offsetof(LCommonConstantValues_GetHandleCorrectionChange_UnderLimit, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleCorrectionChange_UnderLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleCorrectionChange_UpperStackLimit
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit");
static_assert(sizeof(LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit) == 0x000004, "Wrong size on LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit");
static_assert(offsetof(LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleNeedStatLackAtkRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetHandleNeedStatLackAtkRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleNeedStatLackAtkRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleNeedStatLackAtkRatio");
static_assert(sizeof(LCommonConstantValues_GetHandleNeedStatLackAtkRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetHandleNeedStatLackAtkRatio");
static_assert(offsetof(LCommonConstantValues_GetHandleNeedStatLackAtkRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleNeedStatLackAtkRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHandleNeedStatLackGuardSaveStaminaRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio");
static_assert(sizeof(LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio");
static_assert(offsetof(LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHelpMateAwakeItem
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHelpMateAwakeItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHelpMateAwakeItem) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHelpMateAwakeItem");
static_assert(sizeof(LCommonConstantValues_GetHelpMateAwakeItem) == 0x000008, "Wrong size on LCommonConstantValues_GetHelpMateAwakeItem");
static_assert(offsetof(LCommonConstantValues_GetHelpMateAwakeItem, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHelpMateAwakeItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHelpMateDespawnWorldTrigger
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHelpMateDespawnWorldTrigger final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHelpMateDespawnWorldTrigger) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHelpMateDespawnWorldTrigger");
static_assert(sizeof(LCommonConstantValues_GetHelpMateDespawnWorldTrigger) == 0x000008, "Wrong size on LCommonConstantValues_GetHelpMateDespawnWorldTrigger");
static_assert(offsetof(LCommonConstantValues_GetHelpMateDespawnWorldTrigger, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHelpMateDespawnWorldTrigger::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHelpMateFailMsg
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHelpMateFailMsg final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHelpMateFailMsg) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHelpMateFailMsg");
static_assert(sizeof(LCommonConstantValues_GetHelpMateFailMsg) == 0x000008, "Wrong size on LCommonConstantValues_GetHelpMateFailMsg");
static_assert(offsetof(LCommonConstantValues_GetHelpMateFailMsg, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHelpMateFailMsg::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHelpMateSuccessMsg
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHelpMateSuccessMsg final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHelpMateSuccessMsg) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHelpMateSuccessMsg");
static_assert(sizeof(LCommonConstantValues_GetHelpMateSuccessMsg) == 0x000008, "Wrong size on LCommonConstantValues_GetHelpMateSuccessMsg");
static_assert(offsetof(LCommonConstantValues_GetHelpMateSuccessMsg, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHelpMateSuccessMsg::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHitBoom_Projectile_Code_Name
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHitBoom_Projectile_Code_Name final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHitBoom_Projectile_Code_Name) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHitBoom_Projectile_Code_Name");
static_assert(sizeof(LCommonConstantValues_GetHitBoom_Projectile_Code_Name) == 0x000008, "Wrong size on LCommonConstantValues_GetHitBoom_Projectile_Code_Name");
static_assert(offsetof(LCommonConstantValues_GetHitBoom_Projectile_Code_Name, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHitBoom_Projectile_Code_Name::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHotelTeleportActivateCondition1
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHotelTeleportActivateCondition1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHotelTeleportActivateCondition1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHotelTeleportActivateCondition1");
static_assert(sizeof(LCommonConstantValues_GetHotelTeleportActivateCondition1) == 0x000008, "Wrong size on LCommonConstantValues_GetHotelTeleportActivateCondition1");
static_assert(offsetof(LCommonConstantValues_GetHotelTeleportActivateCondition1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHotelTeleportActivateCondition1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHotelTeleportActivateCondition2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHotelTeleportActivateCondition2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHotelTeleportActivateCondition2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHotelTeleportActivateCondition2");
static_assert(sizeof(LCommonConstantValues_GetHotelTeleportActivateCondition2) == 0x000008, "Wrong size on LCommonConstantValues_GetHotelTeleportActivateCondition2");
static_assert(offsetof(LCommonConstantValues_GetHotelTeleportActivateCondition2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHotelTeleportActivateCondition2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHotelTosionCoilCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHotelTosionCoilCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHotelTosionCoilCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHotelTosionCoilCodeName");
static_assert(sizeof(LCommonConstantValues_GetHotelTosionCoilCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetHotelTosionCoilCodeName");
static_assert(offsetof(LCommonConstantValues_GetHotelTosionCoilCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHotelTosionCoilCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHotelTosionCoilCodeName2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHotelTosionCoilCodeName2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHotelTosionCoilCodeName2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHotelTosionCoilCodeName2");
static_assert(sizeof(LCommonConstantValues_GetHotelTosionCoilCodeName2) == 0x000008, "Wrong size on LCommonConstantValues_GetHotelTosionCoilCodeName2");
static_assert(offsetof(LCommonConstantValues_GetHotelTosionCoilCodeName2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHotelTosionCoilCodeName2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHumanityGain_HighStart
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetHumanityGain_HighStart final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHumanityGain_HighStart) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHumanityGain_HighStart");
static_assert(sizeof(LCommonConstantValues_GetHumanityGain_HighStart) == 0x000004, "Wrong size on LCommonConstantValues_GetHumanityGain_HighStart");
static_assert(offsetof(LCommonConstantValues_GetHumanityGain_HighStart, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHumanityGain_HighStart::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHumanityGainSkill_High
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHumanityGainSkill_High final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHumanityGainSkill_High) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHumanityGainSkill_High");
static_assert(sizeof(LCommonConstantValues_GetHumanityGainSkill_High) == 0x000008, "Wrong size on LCommonConstantValues_GetHumanityGainSkill_High");
static_assert(offsetof(LCommonConstantValues_GetHumanityGainSkill_High, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHumanityGainSkill_High::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHumanityGainSkill_Low
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetHumanityGainSkill_Low final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHumanityGainSkill_Low) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHumanityGainSkill_Low");
static_assert(sizeof(LCommonConstantValues_GetHumanityGainSkill_Low) == 0x000008, "Wrong size on LCommonConstantValues_GetHumanityGainSkill_Low");
static_assert(offsetof(LCommonConstantValues_GetHumanityGainSkill_Low, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHumanityGainSkill_Low::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetHumanityMax
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetHumanityMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetHumanityMax) == 0x000004, "Wrong alignment on LCommonConstantValues_GetHumanityMax");
static_assert(sizeof(LCommonConstantValues_GetHumanityMax) == 0x000004, "Wrong size on LCommonConstantValues_GetHumanityMax");
static_assert(offsetof(LCommonConstantValues_GetHumanityMax, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetHumanityMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetInitWeatherCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetInitWeatherCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetInitWeatherCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetInitWeatherCodeName");
static_assert(sizeof(LCommonConstantValues_GetInitWeatherCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetInitWeatherCodeName");
static_assert(offsetof(LCommonConstantValues_GetInitWeatherCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetInitWeatherCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetIntroSequenceCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetIntroSequenceCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetIntroSequenceCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetIntroSequenceCodeName");
static_assert(sizeof(LCommonConstantValues_GetIntroSequenceCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetIntroSequenceCodeName");
static_assert(offsetof(LCommonConstantValues_GetIntroSequenceCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetIntroSequenceCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetInventoryMaxBladeSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetInventoryMaxBladeSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetInventoryMaxBladeSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetInventoryMaxBladeSlot");
static_assert(sizeof(LCommonConstantValues_GetInventoryMaxBladeSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetInventoryMaxBladeSlot");
static_assert(offsetof(LCommonConstantValues_GetInventoryMaxBladeSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetInventoryMaxBladeSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetInventoryMaxGearSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetInventoryMaxGearSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetInventoryMaxGearSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetInventoryMaxGearSlot");
static_assert(sizeof(LCommonConstantValues_GetInventoryMaxGearSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetInventoryMaxGearSlot");
static_assert(offsetof(LCommonConstantValues_GetInventoryMaxGearSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetInventoryMaxGearSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetInventoryMaxHandleSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetInventoryMaxHandleSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetInventoryMaxHandleSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetInventoryMaxHandleSlot");
static_assert(sizeof(LCommonConstantValues_GetInventoryMaxHandleSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetInventoryMaxHandleSlot");
static_assert(offsetof(LCommonConstantValues_GetInventoryMaxHandleSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetInventoryMaxHandleSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetInventoryMaxPartsSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetInventoryMaxPartsSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetInventoryMaxPartsSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetInventoryMaxPartsSlot");
static_assert(sizeof(LCommonConstantValues_GetInventoryMaxPartsSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetInventoryMaxPartsSlot");
static_assert(offsetof(LCommonConstantValues_GetInventoryMaxPartsSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetInventoryMaxPartsSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetInventoryMaxWeaponSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetInventoryMaxWeaponSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetInventoryMaxWeaponSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetInventoryMaxWeaponSlot");
static_assert(sizeof(LCommonConstantValues_GetInventoryMaxWeaponSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetInventoryMaxWeaponSlot");
static_assert(offsetof(LCommonConstantValues_GetInventoryMaxWeaponSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetInventoryMaxWeaponSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetItemValueGradeCheck
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetItemValueGradeCheck final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetItemValueGradeCheck) == 0x000004, "Wrong alignment on LCommonConstantValues_GetItemValueGradeCheck");
static_assert(sizeof(LCommonConstantValues_GetItemValueGradeCheck) == 0x000004, "Wrong size on LCommonConstantValues_GetItemValueGradeCheck");
static_assert(offsetof(LCommonConstantValues_GetItemValueGradeCheck, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetItemValueGradeCheck::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetLevelResetNeedItem
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetLevelResetNeedItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetLevelResetNeedItem) == 0x000004, "Wrong alignment on LCommonConstantValues_GetLevelResetNeedItem");
static_assert(sizeof(LCommonConstantValues_GetLevelResetNeedItem) == 0x000008, "Wrong size on LCommonConstantValues_GetLevelResetNeedItem");
static_assert(offsetof(LCommonConstantValues_GetLevelResetNeedItem, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetLevelResetNeedItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetLevelResetNeedItemNum
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetLevelResetNeedItemNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetLevelResetNeedItemNum) == 0x000004, "Wrong alignment on LCommonConstantValues_GetLevelResetNeedItemNum");
static_assert(sizeof(LCommonConstantValues_GetLevelResetNeedItemNum) == 0x000004, "Wrong size on LCommonConstantValues_GetLevelResetNeedItemNum");
static_assert(offsetof(LCommonConstantValues_GetLevelResetNeedItemNum, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetLevelResetNeedItemNum::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetLieEffectSequenceCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetLieEffectSequenceCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetLieEffectSequenceCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetLieEffectSequenceCodeName");
static_assert(sizeof(LCommonConstantValues_GetLieEffectSequenceCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetLieEffectSequenceCodeName");
static_assert(offsetof(LCommonConstantValues_GetLieEffectSequenceCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetLieEffectSequenceCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetLiftInteractionFailMessage
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetLiftInteractionFailMessage final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetLiftInteractionFailMessage) == 0x000004, "Wrong alignment on LCommonConstantValues_GetLiftInteractionFailMessage");
static_assert(sizeof(LCommonConstantValues_GetLiftInteractionFailMessage) == 0x000008, "Wrong size on LCommonConstantValues_GetLiftInteractionFailMessage");
static_assert(offsetof(LCommonConstantValues_GetLiftInteractionFailMessage, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetLiftInteractionFailMessage::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetLockerRefillMsgOn
// 0x0001 (0x0001 - 0x0000)
struct LCommonConstantValues_GetLockerRefillMsgOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetLockerRefillMsgOn) == 0x000001, "Wrong alignment on LCommonConstantValues_GetLockerRefillMsgOn");
static_assert(sizeof(LCommonConstantValues_GetLockerRefillMsgOn) == 0x000001, "Wrong size on LCommonConstantValues_GetLockerRefillMsgOn");
static_assert(offsetof(LCommonConstantValues_GetLockerRefillMsgOn, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetLockerRefillMsgOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetMaxLevelStationStargazer
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetMaxLevelStationStargazer final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetMaxLevelStationStargazer) == 0x000004, "Wrong alignment on LCommonConstantValues_GetMaxLevelStationStargazer");
static_assert(sizeof(LCommonConstantValues_GetMaxLevelStationStargazer) == 0x000004, "Wrong size on LCommonConstantValues_GetMaxLevelStationStargazer");
static_assert(offsetof(LCommonConstantValues_GetMaxLevelStationStargazer, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetMaxLevelStationStargazer::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetMaxLevelStationStargazerCondition
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetMaxLevelStationStargazerCondition final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetMaxLevelStationStargazerCondition) == 0x000004, "Wrong alignment on LCommonConstantValues_GetMaxLevelStationStargazerCondition");
static_assert(sizeof(LCommonConstantValues_GetMaxLevelStationStargazerCondition) == 0x000008, "Wrong size on LCommonConstantValues_GetMaxLevelStationStargazerCondition");
static_assert(offsetof(LCommonConstantValues_GetMaxLevelStationStargazerCondition, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetMaxLevelStationStargazerCondition::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetMonadBuffMainItem
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetMonadBuffMainItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetMonadBuffMainItem) == 0x000004, "Wrong alignment on LCommonConstantValues_GetMonadBuffMainItem");
static_assert(sizeof(LCommonConstantValues_GetMonadBuffMainItem) == 0x000008, "Wrong size on LCommonConstantValues_GetMonadBuffMainItem");
static_assert(offsetof(LCommonConstantValues_GetMonadBuffMainItem, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetMonadBuffMainItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetMonasterySimonDieCheck
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetMonasterySimonDieCheck final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetMonasterySimonDieCheck) == 0x000004, "Wrong alignment on LCommonConstantValues_GetMonasterySimonDieCheck");
static_assert(sizeof(LCommonConstantValues_GetMonasterySimonDieCheck) == 0x000008, "Wrong size on LCommonConstantValues_GetMonasterySimonDieCheck");
static_assert(offsetof(LCommonConstantValues_GetMonasterySimonDieCheck, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetMonasterySimonDieCheck::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetMonologueRepeatTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetMonologueRepeatTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetMonologueRepeatTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetMonologueRepeatTime");
static_assert(sizeof(LCommonConstantValues_GetMonologueRepeatTime) == 0x000004, "Wrong size on LCommonConstantValues_GetMonologueRepeatTime");
static_assert(offsetof(LCommonConstantValues_GetMonologueRepeatTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetMonologueRepeatTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetMoviePOrganOpen
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetMoviePOrganOpen final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetMoviePOrganOpen) == 0x000004, "Wrong alignment on LCommonConstantValues_GetMoviePOrganOpen");
static_assert(sizeof(LCommonConstantValues_GetMoviePOrganOpen) == 0x000008, "Wrong size on LCommonConstantValues_GetMoviePOrganOpen");
static_assert(offsetof(LCommonConstantValues_GetMoviePOrganOpen, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetMoviePOrganOpen::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNGP_belt_slot_clear
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetNGP_belt_slot_clear final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNGP_belt_slot_clear) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNGP_belt_slot_clear");
static_assert(sizeof(LCommonConstantValues_GetNGP_belt_slot_clear) == 0x000008, "Wrong size on LCommonConstantValues_GetNGP_belt_slot_clear");
static_assert(offsetof(LCommonConstantValues_GetNGP_belt_slot_clear, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNGP_belt_slot_clear::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNoseStaffLargeBLD
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetNoseStaffLargeBLD final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNoseStaffLargeBLD) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNoseStaffLargeBLD");
static_assert(sizeof(LCommonConstantValues_GetNoseStaffLargeBLD) == 0x000008, "Wrong size on LCommonConstantValues_GetNoseStaffLargeBLD");
static_assert(offsetof(LCommonConstantValues_GetNoseStaffLargeBLD, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNoseStaffLargeBLD::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNoseStaffLargeHND
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetNoseStaffLargeHND final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNoseStaffLargeHND) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNoseStaffLargeHND");
static_assert(sizeof(LCommonConstantValues_GetNoseStaffLargeHND) == 0x000008, "Wrong size on LCommonConstantValues_GetNoseStaffLargeHND");
static_assert(offsetof(LCommonConstantValues_GetNoseStaffLargeHND, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNoseStaffLargeHND::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNoseStaffMediumBLD
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetNoseStaffMediumBLD final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNoseStaffMediumBLD) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNoseStaffMediumBLD");
static_assert(sizeof(LCommonConstantValues_GetNoseStaffMediumBLD) == 0x000008, "Wrong size on LCommonConstantValues_GetNoseStaffMediumBLD");
static_assert(offsetof(LCommonConstantValues_GetNoseStaffMediumBLD, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNoseStaffMediumBLD::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNoseStaffMediumHND
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetNoseStaffMediumHND final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNoseStaffMediumHND) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNoseStaffMediumHND");
static_assert(sizeof(LCommonConstantValues_GetNoseStaffMediumHND) == 0x000008, "Wrong size on LCommonConstantValues_GetNoseStaffMediumHND");
static_assert(offsetof(LCommonConstantValues_GetNoseStaffMediumHND, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNoseStaffMediumHND::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNoseStaffSmallHND
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetNoseStaffSmallHND final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNoseStaffSmallHND) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNoseStaffSmallHND");
static_assert(sizeof(LCommonConstantValues_GetNoseStaffSmallHND) == 0x000008, "Wrong size on LCommonConstantValues_GetNoseStaffSmallHND");
static_assert(offsetof(LCommonConstantValues_GetNoseStaffSmallHND, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNoseStaffSmallHND::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetNpcMenuOpenDelay
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetNpcMenuOpenDelay final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetNpcMenuOpenDelay) == 0x000004, "Wrong alignment on LCommonConstantValues_GetNpcMenuOpenDelay");
static_assert(sizeof(LCommonConstantValues_GetNpcMenuOpenDelay) == 0x000004, "Wrong size on LCommonConstantValues_GetNpcMenuOpenDelay");
static_assert(offsetof(LCommonConstantValues_GetNpcMenuOpenDelay, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetNpcMenuOpenDelay::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetOpeningMovieCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetOpeningMovieCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetOpeningMovieCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetOpeningMovieCodeName");
static_assert(sizeof(LCommonConstantValues_GetOpeningMovieCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetOpeningMovieCodeName");
static_assert(offsetof(LCommonConstantValues_GetOpeningMovieCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetOpeningMovieCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeBld1
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeBld1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeBld1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeBld1");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeBld1) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeBld1");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeBld1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeBld1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeBld2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeBld2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeBld2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeBld2");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeBld2) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeBld2");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeBld2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeBld2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeBld3
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeBld3 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeBld3) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeBld3");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeBld3) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeBld3");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeBld3, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeBld3::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeHnd1
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeHnd1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeHnd1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeHnd1");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeHnd1) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeHnd1");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeHnd1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeHnd1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeHnd2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeHnd2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeHnd2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeHnd2");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeHnd2) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeHnd2");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeHnd2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeHnd2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeHnd3
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeHnd3 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeHnd3) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeHnd3");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeHnd3) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeHnd3");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeHnd3, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeHnd3::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeStat1
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeStat1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeStat1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeStat1");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeStat1) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeStat1");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeStat1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeStat1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeStat2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeStat2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeStat2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeStat2");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeStat2) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeStat2");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeStat2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeStat2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCActionTypeStat3
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCActionTypeStat3 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCActionTypeStat3) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCActionTypeStat3");
static_assert(sizeof(LCommonConstantValues_GetPCActionTypeStat3) == 0x000008, "Wrong size on LCommonConstantValues_GetPCActionTypeStat3");
static_assert(offsetof(LCommonConstantValues_GetPCActionTypeStat3, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCActionTypeStat3::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCDialogMinTurnAngle
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPCDialogMinTurnAngle final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCDialogMinTurnAngle) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCDialogMinTurnAngle");
static_assert(sizeof(LCommonConstantValues_GetPCDialogMinTurnAngle) == 0x000004, "Wrong size on LCommonConstantValues_GetPCDialogMinTurnAngle");
static_assert(offsetof(LCommonConstantValues_GetPCDialogMinTurnAngle, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCDialogMinTurnAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCDialogRotateTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPCDialogRotateTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCDialogRotateTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCDialogRotateTime");
static_assert(sizeof(LCommonConstantValues_GetPCDialogRotateTime) == 0x000004, "Wrong size on LCommonConstantValues_GetPCDialogRotateTime");
static_assert(offsetof(LCommonConstantValues_GetPCDialogRotateTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCDialogRotateTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCInitializeSet1
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCInitializeSet1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCInitializeSet1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCInitializeSet1");
static_assert(sizeof(LCommonConstantValues_GetPCInitializeSet1) == 0x000008, "Wrong size on LCommonConstantValues_GetPCInitializeSet1");
static_assert(offsetof(LCommonConstantValues_GetPCInitializeSet1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCInitializeSet1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCInitializeSet2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCInitializeSet2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCInitializeSet2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCInitializeSet2");
static_assert(sizeof(LCommonConstantValues_GetPCInitializeSet2) == 0x000008, "Wrong size on LCommonConstantValues_GetPCInitializeSet2");
static_assert(offsetof(LCommonConstantValues_GetPCInitializeSet2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCInitializeSet2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCInitializeSet3
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCInitializeSet3 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCInitializeSet3) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCInitializeSet3");
static_assert(sizeof(LCommonConstantValues_GetPCInitializeSet3) == 0x000008, "Wrong size on LCommonConstantValues_GetPCInitializeSet3");
static_assert(offsetof(LCommonConstantValues_GetPCInitializeSet3, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCInitializeSet3::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCInitializeSet_Factory1
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCInitializeSet_Factory1 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCInitializeSet_Factory1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCInitializeSet_Factory1");
static_assert(sizeof(LCommonConstantValues_GetPCInitializeSet_Factory1) == 0x000008, "Wrong size on LCommonConstantValues_GetPCInitializeSet_Factory1");
static_assert(offsetof(LCommonConstantValues_GetPCInitializeSet_Factory1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCInitializeSet_Factory1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCInitializeSet_Factory2
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCInitializeSet_Factory2 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCInitializeSet_Factory2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCInitializeSet_Factory2");
static_assert(sizeof(LCommonConstantValues_GetPCInitializeSet_Factory2) == 0x000008, "Wrong size on LCommonConstantValues_GetPCInitializeSet_Factory2");
static_assert(offsetof(LCommonConstantValues_GetPCInitializeSet_Factory2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCInitializeSet_Factory2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPCInitializeSet_Factory3
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPCInitializeSet_Factory3 final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPCInitializeSet_Factory3) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPCInitializeSet_Factory3");
static_assert(sizeof(LCommonConstantValues_GetPCInitializeSet_Factory3) == 0x000008, "Wrong size on LCommonConstantValues_GetPCInitializeSet_Factory3");
static_assert(offsetof(LCommonConstantValues_GetPCInitializeSet_Factory3, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPCInitializeSet_Factory3::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPlayRateExponentOver
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPlayRateExponentOver final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPlayRateExponentOver) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPlayRateExponentOver");
static_assert(sizeof(LCommonConstantValues_GetPlayRateExponentOver) == 0x000004, "Wrong size on LCommonConstantValues_GetPlayRateExponentOver");
static_assert(offsetof(LCommonConstantValues_GetPlayRateExponentOver, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPlayRateExponentOver::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPlayRateExponentUnder
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPlayRateExponentUnder final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPlayRateExponentUnder) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPlayRateExponentUnder");
static_assert(sizeof(LCommonConstantValues_GetPlayRateExponentUnder) == 0x000004, "Wrong size on LCommonConstantValues_GetPlayRateExponentUnder");
static_assert(offsetof(LCommonConstantValues_GetPlayRateExponentUnder, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPlayRateExponentUnder::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPlayRecordCheckTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPlayRecordCheckTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPlayRecordCheckTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPlayRecordCheckTime");
static_assert(sizeof(LCommonConstantValues_GetPlayRecordCheckTime) == 0x000004, "Wrong size on LCommonConstantValues_GetPlayRecordCheckTime");
static_assert(offsetof(LCommonConstantValues_GetPlayRecordCheckTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPlayRecordCheckTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevel2RequiredSynergyCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevel3RequiredSynergyCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevel4RequiredSynergyCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevel5RequiredSynergyCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevel6RequiredSynergyCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevel7RequiredSynergyCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevelLimitNewGamePlus0
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0 final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevelLimitNewGamePlus1
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1 final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemLevelLimitNewGamePlus2
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2 final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2");
static_assert(sizeof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2");
static_assert(offsetof(LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPSystemMaxLevel
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetPSystemMaxLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPSystemMaxLevel) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPSystemMaxLevel");
static_assert(sizeof(LCommonConstantValues_GetPSystemMaxLevel) == 0x000004, "Wrong size on LCommonConstantValues_GetPSystemMaxLevel");
static_assert(offsetof(LCommonConstantValues_GetPSystemMaxLevel, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPSystemMaxLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPulseItemBuffCodenameOnBreaked
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked");
static_assert(sizeof(LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked) == 0x000008, "Wrong size on LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked");
static_assert(offsetof(LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetPulseItemCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetPulseItemCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetPulseItemCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetPulseItemCodeName");
static_assert(sizeof(LCommonConstantValues_GetPulseItemCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetPulseItemCodeName");
static_assert(offsetof(LCommonConstantValues_GetPulseItemCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetPulseItemCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetQuartzItemCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetQuartzItemCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetQuartzItemCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetQuartzItemCodeName");
static_assert(sizeof(LCommonConstantValues_GetQuartzItemCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetQuartzItemCodeName");
static_assert(offsetof(LCommonConstantValues_GetQuartzItemCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetQuartzItemCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetQuartzSystemLevelUpItemCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName");
static_assert(sizeof(LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName");
static_assert(offsetof(LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetQuartzSystemResetItemCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetQuartzSystemResetItemCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetQuartzSystemResetItemCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetQuartzSystemResetItemCodeName");
static_assert(sizeof(LCommonConstantValues_GetQuartzSystemResetItemCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetQuartzSystemResetItemCodeName");
static_assert(offsetof(LCommonConstantValues_GetQuartzSystemResetItemCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetQuartzSystemResetItemCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetQuartzSystemResetItemNum
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetQuartzSystemResetItemNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetQuartzSystemResetItemNum) == 0x000004, "Wrong alignment on LCommonConstantValues_GetQuartzSystemResetItemNum");
static_assert(sizeof(LCommonConstantValues_GetQuartzSystemResetItemNum) == 0x000004, "Wrong size on LCommonConstantValues_GetQuartzSystemResetItemNum");
static_assert(offsetof(LCommonConstantValues_GetQuartzSystemResetItemNum, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetQuartzSystemResetItemNum::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetRaxasiaShieldPartsName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetRaxasiaShieldPartsName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetRaxasiaShieldPartsName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetRaxasiaShieldPartsName");
static_assert(sizeof(LCommonConstantValues_GetRaxasiaShieldPartsName) == 0x000008, "Wrong size on LCommonConstantValues_GetRaxasiaShieldPartsName");
static_assert(offsetof(LCommonConstantValues_GetRaxasiaShieldPartsName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetRaxasiaShieldPartsName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetReduceFPOnFrenzy
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetReduceFPOnFrenzy final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetReduceFPOnFrenzy) == 0x000004, "Wrong alignment on LCommonConstantValues_GetReduceFPOnFrenzy");
static_assert(sizeof(LCommonConstantValues_GetReduceFPOnFrenzy) == 0x000004, "Wrong size on LCommonConstantValues_GetReduceFPOnFrenzy");
static_assert(offsetof(LCommonConstantValues_GetReduceFPOnFrenzy, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetReduceFPOnFrenzy::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetReduceFPOnFrenzyInterval
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetReduceFPOnFrenzyInterval final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetReduceFPOnFrenzyInterval) == 0x000004, "Wrong alignment on LCommonConstantValues_GetReduceFPOnFrenzyInterval");
static_assert(sizeof(LCommonConstantValues_GetReduceFPOnFrenzyInterval) == 0x000004, "Wrong size on LCommonConstantValues_GetReduceFPOnFrenzyInterval");
static_assert(offsetof(LCommonConstantValues_GetReduceFPOnFrenzyInterval, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetReduceFPOnFrenzyInterval::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetRegainhpMakeRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetRegainhpMakeRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetRegainhpMakeRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetRegainhpMakeRatio");
static_assert(sizeof(LCommonConstantValues_GetRegainhpMakeRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetRegainhpMakeRatio");
static_assert(offsetof(LCommonConstantValues_GetRegainhpMakeRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetRegainhpMakeRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetResetItemSlotPosition
// 0x0001 (0x0001 - 0x0000)
struct LCommonConstantValues_GetResetItemSlotPosition final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetResetItemSlotPosition) == 0x000001, "Wrong alignment on LCommonConstantValues_GetResetItemSlotPosition");
static_assert(sizeof(LCommonConstantValues_GetResetItemSlotPosition) == 0x000001, "Wrong size on LCommonConstantValues_GetResetItemSlotPosition");
static_assert(offsetof(LCommonConstantValues_GetResetItemSlotPosition, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetResetItemSlotPosition::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetResurrection_Abnormal_Code_Name
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetResurrection_Abnormal_Code_Name final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetResurrection_Abnormal_Code_Name) == 0x000004, "Wrong alignment on LCommonConstantValues_GetResurrection_Abnormal_Code_Name");
static_assert(sizeof(LCommonConstantValues_GetResurrection_Abnormal_Code_Name) == 0x000008, "Wrong size on LCommonConstantValues_GetResurrection_Abnormal_Code_Name");
static_assert(offsetof(LCommonConstantValues_GetResurrection_Abnormal_Code_Name, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetResurrection_Abnormal_Code_Name::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSellingPriceRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSellingPriceRatio final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSellingPriceRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSellingPriceRatio");
static_assert(sizeof(LCommonConstantValues_GetSellingPriceRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetSellingPriceRatio");
static_assert(offsetof(LCommonConstantValues_GetSellingPriceRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSellingPriceRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSequenceHotelBICodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetSequenceHotelBICodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSequenceHotelBICodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSequenceHotelBICodeName");
static_assert(sizeof(LCommonConstantValues_GetSequenceHotelBICodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetSequenceHotelBICodeName");
static_assert(offsetof(LCommonConstantValues_GetSequenceHotelBICodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSequenceHotelBICodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessBadAttackMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessBadAttackMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessBadAttackMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessBadAttackMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessBadAttackMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessBadAttackMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessBadAttackMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessBadAttackMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessBadDestructionMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessBadDestructionMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessBadDestructionMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessBadDestructionMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessBadDestructionMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessBadDestructionMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessBadDestructionMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessBadDestructionMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessBrokenAttackMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessBrokenAttackMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessBrokenAttackMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessBrokenAttackMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessBrokenAttackMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessBrokenAttackMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessBrokenAttackMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessBrokenAttackMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessBrokenDestructionMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessBrokenDestructionMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessBrokenDestructionMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessBrokenDestructionMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessBrokenDestructionMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessBrokenDestructionMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessBrokenDestructionMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessBrokenDestructionMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessFineAttackMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessFineAttackMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessFineAttackMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessFineAttackMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessFineAttackMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessFineAttackMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessFineAttackMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessFineAttackMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessFineDestructionMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessFineDestructionMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessFineDestructionMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessFineDestructionMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessFineDestructionMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessFineDestructionMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessFineDestructionMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessFineDestructionMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessNormalAttackMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessNormalAttackMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessNormalAttackMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessNormalAttackMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessNormalAttackMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessNormalAttackMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessNormalAttackMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessNormalAttackMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessNormalDestructionMod
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessNormalDestructionMod final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessNormalDestructionMod) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessNormalDestructionMod");
static_assert(sizeof(LCommonConstantValues_GetSharpnessNormalDestructionMod) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessNormalDestructionMod");
static_assert(offsetof(LCommonConstantValues_GetSharpnessNormalDestructionMod, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessNormalDestructionMod::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSharpnessReduceValue
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSharpnessReduceValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSharpnessReduceValue) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSharpnessReduceValue");
static_assert(sizeof(LCommonConstantValues_GetSharpnessReduceValue) == 0x000004, "Wrong size on LCommonConstantValues_GetSharpnessReduceValue");
static_assert(offsetof(LCommonConstantValues_GetSharpnessReduceValue, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSharpnessReduceValue::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetShopPurchaseLimit
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetShopPurchaseLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetShopPurchaseLimit) == 0x000004, "Wrong alignment on LCommonConstantValues_GetShopPurchaseLimit");
static_assert(sizeof(LCommonConstantValues_GetShopPurchaseLimit) == 0x000004, "Wrong size on LCommonConstantValues_GetShopPurchaseLimit");
static_assert(offsetof(LCommonConstantValues_GetShopPurchaseLimit, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetShopPurchaseLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSkillHitDefenceExponent
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSkillHitDefenceExponent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSkillHitDefenceExponent) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSkillHitDefenceExponent");
static_assert(sizeof(LCommonConstantValues_GetSkillHitDefenceExponent) == 0x000004, "Wrong size on LCommonConstantValues_GetSkillHitDefenceExponent");
static_assert(offsetof(LCommonConstantValues_GetSkillHitDefenceExponent, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSkillHitDefenceExponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSlavearmItemAlterUseType
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetSlavearmItemAlterUseType final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSlavearmItemAlterUseType) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSlavearmItemAlterUseType");
static_assert(sizeof(LCommonConstantValues_GetSlavearmItemAlterUseType) == 0x000008, "Wrong size on LCommonConstantValues_GetSlavearmItemAlterUseType");
static_assert(offsetof(LCommonConstantValues_GetSlavearmItemAlterUseType, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSlavearmItemAlterUseType::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSlaveArmReinforcementResetItemCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName");
static_assert(sizeof(LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName");
static_assert(offsetof(LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSlaveArmReinforcementResetItemNum
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSlaveArmReinforcementResetItemNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSlaveArmReinforcementResetItemNum) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSlaveArmReinforcementResetItemNum");
static_assert(sizeof(LCommonConstantValues_GetSlaveArmReinforcementResetItemNum) == 0x000004, "Wrong size on LCommonConstantValues_GetSlaveArmReinforcementResetItemNum");
static_assert(offsetof(LCommonConstantValues_GetSlaveArmReinforcementResetItemNum, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSlaveArmReinforcementResetItemNum::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSprintExhaustTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSprintExhaustTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSprintExhaustTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSprintExhaustTime");
static_assert(sizeof(LCommonConstantValues_GetSprintExhaustTime) == 0x000004, "Wrong size on LCommonConstantValues_GetSprintExhaustTime");
static_assert(offsetof(LCommonConstantValues_GetSprintExhaustTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSprintExhaustTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSprintSpeedRatioMax
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSprintSpeedRatioMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSprintSpeedRatioMax) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSprintSpeedRatioMax");
static_assert(sizeof(LCommonConstantValues_GetSprintSpeedRatioMax) == 0x000004, "Wrong size on LCommonConstantValues_GetSprintSpeedRatioMax");
static_assert(offsetof(LCommonConstantValues_GetSprintSpeedRatioMax, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSprintSpeedRatioMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSprintSpeedRatioMin
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSprintSpeedRatioMin final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSprintSpeedRatioMin) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSprintSpeedRatioMin");
static_assert(sizeof(LCommonConstantValues_GetSprintSpeedRatioMin) == 0x000004, "Wrong size on LCommonConstantValues_GetSprintSpeedRatioMin");
static_assert(offsetof(LCommonConstantValues_GetSprintSpeedRatioMin, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSprintSpeedRatioMin::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStaminaConsumeRatioExponentOver
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetStaminaConsumeRatioExponentOver final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStaminaConsumeRatioExponentOver) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStaminaConsumeRatioExponentOver");
static_assert(sizeof(LCommonConstantValues_GetStaminaConsumeRatioExponentOver) == 0x000004, "Wrong size on LCommonConstantValues_GetStaminaConsumeRatioExponentOver");
static_assert(offsetof(LCommonConstantValues_GetStaminaConsumeRatioExponentOver, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStaminaConsumeRatioExponentOver::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStaminaConsumeRatioExponentUnder
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetStaminaConsumeRatioExponentUnder final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStaminaConsumeRatioExponentUnder) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStaminaConsumeRatioExponentUnder");
static_assert(sizeof(LCommonConstantValues_GetStaminaConsumeRatioExponentUnder) == 0x000004, "Wrong size on LCommonConstantValues_GetStaminaConsumeRatioExponentUnder");
static_assert(offsetof(LCommonConstantValues_GetStaminaConsumeRatioExponentUnder, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStaminaConsumeRatioExponentUnder::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStealthAbnormalCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetStealthAbnormalCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStealthAbnormalCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStealthAbnormalCodeName");
static_assert(sizeof(LCommonConstantValues_GetStealthAbnormalCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetStealthAbnormalCodeName");
static_assert(offsetof(LCommonConstantValues_GetStealthAbnormalCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStealthAbnormalCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStealthImmediatelyAbnormalCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName");
static_assert(sizeof(LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName");
static_assert(offsetof(LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStealthTotallyImmediatelyAbnormalCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName");
static_assert(sizeof(LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName");
static_assert(offsetof(LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStorageMaxSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetStorageMaxSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStorageMaxSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStorageMaxSlot");
static_assert(sizeof(LCommonConstantValues_GetStorageMaxSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetStorageMaxSlot");
static_assert(offsetof(LCommonConstantValues_GetStorageMaxSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStorageMaxSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetStorageRequirementsSlot
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetStorageRequirementsSlot final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetStorageRequirementsSlot) == 0x000004, "Wrong alignment on LCommonConstantValues_GetStorageRequirementsSlot");
static_assert(sizeof(LCommonConstantValues_GetStorageRequirementsSlot) == 0x000004, "Wrong size on LCommonConstantValues_GetStorageRequirementsSlot");
static_assert(offsetof(LCommonConstantValues_GetStorageRequirementsSlot, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetStorageRequirementsSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetSwapNPCDefaultHPRate
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetSwapNPCDefaultHPRate final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetSwapNPCDefaultHPRate) == 0x000004, "Wrong alignment on LCommonConstantValues_GetSwapNPCDefaultHPRate");
static_assert(sizeof(LCommonConstantValues_GetSwapNPCDefaultHPRate) == 0x000004, "Wrong size on LCommonConstantValues_GetSwapNPCDefaultHPRate");
static_assert(offsetof(LCommonConstantValues_GetSwapNPCDefaultHPRate, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetSwapNPCDefaultHPRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTalkerDialogRotateTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetTalkerDialogRotateTime final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTalkerDialogRotateTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTalkerDialogRotateTime");
static_assert(sizeof(LCommonConstantValues_GetTalkerDialogRotateTime) == 0x000004, "Wrong size on LCommonConstantValues_GetTalkerDialogRotateTime");
static_assert(offsetof(LCommonConstantValues_GetTalkerDialogRotateTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTalkerDialogRotateTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTalkerTurnLAnim
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTalkerTurnLAnim final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTalkerTurnLAnim) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTalkerTurnLAnim");
static_assert(sizeof(LCommonConstantValues_GetTalkerTurnLAnim) == 0x000008, "Wrong size on LCommonConstantValues_GetTalkerTurnLAnim");
static_assert(offsetof(LCommonConstantValues_GetTalkerTurnLAnim, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTalkerTurnLAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTalkerTurnRAnim
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTalkerTurnRAnim final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTalkerTurnRAnim) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTalkerTurnRAnim");
static_assert(sizeof(LCommonConstantValues_GetTalkerTurnRAnim) == 0x000008, "Wrong size on LCommonConstantValues_GetTalkerTurnRAnim");
static_assert(offsetof(LCommonConstantValues_GetTalkerTurnRAnim, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTalkerTurnRAnim::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTeleporStartSequenceCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTeleporStartSequenceCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTeleporStartSequenceCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTeleporStartSequenceCodeName");
static_assert(sizeof(LCommonConstantValues_GetTeleporStartSequenceCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetTeleporStartSequenceCodeName");
static_assert(offsetof(LCommonConstantValues_GetTeleporStartSequenceCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTeleporStartSequenceCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTeleportEndSequenceCodeName
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTeleportEndSequenceCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTeleportEndSequenceCodeName) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTeleportEndSequenceCodeName");
static_assert(sizeof(LCommonConstantValues_GetTeleportEndSequenceCodeName) == 0x000008, "Wrong size on LCommonConstantValues_GetTeleportEndSequenceCodeName");
static_assert(offsetof(LCommonConstantValues_GetTeleportEndSequenceCodeName, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTeleportEndSequenceCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTeleportObjectForNGPDelay
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTeleportObjectForNGPDelay final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTeleportObjectForNGPDelay) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTeleportObjectForNGPDelay");
static_assert(sizeof(LCommonConstantValues_GetTeleportObjectForNGPDelay) == 0x000008, "Wrong size on LCommonConstantValues_GetTeleportObjectForNGPDelay");
static_assert(offsetof(LCommonConstantValues_GetTeleportObjectForNGPDelay, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTeleportObjectForNGPDelay::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTeleportObjectForNGPStart
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTeleportObjectForNGPStart final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTeleportObjectForNGPStart) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTeleportObjectForNGPStart");
static_assert(sizeof(LCommonConstantValues_GetTeleportObjectForNGPStart) == 0x000008, "Wrong size on LCommonConstantValues_GetTeleportObjectForNGPStart");
static_assert(offsetof(LCommonConstantValues_GetTeleportObjectForNGPStart, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTeleportObjectForNGPStart::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTorsionCoilSetFullSlaveMagazine
// 0x0001 (0x0001 - 0x0000)
struct LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine) == 0x000001, "Wrong alignment on LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine");
static_assert(sizeof(LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine) == 0x000001, "Wrong size on LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine");
static_assert(offsetof(LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTungsten2setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTungsten2setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTungsten2setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTungsten2setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetTungsten2setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetTungsten2setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetTungsten2setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTungsten2setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTungsten3setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetTungsten3setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTungsten3setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTungsten3setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetTungsten3setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetTungsten3setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetTungsten3setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTungsten3setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTutorialPendingLimit
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetTutorialPendingLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTutorialPendingLimit) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTutorialPendingLimit");
static_assert(sizeof(LCommonConstantValues_GetTutorialPendingLimit) == 0x000004, "Wrong size on LCommonConstantValues_GetTutorialPendingLimit");
static_assert(offsetof(LCommonConstantValues_GetTutorialPendingLimit, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTutorialPendingLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTutorialPendingTime
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetTutorialPendingTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTutorialPendingTime) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTutorialPendingTime");
static_assert(sizeof(LCommonConstantValues_GetTutorialPendingTime) == 0x000004, "Wrong size on LCommonConstantValues_GetTutorialPendingTime");
static_assert(offsetof(LCommonConstantValues_GetTutorialPendingTime, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTutorialPendingTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetTutorialPriorityPendingMaxCount
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetTutorialPriorityPendingMaxCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetTutorialPriorityPendingMaxCount) == 0x000004, "Wrong alignment on LCommonConstantValues_GetTutorialPriorityPendingMaxCount");
static_assert(sizeof(LCommonConstantValues_GetTutorialPriorityPendingMaxCount) == 0x000004, "Wrong size on LCommonConstantValues_GetTutorialPriorityPendingMaxCount");
static_assert(offsetof(LCommonConstantValues_GetTutorialPriorityPendingMaxCount, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetTutorialPriorityPendingMaxCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetUniqueGrinderMainItem
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetUniqueGrinderMainItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetUniqueGrinderMainItem) == 0x000004, "Wrong alignment on LCommonConstantValues_GetUniqueGrinderMainItem");
static_assert(sizeof(LCommonConstantValues_GetUniqueGrinderMainItem) == 0x000008, "Wrong size on LCommonConstantValues_GetUniqueGrinderMainItem");
static_assert(offsetof(LCommonConstantValues_GetUniqueGrinderMainItem, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetUniqueGrinderMainItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetUranium2setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetUranium2setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetUranium2setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetUranium2setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetUranium2setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetUranium2setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetUranium2setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetUranium2setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetUranium3setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetUranium3setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetUranium3setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetUranium3setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetUranium3setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetUranium3setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetUranium3setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetUranium3setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetVibranium2setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetVibranium2setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetVibranium2setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetVibranium2setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetVibranium2setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetVibranium2setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetVibranium2setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetVibranium2setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetVibranium3setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetVibranium3setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetVibranium3setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetVibranium3setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetVibranium3setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetVibranium3setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetVibranium3setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetVibranium3setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetWalkRunSpeedRatioMax
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetWalkRunSpeedRatioMax final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetWalkRunSpeedRatioMax) == 0x000004, "Wrong alignment on LCommonConstantValues_GetWalkRunSpeedRatioMax");
static_assert(sizeof(LCommonConstantValues_GetWalkRunSpeedRatioMax) == 0x000004, "Wrong size on LCommonConstantValues_GetWalkRunSpeedRatioMax");
static_assert(offsetof(LCommonConstantValues_GetWalkRunSpeedRatioMax, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetWalkRunSpeedRatioMax::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetWalkRunSpeedRatioMin
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetWalkRunSpeedRatioMin final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetWalkRunSpeedRatioMin) == 0x000004, "Wrong alignment on LCommonConstantValues_GetWalkRunSpeedRatioMin");
static_assert(sizeof(LCommonConstantValues_GetWalkRunSpeedRatioMin) == 0x000004, "Wrong size on LCommonConstantValues_GetWalkRunSpeedRatioMin");
static_assert(offsetof(LCommonConstantValues_GetWalkRunSpeedRatioMin, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetWalkRunSpeedRatioMin::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetWeaponPhysicalAttackpowerFatalWeight
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight) == 0x000004, "Wrong alignment on LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight");
static_assert(sizeof(LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight) == 0x000004, "Wrong size on LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight");
static_assert(offsetof(LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetWeightLimitOverAllowRatio
// 0x0004 (0x0004 - 0x0000)
struct LCommonConstantValues_GetWeightLimitOverAllowRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetWeightLimitOverAllowRatio) == 0x000004, "Wrong alignment on LCommonConstantValues_GetWeightLimitOverAllowRatio");
static_assert(sizeof(LCommonConstantValues_GetWeightLimitOverAllowRatio) == 0x000004, "Wrong size on LCommonConstantValues_GetWeightLimitOverAllowRatio");
static_assert(offsetof(LCommonConstantValues_GetWeightLimitOverAllowRatio, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetWeightLimitOverAllowRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetWood2setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetWood2setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetWood2setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetWood2setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetWood2setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetWood2setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetWood2setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetWood2setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LCommonConstantValues.GetWood3setAbnormalState
// 0x0008 (0x0008 - 0x0000)
struct LCommonConstantValues_GetWood3setAbnormalState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCommonConstantValues_GetWood3setAbnormalState) == 0x000004, "Wrong alignment on LCommonConstantValues_GetWood3setAbnormalState");
static_assert(sizeof(LCommonConstantValues_GetWood3setAbnormalState) == 0x000008, "Wrong size on LCommonConstantValues_GetWood3setAbnormalState");
static_assert(offsetof(LCommonConstantValues_GetWood3setAbnormalState, ReturnValue) == 0x000000, "Member 'LCommonConstantValues_GetWood3setAbnormalState::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectDataDB.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LObjectDataDB_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LObjectDataDB_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LObjectDataDB_OnGameDataCharacterSync");
static_assert(sizeof(LObjectDataDB_OnGameDataCharacterSync) == 0x000010, "Wrong size on LObjectDataDB_OnGameDataCharacterSync");
static_assert(offsetof(LObjectDataDB_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LObjectDataDB_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LObjectDataDB_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LObjectDataDB_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LGameDataSystem.AddPlayedRecord
// 0x000C (0x000C - 0x0000)
struct LGameDataSystem_AddPlayedRecord final
{
public:
	class FName                                   RecordName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_AddPlayedRecord) == 0x000004, "Wrong alignment on LGameDataSystem_AddPlayedRecord");
static_assert(sizeof(LGameDataSystem_AddPlayedRecord) == 0x00000C, "Wrong size on LGameDataSystem_AddPlayedRecord");
static_assert(offsetof(LGameDataSystem_AddPlayedRecord, RecordName) == 0x000000, "Member 'LGameDataSystem_AddPlayedRecord::RecordName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_AddPlayedRecord, ReturnValue) == 0x000008, "Member 'LGameDataSystem_AddPlayedRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.DeleteCharacterStorageData
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_DeleteCharacterStorageData final
{
public:
	class FString                                 DeleteName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_DeleteCharacterStorageData) == 0x000008, "Wrong alignment on LGameDataSystem_DeleteCharacterStorageData");
static_assert(sizeof(LGameDataSystem_DeleteCharacterStorageData) == 0x000010, "Wrong size on LGameDataSystem_DeleteCharacterStorageData");
static_assert(offsetof(LGameDataSystem_DeleteCharacterStorageData, DeleteName) == 0x000000, "Member 'LGameDataSystem_DeleteCharacterStorageData::DeleteName' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetAccountEULAVersion
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetAccountEULAVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetAccountEULAVersion) == 0x000008, "Wrong alignment on LGameDataSystem_GetAccountEULAVersion");
static_assert(sizeof(LGameDataSystem_GetAccountEULAVersion) == 0x000010, "Wrong size on LGameDataSystem_GetAccountEULAVersion");
static_assert(offsetof(LGameDataSystem_GetAccountEULAVersion, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetAccountEULAVersion::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetActivityIndex
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetActivityIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetActivityIndex) == 0x000004, "Wrong alignment on LGameDataSystem_GetActivityIndex");
static_assert(sizeof(LGameDataSystem_GetActivityIndex) == 0x000004, "Wrong size on LGameDataSystem_GetActivityIndex");
static_assert(offsetof(LGameDataSystem_GetActivityIndex, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetActivityIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCategoryList
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetCategoryList final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCategoryList) == 0x000008, "Wrong alignment on LGameDataSystem_GetCategoryList");
static_assert(sizeof(LGameDataSystem_GetCategoryList) == 0x000010, "Wrong size on LGameDataSystem_GetCategoryList");
static_assert(offsetof(LGameDataSystem_GetCategoryList, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCategoryList::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCharacterLevel
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetCharacterLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCharacterLevel) == 0x000004, "Wrong alignment on LGameDataSystem_GetCharacterLevel");
static_assert(sizeof(LGameDataSystem_GetCharacterLevel) == 0x000004, "Wrong size on LGameDataSystem_GetCharacterLevel");
static_assert(offsetof(LGameDataSystem_GetCharacterLevel, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCharacterLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCharacterName
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetCharacterName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCharacterName) == 0x000008, "Wrong alignment on LGameDataSystem_GetCharacterName");
static_assert(sizeof(LGameDataSystem_GetCharacterName) == 0x000010, "Wrong size on LGameDataSystem_GetCharacterName");
static_assert(offsetof(LGameDataSystem_GetCharacterName, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCharacterName::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCharacterStoragePlayTime
// 0x0020 (0x0020 - 0x0000)
struct LGameDataSystem_GetCharacterStoragePlayTime final
{
public:
	class FString                                 FindName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCharacterStoragePlayTime) == 0x000008, "Wrong alignment on LGameDataSystem_GetCharacterStoragePlayTime");
static_assert(sizeof(LGameDataSystem_GetCharacterStoragePlayTime) == 0x000020, "Wrong size on LGameDataSystem_GetCharacterStoragePlayTime");
static_assert(offsetof(LGameDataSystem_GetCharacterStoragePlayTime, FindName) == 0x000000, "Member 'LGameDataSystem_GetCharacterStoragePlayTime::FindName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetCharacterStoragePlayTime, ReturnValue) == 0x000010, "Member 'LGameDataSystem_GetCharacterStoragePlayTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCharacterStorageSaveDateTime
// 0x0018 (0x0018 - 0x0000)
struct LGameDataSystem_GetCharacterStorageSaveDateTime final
{
public:
	struct FDateTime                              InDateTime;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCharacterStorageSaveDateTime) == 0x000008, "Wrong alignment on LGameDataSystem_GetCharacterStorageSaveDateTime");
static_assert(sizeof(LGameDataSystem_GetCharacterStorageSaveDateTime) == 0x000018, "Wrong size on LGameDataSystem_GetCharacterStorageSaveDateTime");
static_assert(offsetof(LGameDataSystem_GetCharacterStorageSaveDateTime, InDateTime) == 0x000000, "Member 'LGameDataSystem_GetCharacterStorageSaveDateTime::InDateTime' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetCharacterStorageSaveDateTime, ReturnValue) == 0x000008, "Member 'LGameDataSystem_GetCharacterStorageSaveDateTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetConstantValues
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_GetConstantValues final
{
public:
	class ULCommonConstantValues*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetConstantValues) == 0x000008, "Wrong alignment on LGameDataSystem_GetConstantValues");
static_assert(sizeof(LGameDataSystem_GetConstantValues) == 0x000008, "Wrong size on LGameDataSystem_GetConstantValues");
static_assert(offsetof(LGameDataSystem_GetConstantValues, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetConstantValues::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCurrentErgo
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetCurrentErgo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCurrentErgo) == 0x000004, "Wrong alignment on LGameDataSystem_GetCurrentErgo");
static_assert(sizeof(LGameDataSystem_GetCurrentErgo) == 0x000004, "Wrong size on LGameDataSystem_GetCurrentErgo");
static_assert(offsetof(LGameDataSystem_GetCurrentErgo, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCurrentErgo::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCurrentHotelTosionCoil
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_GetCurrentHotelTosionCoil final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCurrentHotelTosionCoil) == 0x000004, "Wrong alignment on LGameDataSystem_GetCurrentHotelTosionCoil");
static_assert(sizeof(LGameDataSystem_GetCurrentHotelTosionCoil) == 0x000008, "Wrong size on LGameDataSystem_GetCurrentHotelTosionCoil");
static_assert(offsetof(LGameDataSystem_GetCurrentHotelTosionCoil, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCurrentHotelTosionCoil::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCurrentHumanity
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetCurrentHumanity final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCurrentHumanity) == 0x000004, "Wrong alignment on LGameDataSystem_GetCurrentHumanity");
static_assert(sizeof(LGameDataSystem_GetCurrentHumanity) == 0x000004, "Wrong size on LGameDataSystem_GetCurrentHumanity");
static_assert(offsetof(LGameDataSystem_GetCurrentHumanity, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCurrentHumanity::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetCurrentNewGamePlus
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetCurrentNewGamePlus final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetCurrentNewGamePlus) == 0x000004, "Wrong alignment on LGameDataSystem_GetCurrentNewGamePlus");
static_assert(sizeof(LGameDataSystem_GetCurrentNewGamePlus) == 0x000004, "Wrong size on LGameDataSystem_GetCurrentNewGamePlus");
static_assert(offsetof(LGameDataSystem_GetCurrentNewGamePlus, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetCurrentNewGamePlus::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetDepartureTeleportObject
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_GetDepartureTeleportObject final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetDepartureTeleportObject) == 0x000004, "Wrong alignment on LGameDataSystem_GetDepartureTeleportObject");
static_assert(sizeof(LGameDataSystem_GetDepartureTeleportObject) == 0x000008, "Wrong size on LGameDataSystem_GetDepartureTeleportObject");
static_assert(offsetof(LGameDataSystem_GetDepartureTeleportObject, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetDepartureTeleportObject::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetDropErgo
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetDropErgo final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetDropErgo) == 0x000004, "Wrong alignment on LGameDataSystem_GetDropErgo");
static_assert(sizeof(LGameDataSystem_GetDropErgo) == 0x000004, "Wrong size on LGameDataSystem_GetDropErgo");
static_assert(offsetof(LGameDataSystem_GetDropErgo, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetDropErgo::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetEULAVersion
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetEULAVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetEULAVersion) == 0x000008, "Wrong alignment on LGameDataSystem_GetEULAVersion");
static_assert(sizeof(LGameDataSystem_GetEULAVersion) == 0x000010, "Wrong size on LGameDataSystem_GetEULAVersion");
static_assert(offsetof(LGameDataSystem_GetEULAVersion, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetEULAVersion::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetForceStartChapter
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetForceStartChapter final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetForceStartChapter) == 0x000004, "Wrong alignment on LGameDataSystem_GetForceStartChapter");
static_assert(sizeof(LGameDataSystem_GetForceStartChapter) == 0x000004, "Wrong size on LGameDataSystem_GetForceStartChapter");
static_assert(offsetof(LGameDataSystem_GetForceStartChapter, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetForceStartChapter::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetGlobalVariableData
// 0x000C (0x000C - 0x0000)
struct LGameDataSystem_GetGlobalVariableData final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetGlobalVariableData) == 0x000004, "Wrong alignment on LGameDataSystem_GetGlobalVariableData");
static_assert(sizeof(LGameDataSystem_GetGlobalVariableData) == 0x00000C, "Wrong size on LGameDataSystem_GetGlobalVariableData");
static_assert(offsetof(LGameDataSystem_GetGlobalVariableData, InCodeName) == 0x000000, "Member 'LGameDataSystem_GetGlobalVariableData::InCodeName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetGlobalVariableData, ReturnValue) == 0x000008, "Member 'LGameDataSystem_GetGlobalVariableData::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetHairCategoryType
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_GetHairCategoryType final
{
public:
	ELHairCategoryType                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetHairCategoryType) == 0x000001, "Wrong alignment on LGameDataSystem_GetHairCategoryType");
static_assert(sizeof(LGameDataSystem_GetHairCategoryType) == 0x000001, "Wrong size on LGameDataSystem_GetHairCategoryType");
static_assert(offsetof(LGameDataSystem_GetHairCategoryType, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetHairCategoryType::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetHumanityLevel
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetHumanityLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetHumanityLevel) == 0x000004, "Wrong alignment on LGameDataSystem_GetHumanityLevel");
static_assert(sizeof(LGameDataSystem_GetHumanityLevel) == 0x000004, "Wrong size on LGameDataSystem_GetHumanityLevel");
static_assert(offsetof(LGameDataSystem_GetHumanityLevel, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetHumanityLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetHumanityRatio
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetHumanityRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetHumanityRatio) == 0x000004, "Wrong alignment on LGameDataSystem_GetHumanityRatio");
static_assert(sizeof(LGameDataSystem_GetHumanityRatio) == 0x000004, "Wrong size on LGameDataSystem_GetHumanityRatio");
static_assert(offsetof(LGameDataSystem_GetHumanityRatio, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetHumanityRatio::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetLatestTorsionCoil
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_GetLatestTorsionCoil final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetLatestTorsionCoil) == 0x000004, "Wrong alignment on LGameDataSystem_GetLatestTorsionCoil");
static_assert(sizeof(LGameDataSystem_GetLatestTorsionCoil) == 0x000008, "Wrong size on LGameDataSystem_GetLatestTorsionCoil");
static_assert(offsetof(LGameDataSystem_GetLatestTorsionCoil, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetLatestTorsionCoil::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetLevelUpRequireErgo
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_GetLevelUpRequireErgo final
{
public:
	int32                                         CheckLevel;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetLevelUpRequireErgo) == 0x000004, "Wrong alignment on LGameDataSystem_GetLevelUpRequireErgo");
static_assert(sizeof(LGameDataSystem_GetLevelUpRequireErgo) == 0x000008, "Wrong size on LGameDataSystem_GetLevelUpRequireErgo");
static_assert(offsetof(LGameDataSystem_GetLevelUpRequireErgo, CheckLevel) == 0x000000, "Member 'LGameDataSystem_GetLevelUpRequireErgo::CheckLevel' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetLevelUpRequireErgo, ReturnValue) == 0x000004, "Member 'LGameDataSystem_GetLevelUpRequireErgo::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetMaxLevelUpCount
// 0x000C (0x000C - 0x0000)
struct LGameDataSystem_GetMaxLevelUpCount final
{
public:
	int32                                         PlayerLevel;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainSoul;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetMaxLevelUpCount) == 0x000004, "Wrong alignment on LGameDataSystem_GetMaxLevelUpCount");
static_assert(sizeof(LGameDataSystem_GetMaxLevelUpCount) == 0x00000C, "Wrong size on LGameDataSystem_GetMaxLevelUpCount");
static_assert(offsetof(LGameDataSystem_GetMaxLevelUpCount, PlayerLevel) == 0x000000, "Member 'LGameDataSystem_GetMaxLevelUpCount::PlayerLevel' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetMaxLevelUpCount, RemainSoul) == 0x000004, "Member 'LGameDataSystem_GetMaxLevelUpCount::RemainSoul' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetMaxLevelUpCount, ReturnValue) == 0x000008, "Member 'LGameDataSystem_GetMaxLevelUpCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetNewGamePlusProcess
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_GetNewGamePlusProcess final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetNewGamePlusProcess) == 0x000001, "Wrong alignment on LGameDataSystem_GetNewGamePlusProcess");
static_assert(sizeof(LGameDataSystem_GetNewGamePlusProcess) == 0x000001, "Wrong size on LGameDataSystem_GetNewGamePlusProcess");
static_assert(offsetof(LGameDataSystem_GetNewGamePlusProcess, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetNewGamePlusProcess::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetNextLevelUpRequireSoul
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetNextLevelUpRequireSoul final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetNextLevelUpRequireSoul) == 0x000004, "Wrong alignment on LGameDataSystem_GetNextLevelUpRequireSoul");
static_assert(sizeof(LGameDataSystem_GetNextLevelUpRequireSoul) == 0x000004, "Wrong size on LGameDataSystem_GetNextLevelUpRequireSoul");
static_assert(offsetof(LGameDataSystem_GetNextLevelUpRequireSoul, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetNextLevelUpRequireSoul::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetPlayerTeleportTransform
// 0x0040 (0x0040 - 0x0000)
struct LGameDataSystem_GetPlayerTeleportTransform final
{
public:
	ELSpawnTransformType                          OutSpawnTransformType;                             // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetPlayerTeleportTransform) == 0x000010, "Wrong alignment on LGameDataSystem_GetPlayerTeleportTransform");
static_assert(sizeof(LGameDataSystem_GetPlayerTeleportTransform) == 0x000040, "Wrong size on LGameDataSystem_GetPlayerTeleportTransform");
static_assert(offsetof(LGameDataSystem_GetPlayerTeleportTransform, OutSpawnTransformType) == 0x000000, "Member 'LGameDataSystem_GetPlayerTeleportTransform::OutSpawnTransformType' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetPlayerTeleportTransform, ReturnValue) == 0x000010, "Member 'LGameDataSystem_GetPlayerTeleportTransform::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetRaxasiaShieldBroken
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_GetRaxasiaShieldBroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetRaxasiaShieldBroken) == 0x000001, "Wrong alignment on LGameDataSystem_GetRaxasiaShieldBroken");
static_assert(sizeof(LGameDataSystem_GetRaxasiaShieldBroken) == 0x000001, "Wrong size on LGameDataSystem_GetRaxasiaShieldBroken");
static_assert(offsetof(LGameDataSystem_GetRaxasiaShieldBroken, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetRaxasiaShieldBroken::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetRemainSoul
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetRemainSoul final
{
public:
	int32                                         CurLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurSoul;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelUpCount;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetRemainSoul) == 0x000004, "Wrong alignment on LGameDataSystem_GetRemainSoul");
static_assert(sizeof(LGameDataSystem_GetRemainSoul) == 0x000010, "Wrong size on LGameDataSystem_GetRemainSoul");
static_assert(offsetof(LGameDataSystem_GetRemainSoul, CurLevel) == 0x000000, "Member 'LGameDataSystem_GetRemainSoul::CurLevel' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetRemainSoul, CurSoul) == 0x000004, "Member 'LGameDataSystem_GetRemainSoul::CurSoul' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetRemainSoul, LevelUpCount) == 0x000008, "Member 'LGameDataSystem_GetRemainSoul::LevelUpCount' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetRemainSoul, ReturnValue) == 0x00000C, "Member 'LGameDataSystem_GetRemainSoul::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetSaveData
// 0x0018 (0x0018 - 0x0000)
struct LGameDataSystem_GetSaveData final
{
public:
	TArray<struct FLCharacterStorageData>         OutCharacterList;                                  // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_GetSaveData) == 0x000008, "Wrong alignment on LGameDataSystem_GetSaveData");
static_assert(sizeof(LGameDataSystem_GetSaveData) == 0x000018, "Wrong size on LGameDataSystem_GetSaveData");
static_assert(offsetof(LGameDataSystem_GetSaveData, OutCharacterList) == 0x000000, "Member 'LGameDataSystem_GetSaveData::OutCharacterList' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetSaveData, ReturnValue) == 0x000010, "Member 'LGameDataSystem_GetSaveData::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetTeleportList
// 0x0020 (0x0020 - 0x0000)
struct LGameDataSystem_GetTeleportList final
{
public:
	int32                                         CategoryIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLTeleportLocation>             OutTeleportLocationList;                           // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_GetTeleportList) == 0x000008, "Wrong alignment on LGameDataSystem_GetTeleportList");
static_assert(sizeof(LGameDataSystem_GetTeleportList) == 0x000020, "Wrong size on LGameDataSystem_GetTeleportList");
static_assert(offsetof(LGameDataSystem_GetTeleportList, CategoryIndex) == 0x000000, "Member 'LGameDataSystem_GetTeleportList::CategoryIndex' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetTeleportList, OutTeleportLocationList) == 0x000008, "Member 'LGameDataSystem_GetTeleportList::OutTeleportLocationList' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_GetTeleportList, ReturnValue) == 0x000018, "Member 'LGameDataSystem_GetTeleportList::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetWeatherCodeName
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_GetWeatherCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetWeatherCodeName) == 0x000004, "Wrong alignment on LGameDataSystem_GetWeatherCodeName");
static_assert(sizeof(LGameDataSystem_GetWeatherCodeName) == 0x000008, "Wrong size on LGameDataSystem_GetWeatherCodeName");
static_assert(offsetof(LGameDataSystem_GetWeatherCodeName, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetWeatherCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsHiddenConditionTeleportToHotel
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_IsHiddenConditionTeleportToHotel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_IsHiddenConditionTeleportToHotel) == 0x000001, "Wrong alignment on LGameDataSystem_IsHiddenConditionTeleportToHotel");
static_assert(sizeof(LGameDataSystem_IsHiddenConditionTeleportToHotel) == 0x000001, "Wrong size on LGameDataSystem_IsHiddenConditionTeleportToHotel");
static_assert(offsetof(LGameDataSystem_IsHiddenConditionTeleportToHotel, ReturnValue) == 0x000000, "Member 'LGameDataSystem_IsHiddenConditionTeleportToHotel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsLastPlayCharacter
// 0x0018 (0x0018 - 0x0000)
struct LGameDataSystem_IsLastPlayCharacter final
{
public:
	class FString                                 FindName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_IsLastPlayCharacter) == 0x000008, "Wrong alignment on LGameDataSystem_IsLastPlayCharacter");
static_assert(sizeof(LGameDataSystem_IsLastPlayCharacter) == 0x000018, "Wrong size on LGameDataSystem_IsLastPlayCharacter");
static_assert(offsetof(LGameDataSystem_IsLastPlayCharacter, FindName) == 0x000000, "Member 'LGameDataSystem_IsLastPlayCharacter::FindName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_IsLastPlayCharacter, ReturnValue) == 0x000010, "Member 'LGameDataSystem_IsLastPlayCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsNormalShutDown
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_IsNormalShutDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_IsNormalShutDown) == 0x000001, "Wrong alignment on LGameDataSystem_IsNormalShutDown");
static_assert(sizeof(LGameDataSystem_IsNormalShutDown) == 0x000001, "Wrong size on LGameDataSystem_IsNormalShutDown");
static_assert(offsetof(LGameDataSystem_IsNormalShutDown, ReturnValue) == 0x000000, "Member 'LGameDataSystem_IsNormalShutDown::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsPlayingNewGamePlusProcess
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_IsPlayingNewGamePlusProcess final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_IsPlayingNewGamePlusProcess) == 0x000001, "Wrong alignment on LGameDataSystem_IsPlayingNewGamePlusProcess");
static_assert(sizeof(LGameDataSystem_IsPlayingNewGamePlusProcess) == 0x000001, "Wrong size on LGameDataSystem_IsPlayingNewGamePlusProcess");
static_assert(offsetof(LGameDataSystem_IsPlayingNewGamePlusProcess, ReturnValue) == 0x000000, "Member 'LGameDataSystem_IsPlayingNewGamePlusProcess::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsPossibleTeleportToHotel
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_IsPossibleTeleportToHotel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_IsPossibleTeleportToHotel) == 0x000001, "Wrong alignment on LGameDataSystem_IsPossibleTeleportToHotel");
static_assert(sizeof(LGameDataSystem_IsPossibleTeleportToHotel) == 0x000001, "Wrong size on LGameDataSystem_IsPossibleTeleportToHotel");
static_assert(offsetof(LGameDataSystem_IsPossibleTeleportToHotel, ReturnValue) == 0x000000, "Member 'LGameDataSystem_IsPossibleTeleportToHotel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsValidLastPlayCharacter
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_IsValidLastPlayCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_IsValidLastPlayCharacter) == 0x000001, "Wrong alignment on LGameDataSystem_IsValidLastPlayCharacter");
static_assert(sizeof(LGameDataSystem_IsValidLastPlayCharacter) == 0x000001, "Wrong size on LGameDataSystem_IsValidLastPlayCharacter");
static_assert(offsetof(LGameDataSystem_IsValidLastPlayCharacter, ReturnValue) == 0x000000, "Member 'LGameDataSystem_IsValidLastPlayCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsValidStarterPackContinueCharacter
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_IsValidStarterPackContinueCharacter final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_IsValidStarterPackContinueCharacter) == 0x000001, "Wrong alignment on LGameDataSystem_IsValidStarterPackContinueCharacter");
static_assert(sizeof(LGameDataSystem_IsValidStarterPackContinueCharacter) == 0x000001, "Wrong size on LGameDataSystem_IsValidStarterPackContinueCharacter");
static_assert(offsetof(LGameDataSystem_IsValidStarterPackContinueCharacter, ReturnValue) == 0x000000, "Member 'LGameDataSystem_IsValidStarterPackContinueCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsValidStarterPackSelectCharacter
// 0x0018 (0x0018 - 0x0000)
struct LGameDataSystem_IsValidStarterPackSelectCharacter final
{
public:
	class FString                                 SelectName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_IsValidStarterPackSelectCharacter) == 0x000008, "Wrong alignment on LGameDataSystem_IsValidStarterPackSelectCharacter");
static_assert(sizeof(LGameDataSystem_IsValidStarterPackSelectCharacter) == 0x000018, "Wrong size on LGameDataSystem_IsValidStarterPackSelectCharacter");
static_assert(offsetof(LGameDataSystem_IsValidStarterPackSelectCharacter, SelectName) == 0x000000, "Member 'LGameDataSystem_IsValidStarterPackSelectCharacter::SelectName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_IsValidStarterPackSelectCharacter, ReturnValue) == 0x000010, "Member 'LGameDataSystem_IsValidStarterPackSelectCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.IsValidTeleportTransformByType
// 0x0050 (0x0050 - 0x0000)
struct LGameDataSystem_IsValidTeleportTransformByType final
{
public:
	ELSpawnTransformType                          FindType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTransform;                                      // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_IsValidTeleportTransformByType) == 0x000010, "Wrong alignment on LGameDataSystem_IsValidTeleportTransformByType");
static_assert(sizeof(LGameDataSystem_IsValidTeleportTransformByType) == 0x000050, "Wrong size on LGameDataSystem_IsValidTeleportTransformByType");
static_assert(offsetof(LGameDataSystem_IsValidTeleportTransformByType, FindType) == 0x000000, "Member 'LGameDataSystem_IsValidTeleportTransformByType::FindType' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_IsValidTeleportTransformByType, OutTransform) == 0x000010, "Member 'LGameDataSystem_IsValidTeleportTransformByType::OutTransform' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_IsValidTeleportTransformByType, ReturnValue) == 0x000040, "Member 'LGameDataSystem_IsValidTeleportTransformByType::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.LoadSelectCharacterStorageData
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_LoadSelectCharacterStorageData final
{
public:
	class FString                                 SelectName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_LoadSelectCharacterStorageData) == 0x000008, "Wrong alignment on LGameDataSystem_LoadSelectCharacterStorageData");
static_assert(sizeof(LGameDataSystem_LoadSelectCharacterStorageData) == 0x000010, "Wrong size on LGameDataSystem_LoadSelectCharacterStorageData");
static_assert(offsetof(LGameDataSystem_LoadSelectCharacterStorageData, SelectName) == 0x000000, "Member 'LGameDataSystem_LoadSelectCharacterStorageData::SelectName' has a wrong offset!");

// Function ProjectP.LGameDataSystem.NewCharacterStorageData
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_NewCharacterStorageData final
{
public:
	int32                                         StartChapter;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_NewCharacterStorageData) == 0x000004, "Wrong alignment on LGameDataSystem_NewCharacterStorageData");
static_assert(sizeof(LGameDataSystem_NewCharacterStorageData) == 0x000004, "Wrong size on LGameDataSystem_NewCharacterStorageData");
static_assert(offsetof(LGameDataSystem_NewCharacterStorageData, StartChapter) == 0x000000, "Member 'LGameDataSystem_NewCharacterStorageData::StartChapter' has a wrong offset!");

// Function ProjectP.LGameDataSystem.ObjDataDB
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_ObjDataDB final
{
public:
	class ULObjectDataDB*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_ObjDataDB) == 0x000008, "Wrong alignment on LGameDataSystem_ObjDataDB");
static_assert(sizeof(LGameDataSystem_ObjDataDB) == 0x000008, "Wrong size on LGameDataSystem_ObjDataDB");
static_assert(offsetof(LGameDataSystem_ObjDataDB, ReturnValue) == 0x000000, "Member 'LGameDataSystem_ObjDataDB::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.OnClosedStargazerDialog
// 0x0008 (0x0008 - 0x0000)
struct LGameDataSystem_OnClosedStargazerDialog final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_OnClosedStargazerDialog) == 0x000004, "Wrong alignment on LGameDataSystem_OnClosedStargazerDialog");
static_assert(sizeof(LGameDataSystem_OnClosedStargazerDialog) == 0x000008, "Wrong size on LGameDataSystem_OnClosedStargazerDialog");
static_assert(offsetof(LGameDataSystem_OnClosedStargazerDialog, WidgetTableName) == 0x000000, "Member 'LGameDataSystem_OnClosedStargazerDialog::WidgetTableName' has a wrong offset!");

// Function ProjectP.LGameDataSystem.OnLoadGameDataInGame
// 0x0020 (0x0020 - 0x0000)
struct LGameDataSystem_OnLoadGameDataInGame final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULSaveGame*                             SaveGame;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_OnLoadGameDataInGame) == 0x000008, "Wrong alignment on LGameDataSystem_OnLoadGameDataInGame");
static_assert(sizeof(LGameDataSystem_OnLoadGameDataInGame) == 0x000020, "Wrong size on LGameDataSystem_OnLoadGameDataInGame");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataInGame, SlotName) == 0x000000, "Member 'LGameDataSystem_OnLoadGameDataInGame::SlotName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataInGame, bSuccess) == 0x000010, "Member 'LGameDataSystem_OnLoadGameDataInGame::bSuccess' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataInGame, GameDataType) == 0x000011, "Member 'LGameDataSystem_OnLoadGameDataInGame::GameDataType' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataInGame, SaveGame) == 0x000018, "Member 'LGameDataSystem_OnLoadGameDataInGame::SaveGame' has a wrong offset!");

// Function ProjectP.LGameDataSystem.OnLoadGameDataLobby
// 0x0020 (0x0020 - 0x0000)
struct LGameDataSystem_OnLoadGameDataLobby final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULSaveGame*                             SaveGame;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_OnLoadGameDataLobby) == 0x000008, "Wrong alignment on LGameDataSystem_OnLoadGameDataLobby");
static_assert(sizeof(LGameDataSystem_OnLoadGameDataLobby) == 0x000020, "Wrong size on LGameDataSystem_OnLoadGameDataLobby");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataLobby, SlotName) == 0x000000, "Member 'LGameDataSystem_OnLoadGameDataLobby::SlotName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataLobby, bSuccess) == 0x000010, "Member 'LGameDataSystem_OnLoadGameDataLobby::bSuccess' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataLobby, GameDataType) == 0x000011, "Member 'LGameDataSystem_OnLoadGameDataLobby::GameDataType' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnLoadGameDataLobby, SaveGame) == 0x000018, "Member 'LGameDataSystem_OnLoadGameDataLobby::SaveGame' has a wrong offset!");

// Function ProjectP.LGameDataSystem.OnResultEULA
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_OnResultEULA final
{
public:
	bool                                          InAgree;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_OnResultEULA) == 0x000001, "Wrong alignment on LGameDataSystem_OnResultEULA");
static_assert(sizeof(LGameDataSystem_OnResultEULA) == 0x000001, "Wrong size on LGameDataSystem_OnResultEULA");
static_assert(offsetof(LGameDataSystem_OnResultEULA, InAgree) == 0x000000, "Member 'LGameDataSystem_OnResultEULA::InAgree' has a wrong offset!");

// Function ProjectP.LGameDataSystem.OnSaveGameDataInGame
// 0x0018 (0x0018 - 0x0000)
struct LGameDataSystem_OnSaveGameDataInGame final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_OnSaveGameDataInGame) == 0x000008, "Wrong alignment on LGameDataSystem_OnSaveGameDataInGame");
static_assert(sizeof(LGameDataSystem_OnSaveGameDataInGame) == 0x000018, "Wrong size on LGameDataSystem_OnSaveGameDataInGame");
static_assert(offsetof(LGameDataSystem_OnSaveGameDataInGame, SlotName) == 0x000000, "Member 'LGameDataSystem_OnSaveGameDataInGame::SlotName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnSaveGameDataInGame, bSuccess) == 0x000010, "Member 'LGameDataSystem_OnSaveGameDataInGame::bSuccess' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnSaveGameDataInGame, GameDataType) == 0x000011, "Member 'LGameDataSystem_OnSaveGameDataInGame::GameDataType' has a wrong offset!");

// Function ProjectP.LGameDataSystem.OnSaveGameDataLobby
// 0x0018 (0x0018 - 0x0000)
struct LGameDataSystem_OnSaveGameDataLobby final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameDataSystem_OnSaveGameDataLobby) == 0x000008, "Wrong alignment on LGameDataSystem_OnSaveGameDataLobby");
static_assert(sizeof(LGameDataSystem_OnSaveGameDataLobby) == 0x000018, "Wrong size on LGameDataSystem_OnSaveGameDataLobby");
static_assert(offsetof(LGameDataSystem_OnSaveGameDataLobby, SlotName) == 0x000000, "Member 'LGameDataSystem_OnSaveGameDataLobby::SlotName' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnSaveGameDataLobby, bSuccess) == 0x000010, "Member 'LGameDataSystem_OnSaveGameDataLobby::bSuccess' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_OnSaveGameDataLobby, GameDataType) == 0x000011, "Member 'LGameDataSystem_OnSaveGameDataLobby::GameDataType' has a wrong offset!");

// Function ProjectP.LGameDataSystem.RestoreCharacterStorageData
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_RestoreCharacterStorageData final
{
public:
	int32                                         StartChapter;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_RestoreCharacterStorageData) == 0x000004, "Wrong alignment on LGameDataSystem_RestoreCharacterStorageData");
static_assert(sizeof(LGameDataSystem_RestoreCharacterStorageData) == 0x000004, "Wrong size on LGameDataSystem_RestoreCharacterStorageData");
static_assert(offsetof(LGameDataSystem_RestoreCharacterStorageData, StartChapter) == 0x000000, "Member 'LGameDataSystem_RestoreCharacterStorageData::StartChapter' has a wrong offset!");

// Function ProjectP.LGameDataSystem.SaveGameDataFromUI
// 0x0002 (0x0002 - 0x0000)
struct LGameDataSystem_SaveGameDataFromUI final
{
public:
	bool                                          IsAsyncSave;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NormalShutDown;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_SaveGameDataFromUI) == 0x000001, "Wrong alignment on LGameDataSystem_SaveGameDataFromUI");
static_assert(sizeof(LGameDataSystem_SaveGameDataFromUI) == 0x000002, "Wrong size on LGameDataSystem_SaveGameDataFromUI");
static_assert(offsetof(LGameDataSystem_SaveGameDataFromUI, IsAsyncSave) == 0x000000, "Member 'LGameDataSystem_SaveGameDataFromUI::IsAsyncSave' has a wrong offset!");
static_assert(offsetof(LGameDataSystem_SaveGameDataFromUI, NormalShutDown) == 0x000001, "Member 'LGameDataSystem_SaveGameDataFromUI::NormalShutDown' has a wrong offset!");

// Function ProjectP.LGameDataSystem.SelectCharacterStorageData
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_SelectCharacterStorageData final
{
public:
	class FString                                 SelectName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_SelectCharacterStorageData) == 0x000008, "Wrong alignment on LGameDataSystem_SelectCharacterStorageData");
static_assert(sizeof(LGameDataSystem_SelectCharacterStorageData) == 0x000010, "Wrong size on LGameDataSystem_SelectCharacterStorageData");
static_assert(offsetof(LGameDataSystem_SelectCharacterStorageData, SelectName) == 0x000000, "Member 'LGameDataSystem_SelectCharacterStorageData::SelectName' has a wrong offset!");

// Function ProjectP.LGameDataSystem.SetActivityIndex
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_SetActivityIndex final
{
public:
	int32                                         InActivityIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_SetActivityIndex) == 0x000004, "Wrong alignment on LGameDataSystem_SetActivityIndex");
static_assert(sizeof(LGameDataSystem_SetActivityIndex) == 0x000004, "Wrong size on LGameDataSystem_SetActivityIndex");
static_assert(offsetof(LGameDataSystem_SetActivityIndex, InActivityIndex) == 0x000000, "Member 'LGameDataSystem_SetActivityIndex::InActivityIndex' has a wrong offset!");

// Function ProjectP.LGameDataSystem.SetPlayerSpawnFailedMessage
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_SetPlayerSpawnFailedMessage final
{
public:
	class FString                                 InMessage;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_SetPlayerSpawnFailedMessage) == 0x000008, "Wrong alignment on LGameDataSystem_SetPlayerSpawnFailedMessage");
static_assert(sizeof(LGameDataSystem_SetPlayerSpawnFailedMessage) == 0x000010, "Wrong size on LGameDataSystem_SetPlayerSpawnFailedMessage");
static_assert(offsetof(LGameDataSystem_SetPlayerSpawnFailedMessage, InMessage) == 0x000000, "Member 'LGameDataSystem_SetPlayerSpawnFailedMessage::InMessage' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetAccountOpenedRecollection
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_GetAccountOpenedRecollection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetAccountOpenedRecollection) == 0x000001, "Wrong alignment on LGameDataSystem_GetAccountOpenedRecollection");
static_assert(sizeof(LGameDataSystem_GetAccountOpenedRecollection) == 0x000001, "Wrong size on LGameDataSystem_GetAccountOpenedRecollection");
static_assert(offsetof(LGameDataSystem_GetAccountOpenedRecollection, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetAccountOpenedRecollection::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetAccountPlayTime
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetAccountPlayTime final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetAccountPlayTime) == 0x000008, "Wrong alignment on LGameDataSystem_GetAccountPlayTime");
static_assert(sizeof(LGameDataSystem_GetAccountPlayTime) == 0x000010, "Wrong size on LGameDataSystem_GetAccountPlayTime");
static_assert(offsetof(LGameDataSystem_GetAccountPlayTime, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetAccountPlayTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetAccountShowEndingCredit
// 0x0001 (0x0001 - 0x0000)
struct LGameDataSystem_GetAccountShowEndingCredit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetAccountShowEndingCredit) == 0x000001, "Wrong alignment on LGameDataSystem_GetAccountShowEndingCredit");
static_assert(sizeof(LGameDataSystem_GetAccountShowEndingCredit) == 0x000001, "Wrong size on LGameDataSystem_GetAccountShowEndingCredit");
static_assert(offsetof(LGameDataSystem_GetAccountShowEndingCredit, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetAccountShowEndingCredit::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetDeathCount
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetDeathCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetDeathCount) == 0x000004, "Wrong alignment on LGameDataSystem_GetDeathCount");
static_assert(sizeof(LGameDataSystem_GetDeathCount) == 0x000004, "Wrong size on LGameDataSystem_GetDeathCount");
static_assert(offsetof(LGameDataSystem_GetDeathCount, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetDeathCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetPlayTime
// 0x0010 (0x0010 - 0x0000)
struct LGameDataSystem_GetPlayTime final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetPlayTime) == 0x000008, "Wrong alignment on LGameDataSystem_GetPlayTime");
static_assert(sizeof(LGameDataSystem_GetPlayTime) == 0x000010, "Wrong size on LGameDataSystem_GetPlayTime");
static_assert(offsetof(LGameDataSystem_GetPlayTime, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetPlayTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameDataSystem.GetReceiveDamage
// 0x0004 (0x0004 - 0x0000)
struct LGameDataSystem_GetReceiveDamage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameDataSystem_GetReceiveDamage) == 0x000004, "Wrong alignment on LGameDataSystem_GetReceiveDamage");
static_assert(sizeof(LGameDataSystem_GetReceiveDamage) == 0x000004, "Wrong size on LGameDataSystem_GetReceiveDamage");
static_assert(offsetof(LGameDataSystem_GetReceiveDamage, ReturnValue) == 0x000000, "Member 'LGameDataSystem_GetReceiveDamage::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.ApplyControllerDeadZoneMultiply
// 0x0008 (0x0008 - 0x0000)
struct LGamePadOption_ApplyControllerDeadZoneMultiply final
{
public:
	bool                                          InLeftStick;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InValue;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_ApplyControllerDeadZoneMultiply) == 0x000004, "Wrong alignment on LGamePadOption_ApplyControllerDeadZoneMultiply");
static_assert(sizeof(LGamePadOption_ApplyControllerDeadZoneMultiply) == 0x000008, "Wrong size on LGamePadOption_ApplyControllerDeadZoneMultiply");
static_assert(offsetof(LGamePadOption_ApplyControllerDeadZoneMultiply, InLeftStick) == 0x000000, "Member 'LGamePadOption_ApplyControllerDeadZoneMultiply::InLeftStick' has a wrong offset!");
static_assert(offsetof(LGamePadOption_ApplyControllerDeadZoneMultiply, InValue) == 0x000004, "Member 'LGamePadOption_ApplyControllerDeadZoneMultiply::InValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.ApplyControllerForceFeedbackMultiply
// 0x0004 (0x0004 - 0x0000)
struct LGamePadOption_ApplyControllerForceFeedbackMultiply final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_ApplyControllerForceFeedbackMultiply) == 0x000004, "Wrong alignment on LGamePadOption_ApplyControllerForceFeedbackMultiply");
static_assert(sizeof(LGamePadOption_ApplyControllerForceFeedbackMultiply) == 0x000004, "Wrong size on LGamePadOption_ApplyControllerForceFeedbackMultiply");
static_assert(offsetof(LGamePadOption_ApplyControllerForceFeedbackMultiply, InValue) == 0x000000, "Member 'LGamePadOption_ApplyControllerForceFeedbackMultiply::InValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.GetDeadZoneStep
// 0x0008 (0x0008 - 0x0000)
struct LGamePadOption_GetDeadZoneStep final
{
public:
	bool                                          LeftStick;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_GetDeadZoneStep) == 0x000004, "Wrong alignment on LGamePadOption_GetDeadZoneStep");
static_assert(sizeof(LGamePadOption_GetDeadZoneStep) == 0x000008, "Wrong size on LGamePadOption_GetDeadZoneStep");
static_assert(offsetof(LGamePadOption_GetDeadZoneStep, LeftStick) == 0x000000, "Member 'LGamePadOption_GetDeadZoneStep::LeftStick' has a wrong offset!");
static_assert(offsetof(LGamePadOption_GetDeadZoneStep, ReturnValue) == 0x000004, "Member 'LGamePadOption_GetDeadZoneStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.GetForceFeedbackStep
// 0x0004 (0x0004 - 0x0000)
struct LGamePadOption_GetForceFeedbackStep final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_GetForceFeedbackStep) == 0x000004, "Wrong alignment on LGamePadOption_GetForceFeedbackStep");
static_assert(sizeof(LGamePadOption_GetForceFeedbackStep) == 0x000004, "Wrong size on LGamePadOption_GetForceFeedbackStep");
static_assert(offsetof(LGamePadOption_GetForceFeedbackStep, ReturnValue) == 0x000000, "Member 'LGamePadOption_GetForceFeedbackStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.GetMoveSpeedStep
// 0x0008 (0x0008 - 0x0000)
struct LGamePadOption_GetMoveSpeedStep final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_GetMoveSpeedStep) == 0x000004, "Wrong alignment on LGamePadOption_GetMoveSpeedStep");
static_assert(sizeof(LGamePadOption_GetMoveSpeedStep) == 0x000008, "Wrong size on LGamePadOption_GetMoveSpeedStep");
static_assert(offsetof(LGamePadOption_GetMoveSpeedStep, InRotator) == 0x000000, "Member 'LGamePadOption_GetMoveSpeedStep::InRotator' has a wrong offset!");
static_assert(offsetof(LGamePadOption_GetMoveSpeedStep, ReturnValue) == 0x000004, "Member 'LGamePadOption_GetMoveSpeedStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.IsInvertMove
// 0x0002 (0x0002 - 0x0000)
struct LGamePadOption_IsInvertMove final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_IsInvertMove) == 0x000001, "Wrong alignment on LGamePadOption_IsInvertMove");
static_assert(sizeof(LGamePadOption_IsInvertMove) == 0x000002, "Wrong size on LGamePadOption_IsInvertMove");
static_assert(offsetof(LGamePadOption_IsInvertMove, InRotator) == 0x000000, "Member 'LGamePadOption_IsInvertMove::InRotator' has a wrong offset!");
static_assert(offsetof(LGamePadOption_IsInvertMove, ReturnValue) == 0x000001, "Member 'LGamePadOption_IsInvertMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.SetDeadZoneStep
// 0x000C (0x000C - 0x0000)
struct LGamePadOption_SetDeadZoneStep final
{
public:
	bool                                          LeftStick;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InStep;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGamePadOption_SetDeadZoneStep) == 0x000004, "Wrong alignment on LGamePadOption_SetDeadZoneStep");
static_assert(sizeof(LGamePadOption_SetDeadZoneStep) == 0x00000C, "Wrong size on LGamePadOption_SetDeadZoneStep");
static_assert(offsetof(LGamePadOption_SetDeadZoneStep, LeftStick) == 0x000000, "Member 'LGamePadOption_SetDeadZoneStep::LeftStick' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetDeadZoneStep, InStep) == 0x000004, "Member 'LGamePadOption_SetDeadZoneStep::InStep' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetDeadZoneStep, ReturnValue) == 0x000008, "Member 'LGamePadOption_SetDeadZoneStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.SetForceFeedbackStep
// 0x0008 (0x0008 - 0x0000)
struct LGamePadOption_SetForceFeedbackStep final
{
public:
	int32                                         InStep;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGamePadOption_SetForceFeedbackStep) == 0x000004, "Wrong alignment on LGamePadOption_SetForceFeedbackStep");
static_assert(sizeof(LGamePadOption_SetForceFeedbackStep) == 0x000008, "Wrong size on LGamePadOption_SetForceFeedbackStep");
static_assert(offsetof(LGamePadOption_SetForceFeedbackStep, InStep) == 0x000000, "Member 'LGamePadOption_SetForceFeedbackStep::InStep' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetForceFeedbackStep, ReturnValue) == 0x000004, "Member 'LGamePadOption_SetForceFeedbackStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.SetInvertMove
// 0x0003 (0x0003 - 0x0000)
struct LGamePadOption_SetInvertMove final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InInvert;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGamePadOption_SetInvertMove) == 0x000001, "Wrong alignment on LGamePadOption_SetInvertMove");
static_assert(sizeof(LGamePadOption_SetInvertMove) == 0x000003, "Wrong size on LGamePadOption_SetInvertMove");
static_assert(offsetof(LGamePadOption_SetInvertMove, InRotator) == 0x000000, "Member 'LGamePadOption_SetInvertMove::InRotator' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetInvertMove, InInvert) == 0x000001, "Member 'LGamePadOption_SetInvertMove::InInvert' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetInvertMove, ReturnValue) == 0x000002, "Member 'LGamePadOption_SetInvertMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LGamePadOption.SetMoveSpeedStep
// 0x000C (0x000C - 0x0000)
struct LGamePadOption_SetMoveSpeedStep final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InStep;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGamePadOption_SetMoveSpeedStep) == 0x000004, "Wrong alignment on LGamePadOption_SetMoveSpeedStep");
static_assert(sizeof(LGamePadOption_SetMoveSpeedStep) == 0x00000C, "Wrong size on LGamePadOption_SetMoveSpeedStep");
static_assert(offsetof(LGamePadOption_SetMoveSpeedStep, InRotator) == 0x000000, "Member 'LGamePadOption_SetMoveSpeedStep::InRotator' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetMoveSpeedStep, InStep) == 0x000004, "Member 'LGamePadOption_SetMoveSpeedStep::InStep' has a wrong offset!");
static_assert(offsetof(LGamePadOption_SetMoveSpeedStep, ReturnValue) == 0x000008, "Member 'LGamePadOption_SetMoveSpeedStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameInstance.ActiveGameSystemForTest
// 0x0001 (0x0001 - 0x0000)
struct LGameInstance_ActiveGameSystemForTest final
{
public:
	ELGameSubSystemActiveType                     ActiveType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameInstance_ActiveGameSystemForTest) == 0x000001, "Wrong alignment on LGameInstance_ActiveGameSystemForTest");
static_assert(sizeof(LGameInstance_ActiveGameSystemForTest) == 0x000001, "Wrong size on LGameInstance_ActiveGameSystemForTest");
static_assert(offsetof(LGameInstance_ActiveGameSystemForTest, ActiveType) == 0x000000, "Member 'LGameInstance_ActiveGameSystemForTest::ActiveType' has a wrong offset!");

// Function ProjectP.LGameInstance.ExecBP
// 0x0020 (0x0020 - 0x0000)
struct LGameInstance_ExecBP final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Cmd;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGameInstance_ExecBP) == 0x000008, "Wrong alignment on LGameInstance_ExecBP");
static_assert(sizeof(LGameInstance_ExecBP) == 0x000020, "Wrong size on LGameInstance_ExecBP");
static_assert(offsetof(LGameInstance_ExecBP, InWorld) == 0x000000, "Member 'LGameInstance_ExecBP::InWorld' has a wrong offset!");
static_assert(offsetof(LGameInstance_ExecBP, Cmd) == 0x000008, "Member 'LGameInstance_ExecBP::Cmd' has a wrong offset!");
static_assert(offsetof(LGameInstance_ExecBP, ReturnValue) == 0x000018, "Member 'LGameInstance_ExecBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameInstance.GetEmptyPulseGauge
// 0x0010 (0x0010 - 0x0000)
struct LGameInstance_GetEmptyPulseGauge final
{
public:
	int32                                         EmptyPulseCount;                                   // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmptyPulseGauge_Current;                           // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmptyPulseGauge_Max;                               // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmptyPulseGauge_DefatltMax;                        // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameInstance_GetEmptyPulseGauge) == 0x000004, "Wrong alignment on LGameInstance_GetEmptyPulseGauge");
static_assert(sizeof(LGameInstance_GetEmptyPulseGauge) == 0x000010, "Wrong size on LGameInstance_GetEmptyPulseGauge");
static_assert(offsetof(LGameInstance_GetEmptyPulseGauge, EmptyPulseCount) == 0x000000, "Member 'LGameInstance_GetEmptyPulseGauge::EmptyPulseCount' has a wrong offset!");
static_assert(offsetof(LGameInstance_GetEmptyPulseGauge, EmptyPulseGauge_Current) == 0x000004, "Member 'LGameInstance_GetEmptyPulseGauge::EmptyPulseGauge_Current' has a wrong offset!");
static_assert(offsetof(LGameInstance_GetEmptyPulseGauge, EmptyPulseGauge_Max) == 0x000008, "Member 'LGameInstance_GetEmptyPulseGauge::EmptyPulseGauge_Max' has a wrong offset!");
static_assert(offsetof(LGameInstance_GetEmptyPulseGauge, EmptyPulseGauge_DefatltMax) == 0x00000C, "Member 'LGameInstance_GetEmptyPulseGauge::EmptyPulseGauge_DefatltMax' has a wrong offset!");

// Function ProjectP.LGameInstance.GetGameState
// 0x0001 (0x0001 - 0x0000)
struct LGameInstance_GetGameState final
{
public:
	EPNGameState                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameInstance_GetGameState) == 0x000001, "Wrong alignment on LGameInstance_GetGameState");
static_assert(sizeof(LGameInstance_GetGameState) == 0x000001, "Wrong size on LGameInstance_GetGameState");
static_assert(offsetof(LGameInstance_GetGameState, ReturnValue) == 0x000000, "Member 'LGameInstance_GetGameState::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameInstance.IsPlayState
// 0x0001 (0x0001 - 0x0000)
struct LGameInstance_IsPlayState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameInstance_IsPlayState) == 0x000001, "Wrong alignment on LGameInstance_IsPlayState");
static_assert(sizeof(LGameInstance_IsPlayState) == 0x000001, "Wrong size on LGameInstance_IsPlayState");
static_assert(offsetof(LGameInstance_IsPlayState, ReturnValue) == 0x000000, "Member 'LGameInstance_IsPlayState::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameInstance.MakeNewCharacterBP
// 0x0001 (0x0001 - 0x0000)
struct LGameInstance_MakeNewCharacterBP final
{
public:
	bool                                          bInEditor;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameInstance_MakeNewCharacterBP) == 0x000001, "Wrong alignment on LGameInstance_MakeNewCharacterBP");
static_assert(sizeof(LGameInstance_MakeNewCharacterBP) == 0x000001, "Wrong size on LGameInstance_MakeNewCharacterBP");
static_assert(offsetof(LGameInstance_MakeNewCharacterBP, bInEditor) == 0x000000, "Member 'LGameInstance_MakeNewCharacterBP::bInEditor' has a wrong offset!");

// Function ProjectP.LGameInstance.OnChangeGameState
// 0x0002 (0x0002 - 0x0000)
struct LGameInstance_OnChangeGameState final
{
public:
	EPNGameState                                  InGameState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExecuteInGameMode;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameInstance_OnChangeGameState) == 0x000001, "Wrong alignment on LGameInstance_OnChangeGameState");
static_assert(sizeof(LGameInstance_OnChangeGameState) == 0x000002, "Wrong size on LGameInstance_OnChangeGameState");
static_assert(offsetof(LGameInstance_OnChangeGameState, InGameState) == 0x000000, "Member 'LGameInstance_OnChangeGameState::InGameState' has a wrong offset!");
static_assert(offsetof(LGameInstance_OnChangeGameState, ExecuteInGameMode) == 0x000001, "Member 'LGameInstance_OnChangeGameState::ExecuteInGameMode' has a wrong offset!");

// Function ProjectP.LItemDropSystemData.SpawnDropErgoData
// 0x0030 (0x0030 - 0x0000)
struct LItemDropSystemData_SpawnDropErgoData final
{
public:
	struct FLDropErgoData                         DropErgoData;                                      // 0x0000(0x0030)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemDropSystemData_SpawnDropErgoData) == 0x000008, "Wrong alignment on LItemDropSystemData_SpawnDropErgoData");
static_assert(sizeof(LItemDropSystemData_SpawnDropErgoData) == 0x000030, "Wrong size on LItemDropSystemData_SpawnDropErgoData");
static_assert(offsetof(LItemDropSystemData_SpawnDropErgoData, DropErgoData) == 0x000000, "Member 'LItemDropSystemData_SpawnDropErgoData::DropErgoData' has a wrong offset!");

// Function ProjectP.LGameSettings.CanHotKey
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_CanHotKey final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_CanHotKey) == 0x000001, "Wrong alignment on LGameSettings_CanHotKey");
static_assert(sizeof(LGameSettings_CanHotKey) == 0x000001, "Wrong size on LGameSettings_CanHotKey");
static_assert(offsetof(LGameSettings_CanHotKey, ReturnValue) == 0x000000, "Member 'LGameSettings_CanHotKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.CanPreload
// 0x0002 (0x0002 - 0x0000)
struct LGameSettings_CanPreload final
{
public:
	ELPreloadUsage                                Usage;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_CanPreload) == 0x000001, "Wrong alignment on LGameSettings_CanPreload");
static_assert(sizeof(LGameSettings_CanPreload) == 0x000002, "Wrong size on LGameSettings_CanPreload");
static_assert(offsetof(LGameSettings_CanPreload, Usage) == 0x000000, "Member 'LGameSettings_CanPreload::Usage' has a wrong offset!");
static_assert(offsetof(LGameSettings_CanPreload, ReturnValue) == 0x000001, "Member 'LGameSettings_CanPreload::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.CheckGameCommand
// 0x0002 (0x0002 - 0x0000)
struct LGameSettings_CheckGameCommand final
{
public:
	ELGameCommandCategory                         CommandCategory;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_CheckGameCommand) == 0x000001, "Wrong alignment on LGameSettings_CheckGameCommand");
static_assert(sizeof(LGameSettings_CheckGameCommand) == 0x000002, "Wrong size on LGameSettings_CheckGameCommand");
static_assert(offsetof(LGameSettings_CheckGameCommand, CommandCategory) == 0x000000, "Member 'LGameSettings_CheckGameCommand::CommandCategory' has a wrong offset!");
static_assert(offsetof(LGameSettings_CheckGameCommand, ReturnValue) == 0x000001, "Member 'LGameSettings_CheckGameCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsBoostAI
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsBoostAI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsBoostAI) == 0x000001, "Wrong alignment on LGameSettings_IsBoostAI");
static_assert(sizeof(LGameSettings_IsBoostAI) == 0x000001, "Wrong size on LGameSettings_IsBoostAI");
static_assert(offsetof(LGameSettings_IsBoostAI, ReturnValue) == 0x000000, "Member 'LGameSettings_IsBoostAI::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsEasyMode
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsEasyMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsEasyMode) == 0x000001, "Wrong alignment on LGameSettings_IsEasyMode");
static_assert(sizeof(LGameSettings_IsEasyMode) == 0x000001, "Wrong size on LGameSettings_IsEasyMode");
static_assert(offsetof(LGameSettings_IsEasyMode, ReturnValue) == 0x000000, "Member 'LGameSettings_IsEasyMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsEnableActivationSystemV2
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsEnableActivationSystemV2 final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsEnableActivationSystemV2) == 0x000001, "Wrong alignment on LGameSettings_IsEnableActivationSystemV2");
static_assert(sizeof(LGameSettings_IsEnableActivationSystemV2) == 0x000001, "Wrong size on LGameSettings_IsEnableActivationSystemV2");
static_assert(offsetof(LGameSettings_IsEnableActivationSystemV2, ReturnValue) == 0x000000, "Member 'LGameSettings_IsEnableActivationSystemV2::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsGameDayBuild
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsGameDayBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsGameDayBuild) == 0x000001, "Wrong alignment on LGameSettings_IsGameDayBuild");
static_assert(sizeof(LGameSettings_IsGameDayBuild) == 0x000001, "Wrong size on LGameSettings_IsGameDayBuild");
static_assert(offsetof(LGameSettings_IsGameDayBuild, ReturnValue) == 0x000000, "Member 'LGameSettings_IsGameDayBuild::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsNeowizAuth
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsNeowizAuth final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsNeowizAuth) == 0x000001, "Wrong alignment on LGameSettings_IsNeowizAuth");
static_assert(sizeof(LGameSettings_IsNeowizAuth) == 0x000001, "Wrong size on LGameSettings_IsNeowizAuth");
static_assert(offsetof(LGameSettings_IsNeowizAuth, ReturnValue) == 0x000000, "Member 'LGameSettings_IsNeowizAuth::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsUseActionGroupBuildData
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsUseActionGroupBuildData final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsUseActionGroupBuildData) == 0x000001, "Wrong alignment on LGameSettings_IsUseActionGroupBuildData");
static_assert(sizeof(LGameSettings_IsUseActionGroupBuildData) == 0x000001, "Wrong size on LGameSettings_IsUseActionGroupBuildData");
static_assert(offsetof(LGameSettings_IsUseActionGroupBuildData, ReturnValue) == 0x000000, "Member 'LGameSettings_IsUseActionGroupBuildData::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.IsUseLevelStreaming
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_IsUseLevelStreaming final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_IsUseLevelStreaming) == 0x000001, "Wrong alignment on LGameSettings_IsUseLevelStreaming");
static_assert(sizeof(LGameSettings_IsUseLevelStreaming) == 0x000001, "Wrong size on LGameSettings_IsUseLevelStreaming");
static_assert(offsetof(LGameSettings_IsUseLevelStreaming, ReturnValue) == 0x000000, "Member 'LGameSettings_IsUseLevelStreaming::ReturnValue' has a wrong offset!");

// Function ProjectP.LGameSettings.SetEasyModeEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGameSettings_SetEasyModeEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGameSettings_SetEasyModeEnabled) == 0x000001, "Wrong alignment on LGameSettings_SetEasyModeEnabled");
static_assert(sizeof(LGameSettings_SetEasyModeEnabled) == 0x000001, "Wrong size on LGameSettings_SetEasyModeEnabled");
static_assert(offsetof(LGameSettings_SetEasyModeEnabled, bEnable) == 0x000000, "Member 'LGameSettings_SetEasyModeEnabled::bEnable' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_AssistUseItemDown
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_AssistUseItemDown final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_AssistUseItemDown) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_AssistUseItemDown");
static_assert(sizeof(LInputCommand_InputCommand_AssistUseItemDown) == 0x000008, "Wrong size on LInputCommand_InputCommand_AssistUseItemDown");
static_assert(offsetof(LInputCommand_InputCommand_AssistUseItemDown, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_AssistUseItemDown::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_AssistUseItemLeft
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_AssistUseItemLeft final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_AssistUseItemLeft) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_AssistUseItemLeft");
static_assert(sizeof(LInputCommand_InputCommand_AssistUseItemLeft) == 0x000008, "Wrong size on LInputCommand_InputCommand_AssistUseItemLeft");
static_assert(offsetof(LInputCommand_InputCommand_AssistUseItemLeft, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_AssistUseItemLeft::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_AssistUseItemRight
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_AssistUseItemRight final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_AssistUseItemRight) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_AssistUseItemRight");
static_assert(sizeof(LInputCommand_InputCommand_AssistUseItemRight) == 0x000008, "Wrong size on LInputCommand_InputCommand_AssistUseItemRight");
static_assert(offsetof(LInputCommand_InputCommand_AssistUseItemRight, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_AssistUseItemRight::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_AssistUseItemUp
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_AssistUseItemUp final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_AssistUseItemUp) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_AssistUseItemUp");
static_assert(sizeof(LInputCommand_InputCommand_AssistUseItemUp) == 0x000008, "Wrong size on LInputCommand_InputCommand_AssistUseItemUp");
static_assert(offsetof(LInputCommand_InputCommand_AssistUseItemUp, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_AssistUseItemUp::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_ChargeCancel
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_ChargeCancel final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_ChargeCancel) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_ChargeCancel");
static_assert(sizeof(LInputCommand_InputCommand_ChargeCancel) == 0x000008, "Wrong size on LInputCommand_InputCommand_ChargeCancel");
static_assert(offsetof(LInputCommand_InputCommand_ChargeCancel, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_ChargeCancel::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_Dash
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_Dash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_Dash) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_Dash");
static_assert(sizeof(LInputCommand_InputCommand_Dash) == 0x000008, "Wrong size on LInputCommand_InputCommand_Dash");
static_assert(offsetof(LInputCommand_InputCommand_Dash, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_Dash::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_DirectLockOnDash
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_DirectLockOnDash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_DirectLockOnDash) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_DirectLockOnDash");
static_assert(sizeof(LInputCommand_InputCommand_DirectLockOnDash) == 0x000008, "Wrong size on LInputCommand_InputCommand_DirectLockOnDash");
static_assert(offsetof(LInputCommand_InputCommand_DirectLockOnDash, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_DirectLockOnDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_DisableSprint
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_DisableSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_DisableSprint) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_DisableSprint");
static_assert(sizeof(LInputCommand_InputCommand_DisableSprint) == 0x000008, "Wrong size on LInputCommand_InputCommand_DisableSprint");
static_assert(offsetof(LInputCommand_InputCommand_DisableSprint, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_DisableSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_EnableSprint
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_EnableSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_EnableSprint) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_EnableSprint");
static_assert(sizeof(LInputCommand_InputCommand_EnableSprint) == 0x000008, "Wrong size on LInputCommand_InputCommand_EnableSprint");
static_assert(offsetof(LInputCommand_InputCommand_EnableSprint, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_EnableSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_FableHandle
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_FableHandle final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_FableHandle) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_FableHandle");
static_assert(sizeof(LInputCommand_InputCommand_FableHandle) == 0x000008, "Wrong size on LInputCommand_InputCommand_FableHandle");
static_assert(offsetof(LInputCommand_InputCommand_FableHandle, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_FableHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_FableHandle_OnGuardHit
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_FableHandle_OnGuardHit final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_FableHandle_OnGuardHit) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_FableHandle_OnGuardHit");
static_assert(sizeof(LInputCommand_InputCommand_FableHandle_OnGuardHit) == 0x000008, "Wrong size on LInputCommand_InputCommand_FableHandle_OnGuardHit");
static_assert(offsetof(LInputCommand_InputCommand_FableHandle_OnGuardHit, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_FableHandle_OnGuardHit::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_Frenzy
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_Frenzy final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_Frenzy) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_Frenzy");
static_assert(sizeof(LInputCommand_InputCommand_Frenzy) == 0x000008, "Wrong size on LInputCommand_InputCommand_Frenzy");
static_assert(offsetof(LInputCommand_InputCommand_Frenzy, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_Frenzy::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_FrenzyRelease
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_FrenzyRelease final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_FrenzyRelease) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_FrenzyRelease");
static_assert(sizeof(LInputCommand_InputCommand_FrenzyRelease) == 0x000008, "Wrong size on LInputCommand_InputCommand_FrenzyRelease");
static_assert(offsetof(LInputCommand_InputCommand_FrenzyRelease, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_FrenzyRelease::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_Guard
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_Guard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_Guard) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_Guard");
static_assert(sizeof(LInputCommand_InputCommand_Guard) == 0x000008, "Wrong size on LInputCommand_InputCommand_Guard");
static_assert(offsetof(LInputCommand_InputCommand_Guard, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_Guard::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_GuardEnd
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_GuardEnd final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_GuardEnd) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_GuardEnd");
static_assert(sizeof(LInputCommand_InputCommand_GuardEnd) == 0x000008, "Wrong size on LInputCommand_InputCommand_GuardEnd");
static_assert(offsetof(LInputCommand_InputCommand_GuardEnd, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_GuardEnd::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_LightAttack
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_LightAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_LightAttack) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_LightAttack");
static_assert(sizeof(LInputCommand_InputCommand_LightAttack) == 0x000008, "Wrong size on LInputCommand_InputCommand_LightAttack");
static_assert(offsetof(LInputCommand_InputCommand_LightAttack, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_LightAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_None
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_None final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_None) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_None");
static_assert(sizeof(LInputCommand_InputCommand_None) == 0x000008, "Wrong size on LInputCommand_InputCommand_None");
static_assert(offsetof(LInputCommand_InputCommand_None, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_None::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_ObjectInteraction
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_ObjectInteraction final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_ObjectInteraction) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_ObjectInteraction");
static_assert(sizeof(LInputCommand_InputCommand_ObjectInteraction) == 0x000008, "Wrong size on LInputCommand_InputCommand_ObjectInteraction");
static_assert(offsetof(LInputCommand_InputCommand_ObjectInteraction, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_ObjectInteraction::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_ParryDash
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_ParryDash final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_ParryDash) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_ParryDash");
static_assert(sizeof(LInputCommand_InputCommand_ParryDash) == 0x000008, "Wrong size on LInputCommand_InputCommand_ParryDash");
static_assert(offsetof(LInputCommand_InputCommand_ParryDash, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_ParryDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_ParryGuard
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_ParryGuard final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_ParryGuard) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_ParryGuard");
static_assert(sizeof(LInputCommand_InputCommand_ParryGuard) == 0x000008, "Wrong size on LInputCommand_InputCommand_ParryGuard");
static_assert(offsetof(LInputCommand_InputCommand_ParryGuard, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_ParryGuard::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_Parrying
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_Parrying final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_Parrying) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_Parrying");
static_assert(sizeof(LInputCommand_InputCommand_Parrying) == 0x000008, "Wrong size on LInputCommand_InputCommand_Parrying");
static_assert(offsetof(LInputCommand_InputCommand_Parrying, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_Parrying::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_SlaveArmPress
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_SlaveArmPress final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_SlaveArmPress) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_SlaveArmPress");
static_assert(sizeof(LInputCommand_InputCommand_SlaveArmPress) == 0x000008, "Wrong size on LInputCommand_InputCommand_SlaveArmPress");
static_assert(offsetof(LInputCommand_InputCommand_SlaveArmPress, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_SlaveArmPress::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_SlaveArmRelease
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_SlaveArmRelease final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_SlaveArmRelease) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_SlaveArmRelease");
static_assert(sizeof(LInputCommand_InputCommand_SlaveArmRelease) == 0x000008, "Wrong size on LInputCommand_InputCommand_SlaveArmRelease");
static_assert(offsetof(LInputCommand_InputCommand_SlaveArmRelease, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_SlaveArmRelease::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_StartSprint
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_StartSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_StartSprint) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_StartSprint");
static_assert(sizeof(LInputCommand_InputCommand_StartSprint) == 0x000008, "Wrong size on LInputCommand_InputCommand_StartSprint");
static_assert(offsetof(LInputCommand_InputCommand_StartSprint, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_StartSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_StartTurning
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_StartTurning final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_StartTurning) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_StartTurning");
static_assert(sizeof(LInputCommand_InputCommand_StartTurning) == 0x000008, "Wrong size on LInputCommand_InputCommand_StartTurning");
static_assert(offsetof(LInputCommand_InputCommand_StartTurning, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_StartTurning::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_StopRunning
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_StopRunning final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_StopRunning) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_StopRunning");
static_assert(sizeof(LInputCommand_InputCommand_StopRunning) == 0x000008, "Wrong size on LInputCommand_InputCommand_StopRunning");
static_assert(offsetof(LInputCommand_InputCommand_StopRunning, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_StopRunning::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_StopSprint
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_StopSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_StopSprint) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_StopSprint");
static_assert(sizeof(LInputCommand_InputCommand_StopSprint) == 0x000008, "Wrong size on LInputCommand_InputCommand_StopSprint");
static_assert(offsetof(LInputCommand_InputCommand_StopSprint, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_StopSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_StopTurning
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_StopTurning final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_StopTurning) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_StopTurning");
static_assert(sizeof(LInputCommand_InputCommand_StopTurning) == 0x000008, "Wrong size on LInputCommand_InputCommand_StopTurning");
static_assert(offsetof(LInputCommand_InputCommand_StopTurning, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_StopTurning::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_StrongAttack
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_StrongAttack final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_StrongAttack) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_StrongAttack");
static_assert(sizeof(LInputCommand_InputCommand_StrongAttack) == 0x000008, "Wrong size on LInputCommand_InputCommand_StrongAttack");
static_assert(offsetof(LInputCommand_InputCommand_StrongAttack, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_StrongAttack::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_ToggleWalkMode
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_ToggleWalkMode final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_ToggleWalkMode) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_ToggleWalkMode");
static_assert(sizeof(LInputCommand_InputCommand_ToggleWalkMode) == 0x000008, "Wrong size on LInputCommand_InputCommand_ToggleWalkMode");
static_assert(offsetof(LInputCommand_InputCommand_ToggleWalkMode, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_ToggleWalkMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_TurnSprint
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_TurnSprint final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_TurnSprint) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_TurnSprint");
static_assert(sizeof(LInputCommand_InputCommand_TurnSprint) == 0x000008, "Wrong size on LInputCommand_InputCommand_TurnSprint");
static_assert(offsetof(LInputCommand_InputCommand_TurnSprint, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_TurnSprint::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_UseItem
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_UseItem final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_UseItem) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_UseItem");
static_assert(sizeof(LInputCommand_InputCommand_UseItem) == 0x000008, "Wrong size on LInputCommand_InputCommand_UseItem");
static_assert(offsetof(LInputCommand_InputCommand_UseItem, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_UseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_WeaponChange
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_WeaponChange final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_WeaponChange) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_WeaponChange");
static_assert(sizeof(LInputCommand_InputCommand_WeaponChange) == 0x000008, "Wrong size on LInputCommand_InputCommand_WeaponChange");
static_assert(offsetof(LInputCommand_InputCommand_WeaponChange, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_WeaponChange::ReturnValue' has a wrong offset!");

// Function ProjectP.LInputCommand.InputCommand_WeaponChangePrevious
// 0x0008 (0x0008 - 0x0000)
struct LInputCommand_InputCommand_WeaponChangePrevious final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInputCommand_InputCommand_WeaponChangePrevious) == 0x000004, "Wrong alignment on LInputCommand_InputCommand_WeaponChangePrevious");
static_assert(sizeof(LInputCommand_InputCommand_WeaponChangePrevious) == 0x000008, "Wrong size on LInputCommand_InputCommand_WeaponChangePrevious");
static_assert(offsetof(LInputCommand_InputCommand_WeaponChangePrevious, ReturnValue) == 0x000000, "Member 'LInputCommand_InputCommand_WeaponChangePrevious::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetCurrentLanguage
// 0x0010 (0x0010 - 0x0000)
struct LPlayOption_GetCurrentLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetCurrentLanguage) == 0x000008, "Wrong alignment on LPlayOption_GetCurrentLanguage");
static_assert(sizeof(LPlayOption_GetCurrentLanguage) == 0x000010, "Wrong size on LPlayOption_GetCurrentLanguage");
static_assert(offsetof(LPlayOption_GetCurrentLanguage, ReturnValue) == 0x000000, "Member 'LPlayOption_GetCurrentLanguage::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetEnableTutorialPopup
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_GetEnableTutorialPopup final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetEnableTutorialPopup) == 0x000001, "Wrong alignment on LPlayOption_GetEnableTutorialPopup");
static_assert(sizeof(LPlayOption_GetEnableTutorialPopup) == 0x000001, "Wrong size on LPlayOption_GetEnableTutorialPopup");
static_assert(offsetof(LPlayOption_GetEnableTutorialPopup, ReturnValue) == 0x000000, "Member 'LPlayOption_GetEnableTutorialPopup::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetHUDVisibility
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_GetHUDVisibility final
{
public:
	ELHUDVisible                                  ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetHUDVisibility) == 0x000001, "Wrong alignment on LPlayOption_GetHUDVisibility");
static_assert(sizeof(LPlayOption_GetHUDVisibility) == 0x000001, "Wrong size on LPlayOption_GetHUDVisibility");
static_assert(offsetof(LPlayOption_GetHUDVisibility, ReturnValue) == 0x000000, "Member 'LPlayOption_GetHUDVisibility::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetLanguageStep
// 0x0004 (0x0004 - 0x0000)
struct LPlayOption_GetLanguageStep final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetLanguageStep) == 0x000004, "Wrong alignment on LPlayOption_GetLanguageStep");
static_assert(sizeof(LPlayOption_GetLanguageStep) == 0x000004, "Wrong size on LPlayOption_GetLanguageStep");
static_assert(offsetof(LPlayOption_GetLanguageStep, ReturnValue) == 0x000000, "Member 'LPlayOption_GetLanguageStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetLockOnImportanceWeightMultiply
// 0x0004 (0x0004 - 0x0000)
struct LPlayOption_GetLockOnImportanceWeightMultiply final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetLockOnImportanceWeightMultiply) == 0x000004, "Wrong alignment on LPlayOption_GetLockOnImportanceWeightMultiply");
static_assert(sizeof(LPlayOption_GetLockOnImportanceWeightMultiply) == 0x000004, "Wrong size on LPlayOption_GetLockOnImportanceWeightMultiply");
static_assert(offsetof(LPlayOption_GetLockOnImportanceWeightMultiply, ReturnValue) == 0x000000, "Member 'LPlayOption_GetLockOnImportanceWeightMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetSelectableLanguages
// 0x0010 (0x0010 - 0x0000)
struct LPlayOption_GetSelectableLanguages final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetSelectableLanguages) == 0x000008, "Wrong alignment on LPlayOption_GetSelectableLanguages");
static_assert(sizeof(LPlayOption_GetSelectableLanguages) == 0x000010, "Wrong size on LPlayOption_GetSelectableLanguages");
static_assert(offsetof(LPlayOption_GetSelectableLanguages, ReturnValue) == 0x000000, "Member 'LPlayOption_GetSelectableLanguages::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetSubtitleSize
// 0x0004 (0x0004 - 0x0000)
struct LPlayOption_GetSubtitleSize final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetSubtitleSize) == 0x000004, "Wrong alignment on LPlayOption_GetSubtitleSize");
static_assert(sizeof(LPlayOption_GetSubtitleSize) == 0x000004, "Wrong size on LPlayOption_GetSubtitleSize");
static_assert(offsetof(LPlayOption_GetSubtitleSize, ReturnValue) == 0x000000, "Member 'LPlayOption_GetSubtitleSize::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetUseAutoNewTargetLockOn
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_GetUseAutoNewTargetLockOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetUseAutoNewTargetLockOn) == 0x000001, "Wrong alignment on LPlayOption_GetUseAutoNewTargetLockOn");
static_assert(sizeof(LPlayOption_GetUseAutoNewTargetLockOn) == 0x000001, "Wrong size on LPlayOption_GetUseAutoNewTargetLockOn");
static_assert(offsetof(LPlayOption_GetUseAutoNewTargetLockOn, ReturnValue) == 0x000000, "Member 'LPlayOption_GetUseAutoNewTargetLockOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.GetUseAutoTargeting
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_GetUseAutoTargeting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_GetUseAutoTargeting) == 0x000001, "Wrong alignment on LPlayOption_GetUseAutoTargeting");
static_assert(sizeof(LPlayOption_GetUseAutoTargeting) == 0x000001, "Wrong size on LPlayOption_GetUseAutoTargeting");
static_assert(offsetof(LPlayOption_GetUseAutoTargeting, ReturnValue) == 0x000000, "Member 'LPlayOption_GetUseAutoTargeting::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.IsBloodExpressionEnabled
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_IsBloodExpressionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_IsBloodExpressionEnabled) == 0x000001, "Wrong alignment on LPlayOption_IsBloodExpressionEnabled");
static_assert(sizeof(LPlayOption_IsBloodExpressionEnabled) == 0x000001, "Wrong size on LPlayOption_IsBloodExpressionEnabled");
static_assert(offsetof(LPlayOption_IsBloodExpressionEnabled, ReturnValue) == 0x000000, "Member 'LPlayOption_IsBloodExpressionEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.IsDirectLockOnDash
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_IsDirectLockOnDash final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_IsDirectLockOnDash) == 0x000001, "Wrong alignment on LPlayOption_IsDirectLockOnDash");
static_assert(sizeof(LPlayOption_IsDirectLockOnDash) == 0x000001, "Wrong size on LPlayOption_IsDirectLockOnDash");
static_assert(offsetof(LPlayOption_IsDirectLockOnDash, ReturnValue) == 0x000000, "Member 'LPlayOption_IsDirectLockOnDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.IsMotionBlurEnabled
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_IsMotionBlurEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_IsMotionBlurEnabled) == 0x000001, "Wrong alignment on LPlayOption_IsMotionBlurEnabled");
static_assert(sizeof(LPlayOption_IsMotionBlurEnabled) == 0x000001, "Wrong size on LPlayOption_IsMotionBlurEnabled");
static_assert(offsetof(LPlayOption_IsMotionBlurEnabled, ReturnValue) == 0x000000, "Member 'LPlayOption_IsMotionBlurEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.IsVideoSubtitleEnabled
// 0x0001 (0x0001 - 0x0000)
struct LPlayOption_IsVideoSubtitleEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_IsVideoSubtitleEnabled) == 0x000001, "Wrong alignment on LPlayOption_IsVideoSubtitleEnabled");
static_assert(sizeof(LPlayOption_IsVideoSubtitleEnabled) == 0x000001, "Wrong size on LPlayOption_IsVideoSubtitleEnabled");
static_assert(offsetof(LPlayOption_IsVideoSubtitleEnabled, ReturnValue) == 0x000000, "Member 'LPlayOption_IsVideoSubtitleEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetDirectLockOnDash
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetDirectLockOnDash final
{
public:
	bool                                          TurnOn;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetDirectLockOnDash) == 0x000001, "Wrong alignment on LPlayOption_SetDirectLockOnDash");
static_assert(sizeof(LPlayOption_SetDirectLockOnDash) == 0x000002, "Wrong size on LPlayOption_SetDirectLockOnDash");
static_assert(offsetof(LPlayOption_SetDirectLockOnDash, TurnOn) == 0x000000, "Member 'LPlayOption_SetDirectLockOnDash::TurnOn' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetDirectLockOnDash, ReturnValue) == 0x000001, "Member 'LPlayOption_SetDirectLockOnDash::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetEnableBloodExpression
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetEnableBloodExpression final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetEnableBloodExpression) == 0x000001, "Wrong alignment on LPlayOption_SetEnableBloodExpression");
static_assert(sizeof(LPlayOption_SetEnableBloodExpression) == 0x000002, "Wrong size on LPlayOption_SetEnableBloodExpression");
static_assert(offsetof(LPlayOption_SetEnableBloodExpression, InEnable) == 0x000000, "Member 'LPlayOption_SetEnableBloodExpression::InEnable' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetEnableBloodExpression, ReturnValue) == 0x000001, "Member 'LPlayOption_SetEnableBloodExpression::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetEnableTutorialPopup
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetEnableTutorialPopup final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetEnableTutorialPopup) == 0x000001, "Wrong alignment on LPlayOption_SetEnableTutorialPopup");
static_assert(sizeof(LPlayOption_SetEnableTutorialPopup) == 0x000002, "Wrong size on LPlayOption_SetEnableTutorialPopup");
static_assert(offsetof(LPlayOption_SetEnableTutorialPopup, Enable) == 0x000000, "Member 'LPlayOption_SetEnableTutorialPopup::Enable' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetEnableTutorialPopup, ReturnValue) == 0x000001, "Member 'LPlayOption_SetEnableTutorialPopup::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetEnableVideoSubtitle
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetEnableVideoSubtitle final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetEnableVideoSubtitle) == 0x000001, "Wrong alignment on LPlayOption_SetEnableVideoSubtitle");
static_assert(sizeof(LPlayOption_SetEnableVideoSubtitle) == 0x000002, "Wrong size on LPlayOption_SetEnableVideoSubtitle");
static_assert(offsetof(LPlayOption_SetEnableVideoSubtitle, InEnable) == 0x000000, "Member 'LPlayOption_SetEnableVideoSubtitle::InEnable' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetEnableVideoSubtitle, ReturnValue) == 0x000001, "Member 'LPlayOption_SetEnableVideoSubtitle::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetHUDVisibility
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetHUDVisibility final
{
public:
	ELHUDVisible                                  InVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetHUDVisibility) == 0x000001, "Wrong alignment on LPlayOption_SetHUDVisibility");
static_assert(sizeof(LPlayOption_SetHUDVisibility) == 0x000002, "Wrong size on LPlayOption_SetHUDVisibility");
static_assert(offsetof(LPlayOption_SetHUDVisibility, InVisible) == 0x000000, "Member 'LPlayOption_SetHUDVisibility::InVisible' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetHUDVisibility, ReturnValue) == 0x000001, "Member 'LPlayOption_SetHUDVisibility::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetLanguageStep
// 0x0008 (0x0008 - 0x0000)
struct LPlayOption_SetLanguageStep final
{
public:
	int32                                         InStep;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayOption_SetLanguageStep) == 0x000004, "Wrong alignment on LPlayOption_SetLanguageStep");
static_assert(sizeof(LPlayOption_SetLanguageStep) == 0x000008, "Wrong size on LPlayOption_SetLanguageStep");
static_assert(offsetof(LPlayOption_SetLanguageStep, InStep) == 0x000000, "Member 'LPlayOption_SetLanguageStep::InStep' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetLanguageStep, ReturnValue) == 0x000004, "Member 'LPlayOption_SetLanguageStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetLockOnImportanceWeightMultiply
// 0x0008 (0x0008 - 0x0000)
struct LPlayOption_SetLockOnImportanceWeightMultiply final
{
public:
	int32                                         InStep;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayOption_SetLockOnImportanceWeightMultiply) == 0x000004, "Wrong alignment on LPlayOption_SetLockOnImportanceWeightMultiply");
static_assert(sizeof(LPlayOption_SetLockOnImportanceWeightMultiply) == 0x000008, "Wrong size on LPlayOption_SetLockOnImportanceWeightMultiply");
static_assert(offsetof(LPlayOption_SetLockOnImportanceWeightMultiply, InStep) == 0x000000, "Member 'LPlayOption_SetLockOnImportanceWeightMultiply::InStep' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetLockOnImportanceWeightMultiply, ReturnValue) == 0x000004, "Member 'LPlayOption_SetLockOnImportanceWeightMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetMotionBlurEnabled
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetMotionBlurEnabled final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetMotionBlurEnabled) == 0x000001, "Wrong alignment on LPlayOption_SetMotionBlurEnabled");
static_assert(sizeof(LPlayOption_SetMotionBlurEnabled) == 0x000002, "Wrong size on LPlayOption_SetMotionBlurEnabled");
static_assert(offsetof(LPlayOption_SetMotionBlurEnabled, InEnable) == 0x000000, "Member 'LPlayOption_SetMotionBlurEnabled::InEnable' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetMotionBlurEnabled, ReturnValue) == 0x000001, "Member 'LPlayOption_SetMotionBlurEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetSubtitleSize
// 0x0008 (0x0008 - 0x0000)
struct LPlayOption_SetSubtitleSize final
{
public:
	int32                                         InSubtitleSize;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayOption_SetSubtitleSize) == 0x000004, "Wrong alignment on LPlayOption_SetSubtitleSize");
static_assert(sizeof(LPlayOption_SetSubtitleSize) == 0x000008, "Wrong size on LPlayOption_SetSubtitleSize");
static_assert(offsetof(LPlayOption_SetSubtitleSize, InSubtitleSize) == 0x000000, "Member 'LPlayOption_SetSubtitleSize::InSubtitleSize' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetSubtitleSize, ReturnValue) == 0x000004, "Member 'LPlayOption_SetSubtitleSize::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetUseAutoNewTargetLockOn
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetUseAutoNewTargetLockOn final
{
public:
	bool                                          InAuto;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetUseAutoNewTargetLockOn) == 0x000001, "Wrong alignment on LPlayOption_SetUseAutoNewTargetLockOn");
static_assert(sizeof(LPlayOption_SetUseAutoNewTargetLockOn) == 0x000002, "Wrong size on LPlayOption_SetUseAutoNewTargetLockOn");
static_assert(offsetof(LPlayOption_SetUseAutoNewTargetLockOn, InAuto) == 0x000000, "Member 'LPlayOption_SetUseAutoNewTargetLockOn::InAuto' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetUseAutoNewTargetLockOn, ReturnValue) == 0x000001, "Member 'LPlayOption_SetUseAutoNewTargetLockOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayOption.SetUseAutoTargeting
// 0x0002 (0x0002 - 0x0000)
struct LPlayOption_SetUseAutoTargeting final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayOption_SetUseAutoTargeting) == 0x000001, "Wrong alignment on LPlayOption_SetUseAutoTargeting");
static_assert(sizeof(LPlayOption_SetUseAutoTargeting) == 0x000002, "Wrong size on LPlayOption_SetUseAutoTargeting");
static_assert(offsetof(LPlayOption_SetUseAutoTargeting, Enable) == 0x000000, "Member 'LPlayOption_SetUseAutoTargeting::Enable' has a wrong offset!");
static_assert(offsetof(LPlayOption_SetUseAutoTargeting, ReturnValue) == 0x000001, "Member 'LPlayOption_SetUseAutoTargeting::ReturnValue' has a wrong offset!");

// Function ProjectP.LLockOnTargetComponent.IsLockOnEnabled
// 0x0001 (0x0001 - 0x0000)
struct LLockOnTargetComponent_IsLockOnEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLockOnTargetComponent_IsLockOnEnabled) == 0x000001, "Wrong alignment on LLockOnTargetComponent_IsLockOnEnabled");
static_assert(sizeof(LLockOnTargetComponent_IsLockOnEnabled) == 0x000001, "Wrong size on LLockOnTargetComponent_IsLockOnEnabled");
static_assert(offsetof(LLockOnTargetComponent_IsLockOnEnabled, ReturnValue) == 0x000000, "Member 'LLockOnTargetComponent_IsLockOnEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCController.CanUseItem
// 0x0010 (0x0010 - 0x0000)
struct LPCController_CanUseItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCController_CanUseItem) == 0x000008, "Wrong alignment on LPCController_CanUseItem");
static_assert(sizeof(LPCController_CanUseItem) == 0x000010, "Wrong size on LPCController_CanUseItem");
static_assert(offsetof(LPCController_CanUseItem, Item) == 0x000000, "Member 'LPCController_CanUseItem::Item' has a wrong offset!");
static_assert(offsetof(LPCController_CanUseItem, ReturnValue) == 0x000008, "Member 'LPCController_CanUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCController.DoLookUp
// 0x0004 (0x0004 - 0x0000)
struct LPCController_DoLookUp final
{
public:
	float                                         InAxisValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_DoLookUp) == 0x000004, "Wrong alignment on LPCController_DoLookUp");
static_assert(sizeof(LPCController_DoLookUp) == 0x000004, "Wrong size on LPCController_DoLookUp");
static_assert(offsetof(LPCController_DoLookUp, InAxisValue) == 0x000000, "Member 'LPCController_DoLookUp::InAxisValue' has a wrong offset!");

// Function ProjectP.LPCController.DoMoveForward
// 0x0004 (0x0004 - 0x0000)
struct LPCController_DoMoveForward final
{
public:
	float                                         InAxisValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_DoMoveForward) == 0x000004, "Wrong alignment on LPCController_DoMoveForward");
static_assert(sizeof(LPCController_DoMoveForward) == 0x000004, "Wrong size on LPCController_DoMoveForward");
static_assert(offsetof(LPCController_DoMoveForward, InAxisValue) == 0x000000, "Member 'LPCController_DoMoveForward::InAxisValue' has a wrong offset!");

// Function ProjectP.LPCController.DoMoveRight
// 0x0004 (0x0004 - 0x0000)
struct LPCController_DoMoveRight final
{
public:
	float                                         InAxisValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_DoMoveRight) == 0x000004, "Wrong alignment on LPCController_DoMoveRight");
static_assert(sizeof(LPCController_DoMoveRight) == 0x000004, "Wrong size on LPCController_DoMoveRight");
static_assert(offsetof(LPCController_DoMoveRight, InAxisValue) == 0x000000, "Member 'LPCController_DoMoveRight::InAxisValue' has a wrong offset!");

// Function ProjectP.LPCController.DoTurn
// 0x0004 (0x0004 - 0x0000)
struct LPCController_DoTurn final
{
public:
	float                                         InAxisValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_DoTurn) == 0x000004, "Wrong alignment on LPCController_DoTurn");
static_assert(sizeof(LPCController_DoTurn) == 0x000004, "Wrong size on LPCController_DoTurn");
static_assert(offsetof(LPCController_DoTurn, InAxisValue) == 0x000000, "Member 'LPCController_DoTurn::InAxisValue' has a wrong offset!");

// Function ProjectP.LPCController.DoUseItem
// 0x0010 (0x0010 - 0x0000)
struct LPCController_DoUseItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCController_DoUseItem) == 0x000008, "Wrong alignment on LPCController_DoUseItem");
static_assert(sizeof(LPCController_DoUseItem) == 0x000010, "Wrong size on LPCController_DoUseItem");
static_assert(offsetof(LPCController_DoUseItem, Item) == 0x000000, "Member 'LPCController_DoUseItem::Item' has a wrong offset!");
static_assert(offsetof(LPCController_DoUseItem, UseCount) == 0x000008, "Member 'LPCController_DoUseItem::UseCount' has a wrong offset!");

// Function ProjectP.LPCController.IsInteractionLadder
// 0x0001 (0x0001 - 0x0000)
struct LPCController_IsInteractionLadder final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_IsInteractionLadder) == 0x000001, "Wrong alignment on LPCController_IsInteractionLadder");
static_assert(sizeof(LPCController_IsInteractionLadder) == 0x000001, "Wrong size on LPCController_IsInteractionLadder");
static_assert(offsetof(LPCController_IsInteractionLadder, ReturnValue) == 0x000000, "Member 'LPCController_IsInteractionLadder::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCController.IsInteractionMotion
// 0x0001 (0x0001 - 0x0000)
struct LPCController_IsInteractionMotion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_IsInteractionMotion) == 0x000001, "Wrong alignment on LPCController_IsInteractionMotion");
static_assert(sizeof(LPCController_IsInteractionMotion) == 0x000001, "Wrong size on LPCController_IsInteractionMotion");
static_assert(offsetof(LPCController_IsInteractionMotion, ReturnValue) == 0x000000, "Member 'LPCController_IsInteractionMotion::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCController.IsInteractionStatus
// 0x0001 (0x0001 - 0x0000)
struct LPCController_IsInteractionStatus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_IsInteractionStatus) == 0x000001, "Wrong alignment on LPCController_IsInteractionStatus");
static_assert(sizeof(LPCController_IsInteractionStatus) == 0x000001, "Wrong size on LPCController_IsInteractionStatus");
static_assert(offsetof(LPCController_IsInteractionStatus, ReturnValue) == 0x000000, "Member 'LPCController_IsInteractionStatus::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCController.OnControllerCommand
// 0x0020 (0x0020 - 0x0000)
struct LPCController_OnControllerCommand final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Args;                                              // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_OnControllerCommand) == 0x000008, "Wrong alignment on LPCController_OnControllerCommand");
static_assert(sizeof(LPCController_OnControllerCommand) == 0x000020, "Wrong size on LPCController_OnControllerCommand");
static_assert(offsetof(LPCController_OnControllerCommand, Command) == 0x000000, "Member 'LPCController_OnControllerCommand::Command' has a wrong offset!");
static_assert(offsetof(LPCController_OnControllerCommand, Args) == 0x000010, "Member 'LPCController_OnControllerCommand::Args' has a wrong offset!");

// Function ProjectP.LPCController.ReceiveOnActionStarted
// 0x0010 (0x0010 - 0x0000)
struct LPCController_ReceiveOnActionStarted final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              StartedAction;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_ReceiveOnActionStarted) == 0x000008, "Wrong alignment on LPCController_ReceiveOnActionStarted");
static_assert(sizeof(LPCController_ReceiveOnActionStarted) == 0x000010, "Wrong size on LPCController_ReceiveOnActionStarted");
static_assert(offsetof(LPCController_ReceiveOnActionStarted, InActMgrComponent) == 0x000000, "Member 'LPCController_ReceiveOnActionStarted::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LPCController_ReceiveOnActionStarted, StartedAction) == 0x000008, "Member 'LPCController_ReceiveOnActionStarted::StartedAction' has a wrong offset!");

// Function ProjectP.LPCController.ReceiveOnActionStopCalled
// 0x0018 (0x0018 - 0x0000)
struct LPCController_ReceiveOnActionStopCalled final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              StoppingAction;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReasonAction;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_ReceiveOnActionStopCalled) == 0x000008, "Wrong alignment on LPCController_ReceiveOnActionStopCalled");
static_assert(sizeof(LPCController_ReceiveOnActionStopCalled) == 0x000018, "Wrong size on LPCController_ReceiveOnActionStopCalled");
static_assert(offsetof(LPCController_ReceiveOnActionStopCalled, InActMgrComponent) == 0x000000, "Member 'LPCController_ReceiveOnActionStopCalled::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LPCController_ReceiveOnActionStopCalled, StoppingAction) == 0x000008, "Member 'LPCController_ReceiveOnActionStopCalled::StoppingAction' has a wrong offset!");
static_assert(offsetof(LPCController_ReceiveOnActionStopCalled, ReasonAction) == 0x000010, "Member 'LPCController_ReceiveOnActionStopCalled::ReasonAction' has a wrong offset!");

// Function ProjectP.LPCController.SetAudioListenerPosition_AudioListenerPositionComponent
// 0x0010 (0x0010 - 0x0000)
struct LPCController_SetAudioListenerPosition_AudioListenerPositionComponent final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_SetAudioListenerPosition_AudioListenerPositionComponent) == 0x000004, "Wrong alignment on LPCController_SetAudioListenerPosition_AudioListenerPositionComponent");
static_assert(sizeof(LPCController_SetAudioListenerPosition_AudioListenerPositionComponent) == 0x000010, "Wrong size on LPCController_SetAudioListenerPosition_AudioListenerPositionComponent");
static_assert(offsetof(LPCController_SetAudioListenerPosition_AudioListenerPositionComponent, Offset) == 0x000000, "Member 'LPCController_SetAudioListenerPosition_AudioListenerPositionComponent::Offset' has a wrong offset!");
static_assert(offsetof(LPCController_SetAudioListenerPosition_AudioListenerPositionComponent, LerpDuration) == 0x00000C, "Member 'LPCController_SetAudioListenerPosition_AudioListenerPositionComponent::LerpDuration' has a wrong offset!");

// Function ProjectP.LPCController.SetAudioListenerPosition_Camera
// 0x0010 (0x0010 - 0x0000)
struct LPCController_SetAudioListenerPosition_Camera final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_SetAudioListenerPosition_Camera) == 0x000004, "Wrong alignment on LPCController_SetAudioListenerPosition_Camera");
static_assert(sizeof(LPCController_SetAudioListenerPosition_Camera) == 0x000010, "Wrong size on LPCController_SetAudioListenerPosition_Camera");
static_assert(offsetof(LPCController_SetAudioListenerPosition_Camera, Offset) == 0x000000, "Member 'LPCController_SetAudioListenerPosition_Camera::Offset' has a wrong offset!");
static_assert(offsetof(LPCController_SetAudioListenerPosition_Camera, LerpDuration) == 0x00000C, "Member 'LPCController_SetAudioListenerPosition_Camera::LerpDuration' has a wrong offset!");

// Function ProjectP.LPCController.SetAudioListenerPosition_Character
// 0x0004 (0x0004 - 0x0000)
struct LPCController_SetAudioListenerPosition_Character final
{
public:
	float                                         LerpDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_SetAudioListenerPosition_Character) == 0x000004, "Wrong alignment on LPCController_SetAudioListenerPosition_Character");
static_assert(sizeof(LPCController_SetAudioListenerPosition_Character) == 0x000004, "Wrong size on LPCController_SetAudioListenerPosition_Character");
static_assert(offsetof(LPCController_SetAudioListenerPosition_Character, LerpDuration) == 0x000000, "Member 'LPCController_SetAudioListenerPosition_Character::LerpDuration' has a wrong offset!");

// Function ProjectP.LPCController.SetAudioListenerPosition_CustomLocation
// 0x0010 (0x0010 - 0x0000)
struct LPCController_SetAudioListenerPosition_CustomLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_SetAudioListenerPosition_CustomLocation) == 0x000004, "Wrong alignment on LPCController_SetAudioListenerPosition_CustomLocation");
static_assert(sizeof(LPCController_SetAudioListenerPosition_CustomLocation) == 0x000010, "Wrong size on LPCController_SetAudioListenerPosition_CustomLocation");
static_assert(offsetof(LPCController_SetAudioListenerPosition_CustomLocation, Location) == 0x000000, "Member 'LPCController_SetAudioListenerPosition_CustomLocation::Location' has a wrong offset!");
static_assert(offsetof(LPCController_SetAudioListenerPosition_CustomLocation, LerpDuration) == 0x00000C, "Member 'LPCController_SetAudioListenerPosition_CustomLocation::LerpDuration' has a wrong offset!");

// Function ProjectP.LPCController.SetInteractionLadder
// 0x0001 (0x0001 - 0x0000)
struct LPCController_SetInteractionLadder final
{
public:
	bool                                          Motion;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_SetInteractionLadder) == 0x000001, "Wrong alignment on LPCController_SetInteractionLadder");
static_assert(sizeof(LPCController_SetInteractionLadder) == 0x000001, "Wrong size on LPCController_SetInteractionLadder");
static_assert(offsetof(LPCController_SetInteractionLadder, Motion) == 0x000000, "Member 'LPCController_SetInteractionLadder::Motion' has a wrong offset!");

// Function ProjectP.LPCController.GetAudioListenerPositionType
// 0x0001 (0x0001 - 0x0000)
struct LPCController_GetAudioListenerPositionType final
{
public:
	ELAudioListenerPositionType                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCController_GetAudioListenerPositionType) == 0x000001, "Wrong alignment on LPCController_GetAudioListenerPositionType");
static_assert(sizeof(LPCController_GetAudioListenerPositionType) == 0x000001, "Wrong size on LPCController_GetAudioListenerPositionType");
static_assert(offsetof(LPCController_GetAudioListenerPositionType, ReturnValue) == 0x000000, "Member 'LPCController_GetAudioListenerPositionType::ReturnValue' has a wrong offset!");

// Function ProjectP.LMovieSystemData.IsPauseOnReachedEnd
// 0x0001 (0x0001 - 0x0000)
struct LMovieSystemData_IsPauseOnReachedEnd final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystemData_IsPauseOnReachedEnd) == 0x000001, "Wrong alignment on LMovieSystemData_IsPauseOnReachedEnd");
static_assert(sizeof(LMovieSystemData_IsPauseOnReachedEnd) == 0x000001, "Wrong size on LMovieSystemData_IsPauseOnReachedEnd");
static_assert(offsetof(LMovieSystemData_IsPauseOnReachedEnd, ReturnValue) == 0x000000, "Member 'LMovieSystemData_IsPauseOnReachedEnd::ReturnValue' has a wrong offset!");

// Function ProjectP.LMovieSystemData.IsPlayingBinkMovie
// 0x0001 (0x0001 - 0x0000)
struct LMovieSystemData_IsPlayingBinkMovie final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystemData_IsPlayingBinkMovie) == 0x000001, "Wrong alignment on LMovieSystemData_IsPlayingBinkMovie");
static_assert(sizeof(LMovieSystemData_IsPlayingBinkMovie) == 0x000001, "Wrong size on LMovieSystemData_IsPlayingBinkMovie");
static_assert(offsetof(LMovieSystemData_IsPlayingBinkMovie, ReturnValue) == 0x000000, "Member 'LMovieSystemData_IsPlayingBinkMovie::ReturnValue' has a wrong offset!");

// Function ProjectP.LMovieSystemData.PlayBinkMovie
// 0x0020 (0x0020 - 0x0000)
struct LMovieSystemData_PlayBinkMovie final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MovieUrl;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseOnReachedEnd;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMovieSystemData_PlayBinkMovie) == 0x000008, "Wrong alignment on LMovieSystemData_PlayBinkMovie");
static_assert(sizeof(LMovieSystemData_PlayBinkMovie) == 0x000020, "Wrong size on LMovieSystemData_PlayBinkMovie");
static_assert(offsetof(LMovieSystemData_PlayBinkMovie, MovieCodeName) == 0x000000, "Member 'LMovieSystemData_PlayBinkMovie::MovieCodeName' has a wrong offset!");
static_assert(offsetof(LMovieSystemData_PlayBinkMovie, MovieUrl) == 0x000008, "Member 'LMovieSystemData_PlayBinkMovie::MovieUrl' has a wrong offset!");
static_assert(offsetof(LMovieSystemData_PlayBinkMovie, bPauseOnReachedEnd) == 0x000018, "Member 'LMovieSystemData_PlayBinkMovie::bPauseOnReachedEnd' has a wrong offset!");
static_assert(offsetof(LMovieSystemData_PlayBinkMovie, ReturnValue) == 0x000019, "Member 'LMovieSystemData_PlayBinkMovie::ReturnValue' has a wrong offset!");

// Function ProjectP.LMovieSystemData.StopBinkMovie
// 0x0008 (0x0008 - 0x0000)
struct LMovieSystemData_StopBinkMovie final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystemData_StopBinkMovie) == 0x000004, "Wrong alignment on LMovieSystemData_StopBinkMovie");
static_assert(sizeof(LMovieSystemData_StopBinkMovie) == 0x000008, "Wrong size on LMovieSystemData_StopBinkMovie");
static_assert(offsetof(LMovieSystemData_StopBinkMovie, MovieCodeName) == 0x000000, "Member 'LMovieSystemData_StopBinkMovie::MovieCodeName' has a wrong offset!");

// Function ProjectP.LHeadTagComponent.CanHeadTagVisible
// 0x0001 (0x0001 - 0x0000)
struct LHeadTagComponent_CanHeadTagVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHeadTagComponent_CanHeadTagVisible) == 0x000001, "Wrong alignment on LHeadTagComponent_CanHeadTagVisible");
static_assert(sizeof(LHeadTagComponent_CanHeadTagVisible) == 0x000001, "Wrong size on LHeadTagComponent_CanHeadTagVisible");
static_assert(offsetof(LHeadTagComponent_CanHeadTagVisible, ReturnValue) == 0x000000, "Member 'LHeadTagComponent_CanHeadTagVisible::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitCollisionDynamic.GetCollisionOwner
// 0x0008 (0x0008 - 0x0000)
struct LHitCollisionDynamic_GetCollisionOwner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitCollisionDynamic_GetCollisionOwner) == 0x000008, "Wrong alignment on LHitCollisionDynamic_GetCollisionOwner");
static_assert(sizeof(LHitCollisionDynamic_GetCollisionOwner) == 0x000008, "Wrong size on LHitCollisionDynamic_GetCollisionOwner");
static_assert(offsetof(LHitCollisionDynamic_GetCollisionOwner, ReturnValue) == 0x000000, "Member 'LHitCollisionDynamic_GetCollisionOwner::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitCollisionDynamic.GetPhysicalSurface
// 0x0001 (0x0001 - 0x0000)
struct LHitCollisionDynamic_GetPhysicalSurface final
{
public:
	ELPhysicalSurfaceType                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitCollisionDynamic_GetPhysicalSurface) == 0x000001, "Wrong alignment on LHitCollisionDynamic_GetPhysicalSurface");
static_assert(sizeof(LHitCollisionDynamic_GetPhysicalSurface) == 0x000001, "Wrong size on LHitCollisionDynamic_GetPhysicalSurface");
static_assert(offsetof(LHitCollisionDynamic_GetPhysicalSurface, ReturnValue) == 0x000000, "Member 'LHitCollisionDynamic_GetPhysicalSurface::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitCollisionDynamic.GetPartsCodeName
// 0x0008 (0x0008 - 0x0000)
struct LHitCollisionDynamic_GetPartsCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitCollisionDynamic_GetPartsCodeName) == 0x000004, "Wrong alignment on LHitCollisionDynamic_GetPartsCodeName");
static_assert(sizeof(LHitCollisionDynamic_GetPartsCodeName) == 0x000008, "Wrong size on LHitCollisionDynamic_GetPartsCodeName");
static_assert(offsetof(LHitCollisionDynamic_GetPartsCodeName, ReturnValue) == 0x000000, "Member 'LHitCollisionDynamic_GetPartsCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitCollisionDynamic.IsAttackCollision
// 0x0001 (0x0001 - 0x0000)
struct LHitCollisionDynamic_IsAttackCollision final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitCollisionDynamic_IsAttackCollision) == 0x000001, "Wrong alignment on LHitCollisionDynamic_IsAttackCollision");
static_assert(sizeof(LHitCollisionDynamic_IsAttackCollision) == 0x000001, "Wrong size on LHitCollisionDynamic_IsAttackCollision");
static_assert(offsetof(LHitCollisionDynamic_IsAttackCollision, ReturnValue) == 0x000000, "Member 'LHitCollisionDynamic_IsAttackCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitCollisionDynamic.IsGuardCollision
// 0x0001 (0x0001 - 0x0000)
struct LHitCollisionDynamic_IsGuardCollision final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitCollisionDynamic_IsGuardCollision) == 0x000001, "Wrong alignment on LHitCollisionDynamic_IsGuardCollision");
static_assert(sizeof(LHitCollisionDynamic_IsGuardCollision) == 0x000001, "Wrong size on LHitCollisionDynamic_IsGuardCollision");
static_assert(offsetof(LHitCollisionDynamic_IsGuardCollision, ReturnValue) == 0x000000, "Member 'LHitCollisionDynamic_IsGuardCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitCollisionDynamic.IsPartsGuardCollision
// 0x0001 (0x0001 - 0x0000)
struct LHitCollisionDynamic_IsPartsGuardCollision final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitCollisionDynamic_IsPartsGuardCollision) == 0x000001, "Wrong alignment on LHitCollisionDynamic_IsPartsGuardCollision");
static_assert(sizeof(LHitCollisionDynamic_IsPartsGuardCollision) == 0x000001, "Wrong size on LHitCollisionDynamic_IsPartsGuardCollision");
static_assert(offsetof(LHitCollisionDynamic_IsPartsGuardCollision, ReturnValue) == 0x000000, "Member 'LHitCollisionDynamic_IsPartsGuardCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitProcComponent.GetDebugShowRepulseSparkInfo
// 0x0001 (0x0001 - 0x0000)
struct LHitProcComponent_GetDebugShowRepulseSparkInfo final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_GetDebugShowRepulseSparkInfo) == 0x000001, "Wrong alignment on LHitProcComponent_GetDebugShowRepulseSparkInfo");
static_assert(sizeof(LHitProcComponent_GetDebugShowRepulseSparkInfo) == 0x000001, "Wrong size on LHitProcComponent_GetDebugShowRepulseSparkInfo");
static_assert(offsetof(LHitProcComponent_GetDebugShowRepulseSparkInfo, ReturnValue) == 0x000000, "Member 'LHitProcComponent_GetDebugShowRepulseSparkInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LHitProcComponent.OnActionStarted
// 0x0010 (0x0010 - 0x0000)
struct LHitProcComponent_OnActionStarted final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              StartedAction;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_OnActionStarted) == 0x000008, "Wrong alignment on LHitProcComponent_OnActionStarted");
static_assert(sizeof(LHitProcComponent_OnActionStarted) == 0x000010, "Wrong size on LHitProcComponent_OnActionStarted");
static_assert(offsetof(LHitProcComponent_OnActionStarted, ActMgrComponent) == 0x000000, "Member 'LHitProcComponent_OnActionStarted::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnActionStarted, StartedAction) == 0x000008, "Member 'LHitProcComponent_OnActionStarted::StartedAction' has a wrong offset!");

// Function ProjectP.LHitProcComponent.OnActionStopCalled
// 0x0018 (0x0018 - 0x0000)
struct LHitProcComponent_OnActionStopCalled final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              StoppingAction;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              ReasonAction;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_OnActionStopCalled) == 0x000008, "Wrong alignment on LHitProcComponent_OnActionStopCalled");
static_assert(sizeof(LHitProcComponent_OnActionStopCalled) == 0x000018, "Wrong size on LHitProcComponent_OnActionStopCalled");
static_assert(offsetof(LHitProcComponent_OnActionStopCalled, ActMgrComponent) == 0x000000, "Member 'LHitProcComponent_OnActionStopCalled::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnActionStopCalled, StoppingAction) == 0x000008, "Member 'LHitProcComponent_OnActionStopCalled::StoppingAction' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnActionStopCalled, ReasonAction) == 0x000010, "Member 'LHitProcComponent_OnActionStopCalled::ReasonAction' has a wrong offset!");

// Function ProjectP.LHitProcComponent.OnDebugHitOcurred
// 0x0088 (0x0088 - 0x0000)
struct LHitProcComponent_OnDebugHitOcurred final
{
public:
	struct FHitResult                             Info;                                              // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_OnDebugHitOcurred) == 0x000004, "Wrong alignment on LHitProcComponent_OnDebugHitOcurred");
static_assert(sizeof(LHitProcComponent_OnDebugHitOcurred) == 0x000088, "Wrong size on LHitProcComponent_OnDebugHitOcurred");
static_assert(offsetof(LHitProcComponent_OnDebugHitOcurred, Info) == 0x000000, "Member 'LHitProcComponent_OnDebugHitOcurred::Info' has a wrong offset!");

// Function ProjectP.LHitProcComponent.OnFxSocketHitOccurred
// 0x0198 (0x0198 - 0x0000)
struct LHitProcComponent_OnFxSocketHitOccurred final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFxSocketTracerInfo                   SocketTracerInfo;                                  // 0x0008(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0110(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_OnFxSocketHitOccurred) == 0x000008, "Wrong alignment on LHitProcComponent_OnFxSocketHitOccurred");
static_assert(sizeof(LHitProcComponent_OnFxSocketHitOccurred) == 0x000198, "Wrong size on LHitProcComponent_OnFxSocketHitOccurred");
static_assert(offsetof(LHitProcComponent_OnFxSocketHitOccurred, ActMgrComponent) == 0x000000, "Member 'LHitProcComponent_OnFxSocketHitOccurred::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnFxSocketHitOccurred, SocketTracerInfo) == 0x000008, "Member 'LHitProcComponent_OnFxSocketHitOccurred::SocketTracerInfo' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnFxSocketHitOccurred, HitResult) == 0x000110, "Member 'LHitProcComponent_OnFxSocketHitOccurred::HitResult' has a wrong offset!");

// Function ProjectP.LHitProcComponent.OnRepulseSocketHitOccurred
// 0x0198 (0x0198 - 0x0000)
struct LHitProcComponent_OnRepulseSocketHitOccurred final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFxSocketTracerInfo                   SocketTracerInfo;                                  // 0x0008(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0110(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_OnRepulseSocketHitOccurred) == 0x000008, "Wrong alignment on LHitProcComponent_OnRepulseSocketHitOccurred");
static_assert(sizeof(LHitProcComponent_OnRepulseSocketHitOccurred) == 0x000198, "Wrong size on LHitProcComponent_OnRepulseSocketHitOccurred");
static_assert(offsetof(LHitProcComponent_OnRepulseSocketHitOccurred, ActMgrComponent) == 0x000000, "Member 'LHitProcComponent_OnRepulseSocketHitOccurred::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnRepulseSocketHitOccurred, SocketTracerInfo) == 0x000008, "Member 'LHitProcComponent_OnRepulseSocketHitOccurred::SocketTracerInfo' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_OnRepulseSocketHitOccurred, HitResult) == 0x000110, "Member 'LHitProcComponent_OnRepulseSocketHitOccurred::HitResult' has a wrong offset!");

// Function ProjectP.LHitProcComponent.ProcessHit
// 0x01E8 (0x01E8 - 0x0000)
struct LHitProcComponent_ProcessHit final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0098(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_ProcessHit) == 0x000008, "Wrong alignment on LHitProcComponent_ProcessHit");
static_assert(sizeof(LHitProcComponent_ProcessHit) == 0x0001E8, "Wrong size on LHitProcComponent_ProcessHit");
static_assert(offsetof(LHitProcComponent_ProcessHit, Attacker) == 0x000000, "Member 'LHitProcComponent_ProcessHit::Attacker' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHit, Victim) == 0x000008, "Member 'LHitProcComponent_ProcessHit::Victim' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHit, HitResult) == 0x000010, "Member 'LHitProcComponent_ProcessHit::HitResult' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHit, HitInfo) == 0x000098, "Member 'LHitProcComponent_ProcessHit::HitInfo' has a wrong offset!");

// Function ProjectP.LHitProcComponent.ProcessHitDecoMesh
// 0x0098 (0x0098 - 0x0000)
struct LHitProcComponent_ProcessHitDecoMesh final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_ProcessHitDecoMesh) == 0x000008, "Wrong alignment on LHitProcComponent_ProcessHitDecoMesh");
static_assert(sizeof(LHitProcComponent_ProcessHitDecoMesh) == 0x000098, "Wrong size on LHitProcComponent_ProcessHitDecoMesh");
static_assert(offsetof(LHitProcComponent_ProcessHitDecoMesh, Attacker) == 0x000000, "Member 'LHitProcComponent_ProcessHitDecoMesh::Attacker' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHitDecoMesh, Victim) == 0x000008, "Member 'LHitProcComponent_ProcessHitDecoMesh::Victim' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHitDecoMesh, HitResult) == 0x000010, "Member 'LHitProcComponent_ProcessHitDecoMesh::HitResult' has a wrong offset!");

// Function ProjectP.LHitProcComponent.ProcessHitProp
// 0x01E8 (0x01E8 - 0x0000)
struct LHitProcComponent_ProcessHitProp final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0098(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHitProcComponent_ProcessHitProp) == 0x000008, "Wrong alignment on LHitProcComponent_ProcessHitProp");
static_assert(sizeof(LHitProcComponent_ProcessHitProp) == 0x0001E8, "Wrong size on LHitProcComponent_ProcessHitProp");
static_assert(offsetof(LHitProcComponent_ProcessHitProp, Attacker) == 0x000000, "Member 'LHitProcComponent_ProcessHitProp::Attacker' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHitProp, Victim) == 0x000008, "Member 'LHitProcComponent_ProcessHitProp::Victim' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHitProp, HitResult) == 0x000010, "Member 'LHitProcComponent_ProcessHitProp::HitResult' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_ProcessHitProp, HitInfo) == 0x000098, "Member 'LHitProcComponent_ProcessHitProp::HitInfo' has a wrong offset!");

// Function ProjectP.LHitProcComponent.RegisterNewHit
// 0x0080 (0x0080 - 0x0000)
struct LHitProcComponent_RegisterNewHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitContext                           HitContext;                                        // 0x0008(0x0074)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LHitProcComponent_RegisterNewHit) == 0x000008, "Wrong alignment on LHitProcComponent_RegisterNewHit");
static_assert(sizeof(LHitProcComponent_RegisterNewHit) == 0x000080, "Wrong size on LHitProcComponent_RegisterNewHit");
static_assert(offsetof(LHitProcComponent_RegisterNewHit, Victim) == 0x000000, "Member 'LHitProcComponent_RegisterNewHit::Victim' has a wrong offset!");
static_assert(offsetof(LHitProcComponent_RegisterNewHit, HitContext) == 0x000008, "Member 'LHitProcComponent_RegisterNewHit::HitContext' has a wrong offset!");

// Function ProjectP.LInteractInterface.GetInteractionStartTransform
// 0x0040 (0x0040 - 0x0000)
struct LInteractInterface_GetInteractionStartTransform final
{
public:
	bool                                          IsValid;                                           // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractInterface_GetInteractionStartTransform) == 0x000010, "Wrong alignment on LInteractInterface_GetInteractionStartTransform");
static_assert(sizeof(LInteractInterface_GetInteractionStartTransform) == 0x000040, "Wrong size on LInteractInterface_GetInteractionStartTransform");
static_assert(offsetof(LInteractInterface_GetInteractionStartTransform, IsValid) == 0x000000, "Member 'LInteractInterface_GetInteractionStartTransform::IsValid' has a wrong offset!");
static_assert(offsetof(LInteractInterface_GetInteractionStartTransform, ReturnValue) == 0x000010, "Member 'LInteractInterface_GetInteractionStartTransform::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractInterface.GetInteractionUserAnimMontage
// 0x0008 (0x0008 - 0x0000)
struct LInteractInterface_GetInteractionUserAnimMontage final
{
public:
	class UAnimSequenceBase*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractInterface_GetInteractionUserAnimMontage) == 0x000008, "Wrong alignment on LInteractInterface_GetInteractionUserAnimMontage");
static_assert(sizeof(LInteractInterface_GetInteractionUserAnimMontage) == 0x000008, "Wrong size on LInteractInterface_GetInteractionUserAnimMontage");
static_assert(offsetof(LInteractInterface_GetInteractionUserAnimMontage, ReturnValue) == 0x000000, "Member 'LInteractInterface_GetInteractionUserAnimMontage::ReturnValue' has a wrong offset!");

// Function ProjectP.LInteractInterface.IsValidUserInteractedComp
// 0x0001 (0x0001 - 0x0000)
struct LInteractInterface_IsValidUserInteractedComp final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LInteractInterface_IsValidUserInteractedComp) == 0x000001, "Wrong alignment on LInteractInterface_IsValidUserInteractedComp");
static_assert(sizeof(LInteractInterface_IsValidUserInteractedComp) == 0x000001, "Wrong size on LInteractInterface_IsValidUserInteractedComp");
static_assert(offsetof(LInteractInterface_IsValidUserInteractedComp, ReturnValue) == 0x000000, "Member 'LInteractInterface_IsValidUserInteractedComp::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.Execute
// 0x0010 (0x0010 - 0x0000)
struct LDialogControl_Execute final
{
public:
	struct FLDialogExecute                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_Execute) == 0x000004, "Wrong alignment on LDialogControl_Execute");
static_assert(sizeof(LDialogControl_Execute) == 0x000010, "Wrong size on LDialogControl_Execute");
static_assert(offsetof(LDialogControl_Execute, ReturnValue) == 0x000000, "Member 'LDialogControl_Execute::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.ExecuteSelect
// 0x0014 (0x0014 - 0x0000)
struct LDialogControl_ExecuteSelect final
{
public:
	int32                                         InMenuIdx;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLDialogExecute                        ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_ExecuteSelect) == 0x000004, "Wrong alignment on LDialogControl_ExecuteSelect");
static_assert(sizeof(LDialogControl_ExecuteSelect) == 0x000014, "Wrong size on LDialogControl_ExecuteSelect");
static_assert(offsetof(LDialogControl_ExecuteSelect, InMenuIdx) == 0x000000, "Member 'LDialogControl_ExecuteSelect::InMenuIdx' has a wrong offset!");
static_assert(offsetof(LDialogControl_ExecuteSelect, ReturnValue) == 0x000004, "Member 'LDialogControl_ExecuteSelect::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.GetMenuItemNotifies
// 0x0010 (0x0010 - 0x0000)
struct LDialogControl_GetMenuItemNotifies final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_GetMenuItemNotifies) == 0x000008, "Wrong alignment on LDialogControl_GetMenuItemNotifies");
static_assert(sizeof(LDialogControl_GetMenuItemNotifies) == 0x000010, "Wrong size on LDialogControl_GetMenuItemNotifies");
static_assert(offsetof(LDialogControl_GetMenuItemNotifies, ReturnValue) == 0x000000, "Member 'LDialogControl_GetMenuItemNotifies::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.GetMenuItemTexts
// 0x0010 (0x0010 - 0x0000)
struct LDialogControl_GetMenuItemTexts final
{
public:
	TArray<class FText>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_GetMenuItemTexts) == 0x000008, "Wrong alignment on LDialogControl_GetMenuItemTexts");
static_assert(sizeof(LDialogControl_GetMenuItemTexts) == 0x000010, "Wrong size on LDialogControl_GetMenuItemTexts");
static_assert(offsetof(LDialogControl_GetMenuItemTexts, ReturnValue) == 0x000000, "Member 'LDialogControl_GetMenuItemTexts::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.GetNameText
// 0x0018 (0x0018 - 0x0000)
struct LDialogControl_GetNameText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_GetNameText) == 0x000008, "Wrong alignment on LDialogControl_GetNameText");
static_assert(sizeof(LDialogControl_GetNameText) == 0x000018, "Wrong size on LDialogControl_GetNameText");
static_assert(offsetof(LDialogControl_GetNameText, ReturnValue) == 0x000000, "Member 'LDialogControl_GetNameText::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.GetScriptText
// 0x0018 (0x0018 - 0x0000)
struct LDialogControl_GetScriptText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_GetScriptText) == 0x000008, "Wrong alignment on LDialogControl_GetScriptText");
static_assert(sizeof(LDialogControl_GetScriptText) == 0x000018, "Wrong size on LDialogControl_GetScriptText");
static_assert(offsetof(LDialogControl_GetScriptText, ReturnValue) == 0x000000, "Member 'LDialogControl_GetScriptText::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.OnCloseUIByExecute
// 0x0008 (0x0008 - 0x0000)
struct LDialogControl_OnCloseUIByExecute final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_OnCloseUIByExecute) == 0x000004, "Wrong alignment on LDialogControl_OnCloseUIByExecute");
static_assert(sizeof(LDialogControl_OnCloseUIByExecute) == 0x000008, "Wrong size on LDialogControl_OnCloseUIByExecute");
static_assert(offsetof(LDialogControl_OnCloseUIByExecute, WidgetTableName) == 0x000000, "Member 'LDialogControl_OnCloseUIByExecute::WidgetTableName' has a wrong offset!");

// Function ProjectP.LDialogControl.StartExecute
// 0x0004 (0x0004 - 0x0000)
struct LDialogControl_StartExecute final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_StartExecute) == 0x000004, "Wrong alignment on LDialogControl_StartExecute");
static_assert(sizeof(LDialogControl_StartExecute) == 0x000004, "Wrong size on LDialogControl_StartExecute");
static_assert(offsetof(LDialogControl_StartExecute, ReturnValue) == 0x000000, "Member 'LDialogControl_StartExecute::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.GetSelectedMenuInfoPtr
// 0x0008 (0x0008 - 0x0000)
struct LDialogControl_GetSelectedMenuInfoPtr final
{
public:
	struct FDialogInfoPtr                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_GetSelectedMenuInfoPtr) == 0x000008, "Wrong alignment on LDialogControl_GetSelectedMenuInfoPtr");
static_assert(sizeof(LDialogControl_GetSelectedMenuInfoPtr) == 0x000008, "Wrong size on LDialogControl_GetSelectedMenuInfoPtr");
static_assert(offsetof(LDialogControl_GetSelectedMenuInfoPtr, ReturnValue) == 0x000000, "Member 'LDialogControl_GetSelectedMenuInfoPtr::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.GetTalkerInfo
// 0x0008 (0x0008 - 0x0000)
struct LDialogControl_GetTalkerInfo final
{
public:
	struct FTalkerInfoPtr                         ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_GetTalkerInfo) == 0x000008, "Wrong alignment on LDialogControl_GetTalkerInfo");
static_assert(sizeof(LDialogControl_GetTalkerInfo) == 0x000008, "Wrong size on LDialogControl_GetTalkerInfo");
static_assert(offsetof(LDialogControl_GetTalkerInfo, ReturnValue) == 0x000000, "Member 'LDialogControl_GetTalkerInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.IsHoldSelectDialog
// 0x0001 (0x0001 - 0x0000)
struct LDialogControl_IsHoldSelectDialog final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_IsHoldSelectDialog) == 0x000001, "Wrong alignment on LDialogControl_IsHoldSelectDialog");
static_assert(sizeof(LDialogControl_IsHoldSelectDialog) == 0x000001, "Wrong size on LDialogControl_IsHoldSelectDialog");
static_assert(offsetof(LDialogControl_IsHoldSelectDialog, ReturnValue) == 0x000000, "Member 'LDialogControl_IsHoldSelectDialog::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.IsValid
// 0x0001 (0x0001 - 0x0000)
struct LDialogControl_IsValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_IsValid) == 0x000001, "Wrong alignment on LDialogControl_IsValid");
static_assert(sizeof(LDialogControl_IsValid) == 0x000001, "Wrong size on LDialogControl_IsValid");
static_assert(offsetof(LDialogControl_IsValid, ReturnValue) == 0x000000, "Member 'LDialogControl_IsValid::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogControl.WillExit
// 0x0001 (0x0001 - 0x0000)
struct LDialogControl_WillExit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogControl_WillExit) == 0x000001, "Wrong alignment on LDialogControl_WillExit");
static_assert(sizeof(LDialogControl_WillExit) == 0x000001, "Wrong size on LDialogControl_WillExit");
static_assert(offsetof(LDialogControl_WillExit, ReturnValue) == 0x000000, "Member 'LDialogControl_WillExit::ReturnValue' has a wrong offset!");

// Function ProjectP.LDialogDB.GetDialog
// 0x0028 (0x0028 - 0x0000)
struct LDialogDB_GetDialog final
{
public:
	class FName                                   DialogCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLDisplayableDialog                    ReturnValue;                                       // 0x0008(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LDialogDB_GetDialog) == 0x000008, "Wrong alignment on LDialogDB_GetDialog");
static_assert(sizeof(LDialogDB_GetDialog) == 0x000028, "Wrong size on LDialogDB_GetDialog");
static_assert(offsetof(LDialogDB_GetDialog, DialogCodeName) == 0x000000, "Member 'LDialogDB_GetDialog::DialogCodeName' has a wrong offset!");
static_assert(offsetof(LDialogDB_GetDialog, ReturnValue) == 0x000008, "Member 'LDialogDB_GetDialog::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.AbandonItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_AbandonItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemoveCount;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_AbandonItem) == 0x000008, "Wrong alignment on LPlayerInventory_AbandonItem");
static_assert(sizeof(LPlayerInventory_AbandonItem) == 0x000010, "Wrong size on LPlayerInventory_AbandonItem");
static_assert(offsetof(LPlayerInventory_AbandonItem, Item) == 0x000000, "Member 'LPlayerInventory_AbandonItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_AbandonItem, RemoveCount) == 0x000008, "Member 'LPlayerInventory_AbandonItem::RemoveCount' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_AbandonItem, ReturnValue) == 0x00000C, "Member 'LPlayerInventory_AbandonItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.AddItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_AddItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_AddItem) == 0x000008, "Wrong alignment on LPlayerInventory_AddItem");
static_assert(sizeof(LPlayerInventory_AddItem) == 0x000010, "Wrong size on LPlayerInventory_AddItem");
static_assert(offsetof(LPlayerInventory_AddItem, Item) == 0x000000, "Member 'LPlayerInventory_AddItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_AddItem, ReturnValue) == 0x000008, "Member 'LPlayerInventory_AddItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.BlockNewNotification
// 0x0001 (0x0001 - 0x0000)
struct LPlayerInventory_BlockNewNotification final
{
public:
	bool                                          InBlocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_BlockNewNotification) == 0x000001, "Wrong alignment on LPlayerInventory_BlockNewNotification");
static_assert(sizeof(LPlayerInventory_BlockNewNotification) == 0x000001, "Wrong size on LPlayerInventory_BlockNewNotification");
static_assert(offsetof(LPlayerInventory_BlockNewNotification, InBlocked) == 0x000000, "Member 'LPlayerInventory_BlockNewNotification::InBlocked' has a wrong offset!");

// Function ProjectP.LPlayerInventory.ClearCategoryNotification
// 0x0001 (0x0001 - 0x0000)
struct LPlayerInventory_ClearCategoryNotification final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_ClearCategoryNotification) == 0x000001, "Wrong alignment on LPlayerInventory_ClearCategoryNotification");
static_assert(sizeof(LPlayerInventory_ClearCategoryNotification) == 0x000001, "Wrong size on LPlayerInventory_ClearCategoryNotification");
static_assert(offsetof(LPlayerInventory_ClearCategoryNotification, Category) == 0x000000, "Member 'LPlayerInventory_ClearCategoryNotification::Category' has a wrong offset!");

// Function ProjectP.LPlayerInventory.ConsumeItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_ConsumeItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeCount;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_ConsumeItem) == 0x000008, "Wrong alignment on LPlayerInventory_ConsumeItem");
static_assert(sizeof(LPlayerInventory_ConsumeItem) == 0x000010, "Wrong size on LPlayerInventory_ConsumeItem");
static_assert(offsetof(LPlayerInventory_ConsumeItem, Item) == 0x000000, "Member 'LPlayerInventory_ConsumeItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_ConsumeItem, ConsumeCount) == 0x000008, "Member 'LPlayerInventory_ConsumeItem::ConsumeCount' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_ConsumeItem, ReturnValue) == 0x00000C, "Member 'LPlayerInventory_ConsumeItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.ConsumeItemByCodeName
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_ConsumeItemByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeCount;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_ConsumeItemByCodeName) == 0x000004, "Wrong alignment on LPlayerInventory_ConsumeItemByCodeName");
static_assert(sizeof(LPlayerInventory_ConsumeItemByCodeName) == 0x000010, "Wrong size on LPlayerInventory_ConsumeItemByCodeName");
static_assert(offsetof(LPlayerInventory_ConsumeItemByCodeName, CodeName) == 0x000000, "Member 'LPlayerInventory_ConsumeItemByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_ConsumeItemByCodeName, ConsumeCount) == 0x000008, "Member 'LPlayerInventory_ConsumeItemByCodeName::ConsumeCount' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_ConsumeItemByCodeName, ReturnValue) == 0x00000C, "Member 'LPlayerInventory_ConsumeItemByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.FindBladeItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_FindBladeItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_FindBladeItems) == 0x000008, "Wrong alignment on LPlayerInventory_FindBladeItems");
static_assert(sizeof(LPlayerInventory_FindBladeItems) == 0x000010, "Wrong size on LPlayerInventory_FindBladeItems");
static_assert(offsetof(LPlayerInventory_FindBladeItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_FindBladeItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.FindCategoryItems
// 0x0018 (0x0018 - 0x0000)
struct LPlayerInventory_FindCategoryItems final
{
public:
	ELItemSecondCategory                          Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_FindCategoryItems) == 0x000008, "Wrong alignment on LPlayerInventory_FindCategoryItems");
static_assert(sizeof(LPlayerInventory_FindCategoryItems) == 0x000018, "Wrong size on LPlayerInventory_FindCategoryItems");
static_assert(offsetof(LPlayerInventory_FindCategoryItems, Category) == 0x000000, "Member 'LPlayerInventory_FindCategoryItems::Category' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_FindCategoryItems, ReturnValue) == 0x000008, "Member 'LPlayerInventory_FindCategoryItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.FindHandleItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_FindHandleItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_FindHandleItems) == 0x000008, "Wrong alignment on LPlayerInventory_FindHandleItems");
static_assert(sizeof(LPlayerInventory_FindHandleItems) == 0x000010, "Wrong size on LPlayerInventory_FindHandleItems");
static_assert(offsetof(LPlayerInventory_FindHandleItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_FindHandleItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.FindItemByCodeName
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_FindItemByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_FindItemByCodeName) == 0x000008, "Wrong alignment on LPlayerInventory_FindItemByCodeName");
static_assert(sizeof(LPlayerInventory_FindItemByCodeName) == 0x000010, "Wrong size on LPlayerInventory_FindItemByCodeName");
static_assert(offsetof(LPlayerInventory_FindItemByCodeName, CodeName) == 0x000000, "Member 'LPlayerInventory_FindItemByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_FindItemByCodeName, ReturnValue) == 0x000008, "Member 'LPlayerInventory_FindItemByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.FindItemsByCodeName
// 0x0018 (0x0018 - 0x0000)
struct LPlayerInventory_FindItemsByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_FindItemsByCodeName) == 0x000008, "Wrong alignment on LPlayerInventory_FindItemsByCodeName");
static_assert(sizeof(LPlayerInventory_FindItemsByCodeName) == 0x000018, "Wrong size on LPlayerInventory_FindItemsByCodeName");
static_assert(offsetof(LPlayerInventory_FindItemsByCodeName, CodeName) == 0x000000, "Member 'LPlayerInventory_FindItemsByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_FindItemsByCodeName, ReturnValue) == 0x000008, "Member 'LPlayerInventory_FindItemsByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.FindUICategoryItems
// 0x0018 (0x0018 - 0x0000)
struct LPlayerInventory_FindUICategoryItems final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_FindUICategoryItems) == 0x000008, "Wrong alignment on LPlayerInventory_FindUICategoryItems");
static_assert(sizeof(LPlayerInventory_FindUICategoryItems) == 0x000018, "Wrong size on LPlayerInventory_FindUICategoryItems");
static_assert(offsetof(LPlayerInventory_FindUICategoryItems, Category) == 0x000000, "Member 'LPlayerInventory_FindUICategoryItems::Category' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_FindUICategoryItems, ReturnValue) == 0x000008, "Member 'LPlayerInventory_FindUICategoryItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetAllItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetAllItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetAllItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetAllItems");
static_assert(sizeof(LPlayerInventory_GetAllItems) == 0x000010, "Wrong size on LPlayerInventory_GetAllItems");
static_assert(offsetof(LPlayerInventory_GetAllItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetAllItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetBladeItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetBladeItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetBladeItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetBladeItems");
static_assert(sizeof(LPlayerInventory_GetBladeItems) == 0x000010, "Wrong size on LPlayerInventory_GetBladeItems");
static_assert(offsetof(LPlayerInventory_GetBladeItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetBladeItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetGearItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetGearItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetGearItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetGearItems");
static_assert(sizeof(LPlayerInventory_GetGearItems) == 0x000010, "Wrong size on LPlayerInventory_GetGearItems");
static_assert(offsetof(LPlayerInventory_GetGearItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetGearItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetHandleItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetHandleItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetHandleItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetHandleItems");
static_assert(sizeof(LPlayerInventory_GetHandleItems) == 0x000010, "Wrong size on LPlayerInventory_GetHandleItems");
static_assert(offsetof(LPlayerInventory_GetHandleItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetHandleItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetItemCategoryMap
// 0x0050 (0x0050 - 0x0000)
struct LPlayerInventory_GetItemCategoryMap final
{
public:
	TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetItemCategoryMap) == 0x000008, "Wrong alignment on LPlayerInventory_GetItemCategoryMap");
static_assert(sizeof(LPlayerInventory_GetItemCategoryMap) == 0x000050, "Wrong size on LPlayerInventory_GetItemCategoryMap");
static_assert(offsetof(LPlayerInventory_GetItemCategoryMap, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetItemCategoryMap::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetItemTotalCountByCodeName
// 0x000C (0x000C - 0x0000)
struct LPlayerInventory_GetItemTotalCountByCodeName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetItemTotalCountByCodeName) == 0x000004, "Wrong alignment on LPlayerInventory_GetItemTotalCountByCodeName");
static_assert(sizeof(LPlayerInventory_GetItemTotalCountByCodeName) == 0x00000C, "Wrong size on LPlayerInventory_GetItemTotalCountByCodeName");
static_assert(offsetof(LPlayerInventory_GetItemTotalCountByCodeName, CodeName) == 0x000000, "Member 'LPlayerInventory_GetItemTotalCountByCodeName::CodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_GetItemTotalCountByCodeName, ReturnValue) == 0x000008, "Member 'LPlayerInventory_GetItemTotalCountByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetPartsItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetPartsItems final
{
public:
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetPartsItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetPartsItems");
static_assert(sizeof(LPlayerInventory_GetPartsItems) == 0x000010, "Wrong size on LPlayerInventory_GetPartsItems");
static_assert(offsetof(LPlayerInventory_GetPartsItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetPartsItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetSlaveArmItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetSlaveArmItems final
{
public:
	TArray<class ULSlaveArmItem*>                 ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetSlaveArmItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetSlaveArmItems");
static_assert(sizeof(LPlayerInventory_GetSlaveArmItems) == 0x000010, "Wrong size on LPlayerInventory_GetSlaveArmItems");
static_assert(offsetof(LPlayerInventory_GetSlaveArmItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetSlaveArmItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetWeaponItems
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetWeaponItems final
{
public:
	TArray<class ULWeaponItem*>                   ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetWeaponItems) == 0x000008, "Wrong alignment on LPlayerInventory_GetWeaponItems");
static_assert(sizeof(LPlayerInventory_GetWeaponItems) == 0x000010, "Wrong size on LPlayerInventory_GetWeaponItems");
static_assert(offsetof(LPlayerInventory_GetWeaponItems, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetWeaponItems::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetWeaponItems_SortedByEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_GetWeaponItems_SortedByEquipSlot final
{
public:
	TArray<class ULWeaponItem*>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetWeaponItems_SortedByEquipSlot) == 0x000008, "Wrong alignment on LPlayerInventory_GetWeaponItems_SortedByEquipSlot");
static_assert(sizeof(LPlayerInventory_GetWeaponItems_SortedByEquipSlot) == 0x000010, "Wrong size on LPlayerInventory_GetWeaponItems_SortedByEquipSlot");
static_assert(offsetof(LPlayerInventory_GetWeaponItems_SortedByEquipSlot, ReturnValue) == 0x000000, "Member 'LPlayerInventory_GetWeaponItems_SortedByEquipSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.GetWeaponTotalCountByCodeName
// 0x0014 (0x0014 - 0x0000)
struct LPlayerInventory_GetWeaponTotalCountByCodeName final
{
public:
	class FName                                   HandleCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BladeCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_GetWeaponTotalCountByCodeName) == 0x000004, "Wrong alignment on LPlayerInventory_GetWeaponTotalCountByCodeName");
static_assert(sizeof(LPlayerInventory_GetWeaponTotalCountByCodeName) == 0x000014, "Wrong size on LPlayerInventory_GetWeaponTotalCountByCodeName");
static_assert(offsetof(LPlayerInventory_GetWeaponTotalCountByCodeName, HandleCodeName) == 0x000000, "Member 'LPlayerInventory_GetWeaponTotalCountByCodeName::HandleCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_GetWeaponTotalCountByCodeName, BladeCodeName) == 0x000008, "Member 'LPlayerInventory_GetWeaponTotalCountByCodeName::BladeCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_GetWeaponTotalCountByCodeName, ReturnValue) == 0x000010, "Member 'LPlayerInventory_GetWeaponTotalCountByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.HasItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_HasItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_HasItem) == 0x000008, "Wrong alignment on LPlayerInventory_HasItem");
static_assert(sizeof(LPlayerInventory_HasItem) == 0x000010, "Wrong size on LPlayerInventory_HasItem");
static_assert(offsetof(LPlayerInventory_HasItem, Item) == 0x000000, "Member 'LPlayerInventory_HasItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_HasItem, ReturnValue) == 0x000008, "Member 'LPlayerInventory_HasItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.IsNotiCategory
// 0x0002 (0x0002 - 0x0000)
struct LPlayerInventory_IsNotiCategory final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerInventory_IsNotiCategory) == 0x000001, "Wrong alignment on LPlayerInventory_IsNotiCategory");
static_assert(sizeof(LPlayerInventory_IsNotiCategory) == 0x000002, "Wrong size on LPlayerInventory_IsNotiCategory");
static_assert(offsetof(LPlayerInventory_IsNotiCategory, Category) == 0x000000, "Member 'LPlayerInventory_IsNotiCategory::Category' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_IsNotiCategory, ReturnValue) == 0x000001, "Member 'LPlayerInventory_IsNotiCategory::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.IsNotiItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_IsNotiItem final
{
public:
	class ULItem*                                 InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_IsNotiItem) == 0x000008, "Wrong alignment on LPlayerInventory_IsNotiItem");
static_assert(sizeof(LPlayerInventory_IsNotiItem) == 0x000010, "Wrong size on LPlayerInventory_IsNotiItem");
static_assert(offsetof(LPlayerInventory_IsNotiItem, InItem) == 0x000000, "Member 'LPlayerInventory_IsNotiItem::InItem' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_IsNotiItem, ReturnValue) == 0x000008, "Member 'LPlayerInventory_IsNotiItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.MoveItemToLocker
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_MoveItemToLocker final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELItemGainResult                              ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_MoveItemToLocker) == 0x000008, "Wrong alignment on LPlayerInventory_MoveItemToLocker");
static_assert(sizeof(LPlayerInventory_MoveItemToLocker) == 0x000010, "Wrong size on LPlayerInventory_MoveItemToLocker");
static_assert(offsetof(LPlayerInventory_MoveItemToLocker, Item) == 0x000000, "Member 'LPlayerInventory_MoveItemToLocker::Item' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_MoveItemToLocker, ItemCount) == 0x000008, "Member 'LPlayerInventory_MoveItemToLocker::ItemCount' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_MoveItemToLocker, ReturnValue) == 0x00000C, "Member 'LPlayerInventory_MoveItemToLocker::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.RemoveItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerInventory_RemoveItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_RemoveItem) == 0x000008, "Wrong alignment on LPlayerInventory_RemoveItem");
static_assert(sizeof(LPlayerInventory_RemoveItem) == 0x000010, "Wrong size on LPlayerInventory_RemoveItem");
static_assert(offsetof(LPlayerInventory_RemoveItem, Item) == 0x000000, "Member 'LPlayerInventory_RemoveItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_RemoveItem, ReturnValue) == 0x000008, "Member 'LPlayerInventory_RemoveItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerInventory.HasSameItem
// 0x000C (0x000C - 0x0000)
struct LPlayerInventory_HasSameItem final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerInventory_HasSameItem) == 0x000004, "Wrong alignment on LPlayerInventory_HasSameItem");
static_assert(sizeof(LPlayerInventory_HasSameItem) == 0x00000C, "Wrong size on LPlayerInventory_HasSameItem");
static_assert(offsetof(LPlayerInventory_HasSameItem, ItemCodeName) == 0x000000, "Member 'LPlayerInventory_HasSameItem::ItemCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerInventory_HasSameItem, ReturnValue) == 0x000008, "Member 'LPlayerInventory_HasSameItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LNpcSpotDieData.ResponseLevelSequenceEnd
// 0x0010 (0x0010 - 0x0000)
struct LNpcSpotDieData_ResponseLevelSequenceEnd final
{
public:
	class FString                                 SpotUniqueID;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNpcSpotDieData_ResponseLevelSequenceEnd) == 0x000008, "Wrong alignment on LNpcSpotDieData_ResponseLevelSequenceEnd");
static_assert(sizeof(LNpcSpotDieData_ResponseLevelSequenceEnd) == 0x000010, "Wrong size on LNpcSpotDieData_ResponseLevelSequenceEnd");
static_assert(offsetof(LNpcSpotDieData_ResponseLevelSequenceEnd, SpotUniqueID) == 0x000000, "Member 'LNpcSpotDieData_ResponseLevelSequenceEnd::SpotUniqueID' has a wrong offset!");

// Function ProjectP.LNpcSpotDieData.ResponseMovieEnd
// 0x0008 (0x0008 - 0x0000)
struct LNpcSpotDieData_ResponseMovieEnd final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNpcSpotDieData_ResponseMovieEnd) == 0x000004, "Wrong alignment on LNpcSpotDieData_ResponseMovieEnd");
static_assert(sizeof(LNpcSpotDieData_ResponseMovieEnd) == 0x000008, "Wrong size on LNpcSpotDieData_ResponseMovieEnd");
static_assert(offsetof(LNpcSpotDieData_ResponseMovieEnd, MovieCodeName) == 0x000000, "Member 'LNpcSpotDieData_ResponseMovieEnd::MovieCodeName' has a wrong offset!");

// Function ProjectP.LItemSystem.AbandonItem
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_AbandonItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_AbandonItem) == 0x000008, "Wrong alignment on LItemSystem_AbandonItem");
static_assert(sizeof(LItemSystem_AbandonItem) == 0x000010, "Wrong size on LItemSystem_AbandonItem");
static_assert(offsetof(LItemSystem_AbandonItem, Item) == 0x000000, "Member 'LItemSystem_AbandonItem::Item' has a wrong offset!");
static_assert(offsetof(LItemSystem_AbandonItem, InCount) == 0x000008, "Member 'LItemSystem_AbandonItem::InCount' has a wrong offset!");
static_assert(offsetof(LItemSystem_AbandonItem, ReturnValue) == 0x00000C, "Member 'LItemSystem_AbandonItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.ChangeCorrectionHandle
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_ChangeCorrectionHandle final
{
public:
	ELStatCorrectChangeType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 HandleOrWeapon;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_ChangeCorrectionHandle) == 0x000008, "Wrong alignment on LItemSystem_ChangeCorrectionHandle");
static_assert(sizeof(LItemSystem_ChangeCorrectionHandle) == 0x000018, "Wrong size on LItemSystem_ChangeCorrectionHandle");
static_assert(offsetof(LItemSystem_ChangeCorrectionHandle, Type) == 0x000000, "Member 'LItemSystem_ChangeCorrectionHandle::Type' has a wrong offset!");
static_assert(offsetof(LItemSystem_ChangeCorrectionHandle, HandleOrWeapon) == 0x000008, "Member 'LItemSystem_ChangeCorrectionHandle::HandleOrWeapon' has a wrong offset!");
static_assert(offsetof(LItemSystem_ChangeCorrectionHandle, ReturnValue) == 0x000010, "Member 'LItemSystem_ChangeCorrectionHandle::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.CheckItemCanUsed
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_CheckItemCanUsed final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_CheckItemCanUsed) == 0x000008, "Wrong alignment on LItemSystem_CheckItemCanUsed");
static_assert(sizeof(LItemSystem_CheckItemCanUsed) == 0x000010, "Wrong size on LItemSystem_CheckItemCanUsed");
static_assert(offsetof(LItemSystem_CheckItemCanUsed, Item) == 0x000000, "Member 'LItemSystem_CheckItemCanUsed::Item' has a wrong offset!");
static_assert(offsetof(LItemSystem_CheckItemCanUsed, UseCount) == 0x000008, "Member 'LItemSystem_CheckItemCanUsed::UseCount' has a wrong offset!");
static_assert(offsetof(LItemSystem_CheckItemCanUsed, ReturnValue) == 0x00000C, "Member 'LItemSystem_CheckItemCanUsed::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.CombineWeapon
// 0x0038 (0x0038 - 0x0000)
struct LItemSystem_CombineWeapon final
{
public:
	class ULWeaponItem*                           WeaponToChange;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLWeaponPartInfoForCombine             HandlePart;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLWeaponPartInfoForCombine             BladePart;                                         // 0x0018(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class ULWeaponItem*                           OutResultWeaponItem;                               // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_CombineWeapon) == 0x000008, "Wrong alignment on LItemSystem_CombineWeapon");
static_assert(sizeof(LItemSystem_CombineWeapon) == 0x000038, "Wrong size on LItemSystem_CombineWeapon");
static_assert(offsetof(LItemSystem_CombineWeapon, WeaponToChange) == 0x000000, "Member 'LItemSystem_CombineWeapon::WeaponToChange' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeapon, HandlePart) == 0x000008, "Member 'LItemSystem_CombineWeapon::HandlePart' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeapon, BladePart) == 0x000018, "Member 'LItemSystem_CombineWeapon::BladePart' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeapon, OutResultWeaponItem) == 0x000028, "Member 'LItemSystem_CombineWeapon::OutResultWeaponItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeapon, ReturnValue) == 0x000030, "Member 'LItemSystem_CombineWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.CombineWeaponWithoutRestrictions
// 0x0020 (0x0020 - 0x0000)
struct LItemSystem_CombineWeaponWithoutRestrictions final
{
public:
	class ULItem*                                 HandleItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 BladeItem;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWeaponItem*                           OutResultWeaponItem;                               // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_CombineWeaponWithoutRestrictions) == 0x000008, "Wrong alignment on LItemSystem_CombineWeaponWithoutRestrictions");
static_assert(sizeof(LItemSystem_CombineWeaponWithoutRestrictions) == 0x000020, "Wrong size on LItemSystem_CombineWeaponWithoutRestrictions");
static_assert(offsetof(LItemSystem_CombineWeaponWithoutRestrictions, HandleItem) == 0x000000, "Member 'LItemSystem_CombineWeaponWithoutRestrictions::HandleItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeaponWithoutRestrictions, BladeItem) == 0x000008, "Member 'LItemSystem_CombineWeaponWithoutRestrictions::BladeItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeaponWithoutRestrictions, OutResultWeaponItem) == 0x000010, "Member 'LItemSystem_CombineWeaponWithoutRestrictions::OutResultWeaponItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_CombineWeaponWithoutRestrictions, ReturnValue) == 0x000018, "Member 'LItemSystem_CombineWeaponWithoutRestrictions::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.CreateItem
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_CreateItem final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_CreateItem) == 0x000008, "Wrong alignment on LItemSystem_CreateItem");
static_assert(sizeof(LItemSystem_CreateItem) == 0x000010, "Wrong size on LItemSystem_CreateItem");
static_assert(offsetof(LItemSystem_CreateItem, CodeName) == 0x000000, "Member 'LItemSystem_CreateItem::CodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_CreateItem, ReturnValue) == 0x000008, "Member 'LItemSystem_CreateItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.CreateWeaponItem
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_CreateWeaponItem final
{
public:
	class FName                                   HandleCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BladeCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWeaponItem*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_CreateWeaponItem) == 0x000008, "Wrong alignment on LItemSystem_CreateWeaponItem");
static_assert(sizeof(LItemSystem_CreateWeaponItem) == 0x000018, "Wrong size on LItemSystem_CreateWeaponItem");
static_assert(offsetof(LItemSystem_CreateWeaponItem, HandleCodeName) == 0x000000, "Member 'LItemSystem_CreateWeaponItem::HandleCodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_CreateWeaponItem, BladeCodeName) == 0x000008, "Member 'LItemSystem_CreateWeaponItem::BladeCodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_CreateWeaponItem, ReturnValue) == 0x000010, "Member 'LItemSystem_CreateWeaponItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.DecideForceUseItem
// 0x000C (0x000C - 0x0000)
struct LItemSystem_DecideForceUseItem final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemCodeName;                                      // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_DecideForceUseItem) == 0x000004, "Wrong alignment on LItemSystem_DecideForceUseItem");
static_assert(sizeof(LItemSystem_DecideForceUseItem) == 0x00000C, "Wrong size on LItemSystem_DecideForceUseItem");
static_assert(offsetof(LItemSystem_DecideForceUseItem, Result) == 0x000000, "Member 'LItemSystem_DecideForceUseItem::Result' has a wrong offset!");
static_assert(offsetof(LItemSystem_DecideForceUseItem, ItemCodeName) == 0x000004, "Member 'LItemSystem_DecideForceUseItem::ItemCodeName' has a wrong offset!");

// Function ProjectP.LItemSystem.DestoryItem
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_DestoryItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_DestoryItem) == 0x000008, "Wrong alignment on LItemSystem_DestoryItem");
static_assert(sizeof(LItemSystem_DestoryItem) == 0x000010, "Wrong size on LItemSystem_DestoryItem");
static_assert(offsetof(LItemSystem_DestoryItem, Item) == 0x000000, "Member 'LItemSystem_DestoryItem::Item' has a wrong offset!");
static_assert(offsetof(LItemSystem_DestoryItem, ReturnValue) == 0x000008, "Member 'LItemSystem_DestoryItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.DivideWeapon
// 0x0020 (0x0020 - 0x0000)
struct LItemSystem_DivideWeapon final
{
public:
	class ULWeaponItem*                           WeaponItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ResultHandleItem;                                  // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ResultBladeItem;                                   // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_DivideWeapon) == 0x000008, "Wrong alignment on LItemSystem_DivideWeapon");
static_assert(sizeof(LItemSystem_DivideWeapon) == 0x000020, "Wrong size on LItemSystem_DivideWeapon");
static_assert(offsetof(LItemSystem_DivideWeapon, WeaponItem) == 0x000000, "Member 'LItemSystem_DivideWeapon::WeaponItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_DivideWeapon, ResultHandleItem) == 0x000008, "Member 'LItemSystem_DivideWeapon::ResultHandleItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_DivideWeapon, ResultBladeItem) == 0x000010, "Member 'LItemSystem_DivideWeapon::ResultBladeItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_DivideWeapon, ReturnValue) == 0x000018, "Member 'LItemSystem_DivideWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.FindSlavearmAlteredConsumeItemInfo
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_FindSlavearmAlteredConsumeItemInfo final
{
public:
	class FName                                   ConsumeItemCodename;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlaveArmItemCodename;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlavearmAlterItemMatchInfoPtr         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_FindSlavearmAlteredConsumeItemInfo) == 0x000008, "Wrong alignment on LItemSystem_FindSlavearmAlteredConsumeItemInfo");
static_assert(sizeof(LItemSystem_FindSlavearmAlteredConsumeItemInfo) == 0x000018, "Wrong size on LItemSystem_FindSlavearmAlteredConsumeItemInfo");
static_assert(offsetof(LItemSystem_FindSlavearmAlteredConsumeItemInfo, ConsumeItemCodename) == 0x000000, "Member 'LItemSystem_FindSlavearmAlteredConsumeItemInfo::ConsumeItemCodename' has a wrong offset!");
static_assert(offsetof(LItemSystem_FindSlavearmAlteredConsumeItemInfo, SlaveArmItemCodename) == 0x000008, "Member 'LItemSystem_FindSlavearmAlteredConsumeItemInfo::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LItemSystem_FindSlavearmAlteredConsumeItemInfo, ReturnValue) == 0x000010, "Member 'LItemSystem_FindSlavearmAlteredConsumeItemInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetBladeListForCombine
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_GetBladeListForCombine final
{
public:
	class ULWeaponItem*                           WeaponToChange;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLWeaponPartInfoForCombine>     OutBladeInfoList;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetBladeListForCombine) == 0x000008, "Wrong alignment on LItemSystem_GetBladeListForCombine");
static_assert(sizeof(LItemSystem_GetBladeListForCombine) == 0x000018, "Wrong size on LItemSystem_GetBladeListForCombine");
static_assert(offsetof(LItemSystem_GetBladeListForCombine, WeaponToChange) == 0x000000, "Member 'LItemSystem_GetBladeListForCombine::WeaponToChange' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetBladeListForCombine, OutBladeInfoList) == 0x000008, "Member 'LItemSystem_GetBladeListForCombine::OutBladeInfoList' has a wrong offset!");

// Function ProjectP.LItemSystem.GetBuyShop
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_GetBuyShop final
{
public:
	class FName                                   ShopCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULProductBuyShop*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetBuyShop) == 0x000008, "Wrong alignment on LItemSystem_GetBuyShop");
static_assert(sizeof(LItemSystem_GetBuyShop) == 0x000010, "Wrong size on LItemSystem_GetBuyShop");
static_assert(offsetof(LItemSystem_GetBuyShop, ShopCodeName) == 0x000000, "Member 'LItemSystem_GetBuyShop::ShopCodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetBuyShop, ReturnValue) == 0x000008, "Member 'LItemSystem_GetBuyShop::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetChangeCorrectionHandleNeeds
// 0x0020 (0x0020 - 0x0000)
struct LItemSystem_GetChangeCorrectionHandleNeeds final
{
public:
	ELStatCorrectChangeType                       InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 InHandleOrWeapon;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutItemCodeName;                                   // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutItemCount;                                      // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutErgoCount;                                      // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetChangeCorrectionHandleNeeds) == 0x000008, "Wrong alignment on LItemSystem_GetChangeCorrectionHandleNeeds");
static_assert(sizeof(LItemSystem_GetChangeCorrectionHandleNeeds) == 0x000020, "Wrong size on LItemSystem_GetChangeCorrectionHandleNeeds");
static_assert(offsetof(LItemSystem_GetChangeCorrectionHandleNeeds, InType) == 0x000000, "Member 'LItemSystem_GetChangeCorrectionHandleNeeds::InType' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetChangeCorrectionHandleNeeds, InHandleOrWeapon) == 0x000008, "Member 'LItemSystem_GetChangeCorrectionHandleNeeds::InHandleOrWeapon' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetChangeCorrectionHandleNeeds, OutItemCodeName) == 0x000010, "Member 'LItemSystem_GetChangeCorrectionHandleNeeds::OutItemCodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetChangeCorrectionHandleNeeds, OutItemCount) == 0x000018, "Member 'LItemSystem_GetChangeCorrectionHandleNeeds::OutItemCount' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetChangeCorrectionHandleNeeds, OutErgoCount) == 0x00001C, "Member 'LItemSystem_GetChangeCorrectionHandleNeeds::OutErgoCount' has a wrong offset!");

// Function ProjectP.LItemSystem.GetCombineResultWeapon
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_GetCombineResultWeapon final
{
public:
	class ULItem*                                 HandleItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 BladeItem;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWeaponItem*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetCombineResultWeapon) == 0x000008, "Wrong alignment on LItemSystem_GetCombineResultWeapon");
static_assert(sizeof(LItemSystem_GetCombineResultWeapon) == 0x000018, "Wrong size on LItemSystem_GetCombineResultWeapon");
static_assert(offsetof(LItemSystem_GetCombineResultWeapon, HandleItem) == 0x000000, "Member 'LItemSystem_GetCombineResultWeapon::HandleItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetCombineResultWeapon, BladeItem) == 0x000008, "Member 'LItemSystem_GetCombineResultWeapon::BladeItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetCombineResultWeapon, ReturnValue) == 0x000010, "Member 'LItemSystem_GetCombineResultWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetConsumeItemAlterableState
// 0x000C (0x000C - 0x0000)
struct LItemSystem_GetConsumeItemAlterableState final
{
public:
	class FName                                   ConsumeItemCodename;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELConsumeItemSlavearmAtlerableState           ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_GetConsumeItemAlterableState) == 0x000004, "Wrong alignment on LItemSystem_GetConsumeItemAlterableState");
static_assert(sizeof(LItemSystem_GetConsumeItemAlterableState) == 0x00000C, "Wrong size on LItemSystem_GetConsumeItemAlterableState");
static_assert(offsetof(LItemSystem_GetConsumeItemAlterableState, ConsumeItemCodename) == 0x000000, "Member 'LItemSystem_GetConsumeItemAlterableState::ConsumeItemCodename' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetConsumeItemAlterableState, ReturnValue) == 0x000008, "Member 'LItemSystem_GetConsumeItemAlterableState::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetHandleListForCombine
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_GetHandleListForCombine final
{
public:
	class ULWeaponItem*                           WeaponToChange;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLWeaponPartInfoForCombine>     OutHandleInfoList;                                 // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetHandleListForCombine) == 0x000008, "Wrong alignment on LItemSystem_GetHandleListForCombine");
static_assert(sizeof(LItemSystem_GetHandleListForCombine) == 0x000018, "Wrong size on LItemSystem_GetHandleListForCombine");
static_assert(offsetof(LItemSystem_GetHandleListForCombine, WeaponToChange) == 0x000000, "Member 'LItemSystem_GetHandleListForCombine::WeaponToChange' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetHandleListForCombine, OutHandleInfoList) == 0x000008, "Member 'LItemSystem_GetHandleListForCombine::OutHandleInfoList' has a wrong offset!");

// Function ProjectP.LItemSystem.GetItemToggleImageResource
// 0x0030 (0x0030 - 0x0000)
struct LItemSystem_GetItemToggleImageResource final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0008(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetItemToggleImageResource) == 0x000008, "Wrong alignment on LItemSystem_GetItemToggleImageResource");
static_assert(sizeof(LItemSystem_GetItemToggleImageResource) == 0x000030, "Wrong size on LItemSystem_GetItemToggleImageResource");
static_assert(offsetof(LItemSystem_GetItemToggleImageResource, Item) == 0x000000, "Member 'LItemSystem_GetItemToggleImageResource::Item' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetItemToggleImageResource, ReturnValue) == 0x000008, "Member 'LItemSystem_GetItemToggleImageResource::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetNecessaryMaterialForCombineWeapon
// 0x0028 (0x0028 - 0x0000)
struct LItemSystem_GetNecessaryMaterialForCombineWeapon final
{
public:
	class ULItem*                                 HandleItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 BladeItem;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCost;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequireCost;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLItemRequireCount>             RequireItems;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetNecessaryMaterialForCombineWeapon) == 0x000008, "Wrong alignment on LItemSystem_GetNecessaryMaterialForCombineWeapon");
static_assert(sizeof(LItemSystem_GetNecessaryMaterialForCombineWeapon) == 0x000028, "Wrong size on LItemSystem_GetNecessaryMaterialForCombineWeapon");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForCombineWeapon, HandleItem) == 0x000000, "Member 'LItemSystem_GetNecessaryMaterialForCombineWeapon::HandleItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForCombineWeapon, BladeItem) == 0x000008, "Member 'LItemSystem_GetNecessaryMaterialForCombineWeapon::BladeItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForCombineWeapon, CurrentCost) == 0x000010, "Member 'LItemSystem_GetNecessaryMaterialForCombineWeapon::CurrentCost' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForCombineWeapon, RequireCost) == 0x000014, "Member 'LItemSystem_GetNecessaryMaterialForCombineWeapon::RequireCost' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForCombineWeapon, RequireItems) == 0x000018, "Member 'LItemSystem_GetNecessaryMaterialForCombineWeapon::RequireItems' has a wrong offset!");

// Function ProjectP.LItemSystem.GetNecessaryMaterialForDivideWeapon
// 0x0030 (0x0030 - 0x0000)
struct LItemSystem_GetNecessaryMaterialForDivideWeapon final
{
public:
	class ULWeaponItem*                           WeaponItem;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCost;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequireCost;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLItemRequireCount                     Item1;                                             // 0x0010(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLItemRequireCount                     Item2;                                             // 0x0020(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetNecessaryMaterialForDivideWeapon) == 0x000008, "Wrong alignment on LItemSystem_GetNecessaryMaterialForDivideWeapon");
static_assert(sizeof(LItemSystem_GetNecessaryMaterialForDivideWeapon) == 0x000030, "Wrong size on LItemSystem_GetNecessaryMaterialForDivideWeapon");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForDivideWeapon, WeaponItem) == 0x000000, "Member 'LItemSystem_GetNecessaryMaterialForDivideWeapon::WeaponItem' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForDivideWeapon, CurrentCost) == 0x000008, "Member 'LItemSystem_GetNecessaryMaterialForDivideWeapon::CurrentCost' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForDivideWeapon, RequireCost) == 0x00000C, "Member 'LItemSystem_GetNecessaryMaterialForDivideWeapon::RequireCost' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForDivideWeapon, Item1) == 0x000010, "Member 'LItemSystem_GetNecessaryMaterialForDivideWeapon::Item1' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetNecessaryMaterialForDivideWeapon, Item2) == 0x000020, "Member 'LItemSystem_GetNecessaryMaterialForDivideWeapon::Item2' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPlayerEquipment
// 0x0008 (0x0008 - 0x0000)
struct LItemSystem_GetPlayerEquipment final
{
public:
	class ULPlayerEquipment*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPlayerEquipment) == 0x000008, "Wrong alignment on LItemSystem_GetPlayerEquipment");
static_assert(sizeof(LItemSystem_GetPlayerEquipment) == 0x000008, "Wrong size on LItemSystem_GetPlayerEquipment");
static_assert(offsetof(LItemSystem_GetPlayerEquipment, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPlayerEquipment::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPlayerInventory
// 0x0008 (0x0008 - 0x0000)
struct LItemSystem_GetPlayerInventory final
{
public:
	class ULPlayerInventory*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPlayerInventory) == 0x000008, "Wrong alignment on LItemSystem_GetPlayerInventory");
static_assert(sizeof(LItemSystem_GetPlayerInventory) == 0x000008, "Wrong size on LItemSystem_GetPlayerInventory");
static_assert(offsetof(LItemSystem_GetPlayerInventory, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPlayerInventory::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPlayerItemLocker
// 0x0008 (0x0008 - 0x0000)
struct LItemSystem_GetPlayerItemLocker final
{
public:
	class ULPlayerItemLocker*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPlayerItemLocker) == 0x000008, "Wrong alignment on LItemSystem_GetPlayerItemLocker");
static_assert(sizeof(LItemSystem_GetPlayerItemLocker) == 0x000008, "Wrong size on LItemSystem_GetPlayerItemLocker");
static_assert(offsetof(LItemSystem_GetPlayerItemLocker, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPlayerItemLocker::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPulseGaugeRechargeSystemEnable
// 0x0001 (0x0001 - 0x0000)
struct LItemSystem_GetPulseGaugeRechargeSystemEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPulseGaugeRechargeSystemEnable) == 0x000001, "Wrong alignment on LItemSystem_GetPulseGaugeRechargeSystemEnable");
static_assert(sizeof(LItemSystem_GetPulseGaugeRechargeSystemEnable) == 0x000001, "Wrong size on LItemSystem_GetPulseGaugeRechargeSystemEnable");
static_assert(offsetof(LItemSystem_GetPulseGaugeRechargeSystemEnable, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPulseGaugeRechargeSystemEnable::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPulseItemExhaustedCount
// 0x0004 (0x0004 - 0x0000)
struct LItemSystem_GetPulseItemExhaustedCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPulseItemExhaustedCount) == 0x000004, "Wrong alignment on LItemSystem_GetPulseItemExhaustedCount");
static_assert(sizeof(LItemSystem_GetPulseItemExhaustedCount) == 0x000004, "Wrong size on LItemSystem_GetPulseItemExhaustedCount");
static_assert(offsetof(LItemSystem_GetPulseItemExhaustedCount, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPulseItemExhaustedCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPulseItemRechargeableCount
// 0x0004 (0x0004 - 0x0000)
struct LItemSystem_GetPulseItemRechargeableCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPulseItemRechargeableCount) == 0x000004, "Wrong alignment on LItemSystem_GetPulseItemRechargeableCount");
static_assert(sizeof(LItemSystem_GetPulseItemRechargeableCount) == 0x000004, "Wrong size on LItemSystem_GetPulseItemRechargeableCount");
static_assert(offsetof(LItemSystem_GetPulseItemRechargeableCount, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPulseItemRechargeableCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPulseItemRechargedCount
// 0x0004 (0x0004 - 0x0000)
struct LItemSystem_GetPulseItemRechargedCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPulseItemRechargedCount) == 0x000004, "Wrong alignment on LItemSystem_GetPulseItemRechargedCount");
static_assert(sizeof(LItemSystem_GetPulseItemRechargedCount) == 0x000004, "Wrong size on LItemSystem_GetPulseItemRechargedCount");
static_assert(offsetof(LItemSystem_GetPulseItemRechargedCount, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPulseItemRechargedCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetPulseRechargeable
// 0x0001 (0x0001 - 0x0000)
struct LItemSystem_GetPulseRechargeable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetPulseRechargeable) == 0x000001, "Wrong alignment on LItemSystem_GetPulseRechargeable");
static_assert(sizeof(LItemSystem_GetPulseRechargeable) == 0x000001, "Wrong size on LItemSystem_GetPulseRechargeable");
static_assert(offsetof(LItemSystem_GetPulseRechargeable, ReturnValue) == 0x000000, "Member 'LItemSystem_GetPulseRechargeable::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetReadyToUseItem
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_GetReadyToUseItem final
{
public:
	class ULActBase*                              Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutUseCount;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetReadyToUseItem) == 0x000008, "Wrong alignment on LItemSystem_GetReadyToUseItem");
static_assert(sizeof(LItemSystem_GetReadyToUseItem) == 0x000018, "Wrong size on LItemSystem_GetReadyToUseItem");
static_assert(offsetof(LItemSystem_GetReadyToUseItem, Action) == 0x000000, "Member 'LItemSystem_GetReadyToUseItem::Action' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetReadyToUseItem, OutUseCount) == 0x000008, "Member 'LItemSystem_GetReadyToUseItem::OutUseCount' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetReadyToUseItem, ReturnValue) == 0x000010, "Member 'LItemSystem_GetReadyToUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetSecondCategory_Blade
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_GetSecondCategory_Blade final
{
public:
	TArray<ELItemSecondCategory>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetSecondCategory_Blade) == 0x000008, "Wrong alignment on LItemSystem_GetSecondCategory_Blade");
static_assert(sizeof(LItemSystem_GetSecondCategory_Blade) == 0x000010, "Wrong size on LItemSystem_GetSecondCategory_Blade");
static_assert(offsetof(LItemSystem_GetSecondCategory_Blade, ReturnValue) == 0x000000, "Member 'LItemSystem_GetSecondCategory_Blade::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetSecondCategory_FromFirst
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_GetSecondCategory_FromFirst final
{
public:
	ELItemFirstCategory                           InCategory;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELItemSecondCategory>                  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetSecondCategory_FromFirst) == 0x000008, "Wrong alignment on LItemSystem_GetSecondCategory_FromFirst");
static_assert(sizeof(LItemSystem_GetSecondCategory_FromFirst) == 0x000018, "Wrong size on LItemSystem_GetSecondCategory_FromFirst");
static_assert(offsetof(LItemSystem_GetSecondCategory_FromFirst, InCategory) == 0x000000, "Member 'LItemSystem_GetSecondCategory_FromFirst::InCategory' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetSecondCategory_FromFirst, ReturnValue) == 0x000008, "Member 'LItemSystem_GetSecondCategory_FromFirst::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetSecondCategory_Handle
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_GetSecondCategory_Handle final
{
public:
	TArray<ELItemSecondCategory>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetSecondCategory_Handle) == 0x000008, "Wrong alignment on LItemSystem_GetSecondCategory_Handle");
static_assert(sizeof(LItemSystem_GetSecondCategory_Handle) == 0x000010, "Wrong size on LItemSystem_GetSecondCategory_Handle");
static_assert(offsetof(LItemSystem_GetSecondCategory_Handle, ReturnValue) == 0x000000, "Member 'LItemSystem_GetSecondCategory_Handle::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetSellShop
// 0x0008 (0x0008 - 0x0000)
struct LItemSystem_GetSellShop final
{
public:
	class ULProductSellShop*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetSellShop) == 0x000008, "Wrong alignment on LItemSystem_GetSellShop");
static_assert(sizeof(LItemSystem_GetSellShop) == 0x000008, "Wrong size on LItemSystem_GetSellShop");
static_assert(offsetof(LItemSystem_GetSellShop, ReturnValue) == 0x000000, "Member 'LItemSystem_GetSellShop::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetSpecialShop
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_GetSpecialShop final
{
public:
	class FName                                   ShopCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULProductSpecialShop*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_GetSpecialShop) == 0x000008, "Wrong alignment on LItemSystem_GetSpecialShop");
static_assert(sizeof(LItemSystem_GetSpecialShop) == 0x000010, "Wrong size on LItemSystem_GetSpecialShop");
static_assert(offsetof(LItemSystem_GetSpecialShop, ShopCodeName) == 0x000000, "Member 'LItemSystem_GetSpecialShop::ShopCodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetSpecialShop, ReturnValue) == 0x000008, "Member 'LItemSystem_GetSpecialShop::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.GetUnusableNow
// 0x000C (0x000C - 0x0000)
struct LItemSystem_GetUnusableNow final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_GetUnusableNow) == 0x000004, "Wrong alignment on LItemSystem_GetUnusableNow");
static_assert(sizeof(LItemSystem_GetUnusableNow) == 0x00000C, "Wrong size on LItemSystem_GetUnusableNow");
static_assert(offsetof(LItemSystem_GetUnusableNow, ItemCodeName) == 0x000000, "Member 'LItemSystem_GetUnusableNow::ItemCodeName' has a wrong offset!");
static_assert(offsetof(LItemSystem_GetUnusableNow, ReturnValue) == 0x000008, "Member 'LItemSystem_GetUnusableNow::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.MakeComplexItem
// 0x0018 (0x0018 - 0x0000)
struct LItemSystem_MakeComplexItem final
{
public:
	class ULItem*                                 ComplexItem_Main;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ComplexItem_Unit;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_MakeComplexItem) == 0x000008, "Wrong alignment on LItemSystem_MakeComplexItem");
static_assert(sizeof(LItemSystem_MakeComplexItem) == 0x000018, "Wrong size on LItemSystem_MakeComplexItem");
static_assert(offsetof(LItemSystem_MakeComplexItem, ComplexItem_Main) == 0x000000, "Member 'LItemSystem_MakeComplexItem::ComplexItem_Main' has a wrong offset!");
static_assert(offsetof(LItemSystem_MakeComplexItem, ComplexItem_Unit) == 0x000008, "Member 'LItemSystem_MakeComplexItem::ComplexItem_Unit' has a wrong offset!");
static_assert(offsetof(LItemSystem_MakeComplexItem, ReturnValue) == 0x000010, "Member 'LItemSystem_MakeComplexItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.OnClosedWindow
// 0x0008 (0x0008 - 0x0000)
struct LItemSystem_OnClosedWindow final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_OnClosedWindow) == 0x000004, "Wrong alignment on LItemSystem_OnClosedWindow");
static_assert(sizeof(LItemSystem_OnClosedWindow) == 0x000008, "Wrong size on LItemSystem_OnClosedWindow");
static_assert(offsetof(LItemSystem_OnClosedWindow, WidgetTableName) == 0x000000, "Member 'LItemSystem_OnClosedWindow::WidgetTableName' has a wrong offset!");

// Function ProjectP.LItemSystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LItemSystem_OnGameDataCharacterSync");
static_assert(sizeof(LItemSystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LItemSystem_OnGameDataCharacterSync");
static_assert(offsetof(LItemSystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LItemSystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LItemSystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LItemSystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LItemSystem.OnReadLetter
// 0x000C (0x000C - 0x0000)
struct LItemSystem_OnReadLetter final
{
public:
	class FName                                   InLetterName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPageNum;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_OnReadLetter) == 0x000004, "Wrong alignment on LItemSystem_OnReadLetter");
static_assert(sizeof(LItemSystem_OnReadLetter) == 0x00000C, "Wrong size on LItemSystem_OnReadLetter");
static_assert(offsetof(LItemSystem_OnReadLetter, InLetterName) == 0x000000, "Member 'LItemSystem_OnReadLetter::InLetterName' has a wrong offset!");
static_assert(offsetof(LItemSystem_OnReadLetter, InPageNum) == 0x000008, "Member 'LItemSystem_OnReadLetter::InPageNum' has a wrong offset!");

// Function ProjectP.LItemSystem.OnUpdateItemInventory
// 0x0008 (0x0008 - 0x0000)
struct LItemSystem_OnUpdateItemInventory final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_OnUpdateItemInventory) == 0x000008, "Wrong alignment on LItemSystem_OnUpdateItemInventory");
static_assert(sizeof(LItemSystem_OnUpdateItemInventory) == 0x000008, "Wrong size on LItemSystem_OnUpdateItemInventory");
static_assert(offsetof(LItemSystem_OnUpdateItemInventory, Item) == 0x000000, "Member 'LItemSystem_OnUpdateItemInventory::Item' has a wrong offset!");

// Function ProjectP.LItemSystem.ReinforceBlade
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_ReinforceBlade final
{
public:
	class ULItem*                                 BladeOrWeapon;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_ReinforceBlade) == 0x000008, "Wrong alignment on LItemSystem_ReinforceBlade");
static_assert(sizeof(LItemSystem_ReinforceBlade) == 0x000010, "Wrong size on LItemSystem_ReinforceBlade");
static_assert(offsetof(LItemSystem_ReinforceBlade, BladeOrWeapon) == 0x000000, "Member 'LItemSystem_ReinforceBlade::BladeOrWeapon' has a wrong offset!");
static_assert(offsetof(LItemSystem_ReinforceBlade, ReturnValue) == 0x000008, "Member 'LItemSystem_ReinforceBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LItemSystem.SetPulseGaugeRechargeSystemEnable
// 0x0001 (0x0001 - 0x0000)
struct LItemSystem_SetPulseGaugeRechargeSystemEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LItemSystem_SetPulseGaugeRechargeSystemEnable) == 0x000001, "Wrong alignment on LItemSystem_SetPulseGaugeRechargeSystemEnable");
static_assert(sizeof(LItemSystem_SetPulseGaugeRechargeSystemEnable) == 0x000001, "Wrong size on LItemSystem_SetPulseGaugeRechargeSystemEnable");
static_assert(offsetof(LItemSystem_SetPulseGaugeRechargeSystemEnable, bEnable) == 0x000000, "Member 'LItemSystem_SetPulseGaugeRechargeSystemEnable::bEnable' has a wrong offset!");

// Function ProjectP.LItemSystem.UseItem
// 0x0010 (0x0010 - 0x0000)
struct LItemSystem_UseItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LItemSystem_UseItem) == 0x000008, "Wrong alignment on LItemSystem_UseItem");
static_assert(sizeof(LItemSystem_UseItem) == 0x000010, "Wrong size on LItemSystem_UseItem");
static_assert(offsetof(LItemSystem_UseItem, Item) == 0x000000, "Member 'LItemSystem_UseItem::Item' has a wrong offset!");
static_assert(offsetof(LItemSystem_UseItem, UseCount) == 0x000008, "Member 'LItemSystem_UseItem::UseCount' has a wrong offset!");
static_assert(offsetof(LItemSystem_UseItem, ReturnValue) == 0x00000C, "Member 'LItemSystem_UseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LFogGateObject.SetFogGateState
// 0x0001 (0x0001 - 0x0000)
struct LFogGateObject_SetFogGateState final
{
public:
	ELFogGateState                                StateData;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFogGateObject_SetFogGateState) == 0x000001, "Wrong alignment on LFogGateObject_SetFogGateState");
static_assert(sizeof(LFogGateObject_SetFogGateState) == 0x000001, "Wrong size on LFogGateObject_SetFogGateState");
static_assert(offsetof(LFogGateObject_SetFogGateState, StateData) == 0x000000, "Member 'LFogGateObject_SetFogGateState::StateData' has a wrong offset!");

// Function ProjectP.LLevelSequenceSystem.GetLastPlayingSequenceActorData
// 0x0008 (0x0008 - 0x0000)
struct LLevelSequenceSystem_GetLastPlayingSequenceActorData final
{
public:
	class ULSequenceActorData*                    ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelSequenceSystem_GetLastPlayingSequenceActorData) == 0x000008, "Wrong alignment on LLevelSequenceSystem_GetLastPlayingSequenceActorData");
static_assert(sizeof(LLevelSequenceSystem_GetLastPlayingSequenceActorData) == 0x000008, "Wrong size on LLevelSequenceSystem_GetLastPlayingSequenceActorData");
static_assert(offsetof(LLevelSequenceSystem_GetLastPlayingSequenceActorData, ReturnValue) == 0x000000, "Member 'LLevelSequenceSystem_GetLastPlayingSequenceActorData::ReturnValue' has a wrong offset!");

// Function ProjectP.LLevelSequenceSystem.GetSequenceActorData
// 0x0010 (0x0010 - 0x0000)
struct LLevelSequenceSystem_GetSequenceActorData final
{
public:
	class FName                                   SequenceCodeName;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULSequenceActorData*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelSequenceSystem_GetSequenceActorData) == 0x000008, "Wrong alignment on LLevelSequenceSystem_GetSequenceActorData");
static_assert(sizeof(LLevelSequenceSystem_GetSequenceActorData) == 0x000010, "Wrong size on LLevelSequenceSystem_GetSequenceActorData");
static_assert(offsetof(LLevelSequenceSystem_GetSequenceActorData, SequenceCodeName) == 0x000000, "Member 'LLevelSequenceSystem_GetSequenceActorData::SequenceCodeName' has a wrong offset!");
static_assert(offsetof(LLevelSequenceSystem_GetSequenceActorData, ReturnValue) == 0x000008, "Member 'LLevelSequenceSystem_GetSequenceActorData::ReturnValue' has a wrong offset!");

// Function ProjectP.LLevelSequenceUtilFuncLibrary.ApplyPCCommand
// 0x0008 (0x0008 - 0x0000)
struct LLevelSequenceUtilFuncLibrary_ApplyPCCommand final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelSequenceUtilFuncLibrary_ApplyPCCommand) == 0x000004, "Wrong alignment on LLevelSequenceUtilFuncLibrary_ApplyPCCommand");
static_assert(sizeof(LLevelSequenceUtilFuncLibrary_ApplyPCCommand) == 0x000008, "Wrong size on LLevelSequenceUtilFuncLibrary_ApplyPCCommand");
static_assert(offsetof(LLevelSequenceUtilFuncLibrary_ApplyPCCommand, Command) == 0x000000, "Member 'LLevelSequenceUtilFuncLibrary_ApplyPCCommand::Command' has a wrong offset!");

// Function ProjectP.LLevelSequenceUtilFuncLibrary.LockPlayerAction
// 0x0008 (0x0008 - 0x0000)
struct LLevelSequenceUtilFuncLibrary_LockPlayerAction final
{
public:
	class ULevelSequencePlayer*                   NeedUnLockPlayerAction;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLevelSequenceUtilFuncLibrary_LockPlayerAction) == 0x000008, "Wrong alignment on LLevelSequenceUtilFuncLibrary_LockPlayerAction");
static_assert(sizeof(LLevelSequenceUtilFuncLibrary_LockPlayerAction) == 0x000008, "Wrong size on LLevelSequenceUtilFuncLibrary_LockPlayerAction");
static_assert(offsetof(LLevelSequenceUtilFuncLibrary_LockPlayerAction, NeedUnLockPlayerAction) == 0x000000, "Member 'LLevelSequenceUtilFuncLibrary_LockPlayerAction::NeedUnLockPlayerAction' has a wrong offset!");

// Function ProjectP.LLockOnSystem.IsFocusTarget
// 0x0010 (0x0010 - 0x0000)
struct LLockOnSystem_IsFocusTarget final
{
public:
	class AActor*                                 CheckActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LLockOnSystem_IsFocusTarget) == 0x000008, "Wrong alignment on LLockOnSystem_IsFocusTarget");
static_assert(sizeof(LLockOnSystem_IsFocusTarget) == 0x000010, "Wrong size on LLockOnSystem_IsFocusTarget");
static_assert(offsetof(LLockOnSystem_IsFocusTarget, CheckActor) == 0x000000, "Member 'LLockOnSystem_IsFocusTarget::CheckActor' has a wrong offset!");
static_assert(offsetof(LLockOnSystem_IsFocusTarget, ReturnValue) == 0x000008, "Member 'LLockOnSystem_IsFocusTarget::ReturnValue' has a wrong offset!");

// Function ProjectP.LLockOnSystem.GetLockOnTargetActor
// 0x0008 (0x0008 - 0x0000)
struct LLockOnSystem_GetLockOnTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLockOnSystem_GetLockOnTargetActor) == 0x000008, "Wrong alignment on LLockOnSystem_GetLockOnTargetActor");
static_assert(sizeof(LLockOnSystem_GetLockOnTargetActor) == 0x000008, "Wrong size on LLockOnSystem_GetLockOnTargetActor");
static_assert(offsetof(LLockOnSystem_GetLockOnTargetActor, ReturnValue) == 0x000000, "Member 'LLockOnSystem_GetLockOnTargetActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LLockOnSystem.GetLockOnTargetPointLocation
// 0x000C (0x000C - 0x0000)
struct LLockOnSystem_GetLockOnTargetPointLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLockOnSystem_GetLockOnTargetPointLocation) == 0x000004, "Wrong alignment on LLockOnSystem_GetLockOnTargetPointLocation");
static_assert(sizeof(LLockOnSystem_GetLockOnTargetPointLocation) == 0x00000C, "Wrong size on LLockOnSystem_GetLockOnTargetPointLocation");
static_assert(offsetof(LLockOnSystem_GetLockOnTargetPointLocation, ReturnValue) == 0x000000, "Member 'LLockOnSystem_GetLockOnTargetPointLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LLockOnSystem.GetLockOnTargetPointLookAtUpperLocation
// 0x000C (0x000C - 0x0000)
struct LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation) == 0x000004, "Wrong alignment on LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation");
static_assert(sizeof(LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation) == 0x00000C, "Wrong size on LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation");
static_assert(offsetof(LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation, ReturnValue) == 0x000000, "Member 'LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LLockOnSystem.IsLockOnMode
// 0x0001 (0x0001 - 0x0000)
struct LLockOnSystem_IsLockOnMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLockOnSystem_IsLockOnMode) == 0x000001, "Wrong alignment on LLockOnSystem_IsLockOnMode");
static_assert(sizeof(LLockOnSystem_IsLockOnMode) == 0x000001, "Wrong size on LLockOnSystem_IsLockOnMode");
static_assert(offsetof(LLockOnSystem_IsLockOnMode, ReturnValue) == 0x000000, "Member 'LLockOnSystem_IsLockOnMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.AddPostProcessMaterial
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_AddPostProcessMaterial final
{
public:
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_AddPostProcessMaterial) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_AddPostProcessMaterial");
static_assert(sizeof(LMiscUtilFuncLibrary_AddPostProcessMaterial) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_AddPostProcessMaterial");
static_assert(offsetof(LMiscUtilFuncLibrary_AddPostProcessMaterial, PostProcessComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_AddPostProcessMaterial::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AddPostProcessMaterial, Material) == 0x000008, "Member 'LMiscUtilFuncLibrary_AddPostProcessMaterial::Material' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AddPostProcessMaterial, InWeight) == 0x000010, "Member 'LMiscUtilFuncLibrary_AddPostProcessMaterial::InWeight' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AddPostProcessMaterial, ReturnValue) == 0x000018, "Member 'LMiscUtilFuncLibrary_AddPostProcessMaterial::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.AttachFollowingEnvSound
// 0x0048 (0x0048 - 0x0000)
struct LMiscUtilFuncLibrary_AttachFollowingEnvSound final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InPhysicalSurface;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachToComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0040(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_AttachFollowingEnvSound) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_AttachFollowingEnvSound");
static_assert(sizeof(LMiscUtilFuncLibrary_AttachFollowingEnvSound) == 0x000048, "Wrong size on LMiscUtilFuncLibrary_AttachFollowingEnvSound");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, InCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::InCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, InPhysicalSurface) == 0x000008, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::InPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, AttachToComponent) == 0x000010, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::AttachToComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, AttachPointName) == 0x000018, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::AttachPointName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, Location) == 0x000020, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, Rotation) == 0x00002C, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, LocationType) == 0x000038, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, bStopWhenAttachedToDestroyed) == 0x000039, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_AttachFollowingEnvSound, ReturnValue) == 0x000040, "Member 'LMiscUtilFuncLibrary_AttachFollowingEnvSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ChangeMaterialColor
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_ChangeMaterialColor final
{
public:
	TArray<class UMeshComponent*>                 MeshComponents;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_ChangeMaterialColor) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_ChangeMaterialColor");
static_assert(sizeof(LMiscUtilFuncLibrary_ChangeMaterialColor) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_ChangeMaterialColor");
static_assert(offsetof(LMiscUtilFuncLibrary_ChangeMaterialColor, MeshComponents) == 0x000000, "Member 'LMiscUtilFuncLibrary_ChangeMaterialColor::MeshComponents' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ChangeMaterialColor, ParameterName) == 0x000010, "Member 'LMiscUtilFuncLibrary_ChangeMaterialColor::ParameterName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ChangeMaterialColor, Value) == 0x000018, "Member 'LMiscUtilFuncLibrary_ChangeMaterialColor::Value' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ChangeMaterialScalar
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_ChangeMaterialScalar final
{
public:
	TArray<class UMeshComponent*>                 MeshComponents;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_ChangeMaterialScalar) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_ChangeMaterialScalar");
static_assert(sizeof(LMiscUtilFuncLibrary_ChangeMaterialScalar) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_ChangeMaterialScalar");
static_assert(offsetof(LMiscUtilFuncLibrary_ChangeMaterialScalar, MeshComponents) == 0x000000, "Member 'LMiscUtilFuncLibrary_ChangeMaterialScalar::MeshComponents' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ChangeMaterialScalar, ParameterName) == 0x000010, "Member 'LMiscUtilFuncLibrary_ChangeMaterialScalar::ParameterName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ChangeMaterialScalar, Value) == 0x000018, "Member 'LMiscUtilFuncLibrary_ChangeMaterialScalar::Value' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ClearAndInvalidateTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle");
static_assert(sizeof(LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle");
static_assert(offsetof(LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle, Handle) == 0x000008, "Member 'LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle::Handle' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ConvertPhysicalSurfaceNameToEnum
// 0x000C (0x000C - 0x0000)
struct LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum final
{
public:
	class FName                                   InPhysicalSurfaceName;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum");
static_assert(sizeof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum) == 0x00000C, "Wrong size on LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum");
static_assert(offsetof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum, InPhysicalSurfaceName) == 0x000000, "Member 'LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum::InPhysicalSurfaceName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ConvertPhysicalSurfaceToEnum
// 0x0002 (0x0002 - 0x0000)
struct LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum final
{
public:
	EPhysicalSurface                              InPhysicalSurface;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum) == 0x000001, "Wrong alignment on LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum");
static_assert(sizeof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum) == 0x000002, "Wrong size on LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum");
static_assert(offsetof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum, InPhysicalSurface) == 0x000000, "Member 'LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum::InPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum, ReturnValue) == 0x000001, "Member 'LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ExecuteContentCommand
// 0x000C (0x000C - 0x0000)
struct LMiscUtilFuncLibrary_ExecuteContentCommand final
{
public:
	class FName                                   CommandCodeName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_ExecuteContentCommand) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_ExecuteContentCommand");
static_assert(sizeof(LMiscUtilFuncLibrary_ExecuteContentCommand) == 0x00000C, "Wrong size on LMiscUtilFuncLibrary_ExecuteContentCommand");
static_assert(offsetof(LMiscUtilFuncLibrary_ExecuteContentCommand, CommandCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_ExecuteContentCommand::CommandCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ExecuteContentCommand, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_ExecuteContentCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ExecuteWorldEvent
// 0x0030 (0x0030 - 0x0000)
struct LMiscUtilFuncLibrary_ExecuteWorldEvent final
{
public:
	ELCallBackEventType                           CallBackEventType;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Param1;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Param2;                                            // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_ExecuteWorldEvent) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_ExecuteWorldEvent");
static_assert(sizeof(LMiscUtilFuncLibrary_ExecuteWorldEvent) == 0x000030, "Wrong size on LMiscUtilFuncLibrary_ExecuteWorldEvent");
static_assert(offsetof(LMiscUtilFuncLibrary_ExecuteWorldEvent, CallBackEventType) == 0x000000, "Member 'LMiscUtilFuncLibrary_ExecuteWorldEvent::CallBackEventType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ExecuteWorldEvent, Param1) == 0x000008, "Member 'LMiscUtilFuncLibrary_ExecuteWorldEvent::Param1' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ExecuteWorldEvent, Param2) == 0x000018, "Member 'LMiscUtilFuncLibrary_ExecuteWorldEvent::Param2' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ExecuteWorldEvent, ReturnValue) == 0x000028, "Member 'LMiscUtilFuncLibrary_ExecuteWorldEvent::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindClosestBoneOnPhysicsAsset
// 0x0048 (0x0048 - 0x0000)
struct LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldImpulse;                                      // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApproximate;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SearchBoneNames;                                   // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FName                                   ClosestBoneName;                                   // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset");
static_assert(sizeof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset) == 0x000048, "Wrong size on LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, MeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::MeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, WorldPosition) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::WorldPosition' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, WorldImpulse) == 0x000014, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::WorldImpulse' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, bApproximate) == 0x000020, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::bApproximate' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, SearchBoneNames) == 0x000028, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::SearchBoneNames' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, ClosestBoneName) == 0x000038, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::ClosestBoneName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset, ReturnValue) == 0x000040, "Member 'LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindComponentForEffect
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_FindComponentForEffect final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXSocket;                                          // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_FindComponentForEffect) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindComponentForEffect");
static_assert(sizeof(LMiscUtilFuncLibrary_FindComponentForEffect) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_FindComponentForEffect");
static_assert(offsetof(LMiscUtilFuncLibrary_FindComponentForEffect, SkeletalMeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindComponentForEffect::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindComponentForEffect, Actor) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindComponentForEffect::Actor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindComponentForEffect, FXSocket) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindComponentForEffect::FXSocket' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindComponentForEffect, MeshSelectionType) == 0x000018, "Member 'LMiscUtilFuncLibrary_FindComponentForEffect::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindComponentForEffect, ReturnValue) == 0x000020, "Member 'LMiscUtilFuncLibrary_FindComponentForEffect::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindLowerBoneList
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_FindLowerBoneList final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneList;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_FindLowerBoneList) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindLowerBoneList");
static_assert(sizeof(LMiscUtilFuncLibrary_FindLowerBoneList) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_FindLowerBoneList");
static_assert(offsetof(LMiscUtilFuncLibrary_FindLowerBoneList, MeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindLowerBoneList::MeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindLowerBoneList, BoneName) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindLowerBoneList::BoneName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindLowerBoneList, BoneList) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindLowerBoneList::BoneList' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindLowerBoneList, ReturnValue) == 0x000020, "Member 'LMiscUtilFuncLibrary_FindLowerBoneList::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindNearbyBoneList
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_FindNearbyBoneList final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneList;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_FindNearbyBoneList) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindNearbyBoneList");
static_assert(sizeof(LMiscUtilFuncLibrary_FindNearbyBoneList) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_FindNearbyBoneList");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearbyBoneList, MeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindNearbyBoneList::MeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearbyBoneList, BoneName) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindNearbyBoneList::BoneName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearbyBoneList, BoneList) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindNearbyBoneList::BoneList' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearbyBoneList, ReturnValue) == 0x000020, "Member 'LMiscUtilFuncLibrary_FindNearbyBoneList::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindNearestFloatInArray
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_FindNearestFloatInArray final
{
public:
	TArray<float>                                 FloatArray;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         InputFloat;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_FindNearestFloatInArray) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindNearestFloatInArray");
static_assert(sizeof(LMiscUtilFuncLibrary_FindNearestFloatInArray) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_FindNearestFloatInArray");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearestFloatInArray, FloatArray) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindNearestFloatInArray::FloatArray' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearestFloatInArray, InputFloat) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindNearestFloatInArray::InputFloat' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindNearestFloatInArray, ReturnValue) == 0x000014, "Member 'LMiscUtilFuncLibrary_FindNearestFloatInArray::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindSplashBloodFx
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_FindSplashBloodFx final
{
public:
	ELBloodEffectType                             InBloodType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         OutParticle;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        OutTrail;                                          // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_FindSplashBloodFx) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindSplashBloodFx");
static_assert(sizeof(LMiscUtilFuncLibrary_FindSplashBloodFx) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_FindSplashBloodFx");
static_assert(offsetof(LMiscUtilFuncLibrary_FindSplashBloodFx, InBloodType) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindSplashBloodFx::InBloodType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindSplashBloodFx, OutParticle) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindSplashBloodFx::OutParticle' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindSplashBloodFx, OutTrail) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindSplashBloodFx::OutTrail' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindSplashBloodFx, ReturnValue) == 0x000018, "Member 'LMiscUtilFuncLibrary_FindSplashBloodFx::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindWeatherFx
// 0x00C8 (0x00C8 - 0x0000)
struct LMiscUtilFuncLibrary_FindWeatherFx final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         OutNiagara;                                        // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutOffset;                                         // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      OutDefaultScalarVariables;                         // 0x0020(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              OutDefautlColorVariables;                          // 0x0070(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_FindWeatherFx) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindWeatherFx");
static_assert(sizeof(LMiscUtilFuncLibrary_FindWeatherFx) == 0x0000C8, "Wrong size on LMiscUtilFuncLibrary_FindWeatherFx");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherFx, InCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindWeatherFx::InCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherFx, OutNiagara) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindWeatherFx::OutNiagara' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherFx, OutOffset) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindWeatherFx::OutOffset' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherFx, OutDefaultScalarVariables) == 0x000020, "Member 'LMiscUtilFuncLibrary_FindWeatherFx::OutDefaultScalarVariables' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherFx, OutDefautlColorVariables) == 0x000070, "Member 'LMiscUtilFuncLibrary_FindWeatherFx::OutDefautlColorVariables' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherFx, ReturnValue) == 0x0000C0, "Member 'LMiscUtilFuncLibrary_FindWeatherFx::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FindWeatherSound
// 0x00B8 (0x00B8 - 0x0000)
struct LMiscUtilFuncLibrary_FindWeatherSound final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OutSound;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      OutDefaultScalarVariables;                         // 0x0010(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              OutDefautlColorVariables;                          // 0x0060(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_FindWeatherSound) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_FindWeatherSound");
static_assert(sizeof(LMiscUtilFuncLibrary_FindWeatherSound) == 0x0000B8, "Wrong size on LMiscUtilFuncLibrary_FindWeatherSound");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherSound, InCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_FindWeatherSound::InCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherSound, OutSound) == 0x000008, "Member 'LMiscUtilFuncLibrary_FindWeatherSound::OutSound' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherSound, OutDefaultScalarVariables) == 0x000010, "Member 'LMiscUtilFuncLibrary_FindWeatherSound::OutDefaultScalarVariables' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherSound, OutDefautlColorVariables) == 0x000060, "Member 'LMiscUtilFuncLibrary_FindWeatherSound::OutDefautlColorVariables' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_FindWeatherSound, ReturnValue) == 0x0000B0, "Member 'LMiscUtilFuncLibrary_FindWeatherSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.FlushAudioCache
// 0x0001 (0x0001 - 0x0000)
struct LMiscUtilFuncLibrary_FlushAudioCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_FlushAudioCache) == 0x000001, "Wrong alignment on LMiscUtilFuncLibrary_FlushAudioCache");
static_assert(sizeof(LMiscUtilFuncLibrary_FlushAudioCache) == 0x000001, "Wrong size on LMiscUtilFuncLibrary_FlushAudioCache");
static_assert(offsetof(LMiscUtilFuncLibrary_FlushAudioCache, ReturnValue) == 0x000000, "Member 'LMiscUtilFuncLibrary_FlushAudioCache::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GameObject_Activate
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GameObject_Activate final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceReset;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GameObject_Activate) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GameObject_Activate");
static_assert(sizeof(LMiscUtilFuncLibrary_GameObject_Activate) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GameObject_Activate");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_Activate, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GameObject_Activate::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_Activate, ForceReset) == 0x000008, "Member 'LMiscUtilFuncLibrary_GameObject_Activate::ForceReset' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_Activate, ReturnValue) == 0x000009, "Member 'LMiscUtilFuncLibrary_GameObject_Activate::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GameObject_Deactivate
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GameObject_Deactivate final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GameObject_Deactivate) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GameObject_Deactivate");
static_assert(sizeof(LMiscUtilFuncLibrary_GameObject_Deactivate) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GameObject_Deactivate");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_Deactivate, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GameObject_Deactivate::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_Deactivate, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GameObject_Deactivate::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GameObject_GetState
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GameObject_GetState final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameObjectState                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GameObject_GetState) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GameObject_GetState");
static_assert(sizeof(LMiscUtilFuncLibrary_GameObject_GetState) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GameObject_GetState");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_GetState, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GameObject_GetState::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GameObject_GetState, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GameObject_GetState::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetBuildConfiguration
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GetBuildConfiguration final
{
public:
	class FString                                 Configuration;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetBuildConfiguration) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetBuildConfiguration");
static_assert(sizeof(LMiscUtilFuncLibrary_GetBuildConfiguration) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GetBuildConfiguration");
static_assert(offsetof(LMiscUtilFuncLibrary_GetBuildConfiguration, Configuration) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetBuildConfiguration::Configuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetConstantValues
// 0x0008 (0x0008 - 0x0000)
struct LMiscUtilFuncLibrary_GetConstantValues final
{
public:
	class ULCommonConstantValues*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetConstantValues) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetConstantValues");
static_assert(sizeof(LMiscUtilFuncLibrary_GetConstantValues) == 0x000008, "Wrong size on LMiscUtilFuncLibrary_GetConstantValues");
static_assert(offsetof(LMiscUtilFuncLibrary_GetConstantValues, ReturnValue) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetConstantValues::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetCurrentLever
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_GetCurrentLever final
{
public:
	class APawn*                                  TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetCurrentLever) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetCurrentLever");
static_assert(sizeof(LMiscUtilFuncLibrary_GetCurrentLever) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_GetCurrentLever");
static_assert(offsetof(LMiscUtilFuncLibrary_GetCurrentLever, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetCurrentLever::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetCurrentLever, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetCurrentLever::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetEquipmentComponentBP
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GetEquipmentComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULEquipmentComponent*                   ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetEquipmentComponentBP) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetEquipmentComponentBP");
static_assert(sizeof(LMiscUtilFuncLibrary_GetEquipmentComponentBP) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GetEquipmentComponentBP");
static_assert(offsetof(LMiscUtilFuncLibrary_GetEquipmentComponentBP, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetEquipmentComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetEquipmentComponentBP, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetEquipmentComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetFXComponent
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GetFXComponent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULFXComponent*                          ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetFXComponent) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetFXComponent");
static_assert(sizeof(LMiscUtilFuncLibrary_GetFXComponent) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GetFXComponent");
static_assert(offsetof(LMiscUtilFuncLibrary_GetFXComponent, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetFXComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetFXComponent, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetFXComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetHitSweepLocation
// 0x0094 (0x0094 - 0x0000)
struct LMiscUtilFuncLibrary_GetHitSweepLocation final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0088(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetHitSweepLocation) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_GetHitSweepLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_GetHitSweepLocation) == 0x000094, "Wrong size on LMiscUtilFuncLibrary_GetHitSweepLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_GetHitSweepLocation, HitResult) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetHitSweepLocation::HitResult' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetHitSweepLocation, ReturnValue) == 0x000088, "Member 'LMiscUtilFuncLibrary_GetHitSweepLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetLBodyStainComponentBP
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_GetLBodyStainComponentBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULBodyStainComponent*                   ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetLBodyStainComponentBP) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetLBodyStainComponentBP");
static_assert(sizeof(LMiscUtilFuncLibrary_GetLBodyStainComponentBP) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_GetLBodyStainComponentBP");
static_assert(offsetof(LMiscUtilFuncLibrary_GetLBodyStainComponentBP, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetLBodyStainComponentBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetLBodyStainComponentBP, Branches) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetLBodyStainComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetLBodyStainComponentBP, ReturnValue) == 0x000010, "Member 'LMiscUtilFuncLibrary_GetLBodyStainComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetMeshComponentsBySelectionType
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 OutComponents;                                     // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           SelectType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType");
static_assert(sizeof(LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType");
static_assert(offsetof(LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType, Actor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType::Actor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType, OutComponents) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType::OutComponents' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType, SelectType) == 0x000018, "Member 'LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType::SelectType' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetNPCSpot
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_GetNPCSpot final
{
public:
	class FString                                 InUniqueSpotId;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCSpot*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetNPCSpot) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetNPCSpot");
static_assert(sizeof(LMiscUtilFuncLibrary_GetNPCSpot) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_GetNPCSpot");
static_assert(offsetof(LMiscUtilFuncLibrary_GetNPCSpot, InUniqueSpotId) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetNPCSpot::InUniqueSpotId' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetNPCSpot, ReturnValue) == 0x000010, "Member 'LMiscUtilFuncLibrary_GetNPCSpot::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetObjectFName
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GetObjectFName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetObjectFName) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetObjectFName");
static_assert(sizeof(LMiscUtilFuncLibrary_GetObjectFName) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GetObjectFName");
static_assert(offsetof(LMiscUtilFuncLibrary_GetObjectFName, Object) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetObjectFName::Object' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetObjectFName, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetObjectFName::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetObjectName
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_GetObjectName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetObjectName) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetObjectName");
static_assert(sizeof(LMiscUtilFuncLibrary_GetObjectName) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_GetObjectName");
static_assert(offsetof(LMiscUtilFuncLibrary_GetObjectName, Object) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetObjectName::Object' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetObjectName, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetObjectName::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetProjectileCorrectionGrade
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_GetProjectileCorrectionGrade final
{
public:
	ELFirstStat                                   Stat;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ULItem*                           ConsumeItem;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponCorrectionPhysicalGrade               ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetProjectileCorrectionGrade) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetProjectileCorrectionGrade");
static_assert(sizeof(LMiscUtilFuncLibrary_GetProjectileCorrectionGrade) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_GetProjectileCorrectionGrade");
static_assert(offsetof(LMiscUtilFuncLibrary_GetProjectileCorrectionGrade, Stat) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetProjectileCorrectionGrade::Stat' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetProjectileCorrectionGrade, ConsumeItem) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetProjectileCorrectionGrade::ConsumeItem' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetProjectileCorrectionGrade, ReturnValue) == 0x000010, "Member 'LMiscUtilFuncLibrary_GetProjectileCorrectionGrade::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetRigidBodyBoneList
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_GetRigidBodyBoneList final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneList;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetRigidBodyBoneList) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetRigidBodyBoneList");
static_assert(sizeof(LMiscUtilFuncLibrary_GetRigidBodyBoneList) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_GetRigidBodyBoneList");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoneList, MeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoneList::MeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoneList, BoneList) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoneList::BoneList' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoneList, ReturnValue) == 0x000018, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoneList::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetRigidBodyBox
// 0x0038 (0x0038 - 0x0000)
struct LMiscUtilFuncLibrary_GetRigidBodyBox final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BoundExtent;                                       // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetRigidBodyBox) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetRigidBodyBox");
static_assert(sizeof(LMiscUtilFuncLibrary_GetRigidBodyBox) == 0x000038, "Wrong size on LMiscUtilFuncLibrary_GetRigidBodyBox");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBox, MeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBox::MeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBox, BoneName) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBox::BoneName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBox, Location) == 0x000010, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBox::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBox, Rotation) == 0x00001C, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBox::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBox, BoundExtent) == 0x000028, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBox::BoundExtent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBox, ReturnValue) == 0x000034, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBox::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetRigidBodyBoxNearby
// 0x0038 (0x0038 - 0x0000)
struct LMiscUtilFuncLibrary_GetRigidBodyBoxNearby final
{
public:
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BoundExtent;                                       // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetRigidBodyBoxNearby");
static_assert(sizeof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby) == 0x000038, "Wrong size on LMiscUtilFuncLibrary_GetRigidBodyBoxNearby");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby, MeshComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoxNearby::MeshComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby, BoneName) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoxNearby::BoneName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby, Location) == 0x000010, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoxNearby::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby, Rotation) == 0x00001C, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoxNearby::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby, BoundExtent) == 0x000028, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoxNearby::BoundExtent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetRigidBodyBoxNearby, ReturnValue) == 0x000034, "Member 'LMiscUtilFuncLibrary_GetRigidBodyBoxNearby::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetShaderPrecompileRemainingCount
// 0x0004 (0x0004 - 0x0000)
struct LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount");
static_assert(sizeof(LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount) == 0x000004, "Wrong size on LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount");
static_assert(offsetof(LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount, ReturnValue) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetSlaveArmCorrectionGrade
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade final
{
public:
	ELFirstStat                                   Stat;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class ULItem*                           SlaveArmItem;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponCorrectionPhysicalGrade               ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade");
static_assert(sizeof(LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade");
static_assert(offsetof(LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade, Stat) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade::Stat' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade, SlaveArmItem) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade::SlaveArmItem' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade, ReturnValue) == 0x000010, "Member 'LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetSpecialBuffLocalText
// 0x0038 (0x0038 - 0x0000)
struct LMiscUtilFuncLibrary_GetSpecialBuffLocalText final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutName;                                           // 0x0008(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FText                                   OutTooltip;                                        // 0x0020(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetSpecialBuffLocalText) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetSpecialBuffLocalText");
static_assert(sizeof(LMiscUtilFuncLibrary_GetSpecialBuffLocalText) == 0x000038, "Wrong size on LMiscUtilFuncLibrary_GetSpecialBuffLocalText");
static_assert(offsetof(LMiscUtilFuncLibrary_GetSpecialBuffLocalText, CodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetSpecialBuffLocalText::CodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetSpecialBuffLocalText, OutName) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetSpecialBuffLocalText::OutName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetSpecialBuffLocalText, OutTooltip) == 0x000020, "Member 'LMiscUtilFuncLibrary_GetSpecialBuffLocalText::OutTooltip' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetStatRoomPC
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_GetStatRoomPC final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALStatRoomPCCharacter*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_GetStatRoomPC) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetStatRoomPC");
static_assert(sizeof(LMiscUtilFuncLibrary_GetStatRoomPC) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_GetStatRoomPC");
static_assert(offsetof(LMiscUtilFuncLibrary_GetStatRoomPC, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetStatRoomPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetStatRoomPC, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetStatRoomPC::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.GetWeaponMeshComponentsBySelectionType
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType final
{
public:
	class ALWeapon*                               WeaponActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMeshComponent*>                 OutComponents;                                     // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           SelectType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType");
static_assert(sizeof(LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType");
static_assert(offsetof(LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType, WeaponActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType::WeaponActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType, OutComponents) == 0x000008, "Member 'LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType::OutComponents' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType, SelectType) == 0x000018, "Member 'LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType::SelectType' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.HideManagedNiagaraComponentsBP
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hide;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP");
static_assert(sizeof(LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP");
static_assert(offsetof(LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP, Hide) == 0x000008, "Member 'LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP::Hide' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP, Branches) == 0x000009, "Member 'LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP::Branches' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.IsLiquidSurface
// 0x0002 (0x0002 - 0x0000)
struct LMiscUtilFuncLibrary_IsLiquidSurface final
{
public:
	ELPhysicalSurfaceType                         PhysicalSurfaceType;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_IsLiquidSurface) == 0x000001, "Wrong alignment on LMiscUtilFuncLibrary_IsLiquidSurface");
static_assert(sizeof(LMiscUtilFuncLibrary_IsLiquidSurface) == 0x000002, "Wrong size on LMiscUtilFuncLibrary_IsLiquidSurface");
static_assert(offsetof(LMiscUtilFuncLibrary_IsLiquidSurface, PhysicalSurfaceType) == 0x000000, "Member 'LMiscUtilFuncLibrary_IsLiquidSurface::PhysicalSurfaceType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_IsLiquidSurface, ReturnValue) == 0x000001, "Member 'LMiscUtilFuncLibrary_IsLiquidSurface::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.IsNearPC
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_IsNearPC final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_IsNearPC) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_IsNearPC");
static_assert(sizeof(LMiscUtilFuncLibrary_IsNearPC) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_IsNearPC");
static_assert(offsetof(LMiscUtilFuncLibrary_IsNearPC, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_IsNearPC::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_IsNearPC, Location) == 0x000008, "Member 'LMiscUtilFuncLibrary_IsNearPC::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_IsNearPC, ReturnValue) == 0x000014, "Member 'LMiscUtilFuncLibrary_IsNearPC::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.IsPCInBox
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_IsPCInBox final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          Box;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_IsPCInBox) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_IsPCInBox");
static_assert(sizeof(LMiscUtilFuncLibrary_IsPCInBox) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_IsPCInBox");
static_assert(offsetof(LMiscUtilFuncLibrary_IsPCInBox, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_IsPCInBox::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_IsPCInBox, Box) == 0x000008, "Member 'LMiscUtilFuncLibrary_IsPCInBox::Box' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_IsPCInBox, ReturnValue) == 0x000010, "Member 'LMiscUtilFuncLibrary_IsPCInBox::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.IsRightAcceptButton
// 0x0001 (0x0001 - 0x0000)
struct LMiscUtilFuncLibrary_IsRightAcceptButton final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_IsRightAcceptButton) == 0x000001, "Wrong alignment on LMiscUtilFuncLibrary_IsRightAcceptButton");
static_assert(sizeof(LMiscUtilFuncLibrary_IsRightAcceptButton) == 0x000001, "Wrong size on LMiscUtilFuncLibrary_IsRightAcceptButton");
static_assert(offsetof(LMiscUtilFuncLibrary_IsRightAcceptButton, ReturnValue) == 0x000000, "Member 'LMiscUtilFuncLibrary_IsRightAcceptButton::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.IsValidEventCondition
// 0x000C (0x000C - 0x0000)
struct LMiscUtilFuncLibrary_IsValidEventCondition final
{
public:
	class FName                                   ConditionName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_IsValidEventCondition) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_IsValidEventCondition");
static_assert(sizeof(LMiscUtilFuncLibrary_IsValidEventCondition) == 0x00000C, "Wrong size on LMiscUtilFuncLibrary_IsValidEventCondition");
static_assert(offsetof(LMiscUtilFuncLibrary_IsValidEventCondition, ConditionName) == 0x000000, "Member 'LMiscUtilFuncLibrary_IsValidEventCondition::ConditionName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_IsValidEventCondition, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_IsValidEventCondition::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.LoadAndAddComponent
// 0x0038 (0x0038 - 0x0000)
struct LMiscUtilFuncLibrary_LoadAndAddComponent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TargetComponentClass;                              // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_LoadAndAddComponent) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_LoadAndAddComponent");
static_assert(sizeof(LMiscUtilFuncLibrary_LoadAndAddComponent) == 0x000038, "Wrong size on LMiscUtilFuncLibrary_LoadAndAddComponent");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAddComponent, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_LoadAndAddComponent::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAddComponent, TargetComponentClass) == 0x000008, "Member 'LMiscUtilFuncLibrary_LoadAndAddComponent::TargetComponentClass' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAddComponent, ReturnValue) == 0x000030, "Member 'LMiscUtilFuncLibrary_LoadAndAddComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.LoadAndAttachToComponent
// 0x0048 (0x0048 - 0x0000)
struct LMiscUtilFuncLibrary_LoadAndAttachToComponent final
{
public:
	class USceneComponent*                        AttachTargetComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TargetComponentClass;                              // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x003A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x003B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReturnValue;                                       // 0x0040(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_LoadAndAttachToComponent) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_LoadAndAttachToComponent");
static_assert(sizeof(LMiscUtilFuncLibrary_LoadAndAttachToComponent) == 0x000048, "Wrong size on LMiscUtilFuncLibrary_LoadAndAttachToComponent");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, AttachTargetComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::AttachTargetComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, TargetComponentClass) == 0x000008, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::TargetComponentClass' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, SocketName) == 0x000030, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::SocketName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, LocationRule) == 0x000038, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::LocationRule' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, RotationRule) == 0x000039, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::RotationRule' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, ScaleRule) == 0x00003A, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::ScaleRule' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, bWeldSimulatedBodies) == 0x00003B, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::bWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LoadAndAttachToComponent, ReturnValue) == 0x000040, "Member 'LMiscUtilFuncLibrary_LoadAndAttachToComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.LogBP
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_LogBP final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Msg;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                LogInstigator;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowScreen;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowScreenDuration;                                // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_LogBP) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_LogBP");
static_assert(sizeof(LMiscUtilFuncLibrary_LogBP) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_LogBP");
static_assert(offsetof(LMiscUtilFuncLibrary_LogBP, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_LogBP::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogBP, Msg) == 0x000008, "Member 'LMiscUtilFuncLibrary_LogBP::Msg' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogBP, LogInstigator) == 0x000018, "Member 'LMiscUtilFuncLibrary_LogBP::LogInstigator' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogBP, ShowScreen) == 0x000020, "Member 'LMiscUtilFuncLibrary_LogBP::ShowScreen' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogBP, ShowScreenDuration) == 0x000024, "Member 'LMiscUtilFuncLibrary_LogBP::ShowScreenDuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.LogForWarningBP
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_LogForWarningBP final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Msg;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                LogInstigator;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowScreen;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowScreenDuration;                                // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_LogForWarningBP) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_LogForWarningBP");
static_assert(sizeof(LMiscUtilFuncLibrary_LogForWarningBP) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_LogForWarningBP");
static_assert(offsetof(LMiscUtilFuncLibrary_LogForWarningBP, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_LogForWarningBP::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogForWarningBP, Msg) == 0x000008, "Member 'LMiscUtilFuncLibrary_LogForWarningBP::Msg' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogForWarningBP, LogInstigator) == 0x000018, "Member 'LMiscUtilFuncLibrary_LogForWarningBP::LogInstigator' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogForWarningBP, ShowScreen) == 0x000020, "Member 'LMiscUtilFuncLibrary_LogForWarningBP::ShowScreen' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_LogForWarningBP, ShowScreenDuration) == 0x000024, "Member 'LMiscUtilFuncLibrary_LogForWarningBP::ShowScreenDuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayCameraShake
// 0x0020 (0x0020 - 0x0000)
struct LMiscUtilFuncLibrary_PlayCameraShake final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Epicenter;                                         // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayCameraShake) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayCameraShake");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayCameraShake) == 0x000020, "Wrong size on LMiscUtilFuncLibrary_PlayCameraShake");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCameraShake, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayCameraShake::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCameraShake, TableCodeName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayCameraShake::TableCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCameraShake, Epicenter) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayCameraShake::Epicenter' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCameraShake, ReturnValue) == 0x00001C, "Member 'LMiscUtilFuncLibrary_PlayCameraShake::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayCharacterSoundAtLocation
// 0x0080 (0x0080 - 0x0000)
struct LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterSoundTypeCodeName;                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0068(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0078(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation) == 0x000080, "Wrong size on LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, EventName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, CharacterSoundTypeCodeName) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::CharacterSoundTypeCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, SpawnTransform) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, VolumeMultiplier) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, PitchMultiplier) == 0x000054, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, StartTime) == 0x000058, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, AttenuationSettings) == 0x000060, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, ConcurrencySettings) == 0x000068, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, bAutoDestroy) == 0x000070, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation, ReturnValue) == 0x000078, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayCharacterSoundAttached
// 0x0068 (0x0068 - 0x0000)
struct LMiscUtilFuncLibrary_PlayCharacterSoundAttached final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterSoundTypeCodeName;                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeMultiplier;                                  // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0060(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayCharacterSoundAttached");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached) == 0x000068, "Wrong size on LMiscUtilFuncLibrary_PlayCharacterSoundAttached");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, EventName) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, CharacterSoundTypeCodeName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::CharacterSoundTypeCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, AttachToComponent) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, AttachPointName) == 0x000018, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, Location) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, Rotation) == 0x00002C, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, LocationType) == 0x000038, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, bStopWhenAttachedToDestroyed) == 0x000039, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, VolumeMultiplier) == 0x00003C, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, PitchMultiplier) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, StartTime) == 0x000044, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::StartTime' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, AttenuationSettings) == 0x000048, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, ConcurrencySettings) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, bAutoDestroy) == 0x000058, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayCharacterSoundAttached, ReturnValue) == 0x000060, "Member 'LMiscUtilFuncLibrary_PlayCharacterSoundAttached::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayExplosiveKillFx
// 0x0050 (0x0050 - 0x0000)
struct LMiscUtilFuncLibrary_PlayExplosiveKillFx final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Attribute;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TargetFxSocketArray;                               // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayExplosiveKillFx) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayExplosiveKillFx");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayExplosiveKillFx) == 0x000050, "Wrong size on LMiscUtilFuncLibrary_PlayExplosiveKillFx");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, EventName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, Attribute) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::Attribute' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, Location) == 0x000018, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, Rotation) == 0x000024, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, LocationType) == 0x000030, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, TargetFxSocketArray) == 0x000038, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::TargetFxSocketArray' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayExplosiveKillFx, ReturnValue) == 0x000048, "Member 'LMiscUtilFuncLibrary_PlayExplosiveKillFx::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayFxCommon_Attach
// 0x0050 (0x0050 - 0x0000)
struct LMiscUtilFuncLibrary_PlayFxCommon_Attach final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayFx;                                           // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySound;                                        // 0x0033(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAttachedEffectSet                    ReturnValue;                                       // 0x0034(0x001C)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayFxCommon_Attach) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayFxCommon_Attach");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayFxCommon_Attach) == 0x000050, "Wrong size on LMiscUtilFuncLibrary_PlayFxCommon_Attach");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, EventName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, SocketName) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::SocketName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, Location) == 0x000018, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, Rotation) == 0x000024, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, LocationType) == 0x000030, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, bAutoDestroy) == 0x000031, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, bPlayFx) == 0x000032, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::bPlayFx' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, bPlaySound) == 0x000033, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::bPlaySound' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Attach, ReturnValue) == 0x000034, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Attach::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayFxCommon_Location
// 0x0040 (0x0040 - 0x0000)
struct LMiscUtilFuncLibrary_PlayFxCommon_Location final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0028(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayFx;                                           // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySound;                                        // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayFxCommon_Location) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayFxCommon_Location");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayFxCommon_Location) == 0x000040, "Wrong size on LMiscUtilFuncLibrary_PlayFxCommon_Location");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, EventName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, Location) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, Rotation) == 0x00001C, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, Scale) == 0x000028, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::Scale' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, VolumeMultiplier) == 0x000034, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, bPlayFx) == 0x000038, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::bPlayFx' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayFxCommon_Location, bPlaySound) == 0x000039, "Member 'LMiscUtilFuncLibrary_PlayFxCommon_Location::bPlaySound' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayHitFx
// 0x0060 (0x0060 - 0x0000)
struct LMiscUtilFuncLibrary_PlayHitFx final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitFXType                                   InHitFxType;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitFX_SecondaryType                         InSecondType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InAttackerMaterial;                                // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Attribute;                                         // 0x0014(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              InPower;                                           // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFxVictimType                                VictimType;                                        // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayHitFx) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayHitFx");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayHitFx) == 0x000060, "Wrong size on LMiscUtilFuncLibrary_PlayHitFx");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayHitFx::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, Victim) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayHitFx::Victim' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, InHitFxType) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayHitFx::InHitFxType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, InSecondType) == 0x000011, "Member 'LMiscUtilFuncLibrary_PlayHitFx::InSecondType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, InAttackerMaterial) == 0x000012, "Member 'LMiscUtilFuncLibrary_PlayHitFx::InAttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, Attribute) == 0x000014, "Member 'LMiscUtilFuncLibrary_PlayHitFx::Attribute' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, InPower) == 0x00001C, "Member 'LMiscUtilFuncLibrary_PlayHitFx::InPower' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, VictimType) == 0x00001D, "Member 'LMiscUtilFuncLibrary_PlayHitFx::VictimType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, SpawnTransform) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayHitFx::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFx, ReturnValue) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayHitFx::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayHitFxAttached
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_PlayHitFxAttached final
{
public:
	class AActor*                                 ActorToAttach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitFXType                                   InHitFxType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitFX_SecondaryType                         InSecondType;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InAttackerMaterial;                                // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Attribute;                                         // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              InPower;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFxVictimType                                VictimType;                                        // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0016(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayHitFxAttached) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayHitFxAttached");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayHitFxAttached) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_PlayHitFxAttached");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, ActorToAttach) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::ActorToAttach' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, InHitFxType) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::InHitFxType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, InSecondType) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::InSecondType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, InAttackerMaterial) == 0x00000A, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::InAttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, Attribute) == 0x00000C, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::Attribute' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, InPower) == 0x000014, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::InPower' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, VictimType) == 0x000015, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::VictimType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitFxAttached, ReturnValue) == 0x000016, "Member 'LMiscUtilFuncLibrary_PlayHitFxAttached::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayHitSFX
// 0x0070 (0x0070 - 0x0000)
struct LMiscUtilFuncLibrary_PlayHitSFX final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitSoundType                                InHitSoundType;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitSound_SecondaryType                      InSecondType;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Attribute;                                         // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InAttackerMaterial;                                // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InPhysicalSurface;                                 // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              InPower;                                           // 0x0016(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFxVictimType                                VictimType;                                        // 0x0017(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlay2DSound;                                      // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0061(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0xE];                                       // 0x0062(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayHitSFX) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayHitSFX");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayHitSFX) == 0x000070, "Wrong size on LMiscUtilFuncLibrary_PlayHitSFX");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, InHitSoundType) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::InHitSoundType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, InSecondType) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::InSecondType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, Attribute) == 0x00000C, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::Attribute' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, InAttackerMaterial) == 0x000014, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::InAttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, InPhysicalSurface) == 0x000015, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::InPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, InPower) == 0x000016, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::InPower' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, VictimType) == 0x000017, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::VictimType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, SpawnTransform) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, VolumeMultiplier) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, PitchMultiplier) == 0x000054, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, OwningActor) == 0x000058, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::OwningActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, bPlay2DSound) == 0x000060, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::bPlay2DSound' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayHitSFX, ReturnValue) == 0x000061, "Member 'LMiscUtilFuncLibrary_PlayHitSFX::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceFxAtLocation
// 0x0070 (0x0070 - 0x0000)
struct LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceFXConditionType              InCondition;                                       // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0060(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation) == 0x000070, "Wrong size on LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, EventName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, PhysicalSurface) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, InCondition) == 0x000011, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::InCondition' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, SpawnTransform) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, bAutoDestroy) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, Instigator) == 0x000058, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::Instigator' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation, ReturnValue) == 0x000060, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceFxAttached
// 0x0048 (0x0048 - 0x0000)
struct LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceFXConditionType              InCondition;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachToComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0040(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached) == 0x000048, "Wrong size on LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, EventName) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, PhysicalSurface) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, InCondition) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::InCondition' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, AttachToComponent) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, AttachPointName) == 0x000018, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, Location) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, Rotation) == 0x00002C, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, LocationType) == 0x000038, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, bAutoDestroy) == 0x000039, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached, ReturnValue) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceSoundAtLocation
// 0x0080 (0x0080 - 0x0000)
struct LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceFXConditionType              InCondition;                                       // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0xE];                                       // 0x0012(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurveValue;                                        // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0068(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0078(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation) == 0x000080, "Wrong size on LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, EventName) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, PhysicalSurface) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, InCondition) == 0x000011, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::InCondition' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, SpawnTransform) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, CurveValue) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::CurveValue' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, VolumeMultiplier) == 0x000054, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, PitchMultiplier) == 0x000058, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, StartTime) == 0x00005C, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, AttenuationSettings) == 0x000060, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, ConcurrencySettings) == 0x000068, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, bAutoDestroy) == 0x000070, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation, ReturnValue) == 0x000078, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceSoundAttached
// 0x0070 (0x0070 - 0x0000)
struct LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceFXConditionType              InCondition;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachToComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveValue;                                        // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0068(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached) == 0x000070, "Wrong size on LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, EventName) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::EventName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, PhysicalSurface) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, InCondition) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::InCondition' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, AttachToComponent) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, AttachPointName) == 0x000018, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, Location) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, Rotation) == 0x00002C, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, LocationType) == 0x000038, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, bStopWhenAttachedToDestroyed) == 0x000039, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, CurveValue) == 0x00003C, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::CurveValue' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, VolumeMultiplier) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, PitchMultiplier) == 0x000044, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, StartTime) == 0x000048, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::StartTime' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, AttenuationSettings) == 0x000050, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, ConcurrencySettings) == 0x000058, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, bAutoDestroy) == 0x000060, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached, ReturnValue) == 0x000068, "Member 'LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayRepulseFx
// 0x0040 (0x0040 - 0x0000)
struct LMiscUtilFuncLibrary_PlayRepulseFx final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerMaterial;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundMaterial;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayRepulseFx) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayRepulseFx");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayRepulseFx) == 0x000040, "Wrong size on LMiscUtilFuncLibrary_PlayRepulseFx");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseFx, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayRepulseFx::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseFx, AttackerMaterial) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayRepulseFx::AttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseFx, GroundMaterial) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlayRepulseFx::GroundMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseFx, SpawnTransform) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayRepulseFx::SpawnTransform' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlayRepulseSound
// 0x0050 (0x0050 - 0x0000)
struct LMiscUtilFuncLibrary_PlayRepulseSound final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerMaterial;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundMaterial;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchModifier;                                     // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlayRepulseSound) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlayRepulseSound");
static_assert(sizeof(LMiscUtilFuncLibrary_PlayRepulseSound) == 0x000050, "Wrong size on LMiscUtilFuncLibrary_PlayRepulseSound");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseSound, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlayRepulseSound::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseSound, AttackerMaterial) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlayRepulseSound::AttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseSound, GroundMaterial) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlayRepulseSound::GroundMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseSound, SpawnTransform) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlayRepulseSound::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseSound, VolumeModifier) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlayRepulseSound::VolumeModifier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlayRepulseSound, PitchModifier) == 0x000044, "Member 'LMiscUtilFuncLibrary_PlayRepulseSound::PitchModifier' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlaySmashFX
// 0x0050 (0x0050 - 0x0000)
struct LMiscUtilFuncLibrary_PlaySmashFX final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InAttackMaterial;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         InGroundMaterial;                                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              InPower;                                           // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlaySmashFX) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlaySmashFX");
static_assert(sizeof(LMiscUtilFuncLibrary_PlaySmashFX) == 0x000050, "Wrong size on LMiscUtilFuncLibrary_PlaySmashFX");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySmashFX, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlaySmashFX::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySmashFX, InAttackMaterial) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlaySmashFX::InAttackMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySmashFX, InGroundMaterial) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlaySmashFX::InGroundMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySmashFX, InPower) == 0x00000A, "Member 'LMiscUtilFuncLibrary_PlaySmashFX::InPower' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySmashFX, SpawnTransform) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlaySmashFX::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySmashFX, ReturnValue) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlaySmashFX::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlaySparkFx
// 0x0040 (0x0040 - 0x0000)
struct LMiscUtilFuncLibrary_PlaySparkFx final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerMaterial;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundMaterial;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PlaySparkFx) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlaySparkFx");
static_assert(sizeof(LMiscUtilFuncLibrary_PlaySparkFx) == 0x000040, "Wrong size on LMiscUtilFuncLibrary_PlaySparkFx");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkFx, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlaySparkFx::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkFx, AttackerMaterial) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlaySparkFx::AttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkFx, GroundMaterial) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlaySparkFx::GroundMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkFx, SpawnTransform) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlaySparkFx::SpawnTransform' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlaySparkSound
// 0x0050 (0x0050 - 0x0000)
struct LMiscUtilFuncLibrary_PlaySparkSound final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerMaterial;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         GroundMaterial;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchModifier;                                     // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlaySparkSound) == 0x000010, "Wrong alignment on LMiscUtilFuncLibrary_PlaySparkSound");
static_assert(sizeof(LMiscUtilFuncLibrary_PlaySparkSound) == 0x000050, "Wrong size on LMiscUtilFuncLibrary_PlaySparkSound");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkSound, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlaySparkSound::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkSound, AttackerMaterial) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlaySparkSound::AttackerMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkSound, GroundMaterial) == 0x000009, "Member 'LMiscUtilFuncLibrary_PlaySparkSound::GroundMaterial' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkSound, SpawnTransform) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlaySparkSound::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkSound, VolumeModifier) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlaySparkSound::VolumeModifier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySparkSound, PitchModifier) == 0x000044, "Member 'LMiscUtilFuncLibrary_PlaySparkSound::PitchModifier' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PlaySwingSFX
// 0x0048 (0x0048 - 0x0000)
struct LMiscUtilFuncLibrary_PlaySwingSFX final
{
public:
	class UAudioComponent*                        OutSwingSfxComponent;                              // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        OutEnchantSfxComponent;                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TargetComponent;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InCodeName;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSkillMotionType                             InMotionType;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              InPower;                                           // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAbnormalEnchantType                         InEnchantType;                                     // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetSocketName;                                  // 0x0024(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPcSound;                                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_PlaySwingSFX) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_PlaySwingSFX");
static_assert(sizeof(LMiscUtilFuncLibrary_PlaySwingSFX) == 0x000048, "Wrong size on LMiscUtilFuncLibrary_PlaySwingSFX");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, OutSwingSfxComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::OutSwingSfxComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, OutEnchantSfxComponent) == 0x000008, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::OutEnchantSfxComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, TargetComponent) == 0x000010, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::TargetComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, InCodeName) == 0x000018, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::InCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, InMotionType) == 0x000020, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::InMotionType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, InPower) == 0x000021, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::InPower' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, InEnchantType) == 0x000022, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::InEnchantType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, TargetSocketName) == 0x000024, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::TargetSocketName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, OffsetLocation) == 0x00002C, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::OffsetLocation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, VolumeMultiplier) == 0x000038, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, PitchMultiplier) == 0x00003C, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_PlaySwingSFX, IsPcSound) == 0x000040, "Member 'LMiscUtilFuncLibrary_PlaySwingSFX::IsPcSound' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PrintActionGroupPathAssets
// 0x0008 (0x0008 - 0x0000)
struct LMiscUtilFuncLibrary_PrintActionGroupPathAssets final
{
public:
	class FName                                   ActionGroupCodeName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PrintActionGroupPathAssets) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_PrintActionGroupPathAssets");
static_assert(sizeof(LMiscUtilFuncLibrary_PrintActionGroupPathAssets) == 0x000008, "Wrong size on LMiscUtilFuncLibrary_PrintActionGroupPathAssets");
static_assert(offsetof(LMiscUtilFuncLibrary_PrintActionGroupPathAssets, ActionGroupCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_PrintActionGroupPathAssets::ActionGroupCodeName' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.PrintNPCLoadAssets
// 0x0008 (0x0008 - 0x0000)
struct LMiscUtilFuncLibrary_PrintNPCLoadAssets final
{
public:
	class FName                                   NPCCodeName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_PrintNPCLoadAssets) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_PrintNPCLoadAssets");
static_assert(sizeof(LMiscUtilFuncLibrary_PrintNPCLoadAssets) == 0x000008, "Wrong size on LMiscUtilFuncLibrary_PrintNPCLoadAssets");
static_assert(offsetof(LMiscUtilFuncLibrary_PrintNPCLoadAssets, NPCCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_PrintNPCLoadAssets::NPCCodeName' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.ProjectWorldToScreenNormalized
// 0x0014 (0x0014 - 0x0000)
struct LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized final
{
public:
	struct FVector                                WorldPosition;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized");
static_assert(sizeof(LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized) == 0x000014, "Wrong size on LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized");
static_assert(offsetof(LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized, WorldPosition) == 0x000000, "Member 'LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized::WorldPosition' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized, ReturnValue) == 0x00000C, "Member 'LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.Proto_EquipSubWeapon
// 0x0018 (0x0018 - 0x0000)
struct LMiscUtilFuncLibrary_Proto_EquipSubWeapon final
{
public:
	class FName                                   HandleCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BladeCodeName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_Proto_EquipSubWeapon) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_Proto_EquipSubWeapon");
static_assert(sizeof(LMiscUtilFuncLibrary_Proto_EquipSubWeapon) == 0x000018, "Wrong size on LMiscUtilFuncLibrary_Proto_EquipSubWeapon");
static_assert(offsetof(LMiscUtilFuncLibrary_Proto_EquipSubWeapon, HandleCodeName) == 0x000000, "Member 'LMiscUtilFuncLibrary_Proto_EquipSubWeapon::HandleCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_Proto_EquipSubWeapon, BladeCodeName) == 0x000008, "Member 'LMiscUtilFuncLibrary_Proto_EquipSubWeapon::BladeCodeName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_Proto_EquipSubWeapon, ReturnValue) == 0x000010, "Member 'LMiscUtilFuncLibrary_Proto_EquipSubWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.Proto_GetSubWeapon
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_Proto_GetSubWeapon final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_Proto_GetSubWeapon) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_Proto_GetSubWeapon");
static_assert(sizeof(LMiscUtilFuncLibrary_Proto_GetSubWeapon) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_Proto_GetSubWeapon");
static_assert(offsetof(LMiscUtilFuncLibrary_Proto_GetSubWeapon, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_Proto_GetSubWeapon::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_Proto_GetSubWeapon, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_Proto_GetSubWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.Proto_GetSubWeaponIndex
// 0x0004 (0x0004 - 0x0000)
struct LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex");
static_assert(sizeof(LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex) == 0x000004, "Wrong size on LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex");
static_assert(offsetof(LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex, ReturnValue) == 0x000000, "Member 'LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.RemovePostProcessMaterial
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_RemovePostProcessMaterial final
{
public:
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MaterialInstnaceDynamic;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_RemovePostProcessMaterial) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_RemovePostProcessMaterial");
static_assert(sizeof(LMiscUtilFuncLibrary_RemovePostProcessMaterial) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_RemovePostProcessMaterial");
static_assert(offsetof(LMiscUtilFuncLibrary_RemovePostProcessMaterial, PostProcessComponent) == 0x000000, "Member 'LMiscUtilFuncLibrary_RemovePostProcessMaterial::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_RemovePostProcessMaterial, MaterialInstnaceDynamic) == 0x000008, "Member 'LMiscUtilFuncLibrary_RemovePostProcessMaterial::MaterialInstnaceDynamic' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_AudioListenerPositionComponent
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent");
static_assert(sizeof(LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent, Offset) == 0x000000, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent::Offset' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent, LerpDuration) == 0x00000C, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent::LerpDuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_Camera
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera final
{
public:
	struct FVector                                Offset;                                            // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera");
static_assert(sizeof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera, Offset) == 0x000000, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera::Offset' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera, LerpDuration) == 0x00000C, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera::LerpDuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_Character
// 0x0004 (0x0004 - 0x0000)
struct LMiscUtilFuncLibrary_SetAudioListenerPosition_Character final
{
public:
	float                                         LerpDuration;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Character) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_SetAudioListenerPosition_Character");
static_assert(sizeof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Character) == 0x000004, "Wrong size on LMiscUtilFuncLibrary_SetAudioListenerPosition_Character");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_Character, LerpDuration) == 0x000000, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_Character::LerpDuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_CustomLocation
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpDuration;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation) == 0x000004, "Wrong alignment on LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation, Location) == 0x000000, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation, LerpDuration) == 0x00000C, "Member 'LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation::LerpDuration' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SetupMainCamera
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_SetupMainCamera final
{
public:
	class ACharacter*                             TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_SetupMainCamera) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_SetupMainCamera");
static_assert(sizeof(LMiscUtilFuncLibrary_SetupMainCamera) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_SetupMainCamera");
static_assert(offsetof(LMiscUtilFuncLibrary_SetupMainCamera, TargetActor) == 0x000000, "Member 'LMiscUtilFuncLibrary_SetupMainCamera::TargetActor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SetupMainCamera, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_SetupMainCamera::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SpawnForceFeedbackAtLocation
// 0x0050 (0x0050 - 0x0000)
struct LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityMultiplier;                               // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackAttenuation*              AttenuationSettings;                               // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackComponent*                ReturnValue;                                       // 0x0048(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation) == 0x000050, "Wrong size on LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, ForceFeedbackEffect) == 0x000008, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, Location) == 0x000010, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, Rotation) == 0x00001C, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, bLooping) == 0x000028, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::bLooping' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, IntensityMultiplier) == 0x00002C, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::IntensityMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, StartTime) == 0x000030, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, AttenuationSettings) == 0x000038, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, bAutoDestroy) == 0x000040, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation, ReturnValue) == 0x000048, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SpawnForceFeedbackAttached
// 0x0058 (0x0058 - 0x0000)
struct LMiscUtilFuncLibrary_SpawnForceFeedbackAttached final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityMultiplier;                               // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackAttenuation*              AttenuationSettings;                               // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackComponent*                ReturnValue;                                       // 0x0050(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_SpawnForceFeedbackAttached");
static_assert(sizeof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached) == 0x000058, "Wrong size on LMiscUtilFuncLibrary_SpawnForceFeedbackAttached");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, ForceFeedbackEffect) == 0x000000, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, AttachToComponent) == 0x000008, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, AttachPointName) == 0x000010, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, Location) == 0x000018, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, Rotation) == 0x000024, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, LocationType) == 0x000030, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::LocationType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, bStopWhenAttachedToDestroyed) == 0x000031, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, bLooping) == 0x000032, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::bLooping' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, IntensityMultiplier) == 0x000034, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::IntensityMultiplier' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, StartTime) == 0x000038, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::StartTime' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, AttenuationSettings) == 0x000040, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, bAutoDestroy) == 0x000048, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnForceFeedbackAttached, ReturnValue) == 0x000050, "Member 'LMiscUtilFuncLibrary_SpawnForceFeedbackAttached::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SpawnMaterialVaryingDecalAtLocation
// 0x0040 (0x0040 - 0x0000)
struct LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULMaterialVarying*                      InMaterialVarying;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     InPlayType;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DecalSize;                                         // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ULDecalComponent*                       ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation) == 0x000040, "Wrong size on LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, InMaterialVarying) == 0x000008, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::InMaterialVarying' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, InPlayType) == 0x000010, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::InPlayType' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, DecalSize) == 0x000014, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::DecalSize' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, Location) == 0x000020, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, Rotation) == 0x00002C, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation, ReturnValue) == 0x000038, "Member 'LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SpawnSystemAttachedWithParameters
// 0x00E0 (0x00E0 - 0x0000)
struct LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters final
{
public:
	class AActor*                                 ActorToAttach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters                NiagaraWithParameters;                             // 0x0008(0x00D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnValue;                                       // 0x00D8(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters");
static_assert(sizeof(LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters) == 0x0000E0, "Wrong size on LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters, ActorToAttach) == 0x000000, "Member 'LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters::ActorToAttach' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters, NiagaraWithParameters) == 0x000008, "Member 'LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters::NiagaraWithParameters' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters, ReturnValue) == 0x0000D8, "Member 'LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.SpawnWindSourceAtLocation
// 0x0040 (0x0040 - 0x0000)
struct LMiscUtilFuncLibrary_SpawnWindSourceAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindSpeed;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPointWind;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VolumeSize;                                        // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWindSourceComponent*                  ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_SpawnWindSourceAtLocation");
static_assert(sizeof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation) == 0x000040, "Wrong size on LMiscUtilFuncLibrary_SpawnWindSourceAtLocation");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, WorldContextObject) == 0x000000, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, WindSpeed) == 0x000008, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::WindSpeed' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, bPointWind) == 0x00000C, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::bPointWind' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, VolumeSize) == 0x000010, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::VolumeSize' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, Location) == 0x00001C, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::Location' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, Rotation) == 0x000028, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, LifeSpan) == 0x000034, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::LifeSpan' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_SpawnWindSourceAtLocation, ReturnValue) == 0x000038, "Member 'LMiscUtilFuncLibrary_SpawnWindSourceAtLocation::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.TraceForLandingOnFloor
// 0x0028 (0x0028 - 0x0000)
struct LMiscUtilFuncLibrary_TraceForLandingOnFloor final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceLocation;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHalfHeight;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ResultLocation;                                    // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_TraceForLandingOnFloor) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_TraceForLandingOnFloor");
static_assert(sizeof(LMiscUtilFuncLibrary_TraceForLandingOnFloor) == 0x000028, "Wrong size on LMiscUtilFuncLibrary_TraceForLandingOnFloor");
static_assert(offsetof(LMiscUtilFuncLibrary_TraceForLandingOnFloor, WorldContext) == 0x000000, "Member 'LMiscUtilFuncLibrary_TraceForLandingOnFloor::WorldContext' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_TraceForLandingOnFloor, TraceLocation) == 0x000008, "Member 'LMiscUtilFuncLibrary_TraceForLandingOnFloor::TraceLocation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_TraceForLandingOnFloor, TraceHalfHeight) == 0x000014, "Member 'LMiscUtilFuncLibrary_TraceForLandingOnFloor::TraceHalfHeight' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_TraceForLandingOnFloor, ResultLocation) == 0x000018, "Member 'LMiscUtilFuncLibrary_TraceForLandingOnFloor::ResultLocation' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_TraceForLandingOnFloor, ReturnValue) == 0x000024, "Member 'LMiscUtilFuncLibrary_TraceForLandingOnFloor::ReturnValue' has a wrong offset!");

// Function ProjectP.LMiscUtilFuncLibrary.WasRenderedActor
// 0x0010 (0x0010 - 0x0000)
struct LMiscUtilFuncLibrary_WasRenderedActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMiscUtilFuncLibrary_WasRenderedActor) == 0x000008, "Wrong alignment on LMiscUtilFuncLibrary_WasRenderedActor");
static_assert(sizeof(LMiscUtilFuncLibrary_WasRenderedActor) == 0x000010, "Wrong size on LMiscUtilFuncLibrary_WasRenderedActor");
static_assert(offsetof(LMiscUtilFuncLibrary_WasRenderedActor, Actor) == 0x000000, "Member 'LMiscUtilFuncLibrary_WasRenderedActor::Actor' has a wrong offset!");
static_assert(offsetof(LMiscUtilFuncLibrary_WasRenderedActor, ReturnValue) == 0x000008, "Member 'LMiscUtilFuncLibrary_WasRenderedActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LMovieSystem.OnMediaClosed
// 0x0008 (0x0008 - 0x0000)
struct LMovieSystem_OnMediaClosed final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystem_OnMediaClosed) == 0x000004, "Wrong alignment on LMovieSystem_OnMediaClosed");
static_assert(sizeof(LMovieSystem_OnMediaClosed) == 0x000008, "Wrong size on LMovieSystem_OnMediaClosed");
static_assert(offsetof(LMovieSystem_OnMediaClosed, MovieCodeName) == 0x000000, "Member 'LMovieSystem_OnMediaClosed::MovieCodeName' has a wrong offset!");

// Function ProjectP.LMovieSystem.OnMediaOpened
// 0x0008 (0x0008 - 0x0000)
struct LMovieSystem_OnMediaOpened final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystem_OnMediaOpened) == 0x000004, "Wrong alignment on LMovieSystem_OnMediaOpened");
static_assert(sizeof(LMovieSystem_OnMediaOpened) == 0x000008, "Wrong size on LMovieSystem_OnMediaOpened");
static_assert(offsetof(LMovieSystem_OnMediaOpened, MovieCodeName) == 0x000000, "Member 'LMovieSystem_OnMediaOpened::MovieCodeName' has a wrong offset!");

// Function ProjectP.LMovieSystem.OnMediaPauseOnReachedEnd
// 0x0008 (0x0008 - 0x0000)
struct LMovieSystem_OnMediaPauseOnReachedEnd final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystem_OnMediaPauseOnReachedEnd) == 0x000004, "Wrong alignment on LMovieSystem_OnMediaPauseOnReachedEnd");
static_assert(sizeof(LMovieSystem_OnMediaPauseOnReachedEnd) == 0x000008, "Wrong size on LMovieSystem_OnMediaPauseOnReachedEnd");
static_assert(offsetof(LMovieSystem_OnMediaPauseOnReachedEnd, MovieCodeName) == 0x000000, "Member 'LMovieSystem_OnMediaPauseOnReachedEnd::MovieCodeName' has a wrong offset!");

// Function ProjectP.LMovieSystem.OnMediaReachedEnd
// 0x0008 (0x0008 - 0x0000)
struct LMovieSystem_OnMediaReachedEnd final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystem_OnMediaReachedEnd) == 0x000004, "Wrong alignment on LMovieSystem_OnMediaReachedEnd");
static_assert(sizeof(LMovieSystem_OnMediaReachedEnd) == 0x000008, "Wrong size on LMovieSystem_OnMediaReachedEnd");
static_assert(offsetof(LMovieSystem_OnMediaReachedEnd, MovieCodeName) == 0x000000, "Member 'LMovieSystem_OnMediaReachedEnd::MovieCodeName' has a wrong offset!");

// Function ProjectP.LMovieSystem.PlayBinkMovie
// 0x000C (0x000C - 0x0000)
struct LMovieSystem_PlayBinkMovie final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LMovieSystem_PlayBinkMovie) == 0x000004, "Wrong alignment on LMovieSystem_PlayBinkMovie");
static_assert(sizeof(LMovieSystem_PlayBinkMovie) == 0x00000C, "Wrong size on LMovieSystem_PlayBinkMovie");
static_assert(offsetof(LMovieSystem_PlayBinkMovie, MovieCodeName) == 0x000000, "Member 'LMovieSystem_PlayBinkMovie::MovieCodeName' has a wrong offset!");
static_assert(offsetof(LMovieSystem_PlayBinkMovie, ReturnValue) == 0x000008, "Member 'LMovieSystem_PlayBinkMovie::ReturnValue' has a wrong offset!");

// Function ProjectP.LMovieSystem.StopBinkMovie
// 0x0008 (0x0008 - 0x0000)
struct LMovieSystem_StopBinkMovie final
{
public:
	class FName                                   MovieCodeName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LMovieSystem_StopBinkMovie) == 0x000004, "Wrong alignment on LMovieSystem_StopBinkMovie");
static_assert(sizeof(LMovieSystem_StopBinkMovie) == 0x000008, "Wrong size on LMovieSystem_StopBinkMovie");
static_assert(offsetof(LMovieSystem_StopBinkMovie, MovieCodeName) == 0x000000, "Member 'LMovieSystem_StopBinkMovie::MovieCodeName' has a wrong offset!");

// Function ProjectP.LNPCController.Get
// 0x0010 (0x0010 - 0x0000)
struct LNPCController_Get final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCController*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_Get) == 0x000008, "Wrong alignment on LNPCController_Get");
static_assert(sizeof(LNPCController_Get) == 0x000010, "Wrong size on LNPCController_Get");
static_assert(offsetof(LNPCController_Get, Actor) == 0x000000, "Member 'LNPCController_Get::Actor' has a wrong offset!");
static_assert(offsetof(LNPCController_Get, ReturnValue) == 0x000008, "Member 'LNPCController_Get::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCController.GetCheckSkillUseCount
// 0x0004 (0x0004 - 0x0000)
struct LNPCController_GetCheckSkillUseCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_GetCheckSkillUseCount) == 0x000004, "Wrong alignment on LNPCController_GetCheckSkillUseCount");
static_assert(sizeof(LNPCController_GetCheckSkillUseCount) == 0x000004, "Wrong size on LNPCController_GetCheckSkillUseCount");
static_assert(offsetof(LNPCController_GetCheckSkillUseCount, ReturnValue) == 0x000000, "Member 'LNPCController_GetCheckSkillUseCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCController.IsCombatState
// 0x0001 (0x0001 - 0x0000)
struct LNPCController_IsCombatState final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_IsCombatState) == 0x000001, "Wrong alignment on LNPCController_IsCombatState");
static_assert(sizeof(LNPCController_IsCombatState) == 0x000001, "Wrong size on LNPCController_IsCombatState");
static_assert(offsetof(LNPCController_IsCombatState, ReturnValue) == 0x000000, "Member 'LNPCController_IsCombatState::ReturnValue' has a wrong offset!");

// Function ProjectP.LNPCController.RunInitBehaviorTree
// 0x0008 (0x0008 - 0x0000)
struct LNPCController_RunInitBehaviorTree final
{
public:
	class UBehaviorTree*                          CustomBehaviroTree;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_RunInitBehaviorTree) == 0x000008, "Wrong alignment on LNPCController_RunInitBehaviorTree");
static_assert(sizeof(LNPCController_RunInitBehaviorTree) == 0x000008, "Wrong size on LNPCController_RunInitBehaviorTree");
static_assert(offsetof(LNPCController_RunInitBehaviorTree, CustomBehaviroTree) == 0x000000, "Member 'LNPCController_RunInitBehaviorTree::CustomBehaviroTree' has a wrong offset!");

// Function ProjectP.LNPCController.SelectCommonActionBP
// 0x0018 (0x0018 - 0x0000)
struct LNPCController_SelectCommonActionBP final
{
public:
	class FName                                   CommonActionMontageName;                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutActionClassName;                                // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActPayloadBase*                       OutPayload;                                        // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_SelectCommonActionBP) == 0x000008, "Wrong alignment on LNPCController_SelectCommonActionBP");
static_assert(sizeof(LNPCController_SelectCommonActionBP) == 0x000018, "Wrong size on LNPCController_SelectCommonActionBP");
static_assert(offsetof(LNPCController_SelectCommonActionBP, CommonActionMontageName) == 0x000000, "Member 'LNPCController_SelectCommonActionBP::CommonActionMontageName' has a wrong offset!");
static_assert(offsetof(LNPCController_SelectCommonActionBP, OutActionClassName) == 0x000008, "Member 'LNPCController_SelectCommonActionBP::OutActionClassName' has a wrong offset!");
static_assert(offsetof(LNPCController_SelectCommonActionBP, OutPayload) == 0x000010, "Member 'LNPCController_SelectCommonActionBP::OutPayload' has a wrong offset!");

// Function ProjectP.LNPCController.SetActivate
// 0x0001 (0x0001 - 0x0000)
struct LNPCController_SetActivate final
{
public:
	bool                                          bInActivate;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_SetActivate) == 0x000001, "Wrong alignment on LNPCController_SetActivate");
static_assert(sizeof(LNPCController_SetActivate) == 0x000001, "Wrong size on LNPCController_SetActivate");
static_assert(offsetof(LNPCController_SetActivate, bInActivate) == 0x000000, "Member 'LNPCController_SetActivate::bInActivate' has a wrong offset!");

// Function ProjectP.LNPCController.IsActivate
// 0x0001 (0x0001 - 0x0000)
struct LNPCController_IsActivate final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LNPCController_IsActivate) == 0x000001, "Wrong alignment on LNPCController_IsActivate");
static_assert(sizeof(LNPCController_IsActivate) == 0x000001, "Wrong size on LNPCController_IsActivate");
static_assert(offsetof(LNPCController_IsActivate, ReturnValue) == 0x000000, "Member 'LNPCController_IsActivate::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.AddRemoveFlag
// 0x0008 (0x0008 - 0x0000)
struct LObjectManagementSystem_AddRemoveFlag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_AddRemoveFlag) == 0x000008, "Wrong alignment on LObjectManagementSystem_AddRemoveFlag");
static_assert(sizeof(LObjectManagementSystem_AddRemoveFlag) == 0x000008, "Wrong size on LObjectManagementSystem_AddRemoveFlag");
static_assert(offsetof(LObjectManagementSystem_AddRemoveFlag, InActor) == 0x000000, "Member 'LObjectManagementSystem_AddRemoveFlag::InActor' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.FindFiles
// 0x0020 (0x0020 - 0x0000)
struct LObjectManagementSystem_FindFiles final
{
public:
	TArray<struct FSoftObjectPath>                OutObjectPaths;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Directory;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_FindFiles) == 0x000008, "Wrong alignment on LObjectManagementSystem_FindFiles");
static_assert(sizeof(LObjectManagementSystem_FindFiles) == 0x000020, "Wrong size on LObjectManagementSystem_FindFiles");
static_assert(offsetof(LObjectManagementSystem_FindFiles, OutObjectPaths) == 0x000000, "Member 'LObjectManagementSystem_FindFiles::OutObjectPaths' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_FindFiles, Directory) == 0x000010, "Member 'LObjectManagementSystem_FindFiles::Directory' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.GetFluidController
// 0x0010 (0x0010 - 0x0000)
struct LObjectManagementSystem_GetFluidController final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_GetFluidController) == 0x000008, "Wrong alignment on LObjectManagementSystem_GetFluidController");
static_assert(sizeof(LObjectManagementSystem_GetFluidController) == 0x000010, "Wrong size on LObjectManagementSystem_GetFluidController");
static_assert(offsetof(LObjectManagementSystem_GetFluidController, Branches) == 0x000000, "Member 'LObjectManagementSystem_GetFluidController::Branches' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_GetFluidController, ReturnValue) == 0x000008, "Member 'LObjectManagementSystem_GetFluidController::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.GetGoldenTree
// 0x0008 (0x0008 - 0x0000)
struct LObjectManagementSystem_GetGoldenTree final
{
public:
	class ULGoldenTree*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_GetGoldenTree) == 0x000008, "Wrong alignment on LObjectManagementSystem_GetGoldenTree");
static_assert(sizeof(LObjectManagementSystem_GetGoldenTree) == 0x000008, "Wrong size on LObjectManagementSystem_GetGoldenTree");
static_assert(offsetof(LObjectManagementSystem_GetGoldenTree, ReturnValue) == 0x000000, "Member 'LObjectManagementSystem_GetGoldenTree::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.GetPlayerCharacter
// 0x0008 (0x0008 - 0x0000)
struct LObjectManagementSystem_GetPlayerCharacter final
{
public:
	class ALPCCharacter*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_GetPlayerCharacter) == 0x000008, "Wrong alignment on LObjectManagementSystem_GetPlayerCharacter");
static_assert(sizeof(LObjectManagementSystem_GetPlayerCharacter) == 0x000008, "Wrong size on LObjectManagementSystem_GetPlayerCharacter");
static_assert(offsetof(LObjectManagementSystem_GetPlayerCharacter, ReturnValue) == 0x000000, "Member 'LObjectManagementSystem_GetPlayerCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.OnSetActiveEnvironment
// 0x0001 (0x0001 - 0x0000)
struct LObjectManagementSystem_OnSetActiveEnvironment final
{
public:
	bool                                          bWorldActive;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_OnSetActiveEnvironment) == 0x000001, "Wrong alignment on LObjectManagementSystem_OnSetActiveEnvironment");
static_assert(sizeof(LObjectManagementSystem_OnSetActiveEnvironment) == 0x000001, "Wrong size on LObjectManagementSystem_OnSetActiveEnvironment");
static_assert(offsetof(LObjectManagementSystem_OnSetActiveEnvironment, bWorldActive) == 0x000000, "Member 'LObjectManagementSystem_OnSetActiveEnvironment::bWorldActive' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.SetFluidController
// 0x0008 (0x0008 - 0x0000)
struct LObjectManagementSystem_SetFluidController final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_SetFluidController) == 0x000008, "Wrong alignment on LObjectManagementSystem_SetFluidController");
static_assert(sizeof(LObjectManagementSystem_SetFluidController) == 0x000008, "Wrong size on LObjectManagementSystem_SetFluidController");
static_assert(offsetof(LObjectManagementSystem_SetFluidController, TargetActor) == 0x000000, "Member 'LObjectManagementSystem_SetFluidController::TargetActor' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.SpawnDestructionObject
// 0x0050 (0x0050 - 0x0000)
struct LObjectManagementSystem_SpawnDestructionObject final
{
public:
	class FName                                   DestructionObjectCodeName;                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTraceAndLandingOnFloor;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALDestructionObject*                    ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_SpawnDestructionObject) == 0x000010, "Wrong alignment on LObjectManagementSystem_SpawnDestructionObject");
static_assert(sizeof(LObjectManagementSystem_SpawnDestructionObject) == 0x000050, "Wrong size on LObjectManagementSystem_SpawnDestructionObject");
static_assert(offsetof(LObjectManagementSystem_SpawnDestructionObject, DestructionObjectCodeName) == 0x000000, "Member 'LObjectManagementSystem_SpawnDestructionObject::DestructionObjectCodeName' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnDestructionObject, SpawnTransform) == 0x000010, "Member 'LObjectManagementSystem_SpawnDestructionObject::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnDestructionObject, bTraceAndLandingOnFloor) == 0x000040, "Member 'LObjectManagementSystem_SpawnDestructionObject::bTraceAndLandingOnFloor' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnDestructionObject, ReturnValue) == 0x000048, "Member 'LObjectManagementSystem_SpawnDestructionObject::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.SpawnNPC
// 0x0060 (0x0060 - 0x0000)
struct LObjectManagementSystem_SpawnNPC final
{
public:
	class FName                                   NPCCodeName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTraceAndLandingOnFloor;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnIdleActionGroupCodeName;                      // 0x0044(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALNPCCharacter*                         ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LObjectManagementSystem_SpawnNPC) == 0x000010, "Wrong alignment on LObjectManagementSystem_SpawnNPC");
static_assert(sizeof(LObjectManagementSystem_SpawnNPC) == 0x000060, "Wrong size on LObjectManagementSystem_SpawnNPC");
static_assert(offsetof(LObjectManagementSystem_SpawnNPC, NPCCodeName) == 0x000000, "Member 'LObjectManagementSystem_SpawnNPC::NPCCodeName' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnNPC, SpawnTransform) == 0x000010, "Member 'LObjectManagementSystem_SpawnNPC::SpawnTransform' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnNPC, bTraceAndLandingOnFloor) == 0x000040, "Member 'LObjectManagementSystem_SpawnNPC::bTraceAndLandingOnFloor' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnNPC, SpawnIdleActionGroupCodeName) == 0x000044, "Member 'LObjectManagementSystem_SpawnNPC::SpawnIdleActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_SpawnNPC, ReturnValue) == 0x000050, "Member 'LObjectManagementSystem_SpawnNPC::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectManagementSystem.FindNPCCharactersAround
// 0x0020 (0x0020 - 0x0000)
struct LObjectManagementSystem_FindNPCCharactersAround final
{
public:
	class FName                                   NPCCodeName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundDistance;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ALNPCCharacter*>                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectManagementSystem_FindNPCCharactersAround) == 0x000008, "Wrong alignment on LObjectManagementSystem_FindNPCCharactersAround");
static_assert(sizeof(LObjectManagementSystem_FindNPCCharactersAround) == 0x000020, "Wrong size on LObjectManagementSystem_FindNPCCharactersAround");
static_assert(offsetof(LObjectManagementSystem_FindNPCCharactersAround, NPCCodeName) == 0x000000, "Member 'LObjectManagementSystem_FindNPCCharactersAround::NPCCodeName' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_FindNPCCharactersAround, AroundDistance) == 0x000008, "Member 'LObjectManagementSystem_FindNPCCharactersAround::AroundDistance' has a wrong offset!");
static_assert(offsetof(LObjectManagementSystem_FindNPCCharactersAround, ReturnValue) == 0x000010, "Member 'LObjectManagementSystem_FindNPCCharactersAround::ReturnValue' has a wrong offset!");

// Function ProjectP.LPoolingObjectManager.CreateObjects
// 0x0038 (0x0038 - 0x0000)
struct LPoolingObjectManager_CreateObjects final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ObjectClassPtr;                                    // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateOnlySurplusAmount;                          // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPoolingObjectManager_CreateObjects) == 0x000008, "Wrong alignment on LPoolingObjectManager_CreateObjects");
static_assert(sizeof(LPoolingObjectManager_CreateObjects) == 0x000038, "Wrong size on LPoolingObjectManager_CreateObjects");
static_assert(offsetof(LPoolingObjectManager_CreateObjects, WorldContext) == 0x000000, "Member 'LPoolingObjectManager_CreateObjects::WorldContext' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_CreateObjects, ObjectClassPtr) == 0x000008, "Member 'LPoolingObjectManager_CreateObjects::ObjectClassPtr' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_CreateObjects, Count) == 0x000030, "Member 'LPoolingObjectManager_CreateObjects::Count' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_CreateObjects, bCreateOnlySurplusAmount) == 0x000034, "Member 'LPoolingObjectManager_CreateObjects::bCreateOnlySurplusAmount' has a wrong offset!");

// Function ProjectP.LPoolingObjectManager.CreateWidgets
// 0x0038 (0x0038 - 0x0000)
struct LPoolingObjectManager_CreateWidgets final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetClassPtr;                                    // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateOnlySurplusAmount;                          // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPoolingObjectManager_CreateWidgets) == 0x000008, "Wrong alignment on LPoolingObjectManager_CreateWidgets");
static_assert(sizeof(LPoolingObjectManager_CreateWidgets) == 0x000038, "Wrong size on LPoolingObjectManager_CreateWidgets");
static_assert(offsetof(LPoolingObjectManager_CreateWidgets, WorldContext) == 0x000000, "Member 'LPoolingObjectManager_CreateWidgets::WorldContext' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_CreateWidgets, WidgetClassPtr) == 0x000008, "Member 'LPoolingObjectManager_CreateWidgets::WidgetClassPtr' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_CreateWidgets, Count) == 0x000030, "Member 'LPoolingObjectManager_CreateWidgets::Count' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_CreateWidgets, bCreateOnlySurplusAmount) == 0x000034, "Member 'LPoolingObjectManager_CreateWidgets::bCreateOnlySurplusAmount' has a wrong offset!");

// Function ProjectP.LPoolingObjectManager.GetRecyclableObject
// 0x0038 (0x0038 - 0x0000)
struct LPoolingObjectManager_GetRecyclableObject final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ObjectClassPtr;                                    // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPoolingObjectManager_GetRecyclableObject) == 0x000008, "Wrong alignment on LPoolingObjectManager_GetRecyclableObject");
static_assert(sizeof(LPoolingObjectManager_GetRecyclableObject) == 0x000038, "Wrong size on LPoolingObjectManager_GetRecyclableObject");
static_assert(offsetof(LPoolingObjectManager_GetRecyclableObject, WorldContext) == 0x000000, "Member 'LPoolingObjectManager_GetRecyclableObject::WorldContext' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_GetRecyclableObject, ObjectClassPtr) == 0x000008, "Member 'LPoolingObjectManager_GetRecyclableObject::ObjectClassPtr' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_GetRecyclableObject, ReturnValue) == 0x000030, "Member 'LPoolingObjectManager_GetRecyclableObject::ReturnValue' has a wrong offset!");

// Function ProjectP.LPoolingObjectManager.ReturnToRecyclingBin
// 0x0018 (0x0018 - 0x0000)
struct LPoolingObjectManager_ReturnToRecyclingBin final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                TargetObject;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPoolingObjectManager_ReturnToRecyclingBin) == 0x000008, "Wrong alignment on LPoolingObjectManager_ReturnToRecyclingBin");
static_assert(sizeof(LPoolingObjectManager_ReturnToRecyclingBin) == 0x000018, "Wrong size on LPoolingObjectManager_ReturnToRecyclingBin");
static_assert(offsetof(LPoolingObjectManager_ReturnToRecyclingBin, WorldContext) == 0x000000, "Member 'LPoolingObjectManager_ReturnToRecyclingBin::WorldContext' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_ReturnToRecyclingBin, TargetObject) == 0x000008, "Member 'LPoolingObjectManager_ReturnToRecyclingBin::TargetObject' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_ReturnToRecyclingBin, ReturnValue) == 0x000010, "Member 'LPoolingObjectManager_ReturnToRecyclingBin::ReturnValue' has a wrong offset!");

// Function ProjectP.LPoolingObjectManager.ShrinkRecyclingBin
// 0x0038 (0x0038 - 0x0000)
struct LPoolingObjectManager_ShrinkRecyclingBin final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ObjectClassPtr;                                    // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPoolingObjectManager_ShrinkRecyclingBin) == 0x000008, "Wrong alignment on LPoolingObjectManager_ShrinkRecyclingBin");
static_assert(sizeof(LPoolingObjectManager_ShrinkRecyclingBin) == 0x000038, "Wrong size on LPoolingObjectManager_ShrinkRecyclingBin");
static_assert(offsetof(LPoolingObjectManager_ShrinkRecyclingBin, WorldContext) == 0x000000, "Member 'LPoolingObjectManager_ShrinkRecyclingBin::WorldContext' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_ShrinkRecyclingBin, ObjectClassPtr) == 0x000008, "Member 'LPoolingObjectManager_ShrinkRecyclingBin::ObjectClassPtr' has a wrong offset!");
static_assert(offsetof(LPoolingObjectManager_ShrinkRecyclingBin, Count) == 0x000030, "Member 'LPoolingObjectManager_ShrinkRecyclingBin::Count' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.CreateNewRecyclables
// 0x0038 (0x0038 - 0x0000)
struct LObjectPoolSystem_CreateNewRecyclables final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RecyclablesClass;                                  // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectPoolSystem_CreateNewRecyclables) == 0x000008, "Wrong alignment on LObjectPoolSystem_CreateNewRecyclables");
static_assert(sizeof(LObjectPoolSystem_CreateNewRecyclables) == 0x000038, "Wrong size on LObjectPoolSystem_CreateNewRecyclables");
static_assert(offsetof(LObjectPoolSystem_CreateNewRecyclables, WorldContext) == 0x000000, "Member 'LObjectPoolSystem_CreateNewRecyclables::WorldContext' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_CreateNewRecyclables, RecyclablesClass) == 0x000008, "Member 'LObjectPoolSystem_CreateNewRecyclables::RecyclablesClass' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_CreateNewRecyclables, Count) == 0x000030, "Member 'LObjectPoolSystem_CreateNewRecyclables::Count' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_CreateNewRecyclables, ReturnValue) == 0x000034, "Member 'LObjectPoolSystem_CreateNewRecyclables::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.GetRecyclables
// 0x0038 (0x0038 - 0x0000)
struct LObjectPoolSystem_GetRecyclables final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RecyclablesClass;                                  // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectPoolSystem_GetRecyclables) == 0x000008, "Wrong alignment on LObjectPoolSystem_GetRecyclables");
static_assert(sizeof(LObjectPoolSystem_GetRecyclables) == 0x000038, "Wrong size on LObjectPoolSystem_GetRecyclables");
static_assert(offsetof(LObjectPoolSystem_GetRecyclables, WorldContext) == 0x000000, "Member 'LObjectPoolSystem_GetRecyclables::WorldContext' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_GetRecyclables, RecyclablesClass) == 0x000008, "Member 'LObjectPoolSystem_GetRecyclables::RecyclablesClass' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_GetRecyclables, ReturnValue) == 0x000030, "Member 'LObjectPoolSystem_GetRecyclables::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.GetSystemData
// 0x0008 (0x0008 - 0x0000)
struct LObjectPoolSystem_GetSystemData final
{
public:
	const class ALObjectPoolSystemData*           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectPoolSystem_GetSystemData) == 0x000008, "Wrong alignment on LObjectPoolSystem_GetSystemData");
static_assert(sizeof(LObjectPoolSystem_GetSystemData) == 0x000008, "Wrong size on LObjectPoolSystem_GetSystemData");
static_assert(offsetof(LObjectPoolSystem_GetSystemData, ReturnValue) == 0x000000, "Member 'LObjectPoolSystem_GetSystemData::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.ResizeRecyclingBin
// 0x0038 (0x0038 - 0x0000)
struct LObjectPoolSystem_ResizeRecyclingBin final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RecyclablesClass;                                  // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredSize;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectPoolSystem_ResizeRecyclingBin) == 0x000008, "Wrong alignment on LObjectPoolSystem_ResizeRecyclingBin");
static_assert(sizeof(LObjectPoolSystem_ResizeRecyclingBin) == 0x000038, "Wrong size on LObjectPoolSystem_ResizeRecyclingBin");
static_assert(offsetof(LObjectPoolSystem_ResizeRecyclingBin, WorldContext) == 0x000000, "Member 'LObjectPoolSystem_ResizeRecyclingBin::WorldContext' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ResizeRecyclingBin, RecyclablesClass) == 0x000008, "Member 'LObjectPoolSystem_ResizeRecyclingBin::RecyclablesClass' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ResizeRecyclingBin, DesiredSize) == 0x000030, "Member 'LObjectPoolSystem_ResizeRecyclingBin::DesiredSize' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ResizeRecyclingBin, ReturnValue) == 0x000034, "Member 'LObjectPoolSystem_ResizeRecyclingBin::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.ReturnToRecyclingBin
// 0x0010 (0x0010 - 0x0000)
struct LObjectPoolSystem_ReturnToRecyclingBin final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LObjectPoolSystem_ReturnToRecyclingBin) == 0x000008, "Wrong alignment on LObjectPoolSystem_ReturnToRecyclingBin");
static_assert(sizeof(LObjectPoolSystem_ReturnToRecyclingBin) == 0x000010, "Wrong size on LObjectPoolSystem_ReturnToRecyclingBin");
static_assert(offsetof(LObjectPoolSystem_ReturnToRecyclingBin, TargetActor) == 0x000000, "Member 'LObjectPoolSystem_ReturnToRecyclingBin::TargetActor' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ReturnToRecyclingBin, ReturnValue) == 0x000008, "Member 'LObjectPoolSystem_ReturnToRecyclingBin::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.ShrinkRecyclingBin
// 0x0038 (0x0038 - 0x0000)
struct LObjectPoolSystem_ShrinkRecyclingBin final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RecyclablesClass;                                  // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredSize;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LObjectPoolSystem_ShrinkRecyclingBin) == 0x000008, "Wrong alignment on LObjectPoolSystem_ShrinkRecyclingBin");
static_assert(sizeof(LObjectPoolSystem_ShrinkRecyclingBin) == 0x000038, "Wrong size on LObjectPoolSystem_ShrinkRecyclingBin");
static_assert(offsetof(LObjectPoolSystem_ShrinkRecyclingBin, WorldContext) == 0x000000, "Member 'LObjectPoolSystem_ShrinkRecyclingBin::WorldContext' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ShrinkRecyclingBin, RecyclablesClass) == 0x000008, "Member 'LObjectPoolSystem_ShrinkRecyclingBin::RecyclablesClass' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ShrinkRecyclingBin, DesiredSize) == 0x000030, "Member 'LObjectPoolSystem_ShrinkRecyclingBin::DesiredSize' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_ShrinkRecyclingBin, ReturnValue) == 0x000034, "Member 'LObjectPoolSystem_ShrinkRecyclingBin::ReturnValue' has a wrong offset!");

// Function ProjectP.LObjectPoolSystem.GetSizeOfRecyclingBin
// 0x0038 (0x0038 - 0x0000)
struct LObjectPoolSystem_GetSizeOfRecyclingBin final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RecyclablesClass;                                  // 0x0008(0x0028)(ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LObjectPoolSystem_GetSizeOfRecyclingBin) == 0x000008, "Wrong alignment on LObjectPoolSystem_GetSizeOfRecyclingBin");
static_assert(sizeof(LObjectPoolSystem_GetSizeOfRecyclingBin) == 0x000038, "Wrong size on LObjectPoolSystem_GetSizeOfRecyclingBin");
static_assert(offsetof(LObjectPoolSystem_GetSizeOfRecyclingBin, WorldContext) == 0x000000, "Member 'LObjectPoolSystem_GetSizeOfRecyclingBin::WorldContext' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_GetSizeOfRecyclingBin, RecyclablesClass) == 0x000008, "Member 'LObjectPoolSystem_GetSizeOfRecyclingBin::RecyclablesClass' has a wrong offset!");
static_assert(offsetof(LObjectPoolSystem_GetSizeOfRecyclingBin, ReturnValue) == 0x000030, "Member 'LObjectPoolSystem_GetSizeOfRecyclingBin::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.ApplyCameraOptionMultiply
// 0x0008 (0x0008 - 0x0000)
struct LCameraOption_ApplyCameraOptionMultiply final
{
public:
	ECameraDirectOption                           InOptionType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsPad;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InValue;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_ApplyCameraOptionMultiply) == 0x000004, "Wrong alignment on LCameraOption_ApplyCameraOptionMultiply");
static_assert(sizeof(LCameraOption_ApplyCameraOptionMultiply) == 0x000008, "Wrong size on LCameraOption_ApplyCameraOptionMultiply");
static_assert(offsetof(LCameraOption_ApplyCameraOptionMultiply, InOptionType) == 0x000000, "Member 'LCameraOption_ApplyCameraOptionMultiply::InOptionType' has a wrong offset!");
static_assert(offsetof(LCameraOption_ApplyCameraOptionMultiply, InIsPad) == 0x000001, "Member 'LCameraOption_ApplyCameraOptionMultiply::InIsPad' has a wrong offset!");
static_assert(offsetof(LCameraOption_ApplyCameraOptionMultiply, InValue) == 0x000004, "Member 'LCameraOption_ApplyCameraOptionMultiply::InValue' has a wrong offset!");

// Function ProjectP.LCameraOption.GetMoveSpeedStep
// 0x0008 (0x0008 - 0x0000)
struct LCameraOption_GetMoveSpeedStep final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELInputOptionType                             InType;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_GetMoveSpeedStep) == 0x000004, "Wrong alignment on LCameraOption_GetMoveSpeedStep");
static_assert(sizeof(LCameraOption_GetMoveSpeedStep) == 0x000008, "Wrong size on LCameraOption_GetMoveSpeedStep");
static_assert(offsetof(LCameraOption_GetMoveSpeedStep, InRotator) == 0x000000, "Member 'LCameraOption_GetMoveSpeedStep::InRotator' has a wrong offset!");
static_assert(offsetof(LCameraOption_GetMoveSpeedStep, InType) == 0x000001, "Member 'LCameraOption_GetMoveSpeedStep::InType' has a wrong offset!");
static_assert(offsetof(LCameraOption_GetMoveSpeedStep, ReturnValue) == 0x000004, "Member 'LCameraOption_GetMoveSpeedStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.IsEnableAlignmentToCamera
// 0x0001 (0x0001 - 0x0000)
struct LCameraOption_IsEnableAlignmentToCamera final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_IsEnableAlignmentToCamera) == 0x000001, "Wrong alignment on LCameraOption_IsEnableAlignmentToCamera");
static_assert(sizeof(LCameraOption_IsEnableAlignmentToCamera) == 0x000001, "Wrong size on LCameraOption_IsEnableAlignmentToCamera");
static_assert(offsetof(LCameraOption_IsEnableAlignmentToCamera, ReturnValue) == 0x000000, "Member 'LCameraOption_IsEnableAlignmentToCamera::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.IsEnableCameraShake
// 0x0001 (0x0001 - 0x0000)
struct LCameraOption_IsEnableCameraShake final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_IsEnableCameraShake) == 0x000001, "Wrong alignment on LCameraOption_IsEnableCameraShake");
static_assert(sizeof(LCameraOption_IsEnableCameraShake) == 0x000001, "Wrong size on LCameraOption_IsEnableCameraShake");
static_assert(offsetof(LCameraOption_IsEnableCameraShake, ReturnValue) == 0x000000, "Member 'LCameraOption_IsEnableCameraShake::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.IsEnableMoveCameraUpDown
// 0x0001 (0x0001 - 0x0000)
struct LCameraOption_IsEnableMoveCameraUpDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_IsEnableMoveCameraUpDown) == 0x000001, "Wrong alignment on LCameraOption_IsEnableMoveCameraUpDown");
static_assert(sizeof(LCameraOption_IsEnableMoveCameraUpDown) == 0x000001, "Wrong size on LCameraOption_IsEnableMoveCameraUpDown");
static_assert(offsetof(LCameraOption_IsEnableMoveCameraUpDown, ReturnValue) == 0x000000, "Member 'LCameraOption_IsEnableMoveCameraUpDown::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.IsInvertMove
// 0x0003 (0x0003 - 0x0000)
struct LCameraOption_IsInvertMove final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELInputOptionType                             InType;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_IsInvertMove) == 0x000001, "Wrong alignment on LCameraOption_IsInvertMove");
static_assert(sizeof(LCameraOption_IsInvertMove) == 0x000003, "Wrong size on LCameraOption_IsInvertMove");
static_assert(offsetof(LCameraOption_IsInvertMove, InRotator) == 0x000000, "Member 'LCameraOption_IsInvertMove::InRotator' has a wrong offset!");
static_assert(offsetof(LCameraOption_IsInvertMove, InType) == 0x000001, "Member 'LCameraOption_IsInvertMove::InType' has a wrong offset!");
static_assert(offsetof(LCameraOption_IsInvertMove, ReturnValue) == 0x000002, "Member 'LCameraOption_IsInvertMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.OnChangedInputMode
// 0x0001 (0x0001 - 0x0000)
struct LCameraOption_OnChangedInputMode final
{
public:
	bool                                          bGamePad;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_OnChangedInputMode) == 0x000001, "Wrong alignment on LCameraOption_OnChangedInputMode");
static_assert(sizeof(LCameraOption_OnChangedInputMode) == 0x000001, "Wrong size on LCameraOption_OnChangedInputMode");
static_assert(offsetof(LCameraOption_OnChangedInputMode, bGamePad) == 0x000000, "Member 'LCameraOption_OnChangedInputMode::bGamePad' has a wrong offset!");

// Function ProjectP.LCameraOption.SetEnableAlignmentToCamera
// 0x0002 (0x0002 - 0x0000)
struct LCameraOption_SetEnableAlignmentToCamera final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_SetEnableAlignmentToCamera) == 0x000001, "Wrong alignment on LCameraOption_SetEnableAlignmentToCamera");
static_assert(sizeof(LCameraOption_SetEnableAlignmentToCamera) == 0x000002, "Wrong size on LCameraOption_SetEnableAlignmentToCamera");
static_assert(offsetof(LCameraOption_SetEnableAlignmentToCamera, Enable) == 0x000000, "Member 'LCameraOption_SetEnableAlignmentToCamera::Enable' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetEnableAlignmentToCamera, ReturnValue) == 0x000001, "Member 'LCameraOption_SetEnableAlignmentToCamera::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.SetEnableCameraShake
// 0x0002 (0x0002 - 0x0000)
struct LCameraOption_SetEnableCameraShake final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_SetEnableCameraShake) == 0x000001, "Wrong alignment on LCameraOption_SetEnableCameraShake");
static_assert(sizeof(LCameraOption_SetEnableCameraShake) == 0x000002, "Wrong size on LCameraOption_SetEnableCameraShake");
static_assert(offsetof(LCameraOption_SetEnableCameraShake, Enable) == 0x000000, "Member 'LCameraOption_SetEnableCameraShake::Enable' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetEnableCameraShake, ReturnValue) == 0x000001, "Member 'LCameraOption_SetEnableCameraShake::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.SetEnableMoveCameraUpDown
// 0x0002 (0x0002 - 0x0000)
struct LCameraOption_SetEnableMoveCameraUpDown final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_SetEnableMoveCameraUpDown) == 0x000001, "Wrong alignment on LCameraOption_SetEnableMoveCameraUpDown");
static_assert(sizeof(LCameraOption_SetEnableMoveCameraUpDown) == 0x000002, "Wrong size on LCameraOption_SetEnableMoveCameraUpDown");
static_assert(offsetof(LCameraOption_SetEnableMoveCameraUpDown, Enable) == 0x000000, "Member 'LCameraOption_SetEnableMoveCameraUpDown::Enable' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetEnableMoveCameraUpDown, ReturnValue) == 0x000001, "Member 'LCameraOption_SetEnableMoveCameraUpDown::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.SetInvertMove
// 0x0004 (0x0004 - 0x0000)
struct LCameraOption_SetInvertMove final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InInvert;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELInputOptionType                             InType;                                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0003(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LCameraOption_SetInvertMove) == 0x000001, "Wrong alignment on LCameraOption_SetInvertMove");
static_assert(sizeof(LCameraOption_SetInvertMove) == 0x000004, "Wrong size on LCameraOption_SetInvertMove");
static_assert(offsetof(LCameraOption_SetInvertMove, InRotator) == 0x000000, "Member 'LCameraOption_SetInvertMove::InRotator' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetInvertMove, InInvert) == 0x000001, "Member 'LCameraOption_SetInvertMove::InInvert' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetInvertMove, InType) == 0x000002, "Member 'LCameraOption_SetInvertMove::InType' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetInvertMove, ReturnValue) == 0x000003, "Member 'LCameraOption_SetInvertMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LCameraOption.SetMoveSpeedStep
// 0x000C (0x000C - 0x0000)
struct LCameraOption_SetMoveSpeedStep final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InStep;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELInputOptionType                             InType;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LCameraOption_SetMoveSpeedStep) == 0x000004, "Wrong alignment on LCameraOption_SetMoveSpeedStep");
static_assert(sizeof(LCameraOption_SetMoveSpeedStep) == 0x00000C, "Wrong size on LCameraOption_SetMoveSpeedStep");
static_assert(offsetof(LCameraOption_SetMoveSpeedStep, InRotator) == 0x000000, "Member 'LCameraOption_SetMoveSpeedStep::InRotator' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetMoveSpeedStep, InStep) == 0x000004, "Member 'LCameraOption_SetMoveSpeedStep::InStep' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetMoveSpeedStep, InType) == 0x000008, "Member 'LCameraOption_SetMoveSpeedStep::InType' has a wrong offset!");
static_assert(offsetof(LCameraOption_SetMoveSpeedStep, ReturnValue) == 0x000009, "Member 'LCameraOption_SetMoveSpeedStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.AutoScalabilityLevel
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_AutoScalabilityLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_AutoScalabilityLevel) == 0x000001, "Wrong alignment on LGraphicOption_AutoScalabilityLevel");
static_assert(sizeof(LGraphicOption_AutoScalabilityLevel) == 0x000001, "Wrong size on LGraphicOption_AutoScalabilityLevel");
static_assert(offsetof(LGraphicOption_AutoScalabilityLevel, ReturnValue) == 0x000000, "Member 'LGraphicOption_AutoScalabilityLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCACAOEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCACAOEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCACAOEnabled) == 0x000001, "Wrong alignment on LGraphicOption_GetCACAOEnabled");
static_assert(sizeof(LGraphicOption_GetCACAOEnabled) == 0x000001, "Wrong size on LGraphicOption_GetCACAOEnabled");
static_assert(offsetof(LGraphicOption_GetCACAOEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCACAOEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentBrightness
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetCurrentBrightness final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentBrightness) == 0x000004, "Wrong alignment on LGraphicOption_GetCurrentBrightness");
static_assert(sizeof(LGraphicOption_GetCurrentBrightness) == 0x000004, "Wrong size on LGraphicOption_GetCurrentBrightness");
static_assert(offsetof(LGraphicOption_GetCurrentBrightness, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentBrightness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentDLSSMode
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentDLSSMode final
{
public:
	EDLSSMode                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentDLSSMode) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentDLSSMode");
static_assert(sizeof(LGraphicOption_GetCurrentDLSSMode) == 0x000001, "Wrong size on LGraphicOption_GetCurrentDLSSMode");
static_assert(offsetof(LGraphicOption_GetCurrentDLSSMode, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentDLSSMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentDLSSSharpness
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetCurrentDLSSSharpness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentDLSSSharpness) == 0x000004, "Wrong alignment on LGraphicOption_GetCurrentDLSSSharpness");
static_assert(sizeof(LGraphicOption_GetCurrentDLSSSharpness) == 0x000004, "Wrong size on LGraphicOption_GetCurrentDLSSSharpness");
static_assert(offsetof(LGraphicOption_GetCurrentDLSSSharpness, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentDLSSSharpness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentFSR1Mode
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentFSR1Mode final
{
public:
	EFSR1Mode                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentFSR1Mode) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentFSR1Mode");
static_assert(sizeof(LGraphicOption_GetCurrentFSR1Mode) == 0x000001, "Wrong size on LGraphicOption_GetCurrentFSR1Mode");
static_assert(offsetof(LGraphicOption_GetCurrentFSR1Mode, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentFSR1Mode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentFSR2Mode
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentFSR2Mode final
{
public:
	EFSR2Mode                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentFSR2Mode) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentFSR2Mode");
static_assert(sizeof(LGraphicOption_GetCurrentFSR2Mode) == 0x000001, "Wrong size on LGraphicOption_GetCurrentFSR2Mode");
static_assert(offsetof(LGraphicOption_GetCurrentFSR2Mode, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentFSR2Mode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentFSR2Sharpness
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetCurrentFSR2Sharpness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentFSR2Sharpness) == 0x000004, "Wrong alignment on LGraphicOption_GetCurrentFSR2Sharpness");
static_assert(sizeof(LGraphicOption_GetCurrentFSR2Sharpness) == 0x000004, "Wrong size on LGraphicOption_GetCurrentFSR2Sharpness");
static_assert(offsetof(LGraphicOption_GetCurrentFSR2Sharpness, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentFSR2Sharpness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentHDRBrightness
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetCurrentHDRBrightness final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentHDRBrightness) == 0x000004, "Wrong alignment on LGraphicOption_GetCurrentHDRBrightness");
static_assert(sizeof(LGraphicOption_GetCurrentHDRBrightness) == 0x000004, "Wrong size on LGraphicOption_GetCurrentHDRBrightness");
static_assert(offsetof(LGraphicOption_GetCurrentHDRBrightness, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentHDRBrightness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentHDRContrast
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetCurrentHDRContrast final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentHDRContrast) == 0x000004, "Wrong alignment on LGraphicOption_GetCurrentHDRContrast");
static_assert(sizeof(LGraphicOption_GetCurrentHDRContrast) == 0x000004, "Wrong size on LGraphicOption_GetCurrentHDRContrast");
static_assert(offsetof(LGraphicOption_GetCurrentHDRContrast, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentHDRContrast::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentPlayStyleOption
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentPlayStyleOption final
{
public:
	EPlayStyleOption                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentPlayStyleOption) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentPlayStyleOption");
static_assert(sizeof(LGraphicOption_GetCurrentPlayStyleOption) == 0x000001, "Wrong size on LGraphicOption_GetCurrentPlayStyleOption");
static_assert(offsetof(LGraphicOption_GetCurrentPlayStyleOption, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentPlayStyleOption::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentReflexMode
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentReflexMode final
{
public:
	EReflexMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentReflexMode) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentReflexMode");
static_assert(sizeof(LGraphicOption_GetCurrentReflexMode) == 0x000001, "Wrong size on LGraphicOption_GetCurrentReflexMode");
static_assert(offsetof(LGraphicOption_GetCurrentReflexMode, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentReflexMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_GetCurrentScreenResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentScreenResolution) == 0x000004, "Wrong alignment on LGraphicOption_GetCurrentScreenResolution");
static_assert(sizeof(LGraphicOption_GetCurrentScreenResolution) == 0x000008, "Wrong size on LGraphicOption_GetCurrentScreenResolution");
static_assert(offsetof(LGraphicOption_GetCurrentScreenResolution, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentScreenResolution::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentXeSSMode
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentXeSSMode final
{
public:
	EXeSSMode                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentXeSSMode) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentXeSSMode");
static_assert(sizeof(LGraphicOption_GetCurrentXeSSMode) == 0x000001, "Wrong size on LGraphicOption_GetCurrentXeSSMode");
static_assert(offsetof(LGraphicOption_GetCurrentXeSSMode, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentXeSSMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetDetailScalability
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_GetDetailScalability final
{
public:
	EScalabilityType                              InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELScalabilityDefaultLevel                     ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetDetailScalability) == 0x000001, "Wrong alignment on LGraphicOption_GetDetailScalability");
static_assert(sizeof(LGraphicOption_GetDetailScalability) == 0x000002, "Wrong size on LGraphicOption_GetDetailScalability");
static_assert(offsetof(LGraphicOption_GetDetailScalability, InType) == 0x000000, "Member 'LGraphicOption_GetDetailScalability::InType' has a wrong offset!");
static_assert(offsetof(LGraphicOption_GetDetailScalability, ReturnValue) == 0x000001, "Member 'LGraphicOption_GetDetailScalability::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetDLSSGEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetDLSSGEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetDLSSGEnabled) == 0x000001, "Wrong alignment on LGraphicOption_GetDLSSGEnabled");
static_assert(sizeof(LGraphicOption_GetDLSSGEnabled) == 0x000001, "Wrong size on LGraphicOption_GetDLSSGEnabled");
static_assert(offsetof(LGraphicOption_GetDLSSGEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetDLSSGEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetFrameRateLimit
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetFrameRateLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetFrameRateLimit) == 0x000004, "Wrong alignment on LGraphicOption_GetFrameRateLimit");
static_assert(sizeof(LGraphicOption_GetFrameRateLimit) == 0x000004, "Wrong size on LGraphicOption_GetFrameRateLimit");
static_assert(offsetof(LGraphicOption_GetFrameRateLimit, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetFrameRateLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetFullscreenMode final
{
public:
	EWindowMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetFullscreenMode) == 0x000001, "Wrong alignment on LGraphicOption_GetFullscreenMode");
static_assert(sizeof(LGraphicOption_GetFullscreenMode) == 0x000001, "Wrong size on LGraphicOption_GetFullscreenMode");
static_assert(offsetof(LGraphicOption_GetFullscreenMode, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetFullscreenMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetGraphicCardName
// 0x0010 (0x0010 - 0x0000)
struct LGraphicOption_GetGraphicCardName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetGraphicCardName) == 0x000008, "Wrong alignment on LGraphicOption_GetGraphicCardName");
static_assert(sizeof(LGraphicOption_GetGraphicCardName) == 0x000010, "Wrong size on LGraphicOption_GetGraphicCardName");
static_assert(offsetof(LGraphicOption_GetGraphicCardName, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetGraphicCardName::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetScreenResolutionStep
// 0x0004 (0x0004 - 0x0000)
struct LGraphicOption_GetScreenResolutionStep final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetScreenResolutionStep) == 0x000004, "Wrong alignment on LGraphicOption_GetScreenResolutionStep");
static_assert(sizeof(LGraphicOption_GetScreenResolutionStep) == 0x000004, "Wrong size on LGraphicOption_GetScreenResolutionStep");
static_assert(offsetof(LGraphicOption_GetScreenResolutionStep, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetScreenResolutionStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetSelectableScreenResolutions
// 0x0010 (0x0010 - 0x0000)
struct LGraphicOption_GetSelectableScreenResolutions final
{
public:
	TArray<struct FIntPoint>                      ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetSelectableScreenResolutions) == 0x000008, "Wrong alignment on LGraphicOption_GetSelectableScreenResolutions");
static_assert(sizeof(LGraphicOption_GetSelectableScreenResolutions) == 0x000010, "Wrong size on LGraphicOption_GetSelectableScreenResolutions");
static_assert(offsetof(LGraphicOption_GetSelectableScreenResolutions, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetSelectableScreenResolutions::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetSupportedDLSSModes
// 0x0010 (0x0010 - 0x0000)
struct LGraphicOption_GetSupportedDLSSModes final
{
public:
	TArray<EDLSSMode>                             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetSupportedDLSSModes) == 0x000008, "Wrong alignment on LGraphicOption_GetSupportedDLSSModes");
static_assert(sizeof(LGraphicOption_GetSupportedDLSSModes) == 0x000010, "Wrong size on LGraphicOption_GetSupportedDLSSModes");
static_assert(offsetof(LGraphicOption_GetSupportedDLSSModes, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetSupportedDLSSModes::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.Is120HzModeEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_Is120HzModeEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_Is120HzModeEnabled) == 0x000001, "Wrong alignment on LGraphicOption_Is120HzModeEnabled");
static_assert(sizeof(LGraphicOption_Is120HzModeEnabled) == 0x000001, "Wrong size on LGraphicOption_Is120HzModeEnabled");
static_assert(offsetof(LGraphicOption_Is120HzModeEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_Is120HzModeEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.Is120HzModeSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_Is120HzModeSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_Is120HzModeSupported) == 0x000001, "Wrong alignment on LGraphicOption_Is120HzModeSupported");
static_assert(sizeof(LGraphicOption_Is120HzModeSupported) == 0x000001, "Wrong size on LGraphicOption_Is120HzModeSupported");
static_assert(offsetof(LGraphicOption_Is120HzModeSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_Is120HzModeSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsCACAOSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsCACAOSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsCACAOSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsCACAOSupported");
static_assert(sizeof(LGraphicOption_IsCACAOSupported) == 0x000001, "Wrong size on LGraphicOption_IsCACAOSupported");
static_assert(offsetof(LGraphicOption_IsCACAOSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsCACAOSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsDLSSGAvailable
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsDLSSGAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsDLSSGAvailable) == 0x000001, "Wrong alignment on LGraphicOption_IsDLSSGAvailable");
static_assert(sizeof(LGraphicOption_IsDLSSGAvailable) == 0x000001, "Wrong size on LGraphicOption_IsDLSSGAvailable");
static_assert(offsetof(LGraphicOption_IsDLSSGAvailable, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsDLSSGAvailable::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsDLSSGSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsDLSSGSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsDLSSGSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsDLSSGSupported");
static_assert(sizeof(LGraphicOption_IsDLSSGSupported) == 0x000001, "Wrong size on LGraphicOption_IsDLSSGSupported");
static_assert(offsetof(LGraphicOption_IsDLSSGSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsDLSSGSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsDLSSModeSupported
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_IsDLSSModeSupported final
{
public:
	EDLSSMode                                     InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsDLSSModeSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsDLSSModeSupported");
static_assert(sizeof(LGraphicOption_IsDLSSModeSupported) == 0x000002, "Wrong size on LGraphicOption_IsDLSSModeSupported");
static_assert(offsetof(LGraphicOption_IsDLSSModeSupported, InMode) == 0x000000, "Member 'LGraphicOption_IsDLSSModeSupported::InMode' has a wrong offset!");
static_assert(offsetof(LGraphicOption_IsDLSSModeSupported, ReturnValue) == 0x000001, "Member 'LGraphicOption_IsDLSSModeSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsDLSSSharpnessAvailable
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsDLSSSharpnessAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsDLSSSharpnessAvailable) == 0x000001, "Wrong alignment on LGraphicOption_IsDLSSSharpnessAvailable");
static_assert(sizeof(LGraphicOption_IsDLSSSharpnessAvailable) == 0x000001, "Wrong size on LGraphicOption_IsDLSSSharpnessAvailable");
static_assert(offsetof(LGraphicOption_IsDLSSSharpnessAvailable, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsDLSSSharpnessAvailable::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsDLSSSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsDLSSSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsDLSSSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsDLSSSupported");
static_assert(sizeof(LGraphicOption_IsDLSSSupported) == 0x000001, "Wrong size on LGraphicOption_IsDLSSSupported");
static_assert(offsetof(LGraphicOption_IsDLSSSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsDLSSSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsFSR1Supported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsFSR1Supported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsFSR1Supported) == 0x000001, "Wrong alignment on LGraphicOption_IsFSR1Supported");
static_assert(sizeof(LGraphicOption_IsFSR1Supported) == 0x000001, "Wrong size on LGraphicOption_IsFSR1Supported");
static_assert(offsetof(LGraphicOption_IsFSR1Supported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsFSR1Supported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsFSR2SharpnessAvailable
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsFSR2SharpnessAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsFSR2SharpnessAvailable) == 0x000001, "Wrong alignment on LGraphicOption_IsFSR2SharpnessAvailable");
static_assert(sizeof(LGraphicOption_IsFSR2SharpnessAvailable) == 0x000001, "Wrong size on LGraphicOption_IsFSR2SharpnessAvailable");
static_assert(offsetof(LGraphicOption_IsFSR2SharpnessAvailable, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsFSR2SharpnessAvailable::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsFSR2Supported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsFSR2Supported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsFSR2Supported) == 0x000001, "Wrong alignment on LGraphicOption_IsFSR2Supported");
static_assert(sizeof(LGraphicOption_IsFSR2Supported) == 0x000001, "Wrong size on LGraphicOption_IsFSR2Supported");
static_assert(offsetof(LGraphicOption_IsFSR2Supported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsFSR2Supported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsHDROutputEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsHDROutputEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsHDROutputEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsHDROutputEnabled");
static_assert(sizeof(LGraphicOption_IsHDROutputEnabled) == 0x000001, "Wrong size on LGraphicOption_IsHDROutputEnabled");
static_assert(offsetof(LGraphicOption_IsHDROutputEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsHDROutputEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsHDROutputSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsHDROutputSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsHDROutputSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsHDROutputSupported");
static_assert(sizeof(LGraphicOption_IsHDROutputSupported) == 0x000001, "Wrong size on LGraphicOption_IsHDROutputSupported");
static_assert(offsetof(LGraphicOption_IsHDROutputSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsHDROutputSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsPlayStyleOptionEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsPlayStyleOptionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsPlayStyleOptionEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsPlayStyleOptionEnabled");
static_assert(sizeof(LGraphicOption_IsPlayStyleOptionEnabled) == 0x000001, "Wrong size on LGraphicOption_IsPlayStyleOptionEnabled");
static_assert(offsetof(LGraphicOption_IsPlayStyleOptionEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsPlayStyleOptionEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingAmbientOcclusionEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingAmbientOcclusionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingAmbientOcclusionEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingAmbientOcclusionEnabled");
static_assert(sizeof(LGraphicOption_IsRayTracingAmbientOcclusionEnabled) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingAmbientOcclusionEnabled");
static_assert(offsetof(LGraphicOption_IsRayTracingAmbientOcclusionEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingAmbientOcclusionEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingGlobalIlluminationEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingGlobalIlluminationEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingGlobalIlluminationEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingGlobalIlluminationEnabled");
static_assert(sizeof(LGraphicOption_IsRayTracingGlobalIlluminationEnabled) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingGlobalIlluminationEnabled");
static_assert(offsetof(LGraphicOption_IsRayTracingGlobalIlluminationEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingGlobalIlluminationEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingReflectionsEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingReflectionsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingReflectionsEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingReflectionsEnabled");
static_assert(sizeof(LGraphicOption_IsRayTracingReflectionsEnabled) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingReflectionsEnabled");
static_assert(offsetof(LGraphicOption_IsRayTracingReflectionsEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingReflectionsEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingShadowsEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingShadowsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingShadowsEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingShadowsEnabled");
static_assert(sizeof(LGraphicOption_IsRayTracingShadowsEnabled) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingShadowsEnabled");
static_assert(offsetof(LGraphicOption_IsRayTracingShadowsEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingShadowsEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingSkyLightEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingSkyLightEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingSkyLightEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingSkyLightEnabled");
static_assert(sizeof(LGraphicOption_IsRayTracingSkyLightEnabled) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingSkyLightEnabled");
static_assert(offsetof(LGraphicOption_IsRayTracingSkyLightEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingSkyLightEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingSupported");
static_assert(sizeof(LGraphicOption_IsRayTracingSupported) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingSupported");
static_assert(offsetof(LGraphicOption_IsRayTracingSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsRayTracingTranslucencyEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsRayTracingTranslucencyEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsRayTracingTranslucencyEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsRayTracingTranslucencyEnabled");
static_assert(sizeof(LGraphicOption_IsRayTracingTranslucencyEnabled) == 0x000001, "Wrong size on LGraphicOption_IsRayTracingTranslucencyEnabled");
static_assert(offsetof(LGraphicOption_IsRayTracingTranslucencyEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsRayTracingTranslucencyEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsReflexModeAvailable
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsReflexModeAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsReflexModeAvailable) == 0x000001, "Wrong alignment on LGraphicOption_IsReflexModeAvailable");
static_assert(sizeof(LGraphicOption_IsReflexModeAvailable) == 0x000001, "Wrong size on LGraphicOption_IsReflexModeAvailable");
static_assert(offsetof(LGraphicOption_IsReflexModeAvailable, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsReflexModeAvailable::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsReflexSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsReflexSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsReflexSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsReflexSupported");
static_assert(sizeof(LGraphicOption_IsReflexSupported) == 0x000001, "Wrong size on LGraphicOption_IsReflexSupported");
static_assert(offsetof(LGraphicOption_IsReflexSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsReflexSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsVRSEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsVRSEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsVRSEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsVRSEnabled");
static_assert(sizeof(LGraphicOption_IsVRSEnabled) == 0x000001, "Wrong size on LGraphicOption_IsVRSEnabled");
static_assert(offsetof(LGraphicOption_IsVRSEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsVRSEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsVRSSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsVRSSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsVRSSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsVRSSupported");
static_assert(sizeof(LGraphicOption_IsVRSSupported) == 0x000001, "Wrong size on LGraphicOption_IsVRSSupported");
static_assert(offsetof(LGraphicOption_IsVRSSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsVRSSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsVSyncEnabled
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsVSyncEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsVSyncEnabled) == 0x000001, "Wrong alignment on LGraphicOption_IsVSyncEnabled");
static_assert(sizeof(LGraphicOption_IsVSyncEnabled) == 0x000001, "Wrong size on LGraphicOption_IsVSyncEnabled");
static_assert(offsetof(LGraphicOption_IsVSyncEnabled, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsVSyncEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.IsXeSSSupported
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_IsXeSSSupported final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_IsXeSSSupported) == 0x000001, "Wrong alignment on LGraphicOption_IsXeSSSupported");
static_assert(sizeof(LGraphicOption_IsXeSSSupported) == 0x000001, "Wrong size on LGraphicOption_IsXeSSSupported");
static_assert(offsetof(LGraphicOption_IsXeSSSupported, ReturnValue) == 0x000000, "Member 'LGraphicOption_IsXeSSSupported::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.Set120HzModeEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_Set120HzModeEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_Set120HzModeEnabled) == 0x000001, "Wrong alignment on LGraphicOption_Set120HzModeEnabled");
static_assert(sizeof(LGraphicOption_Set120HzModeEnabled) == 0x000002, "Wrong size on LGraphicOption_Set120HzModeEnabled");
static_assert(offsetof(LGraphicOption_Set120HzModeEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_Set120HzModeEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_Set120HzModeEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_Set120HzModeEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetCACAOEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetCACAOEnabled final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetCACAOEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetCACAOEnabled");
static_assert(sizeof(LGraphicOption_SetCACAOEnabled) == 0x000002, "Wrong size on LGraphicOption_SetCACAOEnabled");
static_assert(offsetof(LGraphicOption_SetCACAOEnabled, InEnable) == 0x000000, "Member 'LGraphicOption_SetCACAOEnabled::InEnable' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetCACAOEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetCACAOEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetCurrentBrightness
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetCurrentBrightness final
{
public:
	int32                                         InBrightness;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetCurrentBrightness) == 0x000004, "Wrong alignment on LGraphicOption_SetCurrentBrightness");
static_assert(sizeof(LGraphicOption_SetCurrentBrightness) == 0x000008, "Wrong size on LGraphicOption_SetCurrentBrightness");
static_assert(offsetof(LGraphicOption_SetCurrentBrightness, InBrightness) == 0x000000, "Member 'LGraphicOption_SetCurrentBrightness::InBrightness' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetCurrentBrightness, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetCurrentBrightness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetCurrentHDRBrightness
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetCurrentHDRBrightness final
{
public:
	int32                                         InBrightness;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetCurrentHDRBrightness) == 0x000004, "Wrong alignment on LGraphicOption_SetCurrentHDRBrightness");
static_assert(sizeof(LGraphicOption_SetCurrentHDRBrightness) == 0x000008, "Wrong size on LGraphicOption_SetCurrentHDRBrightness");
static_assert(offsetof(LGraphicOption_SetCurrentHDRBrightness, InBrightness) == 0x000000, "Member 'LGraphicOption_SetCurrentHDRBrightness::InBrightness' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetCurrentHDRBrightness, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetCurrentHDRBrightness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetCurrentHDRContrast
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetCurrentHDRContrast final
{
public:
	int32                                         InContrast;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetCurrentHDRContrast) == 0x000004, "Wrong alignment on LGraphicOption_SetCurrentHDRContrast");
static_assert(sizeof(LGraphicOption_SetCurrentHDRContrast) == 0x000008, "Wrong size on LGraphicOption_SetCurrentHDRContrast");
static_assert(offsetof(LGraphicOption_SetCurrentHDRContrast, InContrast) == 0x000000, "Member 'LGraphicOption_SetCurrentHDRContrast::InContrast' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetCurrentHDRContrast, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetCurrentHDRContrast::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetDetailScalability
// 0x0003 (0x0003 - 0x0000)
struct LGraphicOption_SetDetailScalability final
{
public:
	EScalabilityType                              InType;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELScalabilityDefaultLevel                     InValue;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetDetailScalability) == 0x000001, "Wrong alignment on LGraphicOption_SetDetailScalability");
static_assert(sizeof(LGraphicOption_SetDetailScalability) == 0x000003, "Wrong size on LGraphicOption_SetDetailScalability");
static_assert(offsetof(LGraphicOption_SetDetailScalability, InType) == 0x000000, "Member 'LGraphicOption_SetDetailScalability::InType' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetDetailScalability, InValue) == 0x000001, "Member 'LGraphicOption_SetDetailScalability::InValue' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetDetailScalability, ReturnValue) == 0x000002, "Member 'LGraphicOption_SetDetailScalability::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetDLSSGEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetDLSSGEnabled final
{
public:
	bool                                          InEnabled;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetDLSSGEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetDLSSGEnabled");
static_assert(sizeof(LGraphicOption_SetDLSSGEnabled) == 0x000002, "Wrong size on LGraphicOption_SetDLSSGEnabled");
static_assert(offsetof(LGraphicOption_SetDLSSGEnabled, InEnabled) == 0x000000, "Member 'LGraphicOption_SetDLSSGEnabled::InEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetDLSSGEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetDLSSGEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetDLSSMode
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetDLSSMode final
{
public:
	EDLSSMode                                     InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetDLSSMode) == 0x000001, "Wrong alignment on LGraphicOption_SetDLSSMode");
static_assert(sizeof(LGraphicOption_SetDLSSMode) == 0x000002, "Wrong size on LGraphicOption_SetDLSSMode");
static_assert(offsetof(LGraphicOption_SetDLSSMode, InMode) == 0x000000, "Member 'LGraphicOption_SetDLSSMode::InMode' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetDLSSMode, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetDLSSMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetDLSSSharpness
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetDLSSSharpness final
{
public:
	float                                         InSharpness;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetDLSSSharpness) == 0x000004, "Wrong alignment on LGraphicOption_SetDLSSSharpness");
static_assert(sizeof(LGraphicOption_SetDLSSSharpness) == 0x000008, "Wrong size on LGraphicOption_SetDLSSSharpness");
static_assert(offsetof(LGraphicOption_SetDLSSSharpness, InSharpness) == 0x000000, "Member 'LGraphicOption_SetDLSSSharpness::InSharpness' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetDLSSSharpness, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetDLSSSharpness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetFrameRateLimit
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetFrameRateLimit final
{
public:
	float                                         InFrameratelimit;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetFrameRateLimit) == 0x000004, "Wrong alignment on LGraphicOption_SetFrameRateLimit");
static_assert(sizeof(LGraphicOption_SetFrameRateLimit) == 0x000008, "Wrong size on LGraphicOption_SetFrameRateLimit");
static_assert(offsetof(LGraphicOption_SetFrameRateLimit, InFrameratelimit) == 0x000000, "Member 'LGraphicOption_SetFrameRateLimit::InFrameratelimit' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetFrameRateLimit, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetFrameRateLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetFSR1Mode
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetFSR1Mode final
{
public:
	EFSR1Mode                                     InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetFSR1Mode) == 0x000001, "Wrong alignment on LGraphicOption_SetFSR1Mode");
static_assert(sizeof(LGraphicOption_SetFSR1Mode) == 0x000002, "Wrong size on LGraphicOption_SetFSR1Mode");
static_assert(offsetof(LGraphicOption_SetFSR1Mode, InMode) == 0x000000, "Member 'LGraphicOption_SetFSR1Mode::InMode' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetFSR1Mode, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetFSR1Mode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetFSR2Mode
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetFSR2Mode final
{
public:
	EFSR2Mode                                     InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetFSR2Mode) == 0x000001, "Wrong alignment on LGraphicOption_SetFSR2Mode");
static_assert(sizeof(LGraphicOption_SetFSR2Mode) == 0x000002, "Wrong size on LGraphicOption_SetFSR2Mode");
static_assert(offsetof(LGraphicOption_SetFSR2Mode, InMode) == 0x000000, "Member 'LGraphicOption_SetFSR2Mode::InMode' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetFSR2Mode, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetFSR2Mode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetFSR2Sharpness
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetFSR2Sharpness final
{
public:
	float                                         InSharpness;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetFSR2Sharpness) == 0x000004, "Wrong alignment on LGraphicOption_SetFSR2Sharpness");
static_assert(sizeof(LGraphicOption_SetFSR2Sharpness) == 0x000008, "Wrong size on LGraphicOption_SetFSR2Sharpness");
static_assert(offsetof(LGraphicOption_SetFSR2Sharpness, InSharpness) == 0x000000, "Member 'LGraphicOption_SetFSR2Sharpness::InSharpness' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetFSR2Sharpness, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetFSR2Sharpness::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetFullscreenMode
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetFullscreenMode final
{
public:
	EWindowMode                                   InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetFullscreenMode) == 0x000001, "Wrong alignment on LGraphicOption_SetFullscreenMode");
static_assert(sizeof(LGraphicOption_SetFullscreenMode) == 0x000002, "Wrong size on LGraphicOption_SetFullscreenMode");
static_assert(offsetof(LGraphicOption_SetFullscreenMode, InType) == 0x000000, "Member 'LGraphicOption_SetFullscreenMode::InType' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetFullscreenMode, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetFullscreenMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetHDROutputEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetHDROutputEnabled final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetHDROutputEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetHDROutputEnabled");
static_assert(sizeof(LGraphicOption_SetHDROutputEnabled) == 0x000002, "Wrong size on LGraphicOption_SetHDROutputEnabled");
static_assert(offsetof(LGraphicOption_SetHDROutputEnabled, InEnable) == 0x000000, "Member 'LGraphicOption_SetHDROutputEnabled::InEnable' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetHDROutputEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetHDROutputEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetPlayStyleOption
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetPlayStyleOption final
{
public:
	EPlayStyleOption                              InPlayStyle;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetPlayStyleOption) == 0x000001, "Wrong alignment on LGraphicOption_SetPlayStyleOption");
static_assert(sizeof(LGraphicOption_SetPlayStyleOption) == 0x000002, "Wrong size on LGraphicOption_SetPlayStyleOption");
static_assert(offsetof(LGraphicOption_SetPlayStyleOption, InPlayStyle) == 0x000000, "Member 'LGraphicOption_SetPlayStyleOption::InPlayStyle' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetPlayStyleOption, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetPlayStyleOption::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetRayTracingAmbientOcclusionEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetRayTracingAmbientOcclusionEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetRayTracingAmbientOcclusionEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetRayTracingAmbientOcclusionEnabled");
static_assert(sizeof(LGraphicOption_SetRayTracingAmbientOcclusionEnabled) == 0x000002, "Wrong size on LGraphicOption_SetRayTracingAmbientOcclusionEnabled");
static_assert(offsetof(LGraphicOption_SetRayTracingAmbientOcclusionEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_SetRayTracingAmbientOcclusionEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetRayTracingAmbientOcclusionEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetRayTracingAmbientOcclusionEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetRayTracingGlobalIlluminationEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetRayTracingGlobalIlluminationEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetRayTracingGlobalIlluminationEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetRayTracingGlobalIlluminationEnabled");
static_assert(sizeof(LGraphicOption_SetRayTracingGlobalIlluminationEnabled) == 0x000002, "Wrong size on LGraphicOption_SetRayTracingGlobalIlluminationEnabled");
static_assert(offsetof(LGraphicOption_SetRayTracingGlobalIlluminationEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_SetRayTracingGlobalIlluminationEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetRayTracingGlobalIlluminationEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetRayTracingGlobalIlluminationEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetRayTracingReflectionsEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetRayTracingReflectionsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetRayTracingReflectionsEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetRayTracingReflectionsEnabled");
static_assert(sizeof(LGraphicOption_SetRayTracingReflectionsEnabled) == 0x000002, "Wrong size on LGraphicOption_SetRayTracingReflectionsEnabled");
static_assert(offsetof(LGraphicOption_SetRayTracingReflectionsEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_SetRayTracingReflectionsEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetRayTracingReflectionsEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetRayTracingReflectionsEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetRayTracingShadowsEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetRayTracingShadowsEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetRayTracingShadowsEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetRayTracingShadowsEnabled");
static_assert(sizeof(LGraphicOption_SetRayTracingShadowsEnabled) == 0x000002, "Wrong size on LGraphicOption_SetRayTracingShadowsEnabled");
static_assert(offsetof(LGraphicOption_SetRayTracingShadowsEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_SetRayTracingShadowsEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetRayTracingShadowsEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetRayTracingShadowsEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetRayTracingSkyLightEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetRayTracingSkyLightEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetRayTracingSkyLightEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetRayTracingSkyLightEnabled");
static_assert(sizeof(LGraphicOption_SetRayTracingSkyLightEnabled) == 0x000002, "Wrong size on LGraphicOption_SetRayTracingSkyLightEnabled");
static_assert(offsetof(LGraphicOption_SetRayTracingSkyLightEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_SetRayTracingSkyLightEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetRayTracingSkyLightEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetRayTracingSkyLightEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetRayTracingTranslucencyEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetRayTracingTranslucencyEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetRayTracingTranslucencyEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetRayTracingTranslucencyEnabled");
static_assert(sizeof(LGraphicOption_SetRayTracingTranslucencyEnabled) == 0x000002, "Wrong size on LGraphicOption_SetRayTracingTranslucencyEnabled");
static_assert(offsetof(LGraphicOption_SetRayTracingTranslucencyEnabled, bEnabled) == 0x000000, "Member 'LGraphicOption_SetRayTracingTranslucencyEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetRayTracingTranslucencyEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetRayTracingTranslucencyEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetReflexMode
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetReflexMode final
{
public:
	EReflexMode                                   InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetReflexMode) == 0x000001, "Wrong alignment on LGraphicOption_SetReflexMode");
static_assert(sizeof(LGraphicOption_SetReflexMode) == 0x000002, "Wrong size on LGraphicOption_SetReflexMode");
static_assert(offsetof(LGraphicOption_SetReflexMode, InMode) == 0x000000, "Member 'LGraphicOption_SetReflexMode::InMode' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetReflexMode, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetReflexMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetScalabilityLevel
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetScalabilityLevel final
{
public:
	ELScalabilityLevel                            InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetScalabilityLevel) == 0x000001, "Wrong alignment on LGraphicOption_SetScalabilityLevel");
static_assert(sizeof(LGraphicOption_SetScalabilityLevel) == 0x000002, "Wrong size on LGraphicOption_SetScalabilityLevel");
static_assert(offsetof(LGraphicOption_SetScalabilityLevel, InType) == 0x000000, "Member 'LGraphicOption_SetScalabilityLevel::InType' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetScalabilityLevel, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetScalabilityLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetScreenResolutionStep
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_SetScreenResolutionStep final
{
public:
	int32                                         InStep;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LGraphicOption_SetScreenResolutionStep) == 0x000004, "Wrong alignment on LGraphicOption_SetScreenResolutionStep");
static_assert(sizeof(LGraphicOption_SetScreenResolutionStep) == 0x000008, "Wrong size on LGraphicOption_SetScreenResolutionStep");
static_assert(offsetof(LGraphicOption_SetScreenResolutionStep, InStep) == 0x000000, "Member 'LGraphicOption_SetScreenResolutionStep::InStep' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetScreenResolutionStep, ReturnValue) == 0x000004, "Member 'LGraphicOption_SetScreenResolutionStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetVRSEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetVRSEnabled final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetVRSEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetVRSEnabled");
static_assert(sizeof(LGraphicOption_SetVRSEnabled) == 0x000002, "Wrong size on LGraphicOption_SetVRSEnabled");
static_assert(offsetof(LGraphicOption_SetVRSEnabled, InEnable) == 0x000000, "Member 'LGraphicOption_SetVRSEnabled::InEnable' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetVRSEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetVRSEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetVSyncEnabled
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetVSyncEnabled final
{
public:
	bool                                          InEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetVSyncEnabled) == 0x000001, "Wrong alignment on LGraphicOption_SetVSyncEnabled");
static_assert(sizeof(LGraphicOption_SetVSyncEnabled) == 0x000002, "Wrong size on LGraphicOption_SetVSyncEnabled");
static_assert(offsetof(LGraphicOption_SetVSyncEnabled, InEnable) == 0x000000, "Member 'LGraphicOption_SetVSyncEnabled::InEnable' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetVSyncEnabled, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetVSyncEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.SetXeSSMode
// 0x0002 (0x0002 - 0x0000)
struct LGraphicOption_SetXeSSMode final
{
public:
	EXeSSMode                                     InMode;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_SetXeSSMode) == 0x000001, "Wrong alignment on LGraphicOption_SetXeSSMode");
static_assert(sizeof(LGraphicOption_SetXeSSMode) == 0x000002, "Wrong size on LGraphicOption_SetXeSSMode");
static_assert(offsetof(LGraphicOption_SetXeSSMode, InMode) == 0x000000, "Member 'LGraphicOption_SetXeSSMode::InMode' has a wrong offset!");
static_assert(offsetof(LGraphicOption_SetXeSSMode, ReturnValue) == 0x000001, "Member 'LGraphicOption_SetXeSSMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetCurrentScalabilityLevel
// 0x0001 (0x0001 - 0x0000)
struct LGraphicOption_GetCurrentScalabilityLevel final
{
public:
	ELScalabilityLevel                            ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetCurrentScalabilityLevel) == 0x000001, "Wrong alignment on LGraphicOption_GetCurrentScalabilityLevel");
static_assert(sizeof(LGraphicOption_GetCurrentScalabilityLevel) == 0x000001, "Wrong size on LGraphicOption_GetCurrentScalabilityLevel");
static_assert(offsetof(LGraphicOption_GetCurrentScalabilityLevel, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetCurrentScalabilityLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LGraphicOption.GetDesktopResolution
// 0x0008 (0x0008 - 0x0000)
struct LGraphicOption_GetDesktopResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LGraphicOption_GetDesktopResolution) == 0x000004, "Wrong alignment on LGraphicOption_GetDesktopResolution");
static_assert(sizeof(LGraphicOption_GetDesktopResolution) == 0x000008, "Wrong size on LGraphicOption_GetDesktopResolution");
static_assert(offsetof(LGraphicOption_GetDesktopResolution, ReturnValue) == 0x000000, "Member 'LGraphicOption_GetDesktopResolution::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.GetMouseSensitivityStep
// 0x0004 (0x0004 - 0x0000)
struct LKeyboardMouseOption_GetMouseSensitivityStep final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeyboardMouseOption_GetMouseSensitivityStep) == 0x000004, "Wrong alignment on LKeyboardMouseOption_GetMouseSensitivityStep");
static_assert(sizeof(LKeyboardMouseOption_GetMouseSensitivityStep) == 0x000004, "Wrong size on LKeyboardMouseOption_GetMouseSensitivityStep");
static_assert(offsetof(LKeyboardMouseOption_GetMouseSensitivityStep, ReturnValue) == 0x000000, "Member 'LKeyboardMouseOption_GetMouseSensitivityStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.GetMouseSensitivityValue
// 0x0004 (0x0004 - 0x0000)
struct LKeyboardMouseOption_GetMouseSensitivityValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeyboardMouseOption_GetMouseSensitivityValue) == 0x000004, "Wrong alignment on LKeyboardMouseOption_GetMouseSensitivityValue");
static_assert(sizeof(LKeyboardMouseOption_GetMouseSensitivityValue) == 0x000004, "Wrong size on LKeyboardMouseOption_GetMouseSensitivityValue");
static_assert(offsetof(LKeyboardMouseOption_GetMouseSensitivityValue, ReturnValue) == 0x000000, "Member 'LKeyboardMouseOption_GetMouseSensitivityValue::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.GetMoveSpeedStep
// 0x0008 (0x0008 - 0x0000)
struct LKeyboardMouseOption_GetMoveSpeedStep final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeyboardMouseOption_GetMoveSpeedStep) == 0x000004, "Wrong alignment on LKeyboardMouseOption_GetMoveSpeedStep");
static_assert(sizeof(LKeyboardMouseOption_GetMoveSpeedStep) == 0x000008, "Wrong size on LKeyboardMouseOption_GetMoveSpeedStep");
static_assert(offsetof(LKeyboardMouseOption_GetMoveSpeedStep, InRotator) == 0x000000, "Member 'LKeyboardMouseOption_GetMoveSpeedStep::InRotator' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_GetMoveSpeedStep, ReturnValue) == 0x000004, "Member 'LKeyboardMouseOption_GetMoveSpeedStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.IsInvertMove
// 0x0002 (0x0002 - 0x0000)
struct LKeyboardMouseOption_IsInvertMove final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeyboardMouseOption_IsInvertMove) == 0x000001, "Wrong alignment on LKeyboardMouseOption_IsInvertMove");
static_assert(sizeof(LKeyboardMouseOption_IsInvertMove) == 0x000002, "Wrong size on LKeyboardMouseOption_IsInvertMove");
static_assert(offsetof(LKeyboardMouseOption_IsInvertMove, InRotator) == 0x000000, "Member 'LKeyboardMouseOption_IsInvertMove::InRotator' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_IsInvertMove, ReturnValue) == 0x000001, "Member 'LKeyboardMouseOption_IsInvertMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.SetInvertMove
// 0x0003 (0x0003 - 0x0000)
struct LKeyboardMouseOption_SetInvertMove final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InInvert;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LKeyboardMouseOption_SetInvertMove) == 0x000001, "Wrong alignment on LKeyboardMouseOption_SetInvertMove");
static_assert(sizeof(LKeyboardMouseOption_SetInvertMove) == 0x000003, "Wrong size on LKeyboardMouseOption_SetInvertMove");
static_assert(offsetof(LKeyboardMouseOption_SetInvertMove, InRotator) == 0x000000, "Member 'LKeyboardMouseOption_SetInvertMove::InRotator' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_SetInvertMove, InInvert) == 0x000001, "Member 'LKeyboardMouseOption_SetInvertMove::InInvert' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_SetInvertMove, ReturnValue) == 0x000002, "Member 'LKeyboardMouseOption_SetInvertMove::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.SetMouseSensitivityStep
// 0x0008 (0x0008 - 0x0000)
struct LKeyboardMouseOption_SetMouseSensitivityStep final
{
public:
	int32                                         InStep;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LKeyboardMouseOption_SetMouseSensitivityStep) == 0x000004, "Wrong alignment on LKeyboardMouseOption_SetMouseSensitivityStep");
static_assert(sizeof(LKeyboardMouseOption_SetMouseSensitivityStep) == 0x000008, "Wrong size on LKeyboardMouseOption_SetMouseSensitivityStep");
static_assert(offsetof(LKeyboardMouseOption_SetMouseSensitivityStep, InStep) == 0x000000, "Member 'LKeyboardMouseOption_SetMouseSensitivityStep::InStep' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_SetMouseSensitivityStep, ReturnValue) == 0x000004, "Member 'LKeyboardMouseOption_SetMouseSensitivityStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LKeyboardMouseOption.SetMoveSpeedStep
// 0x000C (0x000C - 0x0000)
struct LKeyboardMouseOption_SetMoveSpeedStep final
{
public:
	ECameraDirectOption                           InRotator;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InStep;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LKeyboardMouseOption_SetMoveSpeedStep) == 0x000004, "Wrong alignment on LKeyboardMouseOption_SetMoveSpeedStep");
static_assert(sizeof(LKeyboardMouseOption_SetMoveSpeedStep) == 0x00000C, "Wrong size on LKeyboardMouseOption_SetMoveSpeedStep");
static_assert(offsetof(LKeyboardMouseOption_SetMoveSpeedStep, InRotator) == 0x000000, "Member 'LKeyboardMouseOption_SetMoveSpeedStep::InRotator' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_SetMoveSpeedStep, InStep) == 0x000004, "Member 'LKeyboardMouseOption_SetMoveSpeedStep::InStep' has a wrong offset!");
static_assert(offsetof(LKeyboardMouseOption_SetMoveSpeedStep, ReturnValue) == 0x000008, "Member 'LKeyboardMouseOption_SetMoveSpeedStep::ReturnValue' has a wrong offset!");

// Function ProjectP.LFirstGameStartOption.GetAutoSaveAlert
// 0x0001 (0x0001 - 0x0000)
struct LFirstGameStartOption_GetAutoSaveAlert final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFirstGameStartOption_GetAutoSaveAlert) == 0x000001, "Wrong alignment on LFirstGameStartOption_GetAutoSaveAlert");
static_assert(sizeof(LFirstGameStartOption_GetAutoSaveAlert) == 0x000001, "Wrong size on LFirstGameStartOption_GetAutoSaveAlert");
static_assert(offsetof(LFirstGameStartOption_GetAutoSaveAlert, ReturnValue) == 0x000000, "Member 'LFirstGameStartOption_GetAutoSaveAlert::ReturnValue' has a wrong offset!");

// Function ProjectP.LFirstGameStartOption.GetFirstBrightness
// 0x0001 (0x0001 - 0x0000)
struct LFirstGameStartOption_GetFirstBrightness final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFirstGameStartOption_GetFirstBrightness) == 0x000001, "Wrong alignment on LFirstGameStartOption_GetFirstBrightness");
static_assert(sizeof(LFirstGameStartOption_GetFirstBrightness) == 0x000001, "Wrong size on LFirstGameStartOption_GetFirstBrightness");
static_assert(offsetof(LFirstGameStartOption_GetFirstBrightness, ReturnValue) == 0x000000, "Member 'LFirstGameStartOption_GetFirstBrightness::ReturnValue' has a wrong offset!");

// Function ProjectP.LFirstGameStartOption.GetFirstLanguage
// 0x0001 (0x0001 - 0x0000)
struct LFirstGameStartOption_GetFirstLanguage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFirstGameStartOption_GetFirstLanguage) == 0x000001, "Wrong alignment on LFirstGameStartOption_GetFirstLanguage");
static_assert(sizeof(LFirstGameStartOption_GetFirstLanguage) == 0x000001, "Wrong size on LFirstGameStartOption_GetFirstLanguage");
static_assert(offsetof(LFirstGameStartOption_GetFirstLanguage, ReturnValue) == 0x000000, "Member 'LFirstGameStartOption_GetFirstLanguage::ReturnValue' has a wrong offset!");

// Function ProjectP.LFirstGameStartOption.OnClosedWindow
// 0x0008 (0x0008 - 0x0000)
struct LFirstGameStartOption_OnClosedWindow final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LFirstGameStartOption_OnClosedWindow) == 0x000004, "Wrong alignment on LFirstGameStartOption_OnClosedWindow");
static_assert(sizeof(LFirstGameStartOption_OnClosedWindow) == 0x000008, "Wrong size on LFirstGameStartOption_OnClosedWindow");
static_assert(offsetof(LFirstGameStartOption_OnClosedWindow, WidgetTableName) == 0x000000, "Member 'LFirstGameStartOption_OnClosedWindow::WidgetTableName' has a wrong offset!");

// Function ProjectP.LOptionSystem.GetLocationCodeName
// 0x0008 (0x0008 - 0x0000)
struct LOptionSystem_GetLocationCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_GetLocationCodeName) == 0x000004, "Wrong alignment on LOptionSystem_GetLocationCodeName");
static_assert(sizeof(LOptionSystem_GetLocationCodeName) == 0x000008, "Wrong size on LOptionSystem_GetLocationCodeName");
static_assert(offsetof(LOptionSystem_GetLocationCodeName, ReturnValue) == 0x000000, "Member 'LOptionSystem_GetLocationCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystem.GetNewGamePlusRound
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystem_GetNewGamePlusRound final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_GetNewGamePlusRound) == 0x000008, "Wrong alignment on LOptionSystem_GetNewGamePlusRound");
static_assert(sizeof(LOptionSystem_GetNewGamePlusRound) == 0x000010, "Wrong size on LOptionSystem_GetNewGamePlusRound");
static_assert(offsetof(LOptionSystem_GetNewGamePlusRound, ReturnValue) == 0x000000, "Member 'LOptionSystem_GetNewGamePlusRound::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystem.GetPlayerLevel
// 0x0004 (0x0004 - 0x0000)
struct LOptionSystem_GetPlayerLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_GetPlayerLevel) == 0x000004, "Wrong alignment on LOptionSystem_GetPlayerLevel");
static_assert(sizeof(LOptionSystem_GetPlayerLevel) == 0x000004, "Wrong size on LOptionSystem_GetPlayerLevel");
static_assert(offsetof(LOptionSystem_GetPlayerLevel, ReturnValue) == 0x000000, "Member 'LOptionSystem_GetPlayerLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystem.GetPlayTime
// 0x0010 (0x0010 - 0x0000)
struct LOptionSystem_GetPlayTime final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_GetPlayTime) == 0x000008, "Wrong alignment on LOptionSystem_GetPlayTime");
static_assert(sizeof(LOptionSystem_GetPlayTime) == 0x000010, "Wrong size on LOptionSystem_GetPlayTime");
static_assert(offsetof(LOptionSystem_GetPlayTime, ReturnValue) == 0x000000, "Member 'LOptionSystem_GetPlayTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystem.Load
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystem_Load final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_Load) == 0x000001, "Wrong alignment on LOptionSystem_Load");
static_assert(sizeof(LOptionSystem_Load) == 0x000001, "Wrong size on LOptionSystem_Load");
static_assert(offsetof(LOptionSystem_Load, ReturnValue) == 0x000000, "Member 'LOptionSystem_Load::ReturnValue' has a wrong offset!");

// Function ProjectP.LOptionSystem.OnInitLoadOptionGameData
// 0x0020 (0x0020 - 0x0000)
struct LOptionSystem_OnInitLoadOptionGameData final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULSaveGame*                             SaveGame;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_OnInitLoadOptionGameData) == 0x000008, "Wrong alignment on LOptionSystem_OnInitLoadOptionGameData");
static_assert(sizeof(LOptionSystem_OnInitLoadOptionGameData) == 0x000020, "Wrong size on LOptionSystem_OnInitLoadOptionGameData");
static_assert(offsetof(LOptionSystem_OnInitLoadOptionGameData, SlotName) == 0x000000, "Member 'LOptionSystem_OnInitLoadOptionGameData::SlotName' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnInitLoadOptionGameData, bSuccess) == 0x000010, "Member 'LOptionSystem_OnInitLoadOptionGameData::bSuccess' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnInitLoadOptionGameData, GameDataType) == 0x000011, "Member 'LOptionSystem_OnInitLoadOptionGameData::GameDataType' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnInitLoadOptionGameData, SaveGame) == 0x000018, "Member 'LOptionSystem_OnInitLoadOptionGameData::SaveGame' has a wrong offset!");

// Function ProjectP.LOptionSystem.OnLoadOptionGameData
// 0x0020 (0x0020 - 0x0000)
struct LOptionSystem_OnLoadOptionGameData final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULSaveGame*                             SaveGame;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_OnLoadOptionGameData) == 0x000008, "Wrong alignment on LOptionSystem_OnLoadOptionGameData");
static_assert(sizeof(LOptionSystem_OnLoadOptionGameData) == 0x000020, "Wrong size on LOptionSystem_OnLoadOptionGameData");
static_assert(offsetof(LOptionSystem_OnLoadOptionGameData, SlotName) == 0x000000, "Member 'LOptionSystem_OnLoadOptionGameData::SlotName' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnLoadOptionGameData, bSuccess) == 0x000010, "Member 'LOptionSystem_OnLoadOptionGameData::bSuccess' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnLoadOptionGameData, GameDataType) == 0x000011, "Member 'LOptionSystem_OnLoadOptionGameData::GameDataType' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnLoadOptionGameData, SaveGame) == 0x000018, "Member 'LOptionSystem_OnLoadOptionGameData::SaveGame' has a wrong offset!");

// Function ProjectP.LOptionSystem.OnSaveOptionGameData
// 0x0018 (0x0018 - 0x0000)
struct LOptionSystem_OnSaveOptionGameData final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LOptionSystem_OnSaveOptionGameData) == 0x000008, "Wrong alignment on LOptionSystem_OnSaveOptionGameData");
static_assert(sizeof(LOptionSystem_OnSaveOptionGameData) == 0x000018, "Wrong size on LOptionSystem_OnSaveOptionGameData");
static_assert(offsetof(LOptionSystem_OnSaveOptionGameData, SlotName) == 0x000000, "Member 'LOptionSystem_OnSaveOptionGameData::SlotName' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnSaveOptionGameData, bSuccess) == 0x000010, "Member 'LOptionSystem_OnSaveOptionGameData::bSuccess' has a wrong offset!");
static_assert(offsetof(LOptionSystem_OnSaveOptionGameData, GameDataType) == 0x000011, "Member 'LOptionSystem_OnSaveOptionGameData::GameDataType' has a wrong offset!");

// Function ProjectP.LOptionSystem.Save
// 0x0001 (0x0001 - 0x0000)
struct LOptionSystem_Save final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LOptionSystem_Save) == 0x000001, "Wrong alignment on LOptionSystem_Save");
static_assert(sizeof(LOptionSystem_Save) == 0x000001, "Wrong size on LOptionSystem_Save");
static_assert(offsetof(LOptionSystem_Save, ReturnValue) == 0x000000, "Member 'LOptionSystem_Save::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsAnimInstance.ChangeAnimState
// 0x0008 (0x0008 - 0x0000)
struct LPartsAnimInstance_ChangeAnimState final
{
public:
	class FName                                   AnimState_0;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsAnimInstance_ChangeAnimState) == 0x000004, "Wrong alignment on LPartsAnimInstance_ChangeAnimState");
static_assert(sizeof(LPartsAnimInstance_ChangeAnimState) == 0x000008, "Wrong size on LPartsAnimInstance_ChangeAnimState");
static_assert(offsetof(LPartsAnimInstance_ChangeAnimState, AnimState_0) == 0x000000, "Member 'LPartsAnimInstance_ChangeAnimState::AnimState_0' has a wrong offset!");

// Function ProjectP.LPartsComponent.CheckHitJudgmentAngle
// 0x0010 (0x0010 - 0x0000)
struct LPartsComponent_CheckHitJudgmentAngle final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPartsComponent_CheckHitJudgmentAngle) == 0x000008, "Wrong alignment on LPartsComponent_CheckHitJudgmentAngle");
static_assert(sizeof(LPartsComponent_CheckHitJudgmentAngle) == 0x000010, "Wrong size on LPartsComponent_CheckHitJudgmentAngle");
static_assert(offsetof(LPartsComponent_CheckHitJudgmentAngle, Attacker) == 0x000000, "Member 'LPartsComponent_CheckHitJudgmentAngle::Attacker' has a wrong offset!");
static_assert(offsetof(LPartsComponent_CheckHitJudgmentAngle, ReturnValue) == 0x000008, "Member 'LPartsComponent_CheckHitJudgmentAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.CheckRepulseHitLevel
// 0x000C (0x000C - 0x0000)
struct LPartsComponent_CheckRepulseHitLevel final
{
public:
	ELPhysicalDamageType                          InPhysicalDamageType;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InAttackRepulseLevel;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPartsComponent_CheckRepulseHitLevel) == 0x000004, "Wrong alignment on LPartsComponent_CheckRepulseHitLevel");
static_assert(sizeof(LPartsComponent_CheckRepulseHitLevel) == 0x00000C, "Wrong size on LPartsComponent_CheckRepulseHitLevel");
static_assert(offsetof(LPartsComponent_CheckRepulseHitLevel, InPhysicalDamageType) == 0x000000, "Member 'LPartsComponent_CheckRepulseHitLevel::InPhysicalDamageType' has a wrong offset!");
static_assert(offsetof(LPartsComponent_CheckRepulseHitLevel, InAttackRepulseLevel) == 0x000004, "Member 'LPartsComponent_CheckRepulseHitLevel::InAttackRepulseLevel' has a wrong offset!");
static_assert(offsetof(LPartsComponent_CheckRepulseHitLevel, ReturnValue) == 0x000008, "Member 'LPartsComponent_CheckRepulseHitLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.GetNPCPartsInfoByDestruction
// 0x0008 (0x0008 - 0x0000)
struct LPartsComponent_GetNPCPartsInfoByDestruction final
{
public:
	struct FNPCPartsInfoPtr                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_GetNPCPartsInfoByDestruction) == 0x000008, "Wrong alignment on LPartsComponent_GetNPCPartsInfoByDestruction");
static_assert(sizeof(LPartsComponent_GetNPCPartsInfoByDestruction) == 0x000008, "Wrong size on LPartsComponent_GetNPCPartsInfoByDestruction");
static_assert(offsetof(LPartsComponent_GetNPCPartsInfoByDestruction, ReturnValue) == 0x000000, "Member 'LPartsComponent_GetNPCPartsInfoByDestruction::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.GetOwnerCharacter
// 0x0008 (0x0008 - 0x0000)
struct LPartsComponent_GetOwnerCharacter final
{
public:
	class ALCharacter*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_GetOwnerCharacter) == 0x000008, "Wrong alignment on LPartsComponent_GetOwnerCharacter");
static_assert(sizeof(LPartsComponent_GetOwnerCharacter) == 0x000008, "Wrong size on LPartsComponent_GetOwnerCharacter");
static_assert(offsetof(LPartsComponent_GetOwnerCharacter, ReturnValue) == 0x000000, "Member 'LPartsComponent_GetOwnerCharacter::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.ReceiveDamage
// 0x0010 (0x0010 - 0x0000)
struct LPartsComponent_ReceiveDamage final
{
public:
	int32                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamaged;                                          // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestructionIndexDestoryed;                        // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitProcContext*                       HitProcContext;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_ReceiveDamage) == 0x000008, "Wrong alignment on LPartsComponent_ReceiveDamage");
static_assert(sizeof(LPartsComponent_ReceiveDamage) == 0x000010, "Wrong size on LPartsComponent_ReceiveDamage");
static_assert(offsetof(LPartsComponent_ReceiveDamage, Damage) == 0x000000, "Member 'LPartsComponent_ReceiveDamage::Damage' has a wrong offset!");
static_assert(offsetof(LPartsComponent_ReceiveDamage, bDamaged) == 0x000004, "Member 'LPartsComponent_ReceiveDamage::bDamaged' has a wrong offset!");
static_assert(offsetof(LPartsComponent_ReceiveDamage, bDestructionIndexDestoryed) == 0x000005, "Member 'LPartsComponent_ReceiveDamage::bDestructionIndexDestoryed' has a wrong offset!");
static_assert(offsetof(LPartsComponent_ReceiveDamage, HitProcContext) == 0x000008, "Member 'LPartsComponent_ReceiveDamage::HitProcContext' has a wrong offset!");

// Function ProjectP.LPartsComponent.SetLastImpulseDirection
// 0x000C (0x000C - 0x0000)
struct LPartsComponent_SetLastImpulseDirection final
{
public:
	struct FVector                                ImpulseDirection;                                  // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_SetLastImpulseDirection) == 0x000004, "Wrong alignment on LPartsComponent_SetLastImpulseDirection");
static_assert(sizeof(LPartsComponent_SetLastImpulseDirection) == 0x00000C, "Wrong size on LPartsComponent_SetLastImpulseDirection");
static_assert(offsetof(LPartsComponent_SetLastImpulseDirection, ImpulseDirection) == 0x000000, "Member 'LPartsComponent_SetLastImpulseDirection::ImpulseDirection' has a wrong offset!");

// Function ProjectP.LPartsComponent.SetPartsEnabled
// 0x0001 (0x0001 - 0x0000)
struct LPartsComponent_SetPartsEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_SetPartsEnabled) == 0x000001, "Wrong alignment on LPartsComponent_SetPartsEnabled");
static_assert(sizeof(LPartsComponent_SetPartsEnabled) == 0x000001, "Wrong size on LPartsComponent_SetPartsEnabled");
static_assert(offsetof(LPartsComponent_SetPartsEnabled, bEnable) == 0x000000, "Member 'LPartsComponent_SetPartsEnabled::bEnable' has a wrong offset!");

// Function ProjectP.LPartsComponent.GetPartsActor
// 0x0008 (0x0008 - 0x0000)
struct LPartsComponent_GetPartsActor final
{
public:
	class ALPartsActor*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_GetPartsActor) == 0x000008, "Wrong alignment on LPartsComponent_GetPartsActor");
static_assert(sizeof(LPartsComponent_GetPartsActor) == 0x000008, "Wrong size on LPartsComponent_GetPartsActor");
static_assert(offsetof(LPartsComponent_GetPartsActor, ReturnValue) == 0x000000, "Member 'LPartsComponent_GetPartsActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.GetPartsIndex
// 0x0004 (0x0004 - 0x0000)
struct LPartsComponent_GetPartsIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_GetPartsIndex) == 0x000004, "Wrong alignment on LPartsComponent_GetPartsIndex");
static_assert(sizeof(LPartsComponent_GetPartsIndex) == 0x000004, "Wrong size on LPartsComponent_GetPartsIndex");
static_assert(offsetof(LPartsComponent_GetPartsIndex, ReturnValue) == 0x000000, "Member 'LPartsComponent_GetPartsIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.GetPartsSkillCodeNameOnDestory
// 0x0008 (0x0008 - 0x0000)
struct LPartsComponent_GetPartsSkillCodeNameOnDestory final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_GetPartsSkillCodeNameOnDestory) == 0x000004, "Wrong alignment on LPartsComponent_GetPartsSkillCodeNameOnDestory");
static_assert(sizeof(LPartsComponent_GetPartsSkillCodeNameOnDestory) == 0x000008, "Wrong size on LPartsComponent_GetPartsSkillCodeNameOnDestory");
static_assert(offsetof(LPartsComponent_GetPartsSkillCodeNameOnDestory, ReturnValue) == 0x000000, "Member 'LPartsComponent_GetPartsSkillCodeNameOnDestory::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.IsCompleteDestruct
// 0x0001 (0x0001 - 0x0000)
struct LPartsComponent_IsCompleteDestruct final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_IsCompleteDestruct) == 0x000001, "Wrong alignment on LPartsComponent_IsCompleteDestruct");
static_assert(sizeof(LPartsComponent_IsCompleteDestruct) == 0x000001, "Wrong size on LPartsComponent_IsCompleteDestruct");
static_assert(offsetof(LPartsComponent_IsCompleteDestruct, ReturnValue) == 0x000000, "Member 'LPartsComponent_IsCompleteDestruct::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.IsHitEnabled
// 0x0001 (0x0001 - 0x0000)
struct LPartsComponent_IsHitEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_IsHitEnabled) == 0x000001, "Wrong alignment on LPartsComponent_IsHitEnabled");
static_assert(sizeof(LPartsComponent_IsHitEnabled) == 0x000001, "Wrong size on LPartsComponent_IsHitEnabled");
static_assert(offsetof(LPartsComponent_IsHitEnabled, ReturnValue) == 0x000000, "Member 'LPartsComponent_IsHitEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LPartsComponent.IsPartsDamageToOwner
// 0x0001 (0x0001 - 0x0000)
struct LPartsComponent_IsPartsDamageToOwner final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPartsComponent_IsPartsDamageToOwner) == 0x000001, "Wrong alignment on LPartsComponent_IsPartsDamageToOwner");
static_assert(sizeof(LPartsComponent_IsPartsDamageToOwner) == 0x000001, "Wrong size on LPartsComponent_IsPartsDamageToOwner");
static_assert(offsetof(LPartsComponent_IsPartsDamageToOwner, ReturnValue) == 0x000000, "Member 'LPartsComponent_IsPartsDamageToOwner::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.AttachRainHitSound
// 0x0018 (0x0018 - 0x0000)
struct LPCCharacter_AttachRainHitSound final
{
public:
	ELPhysicalSurfaceType                         InPhysicalSurface;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InLocation;                                        // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRainIntensity;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPCHit;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_AttachRainHitSound) == 0x000004, "Wrong alignment on LPCCharacter_AttachRainHitSound");
static_assert(sizeof(LPCCharacter_AttachRainHitSound) == 0x000018, "Wrong size on LPCCharacter_AttachRainHitSound");
static_assert(offsetof(LPCCharacter_AttachRainHitSound, InPhysicalSurface) == 0x000000, "Member 'LPCCharacter_AttachRainHitSound::InPhysicalSurface' has a wrong offset!");
static_assert(offsetof(LPCCharacter_AttachRainHitSound, InLocation) == 0x000004, "Member 'LPCCharacter_AttachRainHitSound::InLocation' has a wrong offset!");
static_assert(offsetof(LPCCharacter_AttachRainHitSound, InRainIntensity) == 0x000010, "Member 'LPCCharacter_AttachRainHitSound::InRainIntensity' has a wrong offset!");
static_assert(offsetof(LPCCharacter_AttachRainHitSound, IsPCHit) == 0x000014, "Member 'LPCCharacter_AttachRainHitSound::IsPCHit' has a wrong offset!");

// Function ProjectP.LPCCharacter.CheckCanResetAllFirstStat
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_CheckCanResetAllFirstStat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_CheckCanResetAllFirstStat) == 0x000001, "Wrong alignment on LPCCharacter_CheckCanResetAllFirstStat");
static_assert(sizeof(LPCCharacter_CheckCanResetAllFirstStat) == 0x000001, "Wrong size on LPCCharacter_CheckCanResetAllFirstStat");
static_assert(offsetof(LPCCharacter_CheckCanResetAllFirstStat, ReturnValue) == 0x000000, "Member 'LPCCharacter_CheckCanResetAllFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.ConsumeFrenzyPoint
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_ConsumeFrenzyPoint final
{
public:
	int32                                         InAmount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFrenzyConsumeReason                         ConsumeReason;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_ConsumeFrenzyPoint) == 0x000004, "Wrong alignment on LPCCharacter_ConsumeFrenzyPoint");
static_assert(sizeof(LPCCharacter_ConsumeFrenzyPoint) == 0x000008, "Wrong size on LPCCharacter_ConsumeFrenzyPoint");
static_assert(offsetof(LPCCharacter_ConsumeFrenzyPoint, InAmount) == 0x000000, "Member 'LPCCharacter_ConsumeFrenzyPoint::InAmount' has a wrong offset!");
static_assert(offsetof(LPCCharacter_ConsumeFrenzyPoint, ConsumeReason) == 0x000004, "Member 'LPCCharacter_ConsumeFrenzyPoint::ConsumeReason' has a wrong offset!");

// Function ProjectP.LPCCharacter.ConsumeSlaveMagazinePoint
// 0x000C (0x000C - 0x0000)
struct LPCCharacter_ConsumeSlaveMagazinePoint final
{
public:
	int32                                         ConsumeAmount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequirementAmount;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_ConsumeSlaveMagazinePoint) == 0x000004, "Wrong alignment on LPCCharacter_ConsumeSlaveMagazinePoint");
static_assert(sizeof(LPCCharacter_ConsumeSlaveMagazinePoint) == 0x00000C, "Wrong size on LPCCharacter_ConsumeSlaveMagazinePoint");
static_assert(offsetof(LPCCharacter_ConsumeSlaveMagazinePoint, ConsumeAmount) == 0x000000, "Member 'LPCCharacter_ConsumeSlaveMagazinePoint::ConsumeAmount' has a wrong offset!");
static_assert(offsetof(LPCCharacter_ConsumeSlaveMagazinePoint, RequirementAmount) == 0x000004, "Member 'LPCCharacter_ConsumeSlaveMagazinePoint::RequirementAmount' has a wrong offset!");
static_assert(offsetof(LPCCharacter_ConsumeSlaveMagazinePoint, ReturnValue) == 0x000008, "Member 'LPCCharacter_ConsumeSlaveMagazinePoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.ConvertFrenzyUnitCountToFrenzyPoint
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint final
{
public:
	int32                                         FrenzyUnitCount;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint) == 0x000004, "Wrong alignment on LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint");
static_assert(sizeof(LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint) == 0x000008, "Wrong size on LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint");
static_assert(offsetof(LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint, FrenzyUnitCount) == 0x000000, "Member 'LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint::FrenzyUnitCount' has a wrong offset!");
static_assert(offsetof(LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint, ReturnValue) == 0x000004, "Member 'LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.Execute_ShowLocationMsg
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_Execute_ShowLocationMsg final
{
public:
	bool                                          Teleport;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_Execute_ShowLocationMsg) == 0x000001, "Wrong alignment on LPCCharacter_Execute_ShowLocationMsg");
static_assert(sizeof(LPCCharacter_Execute_ShowLocationMsg) == 0x000001, "Wrong size on LPCCharacter_Execute_ShowLocationMsg");
static_assert(offsetof(LPCCharacter_Execute_ShowLocationMsg, Teleport) == 0x000000, "Member 'LPCCharacter_Execute_ShowLocationMsg::Teleport' has a wrong offset!");

// Function ProjectP.LPCCharacter.ExecuteAction_Teleport_NewGamePlus
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_ExecuteAction_Teleport_NewGamePlus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_ExecuteAction_Teleport_NewGamePlus) == 0x000001, "Wrong alignment on LPCCharacter_ExecuteAction_Teleport_NewGamePlus");
static_assert(sizeof(LPCCharacter_ExecuteAction_Teleport_NewGamePlus) == 0x000001, "Wrong size on LPCCharacter_ExecuteAction_Teleport_NewGamePlus");
static_assert(offsetof(LPCCharacter_ExecuteAction_Teleport_NewGamePlus, ReturnValue) == 0x000000, "Member 'LPCCharacter_ExecuteAction_Teleport_NewGamePlus::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.ExecuteAction_TeleportStart
// 0x000C (0x000C - 0x0000)
struct LPCCharacter_ExecuteAction_TeleportStart final
{
public:
	class FName                                   TeleportTorsionCoil;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeleportByClock;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_ExecuteAction_TeleportStart) == 0x000004, "Wrong alignment on LPCCharacter_ExecuteAction_TeleportStart");
static_assert(sizeof(LPCCharacter_ExecuteAction_TeleportStart) == 0x00000C, "Wrong size on LPCCharacter_ExecuteAction_TeleportStart");
static_assert(offsetof(LPCCharacter_ExecuteAction_TeleportStart, TeleportTorsionCoil) == 0x000000, "Member 'LPCCharacter_ExecuteAction_TeleportStart::TeleportTorsionCoil' has a wrong offset!");
static_assert(offsetof(LPCCharacter_ExecuteAction_TeleportStart, IsTeleportByClock) == 0x000008, "Member 'LPCCharacter_ExecuteAction_TeleportStart::IsTeleportByClock' has a wrong offset!");

// Function ProjectP.LPCCharacter.GainFrenzyPoint
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_GainFrenzyPoint final
{
public:
	int32                                         InAmount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GainFrenzyPoint) == 0x000004, "Wrong alignment on LPCCharacter_GainFrenzyPoint");
static_assert(sizeof(LPCCharacter_GainFrenzyPoint) == 0x000004, "Wrong size on LPCCharacter_GainFrenzyPoint");
static_assert(offsetof(LPCCharacter_GainFrenzyPoint, InAmount) == 0x000000, "Member 'LPCCharacter_GainFrenzyPoint::InAmount' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetCurrentFrenzyUnitCount
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_GetCurrentFrenzyUnitCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetCurrentFrenzyUnitCount) == 0x000004, "Wrong alignment on LPCCharacter_GetCurrentFrenzyUnitCount");
static_assert(sizeof(LPCCharacter_GetCurrentFrenzyUnitCount) == 0x000004, "Wrong size on LPCCharacter_GetCurrentFrenzyUnitCount");
static_assert(offsetof(LPCCharacter_GetCurrentFrenzyUnitCount, ReturnValue) == 0x000000, "Member 'LPCCharacter_GetCurrentFrenzyUnitCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetDefaultStatComponent
// 0x0010 (0x0010 - 0x0000)
struct LPCCharacter_GetDefaultStatComponent final
{
public:
	class FName                                   DefalutStatName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULStatComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetDefaultStatComponent) == 0x000008, "Wrong alignment on LPCCharacter_GetDefaultStatComponent");
static_assert(sizeof(LPCCharacter_GetDefaultStatComponent) == 0x000010, "Wrong size on LPCCharacter_GetDefaultStatComponent");
static_assert(offsetof(LPCCharacter_GetDefaultStatComponent, DefalutStatName) == 0x000000, "Member 'LPCCharacter_GetDefaultStatComponent::DefalutStatName' has a wrong offset!");
static_assert(offsetof(LPCCharacter_GetDefaultStatComponent, ReturnValue) == 0x000008, "Member 'LPCCharacter_GetDefaultStatComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetWeightPenalty
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_GetWeightPenalty final
{
public:
	struct FWeightPenaltyInfoPtr                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetWeightPenalty) == 0x000008, "Wrong alignment on LPCCharacter_GetWeightPenalty");
static_assert(sizeof(LPCCharacter_GetWeightPenalty) == 0x000008, "Wrong size on LPCCharacter_GetWeightPenalty");
static_assert(offsetof(LPCCharacter_GetWeightPenalty, ReturnValue) == 0x000000, "Member 'LPCCharacter_GetWeightPenalty::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetWeightPenaltyInGivenMaxWeight
// 0x0010 (0x0010 - 0x0000)
struct LPCCharacter_GetWeightPenaltyInGivenMaxWeight final
{
public:
	int32                                         InMaxWeight;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeightPenaltyInfoPtr                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetWeightPenaltyInGivenMaxWeight) == 0x000008, "Wrong alignment on LPCCharacter_GetWeightPenaltyInGivenMaxWeight");
static_assert(sizeof(LPCCharacter_GetWeightPenaltyInGivenMaxWeight) == 0x000010, "Wrong size on LPCCharacter_GetWeightPenaltyInGivenMaxWeight");
static_assert(offsetof(LPCCharacter_GetWeightPenaltyInGivenMaxWeight, InMaxWeight) == 0x000000, "Member 'LPCCharacter_GetWeightPenaltyInGivenMaxWeight::InMaxWeight' has a wrong offset!");
static_assert(offsetof(LPCCharacter_GetWeightPenaltyInGivenMaxWeight, ReturnValue) == 0x000008, "Member 'LPCCharacter_GetWeightPenaltyInGivenMaxWeight::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.IsEyeColorChanged
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_IsEyeColorChanged final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_IsEyeColorChanged) == 0x000001, "Wrong alignment on LPCCharacter_IsEyeColorChanged");
static_assert(sizeof(LPCCharacter_IsEyeColorChanged) == 0x000001, "Wrong size on LPCCharacter_IsEyeColorChanged");
static_assert(offsetof(LPCCharacter_IsEyeColorChanged, ReturnValue) == 0x000000, "Member 'LPCCharacter_IsEyeColorChanged::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.IsFrenzyActivated
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_IsFrenzyActivated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_IsFrenzyActivated) == 0x000001, "Wrong alignment on LPCCharacter_IsFrenzyActivated");
static_assert(sizeof(LPCCharacter_IsFrenzyActivated) == 0x000001, "Wrong size on LPCCharacter_IsFrenzyActivated");
static_assert(offsetof(LPCCharacter_IsFrenzyActivated, ReturnValue) == 0x000000, "Member 'LPCCharacter_IsFrenzyActivated::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.IsStaminaChangeStatus
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_IsStaminaChangeStatus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_IsStaminaChangeStatus) == 0x000001, "Wrong alignment on LPCCharacter_IsStaminaChangeStatus");
static_assert(sizeof(LPCCharacter_IsStaminaChangeStatus) == 0x000001, "Wrong size on LPCCharacter_IsStaminaChangeStatus");
static_assert(offsetof(LPCCharacter_IsStaminaChangeStatus, ReturnValue) == 0x000000, "Member 'LPCCharacter_IsStaminaChangeStatus::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnAlertLamp
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_OnAlertLamp final
{
public:
	float                                         DurationTime;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnAlertLamp) == 0x000004, "Wrong alignment on LPCCharacter_OnAlertLamp");
static_assert(sizeof(LPCCharacter_OnAlertLamp) == 0x000004, "Wrong size on LPCCharacter_OnAlertLamp");
static_assert(offsetof(LPCCharacter_OnAlertLamp, DurationTime) == 0x000000, "Member 'LPCCharacter_OnAlertLamp::DurationTime' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnBackToHotelTorsionCoil
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_OnBackToHotelTorsionCoil final
{
public:
	bool                                          UseItem;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnBackToHotelTorsionCoil) == 0x000001, "Wrong alignment on LPCCharacter_OnBackToHotelTorsionCoil");
static_assert(sizeof(LPCCharacter_OnBackToHotelTorsionCoil) == 0x000001, "Wrong size on LPCCharacter_OnBackToHotelTorsionCoil");
static_assert(offsetof(LPCCharacter_OnBackToHotelTorsionCoil, UseItem) == 0x000000, "Member 'LPCCharacter_OnBackToHotelTorsionCoil::UseItem' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnBackToLatestTorsionCoil
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_OnBackToLatestTorsionCoil final
{
public:
	bool                                          UseItem;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnBackToLatestTorsionCoil) == 0x000001, "Wrong alignment on LPCCharacter_OnBackToLatestTorsionCoil");
static_assert(sizeof(LPCCharacter_OnBackToLatestTorsionCoil) == 0x000001, "Wrong size on LPCCharacter_OnBackToLatestTorsionCoil");
static_assert(offsetof(LPCCharacter_OnBackToLatestTorsionCoil, UseItem) == 0x000000, "Member 'LPCCharacter_OnBackToLatestTorsionCoil::UseItem' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnClosedLevelUpOrPOrgan
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_OnClosedLevelUpOrPOrgan final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnClosedLevelUpOrPOrgan) == 0x000004, "Wrong alignment on LPCCharacter_OnClosedLevelUpOrPOrgan");
static_assert(sizeof(LPCCharacter_OnClosedLevelUpOrPOrgan) == 0x000008, "Wrong size on LPCCharacter_OnClosedLevelUpOrPOrgan");
static_assert(offsetof(LPCCharacter_OnClosedLevelUpOrPOrgan, WidgetTableName) == 0x000000, "Member 'LPCCharacter_OnClosedLevelUpOrPOrgan::WidgetTableName' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnFrenzyModeMV
// 0x0002 (0x0002 - 0x0000)
struct LPCCharacter_OnFrenzyModeMV final
{
public:
	bool                                          bFrenzyMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstant;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnFrenzyModeMV) == 0x000001, "Wrong alignment on LPCCharacter_OnFrenzyModeMV");
static_assert(sizeof(LPCCharacter_OnFrenzyModeMV) == 0x000002, "Wrong size on LPCCharacter_OnFrenzyModeMV");
static_assert(offsetof(LPCCharacter_OnFrenzyModeMV, bFrenzyMode) == 0x000000, "Member 'LPCCharacter_OnFrenzyModeMV::bFrenzyMode' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnFrenzyModeMV, bInstant) == 0x000001, "Member 'LPCCharacter_OnFrenzyModeMV::bInstant' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnGainExp
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_OnGainExp final
{
public:
	int32                                         InExp;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnGainExp) == 0x000004, "Wrong alignment on LPCCharacter_OnGainExp");
static_assert(sizeof(LPCCharacter_OnGainExp) == 0x000004, "Wrong size on LPCCharacter_OnGainExp");
static_assert(offsetof(LPCCharacter_OnGainExp, InExp) == 0x000000, "Member 'LPCCharacter_OnGainExp::InExp' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnGainHumanity
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_OnGainHumanity final
{
public:
	int32                                         InHumanity;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnGainHumanity) == 0x000004, "Wrong alignment on LPCCharacter_OnGainHumanity");
static_assert(sizeof(LPCCharacter_OnGainHumanity) == 0x000004, "Wrong size on LPCCharacter_OnGainHumanity");
static_assert(offsetof(LPCCharacter_OnGainHumanity, InHumanity) == 0x000000, "Member 'LPCCharacter_OnGainHumanity::InHumanity' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnGainItem
// 0x000C (0x000C - 0x0000)
struct LPCCharacter_OnGainItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnGainItem) == 0x000004, "Wrong alignment on LPCCharacter_OnGainItem");
static_assert(sizeof(LPCCharacter_OnGainItem) == 0x00000C, "Wrong size on LPCCharacter_OnGainItem");
static_assert(offsetof(LPCCharacter_OnGainItem, ItemId) == 0x000000, "Member 'LPCCharacter_OnGainItem::ItemId' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnGainItem, ItemCount) == 0x000008, "Member 'LPCCharacter_OnGainItem::ItemCount' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnGainWeapon
// 0x0010 (0x0010 - 0x0000)
struct LPCCharacter_OnGainWeapon final
{
public:
	class FName                                   Handle;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Blade;                                             // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnGainWeapon) == 0x000004, "Wrong alignment on LPCCharacter_OnGainWeapon");
static_assert(sizeof(LPCCharacter_OnGainWeapon) == 0x000010, "Wrong size on LPCCharacter_OnGainWeapon");
static_assert(offsetof(LPCCharacter_OnGainWeapon, Handle) == 0x000000, "Member 'LPCCharacter_OnGainWeapon::Handle' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnGainWeapon, Blade) == 0x000008, "Member 'LPCCharacter_OnGainWeapon::Blade' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LPCCharacter_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LPCCharacter_OnGameDataCharacterSync");
static_assert(sizeof(LPCCharacter_OnGameDataCharacterSync) == 0x000010, "Wrong size on LPCCharacter_OnGameDataCharacterSync");
static_assert(offsetof(LPCCharacter_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LPCCharacter_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LPCCharacter_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnInitMainUI
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_OnInitMainUI final
{
public:
	class FName                                   MainStateName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnInitMainUI) == 0x000004, "Wrong alignment on LPCCharacter_OnInitMainUI");
static_assert(sizeof(LPCCharacter_OnInitMainUI) == 0x000008, "Wrong size on LPCCharacter_OnInitMainUI");
static_assert(offsetof(LPCCharacter_OnInitMainUI, MainStateName) == 0x000000, "Member 'LPCCharacter_OnInitMainUI::MainStateName' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnMustBeEqualStatsKeepSamed
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_OnMustBeEqualStatsKeepSamed final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnMustBeEqualStatsKeepSamed) == 0x000001, "Wrong alignment on LPCCharacter_OnMustBeEqualStatsKeepSamed");
static_assert(sizeof(LPCCharacter_OnMustBeEqualStatsKeepSamed) == 0x000001, "Wrong size on LPCCharacter_OnMustBeEqualStatsKeepSamed");
static_assert(offsetof(LPCCharacter_OnMustBeEqualStatsKeepSamed, StatType) == 0x000000, "Member 'LPCCharacter_OnMustBeEqualStatsKeepSamed::StatType' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnUIConfirmTeleport
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_OnUIConfirmTeleport final
{
public:
	class FName                                   TeleportTorsionCoil;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_OnUIConfirmTeleport) == 0x000004, "Wrong alignment on LPCCharacter_OnUIConfirmTeleport");
static_assert(sizeof(LPCCharacter_OnUIConfirmTeleport) == 0x000008, "Wrong size on LPCCharacter_OnUIConfirmTeleport");
static_assert(offsetof(LPCCharacter_OnUIConfirmTeleport, TeleportTorsionCoil) == 0x000000, "Member 'LPCCharacter_OnUIConfirmTeleport::TeleportTorsionCoil' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnUseItemBP
// 0x000C (0x000C - 0x0000)
struct LPCCharacter_OnUseItemBP final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOn;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_OnUseItemBP) == 0x000004, "Wrong alignment on LPCCharacter_OnUseItemBP");
static_assert(sizeof(LPCCharacter_OnUseItemBP) == 0x00000C, "Wrong size on LPCCharacter_OnUseItemBP");
static_assert(offsetof(LPCCharacter_OnUseItemBP, ItemId) == 0x000000, "Member 'LPCCharacter_OnUseItemBP::ItemId' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnUseItemBP, IsOn) == 0x000008, "Member 'LPCCharacter_OnUseItemBP::IsOn' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnWatchActionStateAfterRemove
// 0x0018 (0x0018 - 0x0000)
struct LPCCharacter_OnWatchActionStateAfterRemove final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_OnWatchActionStateAfterRemove) == 0x000008, "Wrong alignment on LPCCharacter_OnWatchActionStateAfterRemove");
static_assert(sizeof(LPCCharacter_OnWatchActionStateAfterRemove) == 0x000018, "Wrong size on LPCCharacter_OnWatchActionStateAfterRemove");
static_assert(offsetof(LPCCharacter_OnWatchActionStateAfterRemove, InActMgrComponent) == 0x000000, "Member 'LPCCharacter_OnWatchActionStateAfterRemove::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnWatchActionStateAfterRemove, ActionState) == 0x000008, "Member 'LPCCharacter_OnWatchActionStateAfterRemove::ActionState' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnWatchActionStateAfterRemove, IsPair) == 0x000010, "Member 'LPCCharacter_OnWatchActionStateAfterRemove::IsPair' has a wrong offset!");

// Function ProjectP.LPCCharacter.OnWatchActionStateBeforeAdd
// 0x0018 (0x0018 - 0x0000)
struct LPCCharacter_OnWatchActionStateBeforeAdd final
{
public:
	class ULActMgrComponent*                      InActMgrComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_OnWatchActionStateBeforeAdd) == 0x000008, "Wrong alignment on LPCCharacter_OnWatchActionStateBeforeAdd");
static_assert(sizeof(LPCCharacter_OnWatchActionStateBeforeAdd) == 0x000018, "Wrong size on LPCCharacter_OnWatchActionStateBeforeAdd");
static_assert(offsetof(LPCCharacter_OnWatchActionStateBeforeAdd, InActMgrComponent) == 0x000000, "Member 'LPCCharacter_OnWatchActionStateBeforeAdd::InActMgrComponent' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnWatchActionStateBeforeAdd, ActionState) == 0x000008, "Member 'LPCCharacter_OnWatchActionStateBeforeAdd::ActionState' has a wrong offset!");
static_assert(offsetof(LPCCharacter_OnWatchActionStateBeforeAdd, IsPair) == 0x000010, "Member 'LPCCharacter_OnWatchActionStateBeforeAdd::IsPair' has a wrong offset!");

// Function ProjectP.LPCCharacter.RequestResetAllFirstStat
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_RequestResetAllFirstStat final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_RequestResetAllFirstStat) == 0x000001, "Wrong alignment on LPCCharacter_RequestResetAllFirstStat");
static_assert(sizeof(LPCCharacter_RequestResetAllFirstStat) == 0x000001, "Wrong size on LPCCharacter_RequestResetAllFirstStat");
static_assert(offsetof(LPCCharacter_RequestResetAllFirstStat, ReturnValue) == 0x000000, "Member 'LPCCharacter_RequestResetAllFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.SelectDefaultStat
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_SelectDefaultStat final
{
public:
	class FName                                   DefaultStatCodeName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_SelectDefaultStat) == 0x000004, "Wrong alignment on LPCCharacter_SelectDefaultStat");
static_assert(sizeof(LPCCharacter_SelectDefaultStat) == 0x000008, "Wrong size on LPCCharacter_SelectDefaultStat");
static_assert(offsetof(LPCCharacter_SelectDefaultStat, DefaultStatCodeName) == 0x000000, "Member 'LPCCharacter_SelectDefaultStat::DefaultStatCodeName' has a wrong offset!");

// Function ProjectP.LPCCharacter.UIActiveLevelUpWidget
// 0x0002 (0x0002 - 0x0000)
struct LPCCharacter_UIActiveLevelUpWidget final
{
public:
	bool                                          IsActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsResetLevelUp;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_UIActiveLevelUpWidget) == 0x000001, "Wrong alignment on LPCCharacter_UIActiveLevelUpWidget");
static_assert(sizeof(LPCCharacter_UIActiveLevelUpWidget) == 0x000002, "Wrong size on LPCCharacter_UIActiveLevelUpWidget");
static_assert(offsetof(LPCCharacter_UIActiveLevelUpWidget, IsActive) == 0x000000, "Member 'LPCCharacter_UIActiveLevelUpWidget::IsActive' has a wrong offset!");
static_assert(offsetof(LPCCharacter_UIActiveLevelUpWidget, IsResetLevelUp) == 0x000001, "Member 'LPCCharacter_UIActiveLevelUpWidget::IsResetLevelUp' has a wrong offset!");

// Function ProjectP.LPCCharacter.CheckCanChangeFirstStat
// 0x0010 (0x0010 - 0x0000)
struct LPCCharacter_CheckCanChangeFirstStat final
{
public:
	ELFirstStat                                   FirstStat;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeData;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutErrorCode;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPCCharacter_CheckCanChangeFirstStat) == 0x000004, "Wrong alignment on LPCCharacter_CheckCanChangeFirstStat");
static_assert(sizeof(LPCCharacter_CheckCanChangeFirstStat) == 0x000010, "Wrong size on LPCCharacter_CheckCanChangeFirstStat");
static_assert(offsetof(LPCCharacter_CheckCanChangeFirstStat, FirstStat) == 0x000000, "Member 'LPCCharacter_CheckCanChangeFirstStat::FirstStat' has a wrong offset!");
static_assert(offsetof(LPCCharacter_CheckCanChangeFirstStat, ChangeData) == 0x000004, "Member 'LPCCharacter_CheckCanChangeFirstStat::ChangeData' has a wrong offset!");
static_assert(offsetof(LPCCharacter_CheckCanChangeFirstStat, OutErrorCode) == 0x000008, "Member 'LPCCharacter_CheckCanChangeFirstStat::OutErrorCode' has a wrong offset!");
static_assert(offsetof(LPCCharacter_CheckCanChangeFirstStat, ReturnValue) == 0x00000C, "Member 'LPCCharacter_CheckCanChangeFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetCurrentWeaponName
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_GetCurrentWeaponName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetCurrentWeaponName) == 0x000004, "Wrong alignment on LPCCharacter_GetCurrentWeaponName");
static_assert(sizeof(LPCCharacter_GetCurrentWeaponName) == 0x000008, "Wrong size on LPCCharacter_GetCurrentWeaponName");
static_assert(offsetof(LPCCharacter_GetCurrentWeaponName, ReturnValue) == 0x000000, "Member 'LPCCharacter_GetCurrentWeaponName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetFirstStat
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_GetFirstStat final
{
public:
	ELFirstStatDataType                           DataType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFirstStat                                   StatType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetFirstStat) == 0x000004, "Wrong alignment on LPCCharacter_GetFirstStat");
static_assert(sizeof(LPCCharacter_GetFirstStat) == 0x000008, "Wrong size on LPCCharacter_GetFirstStat");
static_assert(offsetof(LPCCharacter_GetFirstStat, DataType) == 0x000000, "Member 'LPCCharacter_GetFirstStat::DataType' has a wrong offset!");
static_assert(offsetof(LPCCharacter_GetFirstStat, StatType) == 0x000001, "Member 'LPCCharacter_GetFirstStat::StatType' has a wrong offset!");
static_assert(offsetof(LPCCharacter_GetFirstStat, ReturnValue) == 0x000004, "Member 'LPCCharacter_GetFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetLampMesh
// 0x0008 (0x0008 - 0x0000)
struct LPCCharacter_GetLampMesh final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetLampMesh) == 0x000008, "Wrong alignment on LPCCharacter_GetLampMesh");
static_assert(sizeof(LPCCharacter_GetLampMesh) == 0x000008, "Wrong size on LPCCharacter_GetLampMesh");
static_assert(offsetof(LPCCharacter_GetLampMesh, ReturnValue) == 0x000000, "Member 'LPCCharacter_GetLampMesh::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetMaxWeaponCount
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_GetMaxWeaponCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetMaxWeaponCount) == 0x000004, "Wrong alignment on LPCCharacter_GetMaxWeaponCount");
static_assert(sizeof(LPCCharacter_GetMaxWeaponCount) == 0x000004, "Wrong size on LPCCharacter_GetMaxWeaponCount");
static_assert(offsetof(LPCCharacter_GetMaxWeaponCount, ReturnValue) == 0x000000, "Member 'LPCCharacter_GetMaxWeaponCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.GetWeaponIndex
// 0x0004 (0x0004 - 0x0000)
struct LPCCharacter_GetWeaponIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_GetWeaponIndex) == 0x000004, "Wrong alignment on LPCCharacter_GetWeaponIndex");
static_assert(sizeof(LPCCharacter_GetWeaponIndex) == 0x000004, "Wrong size on LPCCharacter_GetWeaponIndex");
static_assert(offsetof(LPCCharacter_GetWeaponIndex, ReturnValue) == 0x000000, "Member 'LPCCharacter_GetWeaponIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LPCCharacter.IsProtectErgoDrop
// 0x0001 (0x0001 - 0x0000)
struct LPCCharacter_IsProtectErgoDrop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPCCharacter_IsProtectErgoDrop) == 0x000001, "Wrong alignment on LPCCharacter_IsProtectErgoDrop");
static_assert(sizeof(LPCCharacter_IsProtectErgoDrop) == 0x000001, "Wrong size on LPCCharacter_IsProtectErgoDrop");
static_assert(offsetof(LPCCharacter_IsProtectErgoDrop, ReturnValue) == 0x000000, "Member 'LPCCharacter_IsProtectErgoDrop::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.GetUseRagdollSleepAndWake
// 0x0001 (0x0001 - 0x0000)
struct LPhysicalAnimationComponent_GetUseRagdollSleepAndWake final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_GetUseRagdollSleepAndWake) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_GetUseRagdollSleepAndWake");
static_assert(sizeof(LPhysicalAnimationComponent_GetUseRagdollSleepAndWake) == 0x000001, "Wrong size on LPhysicalAnimationComponent_GetUseRagdollSleepAndWake");
static_assert(offsetof(LPhysicalAnimationComponent_GetUseRagdollSleepAndWake, ReturnValue) == 0x000000, "Member 'LPhysicalAnimationComponent_GetUseRagdollSleepAndWake::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ChangePhysicsAssetBP
// 0x000C (0x000C - 0x0000)
struct LPhysicalAnimationComponent_ChangePhysicsAssetBP final
{
public:
	struct FLPhysicsInfo_PhysicsAsset             PhysicsInfo;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_ChangePhysicsAssetBP) == 0x000004, "Wrong alignment on LPhysicalAnimationComponent_ChangePhysicsAssetBP");
static_assert(sizeof(LPhysicalAnimationComponent_ChangePhysicsAssetBP) == 0x00000C, "Wrong size on LPhysicalAnimationComponent_ChangePhysicsAssetBP");
static_assert(offsetof(LPhysicalAnimationComponent_ChangePhysicsAssetBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ChangePhysicsAssetBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangePhysicsAssetBP, Branches) == 0x000008, "Member 'LPhysicalAnimationComponent_ChangePhysicsAssetBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangePhysicsAssetBP, ReturnValue) == 0x000009, "Member 'LPhysicalAnimationComponent_ChangePhysicsAssetBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ChangeToExplosionBP
// 0x0208 (0x0208 - 0x0000)
struct LPhysicalAnimationComponent_ChangeToExplosionBP final
{
public:
	struct FLPhysicsInfo_Explosion                PhysicsInfo;                                       // 0x0000(0x0200)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0200(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0201(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_ChangeToExplosionBP) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_ChangeToExplosionBP");
static_assert(sizeof(LPhysicalAnimationComponent_ChangeToExplosionBP) == 0x000208, "Wrong size on LPhysicalAnimationComponent_ChangeToExplosionBP");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToExplosionBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ChangeToExplosionBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToExplosionBP, Branches) == 0x000200, "Member 'LPhysicalAnimationComponent_ChangeToExplosionBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToExplosionBP, ReturnValue) == 0x000201, "Member 'LPhysicalAnimationComponent_ChangeToExplosionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ChangeToNoPhysicsBP
// 0x0003 (0x0003 - 0x0000)
struct LPhysicalAnimationComponent_ChangeToNoPhysicsBP final
{
public:
	struct FLPhysicsInfo_NoPhysics                PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ChangeToNoPhysicsBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ChangeToNoPhysicsBP");
static_assert(sizeof(LPhysicalAnimationComponent_ChangeToNoPhysicsBP) == 0x000003, "Wrong size on LPhysicalAnimationComponent_ChangeToNoPhysicsBP");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToNoPhysicsBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ChangeToNoPhysicsBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToNoPhysicsBP, Branches) == 0x000001, "Member 'LPhysicalAnimationComponent_ChangeToNoPhysicsBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToNoPhysicsBP, ReturnValue) == 0x000002, "Member 'LPhysicalAnimationComponent_ChangeToNoPhysicsBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ChangeToPhysicalAnimationBP
// 0x0003 (0x0003 - 0x0000)
struct LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP final
{
public:
	struct FLPhysicsInfo_PhysicalAnimation        PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP");
static_assert(sizeof(LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP) == 0x000003, "Wrong size on LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP, Branches) == 0x000001, "Member 'LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP, ReturnValue) == 0x000002, "Member 'LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ChangeToRagdollBP
// 0x0003 (0x0003 - 0x0000)
struct LPhysicalAnimationComponent_ChangeToRagdollBP final
{
public:
	struct FLPhysicsInfo_RagDoll                  PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ChangeToRagdollBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ChangeToRagdollBP");
static_assert(sizeof(LPhysicalAnimationComponent_ChangeToRagdollBP) == 0x000003, "Wrong size on LPhysicalAnimationComponent_ChangeToRagdollBP");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToRagdollBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ChangeToRagdollBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToRagdollBP, Branches) == 0x000001, "Member 'LPhysicalAnimationComponent_ChangeToRagdollBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToRagdollBP, ReturnValue) == 0x000002, "Member 'LPhysicalAnimationComponent_ChangeToRagdollBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ChangeToRagdollFreezeBP
// 0x0002 (0x0002 - 0x0000)
struct LPhysicalAnimationComponent_ChangeToRagdollFreezeBP final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ChangeToRagdollFreezeBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ChangeToRagdollFreezeBP");
static_assert(sizeof(LPhysicalAnimationComponent_ChangeToRagdollFreezeBP) == 0x000002, "Wrong size on LPhysicalAnimationComponent_ChangeToRagdollFreezeBP");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToRagdollFreezeBP, Branches) == 0x000000, "Member 'LPhysicalAnimationComponent_ChangeToRagdollFreezeBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ChangeToRagdollFreezeBP, ReturnValue) == 0x000001, "Member 'LPhysicalAnimationComponent_ChangeToRagdollFreezeBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.GetSkeletalMeshComponentBP
// 0x0010 (0x0010 - 0x0000)
struct LPhysicalAnimationComponent_GetSkeletalMeshComponentBP final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_GetSkeletalMeshComponentBP) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_GetSkeletalMeshComponentBP");
static_assert(sizeof(LPhysicalAnimationComponent_GetSkeletalMeshComponentBP) == 0x000010, "Wrong size on LPhysicalAnimationComponent_GetSkeletalMeshComponentBP");
static_assert(offsetof(LPhysicalAnimationComponent_GetSkeletalMeshComponentBP, Branches) == 0x000000, "Member 'LPhysicalAnimationComponent_GetSkeletalMeshComponentBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_GetSkeletalMeshComponentBP, ReturnValue) == 0x000008, "Member 'LPhysicalAnimationComponent_GetSkeletalMeshComponentBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.MakeExplosionInfo
// 0x0360 (0x0360 - 0x0000)
struct LPhysicalAnimationComponent_MakeExplosionInfo final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Murderer;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0010(0x0150)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLPhysicsInfo_Explosion                ReturnValue;                                       // 0x0160(0x0200)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_MakeExplosionInfo) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_MakeExplosionInfo");
static_assert(sizeof(LPhysicalAnimationComponent_MakeExplosionInfo) == 0x000360, "Wrong size on LPhysicalAnimationComponent_MakeExplosionInfo");
static_assert(offsetof(LPhysicalAnimationComponent_MakeExplosionInfo, TargetActor) == 0x000000, "Member 'LPhysicalAnimationComponent_MakeExplosionInfo::TargetActor' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_MakeExplosionInfo, Murderer) == 0x000008, "Member 'LPhysicalAnimationComponent_MakeExplosionInfo::Murderer' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_MakeExplosionInfo, HitInfo) == 0x000010, "Member 'LPhysicalAnimationComponent_MakeExplosionInfo::HitInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_MakeExplosionInfo, ReturnValue) == 0x000160, "Member 'LPhysicalAnimationComponent_MakeExplosionInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnChangePhysicsAssetBP
// 0x000C (0x000C - 0x0000)
struct LPhysicalAnimationComponent_OnChangePhysicsAssetBP final
{
public:
	struct FLPhysicsInfo_PhysicsAsset             PhysicsInfo;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_OnChangePhysicsAssetBP) == 0x000004, "Wrong alignment on LPhysicalAnimationComponent_OnChangePhysicsAssetBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnChangePhysicsAssetBP) == 0x00000C, "Wrong size on LPhysicalAnimationComponent_OnChangePhysicsAssetBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangePhysicsAssetBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_OnChangePhysicsAssetBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangePhysicsAssetBP, ReturnValue) == 0x000008, "Member 'LPhysicalAnimationComponent_OnChangePhysicsAssetBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnChangeToExplosionBP
// 0x0208 (0x0208 - 0x0000)
struct LPhysicalAnimationComponent_OnChangeToExplosionBP final
{
public:
	struct FLPhysicsInfo_Explosion                PhysicsInfo;                                       // 0x0000(0x0200)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0200(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_OnChangeToExplosionBP) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_OnChangeToExplosionBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnChangeToExplosionBP) == 0x000208, "Wrong size on LPhysicalAnimationComponent_OnChangeToExplosionBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToExplosionBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_OnChangeToExplosionBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToExplosionBP, ReturnValue) == 0x000200, "Member 'LPhysicalAnimationComponent_OnChangeToExplosionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnChangeToNoPhysicsBP
// 0x0002 (0x0002 - 0x0000)
struct LPhysicalAnimationComponent_OnChangeToNoPhysicsBP final
{
public:
	struct FLPhysicsInfo_NoPhysics                PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_OnChangeToNoPhysicsBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_OnChangeToNoPhysicsBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnChangeToNoPhysicsBP) == 0x000002, "Wrong size on LPhysicalAnimationComponent_OnChangeToNoPhysicsBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToNoPhysicsBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_OnChangeToNoPhysicsBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToNoPhysicsBP, ReturnValue) == 0x000001, "Member 'LPhysicalAnimationComponent_OnChangeToNoPhysicsBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnChangeToPhysicalAnimationBP
// 0x0002 (0x0002 - 0x0000)
struct LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP final
{
public:
	struct FLPhysicsInfo_PhysicalAnimation        PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP) == 0x000002, "Wrong size on LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP, ReturnValue) == 0x000001, "Member 'LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnChangeToRagdollBP
// 0x0002 (0x0002 - 0x0000)
struct LPhysicalAnimationComponent_OnChangeToRagdollBP final
{
public:
	struct FLPhysicsInfo_RagDoll                  PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_OnChangeToRagdollBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_OnChangeToRagdollBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnChangeToRagdollBP) == 0x000002, "Wrong size on LPhysicalAnimationComponent_OnChangeToRagdollBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToRagdollBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_OnChangeToRagdollBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToRagdollBP, ReturnValue) == 0x000001, "Member 'LPhysicalAnimationComponent_OnChangeToRagdollBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnChangeToRagdollFreezeBP
// 0x0001 (0x0001 - 0x0000)
struct LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP) == 0x000001, "Wrong size on LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP, ReturnValue) == 0x000000, "Member 'LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.OnResetBP
// 0x0008 (0x0008 - 0x0000)
struct LPhysicalAnimationComponent_OnResetBP final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_OnResetBP) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_OnResetBP");
static_assert(sizeof(LPhysicalAnimationComponent_OnResetBP) == 0x000008, "Wrong size on LPhysicalAnimationComponent_OnResetBP");
static_assert(offsetof(LPhysicalAnimationComponent_OnResetBP, InSkeletalMeshComponent) == 0x000000, "Member 'LPhysicalAnimationComponent_OnResetBP::InSkeletalMeshComponent' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveChangePhysicsAssetBP
// 0x000C (0x000C - 0x0000)
struct LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP final
{
public:
	struct FLPhysicsInfo_PhysicsAsset             PhysicsInfo;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP) == 0x000004, "Wrong alignment on LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP) == 0x00000C, "Wrong size on LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP, Branches) == 0x000008, "Member 'LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP, ReturnValue) == 0x000009, "Member 'LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToExplosionBP
// 0x0208 (0x0208 - 0x0000)
struct LPhysicalAnimationComponent_ReserveChangeToExplosionBP final
{
public:
	struct FLPhysicsInfo_Explosion                PhysicsInfo;                                       // 0x0000(0x0200)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0200(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0201(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x6];                                      // 0x0202(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveChangeToExplosionBP) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_ReserveChangeToExplosionBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveChangeToExplosionBP) == 0x000208, "Wrong size on LPhysicalAnimationComponent_ReserveChangeToExplosionBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToExplosionBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveChangeToExplosionBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToExplosionBP, Branches) == 0x000200, "Member 'LPhysicalAnimationComponent_ReserveChangeToExplosionBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToExplosionBP, ReturnValue) == 0x000201, "Member 'LPhysicalAnimationComponent_ReserveChangeToExplosionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToNoPhysicsBP
// 0x0003 (0x0003 - 0x0000)
struct LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP final
{
public:
	struct FLPhysicsInfo_NoPhysics                PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP) == 0x000003, "Wrong size on LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP, Branches) == 0x000001, "Member 'LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP, ReturnValue) == 0x000002, "Member 'LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToPhysicalAnimationBP
// 0x0003 (0x0003 - 0x0000)
struct LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP final
{
public:
	struct FLPhysicsInfo_PhysicalAnimation        PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP) == 0x000003, "Wrong size on LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP, Branches) == 0x000001, "Member 'LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP, ReturnValue) == 0x000002, "Member 'LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToRagdollBP
// 0x0003 (0x0003 - 0x0000)
struct LPhysicalAnimationComponent_ReserveChangeToRagdollBP final
{
public:
	struct FLPhysicsInfo_RagDoll                  PhysicsInfo;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveChangeToRagdollBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ReserveChangeToRagdollBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveChangeToRagdollBP) == 0x000003, "Wrong size on LPhysicalAnimationComponent_ReserveChangeToRagdollBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToRagdollBP, PhysicsInfo) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveChangeToRagdollBP::PhysicsInfo' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToRagdollBP, Branches) == 0x000001, "Member 'LPhysicalAnimationComponent_ReserveChangeToRagdollBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToRagdollBP, ReturnValue) == 0x000002, "Member 'LPhysicalAnimationComponent_ReserveChangeToRagdollBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToRagdollFreezeBP
// 0x0002 (0x0002 - 0x0000)
struct LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP final
{
public:
	EExecutePin                                   Branches;                                          // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP) == 0x000001, "Wrong alignment on LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP) == 0x000002, "Wrong size on LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP, Branches) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP, ReturnValue) == 0x000001, "Member 'LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.ReserveResetBP
// 0x0010 (0x0010 - 0x0000)
struct LPhysicalAnimationComponent_ReserveResetBP final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromBeginPlay;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExecutePin                                   Branches;                                          // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_ReserveResetBP) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_ReserveResetBP");
static_assert(sizeof(LPhysicalAnimationComponent_ReserveResetBP) == 0x000010, "Wrong size on LPhysicalAnimationComponent_ReserveResetBP");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveResetBP, InSkeletalMeshComponent) == 0x000000, "Member 'LPhysicalAnimationComponent_ReserveResetBP::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveResetBP, FromBeginPlay) == 0x000008, "Member 'LPhysicalAnimationComponent_ReserveResetBP::FromBeginPlay' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveResetBP, Branches) == 0x000009, "Member 'LPhysicalAnimationComponent_ReserveResetBP::Branches' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_ReserveResetBP, ReturnValue) == 0x00000A, "Member 'LPhysicalAnimationComponent_ReserveResetBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LPhysicalAnimationComponent.Reset
// 0x0010 (0x0010 - 0x0000)
struct LPhysicalAnimationComponent_Reset final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromBeginPlay;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPhysicalAnimationComponent_Reset) == 0x000008, "Wrong alignment on LPhysicalAnimationComponent_Reset");
static_assert(sizeof(LPhysicalAnimationComponent_Reset) == 0x000010, "Wrong size on LPhysicalAnimationComponent_Reset");
static_assert(offsetof(LPhysicalAnimationComponent_Reset, InSkeletalMeshComponent) == 0x000000, "Member 'LPhysicalAnimationComponent_Reset::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(LPhysicalAnimationComponent_Reset, FromBeginPlay) == 0x000008, "Member 'LPhysicalAnimationComponent_Reset::FromBeginPlay' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.CheckCanEquipItem
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_CheckCanEquipItem final
{
public:
	ELEquipSlotType                               SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_CheckCanEquipItem) == 0x000008, "Wrong alignment on LPlayerEquipment_CheckCanEquipItem");
static_assert(sizeof(LPlayerEquipment_CheckCanEquipItem) == 0x000018, "Wrong size on LPlayerEquipment_CheckCanEquipItem");
static_assert(offsetof(LPlayerEquipment_CheckCanEquipItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_CheckCanEquipItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_CheckCanEquipItem, Item) == 0x000008, "Member 'LPlayerEquipment_CheckCanEquipItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_CheckCanEquipItem, ReturnValue) == 0x000010, "Member 'LPlayerEquipment_CheckCanEquipItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.ChooseNextSlaveArmItem
// 0x0001 (0x0001 - 0x0000)
struct LPlayerEquipment_ChooseNextSlaveArmItem final
{
public:
	bool                                          bSelectPrevious;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_ChooseNextSlaveArmItem) == 0x000001, "Wrong alignment on LPlayerEquipment_ChooseNextSlaveArmItem");
static_assert(sizeof(LPlayerEquipment_ChooseNextSlaveArmItem) == 0x000001, "Wrong size on LPlayerEquipment_ChooseNextSlaveArmItem");
static_assert(offsetof(LPlayerEquipment_ChooseNextSlaveArmItem, bSelectPrevious) == 0x000000, "Member 'LPlayerEquipment_ChooseNextSlaveArmItem::bSelectPrevious' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.ChooseNextUseItem
// 0x0001 (0x0001 - 0x0000)
struct LPlayerEquipment_ChooseNextUseItem final
{
public:
	bool                                          bSelectPrevious;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_ChooseNextUseItem) == 0x000001, "Wrong alignment on LPlayerEquipment_ChooseNextUseItem");
static_assert(sizeof(LPlayerEquipment_ChooseNextUseItem) == 0x000001, "Wrong size on LPlayerEquipment_ChooseNextUseItem");
static_assert(offsetof(LPlayerEquipment_ChooseNextUseItem, bSelectPrevious) == 0x000000, "Member 'LPlayerEquipment_ChooseNextUseItem::bSelectPrevious' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.ChooseNextWeaponItem
// 0x0001 (0x0001 - 0x0000)
struct LPlayerEquipment_ChooseNextWeaponItem final
{
public:
	bool                                          bSelectPrevious;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_ChooseNextWeaponItem) == 0x000001, "Wrong alignment on LPlayerEquipment_ChooseNextWeaponItem");
static_assert(sizeof(LPlayerEquipment_ChooseNextWeaponItem) == 0x000001, "Wrong size on LPlayerEquipment_ChooseNextWeaponItem");
static_assert(offsetof(LPlayerEquipment_ChooseNextWeaponItem, bSelectPrevious) == 0x000000, "Member 'LPlayerEquipment_ChooseNextWeaponItem::bSelectPrevious' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.EquipAssistUseItem
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_EquipAssistUseItem final
{
public:
	ELAssistUseItemSlotType                       SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_EquipAssistUseItem) == 0x000008, "Wrong alignment on LPlayerEquipment_EquipAssistUseItem");
static_assert(sizeof(LPlayerEquipment_EquipAssistUseItem) == 0x000018, "Wrong size on LPlayerEquipment_EquipAssistUseItem");
static_assert(offsetof(LPlayerEquipment_EquipAssistUseItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_EquipAssistUseItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipAssistUseItem, Item) == 0x000008, "Member 'LPlayerEquipment_EquipAssistUseItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipAssistUseItem, ReturnValue) == 0x000010, "Member 'LPlayerEquipment_EquipAssistUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.EquipItem
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_EquipItem final
{
public:
	ELEquipSlotType                               SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_EquipItem) == 0x000008, "Wrong alignment on LPlayerEquipment_EquipItem");
static_assert(sizeof(LPlayerEquipment_EquipItem) == 0x000018, "Wrong size on LPlayerEquipment_EquipItem");
static_assert(offsetof(LPlayerEquipment_EquipItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_EquipItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipItem, Item) == 0x000008, "Member 'LPlayerEquipment_EquipItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipItem, ReturnValue) == 0x000010, "Member 'LPlayerEquipment_EquipItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.EquipUseItem_CurrentLine
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_EquipUseItem_CurrentLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_EquipUseItem_CurrentLine) == 0x000008, "Wrong alignment on LPlayerEquipment_EquipUseItem_CurrentLine");
static_assert(sizeof(LPlayerEquipment_EquipUseItem_CurrentLine) == 0x000018, "Wrong size on LPlayerEquipment_EquipUseItem_CurrentLine");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_CurrentLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_EquipUseItem_CurrentLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_CurrentLine, Item) == 0x000008, "Member 'LPlayerEquipment_EquipUseItem_CurrentLine::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_CurrentLine, ReturnValue) == 0x000010, "Member 'LPlayerEquipment_EquipUseItem_CurrentLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.EquipUseItem_SpecifiedLine
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_EquipUseItem_SpecifiedLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstLine;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_EquipUseItem_SpecifiedLine) == 0x000008, "Wrong alignment on LPlayerEquipment_EquipUseItem_SpecifiedLine");
static_assert(sizeof(LPlayerEquipment_EquipUseItem_SpecifiedLine) == 0x000018, "Wrong size on LPlayerEquipment_EquipUseItem_SpecifiedLine");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_SpecifiedLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_EquipUseItem_SpecifiedLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_SpecifiedLine, Item) == 0x000008, "Member 'LPlayerEquipment_EquipUseItem_SpecifiedLine::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_SpecifiedLine, FirstLine) == 0x000010, "Member 'LPlayerEquipment_EquipUseItem_SpecifiedLine::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_EquipUseItem_SpecifiedLine, ReturnValue) == 0x000011, "Member 'LPlayerEquipment_EquipUseItem_SpecifiedLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.FindAssistUseItem
// 0x0014 (0x0014 - 0x0000)
struct LPlayerEquipment_FindAssistUseItem final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAssistUseItemSlot                    ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_FindAssistUseItem) == 0x000004, "Wrong alignment on LPlayerEquipment_FindAssistUseItem");
static_assert(sizeof(LPlayerEquipment_FindAssistUseItem) == 0x000014, "Wrong size on LPlayerEquipment_FindAssistUseItem");
static_assert(offsetof(LPlayerEquipment_FindAssistUseItem, ItemCodeName) == 0x000000, "Member 'LPlayerEquipment_FindAssistUseItem::ItemCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_FindAssistUseItem, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_FindAssistUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.FindEquipItem
// 0x0020 (0x0020 - 0x0000)
struct LPlayerEquipment_FindEquipItem final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLEquipItemSlot                        ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_FindEquipItem) == 0x000008, "Wrong alignment on LPlayerEquipment_FindEquipItem");
static_assert(sizeof(LPlayerEquipment_FindEquipItem) == 0x000020, "Wrong size on LPlayerEquipment_FindEquipItem");
static_assert(offsetof(LPlayerEquipment_FindEquipItem, Item) == 0x000000, "Member 'LPlayerEquipment_FindEquipItem::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_FindEquipItem, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_FindEquipItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.FindEquipItems_ByEquipGroupId
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_FindEquipItems_ByEquipGroupId final
{
public:
	int32                                         InEquipGroupId;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLEquipItemSlot>                ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_FindEquipItems_ByEquipGroupId) == 0x000008, "Wrong alignment on LPlayerEquipment_FindEquipItems_ByEquipGroupId");
static_assert(sizeof(LPlayerEquipment_FindEquipItems_ByEquipGroupId) == 0x000018, "Wrong size on LPlayerEquipment_FindEquipItems_ByEquipGroupId");
static_assert(offsetof(LPlayerEquipment_FindEquipItems_ByEquipGroupId, InEquipGroupId) == 0x000000, "Member 'LPlayerEquipment_FindEquipItems_ByEquipGroupId::InEquipGroupId' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_FindEquipItems_ByEquipGroupId, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_FindEquipItems_ByEquipGroupId::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.FindUseItem_CurrentLine
// 0x001C (0x001C - 0x0000)
struct LPlayerEquipment_FindUseItem_CurrentLine final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLUseItemSlot                          ReturnValue;                                       // 0x0008(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_FindUseItem_CurrentLine) == 0x000004, "Wrong alignment on LPlayerEquipment_FindUseItem_CurrentLine");
static_assert(sizeof(LPlayerEquipment_FindUseItem_CurrentLine) == 0x00001C, "Wrong size on LPlayerEquipment_FindUseItem_CurrentLine");
static_assert(offsetof(LPlayerEquipment_FindUseItem_CurrentLine, ItemCodeName) == 0x000000, "Member 'LPlayerEquipment_FindUseItem_CurrentLine::ItemCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_FindUseItem_CurrentLine, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_FindUseItem_CurrentLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.FindUseItem_SpecifiedLine
// 0x0020 (0x0020 - 0x0000)
struct LPlayerEquipment_FindUseItem_SpecifiedLine final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstLine;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLUseItemSlot                          ReturnValue;                                       // 0x000C(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_FindUseItem_SpecifiedLine) == 0x000004, "Wrong alignment on LPlayerEquipment_FindUseItem_SpecifiedLine");
static_assert(sizeof(LPlayerEquipment_FindUseItem_SpecifiedLine) == 0x000020, "Wrong size on LPlayerEquipment_FindUseItem_SpecifiedLine");
static_assert(offsetof(LPlayerEquipment_FindUseItem_SpecifiedLine, ItemCodeName) == 0x000000, "Member 'LPlayerEquipment_FindUseItem_SpecifiedLine::ItemCodeName' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_FindUseItem_SpecifiedLine, FirstLine) == 0x000008, "Member 'LPlayerEquipment_FindUseItem_SpecifiedLine::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_FindUseItem_SpecifiedLine, ReturnValue) == 0x00000C, "Member 'LPlayerEquipment_FindUseItem_SpecifiedLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetAssistUseItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetAssistUseItem final
{
public:
	ELAssistUseItemSlotType                       SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetAssistUseItem) == 0x000008, "Wrong alignment on LPlayerEquipment_GetAssistUseItem");
static_assert(sizeof(LPlayerEquipment_GetAssistUseItem) == 0x000010, "Wrong size on LPlayerEquipment_GetAssistUseItem");
static_assert(offsetof(LPlayerEquipment_GetAssistUseItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_GetAssistUseItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetAssistUseItem, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetAssistUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetAssistUseItemCodeName
// 0x000C (0x000C - 0x0000)
struct LPlayerEquipment_GetAssistUseItemCodeName final
{
public:
	ELAssistUseItemSlotType                       SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetAssistUseItemCodeName) == 0x000004, "Wrong alignment on LPlayerEquipment_GetAssistUseItemCodeName");
static_assert(sizeof(LPlayerEquipment_GetAssistUseItemCodeName) == 0x00000C, "Wrong size on LPlayerEquipment_GetAssistUseItemCodeName");
static_assert(offsetof(LPlayerEquipment_GetAssistUseItemCodeName, SlotType) == 0x000000, "Member 'LPlayerEquipment_GetAssistUseItemCodeName::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetAssistUseItemCodeName, ReturnValue) == 0x000004, "Member 'LPlayerEquipment_GetAssistUseItemCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetChosenSlaveArmItem
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_GetChosenSlaveArmItem final
{
public:
	struct FLEquipItemSlot                        ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetChosenSlaveArmItem) == 0x000008, "Wrong alignment on LPlayerEquipment_GetChosenSlaveArmItem");
static_assert(sizeof(LPlayerEquipment_GetChosenSlaveArmItem) == 0x000018, "Wrong size on LPlayerEquipment_GetChosenSlaveArmItem");
static_assert(offsetof(LPlayerEquipment_GetChosenSlaveArmItem, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_GetChosenSlaveArmItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetChosenUseItem
// 0x0014 (0x0014 - 0x0000)
struct LPlayerEquipment_GetChosenUseItem final
{
public:
	struct FLUseItemSlot                          ReturnValue;                                       // 0x0000(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetChosenUseItem) == 0x000004, "Wrong alignment on LPlayerEquipment_GetChosenUseItem");
static_assert(sizeof(LPlayerEquipment_GetChosenUseItem) == 0x000014, "Wrong size on LPlayerEquipment_GetChosenUseItem");
static_assert(offsetof(LPlayerEquipment_GetChosenUseItem, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_GetChosenUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetChosenWeaponItem
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_GetChosenWeaponItem final
{
public:
	struct FLEquipItemSlot                        ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetChosenWeaponItem) == 0x000008, "Wrong alignment on LPlayerEquipment_GetChosenWeaponItem");
static_assert(sizeof(LPlayerEquipment_GetChosenWeaponItem) == 0x000018, "Wrong size on LPlayerEquipment_GetChosenWeaponItem");
static_assert(offsetof(LPlayerEquipment_GetChosenWeaponItem, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_GetChosenWeaponItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetChosenWeaponItemBP
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetChosenWeaponItemBP final
{
public:
	class ALWeapon*                               Weapon;                                            // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELEquipSlotType                               EquipSlot;                                         // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_GetChosenWeaponItemBP) == 0x000008, "Wrong alignment on LPlayerEquipment_GetChosenWeaponItemBP");
static_assert(sizeof(LPlayerEquipment_GetChosenWeaponItemBP) == 0x000010, "Wrong size on LPlayerEquipment_GetChosenWeaponItemBP");
static_assert(offsetof(LPlayerEquipment_GetChosenWeaponItemBP, Weapon) == 0x000000, "Member 'LPlayerEquipment_GetChosenWeaponItemBP::Weapon' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetChosenWeaponItemBP, EquipSlot) == 0x000008, "Member 'LPlayerEquipment_GetChosenWeaponItemBP::EquipSlot' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetEquipItem
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetEquipItem final
{
public:
	ELEquipSlotType                               SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetEquipItem) == 0x000008, "Wrong alignment on LPlayerEquipment_GetEquipItem");
static_assert(sizeof(LPlayerEquipment_GetEquipItem) == 0x000010, "Wrong size on LPlayerEquipment_GetEquipItem");
static_assert(offsetof(LPlayerEquipment_GetEquipItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_GetEquipItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetEquipItem, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetEquipItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetEquipItemSlot
// 0x0020 (0x0020 - 0x0000)
struct LPlayerEquipment_GetEquipItemSlot final
{
public:
	ELEquipSlotType                               EquipSlotType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFound;                                            // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLEquipItemSlot                        ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetEquipItemSlot) == 0x000008, "Wrong alignment on LPlayerEquipment_GetEquipItemSlot");
static_assert(sizeof(LPlayerEquipment_GetEquipItemSlot) == 0x000020, "Wrong size on LPlayerEquipment_GetEquipItemSlot");
static_assert(offsetof(LPlayerEquipment_GetEquipItemSlot, EquipSlotType) == 0x000000, "Member 'LPlayerEquipment_GetEquipItemSlot::EquipSlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetEquipItemSlot, bFound) == 0x000001, "Member 'LPlayerEquipment_GetEquipItemSlot::bFound' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetEquipItemSlot, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetEquipItemSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetEquipSlot
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetEquipSlot final
{
public:
	const class ULItem*                           Item;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELEquipSlotType                               ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_GetEquipSlot) == 0x000008, "Wrong alignment on LPlayerEquipment_GetEquipSlot");
static_assert(sizeof(LPlayerEquipment_GetEquipSlot) == 0x000010, "Wrong size on LPlayerEquipment_GetEquipSlot");
static_assert(offsetof(LPlayerEquipment_GetEquipSlot, Item) == 0x000000, "Member 'LPlayerEquipment_GetEquipSlot::Item' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetEquipSlot, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetEquipSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseItem_CurrentLine
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetUseItem_CurrentLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseItem_CurrentLine) == 0x000008, "Wrong alignment on LPlayerEquipment_GetUseItem_CurrentLine");
static_assert(sizeof(LPlayerEquipment_GetUseItem_CurrentLine) == 0x000010, "Wrong size on LPlayerEquipment_GetUseItem_CurrentLine");
static_assert(offsetof(LPlayerEquipment_GetUseItem_CurrentLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_GetUseItem_CurrentLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItem_CurrentLine, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetUseItem_CurrentLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseItem_SpecifiedLine
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetUseItem_SpecifiedLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstLine;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseItem_SpecifiedLine) == 0x000008, "Wrong alignment on LPlayerEquipment_GetUseItem_SpecifiedLine");
static_assert(sizeof(LPlayerEquipment_GetUseItem_SpecifiedLine) == 0x000010, "Wrong size on LPlayerEquipment_GetUseItem_SpecifiedLine");
static_assert(offsetof(LPlayerEquipment_GetUseItem_SpecifiedLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_GetUseItem_SpecifiedLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItem_SpecifiedLine, FirstLine) == 0x000004, "Member 'LPlayerEquipment_GetUseItem_SpecifiedLine::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItem_SpecifiedLine, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetUseItem_SpecifiedLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseItemCodeName_CurrentLine
// 0x000C (0x000C - 0x0000)
struct LPlayerEquipment_GetUseItemCodeName_CurrentLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseItemCodeName_CurrentLine) == 0x000004, "Wrong alignment on LPlayerEquipment_GetUseItemCodeName_CurrentLine");
static_assert(sizeof(LPlayerEquipment_GetUseItemCodeName_CurrentLine) == 0x00000C, "Wrong size on LPlayerEquipment_GetUseItemCodeName_CurrentLine");
static_assert(offsetof(LPlayerEquipment_GetUseItemCodeName_CurrentLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_GetUseItemCodeName_CurrentLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItemCodeName_CurrentLine, ReturnValue) == 0x000004, "Member 'LPlayerEquipment_GetUseItemCodeName_CurrentLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseItemCodeName_SpecifiedLine
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetUseItemCodeName_SpecifiedLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstLine;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseItemCodeName_SpecifiedLine) == 0x000004, "Wrong alignment on LPlayerEquipment_GetUseItemCodeName_SpecifiedLine");
static_assert(sizeof(LPlayerEquipment_GetUseItemCodeName_SpecifiedLine) == 0x000010, "Wrong size on LPlayerEquipment_GetUseItemCodeName_SpecifiedLine");
static_assert(offsetof(LPlayerEquipment_GetUseItemCodeName_SpecifiedLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_GetUseItemCodeName_SpecifiedLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItemCodeName_SpecifiedLine, FirstLine) == 0x000004, "Member 'LPlayerEquipment_GetUseItemCodeName_SpecifiedLine::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItemCodeName_SpecifiedLine, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetUseItemCodeName_SpecifiedLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseItemSlot
// 0x0020 (0x0020 - 0x0000)
struct LPlayerEquipment_GetUseItemSlot final
{
public:
	bool                                          FirstLine;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFound;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLUseItemSlot                          ReturnValue;                                       // 0x000C(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseItemSlot) == 0x000004, "Wrong alignment on LPlayerEquipment_GetUseItemSlot");
static_assert(sizeof(LPlayerEquipment_GetUseItemSlot) == 0x000020, "Wrong size on LPlayerEquipment_GetUseItemSlot");
static_assert(offsetof(LPlayerEquipment_GetUseItemSlot, FirstLine) == 0x000000, "Member 'LPlayerEquipment_GetUseItemSlot::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItemSlot, SlotIndex) == 0x000004, "Member 'LPlayerEquipment_GetUseItemSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItemSlot, bFound) == 0x000008, "Member 'LPlayerEquipment_GetUseItemSlot::bFound' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseItemSlot, ReturnValue) == 0x00000C, "Member 'LPlayerEquipment_GetUseItemSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseSlotsLine
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_GetUseSlotsLine final
{
public:
	bool                                          FirstLine;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLUseItemSlot>                  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseSlotsLine) == 0x000008, "Wrong alignment on LPlayerEquipment_GetUseSlotsLine");
static_assert(sizeof(LPlayerEquipment_GetUseSlotsLine) == 0x000018, "Wrong size on LPlayerEquipment_GetUseSlotsLine");
static_assert(offsetof(LPlayerEquipment_GetUseSlotsLine, FirstLine) == 0x000000, "Member 'LPlayerEquipment_GetUseSlotsLine::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseSlotsLine, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetUseSlotsLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetUseSlotsLine_AllSlot
// 0x0018 (0x0018 - 0x0000)
struct LPlayerEquipment_GetUseSlotsLine_AllSlot final
{
public:
	bool                                          FirstLine;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLUseItemSlot>                  ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetUseSlotsLine_AllSlot) == 0x000008, "Wrong alignment on LPlayerEquipment_GetUseSlotsLine_AllSlot");
static_assert(sizeof(LPlayerEquipment_GetUseSlotsLine_AllSlot) == 0x000018, "Wrong size on LPlayerEquipment_GetUseSlotsLine_AllSlot");
static_assert(offsetof(LPlayerEquipment_GetUseSlotsLine_AllSlot, FirstLine) == 0x000000, "Member 'LPlayerEquipment_GetUseSlotsLine_AllSlot::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_GetUseSlotsLine_AllSlot, ReturnValue) == 0x000008, "Member 'LPlayerEquipment_GetUseSlotsLine_AllSlot::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.SetUnlockEquipSlot
// 0x0002 (0x0002 - 0x0000)
struct LPlayerEquipment_SetUnlockEquipSlot final
{
public:
	ELEquipSlotType                               SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_SetUnlockEquipSlot) == 0x000001, "Wrong alignment on LPlayerEquipment_SetUnlockEquipSlot");
static_assert(sizeof(LPlayerEquipment_SetUnlockEquipSlot) == 0x000002, "Wrong size on LPlayerEquipment_SetUnlockEquipSlot");
static_assert(offsetof(LPlayerEquipment_SetUnlockEquipSlot, SlotType) == 0x000000, "Member 'LPlayerEquipment_SetUnlockEquipSlot::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_SetUnlockEquipSlot, bUnlock) == 0x000001, "Member 'LPlayerEquipment_SetUnlockEquipSlot::bUnlock' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.SetUnlockEquipSlotByCategory
// 0x000C (0x000C - 0x0000)
struct LPlayerEquipment_SetUnlockEquipSlotByCategory final
{
public:
	class FName                                   SlotCategoryType;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_SetUnlockEquipSlotByCategory) == 0x000004, "Wrong alignment on LPlayerEquipment_SetUnlockEquipSlotByCategory");
static_assert(sizeof(LPlayerEquipment_SetUnlockEquipSlotByCategory) == 0x00000C, "Wrong size on LPlayerEquipment_SetUnlockEquipSlotByCategory");
static_assert(offsetof(LPlayerEquipment_SetUnlockEquipSlotByCategory, SlotCategoryType) == 0x000000, "Member 'LPlayerEquipment_SetUnlockEquipSlotByCategory::SlotCategoryType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_SetUnlockEquipSlotByCategory, bUnlock) == 0x000008, "Member 'LPlayerEquipment_SetUnlockEquipSlotByCategory::bUnlock' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.SetUnlockEquipUseSlot
// 0x0008 (0x0008 - 0x0000)
struct LPlayerEquipment_SetUnlockEquipUseSlot final
{
public:
	bool                                          bUnlock;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_SetUnlockEquipUseSlot) == 0x000004, "Wrong alignment on LPlayerEquipment_SetUnlockEquipUseSlot");
static_assert(sizeof(LPlayerEquipment_SetUnlockEquipUseSlot) == 0x000008, "Wrong size on LPlayerEquipment_SetUnlockEquipUseSlot");
static_assert(offsetof(LPlayerEquipment_SetUnlockEquipUseSlot, bUnlock) == 0x000000, "Member 'LPlayerEquipment_SetUnlockEquipUseSlot::bUnlock' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_SetUnlockEquipUseSlot, Count) == 0x000004, "Member 'LPlayerEquipment_SetUnlockEquipUseSlot::Count' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.SwapUseSlotsLine
// 0x0001 (0x0001 - 0x0000)
struct LPlayerEquipment_SwapUseSlotsLine final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_SwapUseSlotsLine) == 0x000001, "Wrong alignment on LPlayerEquipment_SwapUseSlotsLine");
static_assert(sizeof(LPlayerEquipment_SwapUseSlotsLine) == 0x000001, "Wrong size on LPlayerEquipment_SwapUseSlotsLine");
static_assert(offsetof(LPlayerEquipment_SwapUseSlotsLine, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_SwapUseSlotsLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.UnEquipAssistUseItem
// 0x0002 (0x0002 - 0x0000)
struct LPlayerEquipment_UnEquipAssistUseItem final
{
public:
	ELAssistUseItemSlotType                       SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_UnEquipAssistUseItem) == 0x000001, "Wrong alignment on LPlayerEquipment_UnEquipAssistUseItem");
static_assert(sizeof(LPlayerEquipment_UnEquipAssistUseItem) == 0x000002, "Wrong size on LPlayerEquipment_UnEquipAssistUseItem");
static_assert(offsetof(LPlayerEquipment_UnEquipAssistUseItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_UnEquipAssistUseItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_UnEquipAssistUseItem, ReturnValue) == 0x000001, "Member 'LPlayerEquipment_UnEquipAssistUseItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.UnEquipItem
// 0x0002 (0x0002 - 0x0000)
struct LPlayerEquipment_UnEquipItem final
{
public:
	ELEquipSlotType                               SlotType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_UnEquipItem) == 0x000001, "Wrong alignment on LPlayerEquipment_UnEquipItem");
static_assert(sizeof(LPlayerEquipment_UnEquipItem) == 0x000002, "Wrong size on LPlayerEquipment_UnEquipItem");
static_assert(offsetof(LPlayerEquipment_UnEquipItem, SlotType) == 0x000000, "Member 'LPlayerEquipment_UnEquipItem::SlotType' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_UnEquipItem, ReturnValue) == 0x000001, "Member 'LPlayerEquipment_UnEquipItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.UnEquipUseItem_CurrentLine
// 0x0008 (0x0008 - 0x0000)
struct LPlayerEquipment_UnEquipUseItem_CurrentLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_UnEquipUseItem_CurrentLine) == 0x000004, "Wrong alignment on LPlayerEquipment_UnEquipUseItem_CurrentLine");
static_assert(sizeof(LPlayerEquipment_UnEquipUseItem_CurrentLine) == 0x000008, "Wrong size on LPlayerEquipment_UnEquipUseItem_CurrentLine");
static_assert(offsetof(LPlayerEquipment_UnEquipUseItem_CurrentLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_UnEquipUseItem_CurrentLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_UnEquipUseItem_CurrentLine, ReturnValue) == 0x000004, "Member 'LPlayerEquipment_UnEquipUseItem_CurrentLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.UnEquipUseItem_SpecifiedLine
// 0x0008 (0x0008 - 0x0000)
struct LPlayerEquipment_UnEquipUseItem_SpecifiedLine final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstLine;                                         // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPlayerEquipment_UnEquipUseItem_SpecifiedLine) == 0x000004, "Wrong alignment on LPlayerEquipment_UnEquipUseItem_SpecifiedLine");
static_assert(sizeof(LPlayerEquipment_UnEquipUseItem_SpecifiedLine) == 0x000008, "Wrong size on LPlayerEquipment_UnEquipUseItem_SpecifiedLine");
static_assert(offsetof(LPlayerEquipment_UnEquipUseItem_SpecifiedLine, SlotIndex) == 0x000000, "Member 'LPlayerEquipment_UnEquipUseItem_SpecifiedLine::SlotIndex' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_UnEquipUseItem_SpecifiedLine, FirstLine) == 0x000004, "Member 'LPlayerEquipment_UnEquipUseItem_SpecifiedLine::FirstLine' has a wrong offset!");
static_assert(offsetof(LPlayerEquipment_UnEquipUseItem_SpecifiedLine, ReturnValue) == 0x000005, "Member 'LPlayerEquipment_UnEquipUseItem_SpecifiedLine::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetGearArmSlotTypeList
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetGearArmSlotTypeList final
{
public:
	TArray<ELEquipSlotType>                       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetGearArmSlotTypeList) == 0x000008, "Wrong alignment on LPlayerEquipment_GetGearArmSlotTypeList");
static_assert(sizeof(LPlayerEquipment_GetGearArmSlotTypeList) == 0x000010, "Wrong size on LPlayerEquipment_GetGearArmSlotTypeList");
static_assert(offsetof(LPlayerEquipment_GetGearArmSlotTypeList, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_GetGearArmSlotTypeList::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetSlaveArmSlotTypeList
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetSlaveArmSlotTypeList final
{
public:
	TArray<ELEquipSlotType>                       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetSlaveArmSlotTypeList) == 0x000008, "Wrong alignment on LPlayerEquipment_GetSlaveArmSlotTypeList");
static_assert(sizeof(LPlayerEquipment_GetSlaveArmSlotTypeList) == 0x000010, "Wrong size on LPlayerEquipment_GetSlaveArmSlotTypeList");
static_assert(offsetof(LPlayerEquipment_GetSlaveArmSlotTypeList, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_GetSlaveArmSlotTypeList::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.GetWeaponSlotTypeList
// 0x0010 (0x0010 - 0x0000)
struct LPlayerEquipment_GetWeaponSlotTypeList final
{
public:
	TArray<ELEquipSlotType>                       ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_GetWeaponSlotTypeList) == 0x000008, "Wrong alignment on LPlayerEquipment_GetWeaponSlotTypeList");
static_assert(sizeof(LPlayerEquipment_GetWeaponSlotTypeList) == 0x000010, "Wrong size on LPlayerEquipment_GetWeaponSlotTypeList");
static_assert(offsetof(LPlayerEquipment_GetWeaponSlotTypeList, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_GetWeaponSlotTypeList::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.IsEquipedPartsSet
// 0x0001 (0x0001 - 0x0000)
struct LPlayerEquipment_IsEquipedPartsSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_IsEquipedPartsSet) == 0x000001, "Wrong alignment on LPlayerEquipment_IsEquipedPartsSet");
static_assert(sizeof(LPlayerEquipment_IsEquipedPartsSet) == 0x000001, "Wrong size on LPlayerEquipment_IsEquipedPartsSet");
static_assert(offsetof(LPlayerEquipment_IsEquipedPartsSet, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_IsEquipedPartsSet::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayerEquipment.IsSelectedUseSlotsLineFirst
// 0x0001 (0x0001 - 0x0000)
struct LPlayerEquipment_IsSelectedUseSlotsLineFirst final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayerEquipment_IsSelectedUseSlotsLineFirst) == 0x000001, "Wrong alignment on LPlayerEquipment_IsSelectedUseSlotsLineFirst");
static_assert(sizeof(LPlayerEquipment_IsSelectedUseSlotsLineFirst) == 0x000001, "Wrong size on LPlayerEquipment_IsSelectedUseSlotsLineFirst");
static_assert(offsetof(LPlayerEquipment_IsSelectedUseSlotsLineFirst, ReturnValue) == 0x000000, "Member 'LPlayerEquipment_IsSelectedUseSlotsLineFirst::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.SetPlayInputLock
// 0x0001 (0x0001 - 0x0000)
struct LPlayInputSystem_SetPlayInputLock final
{
public:
	bool                                          block;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_SetPlayInputLock) == 0x000001, "Wrong alignment on LPlayInputSystem_SetPlayInputLock");
static_assert(sizeof(LPlayInputSystem_SetPlayInputLock) == 0x000001, "Wrong size on LPlayInputSystem_SetPlayInputLock");
static_assert(offsetof(LPlayInputSystem_SetPlayInputLock, block) == 0x000000, "Member 'LPlayInputSystem_SetPlayInputLock::block' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.GetInputPlatformName
// 0x0010 (0x0010 - 0x0000)
struct LPlayInputSystem_GetInputPlatformName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_GetInputPlatformName) == 0x000008, "Wrong alignment on LPlayInputSystem_GetInputPlatformName");
static_assert(sizeof(LPlayInputSystem_GetInputPlatformName) == 0x000010, "Wrong size on LPlayInputSystem_GetInputPlatformName");
static_assert(offsetof(LPlayInputSystem_GetInputPlatformName, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_GetInputPlatformName::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.GetLastInputKey
// 0x0018 (0x0018 - 0x0000)
struct LPlayInputSystem_GetLastInputKey final
{
public:
	struct FKey                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_GetLastInputKey) == 0x000008, "Wrong alignment on LPlayInputSystem_GetLastInputKey");
static_assert(sizeof(LPlayInputSystem_GetLastInputKey) == 0x000018, "Wrong size on LPlayInputSystem_GetLastInputKey");
static_assert(offsetof(LPlayInputSystem_GetLastInputKey, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_GetLastInputKey::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.GetPlayerInput
// 0x0008 (0x0008 - 0x0000)
struct LPlayInputSystem_GetPlayerInput final
{
public:
	class ULPlayerInput*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_GetPlayerInput) == 0x000008, "Wrong alignment on LPlayInputSystem_GetPlayerInput");
static_assert(sizeof(LPlayInputSystem_GetPlayerInput) == 0x000008, "Wrong size on LPlayInputSystem_GetPlayerInput");
static_assert(offsetof(LPlayInputSystem_GetPlayerInput, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_GetPlayerInput::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.IsGamePadMode
// 0x0001 (0x0001 - 0x0000)
struct LPlayInputSystem_IsGamePadMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_IsGamePadMode) == 0x000001, "Wrong alignment on LPlayInputSystem_IsGamePadMode");
static_assert(sizeof(LPlayInputSystem_IsGamePadMode) == 0x000001, "Wrong size on LPlayInputSystem_IsGamePadMode");
static_assert(offsetof(LPlayInputSystem_IsGamePadMode, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_IsGamePadMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.IsRightAcceptButton
// 0x0001 (0x0001 - 0x0000)
struct LPlayInputSystem_IsRightAcceptButton final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_IsRightAcceptButton) == 0x000001, "Wrong alignment on LPlayInputSystem_IsRightAcceptButton");
static_assert(sizeof(LPlayInputSystem_IsRightAcceptButton) == 0x000001, "Wrong size on LPlayInputSystem_IsRightAcceptButton");
static_assert(offsetof(LPlayInputSystem_IsRightAcceptButton, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_IsRightAcceptButton::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.IsUsingPlayStationGamePad
// 0x0001 (0x0001 - 0x0000)
struct LPlayInputSystem_IsUsingPlayStationGamePad final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_IsUsingPlayStationGamePad) == 0x000001, "Wrong alignment on LPlayInputSystem_IsUsingPlayStationGamePad");
static_assert(sizeof(LPlayInputSystem_IsUsingPlayStationGamePad) == 0x000001, "Wrong size on LPlayInputSystem_IsUsingPlayStationGamePad");
static_assert(offsetof(LPlayInputSystem_IsUsingPlayStationGamePad, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_IsUsingPlayStationGamePad::ReturnValue' has a wrong offset!");

// Function ProjectP.LPlayInputSystem.IsUsingWinDualSense
// 0x0001 (0x0001 - 0x0000)
struct LPlayInputSystem_IsUsingWinDualSense final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPlayInputSystem_IsUsingWinDualSense) == 0x000001, "Wrong alignment on LPlayInputSystem_IsUsingWinDualSense");
static_assert(sizeof(LPlayInputSystem_IsUsingWinDualSense) == 0x000001, "Wrong size on LPlayInputSystem_IsUsingWinDualSense");
static_assert(offsetof(LPlayInputSystem_IsUsingWinDualSense, ReturnValue) == 0x000000, "Member 'LPlayInputSystem_IsUsingWinDualSense::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSellShop.GetSellCategorys
// 0x0050 (0x0050 - 0x0000)
struct LProductSellShop_GetSellCategorys final
{
public:
	TSet<ELItemFirstCategory>                     ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProductSellShop_GetSellCategorys) == 0x000008, "Wrong alignment on LProductSellShop_GetSellCategorys");
static_assert(sizeof(LProductSellShop_GetSellCategorys) == 0x000050, "Wrong size on LProductSellShop_GetSellCategorys");
static_assert(offsetof(LProductSellShop_GetSellCategorys, ReturnValue) == 0x000000, "Member 'LProductSellShop_GetSellCategorys::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSellShop.GetSellList
// 0x0018 (0x0018 - 0x0000)
struct LProductSellShop_GetSellList final
{
public:
	ELItemFirstCategory                           Category;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULItem*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProductSellShop_GetSellList) == 0x000008, "Wrong alignment on LProductSellShop_GetSellList");
static_assert(sizeof(LProductSellShop_GetSellList) == 0x000018, "Wrong size on LProductSellShop_GetSellList");
static_assert(offsetof(LProductSellShop_GetSellList, Category) == 0x000000, "Member 'LProductSellShop_GetSellList::Category' has a wrong offset!");
static_assert(offsetof(LProductSellShop_GetSellList, ReturnValue) == 0x000008, "Member 'LProductSellShop_GetSellList::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSellShop.Sell
// 0x0010 (0x0010 - 0x0000)
struct LProductSellShop_Sell final
{
public:
	class ULItem*                                 InSell;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLockerItem;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProductSellShop_Sell) == 0x000008, "Wrong alignment on LProductSellShop_Sell");
static_assert(sizeof(LProductSellShop_Sell) == 0x000010, "Wrong size on LProductSellShop_Sell");
static_assert(offsetof(LProductSellShop_Sell, InSell) == 0x000000, "Member 'LProductSellShop_Sell::InSell' has a wrong offset!");
static_assert(offsetof(LProductSellShop_Sell, InCount) == 0x000008, "Member 'LProductSellShop_Sell::InCount' has a wrong offset!");
static_assert(offsetof(LProductSellShop_Sell, IsLockerItem) == 0x00000C, "Member 'LProductSellShop_Sell::IsLockerItem' has a wrong offset!");
static_assert(offsetof(LProductSellShop_Sell, ReturnValue) == 0x00000D, "Member 'LProductSellShop_Sell::ReturnValue' has a wrong offset!");

// Function ProjectP.LProductSellShop.CalcSellingPrice
// 0x0010 (0x0010 - 0x0000)
struct LProductSellShop_CalcSellingPrice final
{
public:
	const class ULItem*                           InItem;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProductSellShop_CalcSellingPrice) == 0x000008, "Wrong alignment on LProductSellShop_CalcSellingPrice");
static_assert(sizeof(LProductSellShop_CalcSellingPrice) == 0x000010, "Wrong size on LProductSellShop_CalcSellingPrice");
static_assert(offsetof(LProductSellShop_CalcSellingPrice, InItem) == 0x000000, "Member 'LProductSellShop_CalcSellingPrice::InItem' has a wrong offset!");
static_assert(offsetof(LProductSellShop_CalcSellingPrice, ReturnValue) == 0x000008, "Member 'LProductSellShop_CalcSellingPrice::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileHit_PeriodicHandler.Initialize
// 0x00A0 (0x00A0 - 0x0000)
struct LProjectileHit_PeriodicHandler_Initialize final
{
public:
	class ALProjectile*                           InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLProjectileHitInfo                    InHitInfo;                                         // 0x0010(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileHit_PeriodicHandler_Initialize) == 0x000010, "Wrong alignment on LProjectileHit_PeriodicHandler_Initialize");
static_assert(sizeof(LProjectileHit_PeriodicHandler_Initialize) == 0x0000A0, "Wrong size on LProjectileHit_PeriodicHandler_Initialize");
static_assert(offsetof(LProjectileHit_PeriodicHandler_Initialize, InOwner) == 0x000000, "Member 'LProjectileHit_PeriodicHandler_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LProjectileHit_PeriodicHandler_Initialize, InHitInfo) == 0x000010, "Member 'LProjectileHit_PeriodicHandler_Initialize::InHitInfo' has a wrong offset!");

// Function ProjectP.LProjectileSpawn_PeriodicHandler.Initialize
// 0x0060 (0x0060 - 0x0000)
struct LProjectileSpawn_PeriodicHandler_Initialize final
{
public:
	class ALProjectile*                           InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLChildProjectileSpawnInfo             InSpawnInfo;                                       // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileSpawn_PeriodicHandler_Initialize) == 0x000010, "Wrong alignment on LProjectileSpawn_PeriodicHandler_Initialize");
static_assert(sizeof(LProjectileSpawn_PeriodicHandler_Initialize) == 0x000060, "Wrong size on LProjectileSpawn_PeriodicHandler_Initialize");
static_assert(offsetof(LProjectileSpawn_PeriodicHandler_Initialize, InOwner) == 0x000000, "Member 'LProjectileSpawn_PeriodicHandler_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LProjectileSpawn_PeriodicHandler_Initialize, InSpawnInfo) == 0x000010, "Member 'LProjectileSpawn_PeriodicHandler_Initialize::InSpawnInfo' has a wrong offset!");

// Function ProjectP.LProjectile_AbnormalApplyInRange.Initialize
// 0x0020 (0x0020 - 0x0000)
struct LProjectile_AbnormalApplyInRange_Initialize final
{
public:
	class ALProjectile*                           InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectileAbnormalApplyInRangeInfo   InAbnormalApplyInfo;                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_AbnormalApplyInRange_Initialize) == 0x000008, "Wrong alignment on LProjectile_AbnormalApplyInRange_Initialize");
static_assert(sizeof(LProjectile_AbnormalApplyInRange_Initialize) == 0x000020, "Wrong size on LProjectile_AbnormalApplyInRange_Initialize");
static_assert(offsetof(LProjectile_AbnormalApplyInRange_Initialize, InOwner) == 0x000000, "Member 'LProjectile_AbnormalApplyInRange_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LProjectile_AbnormalApplyInRange_Initialize, InAbnormalApplyInfo) == 0x000008, "Member 'LProjectile_AbnormalApplyInRange_Initialize::InAbnormalApplyInfo' has a wrong offset!");

// Function ProjectP.LProjectile_AbnormalApplyInRange.OnActorBeginOverlap
// 0x0008 (0x0008 - 0x0000)
struct LProjectile_AbnormalApplyInRange_OnActorBeginOverlap final
{
public:
	class AActor*                                 Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_AbnormalApplyInRange_OnActorBeginOverlap) == 0x000008, "Wrong alignment on LProjectile_AbnormalApplyInRange_OnActorBeginOverlap");
static_assert(sizeof(LProjectile_AbnormalApplyInRange_OnActorBeginOverlap) == 0x000008, "Wrong size on LProjectile_AbnormalApplyInRange_OnActorBeginOverlap");
static_assert(offsetof(LProjectile_AbnormalApplyInRange_OnActorBeginOverlap, Other) == 0x000000, "Member 'LProjectile_AbnormalApplyInRange_OnActorBeginOverlap::Other' has a wrong offset!");

// Function ProjectP.LProjectile_AbnormalApplyInRange.OnActorEndOverlap
// 0x0008 (0x0008 - 0x0000)
struct LProjectile_AbnormalApplyInRange_OnActorEndOverlap final
{
public:
	class AActor*                                 Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_AbnormalApplyInRange_OnActorEndOverlap) == 0x000008, "Wrong alignment on LProjectile_AbnormalApplyInRange_OnActorEndOverlap");
static_assert(sizeof(LProjectile_AbnormalApplyInRange_OnActorEndOverlap) == 0x000008, "Wrong size on LProjectile_AbnormalApplyInRange_OnActorEndOverlap");
static_assert(offsetof(LProjectile_AbnormalApplyInRange_OnActorEndOverlap, Other) == 0x000000, "Member 'LProjectile_AbnormalApplyInRange_OnActorEndOverlap::Other' has a wrong offset!");

// Function ProjectP.LProjectile_Chase.ChangeChasingState
// 0x0001 (0x0001 - 0x0000)
struct LProjectile_Chase_ChangeChasingState final
{
public:
	ELChaseProjectileState                        NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectile_Chase_ChangeChasingState) == 0x000001, "Wrong alignment on LProjectile_Chase_ChangeChasingState");
static_assert(sizeof(LProjectile_Chase_ChangeChasingState) == 0x000001, "Wrong size on LProjectile_Chase_ChangeChasingState");
static_assert(offsetof(LProjectile_Chase_ChangeChasingState, NewState) == 0x000000, "Member 'LProjectile_Chase_ChangeChasingState::NewState' has a wrong offset!");

// Function ProjectP.LProjectileSystem.AddUniqueSkillHit
// 0x0018 (0x0018 - 0x0000)
struct LProjectileSystem_AddUniqueSkillHit final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDuration;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectileSystem_AddUniqueSkillHit) == 0x000008, "Wrong alignment on LProjectileSystem_AddUniqueSkillHit");
static_assert(sizeof(LProjectileSystem_AddUniqueSkillHit) == 0x000018, "Wrong size on LProjectileSystem_AddUniqueSkillHit");
static_assert(offsetof(LProjectileSystem_AddUniqueSkillHit, Victim) == 0x000000, "Member 'LProjectileSystem_AddUniqueSkillHit::Victim' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_AddUniqueSkillHit, SkillHitCodeName) == 0x000008, "Member 'LProjectileSystem_AddUniqueSkillHit::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_AddUniqueSkillHit, InDuration) == 0x000010, "Member 'LProjectileSystem_AddUniqueSkillHit::InDuration' has a wrong offset!");

// Function ProjectP.LProjectileSystem.FindAngularProjectileAngle
// 0x0024 (0x0024 - 0x0000)
struct LProjectileSystem_FindAngularProjectileAngle final
{
public:
	struct FVector                                FireLocation;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityForce;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileSystem_FindAngularProjectileAngle) == 0x000004, "Wrong alignment on LProjectileSystem_FindAngularProjectileAngle");
static_assert(sizeof(LProjectileSystem_FindAngularProjectileAngle) == 0x000024, "Wrong size on LProjectileSystem_FindAngularProjectileAngle");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileAngle, FireLocation) == 0x000000, "Member 'LProjectileSystem_FindAngularProjectileAngle::FireLocation' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileAngle, TargetLocation) == 0x00000C, "Member 'LProjectileSystem_FindAngularProjectileAngle::TargetLocation' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileAngle, Speed) == 0x000018, "Member 'LProjectileSystem_FindAngularProjectileAngle::Speed' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileAngle, GravityForce) == 0x00001C, "Member 'LProjectileSystem_FindAngularProjectileAngle::GravityForce' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileAngle, ReturnValue) == 0x000020, "Member 'LProjectileSystem_FindAngularProjectileAngle::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileSystem.FindAngularProjectileSpeed
// 0x0020 (0x0020 - 0x0000)
struct LProjectileSystem_FindAngularProjectileSpeed final
{
public:
	struct FVector                                FireLocation;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileSystem_FindAngularProjectileSpeed) == 0x000004, "Wrong alignment on LProjectileSystem_FindAngularProjectileSpeed");
static_assert(sizeof(LProjectileSystem_FindAngularProjectileSpeed) == 0x000020, "Wrong size on LProjectileSystem_FindAngularProjectileSpeed");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileSpeed, FireLocation) == 0x000000, "Member 'LProjectileSystem_FindAngularProjectileSpeed::FireLocation' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileSpeed, TargetLocation) == 0x00000C, "Member 'LProjectileSystem_FindAngularProjectileSpeed::TargetLocation' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileSpeed, Angle) == 0x000018, "Member 'LProjectileSystem_FindAngularProjectileSpeed::Angle' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileSpeed, ReturnValue) == 0x00001C, "Member 'LProjectileSystem_FindAngularProjectileSpeed::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileSystem.FindAngularProjectileVelocity
// 0x0028 (0x0028 - 0x0000)
struct LProjectileSystem_FindAngularProjectileVelocity final
{
public:
	struct FVector                                FireLocation;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileSystem_FindAngularProjectileVelocity) == 0x000004, "Wrong alignment on LProjectileSystem_FindAngularProjectileVelocity");
static_assert(sizeof(LProjectileSystem_FindAngularProjectileVelocity) == 0x000028, "Wrong size on LProjectileSystem_FindAngularProjectileVelocity");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileVelocity, FireLocation) == 0x000000, "Member 'LProjectileSystem_FindAngularProjectileVelocity::FireLocation' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileVelocity, TargetLocation) == 0x00000C, "Member 'LProjectileSystem_FindAngularProjectileVelocity::TargetLocation' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileVelocity, Duration) == 0x000018, "Member 'LProjectileSystem_FindAngularProjectileVelocity::Duration' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_FindAngularProjectileVelocity, ReturnValue) == 0x00001C, "Member 'LProjectileSystem_FindAngularProjectileVelocity::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileSystem.IsSkillHitIgnored
// 0x0018 (0x0018 - 0x0000)
struct LProjectileSystem_IsSkillHitIgnored final
{
public:
	class AActor*                                 Victim;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectileSystem_IsSkillHitIgnored) == 0x000008, "Wrong alignment on LProjectileSystem_IsSkillHitIgnored");
static_assert(sizeof(LProjectileSystem_IsSkillHitIgnored) == 0x000018, "Wrong size on LProjectileSystem_IsSkillHitIgnored");
static_assert(offsetof(LProjectileSystem_IsSkillHitIgnored, Victim) == 0x000000, "Member 'LProjectileSystem_IsSkillHitIgnored::Victim' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_IsSkillHitIgnored, SkillHitCodeName) == 0x000008, "Member 'LProjectileSystem_IsSkillHitIgnored::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_IsSkillHitIgnored, ReturnValue) == 0x000010, "Member 'LProjectileSystem_IsSkillHitIgnored::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileSystem.LaunchProjectile
// 0x00B0 (0x00B0 - 0x0000)
struct LProjectileSystem_LaunchProjectile final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLProjectileSpawnParameter             SpawnParameters;                                   // 0x0010(0x0090)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class ALProjectile*                           ReturnValue;                                       // 0x00A0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectileSystem_LaunchProjectile) == 0x000010, "Wrong alignment on LProjectileSystem_LaunchProjectile");
static_assert(sizeof(LProjectileSystem_LaunchProjectile) == 0x0000B0, "Wrong size on LProjectileSystem_LaunchProjectile");
static_assert(offsetof(LProjectileSystem_LaunchProjectile, Instigator) == 0x000000, "Member 'LProjectileSystem_LaunchProjectile::Instigator' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_LaunchProjectile, SpawnParameters) == 0x000010, "Member 'LProjectileSystem_LaunchProjectile::SpawnParameters' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_LaunchProjectile, ReturnValue) == 0x0000A0, "Member 'LProjectileSystem_LaunchProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileSystem.PauseAllProjectile
// 0x0001 (0x0001 - 0x0000)
struct LProjectileSystem_PauseAllProjectile final
{
public:
	bool                                          PauseFlag;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileSystem_PauseAllProjectile) == 0x000001, "Wrong alignment on LProjectileSystem_PauseAllProjectile");
static_assert(sizeof(LProjectileSystem_PauseAllProjectile) == 0x000001, "Wrong size on LProjectileSystem_PauseAllProjectile");
static_assert(offsetof(LProjectileSystem_PauseAllProjectile, PauseFlag) == 0x000000, "Member 'LProjectileSystem_PauseAllProjectile::PauseFlag' has a wrong offset!");

// Function ProjectP.LProjectileSystem.RemoveProjectile
// 0x0008 (0x0008 - 0x0000)
struct LProjectileSystem_RemoveProjectile final
{
public:
	int64                                         ProjectileHandleId;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LProjectileSystem_RemoveProjectile) == 0x000008, "Wrong alignment on LProjectileSystem_RemoveProjectile");
static_assert(sizeof(LProjectileSystem_RemoveProjectile) == 0x000008, "Wrong size on LProjectileSystem_RemoveProjectile");
static_assert(offsetof(LProjectileSystem_RemoveProjectile, ProjectileHandleId) == 0x000000, "Member 'LProjectileSystem_RemoveProjectile::ProjectileHandleId' has a wrong offset!");

// Function ProjectP.LProjectileSystem.BoxOverlapMultiByProfile
// 0x0048 (0x0048 - 0x0000)
struct LProjectileSystem_BoxOverlapMultiByProfile final
{
public:
	class ALProjectile*                           Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLOverlapResult>                OutOverlaps;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x0024(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0030(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x003C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectileSystem_BoxOverlapMultiByProfile) == 0x000008, "Wrong alignment on LProjectileSystem_BoxOverlapMultiByProfile");
static_assert(sizeof(LProjectileSystem_BoxOverlapMultiByProfile) == 0x000048, "Wrong size on LProjectileSystem_BoxOverlapMultiByProfile");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, Projectile) == 0x000000, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::Projectile' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, OutOverlaps) == 0x000008, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::OutOverlaps' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, Pos) == 0x000018, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::Pos' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, Rot) == 0x000024, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::Rot' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, Extent) == 0x000030, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::Extent' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, ProfileName) == 0x00003C, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_BoxOverlapMultiByProfile, ReturnValue) == 0x000044, "Member 'LProjectileSystem_BoxOverlapMultiByProfile::ReturnValue' has a wrong offset!");

// Function ProjectP.LProjectileSystem.SphereOverlapMultiByProfile
// 0x0040 (0x0040 - 0x0000)
struct LProjectileSystem_SphereOverlapMultiByProfile final
{
public:
	class ALProjectile*                           Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLOverlapResult>                OutOverlaps;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x0024(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0034(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LProjectileSystem_SphereOverlapMultiByProfile) == 0x000008, "Wrong alignment on LProjectileSystem_SphereOverlapMultiByProfile");
static_assert(sizeof(LProjectileSystem_SphereOverlapMultiByProfile) == 0x000040, "Wrong size on LProjectileSystem_SphereOverlapMultiByProfile");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, Projectile) == 0x000000, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::Projectile' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, OutOverlaps) == 0x000008, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::OutOverlaps' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, Pos) == 0x000018, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::Pos' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, Rot) == 0x000024, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::Rot' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, Radius) == 0x000030, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::Radius' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, ProfileName) == 0x000034, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(LProjectileSystem_SphereOverlapMultiByProfile, ReturnValue) == 0x00003C, "Member 'LProjectileSystem_SphereOverlapMultiByProfile::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpotProjectileSpawn_PeriodicHandler.Initialize
// 0x0060 (0x0060 - 0x0000)
struct LSpotProjectileSpawn_PeriodicHandler_Initialize final
{
public:
	class ALProjectilePropActor*                  InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLProjectilePropSpawnParameter         InSpawnInfo;                                       // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpotProjectileSpawn_PeriodicHandler_Initialize) == 0x000010, "Wrong alignment on LSpotProjectileSpawn_PeriodicHandler_Initialize");
static_assert(sizeof(LSpotProjectileSpawn_PeriodicHandler_Initialize) == 0x000060, "Wrong size on LSpotProjectileSpawn_PeriodicHandler_Initialize");
static_assert(offsetof(LSpotProjectileSpawn_PeriodicHandler_Initialize, InOwner) == 0x000000, "Member 'LSpotProjectileSpawn_PeriodicHandler_Initialize::InOwner' has a wrong offset!");
static_assert(offsetof(LSpotProjectileSpawn_PeriodicHandler_Initialize, InSpawnInfo) == 0x000010, "Member 'LSpotProjectileSpawn_PeriodicHandler_Initialize::InSpawnInfo' has a wrong offset!");

// Function ProjectP.LPropComponent.IsFixCameraOnInteraction
// 0x0001 (0x0001 - 0x0000)
struct LPropComponent_IsFixCameraOnInteraction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropComponent_IsFixCameraOnInteraction) == 0x000001, "Wrong alignment on LPropComponent_IsFixCameraOnInteraction");
static_assert(sizeof(LPropComponent_IsFixCameraOnInteraction) == 0x000001, "Wrong size on LPropComponent_IsFixCameraOnInteraction");
static_assert(offsetof(LPropComponent_IsFixCameraOnInteraction, ReturnValue) == 0x000000, "Member 'LPropComponent_IsFixCameraOnInteraction::ReturnValue' has a wrong offset!");

// Function ProjectP.LPropComponent.OnComponentBeginOverlapped_Interact
// 0x00A8 (0x00A8 - 0x0000)
struct LPropComponent_OnComponentBeginOverlapped_Interact final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OverlapInfo;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropComponent_OnComponentBeginOverlapped_Interact) == 0x000008, "Wrong alignment on LPropComponent_OnComponentBeginOverlapped_Interact");
static_assert(sizeof(LPropComponent_OnComponentBeginOverlapped_Interact) == 0x0000A8, "Wrong size on LPropComponent_OnComponentBeginOverlapped_Interact");
static_assert(offsetof(LPropComponent_OnComponentBeginOverlapped_Interact, OverlappedComp) == 0x000000, "Member 'LPropComponent_OnComponentBeginOverlapped_Interact::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentBeginOverlapped_Interact, Other) == 0x000008, "Member 'LPropComponent_OnComponentBeginOverlapped_Interact::Other' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentBeginOverlapped_Interact, OtherComp) == 0x000010, "Member 'LPropComponent_OnComponentBeginOverlapped_Interact::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentBeginOverlapped_Interact, OtherBodyIndex) == 0x000018, "Member 'LPropComponent_OnComponentBeginOverlapped_Interact::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentBeginOverlapped_Interact, bFromSweep) == 0x00001C, "Member 'LPropComponent_OnComponentBeginOverlapped_Interact::bFromSweep' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentBeginOverlapped_Interact, OverlapInfo) == 0x000020, "Member 'LPropComponent_OnComponentBeginOverlapped_Interact::OverlapInfo' has a wrong offset!");

// Function ProjectP.LPropComponent.OnComponentEndOverlapped_Interact
// 0x0020 (0x0020 - 0x0000)
struct LPropComponent_OnComponentEndOverlapped_Interact final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPropComponent_OnComponentEndOverlapped_Interact) == 0x000008, "Wrong alignment on LPropComponent_OnComponentEndOverlapped_Interact");
static_assert(sizeof(LPropComponent_OnComponentEndOverlapped_Interact) == 0x000020, "Wrong size on LPropComponent_OnComponentEndOverlapped_Interact");
static_assert(offsetof(LPropComponent_OnComponentEndOverlapped_Interact, OverlappedComp) == 0x000000, "Member 'LPropComponent_OnComponentEndOverlapped_Interact::OverlappedComp' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentEndOverlapped_Interact, Other) == 0x000008, "Member 'LPropComponent_OnComponentEndOverlapped_Interact::Other' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentEndOverlapped_Interact, OtherComp) == 0x000010, "Member 'LPropComponent_OnComponentEndOverlapped_Interact::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropComponent_OnComponentEndOverlapped_Interact, OtherBodyIndex) == 0x000018, "Member 'LPropComponent_OnComponentEndOverlapped_Interact::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LPropDestructionSpot.DoFracture
// 0x0001 (0x0001 - 0x0000)
struct LPropDestructionSpot_DoFracture final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropDestructionSpot_DoFracture) == 0x000001, "Wrong alignment on LPropDestructionSpot_DoFracture");
static_assert(sizeof(LPropDestructionSpot_DoFracture) == 0x000001, "Wrong size on LPropDestructionSpot_DoFracture");
static_assert(offsetof(LPropDestructionSpot_DoFracture, ReturnValue) == 0x000000, "Member 'LPropDestructionSpot_DoFracture::ReturnValue' has a wrong offset!");

// Function ProjectP.LPropDestructionSpot.SetCodeNameByBP
// 0x0008 (0x0008 - 0x0000)
struct LPropDestructionSpot_SetCodeNameByBP final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropDestructionSpot_SetCodeNameByBP) == 0x000004, "Wrong alignment on LPropDestructionSpot_SetCodeNameByBP");
static_assert(sizeof(LPropDestructionSpot_SetCodeNameByBP) == 0x000008, "Wrong size on LPropDestructionSpot_SetCodeNameByBP");
static_assert(offsetof(LPropDestructionSpot_SetCodeNameByBP, InCodeName) == 0x000000, "Member 'LPropDestructionSpot_SetCodeNameByBP::InCodeName' has a wrong offset!");

// Function ProjectP.LPropLadderSpot.GetPropLadderInfo
// 0x0010 (0x0010 - 0x0000)
struct LPropLadderSpot_GetPropLadderInfo final
{
public:
	int32                                         FindState;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPropLadderInfoPtr                     ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropLadderSpot_GetPropLadderInfo) == 0x000008, "Wrong alignment on LPropLadderSpot_GetPropLadderInfo");
static_assert(sizeof(LPropLadderSpot_GetPropLadderInfo) == 0x000010, "Wrong size on LPropLadderSpot_GetPropLadderInfo");
static_assert(offsetof(LPropLadderSpot_GetPropLadderInfo, FindState) == 0x000000, "Member 'LPropLadderSpot_GetPropLadderInfo::FindState' has a wrong offset!");
static_assert(offsetof(LPropLadderSpot_GetPropLadderInfo, ReturnValue) == 0x000008, "Member 'LPropLadderSpot_GetPropLadderInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LPropLiftSpot.OnComponentBeginOverlapPropLiftOverlapPawn
// 0x00A8 (0x00A8 - 0x0000)
struct LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn) == 0x000008, "Wrong alignment on LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn");
static_assert(sizeof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn) == 0x0000A8, "Wrong size on LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn, OverlappedComponent) == 0x000000, "Member 'LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn, OtherActor) == 0x000008, "Member 'LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn::OtherActor' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn, OtherComp) == 0x000010, "Member 'LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn, OtherBodyIndex) == 0x000018, "Member 'LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn, bFromSweep) == 0x00001C, "Member 'LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn::bFromSweep' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn, SweepResult) == 0x000020, "Member 'LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn::SweepResult' has a wrong offset!");

// Function ProjectP.LPropLiftSpot.OnComponentBeginOverlapSetLiftStartPoint
// 0x00A8 (0x00A8 - 0x0000)
struct LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint) == 0x000008, "Wrong alignment on LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint");
static_assert(sizeof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint) == 0x0000A8, "Wrong size on LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint, OverlappedComponent) == 0x000000, "Member 'LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint, OtherActor) == 0x000008, "Member 'LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint::OtherActor' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint, OtherComp) == 0x000010, "Member 'LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint, OtherBodyIndex) == 0x000018, "Member 'LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint, bFromSweep) == 0x00001C, "Member 'LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint::bFromSweep' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint, SweepResult) == 0x000020, "Member 'LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint::SweepResult' has a wrong offset!");

// Function ProjectP.LPropLiftSpot.OnComponentEndOverlapPropLiftOverlapPawn
// 0x0020 (0x0020 - 0x0000)
struct LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn) == 0x000008, "Wrong alignment on LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn");
static_assert(sizeof(LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn) == 0x000020, "Wrong size on LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn");
static_assert(offsetof(LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn, OverlappedComponent) == 0x000000, "Member 'LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn, OtherActor) == 0x000008, "Member 'LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn::OtherActor' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn, OtherComp) == 0x000010, "Member 'LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn::OtherComp' has a wrong offset!");
static_assert(offsetof(LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn, OtherBodyIndex) == 0x000018, "Member 'LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LQuartzSystem.CheckCanResetAllQuartz
// 0x0002 (0x0002 - 0x0000)
struct LQuartzSystem_CheckCanResetAllQuartz final
{
public:
	bool                                          bIgnoreRequirements;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_CheckCanResetAllQuartz) == 0x000001, "Wrong alignment on LQuartzSystem_CheckCanResetAllQuartz");
static_assert(sizeof(LQuartzSystem_CheckCanResetAllQuartz) == 0x000002, "Wrong size on LQuartzSystem_CheckCanResetAllQuartz");
static_assert(offsetof(LQuartzSystem_CheckCanResetAllQuartz, bIgnoreRequirements) == 0x000000, "Member 'LQuartzSystem_CheckCanResetAllQuartz::bIgnoreRequirements' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_CheckCanResetAllQuartz, ReturnValue) == 0x000001, "Member 'LQuartzSystem_CheckCanResetAllQuartz::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetPocketData
// 0x0010 (0x0010 - 0x0000)
struct LQuartzSystem_GetPocketData final
{
public:
	class FName                                   PocketCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULQuartzPocket*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetPocketData) == 0x000008, "Wrong alignment on LQuartzSystem_GetPocketData");
static_assert(sizeof(LQuartzSystem_GetPocketData) == 0x000010, "Wrong size on LQuartzSystem_GetPocketData");
static_assert(offsetof(LQuartzSystem_GetPocketData, PocketCodeName) == 0x000000, "Member 'LQuartzSystem_GetPocketData::PocketCodeName' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_GetPocketData, ReturnValue) == 0x000008, "Member 'LQuartzSystem_GetPocketData::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetPocketDataByIndex
// 0x0010 (0x0010 - 0x0000)
struct LQuartzSystem_GetPocketDataByIndex final
{
public:
	int32                                         InPocketIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULQuartzPocket*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetPocketDataByIndex) == 0x000008, "Wrong alignment on LQuartzSystem_GetPocketDataByIndex");
static_assert(sizeof(LQuartzSystem_GetPocketDataByIndex) == 0x000010, "Wrong size on LQuartzSystem_GetPocketDataByIndex");
static_assert(offsetof(LQuartzSystem_GetPocketDataByIndex, InPocketIndex) == 0x000000, "Member 'LQuartzSystem_GetPocketDataByIndex::InPocketIndex' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_GetPocketDataByIndex, ReturnValue) == 0x000008, "Member 'LQuartzSystem_GetPocketDataByIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetQuartzEffect
// 0x0010 (0x0010 - 0x0000)
struct LQuartzSystem_GetQuartzEffect final
{
public:
	class FName                                   QuartzEffectCodeName;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULQuartzEffect*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetQuartzEffect) == 0x000008, "Wrong alignment on LQuartzSystem_GetQuartzEffect");
static_assert(sizeof(LQuartzSystem_GetQuartzEffect) == 0x000010, "Wrong size on LQuartzSystem_GetQuartzEffect");
static_assert(offsetof(LQuartzSystem_GetQuartzEffect, QuartzEffectCodeName) == 0x000000, "Member 'LQuartzSystem_GetQuartzEffect::QuartzEffectCodeName' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_GetQuartzEffect, ReturnValue) == 0x000008, "Member 'LQuartzSystem_GetQuartzEffect::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetRequireItemsForReset
// 0x0050 (0x0050 - 0x0000)
struct LQuartzSystem_GetRequireItemsForReset final
{
public:
	TMap<class FName, int32>                      OutRequireItems;                                   // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetRequireItemsForReset) == 0x000008, "Wrong alignment on LQuartzSystem_GetRequireItemsForReset");
static_assert(sizeof(LQuartzSystem_GetRequireItemsForReset) == 0x000050, "Wrong size on LQuartzSystem_GetRequireItemsForReset");
static_assert(offsetof(LQuartzSystem_GetRequireItemsForReset, OutRequireItems) == 0x000000, "Member 'LQuartzSystem_GetRequireItemsForReset::OutRequireItems' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetReturnItemsAfterReset
// 0x0050 (0x0050 - 0x0000)
struct LQuartzSystem_GetReturnItemsAfterReset final
{
public:
	TMap<class FName, int32>                      OutReturnItems;                                    // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetReturnItemsAfterReset) == 0x000008, "Wrong alignment on LQuartzSystem_GetReturnItemsAfterReset");
static_assert(sizeof(LQuartzSystem_GetReturnItemsAfterReset) == 0x000050, "Wrong size on LQuartzSystem_GetReturnItemsAfterReset");
static_assert(offsetof(LQuartzSystem_GetReturnItemsAfterReset, OutReturnItems) == 0x000000, "Member 'LQuartzSystem_GetReturnItemsAfterReset::OutReturnItems' has a wrong offset!");

// Function ProjectP.LQuartzSystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LQuartzSystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LQuartzSystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LQuartzSystem_OnGameDataCharacterSync");
static_assert(sizeof(LQuartzSystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LQuartzSystem_OnGameDataCharacterSync");
static_assert(offsetof(LQuartzSystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LQuartzSystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LQuartzSystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LQuartzSystem.RequestResetAllQuartz
// 0x0002 (0x0002 - 0x0000)
struct LQuartzSystem_RequestResetAllQuartz final
{
public:
	bool                                          bIgnoreRequirements;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_RequestResetAllQuartz) == 0x000001, "Wrong alignment on LQuartzSystem_RequestResetAllQuartz");
static_assert(sizeof(LQuartzSystem_RequestResetAllQuartz) == 0x000002, "Wrong size on LQuartzSystem_RequestResetAllQuartz");
static_assert(offsetof(LQuartzSystem_RequestResetAllQuartz, bIgnoreRequirements) == 0x000000, "Member 'LQuartzSystem_RequestResetAllQuartz::bIgnoreRequirements' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_RequestResetAllQuartz, ReturnValue) == 0x000001, "Member 'LQuartzSystem_RequestResetAllQuartz::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.RequestUpgradeCoreLevel
// 0x0001 (0x0001 - 0x0000)
struct LQuartzSystem_RequestUpgradeCoreLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_RequestUpgradeCoreLevel) == 0x000001, "Wrong alignment on LQuartzSystem_RequestUpgradeCoreLevel");
static_assert(sizeof(LQuartzSystem_RequestUpgradeCoreLevel) == 0x000001, "Wrong size on LQuartzSystem_RequestUpgradeCoreLevel");
static_assert(offsetof(LQuartzSystem_RequestUpgradeCoreLevel, ReturnValue) == 0x000000, "Member 'LQuartzSystem_RequestUpgradeCoreLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.ResetAllQuartz
// 0x0002 (0x0002 - 0x0000)
struct LQuartzSystem_ResetAllQuartz final
{
public:
	bool                                          bForceReset;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewgamePlus;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_ResetAllQuartz) == 0x000001, "Wrong alignment on LQuartzSystem_ResetAllQuartz");
static_assert(sizeof(LQuartzSystem_ResetAllQuartz) == 0x000002, "Wrong size on LQuartzSystem_ResetAllQuartz");
static_assert(offsetof(LQuartzSystem_ResetAllQuartz, bForceReset) == 0x000000, "Member 'LQuartzSystem_ResetAllQuartz::bForceReset' has a wrong offset!");
static_assert(offsetof(LQuartzSystem_ResetAllQuartz, bNewgamePlus) == 0x000001, "Member 'LQuartzSystem_ResetAllQuartz::bNewgamePlus' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetCoreItemCount
// 0x0004 (0x0004 - 0x0000)
struct LQuartzSystem_GetCoreItemCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetCoreItemCount) == 0x000004, "Wrong alignment on LQuartzSystem_GetCoreItemCount");
static_assert(sizeof(LQuartzSystem_GetCoreItemCount) == 0x000004, "Wrong size on LQuartzSystem_GetCoreItemCount");
static_assert(offsetof(LQuartzSystem_GetCoreItemCount, ReturnValue) == 0x000000, "Member 'LQuartzSystem_GetCoreItemCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetEnabledCoreLevel
// 0x0004 (0x0004 - 0x0000)
struct LQuartzSystem_GetEnabledCoreLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetEnabledCoreLevel) == 0x000004, "Wrong alignment on LQuartzSystem_GetEnabledCoreLevel");
static_assert(sizeof(LQuartzSystem_GetEnabledCoreLevel) == 0x000004, "Wrong size on LQuartzSystem_GetEnabledCoreLevel");
static_assert(offsetof(LQuartzSystem_GetEnabledCoreLevel, ReturnValue) == 0x000000, "Member 'LQuartzSystem_GetEnabledCoreLevel::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetEnabledQuartzMenu
// 0x0001 (0x0001 - 0x0000)
struct LQuartzSystem_GetEnabledQuartzMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetEnabledQuartzMenu) == 0x000001, "Wrong alignment on LQuartzSystem_GetEnabledQuartzMenu");
static_assert(sizeof(LQuartzSystem_GetEnabledQuartzMenu) == 0x000001, "Wrong size on LQuartzSystem_GetEnabledQuartzMenu");
static_assert(offsetof(LQuartzSystem_GetEnabledQuartzMenu, ReturnValue) == 0x000000, "Member 'LQuartzSystem_GetEnabledQuartzMenu::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetMaxLevelLimit
// 0x0004 (0x0004 - 0x0000)
struct LQuartzSystem_GetMaxLevelLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetMaxLevelLimit) == 0x000004, "Wrong alignment on LQuartzSystem_GetMaxLevelLimit");
static_assert(sizeof(LQuartzSystem_GetMaxLevelLimit) == 0x000004, "Wrong size on LQuartzSystem_GetMaxLevelLimit");
static_assert(offsetof(LQuartzSystem_GetMaxLevelLimit, ReturnValue) == 0x000000, "Member 'LQuartzSystem_GetMaxLevelLimit::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuartzSystem.GetQuartzItemCount
// 0x0004 (0x0004 - 0x0000)
struct LQuartzSystem_GetQuartzItemCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LQuartzSystem_GetQuartzItemCount) == 0x000004, "Wrong alignment on LQuartzSystem_GetQuartzItemCount");
static_assert(sizeof(LQuartzSystem_GetQuartzItemCount) == 0x000004, "Wrong size on LQuartzSystem_GetQuartzItemCount");
static_assert(offsetof(LQuartzSystem_GetQuartzItemCount, ReturnValue) == 0x000000, "Member 'LQuartzSystem_GetQuartzItemCount::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuestSystem.GetQuestIconFromTeleportName
// 0x0020 (0x0020 - 0x0000)
struct LQuestSystem_GetQuestIconFromTeleportName final
{
public:
	class FName                                   FindTeleport;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObject>>         OutQuestIconList;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LQuestSystem_GetQuestIconFromTeleportName) == 0x000008, "Wrong alignment on LQuestSystem_GetQuestIconFromTeleportName");
static_assert(sizeof(LQuestSystem_GetQuestIconFromTeleportName) == 0x000020, "Wrong size on LQuestSystem_GetQuestIconFromTeleportName");
static_assert(offsetof(LQuestSystem_GetQuestIconFromTeleportName, FindTeleport) == 0x000000, "Member 'LQuestSystem_GetQuestIconFromTeleportName::FindTeleport' has a wrong offset!");
static_assert(offsetof(LQuestSystem_GetQuestIconFromTeleportName, OutQuestIconList) == 0x000008, "Member 'LQuestSystem_GetQuestIconFromTeleportName::OutQuestIconList' has a wrong offset!");
static_assert(offsetof(LQuestSystem_GetQuestIconFromTeleportName, ReturnValue) == 0x000018, "Member 'LQuestSystem_GetQuestIconFromTeleportName::ReturnValue' has a wrong offset!");

// Function ProjectP.LQuestSystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LQuestSystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LQuestSystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LQuestSystem_OnGameDataCharacterSync");
static_assert(sizeof(LQuestSystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LQuestSystem_OnGameDataCharacterSync");
static_assert(offsetof(LQuestSystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LQuestSystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LQuestSystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LQuestSystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.RichImageRowFunctionLibrary.GetImage
// 0x0098 (0x0098 - 0x0000)
struct RichImageRowFunctionLibrary_GetImage final
{
public:
	struct FRichImageRow                          Row;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RichImageRowFunctionLibrary_GetImage) == 0x000008, "Wrong alignment on RichImageRowFunctionLibrary_GetImage");
static_assert(sizeof(RichImageRowFunctionLibrary_GetImage) == 0x000098, "Wrong size on RichImageRowFunctionLibrary_GetImage");
static_assert(offsetof(RichImageRowFunctionLibrary_GetImage, Row) == 0x000000, "Member 'RichImageRowFunctionLibrary_GetImage::Row' has a wrong offset!");
static_assert(offsetof(RichImageRowFunctionLibrary_GetImage, ReturnValue) == 0x000090, "Member 'RichImageRowFunctionLibrary_GetImage::ReturnValue' has a wrong offset!");

// Function ProjectP.LSaveGameSystem.LoadGameDelegateFunction
// 0x0020 (0x0020 - 0x0000)
struct LSaveGameSystem_LoadGameDelegateFunction final
{
public:
	class FString                                 InSlotName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InUserIndex;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveGame*                              LoadedSave;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSaveGameSystem_LoadGameDelegateFunction) == 0x000008, "Wrong alignment on LSaveGameSystem_LoadGameDelegateFunction");
static_assert(sizeof(LSaveGameSystem_LoadGameDelegateFunction) == 0x000020, "Wrong size on LSaveGameSystem_LoadGameDelegateFunction");
static_assert(offsetof(LSaveGameSystem_LoadGameDelegateFunction, InSlotName) == 0x000000, "Member 'LSaveGameSystem_LoadGameDelegateFunction::InSlotName' has a wrong offset!");
static_assert(offsetof(LSaveGameSystem_LoadGameDelegateFunction, InUserIndex) == 0x000010, "Member 'LSaveGameSystem_LoadGameDelegateFunction::InUserIndex' has a wrong offset!");
static_assert(offsetof(LSaveGameSystem_LoadGameDelegateFunction, LoadedSave) == 0x000018, "Member 'LSaveGameSystem_LoadGameDelegateFunction::LoadedSave' has a wrong offset!");

// Function ProjectP.LSaveGameSystem.SaveGameDelegateFunction
// 0x0018 (0x0018 - 0x0000)
struct LSaveGameSystem_SaveGameDelegateFunction final
{
public:
	class FString                                 InSlotName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InUserIndex;                                       // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSaveGameSystem_SaveGameDelegateFunction) == 0x000008, "Wrong alignment on LSaveGameSystem_SaveGameDelegateFunction");
static_assert(sizeof(LSaveGameSystem_SaveGameDelegateFunction) == 0x000018, "Wrong size on LSaveGameSystem_SaveGameDelegateFunction");
static_assert(offsetof(LSaveGameSystem_SaveGameDelegateFunction, InSlotName) == 0x000000, "Member 'LSaveGameSystem_SaveGameDelegateFunction::InSlotName' has a wrong offset!");
static_assert(offsetof(LSaveGameSystem_SaveGameDelegateFunction, InUserIndex) == 0x000010, "Member 'LSaveGameSystem_SaveGameDelegateFunction::InUserIndex' has a wrong offset!");
static_assert(offsetof(LSaveGameSystem_SaveGameDelegateFunction, bSuccess) == 0x000014, "Member 'LSaveGameSystem_SaveGameDelegateFunction::bSuccess' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.CheckCanReset
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmPage_CheckCanReset final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_CheckCanReset) == 0x000001, "Wrong alignment on LSlaveArmPage_CheckCanReset");
static_assert(sizeof(LSlaveArmPage_CheckCanReset) == 0x000001, "Wrong size on LSlaveArmPage_CheckCanReset");
static_assert(offsetof(LSlaveArmPage_CheckCanReset, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_CheckCanReset::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.GetCanReset
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmPage_GetCanReset final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_GetCanReset) == 0x000001, "Wrong alignment on LSlaveArmPage_GetCanReset");
static_assert(sizeof(LSlaveArmPage_GetCanReset) == 0x000001, "Wrong size on LSlaveArmPage_GetCanReset");
static_assert(offsetof(LSlaveArmPage_GetCanReset, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_GetCanReset::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.GetRequireItemsToReset
// 0x0050 (0x0050 - 0x0000)
struct LSlaveArmPage_GetRequireItemsToReset final
{
public:
	TMap<class FName, int32>                      ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_GetRequireItemsToReset) == 0x000008, "Wrong alignment on LSlaveArmPage_GetRequireItemsToReset");
static_assert(sizeof(LSlaveArmPage_GetRequireItemsToReset) == 0x000050, "Wrong size on LSlaveArmPage_GetRequireItemsToReset");
static_assert(offsetof(LSlaveArmPage_GetRequireItemsToReset, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_GetRequireItemsToReset::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.GetReturnItemsAfterReset
// 0x0050 (0x0050 - 0x0000)
struct LSlaveArmPage_GetReturnItemsAfterReset final
{
public:
	TMap<class FName, int32>                      ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_GetReturnItemsAfterReset) == 0x000008, "Wrong alignment on LSlaveArmPage_GetReturnItemsAfterReset");
static_assert(sizeof(LSlaveArmPage_GetReturnItemsAfterReset) == 0x000050, "Wrong size on LSlaveArmPage_GetReturnItemsAfterReset");
static_assert(offsetof(LSlaveArmPage_GetReturnItemsAfterReset, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_GetReturnItemsAfterReset::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.IsFullyReinforced
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmPage_IsFullyReinforced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_IsFullyReinforced) == 0x000001, "Wrong alignment on LSlaveArmPage_IsFullyReinforced");
static_assert(sizeof(LSlaveArmPage_IsFullyReinforced) == 0x000001, "Wrong size on LSlaveArmPage_IsFullyReinforced");
static_assert(offsetof(LSlaveArmPage_IsFullyReinforced, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_IsFullyReinforced::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.RequestReset
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmPage_RequestReset final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_RequestReset) == 0x000001, "Wrong alignment on LSlaveArmPage_RequestReset");
static_assert(sizeof(LSlaveArmPage_RequestReset) == 0x000001, "Wrong size on LSlaveArmPage_RequestReset");
static_assert(offsetof(LSlaveArmPage_RequestReset, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_RequestReset::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.Reset
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmPage_Reset final
{
public:
	bool                                          bForceReset;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_Reset) == 0x000001, "Wrong alignment on LSlaveArmPage_Reset");
static_assert(sizeof(LSlaveArmPage_Reset) == 0x000001, "Wrong size on LSlaveArmPage_Reset");
static_assert(offsetof(LSlaveArmPage_Reset, bForceReset) == 0x000000, "Member 'LSlaveArmPage_Reset::bForceReset' has a wrong offset!");

// Function ProjectP.LSlaveArmPage.GetNextReinforceTree
// 0x0008 (0x0008 - 0x0000)
struct LSlaveArmPage_GetNextReinforceTree final
{
public:
	class ULSlaveArmTree*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmPage_GetNextReinforceTree) == 0x000008, "Wrong alignment on LSlaveArmPage_GetNextReinforceTree");
static_assert(sizeof(LSlaveArmPage_GetNextReinforceTree) == 0x000008, "Wrong size on LSlaveArmPage_GetNextReinforceTree");
static_assert(offsetof(LSlaveArmPage_GetNextReinforceTree, ReturnValue) == 0x000000, "Member 'LSlaveArmPage_GetNextReinforceTree::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.CheckHaveEnoughMagazinePoint
// 0x0001 (0x0001 - 0x0000)
struct LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint) == 0x000001, "Wrong alignment on LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint");
static_assert(sizeof(LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint) == 0x000001, "Wrong size on LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint");
static_assert(offsetof(LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint, ReturnValue) == 0x000000, "Member 'LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.FindTreeByCodeName
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_FindTreeByCodeName final
{
public:
	class FName                                   SlaveArmTreeCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULSlaveArmTree*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_FindTreeByCodeName) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_FindTreeByCodeName");
static_assert(sizeof(LSlaveArmReinforcementSystem_FindTreeByCodeName) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_FindTreeByCodeName");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByCodeName, SlaveArmTreeCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_FindTreeByCodeName::SlaveArmTreeCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByCodeName, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_FindTreeByCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.FindTreeByDepth
// 0x0018 (0x0018 - 0x0000)
struct LSlaveArmReinforcementSystem_FindTreeByDepth final
{
public:
	class FName                                   SlaveArmItemCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Depth;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULSlaveArmTree*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_FindTreeByDepth) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_FindTreeByDepth");
static_assert(sizeof(LSlaveArmReinforcementSystem_FindTreeByDepth) == 0x000018, "Wrong size on LSlaveArmReinforcementSystem_FindTreeByDepth");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByDepth, SlaveArmItemCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_FindTreeByDepth::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByDepth, Depth) == 0x000008, "Member 'LSlaveArmReinforcementSystem_FindTreeByDepth::Depth' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByDepth, ReturnValue) == 0x000010, "Member 'LSlaveArmReinforcementSystem_FindTreeByDepth::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.FindTreeByPageCodeName
// 0x0018 (0x0018 - 0x0000)
struct LSlaveArmReinforcementSystem_FindTreeByPageCodeName final
{
public:
	class FName                                   SlaveArmPageCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULSlaveArmTree*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_FindTreeByPageCodeName) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_FindTreeByPageCodeName");
static_assert(sizeof(LSlaveArmReinforcementSystem_FindTreeByPageCodeName) == 0x000018, "Wrong size on LSlaveArmReinforcementSystem_FindTreeByPageCodeName");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByPageCodeName, SlaveArmPageCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_FindTreeByPageCodeName::SlaveArmPageCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_FindTreeByPageCodeName, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_FindTreeByPageCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetConsumeMagazinePointMultiplier
// 0x000C (0x000C - 0x0000)
struct LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier final
{
public:
	class FName                                   SlaveArmCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier) == 0x00000C, "Wrong size on LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier, SlaveArmCodeName) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier::SlaveArmCodeName' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetIncreasedAmmo
// 0x000C (0x000C - 0x0000)
struct LSlaveArmReinforcementSystem_GetIncreasedAmmo final
{
public:
	class FName                                   ItemSlaveArmCodeName;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetIncreasedAmmo) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_GetIncreasedAmmo");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetIncreasedAmmo) == 0x00000C, "Wrong size on LSlaveArmReinforcementSystem_GetIncreasedAmmo");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetIncreasedAmmo, ItemSlaveArmCodeName) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetIncreasedAmmo::ItemSlaveArmCodeName' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetIncreasedAmmo, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetIncreasedAmmo::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetReinforcedHitIndex
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_GetReinforcedHitIndex final
{
public:
	class FName                                   SlaveArmItemCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseHitIndex;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetReinforcedHitIndex) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_GetReinforcedHitIndex");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetReinforcedHitIndex) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_GetReinforcedHitIndex");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcedHitIndex, SlaveArmItemCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetReinforcedHitIndex::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcedHitIndex, BaseHitIndex) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetReinforcedHitIndex::BaseHitIndex' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcedHitIndex, ReturnValue) == 0x00000C, "Member 'LSlaveArmReinforcementSystem_GetReinforcedHitIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetReinforcedProjectile
// 0x0018 (0x0018 - 0x0000)
struct LSlaveArmReinforcementSystem_GetReinforcedProjectile final
{
public:
	class FName                                   SlaveArmItemCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BaseProjectileID;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetReinforcedProjectile) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_GetReinforcedProjectile");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetReinforcedProjectile) == 0x000018, "Wrong size on LSlaveArmReinforcementSystem_GetReinforcedProjectile");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcedProjectile, SlaveArmItemCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetReinforcedProjectile::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcedProjectile, BaseProjectileID) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetReinforcedProjectile::BaseProjectileID' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcedProjectile, ReturnValue) == 0x000010, "Member 'LSlaveArmReinforcementSystem_GetReinforcedProjectile::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetReinforcementInfoList
// 0x0018 (0x0018 - 0x0000)
struct LSlaveArmReinforcementSystem_GetReinforcementInfoList final
{
public:
	class FName                                   SlavearmReinforcementInfoname;                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSlaveArmReinforcementInfoPtr>  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetReinforcementInfoList) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_GetReinforcementInfoList");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetReinforcementInfoList) == 0x000018, "Wrong size on LSlaveArmReinforcementSystem_GetReinforcementInfoList");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcementInfoList, SlavearmReinforcementInfoname) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetReinforcementInfoList::SlavearmReinforcementInfoname' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetReinforcementInfoList, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetReinforcementInfoList::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmPage
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmPage final
{
public:
	class FName                                   SlaveArmPageCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULSlaveArmPage*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmPage) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmPage");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmPage) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmPage");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmPage, SlaveArmPageCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmPage::SlaveArmPageCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmPage, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmPage::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmPageBySlaveArmCodeName
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName final
{
public:
	class FName                                   SlaveArmItemCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULSlaveArmPage*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName, SlaveArmItemCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmPageList
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmPageList final
{
public:
	TArray<class ULSlaveArmPage*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmPageList) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmPageList");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmPageList) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmPageList");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmPageList, ReturnValue) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmPageList::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmSkillCodeName
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName final
{
public:
	class FName                                   SlaveArmItemCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName, SlaveArmItemCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmStat
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmStat final
{
public:
	class FName                                   ItemSlaveArmCodeName;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  InStat;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmStat) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmStat");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmStat) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmStat");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmStat, ItemSlaveArmCodeName) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmStat::ItemSlaveArmCodeName' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmStat, InStat) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmStat::InStat' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmStat, ReturnValue) == 0x00000C, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmTreeListByPageCodeName
// 0x0018 (0x0018 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName final
{
public:
	class FName                                   SlaveArmPageCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULSlaveArmTree*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName) == 0x000018, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName, SlaveArmPageCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName::SlaveArmPageCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmTreeListBySlaveArmCodeName
// 0x0018 (0x0018 - 0x0000)
struct LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName final
{
public:
	class FName                                   SlaveArmItemCodename;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULSlaveArmTree*>                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName");
static_assert(sizeof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName) == 0x000018, "Wrong size on LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName, SlaveArmItemCodename) == 0x000000, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName::SlaveArmItemCodename' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.HasReinforcement
// 0x000C (0x000C - 0x0000)
struct LSlaveArmReinforcementSystem_HasReinforcement final
{
public:
	class FName                                   SlaveArmReinfocementCodeName;                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSlaveArmReinforcementSystem_HasReinforcement) == 0x000004, "Wrong alignment on LSlaveArmReinforcementSystem_HasReinforcement");
static_assert(sizeof(LSlaveArmReinforcementSystem_HasReinforcement) == 0x00000C, "Wrong size on LSlaveArmReinforcementSystem_HasReinforcement");
static_assert(offsetof(LSlaveArmReinforcementSystem_HasReinforcement, SlaveArmReinfocementCodeName) == 0x000000, "Member 'LSlaveArmReinforcementSystem_HasReinforcement::SlaveArmReinfocementCodeName' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_HasReinforcement, ReturnValue) == 0x000008, "Member 'LSlaveArmReinforcementSystem_HasReinforcement::ReturnValue' has a wrong offset!");

// Function ProjectP.LSlaveArmReinforcementSystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LSlaveArmReinforcementSystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSlaveArmReinforcementSystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LSlaveArmReinforcementSystem_OnGameDataCharacterSync");
static_assert(sizeof(LSlaveArmReinforcementSystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LSlaveArmReinforcementSystem_OnGameDataCharacterSync");
static_assert(offsetof(LSlaveArmReinforcementSystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LSlaveArmReinforcementSystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LSlaveArmReinforcementSystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LSlaveArmReinforcementSystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LSoundSystemData.GetBaseSoundMix
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystemData_GetBaseSoundMix final
{
public:
	class USoundMix*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystemData_GetBaseSoundMix) == 0x000008, "Wrong alignment on LSoundSystemData_GetBaseSoundMix");
static_assert(sizeof(LSoundSystemData_GetBaseSoundMix) == 0x000008, "Wrong size on LSoundSystemData_GetBaseSoundMix");
static_assert(offsetof(LSoundSystemData_GetBaseSoundMix, ReturnValue) == 0x000000, "Member 'LSoundSystemData_GetBaseSoundMix::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystemData.GetGlobalMuteSoundMixes
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystemData_GetGlobalMuteSoundMixes final
{
public:
	TArray<class USoundMix*>                      MuteMixes;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystemData_GetGlobalMuteSoundMixes) == 0x000008, "Wrong alignment on LSoundSystemData_GetGlobalMuteSoundMixes");
static_assert(sizeof(LSoundSystemData_GetGlobalMuteSoundMixes) == 0x000010, "Wrong size on LSoundSystemData_GetGlobalMuteSoundMixes");
static_assert(offsetof(LSoundSystemData_GetGlobalMuteSoundMixes, MuteMixes) == 0x000000, "Member 'LSoundSystemData_GetGlobalMuteSoundMixes::MuteMixes' has a wrong offset!");

// Function ProjectP.LSoundSystemData.GetSoundVolumeFadeTime
// 0x0004 (0x0004 - 0x0000)
struct LSoundSystemData_GetSoundVolumeFadeTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystemData_GetSoundVolumeFadeTime) == 0x000004, "Wrong alignment on LSoundSystemData_GetSoundVolumeFadeTime");
static_assert(sizeof(LSoundSystemData_GetSoundVolumeFadeTime) == 0x000004, "Wrong size on LSoundSystemData_GetSoundVolumeFadeTime");
static_assert(offsetof(LSoundSystemData_GetSoundVolumeFadeTime, ReturnValue) == 0x000000, "Member 'LSoundSystemData_GetSoundVolumeFadeTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystemData.OnFadeMuteSound
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystemData_OnFadeMuteSound final
{
public:
	bool                                          bMute;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystemData_OnFadeMuteSound) == 0x000001, "Wrong alignment on LSoundSystemData_OnFadeMuteSound");
static_assert(sizeof(LSoundSystemData_OnFadeMuteSound) == 0x000001, "Wrong size on LSoundSystemData_OnFadeMuteSound");
static_assert(offsetof(LSoundSystemData_OnFadeMuteSound, bMute) == 0x000000, "Member 'LSoundSystemData_OnFadeMuteSound::bMute' has a wrong offset!");

// Function ProjectP.LSoundSystemData.OnPlayBGM
// 0x000C (0x000C - 0x0000)
struct LSoundSystemData_OnPlayBGM final
{
public:
	class FName                                   SoundName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayResult;                                        // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystemData_OnPlayBGM) == 0x000004, "Wrong alignment on LSoundSystemData_OnPlayBGM");
static_assert(sizeof(LSoundSystemData_OnPlayBGM) == 0x00000C, "Wrong size on LSoundSystemData_OnPlayBGM");
static_assert(offsetof(LSoundSystemData_OnPlayBGM, SoundName) == 0x000000, "Member 'LSoundSystemData_OnPlayBGM::SoundName' has a wrong offset!");
static_assert(offsetof(LSoundSystemData_OnPlayBGM, PlayResult) == 0x000008, "Member 'LSoundSystemData_OnPlayBGM::PlayResult' has a wrong offset!");

// Function ProjectP.LSoundSystemData.OnPlayDialogSound
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystemData_OnPlayDialogSound final
{
public:
	struct FDialogInfoPtr                         InDialog;                                          // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystemData_OnPlayDialogSound) == 0x000008, "Wrong alignment on LSoundSystemData_OnPlayDialogSound");
static_assert(sizeof(LSoundSystemData_OnPlayDialogSound) == 0x000010, "Wrong size on LSoundSystemData_OnPlayDialogSound");
static_assert(offsetof(LSoundSystemData_OnPlayDialogSound, InDialog) == 0x000000, "Member 'LSoundSystemData_OnPlayDialogSound::InDialog' has a wrong offset!");
static_assert(offsetof(LSoundSystemData_OnPlayDialogSound, ReturnValue) == 0x000008, "Member 'LSoundSystemData_OnPlayDialogSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystemData.OnPlayRecord
// 0x0018 (0x0018 - 0x0000)
struct LSoundSystemData_OnPlayRecord final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPropSpot*                             InSoundSource;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystemData_OnPlayRecord) == 0x000008, "Wrong alignment on LSoundSystemData_OnPlayRecord");
static_assert(sizeof(LSoundSystemData_OnPlayRecord) == 0x000018, "Wrong size on LSoundSystemData_OnPlayRecord");
static_assert(offsetof(LSoundSystemData_OnPlayRecord, RecordCodeName) == 0x000000, "Member 'LSoundSystemData_OnPlayRecord::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystemData_OnPlayRecord, InSoundSource) == 0x000008, "Member 'LSoundSystemData_OnPlayRecord::InSoundSource' has a wrong offset!");
static_assert(offsetof(LSoundSystemData_OnPlayRecord, ReturnValue) == 0x000010, "Member 'LSoundSystemData_OnPlayRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystemData.OnStopDialogSound
// 0x0002 (0x0002 - 0x0000)
struct LSoundSystemData_OnStopDialogSound final
{
public:
	bool                                          SkipFadeOut;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystemData_OnStopDialogSound) == 0x000001, "Wrong alignment on LSoundSystemData_OnStopDialogSound");
static_assert(sizeof(LSoundSystemData_OnStopDialogSound) == 0x000002, "Wrong size on LSoundSystemData_OnStopDialogSound");
static_assert(offsetof(LSoundSystemData_OnStopDialogSound, SkipFadeOut) == 0x000000, "Member 'LSoundSystemData_OnStopDialogSound::SkipFadeOut' has a wrong offset!");
static_assert(offsetof(LSoundSystemData_OnStopDialogSound, ReturnValue) == 0x000001, "Member 'LSoundSystemData_OnStopDialogSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystemData.OnStopRecord
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystemData_OnStopRecord final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystemData_OnStopRecord) == 0x000001, "Wrong alignment on LSoundSystemData_OnStopRecord");
static_assert(sizeof(LSoundSystemData_OnStopRecord) == 0x000001, "Wrong size on LSoundSystemData_OnStopRecord");
static_assert(offsetof(LSoundSystemData_OnStopRecord, ReturnValue) == 0x000000, "Member 'LSoundSystemData_OnStopRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.AcquireHumanityRecord
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_AcquireHumanityRecord final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_AcquireHumanityRecord) == 0x000004, "Wrong alignment on LSoundSystem_AcquireHumanityRecord");
static_assert(sizeof(LSoundSystem_AcquireHumanityRecord) == 0x00000C, "Wrong size on LSoundSystem_AcquireHumanityRecord");
static_assert(offsetof(LSoundSystem_AcquireHumanityRecord, RecordCodeName) == 0x000000, "Member 'LSoundSystem_AcquireHumanityRecord::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_AcquireHumanityRecord, ReturnValue) == 0x000008, "Member 'LSoundSystem_AcquireHumanityRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.AddSoundControlComponentToRefresh
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_AddSoundControlComponentToRefresh final
{
public:
	class ULSoundControlComponent*                Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_AddSoundControlComponentToRefresh) == 0x000008, "Wrong alignment on LSoundSystem_AddSoundControlComponentToRefresh");
static_assert(sizeof(LSoundSystem_AddSoundControlComponentToRefresh) == 0x000008, "Wrong size on LSoundSystem_AddSoundControlComponentToRefresh");
static_assert(offsetof(LSoundSystem_AddSoundControlComponentToRefresh, Comp) == 0x000000, "Member 'LSoundSystem_AddSoundControlComponentToRefresh::Comp' has a wrong offset!");

// Function ProjectP.LSoundSystem.CheckPlayBGM_FromNpc
// 0x0014 (0x0014 - 0x0000)
struct LSoundSystem_CheckPlayBGM_FromNpc final
{
public:
	class FName                                   NpcName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSoundNameUI;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_CheckPlayBGM_FromNpc) == 0x000004, "Wrong alignment on LSoundSystem_CheckPlayBGM_FromNpc");
static_assert(sizeof(LSoundSystem_CheckPlayBGM_FromNpc) == 0x000014, "Wrong size on LSoundSystem_CheckPlayBGM_FromNpc");
static_assert(offsetof(LSoundSystem_CheckPlayBGM_FromNpc, NpcName) == 0x000000, "Member 'LSoundSystem_CheckPlayBGM_FromNpc::NpcName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_CheckPlayBGM_FromNpc, SoundName) == 0x000008, "Member 'LSoundSystem_CheckPlayBGM_FromNpc::SoundName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_CheckPlayBGM_FromNpc, bShowSoundNameUI) == 0x000010, "Member 'LSoundSystem_CheckPlayBGM_FromNpc::bShowSoundNameUI' has a wrong offset!");

// Function ProjectP.LSoundSystem.CheckStopBGM
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_CheckStopBGM final
{
public:
	class FName                                   SoundName;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_CheckStopBGM) == 0x000004, "Wrong alignment on LSoundSystem_CheckStopBGM");
static_assert(sizeof(LSoundSystem_CheckStopBGM) == 0x000008, "Wrong size on LSoundSystem_CheckStopBGM");
static_assert(offsetof(LSoundSystem_CheckStopBGM, SoundName) == 0x000000, "Member 'LSoundSystem_CheckStopBGM::SoundName' has a wrong offset!");

// Function ProjectP.LSoundSystem.CheckStopBGM_FromNpc
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_CheckStopBGM_FromNpc final
{
public:
	class FName                                   NpcName;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_CheckStopBGM_FromNpc) == 0x000004, "Wrong alignment on LSoundSystem_CheckStopBGM_FromNpc");
static_assert(sizeof(LSoundSystem_CheckStopBGM_FromNpc) == 0x000010, "Wrong size on LSoundSystem_CheckStopBGM_FromNpc");
static_assert(offsetof(LSoundSystem_CheckStopBGM_FromNpc, NpcName) == 0x000000, "Member 'LSoundSystem_CheckStopBGM_FromNpc::NpcName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_CheckStopBGM_FromNpc, SoundName) == 0x000008, "Member 'LSoundSystem_CheckStopBGM_FromNpc::SoundName' has a wrong offset!");

// Function ProjectP.LSoundSystem.ClearSoundMix
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_ClearSoundMix final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_ClearSoundMix) == 0x000008, "Wrong alignment on LSoundSystem_ClearSoundMix");
static_assert(sizeof(LSoundSystem_ClearSoundMix) == 0x000008, "Wrong size on LSoundSystem_ClearSoundMix");
static_assert(offsetof(LSoundSystem_ClearSoundMix, SoundMix) == 0x000000, "Member 'LSoundSystem_ClearSoundMix::SoundMix' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoNextPlayRecord
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_DoNextPlayRecord final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_DoNextPlayRecord) == 0x000001, "Wrong alignment on LSoundSystem_DoNextPlayRecord");
static_assert(sizeof(LSoundSystem_DoNextPlayRecord) == 0x000001, "Wrong size on LSoundSystem_DoNextPlayRecord");
static_assert(offsetof(LSoundSystem_DoNextPlayRecord, ReturnValue) == 0x000000, "Member 'LSoundSystem_DoNextPlayRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoPlayBGM
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_DoPlayBGM final
{
public:
	class FName                                   SoundName;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSoundNameUI;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_DoPlayBGM) == 0x000004, "Wrong alignment on LSoundSystem_DoPlayBGM");
static_assert(sizeof(LSoundSystem_DoPlayBGM) == 0x00000C, "Wrong size on LSoundSystem_DoPlayBGM");
static_assert(offsetof(LSoundSystem_DoPlayBGM, SoundName) == 0x000000, "Member 'LSoundSystem_DoPlayBGM::SoundName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_DoPlayBGM, bShowSoundNameUI) == 0x000008, "Member 'LSoundSystem_DoPlayBGM::bShowSoundNameUI' has a wrong offset!");
static_assert(offsetof(LSoundSystem_DoPlayBGM, ReturnValue) == 0x000009, "Member 'LSoundSystem_DoPlayBGM::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoPlayDialogSound
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_DoPlayDialogSound final
{
public:
	struct FDialogInfoPtr                         InDialog;                                          // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_DoPlayDialogSound) == 0x000008, "Wrong alignment on LSoundSystem_DoPlayDialogSound");
static_assert(sizeof(LSoundSystem_DoPlayDialogSound) == 0x000010, "Wrong size on LSoundSystem_DoPlayDialogSound");
static_assert(offsetof(LSoundSystem_DoPlayDialogSound, InDialog) == 0x000000, "Member 'LSoundSystem_DoPlayDialogSound::InDialog' has a wrong offset!");
static_assert(offsetof(LSoundSystem_DoPlayDialogSound, ReturnValue) == 0x000008, "Member 'LSoundSystem_DoPlayDialogSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoPlayRecord
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_DoPlayRecord final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_DoPlayRecord) == 0x000004, "Wrong alignment on LSoundSystem_DoPlayRecord");
static_assert(sizeof(LSoundSystem_DoPlayRecord) == 0x00000C, "Wrong size on LSoundSystem_DoPlayRecord");
static_assert(offsetof(LSoundSystem_DoPlayRecord, RecordCodeName) == 0x000000, "Member 'LSoundSystem_DoPlayRecord::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_DoPlayRecord, ReturnValue) == 0x000008, "Member 'LSoundSystem_DoPlayRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoPrevPlayRecord
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_DoPrevPlayRecord final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_DoPrevPlayRecord) == 0x000001, "Wrong alignment on LSoundSystem_DoPrevPlayRecord");
static_assert(sizeof(LSoundSystem_DoPrevPlayRecord) == 0x000001, "Wrong size on LSoundSystem_DoPrevPlayRecord");
static_assert(offsetof(LSoundSystem_DoPrevPlayRecord, ReturnValue) == 0x000000, "Member 'LSoundSystem_DoPrevPlayRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoStopDialogSound
// 0x0002 (0x0002 - 0x0000)
struct LSoundSystem_DoStopDialogSound final
{
public:
	bool                                          SkipFadeOut;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_DoStopDialogSound) == 0x000001, "Wrong alignment on LSoundSystem_DoStopDialogSound");
static_assert(sizeof(LSoundSystem_DoStopDialogSound) == 0x000002, "Wrong size on LSoundSystem_DoStopDialogSound");
static_assert(offsetof(LSoundSystem_DoStopDialogSound, SkipFadeOut) == 0x000000, "Member 'LSoundSystem_DoStopDialogSound::SkipFadeOut' has a wrong offset!");
static_assert(offsetof(LSoundSystem_DoStopDialogSound, ReturnValue) == 0x000001, "Member 'LSoundSystem_DoStopDialogSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.DoStopRecord
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_DoStopRecord final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_DoStopRecord) == 0x000001, "Wrong alignment on LSoundSystem_DoStopRecord");
static_assert(sizeof(LSoundSystem_DoStopRecord) == 0x000001, "Wrong size on LSoundSystem_DoStopRecord");
static_assert(offsetof(LSoundSystem_DoStopRecord, ReturnValue) == 0x000000, "Member 'LSoundSystem_DoStopRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.FadeMuteSound
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_FadeMuteSound final
{
public:
	bool                                          bMute;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_FadeMuteSound) == 0x000001, "Wrong alignment on LSoundSystem_FadeMuteSound");
static_assert(sizeof(LSoundSystem_FadeMuteSound) == 0x000001, "Wrong size on LSoundSystem_FadeMuteSound");
static_assert(offsetof(LSoundSystem_FadeMuteSound, bMute) == 0x000000, "Member 'LSoundSystem_FadeMuteSound::bMute' has a wrong offset!");

// Function ProjectP.LSoundSystem.FindPlayableRecordFromPlayingNow
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_FindPlayableRecordFromPlayingNow final
{
public:
	bool                                          FindNext;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_FindPlayableRecordFromPlayingNow) == 0x000004, "Wrong alignment on LSoundSystem_FindPlayableRecordFromPlayingNow");
static_assert(sizeof(LSoundSystem_FindPlayableRecordFromPlayingNow) == 0x00000C, "Wrong size on LSoundSystem_FindPlayableRecordFromPlayingNow");
static_assert(offsetof(LSoundSystem_FindPlayableRecordFromPlayingNow, FindNext) == 0x000000, "Member 'LSoundSystem_FindPlayableRecordFromPlayingNow::FindNext' has a wrong offset!");
static_assert(offsetof(LSoundSystem_FindPlayableRecordFromPlayingNow, ReturnValue) == 0x000004, "Member 'LSoundSystem_FindPlayableRecordFromPlayingNow::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetAllRecordList
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_GetAllRecordList final
{
public:
	TArray<struct FItemCommonInfo>                ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetAllRecordList) == 0x000008, "Wrong alignment on LSoundSystem_GetAllRecordList");
static_assert(sizeof(LSoundSystem_GetAllRecordList) == 0x000010, "Wrong size on LSoundSystem_GetAllRecordList");
static_assert(offsetof(LSoundSystem_GetAllRecordList, ReturnValue) == 0x000000, "Member 'LSoundSystem_GetAllRecordList::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetClassVolume
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_GetClassVolume final
{
public:
	class USoundClass*                            TargetSoundClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_GetClassVolume) == 0x000008, "Wrong alignment on LSoundSystem_GetClassVolume");
static_assert(sizeof(LSoundSystem_GetClassVolume) == 0x000010, "Wrong size on LSoundSystem_GetClassVolume");
static_assert(offsetof(LSoundSystem_GetClassVolume, TargetSoundClass) == 0x000000, "Member 'LSoundSystem_GetClassVolume::TargetSoundClass' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetClassVolume, ReturnValue) == 0x000008, "Member 'LSoundSystem_GetClassVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetDialogSound
// 0x0018 (0x0018 - 0x0000)
struct LSoundSystem_GetDialogSound final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutUseSoundMix;                                    // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetDialogSound) == 0x000008, "Wrong alignment on LSoundSystem_GetDialogSound");
static_assert(sizeof(LSoundSystem_GetDialogSound) == 0x000018, "Wrong size on LSoundSystem_GetDialogSound");
static_assert(offsetof(LSoundSystem_GetDialogSound, RowName) == 0x000000, "Member 'LSoundSystem_GetDialogSound::RowName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetDialogSound, OutUseSoundMix) == 0x000008, "Member 'LSoundSystem_GetDialogSound::OutUseSoundMix' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetDialogSound, ReturnValue) == 0x000010, "Member 'LSoundSystem_GetDialogSound::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetMultifliedVolume
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_GetMultifliedVolume final
{
public:
	ELVolumeType                                  FindType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetMultifliedVolume) == 0x000004, "Wrong alignment on LSoundSystem_GetMultifliedVolume");
static_assert(sizeof(LSoundSystem_GetMultifliedVolume) == 0x000008, "Wrong size on LSoundSystem_GetMultifliedVolume");
static_assert(offsetof(LSoundSystem_GetMultifliedVolume, FindType) == 0x000000, "Member 'LSoundSystem_GetMultifliedVolume::FindType' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetMultifliedVolume, ReturnValue) == 0x000004, "Member 'LSoundSystem_GetMultifliedVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetRecordCue
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_GetRecordCue final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetRecordCue) == 0x000008, "Wrong alignment on LSoundSystem_GetRecordCue");
static_assert(sizeof(LSoundSystem_GetRecordCue) == 0x000010, "Wrong size on LSoundSystem_GetRecordCue");
static_assert(offsetof(LSoundSystem_GetRecordCue, RecordCodeName) == 0x000000, "Member 'LSoundSystem_GetRecordCue::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetRecordCue, ReturnValue) == 0x000008, "Member 'LSoundSystem_GetRecordCue::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetRecordCurrentDuration
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_GetRecordCurrentDuration final
{
public:
	const class USoundWave*                       PlayingSoundWave;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackPercent;                                   // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetRecordCurrentDuration) == 0x000008, "Wrong alignment on LSoundSystem_GetRecordCurrentDuration");
static_assert(sizeof(LSoundSystem_GetRecordCurrentDuration) == 0x000010, "Wrong size on LSoundSystem_GetRecordCurrentDuration");
static_assert(offsetof(LSoundSystem_GetRecordCurrentDuration, PlayingSoundWave) == 0x000000, "Member 'LSoundSystem_GetRecordCurrentDuration::PlayingSoundWave' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetRecordCurrentDuration, PlaybackPercent) == 0x000008, "Member 'LSoundSystem_GetRecordCurrentDuration::PlaybackPercent' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetRecordCurrentDuration, ReturnValue) == 0x00000C, "Member 'LSoundSystem_GetRecordCurrentDuration::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetRecordDuration
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_GetRecordDuration final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetRecordDuration) == 0x000004, "Wrong alignment on LSoundSystem_GetRecordDuration");
static_assert(sizeof(LSoundSystem_GetRecordDuration) == 0x00000C, "Wrong size on LSoundSystem_GetRecordDuration");
static_assert(offsetof(LSoundSystem_GetRecordDuration, RecordCodeName) == 0x000000, "Member 'LSoundSystem_GetRecordDuration::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetRecordDuration, ReturnValue) == 0x000008, "Member 'LSoundSystem_GetRecordDuration::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetSwishMultiplier
// 0x0004 (0x0004 - 0x0000)
struct LSoundSystem_GetSwishMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetSwishMultiplier) == 0x000004, "Wrong alignment on LSoundSystem_GetSwishMultiplier");
static_assert(sizeof(LSoundSystem_GetSwishMultiplier) == 0x000004, "Wrong size on LSoundSystem_GetSwishMultiplier");
static_assert(offsetof(LSoundSystem_GetSwishMultiplier, ReturnValue) == 0x000000, "Member 'LSoundSystem_GetSwishMultiplier::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetVolume
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_GetVolume final
{
public:
	ELVolumeType                                  FindType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetVolume) == 0x000004, "Wrong alignment on LSoundSystem_GetVolume");
static_assert(sizeof(LSoundSystem_GetVolume) == 0x000008, "Wrong size on LSoundSystem_GetVolume");
static_assert(offsetof(LSoundSystem_GetVolume, FindType) == 0x000000, "Member 'LSoundSystem_GetVolume::FindType' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetVolume, ReturnValue) == 0x000004, "Member 'LSoundSystem_GetVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.IsPlayableUISound
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_IsPlayableUISound final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_IsPlayableUISound) == 0x000001, "Wrong alignment on LSoundSystem_IsPlayableUISound");
static_assert(sizeof(LSoundSystem_IsPlayableUISound) == 0x000001, "Wrong size on LSoundSystem_IsPlayableUISound");
static_assert(offsetof(LSoundSystem_IsPlayableUISound, ReturnValue) == 0x000000, "Member 'LSoundSystem_IsPlayableUISound::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.IsPlayingBGM
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_IsPlayingBGM final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_IsPlayingBGM) == 0x000001, "Wrong alignment on LSoundSystem_IsPlayingBGM");
static_assert(sizeof(LSoundSystem_IsPlayingBGM) == 0x000001, "Wrong size on LSoundSystem_IsPlayingBGM");
static_assert(offsetof(LSoundSystem_IsPlayingBGM, ReturnValue) == 0x000000, "Member 'LSoundSystem_IsPlayingBGM::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.IsPushedSoundMix
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_IsPushedSoundMix final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_IsPushedSoundMix) == 0x000008, "Wrong alignment on LSoundSystem_IsPushedSoundMix");
static_assert(sizeof(LSoundSystem_IsPushedSoundMix) == 0x000010, "Wrong size on LSoundSystem_IsPushedSoundMix");
static_assert(offsetof(LSoundSystem_IsPushedSoundMix, SoundMix) == 0x000000, "Member 'LSoundSystem_IsPushedSoundMix::SoundMix' has a wrong offset!");
static_assert(offsetof(LSoundSystem_IsPushedSoundMix, ReturnValue) == 0x000008, "Member 'LSoundSystem_IsPushedSoundMix::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.MuteAllSound
// 0x0002 (0x0002 - 0x0000)
struct LSoundSystem_MuteAllSound final
{
public:
	bool                                          bMute;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFade;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_MuteAllSound) == 0x000001, "Wrong alignment on LSoundSystem_MuteAllSound");
static_assert(sizeof(LSoundSystem_MuteAllSound) == 0x000002, "Wrong size on LSoundSystem_MuteAllSound");
static_assert(offsetof(LSoundSystem_MuteAllSound, bMute) == 0x000000, "Member 'LSoundSystem_MuteAllSound::bMute' has a wrong offset!");
static_assert(offsetof(LSoundSystem_MuteAllSound, bFade) == 0x000001, "Member 'LSoundSystem_MuteAllSound::bFade' has a wrong offset!");

// Function ProjectP.LSoundSystem.MuteSound
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_MuteSound final
{
public:
	bool                                          bMute;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_MuteSound) == 0x000001, "Wrong alignment on LSoundSystem_MuteSound");
static_assert(sizeof(LSoundSystem_MuteSound) == 0x000001, "Wrong size on LSoundSystem_MuteSound");
static_assert(offsetof(LSoundSystem_MuteSound, bMute) == 0x000000, "Member 'LSoundSystem_MuteSound::bMute' has a wrong offset!");

// Function ProjectP.LSoundSystem.MuteUISound
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_MuteUISound final
{
public:
	bool                                          Mute;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_MuteUISound) == 0x000001, "Wrong alignment on LSoundSystem_MuteUISound");
static_assert(sizeof(LSoundSystem_MuteUISound) == 0x000001, "Wrong size on LSoundSystem_MuteUISound");
static_assert(offsetof(LSoundSystem_MuteUISound, Mute) == 0x000000, "Member 'LSoundSystem_MuteUISound::Mute' has a wrong offset!");

// Function ProjectP.LSoundSystem.OnRecordPlaybackPercent
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_OnRecordPlaybackPercent final
{
public:
	const class USoundWave*                       PlayingSoundWave;                                  // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackPercent;                                   // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_OnRecordPlaybackPercent) == 0x000008, "Wrong alignment on LSoundSystem_OnRecordPlaybackPercent");
static_assert(sizeof(LSoundSystem_OnRecordPlaybackPercent) == 0x000010, "Wrong size on LSoundSystem_OnRecordPlaybackPercent");
static_assert(offsetof(LSoundSystem_OnRecordPlaybackPercent, PlayingSoundWave) == 0x000000, "Member 'LSoundSystem_OnRecordPlaybackPercent::PlayingSoundWave' has a wrong offset!");
static_assert(offsetof(LSoundSystem_OnRecordPlaybackPercent, PlaybackPercent) == 0x000008, "Member 'LSoundSystem_OnRecordPlaybackPercent::PlaybackPercent' has a wrong offset!");

// Function ProjectP.LSoundSystem.PlaySound2DFromSequence
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_PlaySound2DFromSequence final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_PlaySound2DFromSequence) == 0x000008, "Wrong alignment on LSoundSystem_PlaySound2DFromSequence");
static_assert(sizeof(LSoundSystem_PlaySound2DFromSequence) == 0x000008, "Wrong size on LSoundSystem_PlaySound2DFromSequence");
static_assert(offsetof(LSoundSystem_PlaySound2DFromSequence, Sound) == 0x000000, "Member 'LSoundSystem_PlaySound2DFromSequence::Sound' has a wrong offset!");

// Function ProjectP.LSoundSystem.PopSoundMixFromSequence
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_PopSoundMixFromSequence final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_PopSoundMixFromSequence) == 0x000008, "Wrong alignment on LSoundSystem_PopSoundMixFromSequence");
static_assert(sizeof(LSoundSystem_PopSoundMixFromSequence) == 0x000008, "Wrong size on LSoundSystem_PopSoundMixFromSequence");
static_assert(offsetof(LSoundSystem_PopSoundMixFromSequence, SoundMix) == 0x000000, "Member 'LSoundSystem_PopSoundMixFromSequence::SoundMix' has a wrong offset!");

// Function ProjectP.LSoundSystem.PushSoundMix_MustFadeIn
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_PushSoundMix_MustFadeIn final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_PushSoundMix_MustFadeIn) == 0x000008, "Wrong alignment on LSoundSystem_PushSoundMix_MustFadeIn");
static_assert(sizeof(LSoundSystem_PushSoundMix_MustFadeIn) == 0x000008, "Wrong size on LSoundSystem_PushSoundMix_MustFadeIn");
static_assert(offsetof(LSoundSystem_PushSoundMix_MustFadeIn, SoundMix) == 0x000000, "Member 'LSoundSystem_PushSoundMix_MustFadeIn::SoundMix' has a wrong offset!");

// Function ProjectP.LSoundSystem.PushSoundMixFromSequence
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_PushSoundMixFromSequence final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_PushSoundMixFromSequence) == 0x000008, "Wrong alignment on LSoundSystem_PushSoundMixFromSequence");
static_assert(sizeof(LSoundSystem_PushSoundMixFromSequence) == 0x000008, "Wrong size on LSoundSystem_PushSoundMixFromSequence");
static_assert(offsetof(LSoundSystem_PushSoundMixFromSequence, SoundMix) == 0x000000, "Member 'LSoundSystem_PushSoundMixFromSequence::SoundMix' has a wrong offset!");

// Function ProjectP.LSoundSystem.SetPendingNextPlayRecord
// 0x0008 (0x0008 - 0x0000)
struct LSoundSystem_SetPendingNextPlayRecord final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_SetPendingNextPlayRecord) == 0x000004, "Wrong alignment on LSoundSystem_SetPendingNextPlayRecord");
static_assert(sizeof(LSoundSystem_SetPendingNextPlayRecord) == 0x000008, "Wrong size on LSoundSystem_SetPendingNextPlayRecord");
static_assert(offsetof(LSoundSystem_SetPendingNextPlayRecord, RecordCodeName) == 0x000000, "Member 'LSoundSystem_SetPendingNextPlayRecord::RecordCodeName' has a wrong offset!");

// Function ProjectP.LSoundSystem.SetVolume
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_SetVolume final
{
public:
	ELVolumeType                                  FindType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InVolume;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_SetVolume) == 0x000004, "Wrong alignment on LSoundSystem_SetVolume");
static_assert(sizeof(LSoundSystem_SetVolume) == 0x00000C, "Wrong size on LSoundSystem_SetVolume");
static_assert(offsetof(LSoundSystem_SetVolume, FindType) == 0x000000, "Member 'LSoundSystem_SetVolume::FindType' has a wrong offset!");
static_assert(offsetof(LSoundSystem_SetVolume, InVolume) == 0x000004, "Member 'LSoundSystem_SetVolume::InVolume' has a wrong offset!");
static_assert(offsetof(LSoundSystem_SetVolume, ReturnValue) == 0x000008, "Member 'LSoundSystem_SetVolume::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetAudioVolumeConcurrency
// 0x0010 (0x0010 - 0x0000)
struct LSoundSystem_GetAudioVolumeConcurrency final
{
public:
	const class UAudioComponent*                  InAudioComp;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_GetAudioVolumeConcurrency) == 0x000008, "Wrong alignment on LSoundSystem_GetAudioVolumeConcurrency");
static_assert(sizeof(LSoundSystem_GetAudioVolumeConcurrency) == 0x000010, "Wrong size on LSoundSystem_GetAudioVolumeConcurrency");
static_assert(offsetof(LSoundSystem_GetAudioVolumeConcurrency, InAudioComp) == 0x000000, "Member 'LSoundSystem_GetAudioVolumeConcurrency::InAudioComp' has a wrong offset!");
static_assert(offsetof(LSoundSystem_GetAudioVolumeConcurrency, ReturnValue) == 0x000008, "Member 'LSoundSystem_GetAudioVolumeConcurrency::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.GetIsAsncLoadingMapCompleted
// 0x0001 (0x0001 - 0x0000)
struct LSoundSystem_GetIsAsncLoadingMapCompleted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSoundSystem_GetIsAsncLoadingMapCompleted) == 0x000001, "Wrong alignment on LSoundSystem_GetIsAsncLoadingMapCompleted");
static_assert(sizeof(LSoundSystem_GetIsAsncLoadingMapCompleted) == 0x000001, "Wrong size on LSoundSystem_GetIsAsncLoadingMapCompleted");
static_assert(offsetof(LSoundSystem_GetIsAsncLoadingMapCompleted, ReturnValue) == 0x000000, "Member 'LSoundSystem_GetIsAsncLoadingMapCompleted::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.IsNotiRecord
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_IsNotiRecord final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_IsNotiRecord) == 0x000004, "Wrong alignment on LSoundSystem_IsNotiRecord");
static_assert(sizeof(LSoundSystem_IsNotiRecord) == 0x00000C, "Wrong size on LSoundSystem_IsNotiRecord");
static_assert(offsetof(LSoundSystem_IsNotiRecord, RecordCodeName) == 0x000000, "Member 'LSoundSystem_IsNotiRecord::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_IsNotiRecord, ReturnValue) == 0x000008, "Member 'LSoundSystem_IsNotiRecord::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.IsRecord_CanAquireHumanity
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_IsRecord_CanAquireHumanity final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_IsRecord_CanAquireHumanity) == 0x000004, "Wrong alignment on LSoundSystem_IsRecord_CanAquireHumanity");
static_assert(sizeof(LSoundSystem_IsRecord_CanAquireHumanity) == 0x00000C, "Wrong size on LSoundSystem_IsRecord_CanAquireHumanity");
static_assert(offsetof(LSoundSystem_IsRecord_CanAquireHumanity, RecordCodeName) == 0x000000, "Member 'LSoundSystem_IsRecord_CanAquireHumanity::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_IsRecord_CanAquireHumanity, ReturnValue) == 0x000008, "Member 'LSoundSystem_IsRecord_CanAquireHumanity::ReturnValue' has a wrong offset!");

// Function ProjectP.LSoundSystem.IsRecordHavingHumanity
// 0x000C (0x000C - 0x0000)
struct LSoundSystem_IsRecordHavingHumanity final
{
public:
	class FName                                   RecordCodeName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSoundSystem_IsRecordHavingHumanity) == 0x000004, "Wrong alignment on LSoundSystem_IsRecordHavingHumanity");
static_assert(sizeof(LSoundSystem_IsRecordHavingHumanity) == 0x00000C, "Wrong size on LSoundSystem_IsRecordHavingHumanity");
static_assert(offsetof(LSoundSystem_IsRecordHavingHumanity, RecordCodeName) == 0x000000, "Member 'LSoundSystem_IsRecordHavingHumanity::RecordCodeName' has a wrong offset!");
static_assert(offsetof(LSoundSystem_IsRecordHavingHumanity, ReturnValue) == 0x000008, "Member 'LSoundSystem_IsRecordHavingHumanity::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_By_HP.OnUpdateHP
// 0x0008 (0x0008 - 0x0000)
struct LSpecialBuff_Abnormal_By_HP_OnUpdateHP final
{
public:
	int32                                         CurrentHP;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuff_Abnormal_By_HP_OnUpdateHP) == 0x000004, "Wrong alignment on LSpecialBuff_Abnormal_By_HP_OnUpdateHP");
static_assert(sizeof(LSpecialBuff_Abnormal_By_HP_OnUpdateHP) == 0x000008, "Wrong size on LSpecialBuff_Abnormal_By_HP_OnUpdateHP");
static_assert(offsetof(LSpecialBuff_Abnormal_By_HP_OnUpdateHP, CurrentHP) == 0x000000, "Member 'LSpecialBuff_Abnormal_By_HP_OnUpdateHP::CurrentHP' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_By_HP_OnUpdateHP, MaxHP) == 0x000004, "Member 'LSpecialBuff_Abnormal_By_HP_OnUpdateHP::MaxHP' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Resurrection.OnUpdateHP
// 0x0008 (0x0008 - 0x0000)
struct LSpecialBuff_Resurrection_OnUpdateHP final
{
public:
	int32                                         CurrentHP;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuff_Resurrection_OnUpdateHP) == 0x000004, "Wrong alignment on LSpecialBuff_Resurrection_OnUpdateHP");
static_assert(sizeof(LSpecialBuff_Resurrection_OnUpdateHP) == 0x000008, "Wrong size on LSpecialBuff_Resurrection_OnUpdateHP");
static_assert(offsetof(LSpecialBuff_Resurrection_OnUpdateHP, CurrentHP) == 0x000000, "Member 'LSpecialBuff_Resurrection_OnUpdateHP::CurrentHP' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Resurrection_OnUpdateHP, MaxHP) == 0x000004, "Member 'LSpecialBuff_Resurrection_OnUpdateHP::MaxHP' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_On_PulseRechargeState.OnEnterActionState
// 0x0018 (0x0018 - 0x0000)
struct LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState) == 0x000008, "Wrong alignment on LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState");
static_assert(sizeof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState) == 0x000018, "Wrong size on LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState");
static_assert(offsetof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState, ActMgrComponent) == 0x000000, "Member 'LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState, ActionState) == 0x000008, "Member 'LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState::ActionState' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState, IsPair) == 0x000010, "Member 'LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState::IsPair' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_On_PulseRechargeState.OnLeaveActionState
// 0x0018 (0x0018 - 0x0000)
struct LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPair;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState) == 0x000008, "Wrong alignment on LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState");
static_assert(sizeof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState) == 0x000018, "Wrong size on LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState");
static_assert(offsetof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState, ActMgrComponent) == 0x000000, "Member 'LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState, ActionState) == 0x000008, "Member 'LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState::ActionState' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState, IsPair) == 0x000010, "Member 'LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState::IsPair' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_On_Debuff.OnApplyRunningAbnormal
// 0x000C (0x000C - 0x0000)
struct LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal final
{
public:
	bool                                          IsApply;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbnormalCodeName;                                  // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal) == 0x000004, "Wrong alignment on LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal");
static_assert(sizeof(LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal) == 0x00000C, "Wrong size on LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal");
static_assert(offsetof(LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal, IsApply) == 0x000000, "Member 'LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal::IsApply' has a wrong offset!");
static_assert(offsetof(LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal, AbnormalCodeName) == 0x000004, "Member 'LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal::AbnormalCodeName' has a wrong offset!");

// Function ProjectP.LSpecialBuff_Abnormal_By_Pulse_ExhastedCount.ApplyAbnormal
// 0x0004 (0x0004 - 0x0000)
struct LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal final
{
public:
	int32                                         ExhastedCount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal) == 0x000004, "Wrong alignment on LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal");
static_assert(sizeof(LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal) == 0x000004, "Wrong size on LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal");
static_assert(offsetof(LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal, ExhastedCount) == 0x000000, "Member 'LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal::ExhastedCount' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.AddBuff
// 0x0010 (0x0010 - 0x0000)
struct LSpecialBuffSystem_AddBuff final
{
public:
	class FName                                   SpecialBuffCodeName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuffSystem_AddBuff) == 0x000004, "Wrong alignment on LSpecialBuffSystem_AddBuff");
static_assert(sizeof(LSpecialBuffSystem_AddBuff) == 0x000010, "Wrong size on LSpecialBuffSystem_AddBuff");
static_assert(offsetof(LSpecialBuffSystem_AddBuff, SpecialBuffCodeName) == 0x000000, "Member 'LSpecialBuffSystem_AddBuff::SpecialBuffCodeName' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_AddBuff, Reason) == 0x000008, "Member 'LSpecialBuffSystem_AddBuff::Reason' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.CheckHaveBuff
// 0x0002 (0x0002 - 0x0000)
struct LSpecialBuffSystem_CheckHaveBuff final
{
public:
	ELSpecialBuffType                             Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuffSystem_CheckHaveBuff) == 0x000001, "Wrong alignment on LSpecialBuffSystem_CheckHaveBuff");
static_assert(sizeof(LSpecialBuffSystem_CheckHaveBuff) == 0x000002, "Wrong size on LSpecialBuffSystem_CheckHaveBuff");
static_assert(offsetof(LSpecialBuffSystem_CheckHaveBuff, Type) == 0x000000, "Member 'LSpecialBuffSystem_CheckHaveBuff::Type' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_CheckHaveBuff, ReturnValue) == 0x000001, "Member 'LSpecialBuffSystem_CheckHaveBuff::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.GetAppliedBuff
// 0x0020 (0x0020 - 0x0000)
struct LSpecialBuffSystem_GetAppliedBuff final
{
public:
	ELSpecialBuffType                             Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULSpecialBuff*>                  OutBuffInfoList;                                   // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuffSystem_GetAppliedBuff) == 0x000008, "Wrong alignment on LSpecialBuffSystem_GetAppliedBuff");
static_assert(sizeof(LSpecialBuffSystem_GetAppliedBuff) == 0x000020, "Wrong size on LSpecialBuffSystem_GetAppliedBuff");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuff, Type) == 0x000000, "Member 'LSpecialBuffSystem_GetAppliedBuff::Type' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuff, OutBuffInfoList) == 0x000008, "Member 'LSpecialBuffSystem_GetAppliedBuff::OutBuffInfoList' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuff, ReturnValue) == 0x000018, "Member 'LSpecialBuffSystem_GetAppliedBuff::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.GetAppliedBuffAll
// 0x0018 (0x0018 - 0x0000)
struct LSpecialBuffSystem_GetAppliedBuffAll final
{
public:
	TArray<class ULSpecialBuff*>                  OutBuffInfoList;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuffSystem_GetAppliedBuffAll) == 0x000008, "Wrong alignment on LSpecialBuffSystem_GetAppliedBuffAll");
static_assert(sizeof(LSpecialBuffSystem_GetAppliedBuffAll) == 0x000018, "Wrong size on LSpecialBuffSystem_GetAppliedBuffAll");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuffAll, OutBuffInfoList) == 0x000000, "Member 'LSpecialBuffSystem_GetAppliedBuffAll::OutBuffInfoList' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuffAll, ReturnValue) == 0x000010, "Member 'LSpecialBuffSystem_GetAppliedBuffAll::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.GetAppliedBuffTotalAmount
// 0x0008 (0x0008 - 0x0000)
struct LSpecialBuffSystem_GetAppliedBuffTotalAmount final
{
public:
	ELSpecialBuffType                             Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuffSystem_GetAppliedBuffTotalAmount) == 0x000004, "Wrong alignment on LSpecialBuffSystem_GetAppliedBuffTotalAmount");
static_assert(sizeof(LSpecialBuffSystem_GetAppliedBuffTotalAmount) == 0x000008, "Wrong size on LSpecialBuffSystem_GetAppliedBuffTotalAmount");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuffTotalAmount, Type) == 0x000000, "Member 'LSpecialBuffSystem_GetAppliedBuffTotalAmount::Type' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_GetAppliedBuffTotalAmount, ReturnValue) == 0x000004, "Member 'LSpecialBuffSystem_GetAppliedBuffTotalAmount::ReturnValue' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LSpecialBuffSystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LSpecialBuffSystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LSpecialBuffSystem_OnGameDataCharacterSync");
static_assert(sizeof(LSpecialBuffSystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LSpecialBuffSystem_OnGameDataCharacterSync");
static_assert(offsetof(LSpecialBuffSystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LSpecialBuffSystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LSpecialBuffSystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.OnHumanityChangesSpecialBuff
// 0x0008 (0x0008 - 0x0000)
struct LSpecialBuffSystem_OnHumanityChangesSpecialBuff final
{
public:
	struct FHumanizationBuffAlterInfoPtr          BuffAlterInfo;                                     // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuffSystem_OnHumanityChangesSpecialBuff) == 0x000008, "Wrong alignment on LSpecialBuffSystem_OnHumanityChangesSpecialBuff");
static_assert(sizeof(LSpecialBuffSystem_OnHumanityChangesSpecialBuff) == 0x000008, "Wrong size on LSpecialBuffSystem_OnHumanityChangesSpecialBuff");
static_assert(offsetof(LSpecialBuffSystem_OnHumanityChangesSpecialBuff, BuffAlterInfo) == 0x000000, "Member 'LSpecialBuffSystem_OnHumanityChangesSpecialBuff::BuffAlterInfo' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.OnStatChanged
// 0x000C (0x000C - 0x0000)
struct LSpecialBuffSystem_OnStatChanged final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AddedValue;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevStatValue;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuffSystem_OnStatChanged) == 0x000004, "Wrong alignment on LSpecialBuffSystem_OnStatChanged");
static_assert(sizeof(LSpecialBuffSystem_OnStatChanged) == 0x00000C, "Wrong size on LSpecialBuffSystem_OnStatChanged");
static_assert(offsetof(LSpecialBuffSystem_OnStatChanged, StatType) == 0x000000, "Member 'LSpecialBuffSystem_OnStatChanged::StatType' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_OnStatChanged, AddedValue) == 0x000004, "Member 'LSpecialBuffSystem_OnStatChanged::AddedValue' has a wrong offset!");
static_assert(offsetof(LSpecialBuffSystem_OnStatChanged, PrevStatValue) == 0x000008, "Member 'LSpecialBuffSystem_OnStatChanged::PrevStatValue' has a wrong offset!");

// Function ProjectP.LSpecialBuffSystem.RemoveBuff
// 0x0008 (0x0008 - 0x0000)
struct LSpecialBuffSystem_RemoveBuff final
{
public:
	class FName                                   SpecialBuffCodeName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LSpecialBuffSystem_RemoveBuff) == 0x000004, "Wrong alignment on LSpecialBuffSystem_RemoveBuff");
static_assert(sizeof(LSpecialBuffSystem_RemoveBuff) == 0x000008, "Wrong size on LSpecialBuffSystem_RemoveBuff");
static_assert(offsetof(LSpecialBuffSystem_RemoveBuff, SpecialBuffCodeName) == 0x000000, "Member 'LSpecialBuffSystem_RemoveBuff::SpecialBuffCodeName' has a wrong offset!");

// Function ProjectP.LStatComponent.EndStaminaRestore
// 0x0008 (0x0008 - 0x0000)
struct LStatComponent_EndStaminaRestore final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_EndStaminaRestore) == 0x000008, "Wrong alignment on LStatComponent_EndStaminaRestore");
static_assert(sizeof(LStatComponent_EndStaminaRestore) == 0x000008, "Wrong size on LStatComponent_EndStaminaRestore");
static_assert(offsetof(LStatComponent_EndStaminaRestore, Instigator) == 0x000000, "Member 'LStatComponent_EndStaminaRestore::Instigator' has a wrong offset!");

// Function ProjectP.LStatComponent.GetCharacterRawStat
// 0x0008 (0x0008 - 0x0000)
struct LStatComponent_GetCharacterRawStat final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_GetCharacterRawStat) == 0x000004, "Wrong alignment on LStatComponent_GetCharacterRawStat");
static_assert(sizeof(LStatComponent_GetCharacterRawStat) == 0x000008, "Wrong size on LStatComponent_GetCharacterRawStat");
static_assert(offsetof(LStatComponent_GetCharacterRawStat, StatType) == 0x000000, "Member 'LStatComponent_GetCharacterRawStat::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetCharacterRawStat, ReturnValue) == 0x000004, "Member 'LStatComponent_GetCharacterRawStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.GetCharacterStat
// 0x0008 (0x0008 - 0x0000)
struct LStatComponent_GetCharacterStat final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_GetCharacterStat) == 0x000004, "Wrong alignment on LStatComponent_GetCharacterStat");
static_assert(sizeof(LStatComponent_GetCharacterStat) == 0x000008, "Wrong size on LStatComponent_GetCharacterStat");
static_assert(offsetof(LStatComponent_GetCharacterStat, StatType) == 0x000000, "Member 'LStatComponent_GetCharacterStat::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetCharacterStat, ReturnValue) == 0x000004, "Member 'LStatComponent_GetCharacterStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.GetStat
// 0x0008 (0x0008 - 0x0000)
struct LStatComponent_GetStat final
{
public:
	ELStatDataType                                DataType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSecondStat                                  StatType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_GetStat) == 0x000004, "Wrong alignment on LStatComponent_GetStat");
static_assert(sizeof(LStatComponent_GetStat) == 0x000008, "Wrong size on LStatComponent_GetStat");
static_assert(offsetof(LStatComponent_GetStat, DataType) == 0x000000, "Member 'LStatComponent_GetStat::DataType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStat, StatType) == 0x000001, "Member 'LStatComponent_GetStat::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStat, ReturnValue) == 0x000004, "Member 'LStatComponent_GetStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.GetStatByPercent
// 0x000C (0x000C - 0x0000)
struct LStatComponent_GetStatByPercent final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CalcRatio;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_GetStatByPercent) == 0x000004, "Wrong alignment on LStatComponent_GetStatByPercent");
static_assert(sizeof(LStatComponent_GetStatByPercent) == 0x00000C, "Wrong size on LStatComponent_GetStatByPercent");
static_assert(offsetof(LStatComponent_GetStatByPercent, StatType) == 0x000000, "Member 'LStatComponent_GetStatByPercent::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStatByPercent, CalcRatio) == 0x000004, "Member 'LStatComponent_GetStatByPercent::CalcRatio' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStatByPercent, ReturnValue) == 0x000008, "Member 'LStatComponent_GetStatByPercent::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.GetStatInfo
// 0x0010 (0x0010 - 0x0000)
struct LStatComponent_GetStatInfo final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Current;                                           // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_GetStatInfo) == 0x000004, "Wrong alignment on LStatComponent_GetStatInfo");
static_assert(sizeof(LStatComponent_GetStatInfo) == 0x000010, "Wrong size on LStatComponent_GetStatInfo");
static_assert(offsetof(LStatComponent_GetStatInfo, StatType) == 0x000000, "Member 'LStatComponent_GetStatInfo::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStatInfo, Current) == 0x000004, "Member 'LStatComponent_GetStatInfo::Current' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStatInfo, Max) == 0x000008, "Member 'LStatComponent_GetStatInfo::Max' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStatInfo, Ratio) == 0x00000C, "Member 'LStatComponent_GetStatInfo::Ratio' has a wrong offset!");

// Function ProjectP.LStatComponent.GetStatPercent
// 0x0008 (0x0008 - 0x0000)
struct LStatComponent_GetStatPercent final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_GetStatPercent) == 0x000004, "Wrong alignment on LStatComponent_GetStatPercent");
static_assert(sizeof(LStatComponent_GetStatPercent) == 0x000008, "Wrong size on LStatComponent_GetStatPercent");
static_assert(offsetof(LStatComponent_GetStatPercent, StatType) == 0x000000, "Member 'LStatComponent_GetStatPercent::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_GetStatPercent, ReturnValue) == 0x000004, "Member 'LStatComponent_GetStatPercent::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.RecoveryMaxStat
// 0x0002 (0x0002 - 0x0000)
struct LStatComponent_RecoveryMaxStat final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_RecoveryMaxStat) == 0x000001, "Wrong alignment on LStatComponent_RecoveryMaxStat");
static_assert(sizeof(LStatComponent_RecoveryMaxStat) == 0x000002, "Wrong size on LStatComponent_RecoveryMaxStat");
static_assert(offsetof(LStatComponent_RecoveryMaxStat, StatType) == 0x000000, "Member 'LStatComponent_RecoveryMaxStat::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_RecoveryMaxStat, ReturnValue) == 0x000001, "Member 'LStatComponent_RecoveryMaxStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.RecoveryStat
// 0x000C (0x000C - 0x0000)
struct LStatComponent_RecoveryStat final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LStatComponent_RecoveryStat) == 0x000004, "Wrong alignment on LStatComponent_RecoveryStat");
static_assert(sizeof(LStatComponent_RecoveryStat) == 0x00000C, "Wrong size on LStatComponent_RecoveryStat");
static_assert(offsetof(LStatComponent_RecoveryStat, StatType) == 0x000000, "Member 'LStatComponent_RecoveryStat::StatType' has a wrong offset!");
static_assert(offsetof(LStatComponent_RecoveryStat, Amount) == 0x000004, "Member 'LStatComponent_RecoveryStat::Amount' has a wrong offset!");
static_assert(offsetof(LStatComponent_RecoveryStat, ReturnValue) == 0x000008, "Member 'LStatComponent_RecoveryStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatComponent.StartStaminaRestore
// 0x0010 (0x0010 - 0x0000)
struct LStatComponent_StartStaminaRestore final
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatComponent_StartStaminaRestore) == 0x000008, "Wrong alignment on LStatComponent_StartStaminaRestore");
static_assert(sizeof(LStatComponent_StartStaminaRestore) == 0x000010, "Wrong size on LStatComponent_StartStaminaRestore");
static_assert(offsetof(LStatComponent_StartStaminaRestore, Ratio) == 0x000000, "Member 'LStatComponent_StartStaminaRestore::Ratio' has a wrong offset!");
static_assert(offsetof(LStatComponent_StartStaminaRestore, Instigator) == 0x000008, "Member 'LStatComponent_StartStaminaRestore::Instigator' has a wrong offset!");

// Function ProjectP.LStatRoomPCCharacter.CheckCanChangeFirstStat
// 0x0010 (0x0010 - 0x0000)
struct LStatRoomPCCharacter_CheckCanChangeFirstStat final
{
public:
	ELFirstStat                                   FirstStat;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeData;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutErrorCode;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LStatRoomPCCharacter_CheckCanChangeFirstStat) == 0x000004, "Wrong alignment on LStatRoomPCCharacter_CheckCanChangeFirstStat");
static_assert(sizeof(LStatRoomPCCharacter_CheckCanChangeFirstStat) == 0x000010, "Wrong size on LStatRoomPCCharacter_CheckCanChangeFirstStat");
static_assert(offsetof(LStatRoomPCCharacter_CheckCanChangeFirstStat, FirstStat) == 0x000000, "Member 'LStatRoomPCCharacter_CheckCanChangeFirstStat::FirstStat' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_CheckCanChangeFirstStat, ChangeData) == 0x000004, "Member 'LStatRoomPCCharacter_CheckCanChangeFirstStat::ChangeData' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_CheckCanChangeFirstStat, OutErrorCode) == 0x000008, "Member 'LStatRoomPCCharacter_CheckCanChangeFirstStat::OutErrorCode' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_CheckCanChangeFirstStat, ReturnValue) == 0x00000C, "Member 'LStatRoomPCCharacter_CheckCanChangeFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LStatRoomPCCharacter.GetDiffStat_ByFirstStat
// 0x0070 (0x0070 - 0x0000)
struct LStatRoomPCCharacter_GetDiffStat_ByFirstStat final
{
public:
	TArray<struct FLSecondStatDiffData>           Common_SecondStatDiff;                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSecondStatDiffData>           Weapon1_SecondStatDiff;                            // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSecondStatDiffData>           Weapon2_SecondStatDiff;                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSecondStatDiffData>           Weapon3_SecondStatDiff;                            // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSecondStatDiffData>           SlaveArm1_SecondStatDiff;                          // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSecondStatDiffData>           SlaveArm2_SecondStatDiff;                          // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSecondStatDiffData>           SlaveArm3_SecondStatDiff;                          // 0x0060(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat) == 0x000008, "Wrong alignment on LStatRoomPCCharacter_GetDiffStat_ByFirstStat");
static_assert(sizeof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat) == 0x000070, "Wrong size on LStatRoomPCCharacter_GetDiffStat_ByFirstStat");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, Common_SecondStatDiff) == 0x000000, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::Common_SecondStatDiff' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, Weapon1_SecondStatDiff) == 0x000010, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::Weapon1_SecondStatDiff' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, Weapon2_SecondStatDiff) == 0x000020, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::Weapon2_SecondStatDiff' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, Weapon3_SecondStatDiff) == 0x000030, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::Weapon3_SecondStatDiff' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, SlaveArm1_SecondStatDiff) == 0x000040, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::SlaveArm1_SecondStatDiff' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, SlaveArm2_SecondStatDiff) == 0x000050, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::SlaveArm2_SecondStatDiff' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetDiffStat_ByFirstStat, SlaveArm3_SecondStatDiff) == 0x000060, "Member 'LStatRoomPCCharacter_GetDiffStat_ByFirstStat::SlaveArm3_SecondStatDiff' has a wrong offset!");

// Function ProjectP.LStatRoomPCCharacter.OnActiveMesh
// 0x0001 (0x0001 - 0x0000)
struct LStatRoomPCCharacter_OnActiveMesh final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatRoomPCCharacter_OnActiveMesh) == 0x000001, "Wrong alignment on LStatRoomPCCharacter_OnActiveMesh");
static_assert(sizeof(LStatRoomPCCharacter_OnActiveMesh) == 0x000001, "Wrong size on LStatRoomPCCharacter_OnActiveMesh");
static_assert(offsetof(LStatRoomPCCharacter_OnActiveMesh, Active) == 0x000000, "Member 'LStatRoomPCCharacter_OnActiveMesh::Active' has a wrong offset!");

// Function ProjectP.LStatRoomPCCharacter.OnSetActiveEnvironment
// 0x0001 (0x0001 - 0x0000)
struct LStatRoomPCCharacter_OnSetActiveEnvironment final
{
public:
	bool                                          Active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatRoomPCCharacter_OnSetActiveEnvironment) == 0x000001, "Wrong alignment on LStatRoomPCCharacter_OnSetActiveEnvironment");
static_assert(sizeof(LStatRoomPCCharacter_OnSetActiveEnvironment) == 0x000001, "Wrong size on LStatRoomPCCharacter_OnSetActiveEnvironment");
static_assert(offsetof(LStatRoomPCCharacter_OnSetActiveEnvironment, Active) == 0x000000, "Member 'LStatRoomPCCharacter_OnSetActiveEnvironment::Active' has a wrong offset!");

// Function ProjectP.LStatRoomPCCharacter.UIChangeFirstStat
// 0x0008 (0x0008 - 0x0000)
struct LStatRoomPCCharacter_UIChangeFirstStat final
{
public:
	ELFirstStat                                   FirstStat;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeData;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatRoomPCCharacter_UIChangeFirstStat) == 0x000004, "Wrong alignment on LStatRoomPCCharacter_UIChangeFirstStat");
static_assert(sizeof(LStatRoomPCCharacter_UIChangeFirstStat) == 0x000008, "Wrong size on LStatRoomPCCharacter_UIChangeFirstStat");
static_assert(offsetof(LStatRoomPCCharacter_UIChangeFirstStat, FirstStat) == 0x000000, "Member 'LStatRoomPCCharacter_UIChangeFirstStat::FirstStat' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_UIChangeFirstStat, ChangeData) == 0x000004, "Member 'LStatRoomPCCharacter_UIChangeFirstStat::ChangeData' has a wrong offset!");

// Function ProjectP.LStatRoomPCCharacter.GetFirstStat
// 0x0008 (0x0008 - 0x0000)
struct LStatRoomPCCharacter_GetFirstStat final
{
public:
	ELFirstStatDataType                           DataType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFirstStat                                   StatType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LStatRoomPCCharacter_GetFirstStat) == 0x000004, "Wrong alignment on LStatRoomPCCharacter_GetFirstStat");
static_assert(sizeof(LStatRoomPCCharacter_GetFirstStat) == 0x000008, "Wrong size on LStatRoomPCCharacter_GetFirstStat");
static_assert(offsetof(LStatRoomPCCharacter_GetFirstStat, DataType) == 0x000000, "Member 'LStatRoomPCCharacter_GetFirstStat::DataType' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetFirstStat, StatType) == 0x000001, "Member 'LStatRoomPCCharacter_GetFirstStat::StatType' has a wrong offset!");
static_assert(offsetof(LStatRoomPCCharacter_GetFirstStat, ReturnValue) == 0x000004, "Member 'LStatRoomPCCharacter_GetFirstStat::ReturnValue' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.GetSpawnPointTransform
// 0x0030 (0x0030 - 0x0000)
struct LTeleportObjectSpot_GetSpawnPointTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTeleportObjectSpot_GetSpawnPointTransform) == 0x000010, "Wrong alignment on LTeleportObjectSpot_GetSpawnPointTransform");
static_assert(sizeof(LTeleportObjectSpot_GetSpawnPointTransform) == 0x000030, "Wrong size on LTeleportObjectSpot_GetSpawnPointTransform");
static_assert(offsetof(LTeleportObjectSpot_GetSpawnPointTransform, ReturnValue) == 0x000000, "Member 'LTeleportObjectSpot_GetSpawnPointTransform::ReturnValue' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.GetTeleportObjectCodeName
// 0x0008 (0x0008 - 0x0000)
struct LTeleportObjectSpot_GetTeleportObjectCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTeleportObjectSpot_GetTeleportObjectCodeName) == 0x000004, "Wrong alignment on LTeleportObjectSpot_GetTeleportObjectCodeName");
static_assert(sizeof(LTeleportObjectSpot_GetTeleportObjectCodeName) == 0x000008, "Wrong size on LTeleportObjectSpot_GetTeleportObjectCodeName");
static_assert(offsetof(LTeleportObjectSpot_GetTeleportObjectCodeName, ReturnValue) == 0x000000, "Member 'LTeleportObjectSpot_GetTeleportObjectCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.IsPortal
// 0x0001 (0x0001 - 0x0000)
struct LTeleportObjectSpot_IsPortal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTeleportObjectSpot_IsPortal) == 0x000001, "Wrong alignment on LTeleportObjectSpot_IsPortal");
static_assert(sizeof(LTeleportObjectSpot_IsPortal) == 0x000001, "Wrong size on LTeleportObjectSpot_IsPortal");
static_assert(offsetof(LTeleportObjectSpot_IsPortal, ReturnValue) == 0x000000, "Member 'LTeleportObjectSpot_IsPortal::ReturnValue' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.OnClosedWindow
// 0x0008 (0x0008 - 0x0000)
struct LTeleportObjectSpot_OnClosedWindow final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTeleportObjectSpot_OnClosedWindow) == 0x000004, "Wrong alignment on LTeleportObjectSpot_OnClosedWindow");
static_assert(sizeof(LTeleportObjectSpot_OnClosedWindow) == 0x000008, "Wrong size on LTeleportObjectSpot_OnClosedWindow");
static_assert(offsetof(LTeleportObjectSpot_OnClosedWindow, WidgetTableName) == 0x000000, "Member 'LTeleportObjectSpot_OnClosedWindow::WidgetTableName' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.OnComponentBeginOverlapPropOverlapPawn
// 0x00A8 (0x00A8 - 0x0000)
struct LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn) == 0x000008, "Wrong alignment on LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn");
static_assert(sizeof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn) == 0x0000A8, "Wrong size on LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn");
static_assert(offsetof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn, OverlappedComponent) == 0x000000, "Member 'LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn, OtherActor) == 0x000008, "Member 'LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn::OtherActor' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn, OtherComp) == 0x000010, "Member 'LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn::OtherComp' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn, OtherBodyIndex) == 0x000018, "Member 'LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn, bFromSweep) == 0x00001C, "Member 'LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn::bFromSweep' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn, SweepResult) == 0x000020, "Member 'LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn::SweepResult' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.OnComponentEndOverlapPropOverlapPawn
// 0x0020 (0x0020 - 0x0000)
struct LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn) == 0x000008, "Wrong alignment on LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn");
static_assert(sizeof(LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn) == 0x000020, "Wrong size on LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn");
static_assert(offsetof(LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn, OverlappedComponent) == 0x000000, "Member 'LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn, OtherActor) == 0x000008, "Member 'LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn::OtherActor' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn, OtherComp) == 0x000010, "Member 'LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn::OtherComp' has a wrong offset!");
static_assert(offsetof(LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn, OtherBodyIndex) == 0x000018, "Member 'LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn::OtherBodyIndex' has a wrong offset!");

// Function ProjectP.LTeleportObjectSpot.SetTeleportObjectCodeName
// 0x0008 (0x0008 - 0x0000)
struct LTeleportObjectSpot_SetTeleportObjectCodeName final
{
public:
	class FName                                   InCodeName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTeleportObjectSpot_SetTeleportObjectCodeName) == 0x000004, "Wrong alignment on LTeleportObjectSpot_SetTeleportObjectCodeName");
static_assert(sizeof(LTeleportObjectSpot_SetTeleportObjectCodeName) == 0x000008, "Wrong size on LTeleportObjectSpot_SetTeleportObjectCodeName");
static_assert(offsetof(LTeleportObjectSpot_SetTeleportObjectCodeName, InCodeName) == 0x000000, "Member 'LTeleportObjectSpot_SetTeleportObjectCodeName::InCodeName' has a wrong offset!");

// Function ProjectP.LTextLocalization.GetGameStr
// 0x0028 (0x0028 - 0x0000)
struct LTextLocalization_GetGameStr final
{
public:
	class FString                                 CodeName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTextLocalization_GetGameStr) == 0x000008, "Wrong alignment on LTextLocalization_GetGameStr");
static_assert(sizeof(LTextLocalization_GetGameStr) == 0x000028, "Wrong size on LTextLocalization_GetGameStr");
static_assert(offsetof(LTextLocalization_GetGameStr, CodeName) == 0x000000, "Member 'LTextLocalization_GetGameStr::CodeName' has a wrong offset!");
static_assert(offsetof(LTextLocalization_GetGameStr, ReturnValue) == 0x000010, "Member 'LTextLocalization_GetGameStr::ReturnValue' has a wrong offset!");

// Function ProjectP.LTextLocalization.GetGameStrWithName
// 0x0020 (0x0020 - 0x0000)
struct LTextLocalization_GetGameStrWithName final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LTextLocalization_GetGameStrWithName) == 0x000008, "Wrong alignment on LTextLocalization_GetGameStrWithName");
static_assert(sizeof(LTextLocalization_GetGameStrWithName) == 0x000020, "Wrong size on LTextLocalization_GetGameStrWithName");
static_assert(offsetof(LTextLocalization_GetGameStrWithName, CodeName) == 0x000000, "Member 'LTextLocalization_GetGameStrWithName::CodeName' has a wrong offset!");
static_assert(offsetof(LTextLocalization_GetGameStrWithName, ReturnValue) == 0x000008, "Member 'LTextLocalization_GetGameStrWithName::ReturnValue' has a wrong offset!");

// Function ProjectP.LUISystem.AddSystemMessage
// 0x0018 (0x0018 - 0x0000)
struct LUISystem_AddSystemMessage final
{
public:
	class FText                                   Message;                                           // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_AddSystemMessage) == 0x000008, "Wrong alignment on LUISystem_AddSystemMessage");
static_assert(sizeof(LUISystem_AddSystemMessage) == 0x000018, "Wrong size on LUISystem_AddSystemMessage");
static_assert(offsetof(LUISystem_AddSystemMessage, Message) == 0x000000, "Member 'LUISystem_AddSystemMessage::Message' has a wrong offset!");

// Function ProjectP.LUISystem.CompleteNotify_UI
// 0x0010 (0x0010 - 0x0000)
struct LUISystem_CompleteNotify_UI final
{
public:
	class FString                                 InUIName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_CompleteNotify_UI) == 0x000008, "Wrong alignment on LUISystem_CompleteNotify_UI");
static_assert(sizeof(LUISystem_CompleteNotify_UI) == 0x000010, "Wrong size on LUISystem_CompleteNotify_UI");
static_assert(offsetof(LUISystem_CompleteNotify_UI, InUIName) == 0x000000, "Member 'LUISystem_CompleteNotify_UI::InUIName' has a wrong offset!");

// Function ProjectP.LUISystem.GetAlertBlock
// 0x0001 (0x0001 - 0x0000)
struct LUISystem_GetAlertBlock final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_GetAlertBlock) == 0x000001, "Wrong alignment on LUISystem_GetAlertBlock");
static_assert(sizeof(LUISystem_GetAlertBlock) == 0x000001, "Wrong size on LUISystem_GetAlertBlock");
static_assert(offsetof(LUISystem_GetAlertBlock, ReturnValue) == 0x000000, "Member 'LUISystem_GetAlertBlock::ReturnValue' has a wrong offset!");

// Function ProjectP.LUISystem.GetLoadingScreenHandler
// 0x0008 (0x0008 - 0x0000)
struct LUISystem_GetLoadingScreenHandler final
{
public:
	class ULLoadingScreenHandler*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_GetLoadingScreenHandler) == 0x000008, "Wrong alignment on LUISystem_GetLoadingScreenHandler");
static_assert(sizeof(LUISystem_GetLoadingScreenHandler) == 0x000008, "Wrong size on LUISystem_GetLoadingScreenHandler");
static_assert(offsetof(LUISystem_GetLoadingScreenHandler, ReturnValue) == 0x000000, "Member 'LUISystem_GetLoadingScreenHandler::ReturnValue' has a wrong offset!");

// Function ProjectP.LUISystem.IsNotified_UI
// 0x0018 (0x0018 - 0x0000)
struct LUISystem_IsNotified_UI final
{
public:
	class FString                                 InUIName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LUISystem_IsNotified_UI) == 0x000008, "Wrong alignment on LUISystem_IsNotified_UI");
static_assert(sizeof(LUISystem_IsNotified_UI) == 0x000018, "Wrong size on LUISystem_IsNotified_UI");
static_assert(offsetof(LUISystem_IsNotified_UI, InUIName) == 0x000000, "Member 'LUISystem_IsNotified_UI::InUIName' has a wrong offset!");
static_assert(offsetof(LUISystem_IsNotified_UI, ReturnValue) == 0x000010, "Member 'LUISystem_IsNotified_UI::ReturnValue' has a wrong offset!");

// Function ProjectP.LUISystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LUISystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LUISystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LUISystem_OnGameDataCharacterSync");
static_assert(sizeof(LUISystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LUISystem_OnGameDataCharacterSync");
static_assert(offsetof(LUISystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LUISystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LUISystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LUISystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LUISystem.RemoveSystemMessage
// 0x0018 (0x0018 - 0x0000)
struct LUISystem_RemoveSystemMessage final
{
public:
	class FText                                   Message;                                           // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_RemoveSystemMessage) == 0x000008, "Wrong alignment on LUISystem_RemoveSystemMessage");
static_assert(sizeof(LUISystem_RemoveSystemMessage) == 0x000018, "Wrong size on LUISystem_RemoveSystemMessage");
static_assert(offsetof(LUISystem_RemoveSystemMessage, Message) == 0x000000, "Member 'LUISystem_RemoveSystemMessage::Message' has a wrong offset!");

// Function ProjectP.LUISystem.StartLoadingScreen
// 0x0001 (0x0001 - 0x0000)
struct LUISystem_StartLoadingScreen final
{
public:
	ELLoadingScreenType                           Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_StartLoadingScreen) == 0x000001, "Wrong alignment on LUISystem_StartLoadingScreen");
static_assert(sizeof(LUISystem_StartLoadingScreen) == 0x000001, "Wrong size on LUISystem_StartLoadingScreen");
static_assert(offsetof(LUISystem_StartLoadingScreen, Type) == 0x000000, "Member 'LUISystem_StartLoadingScreen::Type' has a wrong offset!");

// Function ProjectP.LUISystem.GetMainWidget
// 0x0008 (0x0008 - 0x0000)
struct LUISystem_GetMainWidget final
{
public:
	class ULWidget*                               ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LUISystem_GetMainWidget) == 0x000008, "Wrong alignment on LUISystem_GetMainWidget");
static_assert(sizeof(LUISystem_GetMainWidget) == 0x000008, "Wrong size on LUISystem_GetMainWidget");
static_assert(offsetof(LUISystem_GetMainWidget, ReturnValue) == 0x000000, "Member 'LUISystem_GetMainWidget::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetProgressRate
// 0x000C (0x000C - 0x0000)
struct LLoadingScreenHandler_GetProgressRate final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLevelLoadOnly;                               // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetProgressRate) == 0x000004, "Wrong alignment on LLoadingScreenHandler_GetProgressRate");
static_assert(sizeof(LLoadingScreenHandler_GetProgressRate) == 0x00000C, "Wrong size on LLoadingScreenHandler_GetProgressRate");
static_assert(offsetof(LLoadingScreenHandler_GetProgressRate, DeltaTime) == 0x000000, "Member 'LLoadingScreenHandler_GetProgressRate::DeltaTime' has a wrong offset!");
static_assert(offsetof(LLoadingScreenHandler_GetProgressRate, bCheckLevelLoadOnly) == 0x000004, "Member 'LLoadingScreenHandler_GetProgressRate::bCheckLevelLoadOnly' has a wrong offset!");
static_assert(offsetof(LLoadingScreenHandler_GetProgressRate, ReturnValue) == 0x000008, "Member 'LLoadingScreenHandler_GetProgressRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetSelectedLoadingScreenTableCodeName
// 0x0008 (0x0008 - 0x0000)
struct LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName) == 0x000004, "Wrong alignment on LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName");
static_assert(sizeof(LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName) == 0x000008, "Wrong size on LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName");
static_assert(offsetof(LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.MoveLifeTime
// 0x0004 (0x0004 - 0x0000)
struct LLoadingScreenHandler_MoveLifeTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_MoveLifeTime) == 0x000004, "Wrong alignment on LLoadingScreenHandler_MoveLifeTime");
static_assert(sizeof(LLoadingScreenHandler_MoveLifeTime) == 0x000004, "Wrong size on LLoadingScreenHandler_MoveLifeTime");
static_assert(offsetof(LLoadingScreenHandler_MoveLifeTime, Time) == 0x000000, "Member 'LLoadingScreenHandler_MoveLifeTime::Time' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.SelectLoadingScreenTable
// 0x0010 (0x0010 - 0x0000)
struct LLoadingScreenHandler_SelectLoadingScreenTable final
{
public:
	class ULDataTableSystem*                      DataTableSystem;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULQuestSystem*                          QuestSystem;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_SelectLoadingScreenTable) == 0x000008, "Wrong alignment on LLoadingScreenHandler_SelectLoadingScreenTable");
static_assert(sizeof(LLoadingScreenHandler_SelectLoadingScreenTable) == 0x000010, "Wrong size on LLoadingScreenHandler_SelectLoadingScreenTable");
static_assert(offsetof(LLoadingScreenHandler_SelectLoadingScreenTable, DataTableSystem) == 0x000000, "Member 'LLoadingScreenHandler_SelectLoadingScreenTable::DataTableSystem' has a wrong offset!");
static_assert(offsetof(LLoadingScreenHandler_SelectLoadingScreenTable, QuestSystem) == 0x000008, "Member 'LLoadingScreenHandler_SelectLoadingScreenTable::QuestSystem' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.SetIndicatorIndex
// 0x0004 (0x0004 - 0x0000)
struct LLoadingScreenHandler_SetIndicatorIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_SetIndicatorIndex) == 0x000004, "Wrong alignment on LLoadingScreenHandler_SetIndicatorIndex");
static_assert(sizeof(LLoadingScreenHandler_SetIndicatorIndex) == 0x000004, "Wrong size on LLoadingScreenHandler_SetIndicatorIndex");
static_assert(offsetof(LLoadingScreenHandler_SetIndicatorIndex, Index_0) == 0x000000, "Member 'LLoadingScreenHandler_SetIndicatorIndex::Index_0' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.StartLoadingSequence
// 0x000C (0x000C - 0x0000)
struct LLoadingScreenHandler_StartLoadingSequence final
{
public:
	struct FLLoadingScreenContext                 LoadingContext;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_StartLoadingSequence) == 0x000004, "Wrong alignment on LLoadingScreenHandler_StartLoadingSequence");
static_assert(sizeof(LLoadingScreenHandler_StartLoadingSequence) == 0x00000C, "Wrong size on LLoadingScreenHandler_StartLoadingSequence");
static_assert(offsetof(LLoadingScreenHandler_StartLoadingSequence, LoadingContext) == 0x000000, "Member 'LLoadingScreenHandler_StartLoadingSequence::LoadingContext' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.StopLoadingSequence
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_StopLoadingSequence final
{
public:
	ELLoadingScreenUsage                          Usage;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_StopLoadingSequence) == 0x000001, "Wrong alignment on LLoadingScreenHandler_StopLoadingSequence");
static_assert(sizeof(LLoadingScreenHandler_StopLoadingSequence) == 0x000001, "Wrong size on LLoadingScreenHandler_StopLoadingSequence");
static_assert(offsetof(LLoadingScreenHandler_StopLoadingSequence, Usage) == 0x000000, "Member 'LLoadingScreenHandler_StopLoadingSequence::Usage' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.VisibleLoading
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_VisibleLoading final
{
public:
	bool                                          bMainLoading;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_VisibleLoading) == 0x000001, "Wrong alignment on LLoadingScreenHandler_VisibleLoading");
static_assert(sizeof(LLoadingScreenHandler_VisibleLoading) == 0x000001, "Wrong size on LLoadingScreenHandler_VisibleLoading");
static_assert(offsetof(LLoadingScreenHandler_VisibleLoading, bMainLoading) == 0x000000, "Member 'LLoadingScreenHandler_VisibleLoading::bMainLoading' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetIndicatorIndex
// 0x0004 (0x0004 - 0x0000)
struct LLoadingScreenHandler_GetIndicatorIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetIndicatorIndex) == 0x000004, "Wrong alignment on LLoadingScreenHandler_GetIndicatorIndex");
static_assert(sizeof(LLoadingScreenHandler_GetIndicatorIndex) == 0x000004, "Wrong size on LLoadingScreenHandler_GetIndicatorIndex");
static_assert(offsetof(LLoadingScreenHandler_GetIndicatorIndex, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_GetIndicatorIndex::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetLifeTime
// 0x0004 (0x0004 - 0x0000)
struct LLoadingScreenHandler_GetLifeTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetLifeTime) == 0x000004, "Wrong alignment on LLoadingScreenHandler_GetLifeTime");
static_assert(sizeof(LLoadingScreenHandler_GetLifeTime) == 0x000004, "Wrong size on LLoadingScreenHandler_GetLifeTime");
static_assert(offsetof(LLoadingScreenHandler_GetLifeTime, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_GetLifeTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetSelectedImage
// 0x0028 (0x0028 - 0x0000)
struct LLoadingScreenHandler_GetSelectedImage final
{
public:
	TSoftObjectPtr<class UTexture2D>              ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetSelectedImage) == 0x000008, "Wrong alignment on LLoadingScreenHandler_GetSelectedImage");
static_assert(sizeof(LLoadingScreenHandler_GetSelectedImage) == 0x000028, "Wrong size on LLoadingScreenHandler_GetSelectedImage");
static_assert(offsetof(LLoadingScreenHandler_GetSelectedImage, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_GetSelectedImage::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetSelectedTipGameStringCodeNames
// 0x0010 (0x0010 - 0x0000)
struct LLoadingScreenHandler_GetSelectedTipGameStringCodeNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetSelectedTipGameStringCodeNames) == 0x000008, "Wrong alignment on LLoadingScreenHandler_GetSelectedTipGameStringCodeNames");
static_assert(sizeof(LLoadingScreenHandler_GetSelectedTipGameStringCodeNames) == 0x000010, "Wrong size on LLoadingScreenHandler_GetSelectedTipGameStringCodeNames");
static_assert(offsetof(LLoadingScreenHandler_GetSelectedTipGameStringCodeNames, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_GetSelectedTipGameStringCodeNames::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.GetUsage
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_GetUsage final
{
public:
	ELLoadingScreenUsage                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_GetUsage) == 0x000001, "Wrong alignment on LLoadingScreenHandler_GetUsage");
static_assert(sizeof(LLoadingScreenHandler_GetUsage) == 0x000001, "Wrong size on LLoadingScreenHandler_GetUsage");
static_assert(offsetof(LLoadingScreenHandler_GetUsage, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_GetUsage::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.IsLoadingComplete
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_IsLoadingComplete final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_IsLoadingComplete) == 0x000001, "Wrong alignment on LLoadingScreenHandler_IsLoadingComplete");
static_assert(sizeof(LLoadingScreenHandler_IsLoadingComplete) == 0x000001, "Wrong size on LLoadingScreenHandler_IsLoadingComplete");
static_assert(offsetof(LLoadingScreenHandler_IsLoadingComplete, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_IsLoadingComplete::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.IsLoadingSequence
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_IsLoadingSequence final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_IsLoadingSequence) == 0x000001, "Wrong alignment on LLoadingScreenHandler_IsLoadingSequence");
static_assert(sizeof(LLoadingScreenHandler_IsLoadingSequence) == 0x000001, "Wrong size on LLoadingScreenHandler_IsLoadingSequence");
static_assert(offsetof(LLoadingScreenHandler_IsLoadingSequence, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_IsLoadingSequence::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.IsLoadingVisible
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_IsLoadingVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_IsLoadingVisible) == 0x000001, "Wrong alignment on LLoadingScreenHandler_IsLoadingVisible");
static_assert(sizeof(LLoadingScreenHandler_IsLoadingVisible) == 0x000001, "Wrong size on LLoadingScreenHandler_IsLoadingVisible");
static_assert(offsetof(LLoadingScreenHandler_IsLoadingVisible, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_IsLoadingVisible::ReturnValue' has a wrong offset!");

// Function ProjectP.LLoadingScreenHandler.IsMovieEnabled
// 0x0001 (0x0001 - 0x0000)
struct LLoadingScreenHandler_IsMovieEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LLoadingScreenHandler_IsMovieEnabled) == 0x000001, "Wrong alignment on LLoadingScreenHandler_IsMovieEnabled");
static_assert(sizeof(LLoadingScreenHandler_IsMovieEnabled) == 0x000001, "Wrong size on LLoadingScreenHandler_IsMovieEnabled");
static_assert(offsetof(LLoadingScreenHandler_IsMovieEnabled, ReturnValue) == 0x000000, "Member 'LLoadingScreenHandler_IsMovieEnabled::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeaponDerbisBlade.GetActiveMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct LWeaponDerbisBlade_GetActiveMeshComponent final
{
public:
	class UMeshComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeaponDerbisBlade_GetActiveMeshComponent) == 0x000008, "Wrong alignment on LWeaponDerbisBlade_GetActiveMeshComponent");
static_assert(sizeof(LWeaponDerbisBlade_GetActiveMeshComponent) == 0x000008, "Wrong size on LWeaponDerbisBlade_GetActiveMeshComponent");
static_assert(offsetof(LWeaponDerbisBlade_GetActiveMeshComponent, ReturnValue) == 0x000000, "Member 'LWeaponDerbisBlade_GetActiveMeshComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.ApplyElement
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_ApplyElement final
{
public:
	class FName                                   ElementName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ApplyElement) == 0x000004, "Wrong alignment on LWeapon_ApplyElement");
static_assert(sizeof(LWeapon_ApplyElement) == 0x000008, "Wrong size on LWeapon_ApplyElement");
static_assert(offsetof(LWeapon_ApplyElement, ElementName) == 0x000000, "Member 'LWeapon_ApplyElement::ElementName' has a wrong offset!");

// Function ProjectP.LWeapon.ApplyFxParameter_BladeLength
// 0x001C (0x001C - 0x0000)
struct LWeapon_ApplyFxParameter_BladeLength final
{
public:
	struct FLAttachedEffectSet                    EffectSet;                                         // 0x0000(0x001C)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ApplyFxParameter_BladeLength) == 0x000004, "Wrong alignment on LWeapon_ApplyFxParameter_BladeLength");
static_assert(sizeof(LWeapon_ApplyFxParameter_BladeLength) == 0x00001C, "Wrong size on LWeapon_ApplyFxParameter_BladeLength");
static_assert(offsetof(LWeapon_ApplyFxParameter_BladeLength, EffectSet) == 0x000000, "Member 'LWeapon_ApplyFxParameter_BladeLength::EffectSet' has a wrong offset!");

// Function ProjectP.LWeapon.ApplyMaterialVarying
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_ApplyMaterialVarying final
{
public:
	class FName                                   MaterialFxCodename;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ApplyMaterialVarying) == 0x000004, "Wrong alignment on LWeapon_ApplyMaterialVarying");
static_assert(sizeof(LWeapon_ApplyMaterialVarying) == 0x000008, "Wrong size on LWeapon_ApplyMaterialVarying");
static_assert(offsetof(LWeapon_ApplyMaterialVarying, MaterialFxCodename) == 0x000000, "Member 'LWeapon_ApplyMaterialVarying::MaterialFxCodename' has a wrong offset!");

// Function ProjectP.LWeapon.BreakBlade
// 0x000C (0x000C - 0x0000)
struct LWeapon_BreakBlade final
{
public:
	struct FVector                                ImpulseDirection;                                  // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_BreakBlade) == 0x000004, "Wrong alignment on LWeapon_BreakBlade");
static_assert(sizeof(LWeapon_BreakBlade) == 0x00000C, "Wrong size on LWeapon_BreakBlade");
static_assert(offsetof(LWeapon_BreakBlade, ImpulseDirection) == 0x000000, "Member 'LWeapon_BreakBlade::ImpulseDirection' has a wrong offset!");

// Function ProjectP.LWeapon.BuildEachCollision_AutoLocation
// 0x0018 (0x0018 - 0x0000)
struct LWeapon_BuildEachCollision_AutoLocation final
{
public:
	class UCapsuleComponent*                      CollisionComp;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleOffset;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeapon_BuildEachCollision_AutoLocation) == 0x000008, "Wrong alignment on LWeapon_BuildEachCollision_AutoLocation");
static_assert(sizeof(LWeapon_BuildEachCollision_AutoLocation) == 0x000018, "Wrong size on LWeapon_BuildEachCollision_AutoLocation");
static_assert(offsetof(LWeapon_BuildEachCollision_AutoLocation, CollisionComp) == 0x000000, "Member 'LWeapon_BuildEachCollision_AutoLocation::CollisionComp' has a wrong offset!");
static_assert(offsetof(LWeapon_BuildEachCollision_AutoLocation, CapsuleOffset) == 0x000008, "Member 'LWeapon_BuildEachCollision_AutoLocation::CapsuleOffset' has a wrong offset!");

// Function ProjectP.LWeapon.BuildEachCollision_AutoSize
// 0x0018 (0x0018 - 0x0000)
struct LWeapon_BuildEachCollision_AutoSize final
{
public:
	class UCapsuleComponent*                      CollisionComp;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_BuildEachCollision_AutoSize) == 0x000008, "Wrong alignment on LWeapon_BuildEachCollision_AutoSize");
static_assert(sizeof(LWeapon_BuildEachCollision_AutoSize) == 0x000018, "Wrong size on LWeapon_BuildEachCollision_AutoSize");
static_assert(offsetof(LWeapon_BuildEachCollision_AutoSize, CollisionComp) == 0x000000, "Member 'LWeapon_BuildEachCollision_AutoSize::CollisionComp' has a wrong offset!");
static_assert(offsetof(LWeapon_BuildEachCollision_AutoSize, MeshComp) == 0x000008, "Member 'LWeapon_BuildEachCollision_AutoSize::MeshComp' has a wrong offset!");
static_assert(offsetof(LWeapon_BuildEachCollision_AutoSize, CapsuleRadius) == 0x000010, "Member 'LWeapon_BuildEachCollision_AutoSize::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(LWeapon_BuildEachCollision_AutoSize, CapsuleHalfHeight) == 0x000014, "Member 'LWeapon_BuildEachCollision_AutoSize::CapsuleHalfHeight' has a wrong offset!");

// Function ProjectP.LWeapon.ChangeAnimState
// 0x000C (0x000C - 0x0000)
struct LWeapon_ChangeAnimState final
{
public:
	ELWeaponPartType                              PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimState;                                         // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ChangeAnimState) == 0x000004, "Wrong alignment on LWeapon_ChangeAnimState");
static_assert(sizeof(LWeapon_ChangeAnimState) == 0x00000C, "Wrong size on LWeapon_ChangeAnimState");
static_assert(offsetof(LWeapon_ChangeAnimState, PartType) == 0x000000, "Member 'LWeapon_ChangeAnimState::PartType' has a wrong offset!");
static_assert(offsetof(LWeapon_ChangeAnimState, AnimState) == 0x000004, "Member 'LWeapon_ChangeAnimState::AnimState' has a wrong offset!");

// Function ProjectP.LWeapon.ChangeAnimStateInner
// 0x000C (0x000C - 0x0000)
struct LWeapon_ChangeAnimStateInner final
{
public:
	ELWeaponPartType                              PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InAnimState;                                       // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ChangeAnimStateInner) == 0x000004, "Wrong alignment on LWeapon_ChangeAnimStateInner");
static_assert(sizeof(LWeapon_ChangeAnimStateInner) == 0x00000C, "Wrong size on LWeapon_ChangeAnimStateInner");
static_assert(offsetof(LWeapon_ChangeAnimStateInner, PartType) == 0x000000, "Member 'LWeapon_ChangeAnimStateInner::PartType' has a wrong offset!");
static_assert(offsetof(LWeapon_ChangeAnimStateInner, InAnimState) == 0x000004, "Member 'LWeapon_ChangeAnimStateInner::InAnimState' has a wrong offset!");

// Function ProjectP.LWeapon.ClearAnimState
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_ClearAnimState final
{
public:
	ELWeaponPartType                              PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ClearAnimState) == 0x000001, "Wrong alignment on LWeapon_ClearAnimState");
static_assert(sizeof(LWeapon_ClearAnimState) == 0x000001, "Wrong size on LWeapon_ClearAnimState");
static_assert(offsetof(LWeapon_ClearAnimState, PartType) == 0x000000, "Member 'LWeapon_ClearAnimState::PartType' has a wrong offset!");

// Function ProjectP.LWeapon.CreateHandleTemplate
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_CreateHandleTemplate final
{
public:
	class ALWeapon*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_CreateHandleTemplate) == 0x000008, "Wrong alignment on LWeapon_CreateHandleTemplate");
static_assert(sizeof(LWeapon_CreateHandleTemplate) == 0x000008, "Wrong size on LWeapon_CreateHandleTemplate");
static_assert(offsetof(LWeapon_CreateHandleTemplate, ReturnValue) == 0x000000, "Member 'LWeapon_CreateHandleTemplate::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.DecreaseDestructionDurability
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_DecreaseDestructionDurability final
{
public:
	int32                                         Durability;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVictimGuard;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumed;                                         // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestructed;                                       // 0x0006(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeapon_DecreaseDestructionDurability) == 0x000004, "Wrong alignment on LWeapon_DecreaseDestructionDurability");
static_assert(sizeof(LWeapon_DecreaseDestructionDurability) == 0x000008, "Wrong size on LWeapon_DecreaseDestructionDurability");
static_assert(offsetof(LWeapon_DecreaseDestructionDurability, Durability) == 0x000000, "Member 'LWeapon_DecreaseDestructionDurability::Durability' has a wrong offset!");
static_assert(offsetof(LWeapon_DecreaseDestructionDurability, bVictimGuard) == 0x000004, "Member 'LWeapon_DecreaseDestructionDurability::bVictimGuard' has a wrong offset!");
static_assert(offsetof(LWeapon_DecreaseDestructionDurability, bConsumed) == 0x000005, "Member 'LWeapon_DecreaseDestructionDurability::bConsumed' has a wrong offset!");
static_assert(offsetof(LWeapon_DecreaseDestructionDurability, bDestructed) == 0x000006, "Member 'LWeapon_DecreaseDestructionDurability::bDestructed' has a wrong offset!");

// Function ProjectP.LWeapon.GetBladeCollision
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetBladeCollision final
{
public:
	class ULWeaponBladeComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetBladeCollision) == 0x000008, "Wrong alignment on LWeapon_GetBladeCollision");
static_assert(sizeof(LWeapon_GetBladeCollision) == 0x000008, "Wrong size on LWeapon_GetBladeCollision");
static_assert(offsetof(LWeapon_GetBladeCollision, ReturnValue) == 0x000000, "Member 'LWeapon_GetBladeCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetBladeCommonInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetBladeCommonInfo final
{
public:
	struct FItemCommonInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetBladeCommonInfo) == 0x000008, "Wrong alignment on LWeapon_GetBladeCommonInfo");
static_assert(sizeof(LWeapon_GetBladeCommonInfo) == 0x000008, "Wrong size on LWeapon_GetBladeCommonInfo");
static_assert(offsetof(LWeapon_GetBladeCommonInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetBladeCommonInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetBrokenBladeOnBuild
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_GetBrokenBladeOnBuild final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetBrokenBladeOnBuild) == 0x000001, "Wrong alignment on LWeapon_GetBrokenBladeOnBuild");
static_assert(sizeof(LWeapon_GetBrokenBladeOnBuild) == 0x000001, "Wrong size on LWeapon_GetBrokenBladeOnBuild");
static_assert(offsetof(LWeapon_GetBrokenBladeOnBuild, ReturnValue) == 0x000000, "Member 'LWeapon_GetBrokenBladeOnBuild::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetHandleCapsuleRadius
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetHandleCapsuleRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetHandleCapsuleRadius) == 0x000004, "Wrong alignment on LWeapon_GetHandleCapsuleRadius");
static_assert(sizeof(LWeapon_GetHandleCapsuleRadius) == 0x000004, "Wrong size on LWeapon_GetHandleCapsuleRadius");
static_assert(offsetof(LWeapon_GetHandleCapsuleRadius, ReturnValue) == 0x000000, "Member 'LWeapon_GetHandleCapsuleRadius::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetHandleCollision
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetHandleCollision final
{
public:
	class ULWeaponHandleComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetHandleCollision) == 0x000008, "Wrong alignment on LWeapon_GetHandleCollision");
static_assert(sizeof(LWeapon_GetHandleCollision) == 0x000008, "Wrong size on LWeapon_GetHandleCollision");
static_assert(offsetof(LWeapon_GetHandleCollision, ReturnValue) == 0x000000, "Member 'LWeapon_GetHandleCollision::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetHandleCommonInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetHandleCommonInfo final
{
public:
	struct FItemCommonInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetHandleCommonInfo) == 0x000008, "Wrong alignment on LWeapon_GetHandleCommonInfo");
static_assert(sizeof(LWeapon_GetHandleCommonInfo) == 0x000008, "Wrong size on LWeapon_GetHandleCommonInfo");
static_assert(offsetof(LWeapon_GetHandleCommonInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetHandleCommonInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetItem
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetItem final
{
public:
	class ULWeaponItem*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetItem) == 0x000008, "Wrong alignment on LWeapon_GetItem");
static_assert(sizeof(LWeapon_GetItem) == 0x000008, "Wrong size on LWeapon_GetItem");
static_assert(offsetof(LWeapon_GetItem, ReturnValue) == 0x000000, "Member 'LWeapon_GetItem::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetMonsterWeaponInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetMonsterWeaponInfo final
{
public:
	struct FItemWeaponMonsterPtr                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetMonsterWeaponInfo) == 0x000008, "Wrong alignment on LWeapon_GetMonsterWeaponInfo");
static_assert(sizeof(LWeapon_GetMonsterWeaponInfo) == 0x000008, "Wrong size on LWeapon_GetMonsterWeaponInfo");
static_assert(offsetof(LWeapon_GetMonsterWeaponInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetMonsterWeaponInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetSkillDist
// 0x0014 (0x0014 - 0x0000)
struct LWeapon_GetSkillDist final
{
public:
	int32                                         AddSkillDist;                                      // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillDistMin;                                      // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillDistMax;                                      // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDistRateMin;                                  // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDistRateMax;                                  // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetSkillDist) == 0x000004, "Wrong alignment on LWeapon_GetSkillDist");
static_assert(sizeof(LWeapon_GetSkillDist) == 0x000014, "Wrong size on LWeapon_GetSkillDist");
static_assert(offsetof(LWeapon_GetSkillDist, AddSkillDist) == 0x000000, "Member 'LWeapon_GetSkillDist::AddSkillDist' has a wrong offset!");
static_assert(offsetof(LWeapon_GetSkillDist, SkillDistMin) == 0x000004, "Member 'LWeapon_GetSkillDist::SkillDistMin' has a wrong offset!");
static_assert(offsetof(LWeapon_GetSkillDist, SkillDistMax) == 0x000008, "Member 'LWeapon_GetSkillDist::SkillDistMax' has a wrong offset!");
static_assert(offsetof(LWeapon_GetSkillDist, SkillDistRateMin) == 0x00000C, "Member 'LWeapon_GetSkillDist::SkillDistRateMin' has a wrong offset!");
static_assert(offsetof(LWeapon_GetSkillDist, SkillDistRateMax) == 0x000010, "Member 'LWeapon_GetSkillDist::SkillDistRateMax' has a wrong offset!");

// Function ProjectP.LWeapon.GetSkillHitCodeName
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetSkillHitCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetSkillHitCodeName) == 0x000004, "Wrong alignment on LWeapon_GetSkillHitCodeName");
static_assert(sizeof(LWeapon_GetSkillHitCodeName) == 0x000008, "Wrong size on LWeapon_GetSkillHitCodeName");
static_assert(offsetof(LWeapon_GetSkillHitCodeName, ReturnValue) == 0x000000, "Member 'LWeapon_GetSkillHitCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.JoinHandleAndBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_JoinHandleAndBlade final
{
public:
	bool                                          bBrokenBladeBuild;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_JoinHandleAndBlade) == 0x000001, "Wrong alignment on LWeapon_JoinHandleAndBlade");
static_assert(sizeof(LWeapon_JoinHandleAndBlade) == 0x000001, "Wrong size on LWeapon_JoinHandleAndBlade");
static_assert(offsetof(LWeapon_JoinHandleAndBlade, bBrokenBladeBuild) == 0x000000, "Member 'LWeapon_JoinHandleAndBlade::bBrokenBladeBuild' has a wrong offset!");

// Function ProjectP.LWeapon.OnApplyRunningAbnormal
// 0x000C (0x000C - 0x0000)
struct LWeapon_OnApplyRunningAbnormal final
{
public:
	bool                                          IsApply;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbnormalCodeName;                                  // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_OnApplyRunningAbnormal) == 0x000004, "Wrong alignment on LWeapon_OnApplyRunningAbnormal");
static_assert(sizeof(LWeapon_OnApplyRunningAbnormal) == 0x00000C, "Wrong size on LWeapon_OnApplyRunningAbnormal");
static_assert(offsetof(LWeapon_OnApplyRunningAbnormal, IsApply) == 0x000000, "Member 'LWeapon_OnApplyRunningAbnormal::IsApply' has a wrong offset!");
static_assert(offsetof(LWeapon_OnApplyRunningAbnormal, AbnormalCodeName) == 0x000004, "Member 'LWeapon_OnApplyRunningAbnormal::AbnormalCodeName' has a wrong offset!");

// Function ProjectP.LWeapon.OnBreakBlade
// 0x0018 (0x0018 - 0x0000)
struct LWeapon_OnBreakBlade final
{
public:
	struct FVector                                BreakPointLocation;                                // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpulseDirection;                                  // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_OnBreakBlade) == 0x000004, "Wrong alignment on LWeapon_OnBreakBlade");
static_assert(sizeof(LWeapon_OnBreakBlade) == 0x000018, "Wrong size on LWeapon_OnBreakBlade");
static_assert(offsetof(LWeapon_OnBreakBlade, BreakPointLocation) == 0x000000, "Member 'LWeapon_OnBreakBlade::BreakPointLocation' has a wrong offset!");
static_assert(offsetof(LWeapon_OnBreakBlade, ImpulseDirection) == 0x00000C, "Member 'LWeapon_OnBreakBlade::ImpulseDirection' has a wrong offset!");

// Function ProjectP.LWeapon.OnDuplicateHandle
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_OnDuplicateHandle final
{
public:
	class ALWeapon*                               DuplicatedHandle;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_OnDuplicateHandle) == 0x000008, "Wrong alignment on LWeapon_OnDuplicateHandle");
static_assert(sizeof(LWeapon_OnDuplicateHandle) == 0x000008, "Wrong size on LWeapon_OnDuplicateHandle");
static_assert(offsetof(LWeapon_OnDuplicateHandle, DuplicatedHandle) == 0x000000, "Member 'LWeapon_OnDuplicateHandle::DuplicatedHandle' has a wrong offset!");

// Function ProjectP.LWeapon.OnFxSocketTraceEvent
// 0x0110 (0x0110 - 0x0000)
struct LWeapon_OnFxSocketTraceEvent final
{
public:
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFxSocketTracerInfo                   SocketTraceInfo;                                   // 0x0008(0x0108)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_OnFxSocketTraceEvent) == 0x000008, "Wrong alignment on LWeapon_OnFxSocketTraceEvent");
static_assert(sizeof(LWeapon_OnFxSocketTraceEvent) == 0x000110, "Wrong size on LWeapon_OnFxSocketTraceEvent");
static_assert(offsetof(LWeapon_OnFxSocketTraceEvent, ActMgrComponent) == 0x000000, "Member 'LWeapon_OnFxSocketTraceEvent::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(LWeapon_OnFxSocketTraceEvent, SocketTraceInfo) == 0x000008, "Member 'LWeapon_OnFxSocketTraceEvent::SocketTraceInfo' has a wrong offset!");

// Function ProjectP.LWeapon.OnWeaponChanged
// 0x0010 (0x0010 - 0x0000)
struct LWeapon_OnWeaponChanged final
{
public:
	class ALWeapon*                               From;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               To;                                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_OnWeaponChanged) == 0x000008, "Wrong alignment on LWeapon_OnWeaponChanged");
static_assert(sizeof(LWeapon_OnWeaponChanged) == 0x000010, "Wrong size on LWeapon_OnWeaponChanged");
static_assert(offsetof(LWeapon_OnWeaponChanged, From) == 0x000000, "Member 'LWeapon_OnWeaponChanged::From' has a wrong offset!");
static_assert(offsetof(LWeapon_OnWeaponChanged, To) == 0x000008, "Member 'LWeapon_OnWeaponChanged::To' has a wrong offset!");

// Function ProjectP.LWeapon.OnWeaponOnOff
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_OnWeaponOnOff final
{
public:
	bool                                          bOnOff;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_OnWeaponOnOff) == 0x000001, "Wrong alignment on LWeapon_OnWeaponOnOff");
static_assert(sizeof(LWeapon_OnWeaponOnOff) == 0x000001, "Wrong size on LWeapon_OnWeaponOnOff");
static_assert(offsetof(LWeapon_OnWeaponOnOff, bOnOff) == 0x000000, "Member 'LWeapon_OnWeaponOnOff::bOnOff' has a wrong offset!");

// Function ProjectP.LWeapon.ProcessDestructionDurability
// 0x0014 (0x0014 - 0x0000)
struct LWeapon_ProcessDestructionDurability final
{
public:
	int32                                         ConsumeAmount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpulseDirection;                                  // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessConsume;                                   // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestructNow;                                      // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeapon_ProcessDestructionDurability) == 0x000004, "Wrong alignment on LWeapon_ProcessDestructionDurability");
static_assert(sizeof(LWeapon_ProcessDestructionDurability) == 0x000014, "Wrong size on LWeapon_ProcessDestructionDurability");
static_assert(offsetof(LWeapon_ProcessDestructionDurability, ConsumeAmount) == 0x000000, "Member 'LWeapon_ProcessDestructionDurability::ConsumeAmount' has a wrong offset!");
static_assert(offsetof(LWeapon_ProcessDestructionDurability, ImpulseDirection) == 0x000004, "Member 'LWeapon_ProcessDestructionDurability::ImpulseDirection' has a wrong offset!");
static_assert(offsetof(LWeapon_ProcessDestructionDurability, bSuccessConsume) == 0x000010, "Member 'LWeapon_ProcessDestructionDurability::bSuccessConsume' has a wrong offset!");
static_assert(offsetof(LWeapon_ProcessDestructionDurability, bDestructNow) == 0x000011, "Member 'LWeapon_ProcessDestructionDurability::bDestructNow' has a wrong offset!");

// Function ProjectP.LWeapon.RemoveElement
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_RemoveElement final
{
public:
	class FName                                   ElementName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_RemoveElement) == 0x000004, "Wrong alignment on LWeapon_RemoveElement");
static_assert(sizeof(LWeapon_RemoveElement) == 0x000008, "Wrong size on LWeapon_RemoveElement");
static_assert(offsetof(LWeapon_RemoveElement, ElementName) == 0x000000, "Member 'LWeapon_RemoveElement::ElementName' has a wrong offset!");

// Function ProjectP.LWeapon.RemoveMaterialVarying
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_RemoveMaterialVarying final
{
public:
	class FName                                   MaterialFxCodename;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_RemoveMaterialVarying) == 0x000004, "Wrong alignment on LWeapon_RemoveMaterialVarying");
static_assert(sizeof(LWeapon_RemoveMaterialVarying) == 0x000008, "Wrong size on LWeapon_RemoveMaterialVarying");
static_assert(offsetof(LWeapon_RemoveMaterialVarying, MaterialFxCodename) == 0x000000, "Member 'LWeapon_RemoveMaterialVarying::MaterialFxCodename' has a wrong offset!");

// Function ProjectP.LWeapon.ReplaceBreakBlade
// 0x000C (0x000C - 0x0000)
struct LWeapon_ReplaceBreakBlade final
{
public:
	struct FVector                                ImpulseDirection;                                  // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ReplaceBreakBlade) == 0x000004, "Wrong alignment on LWeapon_ReplaceBreakBlade");
static_assert(sizeof(LWeapon_ReplaceBreakBlade) == 0x00000C, "Wrong size on LWeapon_ReplaceBreakBlade");
static_assert(offsetof(LWeapon_ReplaceBreakBlade, ImpulseDirection) == 0x000000, "Member 'LWeapon_ReplaceBreakBlade::ImpulseDirection' has a wrong offset!");

// Function ProjectP.LWeapon.SetAnimRateScale
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_SetAnimRateScale final
{
public:
	ELWeaponPartType                              PartType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleRate;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_SetAnimRateScale) == 0x000004, "Wrong alignment on LWeapon_SetAnimRateScale");
static_assert(sizeof(LWeapon_SetAnimRateScale) == 0x000008, "Wrong size on LWeapon_SetAnimRateScale");
static_assert(offsetof(LWeapon_SetAnimRateScale, PartType) == 0x000000, "Member 'LWeapon_SetAnimRateScale::PartType' has a wrong offset!");
static_assert(offsetof(LWeapon_SetAnimRateScale, ScaleRate) == 0x000004, "Member 'LWeapon_SetAnimRateScale::ScaleRate' has a wrong offset!");

// Function ProjectP.LWeapon.SetMonsterWeapon
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_SetMonsterWeapon final
{
public:
	class FName                                   ItemMonsterWeaponCodeName;                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_SetMonsterWeapon) == 0x000004, "Wrong alignment on LWeapon_SetMonsterWeapon");
static_assert(sizeof(LWeapon_SetMonsterWeapon) == 0x000008, "Wrong size on LWeapon_SetMonsterWeapon");
static_assert(offsetof(LWeapon_SetMonsterWeapon, ItemMonsterWeaponCodeName) == 0x000000, "Member 'LWeapon_SetMonsterWeapon::ItemMonsterWeaponCodeName' has a wrong offset!");

// Function ProjectP.LWeapon.SetWeaponAttachmentInfo
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_SetWeaponAttachmentInfo final
{
public:
	ELWeaponAttachPointType                       InWeaponAttachPointType;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_SetWeaponAttachmentInfo) == 0x000001, "Wrong alignment on LWeapon_SetWeaponAttachmentInfo");
static_assert(sizeof(LWeapon_SetWeaponAttachmentInfo) == 0x000001, "Wrong size on LWeapon_SetWeaponAttachmentInfo");
static_assert(offsetof(LWeapon_SetWeaponAttachmentInfo, InWeaponAttachPointType) == 0x000000, "Member 'LWeapon_SetWeaponAttachmentInfo::InWeaponAttachPointType' has a wrong offset!");

// Function ProjectP.LWeapon.SetWeaponClass
// 0x0010 (0x0010 - 0x0000)
struct LWeapon_SetWeaponClass final
{
public:
	TSubclassOf<class ALWeapon>                   InHandleWeaponClass;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALWeapon>                   InBladeWeaponClass;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_SetWeaponClass) == 0x000008, "Wrong alignment on LWeapon_SetWeaponClass");
static_assert(sizeof(LWeapon_SetWeaponClass) == 0x000010, "Wrong size on LWeapon_SetWeaponClass");
static_assert(offsetof(LWeapon_SetWeaponClass, InHandleWeaponClass) == 0x000000, "Member 'LWeapon_SetWeaponClass::InHandleWeaponClass' has a wrong offset!");
static_assert(offsetof(LWeapon_SetWeaponClass, InBladeWeaponClass) == 0x000008, "Member 'LWeapon_SetWeaponClass::InBladeWeaponClass' has a wrong offset!");

// Function ProjectP.LWeapon.SetWeaponItem
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_SetWeaponItem final
{
public:
	class ULWeaponItem*                           Item_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_SetWeaponItem) == 0x000008, "Wrong alignment on LWeapon_SetWeaponItem");
static_assert(sizeof(LWeapon_SetWeaponItem) == 0x000008, "Wrong size on LWeapon_SetWeaponItem");
static_assert(offsetof(LWeapon_SetWeaponItem, Item_0) == 0x000000, "Member 'LWeapon_SetWeaponItem::Item_0' has a wrong offset!");

// Function ProjectP.LWeapon.CanJoinHandleBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_CanJoinHandleBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_CanJoinHandleBlade) == 0x000001, "Wrong alignment on LWeapon_CanJoinHandleBlade");
static_assert(sizeof(LWeapon_CanJoinHandleBlade) == 0x000001, "Wrong size on LWeapon_CanJoinHandleBlade");
static_assert(offsetof(LWeapon_CanJoinHandleBlade, ReturnValue) == 0x000000, "Member 'LWeapon_CanJoinHandleBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetAddtiveSkillHitCodeName
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetAddtiveSkillHitCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetAddtiveSkillHitCodeName) == 0x000004, "Wrong alignment on LWeapon_GetAddtiveSkillHitCodeName");
static_assert(sizeof(LWeapon_GetAddtiveSkillHitCodeName) == 0x000008, "Wrong size on LWeapon_GetAddtiveSkillHitCodeName");
static_assert(offsetof(LWeapon_GetAddtiveSkillHitCodeName, ReturnValue) == 0x000000, "Member 'LWeapon_GetAddtiveSkillHitCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetAtkPowerRate
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetAtkPowerRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetAtkPowerRate) == 0x000004, "Wrong alignment on LWeapon_GetAtkPowerRate");
static_assert(sizeof(LWeapon_GetAtkPowerRate) == 0x000004, "Wrong size on LWeapon_GetAtkPowerRate");
static_assert(offsetof(LWeapon_GetAtkPowerRate, ReturnValue) == 0x000000, "Member 'LWeapon_GetAtkPowerRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetAttachPointBlade
// 0x000C (0x000C - 0x0000)
struct LWeapon_GetAttachPointBlade final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetAttachPointBlade) == 0x000004, "Wrong alignment on LWeapon_GetAttachPointBlade");
static_assert(sizeof(LWeapon_GetAttachPointBlade) == 0x00000C, "Wrong size on LWeapon_GetAttachPointBlade");
static_assert(offsetof(LWeapon_GetAttachPointBlade, ReturnValue) == 0x000000, "Member 'LWeapon_GetAttachPointBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetBladeFableArtsSkillInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetBladeFableArtsSkillInfo final
{
public:
	struct FSkillInfoPtr                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetBladeFableArtsSkillInfo) == 0x000008, "Wrong alignment on LWeapon_GetBladeFableArtsSkillInfo");
static_assert(sizeof(LWeapon_GetBladeFableArtsSkillInfo) == 0x000008, "Wrong size on LWeapon_GetBladeFableArtsSkillInfo");
static_assert(offsetof(LWeapon_GetBladeFableArtsSkillInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetBladeFableArtsSkillInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetBladeInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetBladeInfo final
{
public:
	struct FItemBladeInfoPtr                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetBladeInfo) == 0x000008, "Wrong alignment on LWeapon_GetBladeInfo");
static_assert(sizeof(LWeapon_GetBladeInfo) == 0x000008, "Wrong size on LWeapon_GetBladeInfo");
static_assert(offsetof(LWeapon_GetBladeInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetBladeInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetBladeLength
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetBladeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetBladeLength) == 0x000004, "Wrong alignment on LWeapon_GetBladeLength");
static_assert(sizeof(LWeapon_GetBladeLength) == 0x000004, "Wrong size on LWeapon_GetBladeLength");
static_assert(offsetof(LWeapon_GetBladeLength, ReturnValue) == 0x000000, "Member 'LWeapon_GetBladeLength::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetDestructionDurability
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetDestructionDurability final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetDestructionDurability) == 0x000004, "Wrong alignment on LWeapon_GetDestructionDurability");
static_assert(sizeof(LWeapon_GetDestructionDurability) == 0x000004, "Wrong size on LWeapon_GetDestructionDurability");
static_assert(offsetof(LWeapon_GetDestructionDurability, ReturnValue) == 0x000000, "Member 'LWeapon_GetDestructionDurability::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetEquipAbnormalCodeName
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetEquipAbnormalCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetEquipAbnormalCodeName) == 0x000004, "Wrong alignment on LWeapon_GetEquipAbnormalCodeName");
static_assert(sizeof(LWeapon_GetEquipAbnormalCodeName) == 0x000008, "Wrong size on LWeapon_GetEquipAbnormalCodeName");
static_assert(offsetof(LWeapon_GetEquipAbnormalCodeName, ReturnValue) == 0x000000, "Member 'LWeapon_GetEquipAbnormalCodeName::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetHandleFableArtsSkillInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetHandleFableArtsSkillInfo final
{
public:
	struct FSkillInfoPtr                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetHandleFableArtsSkillInfo) == 0x000008, "Wrong alignment on LWeapon_GetHandleFableArtsSkillInfo");
static_assert(sizeof(LWeapon_GetHandleFableArtsSkillInfo) == 0x000008, "Wrong size on LWeapon_GetHandleFableArtsSkillInfo");
static_assert(offsetof(LWeapon_GetHandleFableArtsSkillInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetHandleFableArtsSkillInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetHandleInfo
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetHandleInfo final
{
public:
	struct FItemHandleInfoPtr                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetHandleInfo) == 0x000008, "Wrong alignment on LWeapon_GetHandleInfo");
static_assert(sizeof(LWeapon_GetHandleInfo) == 0x000008, "Wrong size on LWeapon_GetHandleInfo");
static_assert(offsetof(LWeapon_GetHandleInfo, ReturnValue) == 0x000000, "Member 'LWeapon_GetHandleInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetMaxDestructionDurability
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetMaxDestructionDurability final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetMaxDestructionDurability) == 0x000004, "Wrong alignment on LWeapon_GetMaxDestructionDurability");
static_assert(sizeof(LWeapon_GetMaxDestructionDurability) == 0x000004, "Wrong size on LWeapon_GetMaxDestructionDurability");
static_assert(offsetof(LWeapon_GetMaxDestructionDurability, ReturnValue) == 0x000000, "Member 'LWeapon_GetMaxDestructionDurability::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetMotionSpeedRate
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetMotionSpeedRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetMotionSpeedRate) == 0x000004, "Wrong alignment on LWeapon_GetMotionSpeedRate");
static_assert(sizeof(LWeapon_GetMotionSpeedRate) == 0x000004, "Wrong size on LWeapon_GetMotionSpeedRate");
static_assert(offsetof(LWeapon_GetMotionSpeedRate, ReturnValue) == 0x000000, "Member 'LWeapon_GetMotionSpeedRate::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetMulpleRateAtkPowerAfterBoken
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetMulpleRateAtkPowerAfterBoken final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetMulpleRateAtkPowerAfterBoken) == 0x000004, "Wrong alignment on LWeapon_GetMulpleRateAtkPowerAfterBoken");
static_assert(sizeof(LWeapon_GetMulpleRateAtkPowerAfterBoken) == 0x000004, "Wrong size on LWeapon_GetMulpleRateAtkPowerAfterBoken");
static_assert(offsetof(LWeapon_GetMulpleRateAtkPowerAfterBoken, ReturnValue) == 0x000000, "Member 'LWeapon_GetMulpleRateAtkPowerAfterBoken::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetMulpleRateDestructionPowerAfterBroken
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_GetMulpleRateDestructionPowerAfterBroken final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetMulpleRateDestructionPowerAfterBroken) == 0x000004, "Wrong alignment on LWeapon_GetMulpleRateDestructionPowerAfterBroken");
static_assert(sizeof(LWeapon_GetMulpleRateDestructionPowerAfterBroken) == 0x000004, "Wrong size on LWeapon_GetMulpleRateDestructionPowerAfterBroken");
static_assert(offsetof(LWeapon_GetMulpleRateDestructionPowerAfterBroken, ReturnValue) == 0x000000, "Member 'LWeapon_GetMulpleRateDestructionPowerAfterBroken::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetWeaponAttachPointType
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_GetWeaponAttachPointType final
{
public:
	ELWeaponAttachPointType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetWeaponAttachPointType) == 0x000001, "Wrong alignment on LWeapon_GetWeaponAttachPointType");
static_assert(sizeof(LWeapon_GetWeaponAttachPointType) == 0x000001, "Wrong size on LWeapon_GetWeaponAttachPointType");
static_assert(offsetof(LWeapon_GetWeaponAttachPointType, ReturnValue) == 0x000000, "Member 'LWeapon_GetWeaponAttachPointType::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.GetWeaponOwner
// 0x0008 (0x0008 - 0x0000)
struct LWeapon_GetWeaponOwner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_GetWeaponOwner) == 0x000008, "Wrong alignment on LWeapon_GetWeaponOwner");
static_assert(sizeof(LWeapon_GetWeaponOwner) == 0x000008, "Wrong size on LWeapon_GetWeaponOwner");
static_assert(offsetof(LWeapon_GetWeaponOwner, ReturnValue) == 0x000000, "Member 'LWeapon_GetWeaponOwner::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.HasBroken
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_HasBroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_HasBroken) == 0x000001, "Wrong alignment on LWeapon_HasBroken");
static_assert(sizeof(LWeapon_HasBroken) == 0x000001, "Wrong size on LWeapon_HasBroken");
static_assert(offsetof(LWeapon_HasBroken, ReturnValue) == 0x000000, "Member 'LWeapon_HasBroken::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.HasCollisionComponent
// 0x0010 (0x0010 - 0x0000)
struct LWeapon_HasCollisionComponent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWeapon_HasCollisionComponent) == 0x000008, "Wrong alignment on LWeapon_HasCollisionComponent");
static_assert(sizeof(LWeapon_HasCollisionComponent) == 0x000010, "Wrong size on LWeapon_HasCollisionComponent");
static_assert(offsetof(LWeapon_HasCollisionComponent, Component) == 0x000000, "Member 'LWeapon_HasCollisionComponent::Component' has a wrong offset!");
static_assert(offsetof(LWeapon_HasCollisionComponent, ReturnValue) == 0x000008, "Member 'LWeapon_HasCollisionComponent::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsDroped
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsDroped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsDroped) == 0x000001, "Wrong alignment on LWeapon_IsDroped");
static_assert(sizeof(LWeapon_IsDroped) == 0x000001, "Wrong size on LWeapon_IsDroped");
static_assert(offsetof(LWeapon_IsDroped, ReturnValue) == 0x000000, "Member 'LWeapon_IsDroped::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsMonsterWeapon
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsMonsterWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsMonsterWeapon) == 0x000001, "Wrong alignment on LWeapon_IsMonsterWeapon");
static_assert(sizeof(LWeapon_IsMonsterWeapon) == 0x000001, "Wrong size on LWeapon_IsMonsterWeapon");
static_assert(offsetof(LWeapon_IsMonsterWeapon, ReturnValue) == 0x000000, "Member 'LWeapon_IsMonsterWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsNewBreakBlade
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsNewBreakBlade final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsNewBreakBlade) == 0x000001, "Wrong alignment on LWeapon_IsNewBreakBlade");
static_assert(sizeof(LWeapon_IsNewBreakBlade) == 0x000001, "Wrong size on LWeapon_IsNewBreakBlade");
static_assert(offsetof(LWeapon_IsNewBreakBlade, ReturnValue) == 0x000000, "Member 'LWeapon_IsNewBreakBlade::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsPickedWeapon
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsPickedWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsPickedWeapon) == 0x000001, "Wrong alignment on LWeapon_IsPickedWeapon");
static_assert(sizeof(LWeapon_IsPickedWeapon) == 0x000001, "Wrong size on LWeapon_IsPickedWeapon");
static_assert(offsetof(LWeapon_IsPickedWeapon, ReturnValue) == 0x000000, "Member 'LWeapon_IsPickedWeapon::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsRemoveAbnormalStateAfterBroken
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsRemoveAbnormalStateAfterBroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsRemoveAbnormalStateAfterBroken) == 0x000001, "Wrong alignment on LWeapon_IsRemoveAbnormalStateAfterBroken");
static_assert(sizeof(LWeapon_IsRemoveAbnormalStateAfterBroken) == 0x000001, "Wrong size on LWeapon_IsRemoveAbnormalStateAfterBroken");
static_assert(offsetof(LWeapon_IsRemoveAbnormalStateAfterBroken, ReturnValue) == 0x000000, "Member 'LWeapon_IsRemoveAbnormalStateAfterBroken::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsWeaponOn
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsWeaponOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsWeaponOn) == 0x000001, "Wrong alignment on LWeapon_IsWeaponOn");
static_assert(sizeof(LWeapon_IsWeaponOn) == 0x000001, "Wrong size on LWeapon_IsWeaponOn");
static_assert(offsetof(LWeapon_IsWeaponOn, ReturnValue) == 0x000000, "Member 'LWeapon_IsWeaponOn::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.IsWeaponOnOwnerHidden
// 0x0001 (0x0001 - 0x0000)
struct LWeapon_IsWeaponOnOwnerHidden final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_IsWeaponOnOwnerHidden) == 0x000001, "Wrong alignment on LWeapon_IsWeaponOnOwnerHidden");
static_assert(sizeof(LWeapon_IsWeaponOnOwnerHidden) == 0x000001, "Wrong size on LWeapon_IsWeaponOnOwnerHidden");
static_assert(offsetof(LWeapon_IsWeaponOnOwnerHidden, ReturnValue) == 0x000000, "Member 'LWeapon_IsWeaponOnOwnerHidden::ReturnValue' has a wrong offset!");

// Function ProjectP.LWeapon.ToughRecoveryDelayTime
// 0x0004 (0x0004 - 0x0000)
struct LWeapon_ToughRecoveryDelayTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWeapon_ToughRecoveryDelayTime) == 0x000004, "Wrong alignment on LWeapon_ToughRecoveryDelayTime");
static_assert(sizeof(LWeapon_ToughRecoveryDelayTime) == 0x000004, "Wrong size on LWeapon_ToughRecoveryDelayTime");
static_assert(offsetof(LWeapon_ToughRecoveryDelayTime, ReturnValue) == 0x000000, "Member 'LWeapon_ToughRecoveryDelayTime::ReturnValue' has a wrong offset!");

// Function ProjectP.LWidget.ListenForInputAxis
// 0x001C (0x001C - 0x0000)
struct LWidget_ListenForInputAxis final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsume;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float AxisValue)>              Callback;                                          // 0x000C(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_ListenForInputAxis) == 0x000004, "Wrong alignment on LWidget_ListenForInputAxis");
static_assert(sizeof(LWidget_ListenForInputAxis) == 0x00001C, "Wrong size on LWidget_ListenForInputAxis");
static_assert(offsetof(LWidget_ListenForInputAxis, AxisName) == 0x000000, "Member 'LWidget_ListenForInputAxis::AxisName' has a wrong offset!");
static_assert(offsetof(LWidget_ListenForInputAxis, bConsume) == 0x000008, "Member 'LWidget_ListenForInputAxis::bConsume' has a wrong offset!");
static_assert(offsetof(LWidget_ListenForInputAxis, Callback) == 0x00000C, "Member 'LWidget_ListenForInputAxis::Callback' has a wrong offset!");

// Function ProjectP.LWidget.SetBrush_FromAsyncTexture
// 0x0030 (0x0030 - 0x0000)
struct LWidget_SetBrush_FromAsyncTexture final
{
public:
	class UImage*                                 InImage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 InSoftObject;                                      // 0x0008(0x0028)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_SetBrush_FromAsyncTexture) == 0x000008, "Wrong alignment on LWidget_SetBrush_FromAsyncTexture");
static_assert(sizeof(LWidget_SetBrush_FromAsyncTexture) == 0x000030, "Wrong size on LWidget_SetBrush_FromAsyncTexture");
static_assert(offsetof(LWidget_SetBrush_FromAsyncTexture, InImage) == 0x000000, "Member 'LWidget_SetBrush_FromAsyncTexture::InImage' has a wrong offset!");
static_assert(offsetof(LWidget_SetBrush_FromAsyncTexture, InSoftObject) == 0x000008, "Member 'LWidget_SetBrush_FromAsyncTexture::InSoftObject' has a wrong offset!");

// Function ProjectP.LWidget.StopListeningForInputAxis
// 0x0008 (0x0008 - 0x0000)
struct LWidget_StopListeningForInputAxis final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_StopListeningForInputAxis) == 0x000004, "Wrong alignment on LWidget_StopListeningForInputAxis");
static_assert(sizeof(LWidget_StopListeningForInputAxis) == 0x000008, "Wrong size on LWidget_StopListeningForInputAxis");
static_assert(offsetof(LWidget_StopListeningForInputAxis, AxisName) == 0x000000, "Member 'LWidget_StopListeningForInputAxis::AxisName' has a wrong offset!");

// Function ProjectP.LWidget.Tween_CanvasMove
// 0x0028 (0x0028 - 0x0000)
struct LWidget_Tween_CanvasMove final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Start;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              End;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0018(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_CanvasMove) == 0x000008, "Wrong alignment on LWidget_Tween_CanvasMove");
static_assert(sizeof(LWidget_Tween_CanvasMove) == 0x000028, "Wrong size on LWidget_Tween_CanvasMove");
static_assert(offsetof(LWidget_Tween_CanvasMove, Widget) == 0x000000, "Member 'LWidget_Tween_CanvasMove::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasMove, Start) == 0x000008, "Member 'LWidget_Tween_CanvasMove::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasMove, End) == 0x000010, "Member 'LWidget_Tween_CanvasMove::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasMove, Ease) == 0x000018, "Member 'LWidget_Tween_CanvasMove::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasMove, Time) == 0x000024, "Member 'LWidget_Tween_CanvasMove::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_CanvasSize
// 0x0028 (0x0028 - 0x0000)
struct LWidget_Tween_CanvasSize final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Start;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              End;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0018(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_CanvasSize) == 0x000008, "Wrong alignment on LWidget_Tween_CanvasSize");
static_assert(sizeof(LWidget_Tween_CanvasSize) == 0x000028, "Wrong size on LWidget_Tween_CanvasSize");
static_assert(offsetof(LWidget_Tween_CanvasSize, Widget) == 0x000000, "Member 'LWidget_Tween_CanvasSize::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasSize, Start) == 0x000008, "Member 'LWidget_Tween_CanvasSize::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasSize, End) == 0x000010, "Member 'LWidget_Tween_CanvasSize::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasSize, Ease) == 0x000018, "Member 'LWidget_Tween_CanvasSize::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_CanvasSize, Time) == 0x000024, "Member 'LWidget_Tween_CanvasSize::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_ColorAndOpacity
// 0x0038 (0x0038 - 0x0000)
struct LWidget_Tween_ColorAndOpacity final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Start;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           End;                                               // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0028(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_ColorAndOpacity) == 0x000008, "Wrong alignment on LWidget_Tween_ColorAndOpacity");
static_assert(sizeof(LWidget_Tween_ColorAndOpacity) == 0x000038, "Wrong size on LWidget_Tween_ColorAndOpacity");
static_assert(offsetof(LWidget_Tween_ColorAndOpacity, Widget) == 0x000000, "Member 'LWidget_Tween_ColorAndOpacity::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ColorAndOpacity, Start) == 0x000008, "Member 'LWidget_Tween_ColorAndOpacity::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ColorAndOpacity, End) == 0x000018, "Member 'LWidget_Tween_ColorAndOpacity::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ColorAndOpacity, Ease) == 0x000028, "Member 'LWidget_Tween_ColorAndOpacity::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ColorAndOpacity, Time) == 0x000034, "Member 'LWidget_Tween_ColorAndOpacity::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_ContentFloatValue
// 0x0020 (0x0020 - 0x0000)
struct LWidget_Tween_ContentFloatValue final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0010(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_ContentFloatValue) == 0x000008, "Wrong alignment on LWidget_Tween_ContentFloatValue");
static_assert(sizeof(LWidget_Tween_ContentFloatValue) == 0x000020, "Wrong size on LWidget_Tween_ContentFloatValue");
static_assert(offsetof(LWidget_Tween_ContentFloatValue, Widget) == 0x000000, "Member 'LWidget_Tween_ContentFloatValue::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentFloatValue, Start) == 0x000008, "Member 'LWidget_Tween_ContentFloatValue::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentFloatValue, End) == 0x00000C, "Member 'LWidget_Tween_ContentFloatValue::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentFloatValue, Ease) == 0x000010, "Member 'LWidget_Tween_ContentFloatValue::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentFloatValue, Time) == 0x00001C, "Member 'LWidget_Tween_ContentFloatValue::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_ContentsColorAndOpacity
// 0x0038 (0x0038 - 0x0000)
struct LWidget_Tween_ContentsColorAndOpacity final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Start;                                             // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           End;                                               // 0x0018(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0028(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_ContentsColorAndOpacity) == 0x000008, "Wrong alignment on LWidget_Tween_ContentsColorAndOpacity");
static_assert(sizeof(LWidget_Tween_ContentsColorAndOpacity) == 0x000038, "Wrong size on LWidget_Tween_ContentsColorAndOpacity");
static_assert(offsetof(LWidget_Tween_ContentsColorAndOpacity, Widget) == 0x000000, "Member 'LWidget_Tween_ContentsColorAndOpacity::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentsColorAndOpacity, Start) == 0x000008, "Member 'LWidget_Tween_ContentsColorAndOpacity::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentsColorAndOpacity, End) == 0x000018, "Member 'LWidget_Tween_ContentsColorAndOpacity::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentsColorAndOpacity, Ease) == 0x000028, "Member 'LWidget_Tween_ContentsColorAndOpacity::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_ContentsColorAndOpacity, Time) == 0x000034, "Member 'LWidget_Tween_ContentsColorAndOpacity::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_MaterialColor
// 0x0040 (0x0040 - 0x0000)
struct LWidget_Tween_MaterialColor final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Start;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           End;                                               // 0x0020(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0030(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_MaterialColor) == 0x000008, "Wrong alignment on LWidget_Tween_MaterialColor");
static_assert(sizeof(LWidget_Tween_MaterialColor) == 0x000040, "Wrong size on LWidget_Tween_MaterialColor");
static_assert(offsetof(LWidget_Tween_MaterialColor, Widget) == 0x000000, "Member 'LWidget_Tween_MaterialColor::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialColor, ParameterName) == 0x000008, "Member 'LWidget_Tween_MaterialColor::ParameterName' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialColor, Start) == 0x000010, "Member 'LWidget_Tween_MaterialColor::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialColor, End) == 0x000020, "Member 'LWidget_Tween_MaterialColor::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialColor, Ease) == 0x000030, "Member 'LWidget_Tween_MaterialColor::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialColor, Time) == 0x00003C, "Member 'LWidget_Tween_MaterialColor::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_MaterialScalar
// 0x0028 (0x0028 - 0x0000)
struct LWidget_Tween_MaterialScalar final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0018(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_MaterialScalar) == 0x000008, "Wrong alignment on LWidget_Tween_MaterialScalar");
static_assert(sizeof(LWidget_Tween_MaterialScalar) == 0x000028, "Wrong size on LWidget_Tween_MaterialScalar");
static_assert(offsetof(LWidget_Tween_MaterialScalar, Widget) == 0x000000, "Member 'LWidget_Tween_MaterialScalar::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialScalar, ParameterName) == 0x000008, "Member 'LWidget_Tween_MaterialScalar::ParameterName' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialScalar, Start) == 0x000010, "Member 'LWidget_Tween_MaterialScalar::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialScalar, End) == 0x000014, "Member 'LWidget_Tween_MaterialScalar::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialScalar, Ease) == 0x000018, "Member 'LWidget_Tween_MaterialScalar::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_MaterialScalar, Time) == 0x000024, "Member 'LWidget_Tween_MaterialScalar::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_Opacity
// 0x0020 (0x0020 - 0x0000)
struct LWidget_Tween_Opacity final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0010(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_Opacity) == 0x000008, "Wrong alignment on LWidget_Tween_Opacity");
static_assert(sizeof(LWidget_Tween_Opacity) == 0x000020, "Wrong size on LWidget_Tween_Opacity");
static_assert(offsetof(LWidget_Tween_Opacity, Widget) == 0x000000, "Member 'LWidget_Tween_Opacity::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_Opacity, Start) == 0x000008, "Member 'LWidget_Tween_Opacity::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_Opacity, End) == 0x00000C, "Member 'LWidget_Tween_Opacity::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_Opacity, Ease) == 0x000010, "Member 'LWidget_Tween_Opacity::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_Opacity, Time) == 0x00001C, "Member 'LWidget_Tween_Opacity::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_RenderAngle
// 0x0020 (0x0020 - 0x0000)
struct LWidget_Tween_RenderAngle final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0010(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_RenderAngle) == 0x000008, "Wrong alignment on LWidget_Tween_RenderAngle");
static_assert(sizeof(LWidget_Tween_RenderAngle) == 0x000020, "Wrong size on LWidget_Tween_RenderAngle");
static_assert(offsetof(LWidget_Tween_RenderAngle, Widget) == 0x000000, "Member 'LWidget_Tween_RenderAngle::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderAngle, Start) == 0x000008, "Member 'LWidget_Tween_RenderAngle::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderAngle, End) == 0x00000C, "Member 'LWidget_Tween_RenderAngle::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderAngle, Ease) == 0x000010, "Member 'LWidget_Tween_RenderAngle::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderAngle, Time) == 0x00001C, "Member 'LWidget_Tween_RenderAngle::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_RenderOpacity
// 0x0020 (0x0020 - 0x0000)
struct LWidget_Tween_RenderOpacity final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Start;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0010(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_RenderOpacity) == 0x000008, "Wrong alignment on LWidget_Tween_RenderOpacity");
static_assert(sizeof(LWidget_Tween_RenderOpacity) == 0x000020, "Wrong size on LWidget_Tween_RenderOpacity");
static_assert(offsetof(LWidget_Tween_RenderOpacity, Widget) == 0x000000, "Member 'LWidget_Tween_RenderOpacity::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderOpacity, Start) == 0x000008, "Member 'LWidget_Tween_RenderOpacity::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderOpacity, End) == 0x00000C, "Member 'LWidget_Tween_RenderOpacity::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderOpacity, Ease) == 0x000010, "Member 'LWidget_Tween_RenderOpacity::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderOpacity, Time) == 0x00001C, "Member 'LWidget_Tween_RenderOpacity::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_RenderScale
// 0x0028 (0x0028 - 0x0000)
struct LWidget_Tween_RenderScale final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Start;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              End;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0018(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_RenderScale) == 0x000008, "Wrong alignment on LWidget_Tween_RenderScale");
static_assert(sizeof(LWidget_Tween_RenderScale) == 0x000028, "Wrong size on LWidget_Tween_RenderScale");
static_assert(offsetof(LWidget_Tween_RenderScale, Widget) == 0x000000, "Member 'LWidget_Tween_RenderScale::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderScale, Start) == 0x000008, "Member 'LWidget_Tween_RenderScale::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderScale, End) == 0x000010, "Member 'LWidget_Tween_RenderScale::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderScale, Ease) == 0x000018, "Member 'LWidget_Tween_RenderScale::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderScale, Time) == 0x000024, "Member 'LWidget_Tween_RenderScale::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_RenderTransform
// 0x0050 (0x0050 - 0x0000)
struct LWidget_Tween_RenderTransform final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWidgetTransform                       Start;                                             // 0x0008(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FWidgetTransform                       End;                                               // 0x0024(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0040(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_RenderTransform) == 0x000008, "Wrong alignment on LWidget_Tween_RenderTransform");
static_assert(sizeof(LWidget_Tween_RenderTransform) == 0x000050, "Wrong size on LWidget_Tween_RenderTransform");
static_assert(offsetof(LWidget_Tween_RenderTransform, Widget) == 0x000000, "Member 'LWidget_Tween_RenderTransform::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTransform, Start) == 0x000008, "Member 'LWidget_Tween_RenderTransform::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTransform, End) == 0x000024, "Member 'LWidget_Tween_RenderTransform::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTransform, Ease) == 0x000040, "Member 'LWidget_Tween_RenderTransform::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTransform, Time) == 0x00004C, "Member 'LWidget_Tween_RenderTransform::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_RenderTranslation
// 0x0028 (0x0028 - 0x0000)
struct LWidget_Tween_RenderTranslation final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Start;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              End;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTweenEase                             Ease;                                              // 0x0018(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_RenderTranslation) == 0x000008, "Wrong alignment on LWidget_Tween_RenderTranslation");
static_assert(sizeof(LWidget_Tween_RenderTranslation) == 0x000028, "Wrong size on LWidget_Tween_RenderTranslation");
static_assert(offsetof(LWidget_Tween_RenderTranslation, Widget) == 0x000000, "Member 'LWidget_Tween_RenderTranslation::Widget' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTranslation, Start) == 0x000008, "Member 'LWidget_Tween_RenderTranslation::Start' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTranslation, End) == 0x000010, "Member 'LWidget_Tween_RenderTranslation::End' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTranslation, Ease) == 0x000018, "Member 'LWidget_Tween_RenderTranslation::Ease' has a wrong offset!");
static_assert(offsetof(LWidget_Tween_RenderTranslation, Time) == 0x000024, "Member 'LWidget_Tween_RenderTranslation::Time' has a wrong offset!");

// Function ProjectP.LWidget.Tween_Reset
// 0x0008 (0x0008 - 0x0000)
struct LWidget_Tween_Reset final
{
public:
	class FName                                   Category_Name;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_Reset) == 0x000004, "Wrong alignment on LWidget_Tween_Reset");
static_assert(sizeof(LWidget_Tween_Reset) == 0x000008, "Wrong size on LWidget_Tween_Reset");
static_assert(offsetof(LWidget_Tween_Reset, Category_Name) == 0x000000, "Member 'LWidget_Tween_Reset::Category_Name' has a wrong offset!");

// Function ProjectP.LWidget.Tween_Start
// 0x0008 (0x0008 - 0x0000)
struct LWidget_Tween_Start final
{
public:
	class FName                                   Category_Name;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWidget_Tween_Start) == 0x000004, "Wrong alignment on LWidget_Tween_Start");
static_assert(sizeof(LWidget_Tween_Start) == 0x000008, "Wrong size on LWidget_Tween_Start");
static_assert(offsetof(LWidget_Tween_Start, Category_Name) == 0x000000, "Member 'LWidget_Tween_Start::Category_Name' has a wrong offset!");

// Function ProjectP.LHeadTagWidget.RefreshHeadTagVisibleTimer
// 0x0001 (0x0001 - 0x0000)
struct LHeadTagWidget_RefreshHeadTagVisibleTimer final
{
public:
	bool                                          InVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LHeadTagWidget_RefreshHeadTagVisibleTimer) == 0x000001, "Wrong alignment on LHeadTagWidget_RefreshHeadTagVisibleTimer");
static_assert(sizeof(LHeadTagWidget_RefreshHeadTagVisibleTimer) == 0x000001, "Wrong size on LHeadTagWidget_RefreshHeadTagVisibleTimer");
static_assert(offsetof(LHeadTagWidget_RefreshHeadTagVisibleTimer, InVisible) == 0x000000, "Member 'LHeadTagWidget_RefreshHeadTagVisibleTimer::InVisible' has a wrong offset!");

// Function ProjectP.LWorldEventComponent.OnClosedLevelUpWindow
// 0x0008 (0x0008 - 0x0000)
struct LWorldEventComponent_OnClosedLevelUpWindow final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldEventComponent_OnClosedLevelUpWindow) == 0x000004, "Wrong alignment on LWorldEventComponent_OnClosedLevelUpWindow");
static_assert(sizeof(LWorldEventComponent_OnClosedLevelUpWindow) == 0x000008, "Wrong size on LWorldEventComponent_OnClosedLevelUpWindow");
static_assert(offsetof(LWorldEventComponent_OnClosedLevelUpWindow, WidgetTableName) == 0x000000, "Member 'LWorldEventComponent_OnClosedLevelUpWindow::WidgetTableName' has a wrong offset!");

// Function ProjectP.LWorldEventSystem.ExecuteContentCommand
// 0x000C (0x000C - 0x0000)
struct LWorldEventSystem_ExecuteContentCommand final
{
public:
	class FName                                   CommandName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldEventSystem_ExecuteContentCommand) == 0x000004, "Wrong alignment on LWorldEventSystem_ExecuteContentCommand");
static_assert(sizeof(LWorldEventSystem_ExecuteContentCommand) == 0x00000C, "Wrong size on LWorldEventSystem_ExecuteContentCommand");
static_assert(offsetof(LWorldEventSystem_ExecuteContentCommand, CommandName) == 0x000000, "Member 'LWorldEventSystem_ExecuteContentCommand::CommandName' has a wrong offset!");
static_assert(offsetof(LWorldEventSystem_ExecuteContentCommand, ReturnValue) == 0x000008, "Member 'LWorldEventSystem_ExecuteContentCommand::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldEventSystem.IsValidEventConditionBP
// 0x000C (0x000C - 0x0000)
struct LWorldEventSystem_IsValidEventConditionBP final
{
public:
	class FName                                   CommandName;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldEventSystem_IsValidEventConditionBP) == 0x000004, "Wrong alignment on LWorldEventSystem_IsValidEventConditionBP");
static_assert(sizeof(LWorldEventSystem_IsValidEventConditionBP) == 0x00000C, "Wrong size on LWorldEventSystem_IsValidEventConditionBP");
static_assert(offsetof(LWorldEventSystem_IsValidEventConditionBP, CommandName) == 0x000000, "Member 'LWorldEventSystem_IsValidEventConditionBP::CommandName' has a wrong offset!");
static_assert(offsetof(LWorldEventSystem_IsValidEventConditionBP, ReturnValue) == 0x000008, "Member 'LWorldEventSystem_IsValidEventConditionBP::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldEventSystem.OnClosedWindow
// 0x0008 (0x0008 - 0x0000)
struct LWorldEventSystem_OnClosedWindow final
{
public:
	class FName                                   WidgetTableName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldEventSystem_OnClosedWindow) == 0x000004, "Wrong alignment on LWorldEventSystem_OnClosedWindow");
static_assert(sizeof(LWorldEventSystem_OnClosedWindow) == 0x000008, "Wrong size on LWorldEventSystem_OnClosedWindow");
static_assert(offsetof(LWorldEventSystem_OnClosedWindow, WidgetTableName) == 0x000000, "Member 'LWorldEventSystem_OnClosedWindow::WidgetTableName' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.AsyncLoadAfterOpenWorld
// 0x0001 (0x0001 - 0x0000)
struct LWorldLoadSystem_AsyncLoadAfterOpenWorld final
{
public:
	bool                                          bCreateForPIE;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_AsyncLoadAfterOpenWorld) == 0x000001, "Wrong alignment on LWorldLoadSystem_AsyncLoadAfterOpenWorld");
static_assert(sizeof(LWorldLoadSystem_AsyncLoadAfterOpenWorld) == 0x000001, "Wrong size on LWorldLoadSystem_AsyncLoadAfterOpenWorld");
static_assert(offsetof(LWorldLoadSystem_AsyncLoadAfterOpenWorld, bCreateForPIE) == 0x000000, "Member 'LWorldLoadSystem_AsyncLoadAfterOpenWorld::bCreateForPIE' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.AsyncWaitLevel
// 0x0008 (0x0008 - 0x0000)
struct LWorldLoadSystem_AsyncWaitLevel final
{
public:
	class FName                                   TeleportCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_AsyncWaitLevel) == 0x000004, "Wrong alignment on LWorldLoadSystem_AsyncWaitLevel");
static_assert(sizeof(LWorldLoadSystem_AsyncWaitLevel) == 0x000008, "Wrong size on LWorldLoadSystem_AsyncWaitLevel");
static_assert(offsetof(LWorldLoadSystem_AsyncWaitLevel, TeleportCodeName) == 0x000000, "Member 'LWorldLoadSystem_AsyncWaitLevel::TeleportCodeName' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.GetAsyncLoadPercentage
// 0x0004 (0x0004 - 0x0000)
struct LWorldLoadSystem_GetAsyncLoadPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_GetAsyncLoadPercentage) == 0x000004, "Wrong alignment on LWorldLoadSystem_GetAsyncLoadPercentage");
static_assert(sizeof(LWorldLoadSystem_GetAsyncLoadPercentage) == 0x000004, "Wrong size on LWorldLoadSystem_GetAsyncLoadPercentage");
static_assert(offsetof(LWorldLoadSystem_GetAsyncLoadPercentage, ReturnValue) == 0x000000, "Member 'LWorldLoadSystem_GetAsyncLoadPercentage::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.GetWorldLoadScreenInfo
// 0x0008 (0x0008 - 0x0000)
struct LWorldLoadSystem_GetWorldLoadScreenInfo final
{
public:
	class ULWorldLoadScreenInfo*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_GetWorldLoadScreenInfo) == 0x000008, "Wrong alignment on LWorldLoadSystem_GetWorldLoadScreenInfo");
static_assert(sizeof(LWorldLoadSystem_GetWorldLoadScreenInfo) == 0x000008, "Wrong size on LWorldLoadSystem_GetWorldLoadScreenInfo");
static_assert(offsetof(LWorldLoadSystem_GetWorldLoadScreenInfo, ReturnValue) == 0x000000, "Member 'LWorldLoadSystem_GetWorldLoadScreenInfo::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.MakeLoadAlwaysLoadLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming) == 0x000008, "Wrong alignment on LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming");
static_assert(sizeof(LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming) == 0x000008, "Wrong size on LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming");
static_assert(offsetof(LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming, World) == 0x000000, "Member 'LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming::World' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.OnGameDataCharacterSync
// 0x0010 (0x0010 - 0x0000)
struct LWorldLoadSystem_OnGameDataCharacterSync final
{
public:
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoad;                                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldLoadSystem_OnGameDataCharacterSync) == 0x000008, "Wrong alignment on LWorldLoadSystem_OnGameDataCharacterSync");
static_assert(sizeof(LWorldLoadSystem_OnGameDataCharacterSync) == 0x000010, "Wrong size on LWorldLoadSystem_OnGameDataCharacterSync");
static_assert(offsetof(LWorldLoadSystem_OnGameDataCharacterSync, CharacterSaveGame) == 0x000000, "Member 'LWorldLoadSystem_OnGameDataCharacterSync::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(LWorldLoadSystem_OnGameDataCharacterSync, bLoad) == 0x000008, "Member 'LWorldLoadSystem_OnGameDataCharacterSync::bLoad' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.CanSpawnActors
// 0x0001 (0x0001 - 0x0000)
struct LWorldLoadSystem_CanSpawnActors final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_CanSpawnActors) == 0x000001, "Wrong alignment on LWorldLoadSystem_CanSpawnActors");
static_assert(sizeof(LWorldLoadSystem_CanSpawnActors) == 0x000001, "Wrong size on LWorldLoadSystem_CanSpawnActors");
static_assert(offsetof(LWorldLoadSystem_CanSpawnActors, ReturnValue) == 0x000000, "Member 'LWorldLoadSystem_CanSpawnActors::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.GetLoadingStats
// 0x0010 (0x0010 - 0x0000)
struct LWorldLoadSystem_GetLoadingStats final
{
public:
	TArray<class FString>                         Stats;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_GetLoadingStats) == 0x000008, "Wrong alignment on LWorldLoadSystem_GetLoadingStats");
static_assert(sizeof(LWorldLoadSystem_GetLoadingStats) == 0x000010, "Wrong size on LWorldLoadSystem_GetLoadingStats");
static_assert(offsetof(LWorldLoadSystem_GetLoadingStats, Stats) == 0x000000, "Member 'LWorldLoadSystem_GetLoadingStats::Stats' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.IsAsyncWorldLoading
// 0x0001 (0x0001 - 0x0000)
struct LWorldLoadSystem_IsAsyncWorldLoading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_IsAsyncWorldLoading) == 0x000001, "Wrong alignment on LWorldLoadSystem_IsAsyncWorldLoading");
static_assert(sizeof(LWorldLoadSystem_IsAsyncWorldLoading) == 0x000001, "Wrong size on LWorldLoadSystem_IsAsyncWorldLoading");
static_assert(offsetof(LWorldLoadSystem_IsAsyncWorldLoading, ReturnValue) == 0x000000, "Member 'LWorldLoadSystem_IsAsyncWorldLoading::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.IsAsyncWorldLoadMode
// 0x0001 (0x0001 - 0x0000)
struct LWorldLoadSystem_IsAsyncWorldLoadMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadSystem_IsAsyncWorldLoadMode) == 0x000001, "Wrong alignment on LWorldLoadSystem_IsAsyncWorldLoadMode");
static_assert(sizeof(LWorldLoadSystem_IsAsyncWorldLoadMode) == 0x000001, "Wrong size on LWorldLoadSystem_IsAsyncWorldLoadMode");
static_assert(offsetof(LWorldLoadSystem_IsAsyncWorldLoadMode, ReturnValue) == 0x000000, "Member 'LWorldLoadSystem_IsAsyncWorldLoadMode::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.IsAsyncWorldLoadModeInCurrentWorld
// 0x0010 (0x0010 - 0x0000)
struct LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld) == 0x000008, "Wrong alignment on LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld");
static_assert(sizeof(LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld) == 0x000010, "Wrong size on LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld");
static_assert(offsetof(LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld, World) == 0x000000, "Member 'LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld::World' has a wrong offset!");
static_assert(offsetof(LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld, ReturnValue) == 0x000008, "Member 'LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadSystem.IsStartAsyncLoadMap
// 0x000C (0x000C - 0x0000)
struct LWorldLoadSystem_IsStartAsyncLoadMap final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldLoadSystem_IsStartAsyncLoadMap) == 0x000004, "Wrong alignment on LWorldLoadSystem_IsStartAsyncLoadMap");
static_assert(sizeof(LWorldLoadSystem_IsStartAsyncLoadMap) == 0x00000C, "Wrong size on LWorldLoadSystem_IsStartAsyncLoadMap");
static_assert(offsetof(LWorldLoadSystem_IsStartAsyncLoadMap, LevelName) == 0x000000, "Member 'LWorldLoadSystem_IsStartAsyncLoadMap::LevelName' has a wrong offset!");
static_assert(offsetof(LWorldLoadSystem_IsStartAsyncLoadMap, ReturnValue) == 0x000008, "Member 'LWorldLoadSystem_IsStartAsyncLoadMap::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.AddKeepLoadingObjectsInTask
// 0x0010 (0x0010 - 0x0000)
struct LWorldLoadManager_AddKeepLoadingObjectsInTask final
{
public:
	TArray<class UObject*>                        Objects;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_AddKeepLoadingObjectsInTask) == 0x000008, "Wrong alignment on LWorldLoadManager_AddKeepLoadingObjectsInTask");
static_assert(sizeof(LWorldLoadManager_AddKeepLoadingObjectsInTask) == 0x000010, "Wrong size on LWorldLoadManager_AddKeepLoadingObjectsInTask");
static_assert(offsetof(LWorldLoadManager_AddKeepLoadingObjectsInTask, Objects) == 0x000000, "Member 'LWorldLoadManager_AddKeepLoadingObjectsInTask::Objects' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.AddKeepWorldObjectsInTask
// 0x0010 (0x0010 - 0x0000)
struct LWorldLoadManager_AddKeepWorldObjectsInTask final
{
public:
	TArray<class UObject*>                        Objects;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_AddKeepWorldObjectsInTask) == 0x000008, "Wrong alignment on LWorldLoadManager_AddKeepWorldObjectsInTask");
static_assert(sizeof(LWorldLoadManager_AddKeepWorldObjectsInTask) == 0x000010, "Wrong size on LWorldLoadManager_AddKeepWorldObjectsInTask");
static_assert(offsetof(LWorldLoadManager_AddKeepWorldObjectsInTask, Objects) == 0x000000, "Member 'LWorldLoadManager_AddKeepWorldObjectsInTask::Objects' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.AsyncWaitLevel
// 0x0008 (0x0008 - 0x0000)
struct LWorldLoadManager_AsyncWaitLevel final
{
public:
	class FName                                   TeleportCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_AsyncWaitLevel) == 0x000004, "Wrong alignment on LWorldLoadManager_AsyncWaitLevel");
static_assert(sizeof(LWorldLoadManager_AsyncWaitLevel) == 0x000008, "Wrong size on LWorldLoadManager_AsyncWaitLevel");
static_assert(offsetof(LWorldLoadManager_AsyncWaitLevel, TeleportCodeName) == 0x000000, "Member 'LWorldLoadManager_AsyncWaitLevel::TeleportCodeName' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.GetLoadPercentage
// 0x0004 (0x0004 - 0x0000)
struct LWorldLoadManager_GetLoadPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_GetLoadPercentage) == 0x000004, "Wrong alignment on LWorldLoadManager_GetLoadPercentage");
static_assert(sizeof(LWorldLoadManager_GetLoadPercentage) == 0x000004, "Wrong size on LWorldLoadManager_GetLoadPercentage");
static_assert(offsetof(LWorldLoadManager_GetLoadPercentage, ReturnValue) == 0x000000, "Member 'LWorldLoadManager_GetLoadPercentage::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.MakeLoadAlwaysLoadLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming) == 0x000008, "Wrong alignment on LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming");
static_assert(sizeof(LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming) == 0x000008, "Wrong size on LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming");
static_assert(offsetof(LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming, World) == 0x000000, "Member 'LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming::World' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.TickAsyncWorldLoading
// 0x0004 (0x0004 - 0x0000)
struct LWorldLoadManager_TickAsyncWorldLoading final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_TickAsyncWorldLoading) == 0x000004, "Wrong alignment on LWorldLoadManager_TickAsyncWorldLoading");
static_assert(sizeof(LWorldLoadManager_TickAsyncWorldLoading) == 0x000004, "Wrong size on LWorldLoadManager_TickAsyncWorldLoading");
static_assert(offsetof(LWorldLoadManager_TickAsyncWorldLoading, DeltaTime) == 0x000000, "Member 'LWorldLoadManager_TickAsyncWorldLoading::DeltaTime' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.GetLoadingStats
// 0x0010 (0x0010 - 0x0000)
struct LWorldLoadManager_GetLoadingStats final
{
public:
	TArray<class FString>                         Stats;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_GetLoadingStats) == 0x000008, "Wrong alignment on LWorldLoadManager_GetLoadingStats");
static_assert(sizeof(LWorldLoadManager_GetLoadingStats) == 0x000010, "Wrong size on LWorldLoadManager_GetLoadingStats");
static_assert(offsetof(LWorldLoadManager_GetLoadingStats, Stats) == 0x000000, "Member 'LWorldLoadManager_GetLoadingStats::Stats' has a wrong offset!");

// Function ProjectP.LWorldLoadManager.IsAsyncWorldLoading
// 0x0001 (0x0001 - 0x0000)
struct LWorldLoadManager_IsAsyncWorldLoading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldLoadManager_IsAsyncWorldLoading) == 0x000001, "Wrong alignment on LWorldLoadManager_IsAsyncWorldLoading");
static_assert(sizeof(LWorldLoadManager_IsAsyncWorldLoading) == 0x000001, "Wrong size on LWorldLoadManager_IsAsyncWorldLoading");
static_assert(offsetof(LWorldLoadManager_IsAsyncWorldLoading, ReturnValue) == 0x000000, "Member 'LWorldLoadManager_IsAsyncWorldLoading::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystemData.ChangeLightScenario
// 0x0010 (0x0010 - 0x0000)
struct LWorldSystemData_ChangeLightScenario final
{
public:
	class FName                                   UnLoadLevel;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadLevel;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystemData_ChangeLightScenario) == 0x000004, "Wrong alignment on LWorldSystemData_ChangeLightScenario");
static_assert(sizeof(LWorldSystemData_ChangeLightScenario) == 0x000010, "Wrong size on LWorldSystemData_ChangeLightScenario");
static_assert(offsetof(LWorldSystemData_ChangeLightScenario, UnLoadLevel) == 0x000000, "Member 'LWorldSystemData_ChangeLightScenario::UnLoadLevel' has a wrong offset!");
static_assert(offsetof(LWorldSystemData_ChangeLightScenario, LoadLevel) == 0x000008, "Member 'LWorldSystemData_ChangeLightScenario::LoadLevel' has a wrong offset!");

// Function ProjectP.LWorldSystemData.ProcessMoveToTeleportSpotSameLevel
// 0x000C (0x000C - 0x0000)
struct LWorldSystemData_ProcessMoveToTeleportSpotSameLevel final
{
public:
	class FName                                   TeleportCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGameLoadingScreen;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldSystemData_ProcessMoveToTeleportSpotSameLevel) == 0x000004, "Wrong alignment on LWorldSystemData_ProcessMoveToTeleportSpotSameLevel");
static_assert(sizeof(LWorldSystemData_ProcessMoveToTeleportSpotSameLevel) == 0x00000C, "Wrong size on LWorldSystemData_ProcessMoveToTeleportSpotSameLevel");
static_assert(offsetof(LWorldSystemData_ProcessMoveToTeleportSpotSameLevel, TeleportCodeName) == 0x000000, "Member 'LWorldSystemData_ProcessMoveToTeleportSpotSameLevel::TeleportCodeName' has a wrong offset!");
static_assert(offsetof(LWorldSystemData_ProcessMoveToTeleportSpotSameLevel, bInGameLoadingScreen) == 0x000008, "Member 'LWorldSystemData_ProcessMoveToTeleportSpotSameLevel::bInGameLoadingScreen' has a wrong offset!");

// Function ProjectP.LWorldSystem.ApplyWeather
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_ApplyWeather final
{
public:
	class FName                                   InWeatherCodeName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomChangeTime;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_ApplyWeather) == 0x000004, "Wrong alignment on LWorldSystem_ApplyWeather");
static_assert(sizeof(LWorldSystem_ApplyWeather) == 0x00000C, "Wrong size on LWorldSystem_ApplyWeather");
static_assert(offsetof(LWorldSystem_ApplyWeather, InWeatherCodeName) == 0x000000, "Member 'LWorldSystem_ApplyWeather::InWeatherCodeName' has a wrong offset!");
static_assert(offsetof(LWorldSystem_ApplyWeather, CustomChangeTime) == 0x000008, "Member 'LWorldSystem_ApplyWeather::CustomChangeTime' has a wrong offset!");

// Function ProjectP.LWorldSystem.ChangeWeather
// 0x0010 (0x0010 - 0x0000)
struct LWorldSystem_ChangeWeather final
{
public:
	class FName                                   InWeatherCodeName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomChangeTime;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_ChangeWeather) == 0x000004, "Wrong alignment on LWorldSystem_ChangeWeather");
static_assert(sizeof(LWorldSystem_ChangeWeather) == 0x000010, "Wrong size on LWorldSystem_ChangeWeather");
static_assert(offsetof(LWorldSystem_ChangeWeather, InWeatherCodeName) == 0x000000, "Member 'LWorldSystem_ChangeWeather::InWeatherCodeName' has a wrong offset!");
static_assert(offsetof(LWorldSystem_ChangeWeather, CustomChangeTime) == 0x000008, "Member 'LWorldSystem_ChangeWeather::CustomChangeTime' has a wrong offset!");
static_assert(offsetof(LWorldSystem_ChangeWeather, DelayTime) == 0x00000C, "Member 'LWorldSystem_ChangeWeather::DelayTime' has a wrong offset!");

// Function ProjectP.LWorldSystem.GetEndingCreditVelocityMultiply
// 0x0004 (0x0004 - 0x0000)
struct LWorldSystem_GetEndingCreditVelocityMultiply final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_GetEndingCreditVelocityMultiply) == 0x000004, "Wrong alignment on LWorldSystem_GetEndingCreditVelocityMultiply");
static_assert(sizeof(LWorldSystem_GetEndingCreditVelocityMultiply) == 0x000004, "Wrong size on LWorldSystem_GetEndingCreditVelocityMultiply");
static_assert(offsetof(LWorldSystem_GetEndingCreditVelocityMultiply, ReturnValue) == 0x000000, "Member 'LWorldSystem_GetEndingCreditVelocityMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.GetGlobalEnvActor
// 0x0008 (0x0008 - 0x0000)
struct LWorldSystem_GetGlobalEnvActor final
{
public:
	class ALGlobalEnvActor*                       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_GetGlobalEnvActor) == 0x000008, "Wrong alignment on LWorldSystem_GetGlobalEnvActor");
static_assert(sizeof(LWorldSystem_GetGlobalEnvActor) == 0x000008, "Wrong size on LWorldSystem_GetGlobalEnvActor");
static_assert(offsetof(LWorldSystem_GetGlobalEnvActor, ReturnValue) == 0x000000, "Member 'LWorldSystem_GetGlobalEnvActor::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.GetIsShowControlGuide
// 0x0001 (0x0001 - 0x0000)
struct LWorldSystem_GetIsShowControlGuide final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_GetIsShowControlGuide) == 0x000001, "Wrong alignment on LWorldSystem_GetIsShowControlGuide");
static_assert(sizeof(LWorldSystem_GetIsShowControlGuide) == 0x000001, "Wrong size on LWorldSystem_GetIsShowControlGuide");
static_assert(offsetof(LWorldSystem_GetIsShowControlGuide, ReturnValue) == 0x000000, "Member 'LWorldSystem_GetIsShowControlGuide::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.GetWorldLoadingProgress
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_GetWorldLoadingProgress final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLevelLoadOnly;                               // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_GetWorldLoadingProgress) == 0x000004, "Wrong alignment on LWorldSystem_GetWorldLoadingProgress");
static_assert(sizeof(LWorldSystem_GetWorldLoadingProgress) == 0x00000C, "Wrong size on LWorldSystem_GetWorldLoadingProgress");
static_assert(offsetof(LWorldSystem_GetWorldLoadingProgress, DeltaTime) == 0x000000, "Member 'LWorldSystem_GetWorldLoadingProgress::DeltaTime' has a wrong offset!");
static_assert(offsetof(LWorldSystem_GetWorldLoadingProgress, bCheckLevelLoadOnly) == 0x000004, "Member 'LWorldSystem_GetWorldLoadingProgress::bCheckLevelLoadOnly' has a wrong offset!");
static_assert(offsetof(LWorldSystem_GetWorldLoadingProgress, ReturnValue) == 0x000008, "Member 'LWorldSystem_GetWorldLoadingProgress::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.IsShowControlGuide
// 0x0001 (0x0001 - 0x0000)
struct LWorldSystem_IsShowControlGuide final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_IsShowControlGuide) == 0x000001, "Wrong alignment on LWorldSystem_IsShowControlGuide");
static_assert(sizeof(LWorldSystem_IsShowControlGuide) == 0x000001, "Wrong size on LWorldSystem_IsShowControlGuide");
static_assert(offsetof(LWorldSystem_IsShowControlGuide, ReturnValue) == 0x000000, "Member 'LWorldSystem_IsShowControlGuide::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.IsUseEndingCreditVelocityMultiply
// 0x0001 (0x0001 - 0x0000)
struct LWorldSystem_IsUseEndingCreditVelocityMultiply final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_IsUseEndingCreditVelocityMultiply) == 0x000001, "Wrong alignment on LWorldSystem_IsUseEndingCreditVelocityMultiply");
static_assert(sizeof(LWorldSystem_IsUseEndingCreditVelocityMultiply) == 0x000001, "Wrong size on LWorldSystem_IsUseEndingCreditVelocityMultiply");
static_assert(offsetof(LWorldSystem_IsUseEndingCreditVelocityMultiply, ReturnValue) == 0x000000, "Member 'LWorldSystem_IsUseEndingCreditVelocityMultiply::ReturnValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.NewOpenWorld_Inner
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_NewOpenWorld_Inner final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainLoading;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldSystem_NewOpenWorld_Inner) == 0x000004, "Wrong alignment on LWorldSystem_NewOpenWorld_Inner");
static_assert(sizeof(LWorldSystem_NewOpenWorld_Inner) == 0x00000C, "Wrong size on LWorldSystem_NewOpenWorld_Inner");
static_assert(offsetof(LWorldSystem_NewOpenWorld_Inner, LevelName) == 0x000000, "Member 'LWorldSystem_NewOpenWorld_Inner::LevelName' has a wrong offset!");
static_assert(offsetof(LWorldSystem_NewOpenWorld_Inner, bMainLoading) == 0x000008, "Member 'LWorldSystem_NewOpenWorld_Inner::bMainLoading' has a wrong offset!");

// Function ProjectP.LWorldSystem.NewOpenWorld_Outer
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_NewOpenWorld_Outer final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoadingScreen;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayStart;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldSystem_NewOpenWorld_Outer) == 0x000004, "Wrong alignment on LWorldSystem_NewOpenWorld_Outer");
static_assert(sizeof(LWorldSystem_NewOpenWorld_Outer) == 0x00000C, "Wrong size on LWorldSystem_NewOpenWorld_Outer");
static_assert(offsetof(LWorldSystem_NewOpenWorld_Outer, LevelName) == 0x000000, "Member 'LWorldSystem_NewOpenWorld_Outer::LevelName' has a wrong offset!");
static_assert(offsetof(LWorldSystem_NewOpenWorld_Outer, bShowLoadingScreen) == 0x000008, "Member 'LWorldSystem_NewOpenWorld_Outer::bShowLoadingScreen' has a wrong offset!");
static_assert(offsetof(LWorldSystem_NewOpenWorld_Outer, bPlayStart) == 0x000009, "Member 'LWorldSystem_NewOpenWorld_Outer::bPlayStart' has a wrong offset!");

// Function ProjectP.LWorldSystem.OnGlobalVariableChange
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_OnGlobalVariableChange final
{
public:
	class FName                                   InGlobalVariable;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_OnGlobalVariableChange) == 0x000004, "Wrong alignment on LWorldSystem_OnGlobalVariableChange");
static_assert(sizeof(LWorldSystem_OnGlobalVariableChange) == 0x00000C, "Wrong size on LWorldSystem_OnGlobalVariableChange");
static_assert(offsetof(LWorldSystem_OnGlobalVariableChange, InGlobalVariable) == 0x000000, "Member 'LWorldSystem_OnGlobalVariableChange::InGlobalVariable' has a wrong offset!");
static_assert(offsetof(LWorldSystem_OnGlobalVariableChange, InValue) == 0x000008, "Member 'LWorldSystem_OnGlobalVariableChange::InValue' has a wrong offset!");

// Function ProjectP.LWorldSystem.OpenWorldFromMapType
// 0x0002 (0x0002 - 0x0000)
struct LWorldSystem_OpenWorldFromMapType final
{
public:
	ELWorldMapType                                TargetMapType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoadingScreen;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_OpenWorldFromMapType) == 0x000001, "Wrong alignment on LWorldSystem_OpenWorldFromMapType");
static_assert(sizeof(LWorldSystem_OpenWorldFromMapType) == 0x000002, "Wrong size on LWorldSystem_OpenWorldFromMapType");
static_assert(offsetof(LWorldSystem_OpenWorldFromMapType, TargetMapType) == 0x000000, "Member 'LWorldSystem_OpenWorldFromMapType::TargetMapType' has a wrong offset!");
static_assert(offsetof(LWorldSystem_OpenWorldFromMapType, bShowLoadingScreen) == 0x000001, "Member 'LWorldSystem_OpenWorldFromMapType::bShowLoadingScreen' has a wrong offset!");

// Function ProjectP.LWorldSystem.ProcessMoveToTeleportSpotSameLevel
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_ProcessMoveToTeleportSpotSameLevel final
{
public:
	class FName                                   TeleportCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGameLoadingScreen;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldSystem_ProcessMoveToTeleportSpotSameLevel) == 0x000004, "Wrong alignment on LWorldSystem_ProcessMoveToTeleportSpotSameLevel");
static_assert(sizeof(LWorldSystem_ProcessMoveToTeleportSpotSameLevel) == 0x00000C, "Wrong size on LWorldSystem_ProcessMoveToTeleportSpotSameLevel");
static_assert(offsetof(LWorldSystem_ProcessMoveToTeleportSpotSameLevel, TeleportCodeName) == 0x000000, "Member 'LWorldSystem_ProcessMoveToTeleportSpotSameLevel::TeleportCodeName' has a wrong offset!");
static_assert(offsetof(LWorldSystem_ProcessMoveToTeleportSpotSameLevel, bInGameLoadingScreen) == 0x000008, "Member 'LWorldSystem_ProcessMoveToTeleportSpotSameLevel::bInGameLoadingScreen' has a wrong offset!");

// Function ProjectP.LWorldSystem.SetEndingCreditVelocityMultiply
// 0x0004 (0x0004 - 0x0000)
struct LWorldSystem_SetEndingCreditVelocityMultiply final
{
public:
	float                                         InVelocityMultiply;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_SetEndingCreditVelocityMultiply) == 0x000004, "Wrong alignment on LWorldSystem_SetEndingCreditVelocityMultiply");
static_assert(sizeof(LWorldSystem_SetEndingCreditVelocityMultiply) == 0x000004, "Wrong size on LWorldSystem_SetEndingCreditVelocityMultiply");
static_assert(offsetof(LWorldSystem_SetEndingCreditVelocityMultiply, InVelocityMultiply) == 0x000000, "Member 'LWorldSystem_SetEndingCreditVelocityMultiply::InVelocityMultiply' has a wrong offset!");

// Function ProjectP.LWorldSystem.SetGlobalDither
// 0x0001 (0x0001 - 0x0000)
struct LWorldSystem_SetGlobalDither final
{
public:
	bool                                          InFlag;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_SetGlobalDither) == 0x000001, "Wrong alignment on LWorldSystem_SetGlobalDither");
static_assert(sizeof(LWorldSystem_SetGlobalDither) == 0x000001, "Wrong size on LWorldSystem_SetGlobalDither");
static_assert(offsetof(LWorldSystem_SetGlobalDither, InFlag) == 0x000000, "Member 'LWorldSystem_SetGlobalDither::InFlag' has a wrong offset!");

// Function ProjectP.LWorldSystem.SetGlobalEnvActor
// 0x0008 (0x0008 - 0x0000)
struct LWorldSystem_SetGlobalEnvActor final
{
public:
	class ALGlobalEnvActor*                       InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_SetGlobalEnvActor) == 0x000008, "Wrong alignment on LWorldSystem_SetGlobalEnvActor");
static_assert(sizeof(LWorldSystem_SetGlobalEnvActor) == 0x000008, "Wrong size on LWorldSystem_SetGlobalEnvActor");
static_assert(offsetof(LWorldSystem_SetGlobalEnvActor, InActor) == 0x000000, "Member 'LWorldSystem_SetGlobalEnvActor::InActor' has a wrong offset!");

// Function ProjectP.LWorldSystem.SetIsShowControlGuide
// 0x0001 (0x0001 - 0x0000)
struct LWorldSystem_SetIsShowControlGuide final
{
public:
	bool                                          InIsShowControlGuide;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_SetIsShowControlGuide) == 0x000001, "Wrong alignment on LWorldSystem_SetIsShowControlGuide");
static_assert(sizeof(LWorldSystem_SetIsShowControlGuide) == 0x000001, "Wrong size on LWorldSystem_SetIsShowControlGuide");
static_assert(offsetof(LWorldSystem_SetIsShowControlGuide, InIsShowControlGuide) == 0x000000, "Member 'LWorldSystem_SetIsShowControlGuide::InIsShowControlGuide' has a wrong offset!");

// Function ProjectP.LWorldSystem.TeleportToObject
// 0x000C (0x000C - 0x0000)
struct LWorldSystem_TeleportToObject final
{
public:
	class FName                                   TeleportCodeName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGameLoadingScreen;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReservedLevel;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWithLoadingLevel;                            // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LWorldSystem_TeleportToObject) == 0x000004, "Wrong alignment on LWorldSystem_TeleportToObject");
static_assert(sizeof(LWorldSystem_TeleportToObject) == 0x00000C, "Wrong size on LWorldSystem_TeleportToObject");
static_assert(offsetof(LWorldSystem_TeleportToObject, TeleportCodeName) == 0x000000, "Member 'LWorldSystem_TeleportToObject::TeleportCodeName' has a wrong offset!");
static_assert(offsetof(LWorldSystem_TeleportToObject, bInGameLoadingScreen) == 0x000008, "Member 'LWorldSystem_TeleportToObject::bInGameLoadingScreen' has a wrong offset!");
static_assert(offsetof(LWorldSystem_TeleportToObject, bReservedLevel) == 0x000009, "Member 'LWorldSystem_TeleportToObject::bReservedLevel' has a wrong offset!");
static_assert(offsetof(LWorldSystem_TeleportToObject, bStartWithLoadingLevel) == 0x00000A, "Member 'LWorldSystem_TeleportToObject::bStartWithLoadingLevel' has a wrong offset!");

// Function ProjectP.LWorldSystem.GetAppliedWeatherCodeName
// 0x0008 (0x0008 - 0x0000)
struct LWorldSystem_GetAppliedWeatherCodeName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LWorldSystem_GetAppliedWeatherCodeName) == 0x000004, "Wrong alignment on LWorldSystem_GetAppliedWeatherCodeName");
static_assert(sizeof(LWorldSystem_GetAppliedWeatherCodeName) == 0x000008, "Wrong size on LWorldSystem_GetAppliedWeatherCodeName");
static_assert(offsetof(LWorldSystem_GetAppliedWeatherCodeName, ReturnValue) == 0x000000, "Member 'LWorldSystem_GetAppliedWeatherCodeName::ReturnValue' has a wrong offset!");

}

