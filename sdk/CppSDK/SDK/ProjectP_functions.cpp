#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ProjectP

#include "Basic.hpp"

#include "ProjectP_classes.hpp"
#include "ProjectP_parameters.hpp"


namespace SDK
{

// Function ProjectP.LWeaponAnimInstance.ChangeAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AnimState_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponAnimInstance::ChangeAnimState(class FName AnimState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponAnimInstance", "ChangeAnimState");

	Params::LWeaponAnimInstance_ChangeAnimState Parms{};

	Parms.AnimState_0 = AnimState_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeaponAnimInstance.ClearAnimState
// (Final, Native, Public, BlueprintCallable)

void ULWeaponAnimInstance::ClearAnimState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponAnimInstance", "ClearAnimState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropSpot.OnChangePropStateFromLevelObject
// (Final, Native, Protected)
// Parameters:
// int32                                   TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPropSpot::OnChangePropStateFromLevelObject(int32 TargetState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropSpot", "OnChangePropStateFromLevelObject");

	Params::LPropSpot_OnChangePropStateFromLevelObject Parms{};

	Parms.TargetState = TargetState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropSpot.OnCheckLinkedNpcSpotFromLevelObject
// (Final, Native, Protected)
// Parameters:
// ELLinkedNpcSpotExecuteType              ExecuteType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPropSpot::OnCheckLinkedNpcSpotFromLevelObject(ELLinkedNpcSpotExecuteType ExecuteType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropSpot", "OnCheckLinkedNpcSpotFromLevelObject");

	Params::LPropSpot_OnCheckLinkedNpcSpotFromLevelObject Parms{};

	Parms.ExecuteType = ExecuteType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropSpot.OnCheckNextPropStateFromLevelObject
// (Final, Native, Protected)

void ALPropSpot::OnCheckNextPropStateFromLevelObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropSpot", "OnCheckNextPropStateFromLevelObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropSpot.OnComponentBeginOverlapPropVolume
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALPropSpot::OnComponentBeginOverlapPropVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropSpot", "OnComponentBeginOverlapPropVolume");

	Params::LPropSpot_OnComponentBeginOverlapPropVolume Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropSpot.OnComponentEndOverlapPropVolume
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPropSpot::OnComponentEndOverlapPropVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropSpot", "OnComponentEndOverlapPropVolume");

	Params::LPropSpot_OnComponentEndOverlapPropVolume Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBossRoomSpot.OnDeadSpawnNpc
// (Final, Native, Public)
// Parameters:
// class ALNPCSpot*                        TargetNpcSpot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALBossRoomSpot::OnDeadSpawnNpc(class ALNPCSpot* TargetNpcSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBossRoomSpot", "OnDeadSpawnNpc");

	Params::LBossRoomSpot_OnDeadSpawnNpc Parms{};

	Parms.TargetNpcSpot = TargetNpcSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBossRoomSpot.OnSpawnedActor
// (Final, Native, Public)
// Parameters:
// class ALPropSpot*                       TargetPropSpot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALBossRoomSpot::OnSpawnedActor(class ALPropSpot* TargetPropSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBossRoomSpot", "OnSpawnedActor");

	Params::LBossRoomSpot_OnSpawnedActor Parms{};

	Parms.TargetPropSpot = TargetPropSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDurableAbnormalBPFuncLibrary.GetInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLDurableAbnormalBPPtr           In                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAbnormalStateCommonInfoPtr      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAbnormalStateCommonInfoPtr ULDurableAbnormalBPFuncLibrary::GetInfo(const struct FLDurableAbnormalBPPtr& In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LDurableAbnormalBPFuncLibrary", "GetInfo");

	Params::LDurableAbnormalBPFuncLibrary_GetInfo Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDurableAbnormalBPFuncLibrary.GetUniqueId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLDurableAbnormalBPPtr           In                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ULDurableAbnormalBPFuncLibrary::GetUniqueId(const struct FLDurableAbnormalBPPtr& In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LDurableAbnormalBPFuncLibrary", "GetUniqueId");

	Params::LDurableAbnormalBPFuncLibrary_GetUniqueId Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDurableAbnormalBPFuncLibrary.GetRemainDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLDurableAbnormalBPPtr           In                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULDurableAbnormalBPFuncLibrary::GetRemainDuration(const struct FLDurableAbnormalBPPtr& In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDurableAbnormalBPFuncLibrary", "GetRemainDuration");

	Params::LDurableAbnormalBPFuncLibrary_GetRemainDuration Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.BuildupHitBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCalcBuildupData                InBuildupData                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULAbnormalComponent::BuildupHitBP(const struct FLCalcBuildupData& InBuildupData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "BuildupHitBP");

	Params::LAbnormalComponent_BuildupHitBP Parms{};

	Parms.InBuildupData = std::move(InBuildupData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.CalcDirectBuildupHitByHit
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLHitInfo                        InHitInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   InSkillBuildupDamage                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFireBuildupDamage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InElectricBuildupDamage                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAcidBuildupDamage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLCalcBuildupData>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLCalcBuildupData> ULAbnormalComponent::CalcDirectBuildupHitByHit(const struct FLHitInfo& InHitInfo, int32 InSkillBuildupDamage, int32 InFireBuildupDamage, int32 InElectricBuildupDamage, int32 InAcidBuildupDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "CalcDirectBuildupHitByHit");

	Params::LAbnormalComponent_CalcDirectBuildupHitByHit Parms{};

	Parms.InHitInfo = std::move(InHitInfo);
	Parms.InSkillBuildupDamage = InSkillBuildupDamage;
	Parms.InFireBuildupDamage = InFireBuildupDamage;
	Parms.InElectricBuildupDamage = InElectricBuildupDamage;
	Parms.InAcidBuildupDamage = InAcidBuildupDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.GetAppliedAbnormalMaxDurationByUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   InAbnormalUniqueId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAbnormalComponent::GetAppliedAbnormalMaxDurationByUniqueId(int64 InAbnormalUniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "GetAppliedAbnormalMaxDurationByUniqueId");

	Params::LAbnormalComponent_GetAppliedAbnormalMaxDurationByUniqueId Parms{};

	Parms.InAbnormalUniqueId = InAbnormalUniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.GetAppliedAbnormalRemainDurationByUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   InAbnormalUniqueId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAbnormalComponent::GetAppliedAbnormalRemainDurationByUniqueId(int64 InAbnormalUniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "GetAppliedAbnormalRemainDurationByUniqueId");

	Params::LAbnormalComponent_GetAppliedAbnormalRemainDurationByUniqueId Parms{};

	Parms.InAbnormalUniqueId = InAbnormalUniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.OnBrokenBlade
// (Final, Native, Public, BlueprintCallable)

void ULAbnormalComponent::OnBrokenBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnBrokenBlade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.OnCaptureMoment
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMomentConditionCaptureInfo      Capture                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULAbnormalComponent::OnCaptureMoment(class AActor* Owner, const struct FMomentConditionCaptureInfo& Capture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnCaptureMoment");

	Params::LAbnormalComponent_OnCaptureMoment Parms{};

	Parms.Owner = Owner;
	Parms.Capture = std::move(Capture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.OnChooseOtherWeapon
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FLEquipItemSlot                  EquipSlot                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULAbnormalComponent::OnChooseOtherWeapon(const struct FLEquipItemSlot& EquipSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnChooseOtherWeapon");

	Params::LAbnormalComponent_OnChooseOtherWeapon Parms{};

	Parms.EquipSlot = std::move(EquipSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.OnPlayHideFX
// (Final, Native, Public)
// Parameters:
// bool                                    IsHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::OnPlayHideFX(bool IsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnPlayHideFX");

	Params::LAbnormalComponent_OnPlayHideFX Parms{};

	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.OnRemoveAbnormalNiagaraFX
// (Final, Native, Public)
// Parameters:
// class UNiagaraComponent*                InNiagaraComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::OnRemoveAbnormalNiagaraFX(class UNiagaraComponent* InNiagaraComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnRemoveAbnormalNiagaraFX");

	Params::LAbnormalComponent_OnRemoveAbnormalNiagaraFX Parms{};

	Parms.InNiagaraComp = InNiagaraComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.OnRemoveAbnormalParticleFX
// (Final, Native, Public)
// Parameters:
// class UParticleSystemComponent*         InParticleComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::OnRemoveAbnormalParticleFX(class UParticleSystemComponent* InParticleComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnRemoveAbnormalParticleFX");

	Params::LAbnormalComponent_OnRemoveAbnormalParticleFX Parms{};

	Parms.InParticleComp = InParticleComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.OnSatisfiedBuffAlter
// (Final, Native, Public)
// Parameters:
// struct FHumanizationBuffAlterInfoPtr    InActiveBuffAlterInfo                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULAbnormalComponent::OnSatisfiedBuffAlter(const struct FHumanizationBuffAlterInfoPtr& InActiveBuffAlterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "OnSatisfiedBuffAlter");

	Params::LAbnormalComponent_OnSatisfiedBuffAlter Parms{};

	Parms.InActiveBuffAlterInfo = std::move(InActiveBuffAlterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.PutOn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceNewAbnormal                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ULAbnormalComponent::PutOn(const class FName& InAbnormalCodeName, bool ForceNewAbnormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "PutOn");

	Params::LAbnormalComponent_PutOn Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;
	Parms.ForceNewAbnormal = ForceNewAbnormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.PutOnByPayload
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAbnormalPayload                InPayload                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ULAbnormalComponent::PutOnByPayload(const class FName& InAbnormalCodeName, const struct FLAbnormalPayload& InPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "PutOnByPayload");

	Params::LAbnormalComponent_PutOnByPayload Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;
	Parms.InPayload = std::move(InPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.PutOnWithInstigator
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ULAbnormalComponent::PutOnWithInstigator(const class FName& InAbnormalCodeName, class UObject* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "PutOnWithInstigator");

	Params::LAbnormalComponent_PutOnWithInstigator Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.PutOnWithReason
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InReasonCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ULAbnormalComponent::PutOnWithReason(const class FName& InAbnormalCodeName, const class FName& InReasonCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "PutOnWithReason");

	Params::LAbnormalComponent_PutOnWithReason Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;
	Parms.InReasonCodeName = InReasonCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.RequestBroadcast_NPCElementUI
// (Final, Native, Public, BlueprintCallable)

void ULAbnormalComponent::RequestBroadcast_NPCElementUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "RequestBroadcast_NPCElementUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.TakeOff
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::TakeOff(const class FName& InAbnormalCodeName, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "TakeOff");

	Params::LAbnormalComponent_TakeOff Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.TakeOffAllByInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::TakeOffAllByInstigator(class UObject* InInstigator, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "TakeOffAllByInstigator");

	Params::LAbnormalComponent_TakeOffAllByInstigator Parms{};

	Parms.InInstigator = InInstigator;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.TakeOffByGroup
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             IGroupCodeName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::TakeOffByGroup(const class FName& IGroupCodeName, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "TakeOffByGroup");

	Params::LAbnormalComponent_TakeOffByGroup Parms{};

	Parms.IGroupCodeName = IGroupCodeName;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.TakeOffByInstigator
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::TakeOffByInstigator(const class FName& InAbnormalCodeName, class UObject* InInstigator, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "TakeOffByInstigator");

	Params::LAbnormalComponent_TakeOffByInstigator Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;
	Parms.InInstigator = InInstigator;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.TakeOffByUniqueId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   InAbnormalUniqueId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAbnormalComponent::TakeOffByUniqueId(int64 InAbnormalUniqueId, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "TakeOffByUniqueId");

	Params::LAbnormalComponent_TakeOffByUniqueId Parms{};

	Parms.InAbnormalUniqueId = InAbnormalUniqueId;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAbnormalComponent.TakeOffWithRefCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   InAbnormalUniqueId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAbnormalComponent::TakeOffWithRefCount(int64 InAbnormalUniqueId, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "TakeOffWithRefCount");

	Params::LAbnormalComponent_TakeOffWithRefCount Parms{};

	Parms.InAbnormalUniqueId = InAbnormalUniqueId;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.GetAppliedAbnormals
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FLDurableAbnormalBPPtr>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLDurableAbnormalBPPtr> ULAbnormalComponent::GetAppliedAbnormals() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "GetAppliedAbnormals");

	Params::LAbnormalComponent_GetAppliedAbnormals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.IsAppliedAbnormal
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAbnormalComponent::IsAppliedAbnormal(const class FName& InAbnormalCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "IsAppliedAbnormal");

	Params::LAbnormalComponent_IsAppliedAbnormal Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.IsAppliedAbnormalCount
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAbnormalComponent::IsAppliedAbnormalCount(const class FName& InAbnormalCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "IsAppliedAbnormalCount");

	Params::LAbnormalComponent_IsAppliedAbnormalCount Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.IsAppliedGroupAbnormal
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             GroupCodename                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAbnormalComponent::IsAppliedGroupAbnormal(const class FName& GroupCodename) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "IsAppliedGroupAbnormal");

	Params::LAbnormalComponent_IsAppliedGroupAbnormal Parms{};

	Parms.GroupCodename = GroupCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.IsBuildupAbnormal
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAbnormalComponent::IsBuildupAbnormal(const class FName& InAbnormalCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "IsBuildupAbnormal");

	Params::LAbnormalComponent_IsBuildupAbnormal Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAbnormalComponent.IsGaugeAbnormal
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAbnormalCodeName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAbnormalComponent::IsGaugeAbnormal(const class FName& InAbnormalCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAbnormalComponent", "IsGaugeAbnormal");

	Params::LAbnormalComponent_IsGaugeAbnormal Parms{};

	Parms.InAbnormalCodeName = InAbnormalCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBTask_BlueprintBase.GetBehaivorTreeNodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULBTask_BlueprintBase::GetBehaivorTreeNodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBTask_BlueprintBase", "GetBehaivorTreeNodeName");

	Params::LBTask_BlueprintBase_GetBehaivorTreeNodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBTask_BlueprintBase.OnPostEditChangeProperty
// (Event, Public, BlueprintEvent)

void ULBTask_BlueprintBase::OnPostEditChangeProperty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBTask_BlueprintBase", "OnPostEditChangeProperty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LBTask_BlueprintBase.SetBehaivorTreeNodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBTask_BlueprintBase::SetBehaivorTreeNodeName(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBTask_BlueprintBase", "SetBehaivorTreeNodeName");

	Params::LBTask_BlueprintBase_SetBehaivorTreeNodeName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.AddDamagePerTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::AddDamagePerTime(class ALCharacter* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "AddDamagePerTime");

	Params::LDynamicDamageVolumeActor_AddDamagePerTime Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.ApplyDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             Skill_Hit_Override                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::ApplyDamage(class AActor* TargetActor, const struct FHitResult& HitResult, class FName Skill_Hit_Override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "ApplyDamage");

	Params::LDynamicDamageVolumeActor_ApplyDamage Parms{};

	Parms.TargetActor = TargetActor;
	Parms.HitResult = std::move(HitResult);
	Parms.Skill_Hit_Override = Skill_Hit_Override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.GetOverlappedActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ALDynamicDamageVolumeActor::GetOverlappedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "GetOverlappedActors");

	Params::LDynamicDamageVolumeActor_GetOverlappedActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDynamicDamageVolumeActor.OnBeginOverlap
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::OnBeginOverlap(class AActor* Actor, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "OnBeginOverlap");

	Params::LDynamicDamageVolumeActor_OnBeginOverlap Parms{};

	Parms.Actor = Actor;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LDynamicDamageVolumeActor.OnEndOverlap
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::OnEndOverlap(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "OnEndOverlap");

	Params::LDynamicDamageVolumeActor_OnEndOverlap Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LDynamicDamageVolumeActor.RemoveDamagePerTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::RemoveDamagePerTime(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "RemoveDamagePerTime");

	Params::LDynamicDamageVolumeActor_RemoveDamagePerTime Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.Reset
// (Final, Native, Public, BlueprintCallable)

void ALDynamicDamageVolumeActor::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.ResetDynamicDamageVolumeInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::ResetDynamicDamageVolumeInfo(class FName InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "ResetDynamicDamageVolumeInfo");

	Params::LDynamicDamageVolumeActor_ResetDynamicDamageVolumeInfo Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.SetOverlappedActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InActorList                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALDynamicDamageVolumeActor::SetOverlappedActors(const TArray<class AActor*>& InActorList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "SetOverlappedActors");

	Params::LDynamicDamageVolumeActor_SetOverlappedActors Parms{};

	Parms.InActorList = std::move(InActorList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.Start
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALDynamicDamageVolumeActor::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.Stop
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALDynamicDamageVolumeActor::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDynamicDamageVolumeActor.UpdateOverlapEvents
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALDynamicDamageVolumeActor::UpdateOverlapEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDynamicDamageVolumeActor", "UpdateOverlapEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAchievementSystem.MakeAchievementLog
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AchievementCodeName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULAchievementSystem::MakeAchievementLog(const class FName& AchievementCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAchievementSystem", "MakeAchievementLog");

	Params::LAchievementSystem_MakeAchievementLog Parms{};

	Parms.AchievementCodeName = AchievementCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAchievementSystem.OnSendPlatform
// (Final, Native, Protected)
// Parameters:
// class FName                             AchievementCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAchievementSystem::OnSendPlatform(class FName AchievementCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAchievementSystem", "OnSendPlatform");

	Params::LAchievementSystem_OnSendPlatform Parms{};

	Parms.AchievementCodeName = AchievementCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionClass.ULActionClass_Climb
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Climb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Climb");

	Params::LActionClass_ULActionClass_Climb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Common
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Common()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Common");

	Params::LActionClass_ULActionClass_Common Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_CommonMontage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_CommonMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_CommonMontage");

	Params::LActionClass_ULActionClass_CommonMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Dialoging
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Dialoging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Dialoging");

	Params::LActionClass_ULActionClass_Dialoging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Die
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Die()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Die");

	Params::LActionClass_ULActionClass_Die Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_DMG_STAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_DMG_STAND()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_DMG_STAND");

	Params::LActionClass_ULActionClass_DMG_STAND Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Down_Away
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Down_Away()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Down_Away");

	Params::LActionClass_ULActionClass_Down_Away Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Down_Drag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Down_Drag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Down_Drag");

	Params::LActionClass_ULActionClass_Down_Drag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Down_Stamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Down_Stamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Down_Stamp");

	Params::LActionClass_ULActionClass_Down_Stamp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Down_Up
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Down_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Down_Up");

	Params::LActionClass_ULActionClass_Down_Up Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Draw_Weapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Draw_Weapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Draw_Weapon");

	Params::LActionClass_ULActionClass_Draw_Weapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Falling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Falling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Falling");

	Params::LActionClass_ULActionClass_Falling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_FatalAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_FatalAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_FatalAttack");

	Params::LActionClass_ULActionClass_FatalAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_FatalAttack_Victim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_FatalAttack_Victim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_FatalAttack_Victim");

	Params::LActionClass_ULActionClass_FatalAttack_Victim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_FatalAttack_Victim_BeforeHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_FatalAttack_Victim_BeforeHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_FatalAttack_Victim_BeforeHit");

	Params::LActionClass_ULActionClass_FatalAttack_Victim_BeforeHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_FatalAttack_Victim_End
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_FatalAttack_Victim_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_FatalAttack_Victim_End");

	Params::LActionClass_ULActionClass_FatalAttack_Victim_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_FloatingHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_FloatingHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_FloatingHit");

	Params::LActionClass_ULActionClass_FloatingHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Game_Start
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Game_Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Game_Start");

	Params::LActionClass_ULActionClass_Game_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_GetUpDash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_GetUpDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_GetUpDash");

	Params::LActionClass_ULActionClass_GetUpDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Grab
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Grab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Grab");

	Params::LActionClass_ULActionClass_Grab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Grabbed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Grabbed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Grabbed");

	Params::LActionClass_ULActionClass_Grabbed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_GrabRelease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_GrabRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_GrabRelease");

	Params::LActionClass_ULActionClass_GrabRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Grinder_Element
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Grinder_Element()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Grinder_Element");

	Params::LActionClass_ULActionClass_Grinder_Element Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Groggy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Groggy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Groggy");

	Params::LActionClass_ULActionClass_Groggy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Guard");

	Params::LActionClass_ULActionClass_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Guard_Break
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Guard_Break()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Guard_Break");

	Params::LActionClass_ULActionClass_Guard_Break Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Guard_Hit_Heavy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Guard_Hit_Heavy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Guard_Hit_Heavy");

	Params::LActionClass_ULActionClass_Guard_Hit_Heavy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Guard_Hit_Normal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Guard_Hit_Normal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Guard_Hit_Normal");

	Params::LActionClass_ULActionClass_Guard_Hit_Normal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Guard_Reflect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Guard_Reflect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Guard_Reflect");

	Params::LActionClass_ULActionClass_Guard_Reflect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Guard_Repulse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Guard_Repulse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Guard_Repulse");

	Params::LActionClass_ULActionClass_Guard_Repulse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_IdleTurn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_IdleTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_IdleTurn");

	Params::LActionClass_ULActionClass_IdleTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_IdleTurnEnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_IdleTurnEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_IdleTurnEnd");

	Params::LActionClass_ULActionClass_IdleTurnEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Interaction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Interaction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Interaction");

	Params::LActionClass_ULActionClass_Interaction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Jump
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Jump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Jump");

	Params::LActionClass_ULActionClass_Jump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_KnockBack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_KnockBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_KnockBack");

	Params::LActionClass_ULActionClass_KnockBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Landing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Landing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Landing");

	Params::LActionClass_ULActionClass_Landing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Multiple
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Multiple()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Multiple");

	Params::LActionClass_ULActionClass_Multiple Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_None");

	Params::LActionClass_ULActionClass_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_NpcGuard_Break
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_NpcGuard_Break()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_NpcGuard_Break");

	Params::LActionClass_ULActionClass_NpcGuard_Break Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_NpcGuard_Hit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_NpcGuard_Hit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_NpcGuard_Hit");

	Params::LActionClass_ULActionClass_NpcGuard_Hit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_NpcGuard_Hit_Repulse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_NpcGuard_Hit_Repulse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_NpcGuard_Hit_Repulse");

	Params::LActionClass_ULActionClass_NpcGuard_Hit_Repulse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Object_Repulse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Object_Repulse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Object_Repulse");

	Params::LActionClass_ULActionClass_Object_Repulse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Paralyzation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Paralyzation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Paralyzation");

	Params::LActionClass_ULActionClass_Paralyzation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Parry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Parry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Parry");

	Params::LActionClass_ULActionClass_Parry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Put_Weapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Put_Weapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Put_Weapon");

	Params::LActionClass_ULActionClass_Put_Weapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_SkillFailed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_SkillFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_SkillFailed");

	Params::LActionClass_ULActionClass_SkillFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_SlaveArm
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_SlaveArm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_SlaveArm");

	Params::LActionClass_ULActionClass_SlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_SlaveArm_Visual_Idle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_SlaveArm_Visual_Idle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_SlaveArm_Visual_Idle");

	Params::LActionClass_ULActionClass_SlaveArm_Visual_Idle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_SpawnIdle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_SpawnIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_SpawnIdle");

	Params::LActionClass_ULActionClass_SpawnIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Sprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Sprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Sprint");

	Params::LActionClass_ULActionClass_Sprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Sprint_Exhausted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Sprint_Exhausted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Sprint_Exhausted");

	Params::LActionClass_ULActionClass_Sprint_Exhausted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Sprint_TurnAround
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Sprint_TurnAround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Sprint_TurnAround");

	Params::LActionClass_ULActionClass_Sprint_TurnAround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_StopRunning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_StopRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_StopRunning");

	Params::LActionClass_ULActionClass_StopRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_StopSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_StopSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_StopSprint");

	Params::LActionClass_ULActionClass_StopSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_TalkerIdle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_TalkerIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_TalkerIdle");

	Params::LActionClass_ULActionClass_TalkerIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Teleport_End
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Teleport_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Teleport_End");

	Params::LActionClass_ULActionClass_Teleport_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Teleport_NewGamePlus
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Teleport_NewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Teleport_NewGamePlus");

	Params::LActionClass_ULActionClass_Teleport_NewGamePlus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Teleport_Start
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Teleport_Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Teleport_Start");

	Params::LActionClass_ULActionClass_Teleport_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_ToughSpecialHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_ToughSpecialHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_ToughSpecialHit");

	Params::LActionClass_ULActionClass_ToughSpecialHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_TurnAround
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_TurnAround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_TurnAround");

	Params::LActionClass_ULActionClass_TurnAround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Use_Item
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Use_Item()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Use_Item");

	Params::LActionClass_ULActionClass_Use_Item Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Weapon_Change
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Weapon_Change()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Weapon_Change");

	Params::LActionClass_ULActionClass_Weapon_Change Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Wire_Following
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Wire_Following()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Wire_Following");

	Params::LActionClass_ULActionClass_Wire_Following Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Wire_Hit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Wire_Hit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Wire_Hit");

	Params::LActionClass_ULActionClass_Wire_Hit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_Wire_Pulling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_Wire_Pulling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_Wire_Pulling");

	Params::LActionClass_ULActionClass_Wire_Pulling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_WireAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_WireAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_WireAction");

	Params::LActionClass_ULActionClass_WireAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionClass.ULActionClass_WireJumpSmash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionClass::ULActionClass_WireJumpSmash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionClass", "ULActionClass_WireJumpSmash");

	Params::LActionClass_ULActionClass_WireJumpSmash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEnvSettings.OnApplySetting_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   LocalWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEnvSettings::OnApplySetting_BP(float LocalWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEnvSettings", "OnApplySetting_BP");

	Params::LEnvSettings_OnApplySetting_BP Parms{};

	Parms.LocalWeight = LocalWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LBTreeFuncLibrary.GetBlackboardValueAsLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBTNode*                          NodeOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBlackboardKeySelector           Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULBTreeFuncLibrary::GetBlackboardValueAsLocation(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LBTreeFuncLibrary", "GetBlackboardValueAsLocation");

	Params::LBTreeFuncLibrary_GetBlackboardValueAsLocation Parms{};

	Parms.NodeOwner = NodeOwner;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LButton.SetSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSelected_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULButton::SetSelected(bool bSelected_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LButton", "SetSelected");

	Params::LButton_SetSelected Parms{};

	Parms.bSelected_0 = bSelected_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LButton.IsSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULButton::IsSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LButton", "IsSelected");

	Params::LButton_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.ApplyMaxStatMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetChar                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            SecondStatType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Muliplier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCalcStatFuncLibrary::ApplyMaxStatMultiplier(class AActor* TargetChar, ELSecondStat SecondStatType, float Muliplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "ApplyMaxStatMultiplier");

	Params::LCalcStatFuncLibrary_ApplyMaxStatMultiplier Parms{};

	Parms.TargetChar = TargetChar;
	Parms.SecondStatType = SecondStatType;
	Parms.Muliplier = Muliplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeFrenzyAmount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   FrenzyAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcConsumeFrenzyAmount(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, int32 FrenzyAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcConsumeFrenzyAmount");

	Params::LCalcStatFuncLibrary_CalcConsumeFrenzyAmount Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.FrenzyAmount = FrenzyAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeGuardWeaponSharpness
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcConsumeGuardWeaponSharpness(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcConsumeGuardWeaponSharpness");

	Params::LCalcStatFuncLibrary_CalcConsumeGuardWeaponSharpness Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeWeaponSharpness_Attacker
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 HitPartsComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::CalcConsumeWeaponSharpness_Attacker(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, class ULPartsComponent* HitPartsComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcConsumeWeaponSharpness_Attacker");

	Params::LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Attacker Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitPartsComp = HitPartsComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcConsumeWeaponSharpness_Victim
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 HitPartsComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::CalcConsumeWeaponSharpness_Victim(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, class ULPartsComponent* HitPartsComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcConsumeWeaponSharpness_Victim");

	Params::LCalcStatFuncLibrary_CalcConsumeWeaponSharpness_Victim Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitPartsComp = HitPartsComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLCalcDamageData                 CalcDamageData                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULHitProcContext*                 HitProcContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCalcStatFuncLibrary::CalcDamage(struct FLCalcDamageData& CalcDamageData, class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, const struct FHitResult& HitResult, class ULHitProcContext* HitProcContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcDamage");

	Params::LCalcStatFuncLibrary_CalcDamage Parms{};

	Parms.CalcDamageData = std::move(CalcDamageData);
	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitResult = std::move(HitResult);
	Parms.HitProcContext = HitProcContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CalcDamageData = std::move(Parms.CalcDamageData);
}


// Function ProjectP.LCalcStatFuncLibrary.CalcElementalDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLCalcDamageData                 CalcDamageData                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULHitProcContext*                 HitProcContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCalcStatFuncLibrary::CalcElementalDamage(struct FLCalcDamageData& CalcDamageData, class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, const struct FHitResult& HitResult, class ULHitProcContext* HitProcContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcElementalDamage");

	Params::LCalcStatFuncLibrary_CalcElementalDamage Parms{};

	Parms.CalcDamageData = std::move(CalcDamageData);
	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitResult = std::move(HitResult);
	Parms.HitProcContext = HitProcContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CalcDamageData = std::move(Parms.CalcDamageData);
}


// Function ProjectP.LCalcStatFuncLibrary.CalcEquipmentWeightRatio
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcEquipmentWeightRatio(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcEquipmentWeightRatio");

	Params::LCalcStatFuncLibrary_CalcEquipmentWeightRatio Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcEquipmentWeightRatioInGivenMaxWeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcEquipmentWeightRatioInGivenMaxWeight(class AActor* TargetActor, int32 InMaxWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcEquipmentWeightRatioInGivenMaxWeight");

	Params::LCalcStatFuncLibrary_CalcEquipmentWeightRatioInGivenMaxWeight Parms{};

	Parms.TargetActor = TargetActor;
	Parms.InMaxWeight = InMaxWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcFallingDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcFallingDamage(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcFallingDamage");

	Params::LCalcStatFuncLibrary_CalcFallingDamage Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcFrenzyPoint_ForAttacker
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcFrenzyPoint_ForAttacker(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcFrenzyPoint_ForAttacker");

	Params::LCalcStatFuncLibrary_CalcFrenzyPoint_ForAttacker Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcFrenzyPoint_ForVictim
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ALWeapon*                         VictimWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPerfectGuard                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcFrenzyPoint_ForVictim(class AActor* Victim, const struct FLHitInfo& HitInfo, class ALWeapon* VictimWeapon, bool bPerfectGuard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcFrenzyPoint_ForVictim");

	Params::LCalcStatFuncLibrary_CalcFrenzyPoint_ForVictim Parms{};

	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.VictimWeapon = VictimWeapon;
	Parms.bPerfectGuard = bPerfectGuard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcGroggy_ConsumablePoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   OutGroggyAttackDamage                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReduceByPartsComp                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcGroggy_ConsumablePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, float* OutGroggyAttackDamage, class ULPartsComponent* ReduceByPartsComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcGroggy_ConsumablePoint");

	Params::LCalcStatFuncLibrary_CalcGroggy_ConsumablePoint Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.ReduceByPartsComp = ReduceByPartsComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGroggyAttackDamage != nullptr)
		*OutGroggyAttackDamage = Parms.OutGroggyAttackDamage;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcGroggy_MaintainTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetChar                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcGroggy_MaintainTime(class AActor* TargetChar, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcGroggy_MaintainTime");

	Params::LCalcStatFuncLibrary_CalcGroggy_MaintainTime Parms{};

	Parms.TargetChar = TargetChar;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcGroggyEnableTimeAdd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPerfectGuard                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFuryAttack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcGroggyEnableTimeAdd(class AActor* Attacker, class AActor* Victim, bool IsPerfectGuard, bool IsFuryAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcGroggyEnableTimeAdd");

	Params::LCalcStatFuncLibrary_CalcGroggyEnableTimeAdd Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.IsPerfectGuard = IsPerfectGuard;
	Parms.IsFuryAttack = IsFuryAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcGuard_ConsumablePoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::CalcGuard_ConsumablePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcGuard_ConsumablePoint");

	Params::LCalcStatFuncLibrary_CalcGuard_ConsumablePoint Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcGuard_GuardHitDuration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcGuard_GuardHitDuration(class AActor* TargetActor, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcGuard_GuardHitDuration");

	Params::LCalcStatFuncLibrary_CalcGuard_GuardHitDuration Parms{};

	Parms.TargetActor = TargetActor;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcGuard_PenetrationPower
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcGuard_PenetrationPower(class AActor* TargetActor, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcGuard_PenetrationPower");

	Params::LCalcStatFuncLibrary_CalcGuard_PenetrationPower Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcHitIntensity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   OutHitIntensity                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCalcStatFuncLibrary::CalcHitIntensity(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, float* OutHitIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcHitIntensity");

	Params::LCalcStatFuncLibrary_CalcHitIntensity Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitIntensity != nullptr)
		*OutHitIntensity = Parms.OutHitIntensity;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcParalyzation_ConsumablePoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcParalyzation_ConsumablePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcParalyzation_ConsumablePoint");

	Params::LCalcStatFuncLibrary_CalcParalyzation_ConsumablePoint Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcParalyzation_MaintainTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetChar                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcParalyzation_MaintainTime(class AActor* TargetChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcParalyzation_MaintainTime");

	Params::LCalcStatFuncLibrary_CalcParalyzation_MaintainTime Parms{};

	Parms.TargetChar = TargetChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcPulseRechargePoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcPulseRechargePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcPulseRechargePoint");

	Params::LCalcStatFuncLibrary_CalcPulseRechargePoint Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcRigidity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcRigidity(class AActor* TargetActor, class ALWeapon* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcRigidity");

	Params::LCalcStatFuncLibrary_CalcRigidity Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcTough_DamageFinal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   OutToughAttackDamage                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcTough_DamageFinal(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, float* OutToughAttackDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcTough_DamageFinal");

	Params::LCalcStatFuncLibrary_CalcTough_DamageFinal Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutToughAttackDamage != nullptr)
		*OutToughAttackDamage = Parms.OutToughAttackDamage;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcTough_DamagePrimary
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcTough_DamagePrimary(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcTough_DamagePrimary");

	Params::LCalcStatFuncLibrary_CalcTough_DamagePrimary Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CalcTough_DamageSecondary
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::CalcTough_DamageSecondary(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CalcTough_DamageSecondary");

	Params::LCalcStatFuncLibrary_CalcTough_DamageSecondary Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.CheckVictimInCounterEnableBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCalcStatFuncLibrary::CheckVictimInCounterEnableBP(class AActor* Attacker, class AActor* Victim, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "CheckVictimInCounterEnableBP");

	Params::LCalcStatFuncLibrary_CheckVictimInCounterEnableBP Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetAttackRatio_by_Stat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELPhysicalDamageType                    PhysicalDamageType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::GetAttackRatio_by_Stat(class AActor* Attacker, const struct FLHitInfo& HitInfo, ELPhysicalDamageType PhysicalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetAttackRatio_by_Stat");

	Params::LCalcStatFuncLibrary_GetAttackRatio_by_Stat Parms{};

	Parms.Attacker = Attacker;
	Parms.HitInfo = std::move(HitInfo);
	Parms.PhysicalDamageType = PhysicalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetCharacterElementalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalDamageType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetCharacterElementalAttack(class AActor* Character, class FName SkillHitCodeName, ELElementDamageType ElementalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetCharacterElementalAttack");

	Params::LCalcStatFuncLibrary_GetCharacterElementalAttack Parms{};

	Parms.Character = Character;
	Parms.SkillHitCodeName = SkillHitCodeName;
	Parms.ElementalDamageType = ElementalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetCharacterElementalDefence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalDamageType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetCharacterElementalDefence(class AActor* Character, ELElementDamageType ElementalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetCharacterElementalDefence");

	Params::LCalcStatFuncLibrary_GetCharacterElementalDefence Parms{};

	Parms.Character = Character;
	Parms.ElementalDamageType = ElementalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetCharacterPhysicalAttack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELPhysicalDamageType                    PhysicalDamageType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetCharacterPhysicalAttack(class AActor* Character, const struct FLHitInfo& HitInfo, ELPhysicalDamageType PhysicalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetCharacterPhysicalAttack");

	Params::LCalcStatFuncLibrary_GetCharacterPhysicalAttack Parms{};

	Parms.Character = Character;
	Parms.HitInfo = std::move(HitInfo);
	Parms.PhysicalDamageType = PhysicalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetCharacterPhysicalDefence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalDamageType                    PhysicalDamageType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetCharacterPhysicalDefence(class AActor* Character, ELPhysicalDamageType PhysicalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetCharacterPhysicalDefence");

	Params::LCalcStatFuncLibrary_GetCharacterPhysicalDefence Parms{};

	Parms.Character = Character;
	Parms.PhysicalDamageType = PhysicalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetDestructionPower
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::GetDestructionPower(class AActor* Attacker, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetDestructionPower");

	Params::LCalcStatFuncLibrary_GetDestructionPower Parms{};

	Parms.Attacker = Attacker;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetDynamicDamageVolumeElementalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALDynamicDamageVolumeActor*       DynamicDamageVolume                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetDynamicDamageVolumeElementalAttack(class ALDynamicDamageVolumeActor* DynamicDamageVolume, ELElementDamageType ElementalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetDynamicDamageVolumeElementalAttack");

	Params::LCalcStatFuncLibrary_GetDynamicDamageVolumeElementalAttack Parms{};

	Parms.DynamicDamageVolume = DynamicDamageVolume;
	Parms.ElementalType = ElementalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetDynamicDamageVolumePhysicalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALDynamicDamageVolumeActor*       DynamicDamageVolume                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetDynamicDamageVolumePhysicalAttack(class ALDynamicDamageVolumeActor* DynamicDamageVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetDynamicDamageVolumePhysicalAttack");

	Params::LCalcStatFuncLibrary_GetDynamicDamageVolumePhysicalAttack Parms{};

	Parms.DynamicDamageVolume = DynamicDamageVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetFirstStat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFirstStatDataType                     DataType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFirstStat                             StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVirtual                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetFirstStat(class UObject* WorldContextObject, ELFirstStatDataType DataType, ELFirstStat StatType, bool IsVirtual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetFirstStat");

	Params::LCalcStatFuncLibrary_GetFirstStat Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DataType = DataType;
	Parms.StatType = StatType;
	Parms.IsVirtual = IsVirtual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetFirstStatDataList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVirtual                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLFirstStatData>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLFirstStatData> ULCalcStatFuncLibrary::GetFirstStatDataList(class UObject* WorldContextObject, bool IsVirtual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetFirstStatDataList");

	Params::LCalcStatFuncLibrary_GetFirstStatDataList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IsVirtual = IsVirtual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetGuardPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetGuardPoint(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetGuardPoint");

	Params::LCalcStatFuncLibrary_GetGuardPoint Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetProjectileElementalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALProjectile*                     Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetProjectileElementalAttack(class ALProjectile* Projectile, ELElementDamageType ElementalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetProjectileElementalAttack");

	Params::LCalcStatFuncLibrary_GetProjectileElementalAttack Parms{};

	Parms.Projectile = Projectile;
	Parms.ElementalType = ElementalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetProjectilePhysicalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALProjectile*                     Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetProjectilePhysicalAttack(class ALProjectile* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetProjectilePhysicalAttack");

	Params::LCalcStatFuncLibrary_GetProjectilePhysicalAttack Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetPulseRechargePointMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RechargeCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetPulseRechargePointMax(int32 RechargeCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetPulseRechargePointMax");

	Params::LCalcStatFuncLibrary_GetPulseRechargePointMax Parms{};

	Parms.RechargeCount = RechargeCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetSlaveArmElementalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetSlaveArmElementalAttack(class AActor* Attacker, ELElementDamageType ElementalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetSlaveArmElementalAttack");

	Params::LCalcStatFuncLibrary_GetSlaveArmElementalAttack Parms{};

	Parms.Attacker = Attacker;
	Parms.ElementalType = ElementalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetSlaveArmPhysicalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetSlaveArmPhysicalAttack(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetSlaveArmPhysicalAttack");

	Params::LCalcStatFuncLibrary_GetSlaveArmPhysicalAttack Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetSpecialBuffAttackMultiplier
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCalcStatFuncLibrary::GetSpecialBuffAttackMultiplier(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetSpecialBuffAttackMultiplier");

	Params::LCalcStatFuncLibrary_GetSpecialBuffAttackMultiplier Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetStatComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULStatComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULStatComponent* ULCalcStatFuncLibrary::GetStatComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetStatComponentBP");

	Params::LCalcStatFuncLibrary_GetStatComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetTotalDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLCalcDamageData                 CalcDamageData                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetTotalDamage(struct FLCalcDamageData& CalcDamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetTotalDamage");

	Params::LCalcStatFuncLibrary_GetTotalDamage Parms{};

	Parms.CalcDamageData = std::move(CalcDamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CalcDamageData = std::move(Parms.CalcDamageData);

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetWeaponSkillElementalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         AttackerWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalDamageType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetWeaponSkillElementalAttack(class AActor* Character, class ALWeapon* AttackerWeapon, ELElementDamageType ElementalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetWeaponSkillElementalAttack");

	Params::LCalcStatFuncLibrary_GetWeaponSkillElementalAttack Parms{};

	Parms.Character = Character;
	Parms.AttackerWeapon = AttackerWeapon;
	Parms.ElementalDamageType = ElementalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.GetWeaponSkillPhysicalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         AttackerWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalDamageType                    PhysicalDamageType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCalcStatFuncLibrary::GetWeaponSkillPhysicalAttack(class AActor* Character, class ALWeapon* AttackerWeapon, ELPhysicalDamageType PhysicalDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "GetWeaponSkillPhysicalAttack");

	Params::LCalcStatFuncLibrary_GetWeaponSkillPhysicalAttack Parms{};

	Parms.Character = Character;
	Parms.AttackerWeapon = AttackerWeapon;
	Parms.PhysicalDamageType = PhysicalDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.HasElementDamage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLCalcDamageData                 CalcDamageData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementDamageType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCalcStatFuncLibrary::HasElementDamage(const struct FLCalcDamageData& CalcDamageData, ELElementDamageType ElementDamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "HasElementDamage");

	Params::LCalcStatFuncLibrary_HasElementDamage Parms{};

	Parms.CalcDamageData = std::move(CalcDamageData);
	Parms.ElementDamageType = ElementDamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.IsElementalAttack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCalcStatFuncLibrary::IsElementalAttack(class AActor* Attacker, const struct FLHitInfo& HitInfo, ELElementDamageType ElementalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "IsElementalAttack");

	Params::LCalcStatFuncLibrary_IsElementalAttack Parms{};

	Parms.Attacker = Attacker;
	Parms.HitInfo = std::move(HitInfo);
	Parms.ElementalType = ElementalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.IsElementalAttack_Impl
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         AttackerWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELElementDamageType                     ElementalType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCalcStatFuncLibrary::IsElementalAttack_Impl(class AActor* Attacker, class FName SkillHitCodeName, class ALWeapon* AttackerWeapon, ELElementDamageType ElementalType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "IsElementalAttack_Impl");

	Params::LCalcStatFuncLibrary_IsElementalAttack_Impl Parms{};

	Parms.Attacker = Attacker;
	Parms.SkillHitCodeName = SkillHitCodeName;
	Parms.AttackerWeapon = AttackerWeapon;
	Parms.ElementalType = ElementalType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.PickPhysicalDamagedType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELPhysicalDamageType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPhysicalDamageType ULCalcStatFuncLibrary::PickPhysicalDamagedType(class AActor* Attacker, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "PickPhysicalDamagedType");

	Params::LCalcStatFuncLibrary_PickPhysicalDamagedType Parms{};

	Parms.Attacker = Attacker;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCalcStatFuncLibrary.Test_ApplyCharacterStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InputStat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Broadcast                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCalcStatFuncLibrary::Test_ApplyCharacterStat(class AActor* Target, ELSecondStat StatType, int32 InputStat, bool ApplyMax, bool Broadcast)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCalcStatFuncLibrary", "Test_ApplyCharacterStat");

	Params::LCalcStatFuncLibrary_Test_ApplyCharacterStat Parms{};

	Parms.Target = Target;
	Parms.StatType = StatType;
	Parms.InputStat = InputStat;
	Parms.ApplyMax = ApplyMax;
	Parms.Broadcast = Broadcast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.DestoryCameraWork
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::DestoryCameraWork(class ALCameraWork* CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "DestoryCameraWork");

	Params::LCameraManager_DestoryCameraWork Parms{};

	Parms.CameraWork = CameraWork;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraManager.DisableShoulderView
// (Final, Native, Public, BlueprintCallable)

void ALCameraManager::DisableShoulderView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "DisableShoulderView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.EnableMoveCameraUpDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::EnableMoveCameraUpDown(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "EnableMoveCameraUpDown");

	Params::LCameraManager_EnableMoveCameraUpDown Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.EnableShoulderView
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::EnableShoulderView(const struct FVector& Offset, float BlendInTime, float BlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "EnableShoulderView");

	Params::LCameraManager_EnableShoulderView Parms{};

	Parms.Offset = std::move(Offset);
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.GetBasicCameraRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ALCameraManager::GetBasicCameraRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "GetBasicCameraRotation");

	Params::LCameraManager_GetBasicCameraRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraManager.NewCameraWork
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CameraWorkName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCameraWork*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCameraWork* ALCameraManager::NewCameraWork(class FName CameraWorkName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "NewCameraWork");

	Params::LCameraManager_NewCameraWork Parms{};

	Parms.CameraWorkName = CameraWorkName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraManager.OnStopWorkFinish
// (Final, Native, Protected)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::OnStopWorkFinish(class ALCameraWork* CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "OnStopWorkFinish");

	Params::LCameraManager_OnStopWorkFinish Parms{};

	Parms.CameraWork = CameraWork;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.PlayCameraWork
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             CameraWorkName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ObjectContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       TransformContext                                       (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DurationTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCameraWork*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCameraWork* ALCameraManager::PlayCameraWork(class FName CameraWorkName, class UObject* ObjectContext, const struct FTransform& TransformContext, float DurationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "PlayCameraWork");

	Params::LCameraManager_PlayCameraWork Parms{};

	Parms.CameraWorkName = CameraWorkName;
	Parms.ObjectContext = ObjectContext;
	Parms.TransformContext = std::move(TransformContext);
	Parms.DurationTime = DurationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraManager.RegisterCameraWork
// (Final, Native, Public)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::RegisterCameraWork(class ALCameraWork* CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "RegisterCameraWork");

	Params::LCameraManager_RegisterCameraWork Parms{};

	Parms.CameraWork = CameraWork;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.ResetAllModifiers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::ResetAllModifiers(class UObject* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "ResetAllModifiers");

	Params::LCameraManager_ResetAllModifiers Parms{};

	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.ResetCameraDistanceModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::ResetCameraDistanceModifier(class UObject* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "ResetCameraDistanceModifier");

	Params::LCameraManager_ResetCameraDistanceModifier Parms{};

	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.ResetCameraLagSpeedModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCameraAttrModifierID           ModifierID                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::ResetCameraLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "ResetCameraLagSpeedModifier");

	Params::LCameraManager_ResetCameraLagSpeedModifier Parms{};

	Parms.ModifierID = std::move(ModifierID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.ResetCameraRotationLagSpeedModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCameraAttrModifierID           ModifierID                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::ResetCameraRotationLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "ResetCameraRotationLagSpeedModifier");

	Params::LCameraManager_ResetCameraRotationLagSpeedModifier Parms{};

	Parms.ModifierID = std::move(ModifierID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.ResetLocationOffsetModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCameraAttrModifierID           ModifierID                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::ResetLocationOffsetModifier(const struct FLCameraAttrModifierID& ModifierID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "ResetLocationOffsetModifier");

	Params::LCameraManager_ResetLocationOffsetModifier Parms{};

	Parms.ModifierID = std::move(ModifierID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetCameraDistanceModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCameraModifierPriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetCameraDistanceModifier(class UObject* InInstigator, float Distance, ELCameraModifierPriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetCameraDistanceModifier");

	Params::LCameraManager_SetCameraDistanceModifier Parms{};

	Parms.InInstigator = InInstigator;
	Parms.Distance = Distance;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetCameraLagSpeedModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCameraAttrModifierID           ModifierID                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CameraLagSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCameraModifierPriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLCameraAttrModifierBlendTime    BlendTime                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::SetCameraLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID, float CameraLagSpeed, ELCameraModifierPriority Priority, const struct FLCameraAttrModifierBlendTime& BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetCameraLagSpeedModifier");

	Params::LCameraManager_SetCameraLagSpeedModifier Parms{};

	Parms.ModifierID = std::move(ModifierID);
	Parms.CameraLagSpeed = CameraLagSpeed;
	Parms.Priority = Priority;
	Parms.BlendTime = std::move(BlendTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetCameraRotationLagSpeedModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCameraAttrModifierID           ModifierID                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CameraRotationLagSpeed_0                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCameraModifierPriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLCameraAttrModifierBlendTime    BlendTime                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::SetCameraRotationLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID, float CameraRotationLagSpeed_0, ELCameraModifierPriority Priority, const struct FLCameraAttrModifierBlendTime& BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetCameraRotationLagSpeedModifier");

	Params::LCameraManager_SetCameraRotationLagSpeedModifier Parms{};

	Parms.ModifierID = std::move(ModifierID);
	Parms.CameraRotationLagSpeed_0 = CameraRotationLagSpeed_0;
	Parms.Priority = Priority;
	Parms.BlendTime = std::move(BlendTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetCharacterFastMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFastMovement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetCharacterFastMovement(bool bFastMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetCharacterFastMovement");

	Params::LCameraManager_SetCharacterFastMovement Parms{};

	Parms.bFastMovement = bFastMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetCineCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAlignToCineCamera                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlignToPlayerBack                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetCineCamera(bool bAlignToCineCamera, bool bAlignToPlayerBack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetCineCamera");

	Params::LCameraManager_SetCineCamera Parms{};

	Parms.bAlignToCineCamera = bAlignToCineCamera;
	Parms.bAlignToPlayerBack = bAlignToPlayerBack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetCinematicPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPlaying                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetCinematicPlay(bool bPlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetCinematicPlay");

	Params::LCameraManager_SetCinematicPlay Parms{};

	Parms.bPlaying = bPlaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetControlRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::SetControlRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetControlRotation");

	Params::LCameraManager_SetControlRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetControlRotationBack_Player
// (Final, Native, Public, BlueprintCallable)

void ALCameraManager::SetControlRotationBack_Player()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetControlRotationBack_Player");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetControlRotationBack_PlayerInit
// (Final, Native, Public, BlueprintCallable)

void ALCameraManager::SetControlRotationBack_PlayerInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetControlRotationBack_PlayerInit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetControlRotationSmooth
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::SetControlRotationSmooth(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetControlRotationSmooth");

	Params::LCameraManager_SetControlRotationSmooth Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetDialogCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetDialogCamera(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetDialogCamera");

	Params::LCameraManager_SetDialogCamera Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetFollowingCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFollowing                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetFollowingCamera(bool bFollowing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetFollowingCamera");

	Params::LCameraManager_SetFollowingCamera Parms{};

	Parms.bFollowing = bFollowing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetLadderCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLadderCamera                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SetLadderCamera(bool bLadderCamera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetLadderCamera");

	Params::LCameraManager_SetLadderCamera Parms{};

	Parms.bLadderCamera = bLadderCamera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetLocationOffsetModifier
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLCameraAttrModifierID           ModifierID                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCameraModifierPriority                Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLCameraAttrModifierBlendTime    BlendTime                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraManager::SetLocationOffsetModifier(const struct FLCameraAttrModifierID& ModifierID, const struct FVector& LocationOffset, ELCameraModifierPriority Priority, const struct FLCameraAttrModifierBlendTime& BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetLocationOffsetModifier");

	Params::LCameraManager_SetLocationOffsetModifier Parms{};

	Parms.ModifierID = std::move(ModifierID);
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.Priority = Priority;
	Parms.BlendTime = std::move(BlendTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetLockOnCamera
// (Final, Native, Public, BlueprintCallable)

void ALCameraManager::SetLockOnCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetLockOnCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SetMovingCamera
// (Final, Native, Public, BlueprintCallable)

void ALCameraManager::SetMovingCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SetMovingCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraManager.SpawnCameraWorkByName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             CameraWorkName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCameraWork*                     CameraWork                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraManager::SpawnCameraWorkByName(class FName CameraWorkName, class ALCameraWork** CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "SpawnCameraWorkByName");

	Params::LCameraManager_SpawnCameraWorkByName Parms{};

	Parms.CameraWorkName = CameraWorkName;

	UObject::ProcessEvent(Func, &Parms);

	if (CameraWork != nullptr)
		*CameraWork = Parms.CameraWork;
}


// Function ProjectP.LCameraManager.GetBodyLookAtCameraRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ALCameraManager::GetBodyLookAtCameraRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "GetBodyLookAtCameraRotation");

	Params::LCameraManager_GetBodyLookAtCameraRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraManager.GetCameraDistanceValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALCameraManager::GetCameraDistanceValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "GetCameraDistanceValue");

	Params::LCameraManager_GetCameraDistanceValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraManager.GetDefaultCameraData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLPlayerCameraData         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FLPlayerCameraData ALCameraManager::GetDefaultCameraData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "GetDefaultCameraData");

	Params::LCameraManager_GetDefaultCameraData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraManager.GetPlayingCameraWork
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALCameraWork*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCameraWork* ALCameraManager::GetPlayingCameraWork() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraManager", "GetPlayingCameraWork");

	Params::LCameraManager_GetPlayingCameraWork Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_CancelDash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_CancelDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_CancelDash");

	Params::LActionStopReason_ActionStopReason_CancelDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_CancelMove
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_CancelMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_CancelMove");

	Params::LActionStopReason_ActionStopReason_CancelMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_ChangeCostume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_ChangeCostume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_ChangeCostume");

	Params::LActionStopReason_ActionStopReason_ChangeCostume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_EscapeFromInfiniteGrabbing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_EscapeFromInfiniteGrabbing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_EscapeFromInfiniteGrabbing");

	Params::LActionStopReason_ActionStopReason_EscapeFromInfiniteGrabbing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_Explode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_Explode");

	Params::LActionStopReason_ActionStopReason_Explode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_GrabFailed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_GrabFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_GrabFailed");

	Params::LActionStopReason_ActionStopReason_GrabFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_None");

	Params::LActionStopReason_ActionStopReason_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_PayloadInvalid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_PayloadInvalid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_PayloadInvalid");

	Params::LActionStopReason_ActionStopReason_PayloadInvalid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_PlayAnimFailed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_PlayAnimFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_PlayAnimFailed");

	Params::LActionStopReason_ActionStopReason_PlayAnimFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_PlayLevelSequenceBySpot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_PlayLevelSequenceBySpot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_PlayLevelSequenceBySpot");

	Params::LActionStopReason_ActionStopReason_PlayLevelSequenceBySpot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_Sequencer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_Sequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_Sequencer");

	Params::LActionStopReason_ActionStopReason_Sequencer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_StaminaExhausted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_StaminaExhausted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_StaminaExhausted");

	Params::LActionStopReason_ActionStopReason_StaminaExhausted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_Tutorial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_Tutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_Tutorial");

	Params::LActionStopReason_ActionStopReason_Tutorial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStopReason.ActionStopReason_UnexpectedBehaviour
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionStopReason::ActionStopReason_UnexpectedBehaviour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStopReason", "ActionStopReason_UnexpectedBehaviour");

	Params::LActionStopReason_ActionStopReason_UnexpectedBehaviour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ProjectP.LCameraWork.Delegate_OnStopWorkFinish__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::Delegate_OnStopWorkFinish__DelegateSignature(class ALCameraWork* CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "Delegate_OnStopWorkFinish__DelegateSignature");

	Params::LCameraWork_Delegate_OnStopWorkFinish__DelegateSignature Parms{};

	Parms.CameraWork = CameraWork;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.OnChangeBlend
// (Event, Public, BlueprintEvent)
// Parameters:
// ELCameraWorkBlendState                  CameraWorkBlendState                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::OnChangeBlend(ELCameraWorkBlendState CameraWorkBlendState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "OnChangeBlend");

	Params::LCameraWork_OnChangeBlend Parms{};

	Parms.CameraWorkBlendState = CameraWorkBlendState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.OnPreWork
// (BlueprintCosmetic, Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bCanStartWorking                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::OnPreWork(bool* bCanStartWorking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "OnPreWork");

	Params::LCameraWork_OnPreWork Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bCanStartWorking != nullptr)
		*bCanStartWorking = Parms.bCanStartWorking;
}


// Function ProjectP.LCameraWork.OnStartWork
// (Event, Public, BlueprintEvent)

void ALCameraWork::OnStartWork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "OnStartWork");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LCameraWork.OnStopWork
// (Event, Public, BlueprintEvent)

void ALCameraWork::OnStopWork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "OnStopWork");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LCameraWork.ResetWork
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerCameraManager*             Manager                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULCameraWorkManager*              WorkManager_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::ResetWork(class APlayerCameraManager* Manager, class ULCameraWorkManager* WorkManager_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "ResetWork");

	Params::LCameraWork_ResetWork Parms{};

	Parms.Manager = Manager;
	Parms.WorkManager_0 = WorkManager_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraWork.SetPostProcess
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   PostProcessBlendWeight                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPostProcessSettings             PostProcessSettings                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALCameraWork::SetPostProcess(float PostProcessBlendWeight, const struct FPostProcessSettings& PostProcessSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "SetPostProcess");

	Params::LCameraWork_SetPostProcess Parms{};

	Parms.PostProcessBlendWeight = PostProcessBlendWeight;
	Parms.PostProcessSettings = std::move(PostProcessSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraWork.SetViewInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLCameraWorkViewInfo             ViewInfo                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALCameraWork::SetViewInfo(const struct FLCameraWorkViewInfo& ViewInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "SetViewInfo");

	Params::LCameraWork_SetViewInfo Parms{};

	Parms.ViewInfo = std::move(ViewInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraWork.StartWork
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DurationTime_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCameraWork::StartWork(float DurationTime_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "StartWork");

	Params::LCameraWork_StartWork Parms{};

	Parms.DurationTime_0 = DurationTime_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraWork.StopWork
// (Final, Native, Public, BlueprintCallable)

void ALCameraWork::StopWork()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "StopWork");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraWork.StopWorkFinish
// (Final, Native, Public, BlueprintCallable)

void ALCameraWork::StopWorkFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "StopWorkFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraWork.UpdatePostProcess
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::UpdatePostProcess(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "UpdatePostProcess");

	Params::LCameraWork_UpdatePostProcess Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.UpdateTargetView
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::UpdateTargetView(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "UpdateTargetView");

	Params::LCameraWork_UpdateTargetView Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.UpdateTargetViewBlendIn
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::UpdateTargetViewBlendIn(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "UpdateTargetViewBlendIn");

	Params::LCameraWork_UpdateTargetViewBlendIn Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.UpdateTargetViewBlendInFully
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::UpdateTargetViewBlendInFully(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "UpdateTargetViewBlendInFully");

	Params::LCameraWork_UpdateTargetViewBlendInFully Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.UpdateTargetViewBlendOut
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::UpdateTargetViewBlendOut(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "UpdateTargetViewBlendOut");

	Params::LCameraWork_UpdateTargetViewBlendOut Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCameraWork.GetElapsedAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Multiflier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALCameraWork::GetElapsedAlpha(float Multiflier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "GetElapsedAlpha");

	Params::LCameraWork_GetElapsedAlpha Parms{};

	Parms.Multiflier = Multiflier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraWork.HasDurationTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCameraWork::HasDurationTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "HasDurationTime");

	Params::LCameraWork_HasDurationTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraWork.IsWorking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCameraWork::IsWorking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "IsWorking");

	Params::LCameraWork_IsWorking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraWork.UpdateElapsedAlphaForBlend
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   LastElapsedAlaph                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResultAlpha                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiflierIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCameraWork::UpdateElapsedAlphaForBlend(float* LastElapsedAlaph, float* ResultAlpha, float MultiflierIn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraWork", "UpdateElapsedAlphaForBlend");

	Params::LCameraWork_UpdateElapsedAlphaForBlend Parms{};

	Parms.MultiflierIn = MultiflierIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LastElapsedAlaph != nullptr)
		*LastElapsedAlaph = Parms.LastElapsedAlaph;

	if (ResultAlpha != nullptr)
		*ResultAlpha = Parms.ResultAlpha;
}


// Function ProjectP.LActBase.AddActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::AddActionState(class FName ActionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "AddActionState");

	Params::LActBase_AddActionState Parms{};

	Parms.ActionState = ActionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.AddInitActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::AddInitActionState(class FName ActionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "AddInitActionState");

	Params::LActBase_AddInitActionState Parms{};

	Parms.ActionState = ActionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.ChangeActionImmuneState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::ChangeActionImmuneState(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "ChangeActionImmuneState");

	Params::LActBase_ChangeActionImmuneState Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.OnPreProcessAction
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::OnPreProcessAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "OnPreProcessAction");

	Params::LActBase_OnPreProcessAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.OnReset
// (Native, Event, Public, BlueprintEvent)

void ULActBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "OnReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.OnStart
// (Native, Event, Public, BlueprintEvent)

void ULActBase::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.OnStop
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::OnStop(class ULActBase* ReasonAction, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "OnStop");

	Params::LActBase_OnStop Parms{};

	Parms.ReasonAction = ReasonAction;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.OnStopByMe
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ULActBase*                        StoppingAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::OnStopByMe(class ULActBase* StoppingAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "OnStopByMe");

	Params::LActBase_OnStopByMe Parms{};

	Parms.StoppingAction = StoppingAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.OnTick
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::OnTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "OnTick");

	Params::LActBase_OnTick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.ProcessValidLandingSpot
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          CapsuleLocation                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    IsValidLandingSpot                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::ProcessValidLandingSpot(const struct FVector& CapsuleLocation, const struct FHitResult& Hit, bool IsValidLandingSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "ProcessValidLandingSpot");

	Params::LActBase_ProcessValidLandingSpot Parms{};

	Parms.CapsuleLocation = std::move(CapsuleLocation);
	Parms.Hit = std::move(Hit);
	Parms.IsValidLandingSpot = IsValidLandingSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.RemoveActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::RemoveActionState(class FName ActionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "RemoveActionState");

	Params::LActBase_RemoveActionState Parms{};

	Parms.ActionState = ActionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.RemoveInitActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActBase::RemoveInitActionState(class FName ActionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "RemoveInitActionState");

	Params::LActBase_RemoveInitActionState Parms{};

	Parms.ActionState = ActionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActBase.Reset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "Reset");

	Params::LActBase_Reset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.SetActPayload
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULActPayloadBase*                 InActPayload                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::SetActPayload(class ULActPayloadBase* InActPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "SetActPayload");

	Params::LActBase_SetActPayload Parms{};

	Parms.InActPayload = InActPayload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.SetTickable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InTickable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::SetTickable(bool InTickable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "SetTickable");

	Params::LActBase_SetTickable Parms{};

	Parms.InTickable = InTickable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.Start
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "Start");

	Params::LActBase_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::Stop(class ULActBase* ReasonAction, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "Stop");

	Params::LActBase_Stop Parms{};

	Parms.ReasonAction = ReasonAction;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.GetActionTime_End
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActBase::GetActionTime_End() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "GetActionTime_End");

	Params::LActBase_GetActionTime_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.GetActionTime_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActBase::GetActionTime_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "GetActionTime_Start");

	Params::LActBase_GetActionTime_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.GetActPayload
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ULActPayloadBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActPayloadBase* ULActBase::GetActPayload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "GetActPayload");

	Params::LActBase_GetActPayload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActBase.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActBase::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActBase", "IsPlaying");

	Params::LActBase_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.BindOnCurrMontageBlendOutStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_SingleAnim::BindOnCurrMontageBlendOutStarted(int32 MontageInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "BindOnCurrMontageBlendOutStarted");

	Params::LAction_SingleAnim_BindOnCurrMontageBlendOutStarted Parms{};

	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.BindOnCurrMontageEnded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_SingleAnim::BindOnCurrMontageEnded(int32 MontageInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "BindOnCurrMontageEnded");

	Params::LAction_SingleAnim_BindOnCurrMontageEnded Parms{};

	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.ConditionalAnimBranch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      Montage                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELConditionalAnimBranch                 OutBranchResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OutInstigator                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::ConditionalAnimBranch(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSoftObjectPtr<class UAnimMontage> Montage, ELConditionalAnimBranch* OutBranchResult, class UObject** OutInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "ConditionalAnimBranch");

	Params::LAction_SingleAnim_ConditionalAnimBranch Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBranchResult != nullptr)
		*OutBranchResult = Parms.OutBranchResult;

	if (OutInstigator != nullptr)
		*OutInstigator = Parms.OutInstigator;
}


// Function ProjectP.LAction_SingleAnim.ConditionalAnimBranch_WithMontageInstanceID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELConditionalAnimBranch                 OutBranchResult                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OutInstigator                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::ConditionalAnimBranch_WithMontageInstanceID(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 MontageInstanceID, ELConditionalAnimBranch* OutBranchResult, class UObject** OutInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "ConditionalAnimBranch_WithMontageInstanceID");

	Params::LAction_SingleAnim_ConditionalAnimBranch_WithMontageInstanceID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBranchResult != nullptr)
		*OutBranchResult = Parms.OutBranchResult;

	if (OutInstigator != nullptr)
		*OutInstigator = Parms.OutInstigator;
}


// Function ProjectP.LAction_SingleAnim.GetAnimInst
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* ULAction_SingleAnim::GetAnimInst()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "GetAnimInst");

	Params::LAction_SingleAnim_GetAnimInst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.GetAnimInstBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* ULAction_SingleAnim::GetAnimInstBP(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "GetAnimInstBP");

	Params::LAction_SingleAnim_GetAnimInstBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.GetCurrMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULAction_SingleAnim::GetCurrMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "GetCurrMontage");

	Params::LAction_SingleAnim_GetCurrMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.GetCurrMontageInstanceID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_SingleAnim::GetCurrMontageInstanceID(class UAnimInstance** AnimInstance, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "GetCurrMontageInstanceID");

	Params::LAction_SingleAnim_GetCurrMontageInstanceID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AnimInstance != nullptr)
		*AnimInstance = Parms.AnimInstance;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.GetPlayingCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* ULAction_SingleAnim::GetPlayingCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "GetPlayingCharacter");

	Params::LAction_SingleAnim_GetPlayingCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.InitSingleAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    LoadPayload                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::InitSingleAnim(bool LoadPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "InitSingleAnim");

	Params::LAction_SingleAnim_InitSingleAnim Parms{};

	Parms.LoadPayload = LoadPayload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.MakeAbsoluteRootMotionContextBP
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       StartTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       EndTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   StartBlendTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndBlendTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SetManualFinishTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FixStartRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAbsoluteRootMotionModeType            AbsoluteRootMotionModeType                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::MakeAbsoluteRootMotionContextBP(class UAnimMontage* AnimMontage, const struct FTransform& StartTransform, const struct FTransform& EndTransform, float StartBlendTime, float EndBlendTime, float SetManualFinishTime, bool FixStartRotation, ELAbsoluteRootMotionModeType AbsoluteRootMotionModeType, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "MakeAbsoluteRootMotionContextBP");

	Params::LAction_SingleAnim_MakeAbsoluteRootMotionContextBP Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.StartTransform = std::move(StartTransform);
	Parms.EndTransform = std::move(EndTransform);
	Parms.StartBlendTime = StartBlendTime;
	Parms.EndBlendTime = EndBlendTime;
	Parms.SetManualFinishTime = SetManualFinishTime;
	Parms.FixStartRotation = FixStartRotation;
	Parms.AbsoluteRootMotionModeType = AbsoluteRootMotionModeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LAction_SingleAnim.OnAbsoluteRootMotionFinished
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::OnAbsoluteRootMotionFinished(class UAnimMontage* Montage, bool bInterrupted, int32 MontageInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "OnAbsoluteRootMotionFinished");

	Params::LAction_SingleAnim_OnAbsoluteRootMotionFinished Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;
	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.OnCurrMontageBlendOutStarted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::OnCurrMontageBlendOutStarted(class UAnimMontage* Montage, bool bInterrupted, int32 MontageInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "OnCurrMontageBlendOutStarted");

	Params::LAction_SingleAnim_OnCurrMontageBlendOutStarted Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;
	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.OnCurrMontageEnded
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::OnCurrMontageEnded(class UAnimMontage* Montage, bool bInterrupted, int32 MontageInstanceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "OnCurrMontageEnded");

	Params::LAction_SingleAnim_OnCurrMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;
	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.OnLanded
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ACharacter*                       LandingChar                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_SingleAnim::OnLanded(class ACharacter* LandingChar, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "OnLanded");

	Params::LAction_SingleAnim_OnLanded Parms{};

	Parms.LandingChar = LandingChar;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.OnMoveBlockedBy
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ACharacter*                       BlockedChar                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_SingleAnim::OnMoveBlockedBy(class ACharacter* BlockedChar, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "OnMoveBlockedBy");

	Params::LAction_SingleAnim_OnMoveBlockedBy Parms{};

	Parms.BlockedChar = BlockedChar;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InStopRemainTimeCompensateMargin                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin(float InStopRemainTimeCompensateMargin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin");

	Params::LAction_SingleAnim_OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin Parms{};

	Parms.InStopRemainTimeCompensateMargin = InStopRemainTimeCompensateMargin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.PlayCommomAnimBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             CommomAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::PlayCommomAnimBP(class FName CommomAnim, int32* MontageInstanceID, class UAnimMontage** Montage, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "PlayCommomAnimBP");

	Params::LAction_SingleAnim_PlayCommomAnimBP Parms{};

	Parms.CommomAnim = CommomAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MontageInstanceID != nullptr)
		*MontageInstanceID = Parms.MontageInstanceID;

	if (Montage != nullptr)
		*Montage = Parms.Montage;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LAction_SingleAnim.PlayTargetAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    UseAbsoluteRootMotion                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_SingleAnim::PlayTargetAnim(bool UseAbsoluteRootMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "PlayTargetAnim");

	Params::LAction_SingleAnim_PlayTargetAnim Parms{};

	Parms.UseAbsoluteRootMotion = UseAbsoluteRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.PlayTargetAnimBP
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    UseAbsoluteRootMotion                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_SingleAnim::PlayTargetAnimBP(bool UseAbsoluteRootMotion, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "PlayTargetAnimBP");

	Params::LAction_SingleAnim_PlayTargetAnimBP Parms{};

	Parms.UseAbsoluteRootMotion = UseAbsoluteRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.PlayTargetAnimExBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    UseAbsoluteRootMotion                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideMontageBlendIn                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_SingleAnim::PlayTargetAnimExBP(bool UseAbsoluteRootMotion, float OverrideMontageBlendIn, bool ForceOverride, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "PlayTargetAnimExBP");

	Params::LAction_SingleAnim_PlayTargetAnimExBP Parms{};

	Parms.UseAbsoluteRootMotion = UseAbsoluteRootMotion;
	Parms.OverrideMontageBlendIn = OverrideMontageBlendIn;
	Parms.ForceOverride = ForceOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.RefreshStartRotation
// (Final, Native, Public, BlueprintCallable)

void ULAction_SingleAnim::RefreshStartRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "RefreshStartRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.SetAbsoluteRootMotionContext
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAbsoluteRootMotionContext      InAbsoluteRootMotionContext                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::SetAbsoluteRootMotionContext(const struct FLAbsoluteRootMotionContext& InAbsoluteRootMotionContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "SetAbsoluteRootMotionContext");

	Params::LAction_SingleAnim_SetAbsoluteRootMotionContext Parms{};

	Parms.InAbsoluteRootMotionContext = std::move(InAbsoluteRootMotionContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.StartActionRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NeedRotator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_SingleAnim::StartActionRotation(bool NeedRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "StartActionRotation");

	Params::LAction_SingleAnim_StartActionRotation Parms{};

	Parms.NeedRotator = NeedRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_SingleAnim.StopTargetAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_SingleAnim::StopTargetAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "StopTargetAnim");

	Params::LAction_SingleAnim_StopTargetAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SingleAnim.UnBindOnCurrMontageEnded
// (Final, Native, Public, BlueprintCallable)

void ULAction_SingleAnim::UnBindOnCurrMontageEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SingleAnim", "UnBindOnCurrMontageEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_LoopAnim.CancelLoopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             JumpToSectionName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_LoopAnim::CancelLoopAnim(class FName JumpToSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_LoopAnim", "CancelLoopAnim");

	Params::LAction_LoopAnim_CancelLoopAnim Parms{};

	Parms.JumpToSectionName = JumpToSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_LoopAnim.Init_LoopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    LoadPayload                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_LoopAnim::Init_LoopAnim(bool LoadPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_LoopAnim", "Init_LoopAnim");

	Params::LAction_LoopAnim_Init_LoopAnim Parms{};

	Parms.LoadPayload = LoadPayload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_LoopAnim.IsLoopAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_LoopAnim::IsLoopAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_LoopAnim", "IsLoopAnim");

	Params::LAction_LoopAnim_IsLoopAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_LoopAnim.NextLoopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             JumpToSectionName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_LoopAnim::NextLoopAnim(class FName JumpToSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_LoopAnim", "NextLoopAnim");

	Params::LAction_LoopAnim_NextLoopAnim Parms{};

	Parms.JumpToSectionName = JumpToSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_LoopAnim.OnCommandOccurred
// (Final, Native, Public, HasDefaults)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Lever                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SkipCommandPrerequisitiesCheck                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_LoopAnim::OnCommandOccurred(class ULActMgrComponent* ActMgrComponent, class AActor* TargetActor, class FName Command, const struct FVector& Lever, bool SkipCommandPrerequisitiesCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_LoopAnim", "OnCommandOccurred");

	Params::LAction_LoopAnim_OnCommandOccurred Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.TargetActor = TargetActor;
	Parms.Command = Command;
	Parms.Lever = std::move(Lever);
	Parms.SkipCommandPrerequisitiesCheck = SkipCommandPrerequisitiesCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_HitAnim.PlayHitAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             HitAnim                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_HitAnim::PlayHitAnim(class FName HitAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_HitAnim", "PlayHitAnim");

	Params::LAction_HitAnim_PlayHitAnim Parms{};

	Parms.HitAnim = HitAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_HitAnim.PlayHitAnimBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             HitAnim                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_HitAnim::PlayHitAnimBP(class FName HitAnim, int32* MontageInstanceID, class UAnimMontage** Montage, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_HitAnim", "PlayHitAnimBP");

	Params::LAction_HitAnim_PlayHitAnimBP Parms{};

	Parms.HitAnim = HitAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MontageInstanceID != nullptr)
		*MontageInstanceID = Parms.MontageInstanceID;

	if (Montage != nullptr)
		*Montage = Parms.Montage;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LAction_HitAnim.SetLastPlayedHitAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             HitAnim                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAction_HitAnim::SetLastPlayedHitAnim(class FName HitAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_HitAnim", "SetLastPlayedHitAnim");

	Params::LAction_HitAnim_SetLastPlayedHitAnim Parms{};

	Parms.HitAnim = HitAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_HitAnim.UpdateHitMotionReplace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELHitMotionType                         OriginHitMotionType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_HitAnim::UpdateHitMotionReplace(ELHitMotionType OriginHitMotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_HitAnim", "UpdateHitMotionReplace");

	Params::LAction_HitAnim_UpdateHitMotionReplace Parms{};

	Parms.OriginHitMotionType = OriginHitMotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_HitAnim.UpdateSkillHitReplace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewSkillHitCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_HitAnim::UpdateSkillHitReplace(class FName NewSkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_HitAnim", "UpdateSkillHitReplace");

	Params::LAction_HitAnim_UpdateSkillHitReplace Parms{};

	Parms.NewSkillHitCodeName = NewSkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_MultiAnim.OnNewAnimPlayed
// (Native, Event, Public, BlueprintEvent)

void ULAction_MultiAnim::OnNewAnimPlayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_MultiAnim", "OnNewAnimPlayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAction_MultiAnim.OnSelectNextAnim
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentAnimIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_MultiAnim::OnSelectNextAnim(class UAnimMontage* Montage, bool bInterrupted, int32 CurrentAnimIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_MultiAnim", "OnSelectNextAnim");

	Params::LAction_MultiAnim_OnSelectNextAnim Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;
	Parms.CurrentAnimIndex = CurrentAnimIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_MultiAnim.PlayTargetAnimByIndexBP
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   TargetAnimIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULAction_MultiAnim::PlayTargetAnimByIndexBP(int32 TargetAnimIndex, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_MultiAnim", "PlayTargetAnimByIndexBP");

	Params::LAction_MultiAnim_PlayTargetAnimByIndexBP Parms{};

	Parms.TargetAnimIndex = TargetAnimIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SlaveArmVisual.GetSlaveArmAdditiveAlpha
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULAction_SlaveArmVisual::GetSlaveArmAdditiveAlpha()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SlaveArmVisual", "GetSlaveArmAdditiveAlpha");

	Params::LAction_SlaveArmVisual_GetSlaveArmAdditiveAlpha Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_SlaveArmVisual.GetSlaveArmAdditiveAnim
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* ULAction_SlaveArmVisual::GetSlaveArmAdditiveAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_SlaveArmVisual", "GetSlaveArmAdditiveAnim");

	Params::LAction_SlaveArmVisual_GetSlaveArmAdditiveAnim Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_Dialoging.Cancel_StopAfterToWait
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ULAction_Dialoging::Cancel_StopAfterToWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_Dialoging", "Cancel_StopAfterToWait");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LAction_Dialoging.IsPlayingMainAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_Dialoging::IsPlayingMainAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_Dialoging", "IsPlayingMainAnim");

	Params::LAction_Dialoging_IsPlayingMainAnim Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_Dialoging.IsPlayingRotateAnim
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAction_Dialoging::IsPlayingRotateAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_Dialoging", "IsPlayingRotateAnim");

	Params::LAction_Dialoging_IsPlayingRotateAnim Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LAction_Dialoging.StopAfterToWait
// (Event, Public, BlueprintEvent)

void ULAction_Dialoging::StopAfterToWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAction_Dialoging", "StopAfterToWait");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_Action
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULActionStateDebugInfo::ActionStateDebugInfo_From_Action()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStateDebugInfo", "ActionStateDebugInfo_From_Action");

	Params::LActionStateDebugInfo_ActionStateDebugInfo_From_Action Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_Notify
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULActionStateDebugInfo::ActionStateDebugInfo_From_Notify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStateDebugInfo", "ActionStateDebugInfo_From_Notify");

	Params::LActionStateDebugInfo_ActionStateDebugInfo_From_Notify Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_Notify_ApplyInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULActionStateDebugInfo::ActionStateDebugInfo_From_Notify_ApplyInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStateDebugInfo", "ActionStateDebugInfo_From_Notify_ApplyInput");

	Params::LActionStateDebugInfo_ActionStateDebugInfo_From_Notify_ApplyInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_From_NotifyEndMarked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULActionStateDebugInfo::ActionStateDebugInfo_From_NotifyEndMarked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStateDebugInfo", "ActionStateDebugInfo_From_NotifyEndMarked");

	Params::LActionStateDebugInfo_ActionStateDebugInfo_From_NotifyEndMarked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionStateDebugInfo.ActionStateDebugInfo_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULActionStateDebugInfo::ActionStateDebugInfo_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionStateDebugInfo", "ActionStateDebugInfo_None");

	Params::LActionStateDebugInfo_ActionStateDebugInfo_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Aggro_Target
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Aggro_Target()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Aggro_Target");

	Params::LActionState_ActionState_Aggro_Target Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AIState_Force_Return_CHK
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AIState_Force_Return_CHK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AIState_Force_Return_CHK");

	Params::LActionState_ActionState_AIState_Force_Return_CHK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AITargetList_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AITargetList_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AITargetList_Disable");

	Params::LActionState_ActionState_AITargetList_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AITargetList_DisableInDialog
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AITargetList_DisableInDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AITargetList_DisableInDialog");

	Params::LActionState_ActionState_AITargetList_DisableInDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_AcquireGroggyPoint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_AcquireGroggyPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_AcquireGroggyPoint");

	Params::LActionState_ActionState_Allow_AcquireGroggyPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_ChargeCancel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_ChargeCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_ChargeCancel");

	Params::LActionState_ActionState_Allow_ChargeCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_Dash_Heavy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_Dash_Heavy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_Dash_Heavy");

	Params::LActionState_ActionState_Allow_Dash_Heavy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_Dash_Light
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_Dash_Light()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_Dash_Light");

	Params::LActionState_ActionState_Allow_Dash_Light Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_Dying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_Dying");

	Params::LActionState_ActionState_Allow_Dying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_FableCancel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_FableCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_FableCancel");

	Params::LActionState_ActionState_Allow_FableCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_GuardRepulse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_GuardRepulse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_GuardRepulse");

	Params::LActionState_ActionState_Allow_GuardRepulse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_LieDying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_LieDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_LieDying");

	Params::LActionState_ActionState_Allow_LieDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Allow_RepairCancel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Allow_RepairCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Allow_RepairCancel");

	Params::LActionState_ActionState_Allow_RepairCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowAction_Sequence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowAction_Sequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowAction_Sequence");

	Params::LActionState_ActionState_AllowAction_Sequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Dash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Dash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Dash");

	Params::LActionState_ActionState_AllowInput_Dash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_DoubleDash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_DoubleDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_DoubleDash");

	Params::LActionState_ActionState_AllowInput_DoubleDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_FableHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_FableHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_FableHandle");

	Params::LActionState_ActionState_AllowInput_FableHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Frenzy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Frenzy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Frenzy");

	Params::LActionState_ActionState_AllowInput_Frenzy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_GetUpDash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_GetUpDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_GetUpDash");

	Params::LActionState_ActionState_AllowInput_GetUpDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Guard");

	Params::LActionState_ActionState_AllowInput_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_LightAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_LightAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_LightAttack");

	Params::LActionState_ActionState_AllowInput_LightAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Movement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Movement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Movement");

	Params::LActionState_ActionState_AllowInput_Movement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Movement_Forced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Movement_Forced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Movement_Forced");

	Params::LActionState_ActionState_AllowInput_Movement_Forced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Parrying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Parrying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Parrying");

	Params::LActionState_ActionState_AllowInput_Parrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Rotation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Rotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Rotation");

	Params::LActionState_ActionState_AllowInput_Rotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_Rotation_Forced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_Rotation_Forced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_Rotation_Forced");

	Params::LActionState_ActionState_AllowInput_Rotation_Forced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_SlaveArm
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_SlaveArm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_SlaveArm");

	Params::LActionState_ActionState_AllowInput_SlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_StrongAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_StrongAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_StrongAttack");

	Params::LActionState_ActionState_AllowInput_StrongAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_UseItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_UseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_UseItem");

	Params::LActionState_ActionState_AllowInput_UseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_AllowInput_WeaponChange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_AllowInput_WeaponChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_AllowInput_WeaponChange");

	Params::LActionState_ActionState_AllowInput_WeaponChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ApplyInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ApplyInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ApplyInput");

	Params::LActionState_ActionState_ApplyInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_BladeWeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_BladeWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_BladeWeight");

	Params::LActionState_ActionState_BladeWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Can_Dodge_Zero_Stamina
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Can_Dodge_Zero_Stamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Can_Dodge_Zero_Stamina");

	Params::LActionState_ActionState_Can_Dodge_Zero_Stamina Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_CancelMove
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_CancelMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_CancelMove");

	Params::LActionState_ActionState_CancelMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Cinematic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Cinematic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Cinematic");

	Params::LActionState_ActionState_Cinematic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ClimbDown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ClimbDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ClimbDown");

	Params::LActionState_ActionState_ClimbDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ClimbUp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ClimbUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ClimbUp");

	Params::LActionState_ActionState_ClimbUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ConsumeMovement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ConsumeMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ConsumeMovement");

	Params::LActionState_ActionState_ConsumeMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ConsumeRotation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ConsumeRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ConsumeRotation");

	Params::LActionState_ActionState_ConsumeRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Dash_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Dash_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Dash_Disable");

	Params::LActionState_ActionState_Dash_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Dash_SuperHeavy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Dash_SuperHeavy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Dash_SuperHeavy");

	Params::LActionState_ActionState_Dash_SuperHeavy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Dead");

	Params::LActionState_ActionState_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_DeadInvincible_DeadCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_DeadInvincible_DeadCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_DeadInvincible_DeadCharacter");

	Params::LActionState_ActionState_DeadInvincible_DeadCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_DeadInvincible_WorldCommand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_DeadInvincible_WorldCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_DeadInvincible_WorldCommand");

	Params::LActionState_ActionState_DeadInvincible_WorldCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_DepenetrateFromEnv
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_DepenetrateFromEnv()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_DepenetrateFromEnv");

	Params::LActionState_ActionState_DepenetrateFromEnv Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_DestructionDefence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_DestructionDefence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_DestructionDefence");

	Params::LActionState_ActionState_DestructionDefence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Dialoging
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Dialoging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Dialoging");

	Params::LActionState_ActionState_Dialoging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Disable_Footstep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Disable_Footstep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Disable_Footstep");

	Params::LActionState_ActionState_Disable_Footstep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Disable_LockOnRotation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Disable_LockOnRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Disable_LockOnRotation");

	Params::LActionState_ActionState_Disable_LockOnRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Disable_Send_HelpSignal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Disable_Send_HelpSignal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Disable_Send_HelpSignal");

	Params::LActionState_ActionState_Disable_Send_HelpSignal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Disable_TransformModifier_MoveActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Disable_TransformModifier_MoveActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Disable_TransformModifier_MoveActor");

	Params::LActionState_ActionState_Disable_TransformModifier_MoveActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Dodge
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Dodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Dodge");

	Params::LActionState_ActionState_Dodge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_DoubleDash_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_DoubleDash_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_DoubleDash_Enable");

	Params::LActionState_ActionState_DoubleDash_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Dying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Dying");

	Params::LActionState_ActionState_Dying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ExitReposition_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ExitReposition_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ExitReposition_Disable");

	Params::LActionState_ActionState_ExitReposition_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Fable_Buff_Blade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Fable_Buff_Blade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Fable_Buff_Blade");

	Params::LActionState_ActionState_Fable_Buff_Blade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Fable_Buff_Handle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Fable_Buff_Handle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Fable_Buff_Handle");

	Params::LActionState_ActionState_Fable_Buff_Handle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FableArt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FableArt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FableArt");

	Params::LActionState_ActionState_FableArt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Falling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Falling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Falling");

	Params::LActionState_ActionState_Falling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FallingFromDownDrag_B
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FallingFromDownDrag_B()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FallingFromDownDrag_B");

	Params::LActionState_ActionState_FallingFromDownDrag_B Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FallingFromDownDrag_F
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FallingFromDownDrag_F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FallingFromDownDrag_F");

	Params::LActionState_ActionState_FallingFromDownDrag_F Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FallingStart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FallingStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FallingStart");

	Params::LActionState_ActionState_FallingStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FatalAttack_As_Attacker
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FatalAttack_As_Attacker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FatalAttack_As_Attacker");

	Params::LActionState_ActionState_FatalAttack_As_Attacker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FatalAttack_As_Victim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FatalAttack_As_Victim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FatalAttack_As_Victim");

	Params::LActionState_ActionState_FatalAttack_As_Victim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FatalAttack_Counter_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FatalAttack_Counter_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FatalAttack_Counter_Enable");

	Params::LActionState_ActionState_FatalAttack_Counter_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FatalAttack_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FatalAttack_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FatalAttack_Disable");

	Params::LActionState_ActionState_FatalAttack_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FatalAttack_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FatalAttack_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FatalAttack_Enable");

	Params::LActionState_ActionState_FatalAttack_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FatalAttack_Enable_Forced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FatalAttack_Enable_Forced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FatalAttack_Enable_Forced");

	Params::LActionState_ActionState_FatalAttack_Enable_Forced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Floating
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Floating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Floating");

	Params::LActionState_ActionState_Floating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FloatingCeiling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FloatingCeiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FloatingCeiling");

	Params::LActionState_ActionState_FloatingCeiling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FloatingHit_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FloatingHit_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FloatingHit_Enable");

	Params::LActionState_ActionState_FloatingHit_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Frenzy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Frenzy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Frenzy");

	Params::LActionState_ActionState_Frenzy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FuryAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FuryAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FuryAttack");

	Params::LActionState_ActionState_FuryAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_FuryAttackGuardEnable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_FuryAttackGuardEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_FuryAttackGuardEnable");

	Params::LActionState_ActionState_FuryAttackGuardEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_GetUpDash_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_GetUpDash_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_GetUpDash_Disable");

	Params::LActionState_ActionState_GetUpDash_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_GetUpDash_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_GetUpDash_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_GetUpDash_Enable");

	Params::LActionState_ActionState_GetUpDash_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Grab
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Grab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Grab");

	Params::LActionState_ActionState_Grab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Grabbed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Grabbed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Grabbed");

	Params::LActionState_ActionState_Grabbed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_GrappleGun_Reflect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_GrappleGun_Reflect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_GrappleGun_Reflect");

	Params::LActionState_ActionState_GrappleGun_Reflect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Groggy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Groggy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Groggy");

	Params::LActionState_ActionState_Groggy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Groggy_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Groggy_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Groggy_Enable");

	Params::LActionState_ActionState_Groggy_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Groggy_Enable_Time_Added
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Groggy_Enable_Time_Added()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Groggy_Enable_Time_Added");

	Params::LActionState_ActionState_Groggy_Enable_Time_Added Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Guard_Hit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Guard_Hit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Guard_Hit");

	Params::LActionState_ActionState_Guard_Hit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_GuardEx_CoolTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_GuardEx_CoolTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_GuardEx_CoolTime");

	Params::LActionState_ActionState_GuardEx_CoolTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_HeadCostumeOff_Sequence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_HeadCostumeOff_Sequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_HeadCostumeOff_Sequence");

	Params::LActionState_ActionState_HeadCostumeOff_Sequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Heal_Guard_Regain_Maintain
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Heal_Guard_Regain_Maintain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Heal_Guard_Regain_Maintain");

	Params::LActionState_ActionState_Heal_Guard_Regain_Maintain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Hide
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Hide");

	Params::LActionState_ActionState_Hide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_HitBoom
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_HitBoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_HitBoom");

	Params::LActionState_ActionState_HitBoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_HitBoom_CoolTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_HitBoom_CoolTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_HitBoom_CoolTime");

	Params::LActionState_ActionState_HitBoom_CoolTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_HitCheck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_HitCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_HitCheck");

	Params::LActionState_ActionState_HitCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Ignore_Damage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Ignore_Damage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Ignore_Damage");

	Params::LActionState_ActionState_Ignore_Damage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Ignore_Drop_Ergo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Ignore_Drop_Ergo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Ignore_Drop_Ergo");

	Params::LActionState_ActionState_Ignore_Drop_Ergo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Ignore_FallingLateralFriction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Ignore_FallingLateralFriction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Ignore_FallingLateralFriction");

	Params::LActionState_ActionState_Ignore_FallingLateralFriction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Ignore_Invincible_OnDamagedByAbnormal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Ignore_Invincible_OnDamagedByAbnormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Ignore_Invincible_OnDamagedByAbnormal");

	Params::LActionState_ActionState_Ignore_Invincible_OnDamagedByAbnormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Ignore_LeverSpeed_ABP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Ignore_LeverSpeed_ABP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Ignore_LeverSpeed_ABP");

	Params::LActionState_ActionState_Ignore_LeverSpeed_ABP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Ignore_Repulse_All
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Ignore_Repulse_All()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Ignore_Repulse_All");

	Params::LActionState_ActionState_Ignore_Repulse_All Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_IK_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_IK_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_IK_Disable");

	Params::LActionState_ActionState_IK_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Damage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Damage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Damage");

	Params::LActionState_ActionState_Immune_Damage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Elemental
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Elemental()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Elemental");

	Params::LActionState_ActionState_Immune_Elemental Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Groggy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Groggy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Groggy");

	Params::LActionState_ActionState_Immune_Groggy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Hit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Hit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Hit");

	Params::LActionState_ActionState_Immune_Hit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_HitActionDMGStand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_HitActionDMGStand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_HitActionDMGStand");

	Params::LActionState_ActionState_Immune_HitActionDMGStand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_HitActionDownAwayUp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_HitActionDownAwayUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_HitActionDownAwayUp");

	Params::LActionState_ActionState_Immune_HitActionDownAwayUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_HitActionDownDragStamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_HitActionDownDragStamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_HitActionDownDragStamp");

	Params::LActionState_ActionState_Immune_HitActionDownDragStamp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_HitActionGrab
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_HitActionGrab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_HitActionGrab");

	Params::LActionState_ActionState_Immune_HitActionGrab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_HitActionKnockBack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_HitActionKnockBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_HitActionKnockBack");

	Params::LActionState_ActionState_Immune_HitActionKnockBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Immune_Abnormal_Fire_Point
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Immune_Abnormal_Fire_Point()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Immune_Abnormal_Fire_Point");

	Params::LActionState_ActionState_Immune_Immune_Abnormal_Fire_Point Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Paralyzation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Paralyzation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Paralyzation");

	Params::LActionState_ActionState_Immune_Paralyzation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Special_Elemental
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Special_Elemental()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Special_Elemental");

	Params::LActionState_ActionState_Immune_Special_Elemental Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Immune_Tough
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Immune_Tough()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Immune_Tough");

	Params::LActionState_ActionState_Immune_Tough Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Invincible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Invincible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Invincible");

	Params::LActionState_ActionState_Invincible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Key_Pressed_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Key_Pressed_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Key_Pressed_Guard");

	Params::LActionState_ActionState_Key_Pressed_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Key_Pressed_Sprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Key_Pressed_Sprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Key_Pressed_Sprint");

	Params::LActionState_ActionState_Key_Pressed_Sprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockCameraMovement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockCameraMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockCameraMovement");

	Params::LActionState_ActionState_LockCameraMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockCancelMove
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockCancelMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockCancelMove");

	Params::LActionState_ActionState_LockCancelMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockDieAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockDieAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockDieAction");

	Params::LActionState_ActionState_LockDieAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockFalling
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockFalling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockFalling");

	Params::LActionState_ActionState_LockFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockInput_Movement_Forced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockInput_Movement_Forced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockInput_Movement_Forced");

	Params::LActionState_ActionState_LockInput_Movement_Forced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockInput_Rotation_Forced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockInput_Rotation_Forced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockInput_Rotation_Forced");

	Params::LActionState_ActionState_LockInput_Rotation_Forced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockMovement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockMovement");

	Params::LActionState_ActionState_LockMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockOn_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockOn_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockOn_Disable");

	Params::LActionState_ActionState_LockOn_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockOn_DisablePC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockOn_DisablePC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockOn_DisablePC");

	Params::LActionState_ActionState_LockOn_DisablePC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockOnRotateTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockOnRotateTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockOnRotateTarget");

	Params::LActionState_ActionState_LockOnRotateTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockParry_Dash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockParry_Dash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockParry_Dash");

	Params::LActionState_ActionState_LockParry_Dash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockParry_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockParry_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockParry_Guard");

	Params::LActionState_ActionState_LockParry_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockPerfectGuard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockPerfectGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockPerfectGuard");

	Params::LActionState_ActionState_LockPerfectGuard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockPlayerAction_Movie
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockPlayerAction_Movie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockPlayerAction_Movie");

	Params::LActionState_ActionState_LockPlayerAction_Movie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockPlayerAction_Sequence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockPlayerAction_Sequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockPlayerAction_Sequence");

	Params::LActionState_ActionState_LockPlayerAction_Sequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockPlayerAction_Sequence_CameraEnable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockPlayerAction_Sequence_CameraEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockPlayerAction_Sequence_CameraEnable");

	Params::LActionState_ActionState_LockPlayerAction_Sequence_CameraEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockProcessCommand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockProcessCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockProcessCommand");

	Params::LActionState_ActionState_LockProcessCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockRotation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockRotation");

	Params::LActionState_ActionState_LockRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockUseSkill
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockUseSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockUseSkill");

	Params::LActionState_ActionState_LockUseSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockUseSkill_ExceptItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockUseSkill_ExceptItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockUseSkill_ExceptItem");

	Params::LActionState_ActionState_LockUseSkill_ExceptItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LockUseSkill_ExceptItem_SkipTest
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LockUseSkill_ExceptItem_SkipTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LockUseSkill_ExceptItem_SkipTest");

	Params::LActionState_ActionState_LockUseSkill_ExceptItem_SkipTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_AimToTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_AimToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_AimToTarget");

	Params::LActionState_ActionState_LookAt_AimToTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_Disable");

	Params::LActionState_ActionState_LookAt_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_FixAimToTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_FixAimToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_FixAimToTarget");

	Params::LActionState_ActionState_LookAt_FixAimToTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_Head
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_Head()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_Head");

	Params::LActionState_ActionState_LookAt_Head Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_Head_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_Head_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_Head_Disable");

	Params::LActionState_ActionState_LookAt_Head_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_Smash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_Smash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_Smash");

	Params::LActionState_ActionState_LookAt_Smash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_LookAt_UpperBody
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_LookAt_UpperBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_LookAt_UpperBody");

	Params::LActionState_ActionState_LookAt_UpperBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_None");

	Params::LActionState_ActionState_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_NotifyApplyInput_Dash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_NotifyApplyInput_Dash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_NotifyApplyInput_Dash");

	Params::LActionState_ActionState_NotifyApplyInput_Dash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_NotifyApplyInput_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_NotifyApplyInput_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_NotifyApplyInput_Guard");

	Params::LActionState_ActionState_NotifyApplyInput_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_NotifyApplyInput_LightAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_NotifyApplyInput_LightAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_NotifyApplyInput_LightAttack");

	Params::LActionState_ActionState_NotifyApplyInput_LightAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_NotifyApplyInput_StrongAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_NotifyApplyInput_StrongAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_NotifyApplyInput_StrongAttack");

	Params::LActionState_ActionState_NotifyApplyInput_StrongAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_OnGuardHit_Attacker
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_OnGuardHit_Attacker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_OnGuardHit_Attacker");

	Params::LActionState_ActionState_OnGuardHit_Attacker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_OnGuardHit_Victim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_OnGuardHit_Victim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_OnGuardHit_Victim");

	Params::LActionState_ActionState_OnGuardHit_Victim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_OutOfBossRoom
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_OutOfBossRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_OutOfBossRoom");

	Params::LActionState_ActionState_OutOfBossRoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Paralyzation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Paralyzation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Paralyzation");

	Params::LActionState_ActionState_Paralyzation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Paralyzation_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Paralyzation_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Paralyzation_Enable");

	Params::LActionState_ActionState_Paralyzation_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Peace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Peace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Peace");

	Params::LActionState_ActionState_Peace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_PerBodyCollisionProfileApplied
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_PerBodyCollisionProfileApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_PerBodyCollisionProfileApplied");

	Params::LActionState_ActionState_PerBodyCollisionProfileApplied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Perception_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Perception_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Perception_Disable");

	Params::LActionState_ActionState_Perception_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Perfect_Guard_Tough_Damage_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Perfect_Guard_Tough_Damage_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Perfect_Guard_Tough_Damage_Enable");

	Params::LActionState_ActionState_Perfect_Guard_Tough_Damage_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_PhysicsSimulation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_PhysicsSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_PhysicsSimulation");

	Params::LActionState_ActionState_PhysicsSimulation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Prepare_Spawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Prepare_Spawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Prepare_Spawn");

	Params::LActionState_ActionState_Prepare_Spawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_PreventFallingDamage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_PreventFallingDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_PreventFallingDamage");

	Params::LActionState_ActionState_PreventFallingDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Pulse_Rechargeable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Pulse_Rechargeable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Pulse_Rechargeable");

	Params::LActionState_ActionState_Pulse_Rechargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_PushingReposition_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_PushingReposition_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_PushingReposition_Disable");

	Params::LActionState_ActionState_PushingReposition_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_RepairWeapon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_RepairWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_RepairWeapon");

	Params::LActionState_ActionState_RepairWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ReserveInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ReserveInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ReserveInput");

	Params::LActionState_ActionState_ReserveInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ReserveInput_Attack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ReserveInput_Attack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ReserveInput_Attack");

	Params::LActionState_ActionState_ReserveInput_Attack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ReserveInput_Dash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ReserveInput_Dash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ReserveInput_Dash");

	Params::LActionState_ActionState_ReserveInput_Dash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ReserveInput_Special
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ReserveInput_Special()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ReserveInput_Special");

	Params::LActionState_ActionState_ReserveInput_Special Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Resurrection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Resurrection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Resurrection");

	Params::LActionState_ActionState_Resurrection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Resurrection_Used
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Resurrection_Used()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Resurrection_Used");

	Params::LActionState_ActionState_Resurrection_Used Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_RideOnLift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_RideOnLift()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_RideOnLift");

	Params::LActionState_ActionState_RideOnLift Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_RisingAttack_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_RisingAttack_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_RisingAttack_Enable");

	Params::LActionState_ActionState_RisingAttack_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Rootmotion_Velocity_Cap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Rootmotion_Velocity_Cap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Rootmotion_Velocity_Cap");

	Params::LActionState_ActionState_Rootmotion_Velocity_Cap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_SA_NicolaTail_Active
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_SA_NicolaTail_Active()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_SA_NicolaTail_Active");

	Params::LActionState_ActionState_SA_NicolaTail_Active Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_SA_NicolaTail_Counter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_SA_NicolaTail_Counter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_SA_NicolaTail_Counter");

	Params::LActionState_ActionState_SA_NicolaTail_Counter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_SA_PileBunker_Lock
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_SA_PileBunker_Lock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_SA_PileBunker_Lock");

	Params::LActionState_ActionState_SA_PileBunker_Lock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Shotgun_Hold
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Shotgun_Hold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Shotgun_Hold");

	Params::LActionState_ActionState_Shotgun_Hold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Show_Weapon_Forced
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Show_Weapon_Forced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Show_Weapon_Forced");

	Params::LActionState_ActionState_Show_Weapon_Forced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_SlaveArm_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_SlaveArm_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_SlaveArm_Disable");

	Params::LActionState_ActionState_SlaveArm_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Sleep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Sleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Sleep");

	Params::LActionState_ActionState_Sleep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_SpawnIdle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_SpawnIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_SpawnIdle");

	Params::LActionState_ActionState_SpawnIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Sprint_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Sprint_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Sprint_Disable");

	Params::LActionState_ActionState_Sprint_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Sprint_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Sprint_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Sprint_Enable");

	Params::LActionState_ActionState_Sprint_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Always_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Always_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Always_Guard");

	Params::LActionState_ActionState_Stance_Always_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Always_Guard_Off
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Always_Guard_Off()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Always_Guard_Off");

	Params::LActionState_ActionState_Stance_Always_Guard_Off Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Arm_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Arm_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Arm_Guard");

	Params::LActionState_ActionState_Stance_Arm_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Arm_NoStiffen_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Arm_NoStiffen_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Arm_NoStiffen_Guard");

	Params::LActionState_ActionState_Stance_Arm_NoStiffen_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Guard");

	Params::LActionState_ActionState_Stance_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_NoStiffen_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_NoStiffen_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_NoStiffen_Guard");

	Params::LActionState_ActionState_Stance_NoStiffen_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Parrying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Parrying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Parrying");

	Params::LActionState_ActionState_Stance_Parrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Perfect_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Perfect_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Perfect_Guard");

	Params::LActionState_ActionState_Stance_Perfect_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Reflect_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Reflect_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Reflect_Guard");

	Params::LActionState_ActionState_Stance_Reflect_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Stance_BareHand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Stance_BareHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Stance_BareHand");

	Params::LActionState_ActionState_Stance_Stance_BareHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Sword_OneHand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Sword_OneHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Sword_OneHand");

	Params::LActionState_ActionState_Stance_Sword_OneHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Sword_TwoHand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Sword_TwoHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Sword_TwoHand");

	Params::LActionState_ActionState_Stance_Sword_TwoHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Axe
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Axe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Axe");

	Params::LActionState_ActionState_Stance_Weapon_Axe Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Axe2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Axe2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Axe2");

	Params::LActionState_ActionState_Stance_Weapon_Axe2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Blade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Blade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Blade");

	Params::LActionState_ActionState_Stance_Weapon_Blade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Blade2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Blade2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Blade2");

	Params::LActionState_ActionState_Stance_Weapon_Blade2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Spear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Spear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Spear");

	Params::LActionState_ActionState_Stance_Weapon_Spear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Spear2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Spear2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Spear2");

	Params::LActionState_ActionState_Stance_Weapon_Spear2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Sword
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Sword()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Sword");

	Params::LActionState_ActionState_Stance_Weapon_Sword Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Stance_Weapon_Sword2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Stance_Weapon_Sword2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Stance_Weapon_Sword2");

	Params::LActionState_ActionState_Stance_Weapon_Sword2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_StandGuard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_StandGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_StandGuard");

	Params::LActionState_ActionState_StandGuard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_StandGuardEnable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_StandGuardEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_StandGuardEnable");

	Params::LActionState_ActionState_StandGuardEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Start_Rotation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Start_Rotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Start_Rotation");

	Params::LActionState_ActionState_Start_Rotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_StopSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_StopSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_StopSprint");

	Params::LActionState_ActionState_StopSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_SuperArmor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_SuperArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_SuperArmor");

	Params::LActionState_ActionState_SuperArmor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_ToggleWalkMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_ToggleWalkMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_ToggleWalkMode");

	Params::LActionState_ActionState_ToggleWalkMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_TransitAnimation_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_TransitAnimation_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_TransitAnimation_Dead");

	Params::LActionState_ActionState_TransitAnimation_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_TryLockInput_Movement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_TryLockInput_Movement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_TryLockInput_Movement");

	Params::LActionState_ActionState_TryLockInput_Movement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_TryLockInput_Rotation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_TryLockInput_Rotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_TryLockInput_Rotation");

	Params::LActionState_ActionState_TryLockInput_Rotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Tutorial_Walk
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Tutorial_Walk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Tutorial_Walk");

	Params::LActionState_ActionState_Tutorial_Walk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Use_FSM_For_LowerBody
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Use_FSM_For_LowerBody()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Use_FSM_For_LowerBody");

	Params::LActionState_ActionState_Use_FSM_For_LowerBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_UseItem_Disable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_UseItem_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_UseItem_Disable");

	Params::LActionState_ActionState_UseItem_Disable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Victim_Counter_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Victim_Counter_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Victim_Counter_Enable");

	Params::LActionState_ActionState_Victim_Counter_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Weapon_Transform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Weapon_Transform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Weapon_Transform");

	Params::LActionState_ActionState_Weapon_Transform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_EX1
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_WeaponHideByNotify_EX1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_WeaponHideByNotify_EX1");

	Params::LActionState_ActionState_WeaponHideByNotify_EX1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_EX2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_WeaponHideByNotify_EX2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_WeaponHideByNotify_EX2");

	Params::LActionState_ActionState_WeaponHideByNotify_EX2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_EX3
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_WeaponHideByNotify_EX3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_WeaponHideByNotify_EX3");

	Params::LActionState_ActionState_WeaponHideByNotify_EX3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_L
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_WeaponHideByNotify_L()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_WeaponHideByNotify_L");

	Params::LActionState_ActionState_WeaponHideByNotify_L Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_WeaponHideByNotify_R
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_WeaponHideByNotify_R()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_WeaponHideByNotify_R");

	Params::LActionState_ActionState_WeaponHideByNotify_R Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Weight_Advantage_Enable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Weight_Advantage_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Weight_Advantage_Enable");

	Params::LActionState_ActionState_Weight_Advantage_Enable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_WeightPenalty_Decrease_L1_Change
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_WeightPenalty_Decrease_L1_Change()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_WeightPenalty_Decrease_L1_Change");

	Params::LActionState_ActionState_WeightPenalty_Decrease_L1_Change Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionState.ActionState_Zombie
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionState::ActionState_Zombie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionState", "ActionState_Zombie");

	Params::LActionState_ActionState_Zombie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystemData.FindHandBloodMaterial_ForCurrentBody
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UMaterialInstance*                OutMaterial                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALActionSystemData::FindHandBloodMaterial_ForCurrentBody(class UMaterialInstance** OutMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "FindHandBloodMaterial_ForCurrentBody");

	Params::LActionSystemData_FindHandBloodMaterial_ForCurrentBody Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutMaterial != nullptr)
		*OutMaterial = Parms.OutMaterial;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystemData.FindPixelDepthOffsetData_ForCurrentFace
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UTexture*                         OutMask                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutIntensity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALActionSystemData::FindPixelDepthOffsetData_ForCurrentFace(class UTexture** OutMask, float* OutIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "FindPixelDepthOffsetData_ForCurrentFace");

	Params::LActionSystemData_FindPixelDepthOffsetData_ForCurrentFace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutMask != nullptr)
		*OutMask = Parms.OutMask;

	if (OutIntensity != nullptr)
		*OutIntensity = Parms.OutIntensity;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystemData.FindShrinkMesh_ForCurrentBody
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class ALCharacter*                      TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    OutMesh                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALActionSystemData::FindShrinkMesh_ForCurrentBody(class ALCharacter* TargetCharacter, class USkeletalMesh** OutMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "FindShrinkMesh_ForCurrentBody");

	Params::LActionSystemData_FindShrinkMesh_ForCurrentBody Parms{};

	Parms.TargetCharacter = TargetCharacter;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystemData.OnApplyNeedShrink
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALCharacter*                      TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALActionSystemData::OnApplyNeedShrink(class ALCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "OnApplyNeedShrink");

	Params::LActionSystemData_OnApplyNeedShrink Parms{};

	Parms.TargetCharacter = TargetCharacter;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystemData.RemoveFatalLocationIndicator
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFatalAttackInfo                FatalAttackInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   SuccessFatalAttackInfoIndex                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALActionSystemData::RemoveFatalLocationIndicator(class AActor* TargetActor, const struct FLFatalAttackInfo& FatalAttackInfo, int32 SuccessFatalAttackInfoIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "RemoveFatalLocationIndicator");

	Params::LActionSystemData_RemoveFatalLocationIndicator Parms{};

	Parms.TargetActor = TargetActor;
	Parms.FatalAttackInfo = std::move(FatalAttackInfo);
	Parms.SuccessFatalAttackInfoIndex = SuccessFatalAttackInfoIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionSystemData.SetFatalLocationIndicatorState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLFatalIndicatorFxState          IndicatorFx                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALActionSystemData::SetFatalLocationIndicatorState(const struct FLFatalIndicatorFxState& IndicatorFx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "SetFatalLocationIndicatorState");

	Params::LActionSystemData_SetFatalLocationIndicatorState Parms{};

	Parms.IndicatorFx = std::move(IndicatorFx);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionSystemData.SpawnFatalLocationIndicator
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFatalAttackInfo                FatalAttackInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALActionSystemData::SpawnFatalLocationIndicator(class AActor* TargetActor, const struct FLFatalAttackInfo& FatalAttackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "SpawnFatalLocationIndicator");

	Params::LActionSystemData_SpawnFatalLocationIndicator Parms{};

	Parms.TargetActor = TargetActor;
	Parms.FatalAttackInfo = std::move(FatalAttackInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionSystemData.UpdateFatalLocationIndicator
// (Final, Native, Public)

void ALActionSystemData::UpdateFatalLocationIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystemData", "UpdateFatalLocationIndicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionSystem.AddFatalIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionSystem::AddFatalIndicator(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "AddFatalIndicator");

	Params::LActionSystem_AddFatalIndicator Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.OnApplyNeedShrink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionSystem::OnApplyNeedShrink(class ALCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "OnApplyNeedShrink");

	Params::LActionSystem_OnApplyNeedShrink Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.RemoveFatalIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SuccessFatalAttackInfoIndex                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionSystem::RemoveFatalIndicator(class AActor* TargetActor, int32 SuccessFatalAttackInfoIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "RemoveFatalIndicator");

	Params::LActionSystem_RemoveFatalIndicator Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SuccessFatalAttackInfoIndex = SuccessFatalAttackInfoIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionSystem.GetBL_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetBL_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetBL_Start");

	Params::LActionSystem_GetBL_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetBR_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetBR_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetBR_Start");

	Params::LActionSystem_GetBR_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetDash_Back_End
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetDash_Back_End() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetDash_Back_End");

	Params::LActionSystem_GetDash_Back_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetDash_Front_End
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetDash_Front_End() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetDash_Front_End");

	Params::LActionSystem_GetDash_Front_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetDash_Left_End
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetDash_Left_End() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetDash_Left_End");

	Params::LActionSystem_GetDash_Left_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetDash_Right_End
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetDash_Right_End() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetDash_Right_End");

	Params::LActionSystem_GetDash_Right_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetDownRotateTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetDownRotateTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetDownRotateTime");

	Params::LActionSystem_GetDownRotateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetFallingDieVariable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionSystem::GetFallingDieVariable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetFallingDieVariable");

	Params::LActionSystem_GetFallingDieVariable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetFatalTargetPointLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRange                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionSystem::GetFatalTargetPointLocation(int32 Index_0, struct FVector* WorldLocation, bool* InRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetFatalTargetPointLocation");

	Params::LActionSystem_GetFatalTargetPointLocation Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (InRange != nullptr)
		*InRange = Parms.InRange;
}


// Function ProjectP.LActionSystem.GetFL_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetFL_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetFL_Start");

	Params::LActionSystem_GetFL_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetGroggyDamageRatioJustToughZero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetGroggyDamageRatioJustToughZero() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetGroggyDamageRatioJustToughZero");

	Params::LActionSystem_GetGroggyDamageRatioJustToughZero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetGuardEx_CoolTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetGuardEx_CoolTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetGuardEx_CoolTime");

	Params::LActionSystem_GetGuardEx_CoolTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetGuardRegainDamageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetGuardRegainDamageRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetGuardRegainDamageRatio");

	Params::LActionSystem_GetGuardRegainDamageRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetGuardRegainDelayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetGuardRegainDelayTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetGuardRegainDelayTime");

	Params::LActionSystem_GetGuardRegainDelayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetGuardRegainHealRatioParrying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetGuardRegainHealRatioParrying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetGuardRegainHealRatioParrying");

	Params::LActionSystem_GetGuardRegainHealRatioParrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetGuardRegainRecoveryRatioGuarding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionSystem::GetGuardRegainRecoveryRatioGuarding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetGuardRegainRecoveryRatioGuarding");

	Params::LActionSystem_GetGuardRegainRecoveryRatioGuarding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetHit_Intencity_Down
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetHit_Intencity_Down() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetHit_Intencity_Down");

	Params::LActionSystem_GetHit_Intencity_Down Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetHit_Intencity_KnockBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetHit_Intencity_KnockBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetHit_Intencity_KnockBack");

	Params::LActionSystem_GetHit_Intencity_KnockBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetHitRotateTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetHitRotateTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetHitRotateTime");

	Params::LActionSystem_GetHitRotateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetJustRepairDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetJustRepairDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetJustRepairDuration");

	Params::LActionSystem_GetJustRepairDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetJustRepairSharpnessRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetJustRepairSharpnessRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetJustRepairSharpnessRatio");

	Params::LActionSystem_GetJustRepairSharpnessRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetKnockbackRotateTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetKnockbackRotateTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetKnockbackRotateTime");

	Params::LActionSystem_GetKnockbackRotateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetLB_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetLB_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetLB_Start");

	Params::LActionSystem_GetLB_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetLF_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetLF_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetLF_Start");

	Params::LActionSystem_GetLF_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetOnGuardHit_RetainTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetOnGuardHit_RetainTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetOnGuardHit_RetainTime");

	Params::LActionSystem_GetOnGuardHit_RetainTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetPerfectGuard_HitDurationRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetPerfectGuard_HitDurationRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetPerfectGuard_HitDurationRatio");

	Params::LActionSystem_GetPerfectGuard_HitDurationRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetPerfectGuard_KnockbackDistanceRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetPerfectGuard_KnockbackDistanceRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetPerfectGuard_KnockbackDistanceRatio");

	Params::LActionSystem_GetPerfectGuard_KnockbackDistanceRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetPerfectGuard_KnockbackDurationRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetPerfectGuard_KnockbackDurationRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetPerfectGuard_KnockbackDurationRatio");

	Params::LActionSystem_GetPerfectGuard_KnockbackDurationRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetPerfectGuard_ReduceRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetPerfectGuard_ReduceRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetPerfectGuard_ReduceRate");

	Params::LActionSystem_GetPerfectGuard_ReduceRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetPerfectGuard_Stamina_ReduceRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetPerfectGuard_Stamina_ReduceRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetPerfectGuard_Stamina_ReduceRate");

	Params::LActionSystem_GetPerfectGuard_Stamina_ReduceRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetRagdollFreezeTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetRagdollFreezeTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetRagdollFreezeTime");

	Params::LActionSystem_GetRagdollFreezeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetRagdollInteractionTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetRagdollInteractionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetRagdollInteractionTime");

	Params::LActionSystem_GetRagdollInteractionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetRB_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetRB_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetRB_Start");

	Params::LActionSystem_GetRB_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetRF_Start
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetRF_Start() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetRF_Start");

	Params::LActionSystem_GetRF_Start Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetRgidityRatioPerfectGuard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetRgidityRatioPerfectGuard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetRgidityRatioPerfectGuard");

	Params::LActionSystem_GetRgidityRatioPerfectGuard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetRigidityConstant
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetRigidityConstant() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetRigidityConstant");

	Params::LActionSystem_GetRigidityConstant Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetSparkFxInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetSparkFxInterval() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetSparkFxInterval");

	Params::LActionSystem_GetSparkFxInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetSparkSFxInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetSparkSFxInterval() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetSparkSFxInterval");

	Params::LActionSystem_GetSparkSFxInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetStiffen_Duration_PerfectGuard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetStiffen_Duration_PerfectGuard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetStiffen_Duration_PerfectGuard");

	Params::LActionSystem_GetStiffen_Duration_PerfectGuard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetStiffen_PlayRate_PerfectGuard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetStiffen_PlayRate_PerfectGuard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetStiffen_PlayRate_PerfectGuard");

	Params::LActionSystem_GetStiffen_PlayRate_PerfectGuard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetStiffenDelayDefender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetStiffenDelayDefender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetStiffenDelayDefender");

	Params::LActionSystem_GetStiffenDelayDefender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetStopAfterSprintTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetStopAfterSprintTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetStopAfterSprintTime");

	Params::LActionSystem_GetStopAfterSprintTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetWeaponMaxSharpnessReduceRatio_By_Grinding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetWeaponMaxSharpnessReduceRatio_By_Grinding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetWeaponMaxSharpnessReduceRatio_By_Grinding");

	Params::LActionSystem_GetWeaponMaxSharpnessReduceRatio_By_Grinding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionSystem.GetWeaponSharpnessReduceMultiplier_By_Grinding_count
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionSystem::GetWeaponSharpnessReduceMultiplier_By_Grinding_count() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActionSystem", "GetWeaponSharpnessReduceMultiplier_By_Grinding_count");

	Params::LActionSystem_GetWeaponSharpnessReduceMultiplier_By_Grinding_count Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.AddInputActionKeyMapping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionKeyMapping           Mapping                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::AddInputActionKeyMapping(class FName InputAction, const struct FInputActionKeyMapping& Mapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "AddInputActionKeyMapping");

	Params::LActionUtilFuncLibrary_AddInputActionKeyMapping Parms{};

	Parms.InputAction = InputAction;
	Parms.Mapping = std::move(Mapping);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.AddInputAxisKeyMapping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputAxisKeyMapping             Mapping                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::AddInputAxisKeyMapping(class FName InputAction, const struct FInputAxisKeyMapping& Mapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "AddInputAxisKeyMapping");

	Params::LActionUtilFuncLibrary_AddInputAxisKeyMapping Parms{};

	Parms.InputAction = InputAction;
	Parms.Mapping = std::move(Mapping);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CalcHitAngleBP
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          OutHitOrigin                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionUtilFuncLibrary::CalcHitAngleBP(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, struct FVector* OutHitOrigin, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CalcHitAngleBP");

	Params::LActionUtilFuncLibrary_CalcHitAngleBP Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitOrigin != nullptr)
		*OutHitOrigin = std::move(Parms.OutHitOrigin);

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CalcParabolicMoveVelocity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULActionUtilFuncLibrary::CalcParabolicMoveVelocity(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, float Gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CalcParabolicMoveVelocity");

	Params::LActionUtilFuncLibrary_CalcParabolicMoveVelocity Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.Duration = Duration;
	Parms.Gravity = Gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangeCollisionState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCollisionState                        CollisionState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::ChangeCollisionState(class AActor* TargetActor, ELCollisionState CollisionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangeCollisionState");

	Params::LActionUtilFuncLibrary_ChangeCollisionState Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CollisionState = CollisionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangeFloatingState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyCeiling                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::ChangeFloatingState(class AActor* TargetActor, bool bEnable, bool bApplyCeiling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangeFloatingState");

	Params::LActionUtilFuncLibrary_ChangeFloatingState Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bEnable = bEnable;
	Parms.bApplyCeiling = bApplyCeiling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangeHairCategoryType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELHairCategoryType                      HairCategoryType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::ChangeHairCategoryType(ELHairCategoryType HairCategoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangeHairCategoryType");

	Params::LActionUtilFuncLibrary_ChangeHairCategoryType Parms{};

	Parms.HairCategoryType = HairCategoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangeInputPreset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             PresetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::ChangeInputPreset(class FName PresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangeInputPreset");

	Params::LActionUtilFuncLibrary_ChangeInputPreset Parms{};

	Parms.PresetName = PresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangePerBodyCollisionProfile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TurnOffOverlapBody                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TurnOffSecondaryBody                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CollisionProfile_ChangeTarget                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CollisionProfile_Other                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutCount_AllBody                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutCount_ChangeByOverlap                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutCount_ChangedBySecondary                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::ChangePerBodyCollisionProfile(class AActor* TargetActor, bool TurnOffOverlapBody, bool TurnOffSecondaryBody, const class FName CollisionProfile_ChangeTarget, const class FName CollisionProfile_Other, int32* OutCount_AllBody, int32* OutCount_ChangeByOverlap, int32* OutCount_ChangedBySecondary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangePerBodyCollisionProfile");

	Params::LActionUtilFuncLibrary_ChangePerBodyCollisionProfile Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TurnOffOverlapBody = TurnOffOverlapBody;
	Parms.TurnOffSecondaryBody = TurnOffSecondaryBody;
	Parms.CollisionProfile_ChangeTarget = CollisionProfile_ChangeTarget;
	Parms.CollisionProfile_Other = CollisionProfile_Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCount_AllBody != nullptr)
		*OutCount_AllBody = Parms.OutCount_AllBody;

	if (OutCount_ChangeByOverlap != nullptr)
		*OutCount_ChangeByOverlap = Parms.OutCount_ChangeByOverlap;

	if (OutCount_ChangedBySecondary != nullptr)
		*OutCount_ChangedBySecondary = Parms.OutCount_ChangedBySecondary;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangeWeaponAnimState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AnimState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionUtilFuncLibrary::ChangeWeaponAnimState(class AActor* Actor, ELWeaponAttachPointType AttachPointType, ELWeaponPartType PartType, class FName AnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangeWeaponAnimState");

	Params::LActionUtilFuncLibrary_ChangeWeaponAnimState Parms{};

	Parms.Actor = Actor;
	Parms.AttachPointType = AttachPointType;
	Parms.PartType = PartType;
	Parms.AnimState = AnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ChangeWeaponAnimStateWithPickedIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PickedIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AnimState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::ChangeWeaponAnimStateWithPickedIndex(class AActor* Actor, int32 PickedIndex, ELWeaponPartType PartType, class FName AnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ChangeWeaponAnimStateWithPickedIndex");

	Params::LActionUtilFuncLibrary_ChangeWeaponAnimStateWithPickedIndex Parms{};

	Parms.Actor = Actor;
	Parms.PickedIndex = PickedIndex;
	Parms.PartType = PartType;
	Parms.AnimState = AnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.CheatFalling
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::CheatFalling(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheatFalling");

	Params::LActionUtilFuncLibrary_CheatFalling Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.CheatFly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::CheatFly(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheatFly");

	Params::LActionUtilFuncLibrary_CheatFly Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.CheatGhost
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::CheatGhost(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheatGhost");

	Params::LActionUtilFuncLibrary_CheatGhost Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.CheatWalk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::CheatWalk(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheatWalk");

	Params::LActionUtilFuncLibrary_CheatWalk Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.CheckAlwaysGuard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::CheckAlwaysGuard(class AActor* Attacker, class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheckAlwaysGuard");

	Params::LActionUtilFuncLibrary_CheckAlwaysGuard Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CheckCollisionOwnerTypeBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              CollisionComponent                                     (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCollisionOwnerType                    CheckType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::CheckCollisionOwnerTypeBP(const class UPrimitiveComponent* CollisionComponent, ELCollisionOwnerType CheckType, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheckCollisionOwnerTypeBP");

	Params::LActionUtilFuncLibrary_CheckCollisionOwnerTypeBP Parms{};

	Parms.CollisionComponent = CollisionComponent;
	Parms.CheckType = CheckType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CheckFatalAttackConditionsBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           CheckTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFatalAttackInfo                CheckFatalAttackInfo                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    AllowFatalTrailMargin                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::CheckFatalAttackConditionsBP(class AActor* CheckTarget, const struct FLFatalAttackInfo& CheckFatalAttackInfo, bool AllowFatalTrailMargin, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheckFatalAttackConditionsBP");

	Params::LActionUtilFuncLibrary_CheckFatalAttackConditionsBP Parms{};

	Parms.CheckTarget = CheckTarget;
	Parms.CheckFatalAttackInfo = std::move(CheckFatalAttackInfo);
	Parms.AllowFatalTrailMargin = AllowFatalTrailMargin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CheckGrabBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::CheckGrabBP(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheckGrabBP");

	Params::LActionUtilFuncLibrary_CheckGrabBP Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CheckObstacleOnPathBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              CheckTargetComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PathArray                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult ULActionUtilFuncLibrary::CheckObstacleOnPathBP(class UPrimitiveComponent* CheckTargetComponent, const TArray<struct FVector>& PathArray, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CheckObstacleOnPathBP");

	Params::LActionUtilFuncLibrary_CheckObstacleOnPathBP Parms{};

	Parms.CheckTargetComponent = CheckTargetComponent;
	Parms.PathArray = std::move(PathArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.CollectLCharacterInRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TestOrigin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALCharacter*>              IgnoredCharacterArray                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ALCharacter*>              OutCollectedCharacterArray                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionUtilFuncLibrary::CollectLCharacterInRange(const struct FVector& TestOrigin, const float Range, const TArray<class ALCharacter*>& IgnoredCharacterArray, TArray<class ALCharacter*>* OutCollectedCharacterArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "CollectLCharacterInRange");

	Params::LActionUtilFuncLibrary_CollectLCharacterInRange Parms{};

	Parms.TestOrigin = std::move(TestOrigin);
	Parms.Range = Range;
	Parms.IgnoredCharacterArray = std::move(IgnoredCharacterArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCollectedCharacterArray != nullptr)
		*OutCollectedCharacterArray = std::move(Parms.OutCollectedCharacterArray);

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ComputeFatalOffsetRotationBP
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CheckTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULActionUtilFuncLibrary::ComputeFatalOffsetRotationBP(class AActor* CheckTarget, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ComputeFatalOffsetRotationBP");

	Params::LActionUtilFuncLibrary_ComputeFatalOffsetRotationBP Parms{};

	Parms.CheckTarget = CheckTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ConvertToActionKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InActionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPCActionKeyType ULActionUtilFuncLibrary::ConvertToActionKey(const class FString& InActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ConvertToActionKey");

	Params::LActionUtilFuncLibrary_ConvertToActionKey Parms{};

	Parms.InActionName = std::move(InActionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ConvertToActionKeyString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELPCActionKeyType                       InActionKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULActionUtilFuncLibrary::ConvertToActionKeyString(ELPCActionKeyType InActionKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ConvertToActionKeyString");

	Params::LActionUtilFuncLibrary_ConvertToActionKeyString Parms{};

	Parms.InActionKey = InActionKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DecreaseWeaponDestructDurability
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DurabilityAmount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BreakDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVictimGuard                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayHitAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutPlayActionClassCodeName                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::DecreaseWeaponDestructDurability(class AActor* Attacker, class AActor* Victim, int32 DurabilityAmount, const struct FVector& BreakDirection, bool bVictimGuard, bool bPlayHitAction, class FName* OutPlayActionClassCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DecreaseWeaponDestructDurability");

	Params::LActionUtilFuncLibrary_DecreaseWeaponDestructDurability Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.DurabilityAmount = DurabilityAmount;
	Parms.BreakDirection = std::move(BreakDirection);
	Parms.bVictimGuard = bVictimGuard;
	Parms.bPlayHitAction = bPlayHitAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPlayActionClassCodeName != nullptr)
		*OutPlayActionClassCodeName = Parms.OutPlayActionClassCodeName;
}


// Function ProjectP.LActionUtilFuncLibrary.DoChangeCharBlockType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCharacterCollisionType                CharacterCollisionType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseStack                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoChangeCharBlockType(class AActor* TargetActor, ELCharacterCollisionType CharacterCollisionType, bool UseStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoChangeCharBlockType");

	Params::LActionUtilFuncLibrary_DoChangeCharBlockType Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CharacterCollisionType = CharacterCollisionType;
	Parms.UseStack = UseStack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoChangeWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SelectPrevious                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoChangeWeapon(class AActor* TargetActor, bool SelectPrevious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoChangeWeapon");

	Params::LActionUtilFuncLibrary_DoChangeWeapon Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SelectPrevious = SelectPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoCharacterKillZone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCustomDieUIShowTime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DieUI_StartDelay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoExecuteSequence                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::DoCharacterKillZone(class AActor* Actor, bool bUseCustomDieUIShowTime, float DieUI_StartDelay, bool bDoExecuteSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoCharacterKillZone");

	Params::LActionUtilFuncLibrary_DoCharacterKillZone Parms{};

	Parms.Actor = Actor;
	Parms.bUseCustomDieUIShowTime = bUseCustomDieUIShowTime;
	Parms.DieUI_StartDelay = DieUI_StartDelay;
	Parms.bDoExecuteSequence = bDoExecuteSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.DoGrabBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoGrabBP(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoGrabBP");

	Params::LActionUtilFuncLibrary_DoGrabBP Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoGrabReleaseBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGrabReleaseInfo                GrabReleaseInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoGrabReleaseBP(class AActor* TargetActor, const struct FLGrabReleaseInfo& GrabReleaseInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoGrabReleaseBP");

	Params::LActionUtilFuncLibrary_DoGrabReleaseBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.GrabReleaseInfo = std::move(GrabReleaseInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoHideBone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoHideBone(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName, bool Hide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoHideBone");

	Params::LActionUtilFuncLibrary_DoHideBone Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.BoneName = BoneName;
	Parms.Hide = Hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoIdleMove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCalledFromNotify                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoIdleMove(class AActor* TargetActor, bool bCalledFromNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoIdleMove");

	Params::LActionUtilFuncLibrary_DoIdleMove Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bCalledFromNotify = bCalledFromNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoNPCSuicide
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELNPCSuicideType                        SuicideType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DeadCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bItemGet                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExpGet                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseOverrideRespawnState                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRespawnEnable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayDeadSound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::DoNPCSuicide(class AActor* Actor, ELNPCSuicideType SuicideType, class FName DeadCodeName, bool bItemGet, bool bExpGet, bool bUseOverrideRespawnState, bool bRespawnEnable, bool bPlayDeadSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoNPCSuicide");

	Params::LActionUtilFuncLibrary_DoNPCSuicide Parms{};

	Parms.Actor = Actor;
	Parms.SuicideType = SuicideType;
	Parms.DeadCodeName = DeadCodeName;
	Parms.bItemGet = bItemGet;
	Parms.bExpGet = bExpGet;
	Parms.bUseOverrideRespawnState = bUseOverrideRespawnState;
	Parms.bRespawnEnable = bRespawnEnable;
	Parms.bPlayDeadSound = bPlayDeadSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.DoRespawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoRespawn(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoRespawn");

	Params::LActionUtilFuncLibrary_DoRespawn Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoWeaponOffBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoWeaponOffBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoWeaponOffBP");

	Params::LActionUtilFuncLibrary_DoWeaponOffBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.DoWeaponOnBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::DoWeaponOnBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "DoWeaponOnBP");

	Params::LActionUtilFuncLibrary_DoWeaponOnBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ExtractMontageBoneTransformBP
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExtractRootmotion                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ULActionUtilFuncLibrary::ExtractMontageBoneTransformBP(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage, const class FName BoneName, const float Position, bool ExtractRootmotion, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ExtractMontageBoneTransformBP");

	Params::LActionUtilFuncLibrary_ExtractMontageBoneTransformBP Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.AnimMontage = AnimMontage;
	Parms.BoneName = BoneName;
	Parms.Position = Position;
	Parms.ExtractRootmotion = ExtractRootmotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ExtractRootMotionFromTrackRangeBP
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartPosition                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndPosition                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ULActionUtilFuncLibrary::ExtractRootMotionFromTrackRangeBP(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage, const float StartPosition, const float EndPosition, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ExtractRootMotionFromTrackRangeBP");

	Params::LActionUtilFuncLibrary_ExtractRootMotionFromTrackRangeBP Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.AnimMontage = AnimMontage;
	Parms.StartPosition = StartPosition;
	Parms.EndPosition = EndPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindActionKeyInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Alt                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ctrl                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Shift                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Cmd                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULActionUtilFuncLibrary::FindActionKeyInputAction(const struct FKey& Key, bool Alt, bool Ctrl, bool Shift, bool Cmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindActionKeyInputAction");

	Params::LActionUtilFuncLibrary_FindActionKeyInputAction Parms{};

	Parms.Key = std::move(Key);
	Parms.Alt = Alt;
	Parms.Ctrl = Ctrl;
	Parms.Shift = Shift;
	Parms.Cmd = Cmd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindActionState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::FindActionState(class AActor* Actor, class FName ActionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindActionState");

	Params::LActionUtilFuncLibrary_FindActionState Parms{};

	Parms.Actor = Actor;
	Parms.ActionState = ActionState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindActiveFxSocketTracerInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFxSocketTracerInfo             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLFxSocketTracerInfo ULActionUtilFuncLibrary::FindActiveFxSocketTracerInfo(class AActor* TargetActor, const struct FLGameObjectHandle& Handle, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindActiveFxSocketTracerInfo");

	Params::LActionUtilFuncLibrary_FindActiveFxSocketTracerInfo Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindAxisKeyInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Alt                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ctrl                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Shift                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Cmd                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULActionUtilFuncLibrary::FindAxisKeyInputAction(const struct FKey& Key, bool Alt, bool Ctrl, bool Shift, bool Cmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindAxisKeyInputAction");

	Params::LActionUtilFuncLibrary_FindAxisKeyInputAction Parms{};

	Parms.Key = std::move(Key);
	Parms.Alt = Alt;
	Parms.Ctrl = Ctrl;
	Parms.Shift = Shift;
	Parms.Cmd = Cmd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindEquippedItemSlaveArmInfoBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemSlaveArmInfoPtr             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemSlaveArmInfoPtr ULActionUtilFuncLibrary::FindEquippedItemSlaveArmInfoBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindEquippedItemSlaveArmInfoBP");

	Params::LActionUtilFuncLibrary_FindEquippedItemSlaveArmInfoBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindFatalAttackTargetBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFatalAttackInfo                OutFatalAttackInfo                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULActionUtilFuncLibrary::FindFatalAttackTargetBP(class AActor* Attacker, struct FLFatalAttackInfo* OutFatalAttackInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindFatalAttackTargetBP");

	Params::LActionUtilFuncLibrary_FindFatalAttackTargetBP Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFatalAttackInfo != nullptr)
		*OutFatalAttackInfo = std::move(Parms.OutFatalAttackInfo);

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindHandBloodMaterial_ForCurrentBodyBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                OutMaterial                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::FindHandBloodMaterial_ForCurrentBodyBP(class UMaterialInstance** OutMaterial, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindHandBloodMaterial_ForCurrentBodyBP");

	Params::LActionUtilFuncLibrary_FindHandBloodMaterial_ForCurrentBodyBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMaterial != nullptr)
		*OutMaterial = Parms.OutMaterial;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LActionUtilFuncLibrary.FindHitIndexInfoBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HitIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitIndexInfoPtr                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FHitIndexInfoPtr ULActionUtilFuncLibrary::FindHitIndexInfoBP(class FName SkillCodeName, int32 HitIndex, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindHitIndexInfoBP");

	Params::LActionUtilFuncLibrary_FindHitIndexInfoBP Parms{};

	Parms.SkillCodeName = SkillCodeName;
	Parms.HitIndex = HitIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindHitMotionReplaceInfoBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             HitMotionReplaceGroupCodeName                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitMotionType                         OriginHitMotionType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitMotionReplaceInfoPtr         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FHitMotionReplaceInfoPtr ULActionUtilFuncLibrary::FindHitMotionReplaceInfoBP(class FName HitMotionReplaceGroupCodeName, ELHitMotionType OriginHitMotionType, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindHitMotionReplaceInfoBP");

	Params::LActionUtilFuncLibrary_FindHitMotionReplaceInfoBP Parms{};

	Parms.HitMotionReplaceGroupCodeName = HitMotionReplaceGroupCodeName;
	Parms.OriginHitMotionType = OriginHitMotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindNoneLockOnAutoGuideTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULActionUtilFuncLibrary::FindNoneLockOnAutoGuideTarget(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindNoneLockOnAutoGuideTarget");

	Params::LActionUtilFuncLibrary_FindNoneLockOnAutoGuideTarget Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindPartsActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PartsIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALPartsActor*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALPartsActor* ULActionUtilFuncLibrary::FindPartsActor(class AActor* Actor, int32 PartsIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindPartsActor");

	Params::LActionUtilFuncLibrary_FindPartsActor Parms{};

	Parms.Actor = Actor;
	Parms.PartsIndex = PartsIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindPartsComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PartsIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULActionUtilFuncLibrary::FindPartsComponent(class AActor* Actor, int32 PartsIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindPartsComponent");

	Params::LActionUtilFuncLibrary_FindPartsComponent Parms{};

	Parms.Actor = Actor;
	Parms.PartsIndex = PartsIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindPixelDepthOffsetData_ForCurrentFaceBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTexture*                         OutMask                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutIntensity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::FindPixelDepthOffsetData_ForCurrentFaceBP(class UTexture** OutMask, float* OutIntensity, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindPixelDepthOffsetData_ForCurrentFaceBP");

	Params::LActionUtilFuncLibrary_FindPixelDepthOffsetData_ForCurrentFaceBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMask != nullptr)
		*OutMask = Parms.OutMask;

	if (OutIntensity != nullptr)
		*OutIntensity = Parms.OutIntensity;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LActionUtilFuncLibrary.FindPresetInputAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InPresetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPCActionKeyType ULActionUtilFuncLibrary::FindPresetInputAction(class FName InPresetName, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindPresetInputAction");

	Params::LActionUtilFuncLibrary_FindPresetInputAction Parms{};

	Parms.InPresetName = InPresetName;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindPresetInputActionKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InPresetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       KeyType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey ULActionUtilFuncLibrary::FindPresetInputActionKey(class FName InPresetName, ELPCActionKeyType KeyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindPresetInputActionKey");

	Params::LActionUtilFuncLibrary_FindPresetInputActionKey Parms{};

	Parms.InPresetName = InPresetName;
	Parms.KeyType = KeyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindShrinkMesh_ForCurrentBodyBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALCharacter*                      TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    OutMesh                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::FindShrinkMesh_ForCurrentBodyBP(class ALCharacter* TargetCharacter, class USkeletalMesh** OutMesh, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindShrinkMesh_ForCurrentBodyBP");

	Params::LActionUtilFuncLibrary_FindShrinkMesh_ForCurrentBodyBP Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LActionUtilFuncLibrary.FindSocketOwnerComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     MeshSelectionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ULActionUtilFuncLibrary::FindSocketOwnerComponent(class AActor* TargetActor, class FName SocketName, ELMeshSelectionType MeshSelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindSocketOwnerComponent");

	Params::LActionUtilFuncLibrary_FindSocketOwnerComponent Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SocketName = SocketName;
	Parms.MeshSelectionType = MeshSelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.FindWeaponDestructDurability
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 WeaponAttachPoint                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLWeaponDestructDurabilityEnable WeaponDestructDurabilityEnable_0                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::FindWeaponDestructDurability(class AActor* Actor, ELWeaponAttachPointType WeaponAttachPoint, struct FLWeaponDestructDurabilityEnable* WeaponDestructDurabilityEnable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "FindWeaponDestructDurability");

	Params::LActionUtilFuncLibrary_FindWeaponDestructDurability Parms{};

	Parms.Actor = Actor;
	Parms.WeaponAttachPoint = WeaponAttachPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WeaponDestructDurabilityEnable_0 != nullptr)
		*WeaponDestructDurabilityEnable_0 = std::move(Parms.WeaponDestructDurabilityEnable_0);

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetActionClassCodeNameBySkillHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetActionClassCodeNameBySkillHit(class AActor* Victim, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetActionClassCodeNameBySkillHit");

	Params::LActionUtilFuncLibrary_GetActionClassCodeNameBySkillHit Parms{};

	Parms.Victim = Victim;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetActiveSlaveArmItemBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULActionUtilFuncLibrary::GetActiveSlaveArmItemBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetActiveSlaveArmItemBP");

	Params::LActionUtilFuncLibrary_GetActiveSlaveArmItemBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetActiveSlaveArmSkillCodeNameBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetActiveSlaveArmSkillCodeNameBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetActiveSlaveArmSkillCodeNameBP");

	Params::LActionUtilFuncLibrary_GetActiveSlaveArmSkillCodeNameBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetActiveUseItemSkillCodeNameBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULActPayloadBase*                 InOptionalPayloadItem                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetActiveUseItemSkillCodeNameBP(class ULActPayloadBase* InOptionalPayloadItem, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetActiveUseItemSkillCodeNameBP");

	Params::LActionUtilFuncLibrary_GetActiveUseItemSkillCodeNameBP Parms{};

	Parms.InOptionalPayloadItem = InOptionalPayloadItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetActMgrComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActMgrComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActMgrComponent* ULActionUtilFuncLibrary::GetActMgrComponent(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetActMgrComponent");

	Params::LActionUtilFuncLibrary_GetActMgrComponent Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetActMgrComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActMgrComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActMgrComponent* ULActionUtilFuncLibrary::GetActMgrComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetActMgrComponentBP");

	Params::LActionUtilFuncLibrary_GetActMgrComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetAssistUseItemSkillCodeNameBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELAssistUseItemSlotType                 InSlotType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetAssistUseItemSkillCodeNameBP(ELAssistUseItemSlotType InSlotType, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetAssistUseItemSkillCodeNameBP");

	Params::LActionUtilFuncLibrary_GetAssistUseItemSkillCodeNameBP Parms{};

	Parms.InSlotType = InSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetBodyWeaponByAttachPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPartsAttachPointType                  AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULActionUtilFuncLibrary::GetBodyWeaponByAttachPoint(class AActor* TargetActor, ELPartsAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetBodyWeaponByAttachPoint");

	Params::LActionUtilFuncLibrary_GetBodyWeaponByAttachPoint Parms{};

	Parms.TargetActor = TargetActor;
	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetBodyWeaponBySkillHit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULActionUtilFuncLibrary::GetBodyWeaponBySkillHit(class AActor* TargetActor, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetBodyWeaponBySkillHit");

	Params::LActionUtilFuncLibrary_GetBodyWeaponBySkillHit Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCommandConsumed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::GetCommandConsumed(class FName Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCommandConsumed");

	Params::LActionUtilFuncLibrary_GetCommandConsumed Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCommandRaisedTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionUtilFuncLibrary::GetCommandRaisedTime(class FName Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCommandRaisedTime");

	Params::LActionUtilFuncLibrary_GetCommandRaisedTime Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCommonAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetCommonAnim(class AActor* TargetActor, class FName CommonCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCommonAnim");

	Params::LActionUtilFuncLibrary_GetCommonAnim Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CommonCodeName = CommonCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCommonAnimBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetCommonAnimBP(class AActor* TargetActor, class FName CommonCodeName, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCommonAnimBP");

	Params::LActionUtilFuncLibrary_GetCommonAnimBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CommonCodeName = CommonCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCommonAnimExBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutOverrideMontageBlendIn                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetCommonAnimExBP(class AActor* TargetActor, class FName CommonCodeName, float* OutOverrideMontageBlendIn, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCommonAnimExBP");

	Params::LActionUtilFuncLibrary_GetCommonAnimExBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CommonCodeName = CommonCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverrideMontageBlendIn != nullptr)
		*OutOverrideMontageBlendIn = Parms.OutOverrideMontageBlendIn;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCurrentActionCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExceptHitAction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELActionCategory                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELActionCategory ULActionUtilFuncLibrary::GetCurrentActionCategory(class AActor* TargetActor, bool ExceptHitAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCurrentActionCategory");

	Params::LActionUtilFuncLibrary_GetCurrentActionCategory Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ExceptHitAction = ExceptHitAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCurrentGrabResultBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGrabResultInfo                 OutGrabResultInfo                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::GetCurrentGrabResultBP(class AActor* TargetActor, struct FLGrabResultInfo* OutGrabResultInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCurrentGrabResultBP");

	Params::LActionUtilFuncLibrary_GetCurrentGrabResultBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGrabResultInfo != nullptr)
		*OutGrabResultInfo = std::move(Parms.OutGrabResultInfo);

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCurrentPresetInputAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPCActionKeyType ULActionUtilFuncLibrary::GetCurrentPresetInputAction(bool IsGamePad, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCurrentPresetInputAction");

	Params::LActionUtilFuncLibrary_GetCurrentPresetInputAction Parms{};

	Parms.IsGamePad = IsGamePad;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetCurrentPresetInputActionKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       KeyType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey ULActionUtilFuncLibrary::GetCurrentPresetInputActionKey(bool IsGamePad, ELPCActionKeyType KeyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetCurrentPresetInputActionKey");

	Params::LActionUtilFuncLibrary_GetCurrentPresetInputActionKey Parms{};

	Parms.IsGamePad = IsGamePad;
	Parms.KeyType = KeyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetDeathInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULReasonForDeathInfo*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULReasonForDeathInfo* ULActionUtilFuncLibrary::GetDeathInfo(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetDeathInfo");

	Params::LActionUtilFuncLibrary_GetDeathInfo Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetDebuffResistStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELAbnormalAbstateClass                  InAbnormalAbstateClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELSecondStat ULActionUtilFuncLibrary::GetDebuffResistStat(ELAbnormalAbstateClass InAbnormalAbstateClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetDebuffResistStat");

	Params::LActionUtilFuncLibrary_GetDebuffResistStat Parms{};

	Parms.InAbnormalAbstateClass = InAbnormalAbstateClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetDieAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULReasonForDeathInfo*             ReasonInfo                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetDieAnim(class AActor* TargetActor, const class ULReasonForDeathInfo* ReasonInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetDieAnim");

	Params::LActionUtilFuncLibrary_GetDieAnim Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ReasonInfo = ReasonInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetDieAnimEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULReasonForDeathInfo*             ReasonInfo                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutOverrideMontageBlendIn                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetDieAnimEx(class AActor* TargetActor, const class ULReasonForDeathInfo* ReasonInfo, float* OutOverrideMontageBlendIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetDieAnimEx");

	Params::LActionUtilFuncLibrary_GetDieAnimEx Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ReasonInfo = ReasonInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverrideMontageBlendIn != nullptr)
		*OutOverrideMontageBlendIn = Parms.OutOverrideMontageBlendIn;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetElementalStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELElementDamageType                     ElementalType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELDamageBranchType                      ElementalStatType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELSecondStat ULActionUtilFuncLibrary::GetElementalStat(ELElementDamageType ElementalType, ELDamageBranchType ElementalStatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetElementalStat");

	Params::LActionUtilFuncLibrary_GetElementalStat Parms{};

	Parms.ElementalType = ElementalType;
	Parms.ElementalStatType = ElementalStatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetEndCommonAnimBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetEndCommonAnimBP(class AActor* TargetActor, class FName CommonCodeName, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetEndCommonAnimBP");

	Params::LActionUtilFuncLibrary_GetEndCommonAnimBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CommonCodeName = CommonCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetFallingAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetFallingAnim(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetFallingAnim");

	Params::LActionUtilFuncLibrary_GetFallingAnim Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetFallingAnimEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutOverrideMontageBlendIn                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetFallingAnimEx(class AActor* TargetActor, float* OutOverrideMontageBlendIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetFallingAnimEx");

	Params::LActionUtilFuncLibrary_GetFallingAnimEx Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverrideMontageBlendIn != nullptr)
		*OutOverrideMontageBlendIn = Parms.OutOverrideMontageBlendIn;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetGrabAttackerBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULActionUtilFuncLibrary::GetGrabAttackerBP(class AActor* Victim, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetGrabAttackerBP");

	Params::LActionUtilFuncLibrary_GetGrabAttackerBP Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetGrabVictimBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULActionUtilFuncLibrary::GetGrabVictimBP(class AActor* Attacker, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetGrabVictimBP");

	Params::LActionUtilFuncLibrary_GetGrabVictimBP Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetHairCategoryType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELHairCategoryType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELHairCategoryType ULActionUtilFuncLibrary::GetHairCategoryType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetHairCategoryType");

	Params::LActionUtilFuncLibrary_GetHairCategoryType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetHitProcComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULHitProcComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULHitProcComponent* ULActionUtilFuncLibrary::GetHitProcComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetHitProcComponentBP");

	Params::LActionUtilFuncLibrary_GetHitProcComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetInputKeyForAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Gamepad                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> ULActionUtilFuncLibrary::GetInputKeyForAction(class FName InputAction, bool Gamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetInputKeyForAction");

	Params::LActionUtilFuncLibrary_GetInputKeyForAction Parms{};

	Parms.InputAction = InputAction;
	Parms.Gamepad = Gamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetInputKeyForAxis
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Gamepad                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> ULActionUtilFuncLibrary::GetInputKeyForAxis(class FName InputAction, bool Gamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetInputKeyForAxis");

	Params::LActionUtilFuncLibrary_GetInputKeyForAxis Parms{};

	Parms.InputAction = InputAction;
	Parms.Gamepad = Gamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetLandingAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetLandingAnim(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetLandingAnim");

	Params::LActionUtilFuncLibrary_GetLandingAnim Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetLandingAnimEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutOverrideMontageBlendIn                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULActionUtilFuncLibrary::GetLandingAnimEx(class AActor* TargetActor, float* OutOverrideMontageBlendIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetLandingAnimEx");

	Params::LActionUtilFuncLibrary_GetLandingAnimEx Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverrideMontageBlendIn != nullptr)
		*OutOverrideMontageBlendIn = Parms.OutOverrideMontageBlendIn;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetLastPlayingAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExceptHitAction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActionUtilFuncLibrary::GetLastPlayingAction(class AActor* TargetActor, bool ExceptHitAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetLastPlayingAction");

	Params::LActionUtilFuncLibrary_GetLastPlayingAction Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ExceptHitAction = ExceptHitAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetLCharacterMovementComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULCharacterMovementComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULCharacterMovementComponent* ULActionUtilFuncLibrary::GetLCharacterMovementComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetLCharacterMovementComponentBP");

	Params::LActionUtilFuncLibrary_GetLCharacterMovementComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetMeshSelectionTypeByWeaponAttachType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELWeaponAttachPointType                 WeaponAttachPointType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELMeshSelectionType ULActionUtilFuncLibrary::GetMeshSelectionTypeByWeaponAttachType(ELWeaponAttachPointType WeaponAttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetMeshSelectionTypeByWeaponAttachType");

	Params::LActionUtilFuncLibrary_GetMeshSelectionTypeByWeaponAttachType Parms{};

	Parms.WeaponAttachPointType = WeaponAttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetMontage_CurrentPlayPositionBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionUtilFuncLibrary::GetMontage_CurrentPlayPositionBP(class UAnimInstance* AnimInst, int32 MontageInstanceID, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetMontage_CurrentPlayPositionBP");

	Params::LActionUtilFuncLibrary_GetMontage_CurrentPlayPositionBP Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetMontage_CurrentSectionBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetMontage_CurrentSectionBP(class UAnimInstance* AnimInst, int32 MontageInstanceID, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetMontage_CurrentSectionBP");

	Params::LActionUtilFuncLibrary_GetMontage_CurrentSectionBP Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetMontage_PlayLengthWithRateScaleBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionUtilFuncLibrary::GetMontage_PlayLengthWithRateScaleBP(class UAnimMontage* Montage, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetMontage_PlayLengthWithRateScaleBP");

	Params::LActionUtilFuncLibrary_GetMontage_PlayLengthWithRateScaleBP Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetMontage_PlayRateBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionUtilFuncLibrary::GetMontage_PlayRateBP(class UAnimMontage* Montage, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetMontage_PlayRateBP");

	Params::LActionUtilFuncLibrary_GetMontage_PlayRateBP Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetMontage_SectionLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULActionUtilFuncLibrary::GetMontage_SectionLength(class UAnimMontage* InMontage, int32 InSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetMontage_SectionLength");

	Params::LActionUtilFuncLibrary_GetMontage_SectionLength Parms{};

	Parms.InMontage = InMontage;
	Parms.InSection = InSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetPhysicalAnimationComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPhysicalAnimationComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPhysicalAnimationComponent* ULActionUtilFuncLibrary::GetPhysicalAnimationComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetPhysicalAnimationComponentBP");

	Params::LActionUtilFuncLibrary_GetPhysicalAnimationComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetPhysicalStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELPhysicalDamageType                    PhysicalType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELDamageBranchType                      ElementalStatType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELSecondStat ULActionUtilFuncLibrary::GetPhysicalStat(ELPhysicalDamageType PhysicalType, ELDamageBranchType ElementalStatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetPhysicalStat");

	Params::LActionUtilFuncLibrary_GetPhysicalStat Parms{};

	Parms.PhysicalType = PhysicalType;
	Parms.ElementalStatType = ElementalStatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetSkillAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* ULActionUtilFuncLibrary::GetSkillAnim(class AActor* TargetActor, class FName SkillCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetSkillAnim");

	Params::LActionUtilFuncLibrary_GetSkillAnim Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SkillCodeName = SkillCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULActionUtilFuncLibrary::GetWeapon(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetWeapon");

	Params::LActionUtilFuncLibrary_GetWeapon Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetWeaponAttachPointSocket
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::GetWeaponAttachPointSocket(class AActor* TargetActor, ELWeaponAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetWeaponAttachPointSocket");

	Params::LActionUtilFuncLibrary_GetWeaponAttachPointSocket Parms{};

	Parms.TargetActor = TargetActor;
	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetWeaponAttachTypeByMeshSelectionType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELMeshSelectionType                     MeshSelectionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELWeaponAttachPointType ULActionUtilFuncLibrary::GetWeaponAttachTypeByMeshSelectionType(ELMeshSelectionType MeshSelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetWeaponAttachTypeByMeshSelectionType");

	Params::LActionUtilFuncLibrary_GetWeaponAttachTypeByMeshSelectionType Parms{};

	Parms.MeshSelectionType = MeshSelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetWeaponByAttachPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULActionUtilFuncLibrary::GetWeaponByAttachPoint(class AActor* TargetActor, ELWeaponAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetWeaponByAttachPoint");

	Params::LActionUtilFuncLibrary_GetWeaponByAttachPoint Parms{};

	Parms.TargetActor = TargetActor;
	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetWeaponByItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULActionUtilFuncLibrary::GetWeaponByItem(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetWeaponByItem");

	Params::LActionUtilFuncLibrary_GetWeaponByItem Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.GetWeaponBySkillHit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULActionUtilFuncLibrary::GetWeaponBySkillHit(class AActor* TargetActor, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "GetWeaponBySkillHit");

	Params::LActionUtilFuncLibrary_GetWeaponBySkillHit Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsAttackAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELActionCategory                        ActionCategory                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsAttackAction(ELActionCategory ActionCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsAttackAction");

	Params::LActionUtilFuncLibrary_IsAttackAction Parms{};

	Parms.ActionCategory = ActionCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsCommandPressed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsCommandPressed(class FName Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsCommandPressed");

	Params::LActionUtilFuncLibrary_IsCommandPressed Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsCounterAlwaysBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsCounterAlwaysBP(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsCounterAlwaysBP");

	Params::LActionUtilFuncLibrary_IsCounterAlwaysBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsDashAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELActionCategory                        ActionCategory                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsDashAction(ELActionCategory ActionCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsDashAction");

	Params::LActionUtilFuncLibrary_IsDashAction Parms{};

	Parms.ActionCategory = ActionCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsFatalHitActionClassName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionClassName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsFatalHitActionClassName(class FName ActionClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsFatalHitActionClassName");

	Params::LActionUtilFuncLibrary_IsFatalHitActionClassName Parms{};

	Parms.ActionClassName = ActionClassName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsHitAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELActionCategory                        ActionCategory                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsHitAction(ELActionCategory ActionCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsHitAction");

	Params::LActionUtilFuncLibrary_IsHitAction Parms{};

	Parms.ActionCategory = ActionCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsInGrabProcessBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsInGrabProcessBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsInGrabProcessBP");

	Params::LActionUtilFuncLibrary_IsInGrabProcessBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsInIdleMoveState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsInIdleMoveState(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsInIdleMoveState");

	Params::LActionUtilFuncLibrary_IsInIdleMoveState Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsLandWalkable
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          LandNormal                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsLandWalkable(const struct FVector& LandNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsLandWalkable");

	Params::LActionUtilFuncLibrary_IsLandWalkable Parms{};

	Parms.LandNormal = std::move(LandNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsPlayingSequence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsPlayingSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsPlayingSequence");

	Params::LActionUtilFuncLibrary_IsPlayingSequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsSkillHitTypeWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELSkillHitType                          SkillHitType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsSkillHitTypeWeapon(ELSkillHitType SkillHitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsSkillHitTypeWeapon");

	Params::LActionUtilFuncLibrary_IsSkillHitTypeWeapon Parms{};

	Parms.SkillHitType = SkillHitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.IsValidGameObjectHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::IsValidGameObjectHandle(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "IsValidGameObjectHandle");

	Params::LActionUtilFuncLibrary_IsValidGameObjectHandle Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.LaunchHitCollisionDynamic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitCollisionInfo               HitColInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLHitContext                     HitContext                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ALHitCollisionDynamic*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALHitCollisionDynamic* ULActionUtilFuncLibrary::LaunchHitCollisionDynamic(class AActor* Instigator, const struct FLHitCollisionInfo& HitColInfo, const struct FLHitContext& HitContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "LaunchHitCollisionDynamic");

	Params::LActionUtilFuncLibrary_LaunchHitCollisionDynamic Parms{};

	Parms.Instigator = Instigator;
	Parms.HitColInfo = std::move(HitColInfo);
	Parms.HitContext = std::move(HitContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.LaunchHitCollisionDynamicWithGrab
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitCollisionInfo               HitColInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLHitContext                     HitContext                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLGrabInfo                       GrabInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ALHitCollisionDynamic*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALHitCollisionDynamic* ULActionUtilFuncLibrary::LaunchHitCollisionDynamicWithGrab(class AActor* Instigator, const struct FLHitCollisionInfo& HitColInfo, const struct FLHitContext& HitContext, const struct FLGrabInfo& GrabInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "LaunchHitCollisionDynamicWithGrab");

	Params::LActionUtilFuncLibrary_LaunchHitCollisionDynamicWithGrab Parms{};

	Parms.Instigator = Instigator;
	Parms.HitColInfo = std::move(HitColInfo);
	Parms.HitContext = std::move(HitContext);
	Parms.GrabInfo = std::move(GrabInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.LaunchTraceAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSocketTraceType                       SocketTraceType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBroken                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          LifeOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActionUtilFuncLibrary::LaunchTraceAttack(class AActor* TargetActor, class FName SkillHitName, ELSocketTraceType SocketTraceType, bool IsBroken, class UObject* LifeOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "LaunchTraceAttack");

	Params::LActionUtilFuncLibrary_LaunchTraceAttack Parms{};

	Parms.TargetActor = TargetActor;
	Parms.SkillHitName = SkillHitName;
	Parms.SocketTraceType = SocketTraceType;
	Parms.IsBroken = IsBroken;
	Parms.LifeOwner = LifeOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.LaunchTraceAttack_by_NonHitNotify
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         WeaponActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSocketTraceType                       SocketTraceType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TraceStartSocket                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TraceEndSocket                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceSphereRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBroken                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          LifeOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActionUtilFuncLibrary::LaunchTraceAttack_by_NonHitNotify(class AActor* TargetActor, class ALWeapon* WeaponActor, ELSocketTraceType SocketTraceType, class FName TraceStartSocket, class FName TraceEndSocket, float TraceSphereRadius, float LifeSpan, ELPhysicalSurfaceType PhysicalSurface, bool IsBroken, class UObject* LifeOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "LaunchTraceAttack_by_NonHitNotify");

	Params::LActionUtilFuncLibrary_LaunchTraceAttack_by_NonHitNotify Parms{};

	Parms.TargetActor = TargetActor;
	Parms.WeaponActor = WeaponActor;
	Parms.SocketTraceType = SocketTraceType;
	Parms.TraceStartSocket = TraceStartSocket;
	Parms.TraceEndSocket = TraceEndSocket;
	Parms.TraceSphereRadius = TraceSphereRadius;
	Parms.LifeSpan = LifeSpan;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.IsBroken = IsBroken;
	Parms.LifeOwner = LifeOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.LockPCActions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowMoveOnly                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::LockPCActions(const class UObject* WorldContextObject, bool AllowMoveOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "LockPCActions");

	Params::LActionUtilFuncLibrary_LockPCActions Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AllowMoveOnly = AllowMoveOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.OnStartFatalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::OnStartFatalAttack(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "OnStartFatalAttack");

	Params::LActionUtilFuncLibrary_OnStartFatalAttack Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.OnStopFatalAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::OnStopFatalAttack(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "OnStopFatalAttack");

	Params::LActionUtilFuncLibrary_OnStopFatalAttack Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.OverrideAnimationAssetBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MachineName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::OverrideAnimationAssetBP(class UAnimInstance* AnimInstance, class UAnimationAsset* AnimationAsset, class FName MachineName, class FName StateName, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "OverrideAnimationAssetBP");

	Params::LActionUtilFuncLibrary_OverrideAnimationAssetBP Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.AnimationAsset = AnimationAsset;
	Parms.MachineName = MachineName;
	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PauseMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Pause                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::PauseMontage(class UAnimInstance* AnimInst, int32 MontageInstanceID, bool Pause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PauseMontage");

	Params::LActionUtilFuncLibrary_PauseMontage Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;
	Parms.Pause = Pause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlayActionClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionClassCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActPayloadBase*                 Payload                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActionUtilFuncLibrary::PlayActionClass(class AActor* Target, class FName ActionClassCodeName, class ULActPayloadBase* Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlayActionClass");

	Params::LActionUtilFuncLibrary_PlayActionClass Parms{};

	Parms.Target = Target;
	Parms.ActionClassCodeName = ActionClassCodeName;
	Parms.Payload = Payload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlayAnimAsDynamicMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSlotNodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     OutMontage                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionUtilFuncLibrary::PlayAnimAsDynamicMontage(class UAnimInstance* AnimInst, class UAnimSequenceBase* Anim, class FName InSlotNodeName, class UAnimMontage** OutMontage, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlayAnimAsDynamicMontage");

	Params::LActionUtilFuncLibrary_PlayAnimAsDynamicMontage Parms{};

	Parms.AnimInst = AnimInst;
	Parms.Anim = Anim;
	Parms.InSlotNodeName = InSlotNodeName;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMontage != nullptr)
		*OutMontage = Parms.OutMontage;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlayCommonMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonMontageCodeName                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActionUtilFuncLibrary::PlayCommonMontage(class AActor* Target, class FName CommonMontageCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlayCommonMontage");

	Params::LActionUtilFuncLibrary_PlayCommonMontage Parms{};

	Parms.Target = Target;
	Parms.CommonMontageCodeName = CommonMontageCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlayHitActionBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitActionClassCodeName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActionUtilFuncLibrary::PlayHitActionBP(class AActor* Attacker, class AActor* Victim, class FName HitActionClassCodeName, const struct FLHitInfo& HitInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlayHitActionBP");

	Params::LActionUtilFuncLibrary_PlayHitActionBP Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitActionClassCodeName = HitActionClassCodeName;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlayLoopAnimAsDynamicMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                StartAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                LoopAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                EndAnim                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSlotNodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     OutMontage                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionUtilFuncLibrary::PlayLoopAnimAsDynamicMontage(class UAnimInstance* AnimInst, class UAnimSequenceBase* StartAnim, class UAnimSequenceBase* LoopAnim, class UAnimSequenceBase* EndAnim, class FName InSlotNodeName, class UAnimMontage** OutMontage, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlayLoopAnimAsDynamicMontage");

	Params::LActionUtilFuncLibrary_PlayLoopAnimAsDynamicMontage Parms{};

	Parms.AnimInst = AnimInst;
	Parms.StartAnim = StartAnim;
	Parms.LoopAnim = LoopAnim;
	Parms.EndAnim = EndAnim;
	Parms.InSlotNodeName = InSlotNodeName;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMontage != nullptr)
		*OutMontage = Parms.OutMontage;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlayMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopAllMontages                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActionUtilFuncLibrary::PlayMontage(class UAnimInstance* AnimInst, class UAnimMontage* Montage, float InPlayRate, float InTimeToStartMontageAt, bool bStopAllMontages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlayMontage");

	Params::LActionUtilFuncLibrary_PlayMontage Parms{};

	Parms.AnimInst = AnimInst;
	Parms.Montage = Montage;
	Parms.InPlayRate = InPlayRate;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	Parms.bStopAllMontages = bStopAllMontages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlaySkillActionBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAction_StartRotationInfo       StartRotationInfo                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ULActPayloadBase*                 Payload                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActionUtilFuncLibrary::PlaySkillActionBP(class AActor* Target, class FName SkillCodeName, const struct FLAction_StartRotationInfo& StartRotationInfo, class ULActPayloadBase* Payload, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlaySkillActionBP");

	Params::LActionUtilFuncLibrary_PlaySkillActionBP Parms{};

	Parms.Target = Target;
	Parms.SkillCodeName = SkillCodeName;
	Parms.StartRotationInfo = std::move(StartRotationInfo);
	Parms.Payload = Payload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PlaySocketTracerFx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFxSocketTracerInfo             FxSocketTracerInfo                                     (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bPlayFx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlaySound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::PlaySocketTracerFx(class AActor* OwnerActor, const struct FLFxSocketTracerInfo& FxSocketTracerInfo, const struct FHitResult& HitResult, bool bPlayFx, bool bPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PlaySocketTracerFx");

	Params::LActionUtilFuncLibrary_PlaySocketTracerFx Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.FxSocketTracerInfo = std::move(FxSocketTracerInfo);
	Parms.HitResult = std::move(HitResult);
	Parms.bPlayFx = bPlayFx;
	Parms.bPlaySound = bPlaySound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.ProcessHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ULHitColMgrComponent*             LHitColMgrComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::ProcessHit(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult, const struct FLHitInfo& HitInfo, class ULHitColMgrComponent* LHitColMgrComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ProcessHit");

	Params::LActionUtilFuncLibrary_ProcessHit Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitResult = std::move(HitResult);
	Parms.HitInfo = std::move(HitInfo);
	Parms.LHitColMgrComponent = LHitColMgrComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.PutOnBuff
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BuffCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::PutOnBuff(class AActor* TargetActor, class FName BuffCodeName, class UObject* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "PutOnBuff");

	Params::LActionUtilFuncLibrary_PutOnBuff Parms{};

	Parms.TargetActor = TargetActor;
	Parms.BuffCodeName = BuffCodeName;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.RecordDieCauseHitDirectionBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::RecordDieCauseHitDirectionBP(class AActor* TargetActor, class AActor* Attacker, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "RecordDieCauseHitDirectionBP");

	Params::LActionUtilFuncLibrary_RecordDieCauseHitDirectionBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.RecreateClothingActors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::RecreateClothingActors(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "RecreateClothingActors");

	Params::LActionUtilFuncLibrary_RecreateClothingActors Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.RemoveInputActionKeyMapping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::RemoveInputActionKeyMapping(class FName InputAction, bool IsGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "RemoveInputActionKeyMapping");

	Params::LActionUtilFuncLibrary_RemoveInputActionKeyMapping Parms{};

	Parms.InputAction = InputAction;
	Parms.IsGamePad = IsGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.RemoveInputAxisKeyMapping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::RemoveInputAxisKeyMapping(class FName InputAction, bool IsGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "RemoveInputAxisKeyMapping");

	Params::LActionUtilFuncLibrary_RemoveInputAxisKeyMapping Parms{};

	Parms.InputAction = InputAction;
	Parms.IsGamePad = IsGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.ResetInputKeyMapping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::ResetInputKeyMapping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "ResetInputKeyMapping");

	Params::LActionUtilFuncLibrary_ResetInputKeyMapping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SelectCommonActionMontageCodeNameByHitMotionBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitMotionType                         HitMotionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitMotionDirectionType                HitMotionDirectionType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TryExcludeCodeName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULActionUtilFuncLibrary::SelectCommonActionMontageCodeNameByHitMotionBP(class AActor* TargetActor, ELHitMotionType HitMotionType, ELHitMotionDirectionType HitMotionDirectionType, class FName TryExcludeCodeName, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SelectCommonActionMontageCodeNameByHitMotionBP");

	Params::LActionUtilFuncLibrary_SelectCommonActionMontageCodeNameByHitMotionBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.HitMotionType = HitMotionType;
	Parms.HitMotionDirectionType = HitMotionDirectionType;
	Parms.TryExcludeCodeName = TryExcludeCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetAllPhysicsAngularVelocityInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetAllPhysicsAngularVelocityInRadians(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FVector& NewVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetAllPhysicsAngularVelocityInRadians");

	Params::LActionUtilFuncLibrary_SetAllPhysicsAngularVelocityInRadians Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.NewVel = std::move(NewVel);
	Parms.bAddToCurrent = bAddToCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetAllPhysicsLinearVelocity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetAllPhysicsLinearVelocity(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FVector& NewVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetAllPhysicsLinearVelocity");

	Params::LActionUtilFuncLibrary_SetAllPhysicsLinearVelocity Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.NewVel = std::move(NewVel);
	Parms.bAddToCurrent = bAddToCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetAxisValueUpperLimit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Limit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetAxisValueUpperLimit(class AActor* TargetActor, float Limit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetAxisValueUpperLimit");

	Params::LActionUtilFuncLibrary_SetAxisValueUpperLimit Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Limit = Limit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetCommandConsumed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Consumed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetCommandConsumed(class FName Command, bool Consumed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetCommandConsumed");

	Params::LActionUtilFuncLibrary_SetCommandConsumed Parms{};

	Parms.Command = Command;
	Parms.Consumed = Consumed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetFullBodyWhenMoveStopped
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetFullBodyWhenMoveStopped(class AActor* TargetActor, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetFullBodyWhenMoveStopped");

	Params::LActionUtilFuncLibrary_SetFullBodyWhenMoveStopped Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetMainAnimFSMState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAnimFSMState                          MainAnimFSMState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetMainAnimFSMState(class AActor* TargetActor, ELAnimFSMState MainAnimFSMState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetMainAnimFSMState");

	Params::LActionUtilFuncLibrary_SetMainAnimFSMState Parms{};

	Parms.TargetActor = TargetActor;
	Parms.MainAnimFSMState = MainAnimFSMState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetMontage_AutoBlendOut
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseAutoBlendOut                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetMontage_AutoBlendOut(class UAnimInstance* AnimInst, int32 MontageInstanceID, bool UseAutoBlendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetMontage_AutoBlendOut");

	Params::LActionUtilFuncLibrary_SetMontage_AutoBlendOut Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;
	Parms.UseAutoBlendOut = UseAutoBlendOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP(class UAnimInstance* AnimInst, int32 MontageInstanceID, bool Value, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP");

	Params::LActionUtilFuncLibrary_SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetMontage_NextSection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionNameToChange                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NextSection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetMontage_NextSection(class UAnimInstance* AnimInst, int32 MontageInstanceID, class FName SectionNameToChange, class FName NextSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetMontage_NextSection");

	Params::LActionUtilFuncLibrary_SetMontage_NextSection Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;
	Parms.SectionNameToChange = SectionNameToChange;
	Parms.NextSection = NextSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetMoveIgnoreMask_Monster
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetMoveIgnoreMask_Monster(class ACharacter* TargetCharacter, bool Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetMoveIgnoreMask_Monster");

	Params::LActionUtilFuncLibrary_SetMoveIgnoreMask_Monster Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.Ignore = Ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetMoveIgnoreMask_Movement_Related
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Ignore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetMoveIgnoreMask_Movement_Related(class ACharacter* TargetCharacter, bool Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetMoveIgnoreMask_Movement_Related");

	Params::LActionUtilFuncLibrary_SetMoveIgnoreMask_Movement_Related Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.Ignore = Ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetNoSkeletonUpdate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TurnOff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetNoSkeletonUpdate(class AActor* TargetActor, bool TurnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetNoSkeletonUpdate");

	Params::LActionUtilFuncLibrary_SetNoSkeletonUpdate Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TurnOff = TurnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetPerBoneMotionBlur
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*            SkinnedMeshComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TurnOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetPerBoneMotionBlur(class USkinnedMeshComponent* SkinnedMeshComponent, bool TurnOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetPerBoneMotionBlur");

	Params::LActionUtilFuncLibrary_SetPerBoneMotionBlur Parms{};

	Parms.SkinnedMeshComponent = SkinnedMeshComponent;
	Parms.TurnOn = TurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SetStaminaSprintStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::SetStaminaSprintStatus(class AActor* TargetActor, bool Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetStaminaSprintStatus");

	Params::LActionUtilFuncLibrary_SetStaminaSprintStatus Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.SetUpdateOverlapsOnAnimationFinalize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::SetUpdateOverlapsOnAnimationFinalize(class AActor* TargetActor, bool bUpdateOverlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SetUpdateOverlapsOnAnimationFinalize");

	Params::LActionUtilFuncLibrary_SetUpdateOverlapsOnAnimationFinalize Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bUpdateOverlap = bUpdateOverlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SpawnDynamicDamageVolumeActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DynamicDamageVolumeCodeName                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ALDynamicDamageVolumeActor*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALDynamicDamageVolumeActor* ULActionUtilFuncLibrary::SpawnDynamicDamageVolumeActor(class AActor* Instigator, class FName DynamicDamageVolumeCodeName, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SpawnDynamicDamageVolumeActor");

	Params::LActionUtilFuncLibrary_SpawnDynamicDamageVolumeActor Parms{};

	Parms.Instigator = Instigator;
	Parms.DynamicDamageVolumeCodeName = DynamicDamageVolumeCodeName;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.StartHide
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseDissolveEffect                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::StartHide(class AActor* TargetActor, bool bUseDissolveEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "StartHide");

	Params::LActionUtilFuncLibrary_StartHide Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bUseDissolveEffect = bUseDissolveEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.StopHide
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseDissolveEffect                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::StopHide(class AActor* TargetActor, bool bUseDissolveEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "StopHide");

	Params::LActionUtilFuncLibrary_StopHide Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bUseDissolveEffect = bUseDissolveEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.StopMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MontageInstanceID                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::StopMontage(class UAnimInstance* AnimInst, int32 MontageInstanceID, float BlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "StopMontage");

	Params::LActionUtilFuncLibrary_StopMontage Parms{};

	Parms.AnimInst = AnimInst;
	Parms.MontageInstanceID = MontageInstanceID;
	Parms.BlendOutTime = BlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SwitchAngleToType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAngleRangeType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELAngleRangeType ULActionUtilFuncLibrary::SwitchAngleToType(class AActor* TargetActor, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SwitchAngleToType");

	Params::LActionUtilFuncLibrary_SwitchAngleToType Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SwitchAngleToType_2Way
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAngleRangeType_2Way                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELAngleRangeType_2Way ULActionUtilFuncLibrary::SwitchAngleToType_2Way(class AActor* TargetActor, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SwitchAngleToType_2Way");

	Params::LActionUtilFuncLibrary_SwitchAngleToType_2Way Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.SwitchAngleToType_4Way
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAngleRangeType_4Way                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELAngleRangeType_4Way ULActionUtilFuncLibrary::SwitchAngleToType_4Way(class AActor* TargetActor, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "SwitchAngleToType_4Way");

	Params::LActionUtilFuncLibrary_SwitchAngleToType_4Way Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.TakeOffBuff
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BuffCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::TakeOffBuff(class AActor* TargetActor, class FName BuffCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "TakeOffBuff");

	Params::LActionUtilFuncLibrary_TakeOffBuff Parms{};

	Parms.TargetActor = TargetActor;
	Parms.BuffCodeName = BuffCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.Test_ContentCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CommandCodeName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::Test_ContentCommand(class FName CommandCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "Test_ContentCommand");

	Params::LActionUtilFuncLibrary_Test_ContentCommand Parms{};

	Parms.CommandCodeName = CommandCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.Test_DeadCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::Test_DeadCharacter(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "Test_DeadCharacter");

	Params::LActionUtilFuncLibrary_Test_DeadCharacter Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.Test_ForceToggleCommmand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ToggleCommand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TurnOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::Test_ForceToggleCommmand(class FName ToggleCommand, bool TurnOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "Test_ForceToggleCommmand");

	Params::LActionUtilFuncLibrary_Test_ForceToggleCommmand Parms{};

	Parms.ToggleCommand = ToggleCommand;
	Parms.TurnOn = TurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.UndoLastChangeCharBlockType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UndoToOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::UndoLastChangeCharBlockType(class AActor* TargetActor, bool UndoToOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "UndoLastChangeCharBlockType");

	Params::LActionUtilFuncLibrary_UndoLastChangeCharBlockType Parms{};

	Parms.TargetActor = TargetActor;
	Parms.UndoToOrigin = UndoToOrigin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.UnlockPCActions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActionUtilFuncLibrary::UnlockPCActions(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "UnlockPCActions");

	Params::LActionUtilFuncLibrary_UnlockPCActions Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActionUtilFuncLibrary.UpdateWeaponOnOffByBareHand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::UpdateWeaponOnOffByBareHand(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "UpdateWeaponOnOffByBareHand");

	Params::LActionUtilFuncLibrary_UpdateWeaponOnOffByBareHand Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.WeaponDestructDurabilityDisable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 WeaponAttachPoint                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsageGuard                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::WeaponDestructDurabilityDisable(class AActor* Actor, ELWeaponAttachPointType WeaponAttachPoint, bool bUsageGuard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "WeaponDestructDurabilityDisable");

	Params::LActionUtilFuncLibrary_WeaponDestructDurabilityDisable Parms{};

	Parms.Actor = Actor;
	Parms.WeaponAttachPoint = WeaponAttachPoint;
	Parms.bUsageGuard = bUsageGuard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActionUtilFuncLibrary.WeaponDestructDurabilityEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 WeaponAttackPoint                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsageGuard                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActionUtilFuncLibrary::WeaponDestructDurabilityEnable(class AActor* Actor, ELWeaponAttachPointType WeaponAttackPoint, int32 StartAngle, int32 EndAngle, int32 Distance, bool bUsageGuard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LActionUtilFuncLibrary", "WeaponDestructDurabilityEnable");

	Params::LActionUtilFuncLibrary_WeaponDestructDurabilityEnable Parms{};

	Parms.Actor = Actor;
	Parms.WeaponAttackPoint = WeaponAttackPoint;
	Parms.StartAngle = StartAngle;
	Parms.EndAngle = EndAngle;
	Parms.Distance = Distance;
	Parms.bUsageGuard = bUsageGuard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.AddActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePair                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        OwnerAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELImmuneSourceType                      ImmuneSourceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DebugInfo                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::AddActionState(class FName State, bool UsePair, class UObject* Instigator, class ULActBase* OwnerAction, ELImmuneSourceType ImmuneSourceType, const class FString& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddActionState");

	Params::LActMgrComponent_AddActionState Parms{};

	Parms.State = State;
	Parms.UsePair = UsePair;
	Parms.Instigator = Instigator;
	Parms.OwnerAction = OwnerAction;
	Parms.ImmuneSourceType = ImmuneSourceType;
	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.AddActionState_AutoRemove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePair                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        OwnerAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELImmuneSourceType                      ImmuneSourceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExpirationTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DebugInfo                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::AddActionState_AutoRemove(float LifeSpan, class FName State, bool UsePair, class UObject* Instigator, class ULActBase* OwnerAction, ELImmuneSourceType ImmuneSourceType, float ExpirationTime, const class FString& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddActionState_AutoRemove");

	Params::LActMgrComponent_AddActionState_AutoRemove Parms{};

	Parms.LifeSpan = LifeSpan;
	Parms.State = State;
	Parms.UsePair = UsePair;
	Parms.Instigator = Instigator;
	Parms.OwnerAction = OwnerAction;
	Parms.ImmuneSourceType = ImmuneSourceType;
	Parms.ExpirationTime = ExpirationTime;
	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.AddActionStateArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     StateArray                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    UsePair                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        OwnerAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELImmuneSourceType                      ImmuneSourceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DebugInfo                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::AddActionStateArray(const TArray<class FName>& StateArray, bool UsePair, class UObject* Instigator, class ULActBase* OwnerAction, ELImmuneSourceType ImmuneSourceType, const class FString& DebugInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddActionStateArray");

	Params::LActMgrComponent_AddActionStateArray Parms{};

	Parms.StateArray = std::move(StateArray);
	Parms.UsePair = UsePair;
	Parms.Instigator = Instigator;
	Parms.OwnerAction = OwnerAction;
	Parms.ImmuneSourceType = ImmuneSourceType;
	Parms.DebugInfo = std::move(DebugInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.AddAnimRateScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAnimRateScaleOperationType            OperationType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RateScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::AddAnimRateScale(ELAnimRateScaleOperationType OperationType, float RateScale, float Duration, class UObject* Instigator, class USkeletalMeshComponent* SkeletalMeshComponent, class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddAnimRateScale");

	Params::LActMgrComponent_AddAnimRateScale Parms{};

	Parms.OperationType = OperationType;
	Parms.RateScale = RateScale;
	Parms.Duration = Duration;
	Parms.Instigator = Instigator;
	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.AddAnimRootMotionTranslationScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAnimRootMotionScaleOperationType      OperationType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RateScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RateScale_Vertical                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RateScale_Horizontal                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::AddAnimRootMotionTranslationScale(ELAnimRootMotionScaleOperationType OperationType, float RateScale, float Duration, class UObject* Instigator, float RateScale_Vertical, float RateScale_Horizontal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddAnimRootMotionTranslationScale");

	Params::LActMgrComponent_AddAnimRootMotionTranslationScale Parms{};

	Parms.OperationType = OperationType;
	Parms.RateScale = RateScale;
	Parms.Duration = Duration;
	Parms.Instigator = Instigator;
	Parms.RateScale_Vertical = RateScale_Vertical;
	Parms.RateScale_Horizontal = RateScale_Horizontal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.AddFxSocketTracer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLFxSocketTracerInfo             Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    StartCheck                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::AddFxSocketTracer(const struct FLFxSocketTracerInfo& Info, bool StartCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddFxSocketTracer");

	Params::LActMgrComponent_AddFxSocketTracer Parms{};

	Parms.Info = std::move(Info);
	Parms.StartCheck = StartCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.AddPreInputCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLReservedCommand                ReservedCommand                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULActMgrComponent::AddPreInputCommand(const struct FLReservedCommand& ReservedCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddPreInputCommand");

	Params::LActMgrComponent_AddPreInputCommand Parms{};

	Parms.ReservedCommand = std::move(ReservedCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.AddToHitGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HitGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::AddToHitGroup(class AActor* Victim, int32 HitGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AddToHitGroup");

	Params::LActMgrComponent_AddToHitGroup Parms{};

	Parms.Victim = Victim;
	Parms.HitGroup = HitGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.BindTransformModifierToAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULActBase*                        OwnerAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULActMgrComponent::BindTransformModifierToAction(class ULActBase* OwnerAction, const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "BindTransformModifierToAction");

	Params::LActMgrComponent_BindTransformModifierToAction Parms{};

	Parms.OwnerAction = OwnerAction;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.CachePlayedHitCommonActionMontageCodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             HitCommonActionMontageCodeName                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::CachePlayedHitCommonActionMontageCodeName(class FName HitCommonActionMontageCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "CachePlayedHitCommonActionMontageCodeName");

	Params::LActMgrComponent_CachePlayedHitCommonActionMontageCodeName Parms{};

	Parms.HitCommonActionMontageCodeName = HitCommonActionMontageCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.CheckFxSocketTracer_Redo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::CheckFxSocketTracer_Redo(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "CheckFxSocketTracer_Redo");

	Params::LActMgrComponent_CheckFxSocketTracer_Redo Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.CheckFxSocketTracer_Stop
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::CheckFxSocketTracer_Stop(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "CheckFxSocketTracer_Stop");

	Params::LActMgrComponent_CheckFxSocketTracer_Stop Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.ClearActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::ClearActionState(class FName State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "ClearActionState");

	Params::LActMgrComponent_ClearActionState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.ClearPreInputCommand
// (Final, Native, Public, BlueprintCallable)

void ULActMgrComponent::ClearPreInputCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "ClearPreInputCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.FuncForClearPreInputCommand
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::FuncForClearPreInputCommand(class UAnimMontage* Montage, bool Interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "FuncForClearPreInputCommand");

	Params::LActMgrComponent_FuncForClearPreInputCommand Parms{};

	Parms.Montage = Montage;
	Parms.Interrupted = Interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.GetActionFromAssetName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BaseActionClassCodeName                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AssetName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::GetActionFromAssetName(class AActor* TargetActor, class FName BaseActionClassCodeName, class FName AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetActionFromAssetName");

	Params::LActMgrComponent_GetActionFromAssetName Parms{};

	Parms.TargetActor = TargetActor;
	Parms.BaseActionClassCodeName = BaseActionClassCodeName;
	Parms.AssetName = AssetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetActionFromTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::GetActionFromTable(class AActor* TargetActor, class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetActionFromTable");

	Params::LActMgrComponent_GetActionFromTable Parms{};

	Parms.TargetActor = TargetActor;
	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetAvailableAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             Type                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::GetAvailableAction(class AActor* TargetActor, const TSoftClassPtr<class UClass> Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetAvailableAction");

	Params::LActMgrComponent_GetAvailableAction Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetDefaultSpawnedGuardCollisionDynamic
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALHitCollisionDynamic*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALHitCollisionDynamic* ULActMgrComponent::GetDefaultSpawnedGuardCollisionDynamic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetDefaultSpawnedGuardCollisionDynamic");

	Params::LActMgrComponent_GetDefaultSpawnedGuardCollisionDynamic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetPlayingAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Type                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::GetPlayingAction(const TSoftClassPtr<class UClass> Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetPlayingAction");

	Params::LActMgrComponent_GetPlayingAction Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetSlaveArmActionForVisualActionBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULAction_SlaveArmVisual*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULAction_SlaveArmVisual* ULActMgrComponent::GetSlaveArmActionForVisualActionBP(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetSlaveArmActionForVisualActionBP");

	Params::LActMgrComponent_GetSlaveArmActionForVisualActionBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.OnBoneTransformsFinalized_ForGrab
// (Final, Native, Public)

void ULActMgrComponent::OnBoneTransformsFinalized_ForGrab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "OnBoneTransformsFinalized_ForGrab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.PlayAction_Die
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::PlayAction_Die(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "PlayAction_Die");

	Params::LActMgrComponent_PlayAction_Die Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.PlayAction_SkillFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FailedSkillCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::PlayAction_SkillFailed(class AActor* TargetActor, class FName FailedSkillCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "PlayAction_SkillFailed");

	Params::LActMgrComponent_PlayAction_SkillFailed Parms{};

	Parms.TargetActor = TargetActor;
	Parms.FailedSkillCodeName = FailedSkillCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.PreProcessCommand
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Lever                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::PreProcessCommand(class AActor* TargetActor, class FName Command, const struct FVector& Lever)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "PreProcessCommand");

	Params::LActMgrComponent_PreProcessCommand Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Command = Command;
	Parms.Lever = std::move(Lever);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.ProcessAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        TargetAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActPayloadBase*                 Payload                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::ProcessAction(class AActor* TargetActor, class ULActBase* TargetAction, class ULActPayloadBase* Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "ProcessAction");

	Params::LActMgrComponent_ProcessAction Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetAction = TargetAction;
	Parms.Payload = Payload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.ProcessCommand
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Lever                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SkipCommandPrerequisitiesCheck                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CommandEventTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceQueryCommand                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsReserved                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::ProcessCommand(class AActor* TargetActor, class FName Command, const struct FVector& Lever, bool SkipCommandPrerequisitiesCheck, float CommandEventTime, bool ForceQueryCommand, bool IsReserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "ProcessCommand");

	Params::LActMgrComponent_ProcessCommand Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Command = Command;
	Parms.Lever = std::move(Lever);
	Parms.SkipCommandPrerequisitiesCheck = SkipCommandPrerequisitiesCheck;
	Parms.CommandEventTime = CommandEventTime;
	Parms.ForceQueryCommand = ForceQueryCommand;
	Parms.IsReserved = IsReserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.QueryNextAction
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Lever                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        CurrAction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutActionClass                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLActionInfo                     OutActionInfo                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class ULActPayloadBase*                 OutPayload                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::QueryNextAction(class AActor* TargetActor, class FName Command, const struct FVector& Lever, class ULActBase* CurrAction, class FName* OutActionClass, struct FLActionInfo* OutActionInfo, class ULActPayloadBase** OutPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "QueryNextAction");

	Params::LActMgrComponent_QueryNextAction Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Command = Command;
	Parms.Lever = std::move(Lever);
	Parms.CurrAction = CurrAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActionClass != nullptr)
		*OutActionClass = Parms.OutActionClass;

	if (OutActionInfo != nullptr)
		*OutActionInfo = std::move(Parms.OutActionInfo);

	if (OutPayload != nullptr)
		*OutPayload = Parms.OutPayload;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RegisterFxSocketTracerEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)>SocketTraceEvent                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RegisterFxSocketTracerEvent(const struct FLGameObjectHandle& Handle, const TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)>& SocketTraceEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RegisterFxSocketTracerEvent");

	Params::LActMgrComponent_RegisterFxSocketTracerEvent Parms{};

	Parms.Handle = std::move(Handle);
	Parms.SocketTraceEvent = SocketTraceEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RegisterWatchingCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckReservedCommand                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        OwnerAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::RegisterWatchingCommand(class FName Command, bool CheckReservedCommand, class ULActBase* OwnerAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RegisterWatchingCommand");

	Params::LActMgrComponent_RegisterWatchingCommand Parms{};

	Parms.Command = Command;
	Parms.CheckReservedCommand = CheckReservedCommand;
	Parms.OwnerAction = OwnerAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveActionState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePair                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELImmuneSourceType                      ImmuneSourceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ValidOnThisFrame                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveActionState(class FName State, bool UsePair, class UObject* Instigator, ELImmuneSourceType ImmuneSourceType, bool ValidOnThisFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveActionState");

	Params::LActMgrComponent_RemoveActionState Parms{};

	Parms.State = State;
	Parms.UsePair = UsePair;
	Parms.Instigator = Instigator;
	Parms.ImmuneSourceType = ImmuneSourceType;
	Parms.ValidOnThisFrame = ValidOnThisFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveActionState_AutoRemove
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULActMgrComponent::RemoveActionState_AutoRemove(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveActionState_AutoRemove");

	Params::LActMgrComponent_RemoveActionState_AutoRemove Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.RemoveActionStateArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     StateArray                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    UsePair                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELImmuneSourceType                      ImmuneSourceType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ValidOnThisFrame                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveActionStateArray(const TArray<class FName>& StateArray, bool UsePair, class UObject* Instigator, ELImmuneSourceType ImmuneSourceType, bool ValidOnThisFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveActionStateArray");

	Params::LActMgrComponent_RemoveActionStateArray Parms{};

	Parms.StateArray = std::move(StateArray);
	Parms.UsePair = UsePair;
	Parms.Instigator = Instigator;
	Parms.ImmuneSourceType = ImmuneSourceType;
	Parms.ValidOnThisFrame = ValidOnThisFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAllAnimRateScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAllAnimRateScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAllAnimRateScale");

	Params::LActMgrComponent_RemoveAllAnimRateScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAllAnimRootMotionTranslationScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAllAnimRootMotionTranslationScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAllAnimRootMotionTranslationScale");

	Params::LActMgrComponent_RemoveAllAnimRootMotionTranslationScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAllFxSocketTracer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAllFxSocketTracer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAllFxSocketTracer");

	Params::LActMgrComponent_RemoveAllFxSocketTracer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAnimRateScale
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAnimRateScale(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAnimRateScale");

	Params::LActMgrComponent_RemoveAnimRateScale Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAnimRateScaleByInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAnimRateScaleByInstigator(class UObject* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAnimRateScaleByInstigator");

	Params::LActMgrComponent_RemoveAnimRateScaleByInstigator Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAnimRootMotionTranslationScale
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAnimRootMotionTranslationScale(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAnimRootMotionTranslationScale");

	Params::LActMgrComponent_RemoveAnimRootMotionTranslationScale Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveAnimRootMotionTranslationScaleByInstigator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveAnimRootMotionTranslationScaleByInstigator(class UObject* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveAnimRootMotionTranslationScaleByInstigator");

	Params::LActMgrComponent_RemoveAnimRootMotionTranslationScaleByInstigator Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.RemoveFxSocketTracer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::RemoveFxSocketTracer(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "RemoveFxSocketTracer");

	Params::LActMgrComponent_RemoveFxSocketTracer Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.SetComboTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Type                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::SetComboTable(TSoftClassPtr<class UClass> Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "SetComboTable");

	Params::LActMgrComponent_SetComboTable Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.SetSkillTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::SetSkillTarget(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "SetSkillTarget");

	Params::LActMgrComponent_SetSkillTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.SetSkillTargetLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::SetSkillTargetLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "SetSkillTargetLocation");

	Params::LActMgrComponent_SetSkillTargetLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StartMeshRotatingOnFloor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RotSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActMgrComponent::StartMeshRotatingOnFloor(float RotSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartMeshRotatingOnFloor");

	Params::LActMgrComponent_StartMeshRotatingOnFloor Parms{};

	Parms.RotSpeed = RotSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartSkillMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SkillMoveID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::StartSkillMove(class FName SkillMoveID, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartSkillMove");

	Params::LActMgrComponent_StartSkillMove Parms{};

	Parms.SkillMoveID = SkillMoveID;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StartSyncTransformToTarget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLSyncTransformToTargetInfo      Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::StartSyncTransformToTarget(const struct FLSyncTransformToTargetInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartSyncTransformToTarget");

	Params::LActMgrComponent_StartSyncTransformToTarget Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Movement                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FixedDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseStepUp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     MoveCurve                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         MoveRot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    CheckNavPath                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvokeBlockEvent                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckFloor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_MoveActor(class AActor* TargetActor, const struct FVector& Movement, float Duration, bool FixedDir, bool UseStepUp, class UCurveVector* MoveCurve, const struct FRotator& MoveRot, bool CheckNavPath, bool InvokeBlockEvent, bool CheckFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_MoveActor");

	Params::LActMgrComponent_StartTransformModifier_MoveActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Movement = std::move(Movement);
	Parms.Duration = Duration;
	Parms.FixedDir = FixedDir;
	Parms.UseStepUp = UseStepUp;
	Parms.MoveCurve = MoveCurve;
	Parms.MoveRot = std::move(MoveRot);
	Parms.CheckNavPath = CheckNavPath;
	Parms.InvokeBlockEvent = InvokeBlockEvent;
	Parms.CheckFloor = CheckFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_MoveOnly
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Movement                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseStepUp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     MoveCurve                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckNavPath                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ApplyFakeVelocity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InvokeBlockEvent                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckFloor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_MoveActor_MoveOnly(class AActor* TargetActor, const struct FVector& Movement, float Duration, bool UseStepUp, class UCurveVector* MoveCurve, bool CheckNavPath, float ApplyFakeVelocity, bool InvokeBlockEvent, bool CheckFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_MoveActor_MoveOnly");

	Params::LActMgrComponent_StartTransformModifier_MoveActor_MoveOnly Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Movement = std::move(Movement);
	Parms.Duration = Duration;
	Parms.UseStepUp = UseStepUp;
	Parms.MoveCurve = MoveCurve;
	Parms.CheckNavPath = CheckNavPath;
	Parms.ApplyFakeVelocity = ApplyFakeVelocity;
	Parms.InvokeBlockEvent = InvokeBlockEvent;
	Parms.CheckFloor = CheckFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_Walking
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Movement                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FixedDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     MoveCurve                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         MoveRot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    CheckNavPath                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckFloor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_MoveActor_Walking(class AActor* TargetActor, const struct FVector& Movement, float Duration, bool FixedDir, class UCurveVector* MoveCurve, const struct FRotator& MoveRot, bool CheckNavPath, bool CheckFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_MoveActor_Walking");

	Params::LActMgrComponent_StartTransformModifier_MoveActor_Walking Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Movement = std::move(Movement);
	Parms.Duration = Duration;
	Parms.FixedDir = FixedDir;
	Parms.MoveCurve = MoveCurve;
	Parms.MoveRot = std::move(MoveRot);
	Parms.CheckNavPath = CheckNavPath;
	Parms.CheckFloor = CheckFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_Walking_MoveOnly
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Movement                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     MoveCurve                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckNavPath                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ApplyFakeVelocity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckFloor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_MoveActor_Walking_MoveOnly(class AActor* TargetActor, const struct FVector& Movement, float Duration, class UCurveVector* MoveCurve, bool CheckNavPath, float ApplyFakeVelocity, bool CheckFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_MoveActor_Walking_MoveOnly");

	Params::LActMgrComponent_StartTransformModifier_MoveActor_Walking_MoveOnly Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Movement = std::move(Movement);
	Parms.Duration = Duration;
	Parms.MoveCurve = MoveCurve;
	Parms.CheckNavPath = CheckNavPath;
	Parms.ApplyFakeVelocity = ApplyFakeVelocity;
	Parms.CheckFloor = CheckFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_MoveActor_Walking_Tracking
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLTransformModifierInfo_MoveActor_Walking_TrackingInfo                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_MoveActor_Walking_Tracking(class AActor* TargetActor, struct FLTransformModifierInfo_MoveActor_Walking_Tracking* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_MoveActor_Walking_Tracking");

	Params::LActMgrComponent_StartTransformModifier_MoveActor_Walking_Tracking Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      RotSpeedCurve                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_RotateActor(class AActor* TargetActor, const struct FRotator& Rot, float Duration, class UCurveFloat* RotSpeedCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_RotateActor");

	Params::LActMgrComponent_StartTransformModifier_RotateActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Rot = std::move(Rot);
	Parms.Duration = Duration;
	Parms.RotSpeedCurve = RotSpeedCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_AddYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AddYaw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      RotSpeedCurve                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_RotateActor_AddYaw(class AActor* TargetActor, float AddYaw, float Duration, class UCurveFloat* RotSpeedCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_RotateActor_AddYaw");

	Params::LActMgrComponent_StartTransformModifier_RotateActor_AddYaw Parms{};

	Parms.TargetActor = TargetActor;
	Parms.AddYaw = AddYaw;
	Parms.Duration = Duration;
	Parms.RotSpeedCurve = RotSpeedCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_ToLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FaceToLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_RotateActor_ToLocation(class AActor* TargetActor, const struct FVector& FaceToLocation, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_RotateActor_ToLocation");

	Params::LActMgrComponent_StartTransformModifier_RotateActor_ToLocation Parms{};

	Parms.TargetActor = TargetActor;
	Parms.FaceToLocation = std::move(FaceToLocation);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_ToYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FinalYaw                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YawSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_RotateActor_ToYaw(class AActor* TargetActor, float FinalYaw, float YawSpeed, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_RotateActor_ToYaw");

	Params::LActMgrComponent_StartTransformModifier_RotateActor_ToYaw Parms{};

	Parms.TargetActor = TargetActor;
	Parms.FinalYaw = FinalYaw;
	Parms.YawSpeed = YawSpeed;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StartTransformModifier_RotateActor_Tracking
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLTransformModifierInfo_RotateActor_TrackingInfo                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLGameObjectHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLGameObjectHandle ULActMgrComponent::StartTransformModifier_RotateActor_Tracking(class AActor* TargetActor, struct FLTransformModifierInfo_RotateActor_Tracking* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StartTransformModifier_RotateActor_Tracking");

	Params::LActMgrComponent_StartTransformModifier_RotateActor_Tracking Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StopAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Type                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::StopAction(const TSoftClassPtr<class UClass> Type, class ULActBase* ReasonAction, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopAction");

	Params::LActMgrComponent_StopAction Parms{};

	Parms.Type = Type;
	Parms.ReasonAction = ReasonAction;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StopAllAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeDecorateAction                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::StopAllAction(class ULActBase* ReasonAction, class FName Reason, bool IncludeDecorateAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopAllAction");

	Params::LActMgrComponent_StopAllAction Parms{};

	Parms.ReasonAction = ReasonAction;
	Parms.Reason = Reason;
	Parms.IncludeDecorateAction = IncludeDecorateAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StopAllTransformModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CompensationTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::StopAllTransformModifier(float CompensationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopAllTransformModifier");

	Params::LActMgrComponent_StopAllTransformModifier Parms{};

	Parms.CompensationTime = CompensationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StopMeshRotatingOnFloor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RotSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StopImmediate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActMgrComponent::StopMeshRotatingOnFloor(float RotSpeed, bool StopImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopMeshRotatingOnFloor");

	Params::LActMgrComponent_StopMeshRotatingOnFloor Parms{};

	Parms.RotSpeed = RotSpeed;
	Parms.StopImmediate = StopImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.StopSkillMove
// (Final, Native, Public, BlueprintCallable)

void ULActMgrComponent::StopSkillMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopSkillMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StopSyncTransformToTarget
// (Final, Native, Public, BlueprintCallable)

void ULActMgrComponent::StopSyncTransformToTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopSyncTransformToTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.StopTransformModifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CompensationTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::StopTransformModifier(const struct FLGameObjectHandle& Handle, float CompensationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "StopTransformModifier");

	Params::LActMgrComponent_StopTransformModifier Parms{};

	Parms.Handle = std::move(Handle);
	Parms.CompensationTime = CompensationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.UnregisterFxSocketTracerEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)>SocketTraceEvent                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::UnregisterFxSocketTracerEvent(const struct FLGameObjectHandle& Handle, const TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)>& SocketTraceEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "UnregisterFxSocketTracerEvent");

	Params::LActMgrComponent_UnregisterFxSocketTracerEvent Parms{};

	Parms.Handle = std::move(Handle);
	Parms.SocketTraceEvent = SocketTraceEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.UnregisterWatchingCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULActMgrComponent::UnregisterWatchingCommand(const struct FLGameObjectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "UnregisterWatchingCommand");

	Params::LActMgrComponent_UnregisterWatchingCommand Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LActMgrComponent.AleadyInHitGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HitGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::AleadyInHitGroup(class AActor* Victim, int32 HitGroup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "AleadyInHitGroup");

	Params::LActMgrComponent_AleadyInHitGroup Parms{};

	Parms.Victim = Victim;
	Parms.HitGroup = HitGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.CheckLastPlayingActionClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftClassPtr<class UClass>             Type                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::CheckLastPlayingActionClass(const TSoftClassPtr<class UClass> Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "CheckLastPlayingActionClass");

	Params::LActMgrComponent_CheckLastPlayingActionClass Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.FindActionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::FindActionState(class FName State) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "FindActionState");

	Params::LActMgrComponent_FindActionState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.FindActionStateAny
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     StateArray                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::FindActionStateAny(const TArray<class FName>& StateArray) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "FindActionStateAny");

	Params::LActMgrComponent_FindActionStateAny Parms{};

	Parms.StateArray = std::move(StateArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetActionFrameCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULActMgrComponent::GetActionFrameCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetActionFrameCount");

	Params::LActMgrComponent_GetActionFrameCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetComboTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULComboTableBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULComboTableBase* ULActMgrComponent::GetComboTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetComboTable");

	Params::LActMgrComponent_GetComboTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetLastPlayingAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ExceptHitAction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeJustStopped                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExcludeDecorateAction                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludePendingOnStart                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::GetLastPlayingAction(bool ExceptHitAction, bool IncludeJustStopped, bool ExcludeDecorateAction, bool IncludePendingOnStart) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetLastPlayingAction");

	Params::LActMgrComponent_GetLastPlayingAction Parms{};

	Parms.ExceptHitAction = ExceptHitAction;
	Parms.IncludeJustStopped = IncludeJustStopped;
	Parms.ExcludeDecorateAction = ExcludeDecorateAction;
	Parms.IncludePendingOnStart = IncludePendingOnStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetLastPlayingDecorateAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IncludePendingOnStart                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ULActMgrComponent::GetLastPlayingDecorateAction(bool IncludePendingOnStart) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetLastPlayingDecorateAction");

	Params::LActMgrComponent_GetLastPlayingDecorateAction Parms{};

	Parms.IncludePendingOnStart = IncludePendingOnStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetLastPreInputCommand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLReservedCommand                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLReservedCommand ULActMgrComponent::GetLastPreInputCommand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetLastPreInputCommand");

	Params::LActMgrComponent_GetLastPreInputCommand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetSkillTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULActMgrComponent::GetSkillTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetSkillTargetLocation");

	Params::LActMgrComponent_GetSkillTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.GetStandGuardRangeAngle
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   RangeAngleStart                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RangeAngleEnd                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULActMgrComponent::GetStandGuardRangeAngle(int32* RangeAngleStart, int32* RangeAngleEnd) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "GetStandGuardRangeAngle");

	Params::LActMgrComponent_GetStandGuardRangeAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RangeAngleStart != nullptr)
		*RangeAngleStart = Parms.RangeAngleStart;

	if (RangeAngleEnd != nullptr)
		*RangeAngleEnd = Parms.RangeAngleEnd;
}


// Function ProjectP.LActMgrComponent.IsInSkillMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::IsInSkillMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "IsInSkillMove");

	Params::LActMgrComponent_IsInSkillMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.IsTransformModifierActive
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLGameObjectHandle               Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::IsTransformModifierActive(const struct FLGameObjectHandle& Handle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "IsTransformModifierActive");

	Params::LActMgrComponent_IsTransformModifierActive Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LActMgrComponent.IsValidSkillTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULActMgrComponent::IsValidSkillTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LActMgrComponent", "IsValidSkillTarget");

	Params::LActMgrComponent_IsValidSkillTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.AddMoveSpeedRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MoveSpeedRateName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::AddMoveSpeedRate(class FName MoveSpeedRateName, float SpeedRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "AddMoveSpeedRate");

	Params::LAIController_AddMoveSpeedRate Parms{};

	Parms.MoveSpeedRateName = MoveSpeedRateName;
	Parms.SpeedRate = SpeedRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.AddPauseAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PauseName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintain                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::AddPauseAI(class FName PauseName, bool bMaintain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "AddPauseAI");

	Params::LAIController_AddPauseAI Parms{};

	Parms.PauseName = PauseName;
	Parms.bMaintain = bMaintain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.BeginPlayControllerBP
// (Event, Public, BlueprintEvent)

void ALAIController::BeginPlayControllerBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "BeginPlayControllerBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LAIController.CalculatePathLength
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CalculateName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowPartialPaths                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PathLength                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CalculatePathLength(class FName* CalculateName, const struct FVector& StartLocation, const struct FVector& EndLocation, bool bAllowPartialPaths, float* PathLength, struct FVector* DestLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CalculatePathLength");

	Params::LAIController_CalculatePathLength Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.bAllowPartialPaths = bAllowPartialPaths;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CalculateName != nullptr)
		*CalculateName = Parms.CalculateName;

	if (PathLength != nullptr)
		*PathLength = Parms.PathLength;

	if (DestLocation != nullptr)
		*DestLocation = std::move(Parms.DestLocation);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CanReachHome
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CanReachHome()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CanReachHome");

	Params::LAIController_CanReachHome Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CanReachTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAITargetType                          TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CanReachTarget(ELAITargetType TargetType, bool bCheckHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CanReachTarget");

	Params::LAIController_CanReachTarget Parms{};

	Parms.TargetType = TargetType;
	Parms.bCheckHeight = bCheckHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.ChangeBehaviorTreeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InStateName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ChangeBehaviorTreeState(class FName InStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChangeBehaviorTreeState");

	Params::LAIController_ChangeBehaviorTreeState Parms{};

	Parms.InStateName = InStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ChangeBehaviorTreeStateForce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InStateName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ChangeBehaviorTreeStateForce(class FName InStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChangeBehaviorTreeStateForce");

	Params::LAIController_ChangeBehaviorTreeStateForce Parms{};

	Parms.InStateName = InStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ChangeCurrentLocationToHomeLocation
// (Final, Native, Public, BlueprintCallable)

void ALAIController::ChangeCurrentLocationToHomeLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChangeCurrentLocationToHomeLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ChangeExtraState
// (Final, Native, Public, BlueprintCallable)

void ALAIController::ChangeExtraState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChangeExtraState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ChangeMoveSpeedRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ChangeMoveSpeedRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChangeMoveSpeedRate");

	Params::LAIController_ChangeMoveSpeedRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ChangeReverseMoveDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReverse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ChangeReverseMoveDirection(bool bReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChangeReverseMoveDirection");

	Params::LAIController_ChangeReverseMoveDirection Parms{};

	Parms.bReverse = bReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.CheckActionCategoryAndConsume
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELAITargetType                          TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHostileType                           HostileTargetType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetCheckRange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELActionCategory                        CheckActionCategory                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionCategory_AnyCodeName                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckActionCategoryAndConsume(ELAITargetType TargetType, ELHostileType HostileTargetType, float TargetCheckRange, ELActionCategory CheckActionCategory, const class FName& ActionCategory_AnyCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckActionCategoryAndConsume");

	Params::LAIController_CheckActionCategoryAndConsume Parms{};

	Parms.TargetType = TargetType;
	Parms.HostileTargetType = HostileTargetType;
	Parms.TargetCheckRange = TargetCheckRange;
	Parms.CheckActionCategory = CheckActionCategory;
	Parms.ActionCategory_AnyCodeName = ActionCategory_AnyCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckMoveReduced
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ThresholdMoveAmount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HoldingTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckMoveReduced(float ThresholdMoveAmount, float HoldingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckMoveReduced");

	Params::LAIController_CheckMoveReduced Parms{};

	Parms.ThresholdMoveAmount = ThresholdMoveAmount;
	Parms.HoldingTime = HoldingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckOnceCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ConditionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckOnceCondition(class FName ConditionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckOnceCondition");

	Params::LAIController_CheckOnceCondition Parms{};

	Parms.ConditionName = ConditionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckSelectedSkillRangeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CheckActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckType                      OverrideRangeCheckType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckSelectedSkillRangeAngle(class AActor* CheckActor, ELAIRangeMinMaxType MinMaxType, bool bCheckDistance, bool bCheckAngle, bool bCheckHeight, ELAIRangeCheckType OverrideRangeCheckType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckSelectedSkillRangeAngle");

	Params::LAIController_CheckSelectedSkillRangeAngle Parms{};

	Parms.CheckActor = CheckActor;
	Parms.MinMaxType = MinMaxType;
	Parms.bCheckDistance = bCheckDistance;
	Parms.bCheckAngle = bCheckAngle;
	Parms.bCheckHeight = bCheckHeight;
	Parms.OverrideRangeCheckType = OverrideRangeCheckType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckSkillApproachDist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CheckActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDist                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckSkillApproachDist(class AActor* CheckActor, ELAIRangeMinMaxType MinMaxType, float MinDist, float MaxDist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckSkillApproachDist");

	Params::LAIController_CheckSkillApproachDist Parms{};

	Parms.CheckActor = CheckActor;
	Parms.MinMaxType = MinMaxType;
	Parms.MinDist = MinDist;
	Parms.MaxDist = MaxDist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckSkillUseCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAIUseSkillCountType                   UseSkillCountType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckSkillUseCount(ELAIUseSkillCountType UseSkillCountType, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckSkillUseCount");

	Params::LAIController_CheckSkillUseCount Parms{};

	Parms.UseSkillCountType = UseSkillCountType;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckTargetAngleDeviation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DeviationAngle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckTargetAngleDeviation(const struct FVector& TargetLocation, int32 DeviationAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckTargetAngleDeviation");

	Params::LAIController_CheckTargetAngleDeviation Parms{};

	Parms.TargetLocation = std::move(TargetLocation);
	Parms.DeviationAngle = DeviationAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckTargetRangeHeightAngleDist_PrimaryAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeginDegree                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndDegree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CheckHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckType                      RangeCheckType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrimaryTarget_StartAngle                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrimaryTarget_EndAngle                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideTargetToSelf_Angle                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideTargetToSelf_Distance                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckTargetRangeHeightAngleDist_PrimaryAngle(float MinRange, float MaxRange, int32 BeginDegree, int32 EndDegree, float CheckHeight, ELAIRangeCheckType RangeCheckType, float PrimaryTarget_StartAngle, float PrimaryTarget_EndAngle, float OverrideTargetToSelf_Angle, float OverrideTargetToSelf_Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckTargetRangeHeightAngleDist_PrimaryAngle");

	Params::LAIController_CheckTargetRangeHeightAngleDist_PrimaryAngle Parms{};

	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.BeginDegree = BeginDegree;
	Parms.EndDegree = EndDegree;
	Parms.CheckHeight = CheckHeight;
	Parms.RangeCheckType = RangeCheckType;
	Parms.PrimaryTarget_StartAngle = PrimaryTarget_StartAngle;
	Parms.PrimaryTarget_EndAngle = PrimaryTarget_EndAngle;
	Parms.OverrideTargetToSelf_Angle = OverrideTargetToSelf_Angle;
	Parms.OverrideTargetToSelf_Distance = OverrideTargetToSelf_Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckTargetRangeInAround
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAIActorClassType                      ActorClassType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CheckDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHostileType                           TargetHostileType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckTargetRangeInAround(ELAIActorClassType ActorClassType, float CheckDistance, ELHostileType TargetHostileType, class FName TargetCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckTargetRangeInAround");

	Params::LAIController_CheckTargetRangeInAround Parms{};

	Parms.ActorClassType = ActorClassType;
	Parms.CheckDistance = CheckDistance;
	Parms.TargetHostileType = TargetHostileType;
	Parms.TargetCodeName = TargetCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.CheckWorldTriggerVolatile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TriggerName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::CheckWorldTriggerVolatile(const class FString& TriggerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "CheckWorldTriggerVolatile");

	Params::LAIController_CheckWorldTriggerVolatile Parms{};

	Parms.TriggerName = std::move(TriggerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.ChooseUseSkill
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bCheckRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     RangeMinMaxType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLNPCStandbySkill>        CustomSkillList                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bReselectIncludeCooltime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::ChooseUseSkill(bool bCheckRange, bool bCheckAngle, ELAIRangeMinMaxType RangeMinMaxType, const TArray<struct FLNPCStandbySkill>& CustomSkillList, bool bReselectIncludeCooltime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ChooseUseSkill");

	Params::LAIController_ChooseUseSkill Parms{};

	Parms.bCheckRange = bCheckRange;
	Parms.bCheckAngle = bCheckAngle;
	Parms.RangeMinMaxType = RangeMinMaxType;
	Parms.CustomSkillList = std::move(CustomSkillList);
	Parms.bReselectIncludeCooltime = bReselectIncludeCooltime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.ContinueSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSkillCooltime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ContinueSkill(class FName SkillCodeName, bool bUseSkillCooltime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ContinueSkill");

	Params::LAIController_ContinueSkill Parms{};

	Parms.SkillCodeName = SkillCodeName;
	Parms.bUseSkillCooltime = bUseSkillCooltime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.DoTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAITargetType                          LocationTargetType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAITargetType                          DirectionTargetType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFloatInterval                  Distance                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLFloatInterval                  Angle                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ALAIController::DoTeleport(ELAITargetType LocationTargetType, ELAITargetType DirectionTargetType, ELAIDirectionType DirectionType, const struct FLFloatInterval& Distance, const struct FLFloatInterval& Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "DoTeleport");

	Params::LAIController_DoTeleport Parms{};

	Parms.LocationTargetType = LocationTargetType;
	Parms.DirectionTargetType = DirectionTargetType;
	Parms.DirectionType = DirectionType;
	Parms.Distance = std::move(Distance);
	Parms.Angle = std::move(Angle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.EndPlayControllerBP
// (Event, Public, BlueprintEvent)

void ALAIController::EndPlayControllerBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "EndPlayControllerBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LAIController.ExecuteSkillTask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSkillCooltime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGlobalCooltime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckCooltime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckGlobalCooltime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceExecute                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLNPCSkillLaunchResult           OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ALAIController::ExecuteSkillTask(class FName SkillCodeName, bool bUseSkillCooltime, bool bUseGlobalCooltime, bool bCheckCooltime, bool bCheckGlobalCooltime, bool bForceExecute, struct FLNPCSkillLaunchResult* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ExecuteSkillTask");

	Params::LAIController_ExecuteSkillTask Parms{};

	Parms.SkillCodeName = SkillCodeName;
	Parms.bUseSkillCooltime = bUseSkillCooltime;
	Parms.bUseGlobalCooltime = bUseGlobalCooltime;
	Parms.bCheckCooltime = bCheckCooltime;
	Parms.bCheckGlobalCooltime = bCheckGlobalCooltime;
	Parms.bForceExecute = bForceExecute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function ProjectP.LAIController.GetCurrentBehaviorTree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBehaviorTree*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBehaviorTree* ALAIController::GetCurrentBehaviorTree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetCurrentBehaviorTree");

	Params::LAIController_GetCurrentBehaviorTree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetHomeLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALAIController::GetHomeLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetHomeLocation");

	Params::LAIController_GetHomeLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetLastUsedSkillCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALAIController::GetLastUsedSkillCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetLastUsedSkillCodeName");

	Params::LAIController_GetLastUsedSkillCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetMasterActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALAIController::GetMasterActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetMasterActor");

	Params::LAIController_GetMasterActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetNpcInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FNPCInfoPtr                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNPCInfoPtr ALAIController::GetNpcInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetNpcInfo");

	Params::LAIController_GetNpcInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetPrimaryTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALAIController::GetPrimaryTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetPrimaryTarget");

	Params::LAIController_GetPrimaryTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetRandomPointInStrafe
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RandomLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::GetRandomPointInStrafe(class AActor* TargetActor, float MinDistance, float MaxDistance, float MinAngle, float MaxAngle, struct FVector* RandomLocation, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetRandomPointInStrafe");

	Params::LAIController_GetRandomPointInStrafe Parms{};

	Parms.TargetActor = TargetActor;
	Parms.MinDistance = MinDistance;
	Parms.MaxDistance = MaxDistance;
	Parms.MinAngle = MinAngle;
	Parms.MaxAngle = MaxAngle;
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RandomLocation != nullptr)
		*RandomLocation = std::move(Parms.RandomLocation);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetSelectedSkillCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALAIController::GetSelectedSkillCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetSelectedSkillCodeName");

	Params::LAIController_GetSelectedSkillCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetWarningLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALAIController::GetWarningLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetWarningLocation");

	Params::LAIController_GetWarningLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.HasMoveGoalReached
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAIMovementGoal                 Goal                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bProjectPoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustumAcceptibleRadius                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::HasMoveGoalReached(const struct FLAIMovementGoal& Goal, bool bProjectPoint, float CustumAcceptibleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "HasMoveGoalReached");

	Params::LAIController_HasMoveGoalReached Parms{};

	Parms.Goal = std::move(Goal);
	Parms.bProjectPoint = bProjectPoint;
	Parms.CustumAcceptibleRadius = CustumAcceptibleRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.HasMoveReached
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAIObjective                    Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bProjectPoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustumAcceptibleRadius                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::HasMoveReached(const struct FLAIObjective& Target, bool bProjectPoint, float CustumAcceptibleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "HasMoveReached");

	Params::LAIController_HasMoveReached Parms{};

	Parms.Target = std::move(Target);
	Parms.bProjectPoint = bProjectPoint;
	Parms.CustumAcceptibleRadius = CustumAcceptibleRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.InitBehaviorTree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBehaviorTree*                    BTree                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::InitBehaviorTree(class UBehaviorTree* BTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "InitBehaviorTree");

	Params::LAIController_InitBehaviorTree Parms{};

	Parms.BTree = BTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.InitBehaviorTreeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InStateName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::InitBehaviorTreeState(class FName InStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "InitBehaviorTreeState");

	Params::LAIController_InitBehaviorTreeState Parms{};

	Parms.InStateName = InStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.InitStartAI
// (Final, Native, Public, BlueprintCallable)

void ALAIController::InitStartAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "InitStartAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.IsApplyBoostAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsApplyBoostAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsApplyBoostAI");

	Params::LAIController_IsApplyBoostAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsExistDamageEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsExistDamageEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsExistDamageEvent");

	Params::LAIController_IsExistDamageEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsLaunchSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULActBase*                        Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsLaunchSkill(class ULActBase* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsLaunchSkill");

	Params::LAIController_IsLaunchSkill Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsPathWayMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsPathWayMoving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsPathWayMoving");

	Params::LAIController_IsPathWayMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsSkillCooltime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsSkillCooltime(class FName SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsSkillCooltime");

	Params::LAIController_IsSkillCooltime Parms{};

	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsSkillGlobalCooltime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsSkillGlobalCooltime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsSkillGlobalCooltime");

	Params::LAIController_IsSkillGlobalCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsStrafeMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsStrafeMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsStrafeMove");

	Params::LAIController_IsStrafeMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsWaitOrFinishWayPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsWaitOrFinishWayPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsWaitOrFinishWayPoint");

	Params::LAIController_IsWaitOrFinishWayPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.ManipulateTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TimerCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAITimerFunctionType                   FunctionType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ManipulateTimer(class FName TimerCodeName, ELAITimerFunctionType FunctionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ManipulateTimer");

	Params::LAIController_ManipulateTimer Parms{};

	Parms.TimerCodeName = TimerCodeName;
	Parms.FunctionType = FunctionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ModifyCooltime
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELModifyCooltimeChangeType              ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELModifyCooltimeTargetType              TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     SkillCodeNames                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bExceptSkillCodeNames                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIFloatValueType                      ValueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CoolTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::ModifyCooltime(ELModifyCooltimeChangeType ChangeType, ELModifyCooltimeTargetType TargetType, const TArray<class FName>& SkillCodeNames, bool bExceptSkillCodeNames, ELAIFloatValueType ValueType, float CoolTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ModifyCooltime");

	Params::LAIController_ModifyCooltime Parms{};

	Parms.ChangeType = ChangeType;
	Parms.TargetType = TargetType;
	Parms.SkillCodeNames = std::move(SkillCodeNames);
	Parms.bExceptSkillCodeNames = bExceptSkillCodeNames;
	Parms.ValueType = ValueType;
	Parms.CoolTime = CoolTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.MoveToGoal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementID                   CurrMovementID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIMovementGoal                 Goal                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIMovementDirection            Direction                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIMovementID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementID ALAIController::MoveToGoal(const struct FLAIMovementID& CurrMovementID, const struct FLAIMovementGoal& Goal, const struct FLAIMovementDirection& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToGoal");

	Params::LAIController_MoveToGoal Parms{};

	Parms.CurrMovementID = std::move(CurrMovementID);
	Parms.Goal = std::move(Goal);
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementGoal                 Goal                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   RotationRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseTurnAround                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RotateAngleOverride                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIMoveSpeedType                       MoveSpeedType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationCooltime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMoveBehaviorID               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMoveBehaviorID ALAIController::MoveToPosition(const struct FLAIMovementGoal& Goal, float RotationRate, bool bUseTurnAround, int32 RotateAngleOverride, ELAIMoveSpeedType MoveSpeedType, float MoveSpeed, float RotationCooltime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToPosition");

	Params::LAIController_MoveToPosition Parms{};

	Parms.Goal = std::move(Goal);
	Parms.RotationRate = RotationRate;
	Parms.bUseTurnAround = bUseTurnAround;
	Parms.RotateAngleOverride = RotateAngleOverride;
	Parms.MoveSpeedType = MoveSpeedType;
	Parms.MoveSpeed = MoveSpeed;
	Parms.RotationCooltime = RotationCooltime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToPositionBack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementGoal                 Goal                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   RotationRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIMoveSpeedType                       MoveSpeedType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMoveBehaviorID               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMoveBehaviorID ALAIController::MoveToPositionBack(const struct FLAIMovementGoal& Goal, float RotationRate, ELAIMoveSpeedType MoveSpeedType, float MoveSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToPositionBack");

	Params::LAIController_MoveToPositionBack Parms{};

	Parms.Goal = std::move(Goal);
	Parms.RotationRate = RotationRate;
	Parms.MoveSpeedType = MoveSpeedType;
	Parms.MoveSpeed = MoveSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToRandomRoamSelf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementID                   CurrMovementID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ELAIDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementID ALAIController::MoveToRandomRoamSelf(const struct FLAIMovementID& CurrMovementID, ELAIDirectionType DirectionType, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToRandomRoamSelf");

	Params::LAIController_MoveToRandomRoamSelf Parms{};

	Parms.CurrMovementID = std::move(CurrMovementID);
	Parms.DirectionType = DirectionType;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToRandomRoamStrafe
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementID                   CurrMovementID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ELAIDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementID ALAIController::MoveToRandomRoamStrafe(const struct FLAIMovementID& CurrMovementID, ELAIDirectionType DirectionType, class AActor* TargetActor, float MinDistance, float MaxDistance, float MinAngle, float MaxAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToRandomRoamStrafe");

	Params::LAIController_MoveToRandomRoamStrafe Parms{};

	Parms.CurrMovementID = std::move(CurrMovementID);
	Parms.DirectionType = DirectionType;
	Parms.TargetActor = TargetActor;
	Parms.MinDistance = MinDistance;
	Parms.MaxDistance = MaxDistance;
	Parms.MinAngle = MinAngle;
	Parms.MaxAngle = MaxAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToSkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementID                   CurrMovementID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ELAITargetType                          TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementID ALAIController::MoveToSkill(const struct FLAIMovementID& CurrMovementID, ELAITargetType TargetType, ELAIDirectionType DirectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToSkill");

	Params::LAIController_MoveToSkill Parms{};

	Parms.CurrMovementID = std::move(CurrMovementID);
	Parms.TargetType = TargetType;
	Parms.DirectionType = DirectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToStrafe
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAIMoveDirection                       MoveDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIMoveSpeedType                       MoveSpeedType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMoveBehaviorID               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMoveBehaviorID ALAIController::MoveToStrafe(ELAIMoveDirection MoveDirection, float MoveTime, ELAIMoveSpeedType MoveSpeedType, float MoveSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToStrafe");

	Params::LAIController_MoveToStrafe Parms{};

	Parms.MoveDirection = MoveDirection;
	Parms.MoveTime = MoveTime;
	Parms.MoveSpeedType = MoveSpeedType;
	Parms.MoveSpeed = MoveSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.MoveToType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLAIMovementID                   CurrMovementID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ELAITargetType                          TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementID ALAIController::MoveToType(const struct FLAIMovementID& CurrMovementID, ELAITargetType TargetType, ELAIDirectionType DirectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "MoveToType");

	Params::LAIController_MoveToType Parms{};

	Parms.CurrMovementID = std::move(CurrMovementID);
	Parms.TargetType = TargetType;
	Parms.DirectionType = DirectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.OnMovementNavigationQueryFilter
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::OnMovementNavigationQueryFilter(TSubclassOf<class UNavigationQueryFilter>* FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "OnMovementNavigationQueryFilter");

	Params::LAIController_OnMovementNavigationQueryFilter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FilterClass != nullptr)
		*FilterClass = Parms.FilterClass;
}


// Function ProjectP.LAIController.QueryTargetCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELQueryTargetConditionType              ConditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::QueryTargetCondition(ELQueryTargetConditionType ConditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "QueryTargetCondition");

	Params::LAIController_QueryTargetCondition Parms{};

	Parms.ConditionType = ConditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.RemoveMoveSpeedRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MoveSpeedRateName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::RemoveMoveSpeedRate(class FName MoveSpeedRateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "RemoveMoveSpeedRate");

	Params::LAIController_RemoveMoveSpeedRate Parms{};

	Parms.MoveSpeedRateName = MoveSpeedRateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.RemovePauseAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PauseName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintain                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::RemovePauseAI(class FName PauseName, bool bMaintain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "RemovePauseAI");

	Params::LAIController_RemovePauseAI Parms{};

	Parms.PauseName = PauseName;
	Parms.bMaintain = bMaintain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.RequestMoveToWayPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PathWayCodeName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RotateActionDeviationAngle                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIMoveSpeedType                       MoveSpeedType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveSpeedRate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::RequestMoveToWayPoint(class FName PathWayCodeName, int32 RotateActionDeviationAngle, ELAIMoveSpeedType MoveSpeedType, float MoveSpeedRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "RequestMoveToWayPoint");

	Params::LAIController_RequestMoveToWayPoint Parms{};

	Parms.PathWayCodeName = PathWayCodeName;
	Parms.RotateActionDeviationAngle = RotateActionDeviationAngle;
	Parms.MoveSpeedType = MoveSpeedType;
	Parms.MoveSpeedRate = MoveSpeedRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ResetSelectedSkill
// (Final, Native, Public, BlueprintCallable)

void ALAIController::ResetSelectedSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ResetSelectedSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.ResetTarget
// (Final, Native, Public, BlueprintCallable)

void ALAIController::ResetTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "ResetTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SendWorldTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAISendWorldTriggerType                TriggerType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TriggerString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SendRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NPCCodeName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::SendWorldTrigger(ELAISendWorldTriggerType TriggerType, const class FString& TriggerString, float SendRadius, class FName NPCCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SendWorldTrigger");

	Params::LAIController_SendWorldTrigger Parms{};

	Parms.TriggerType = TriggerType;
	Parms.TriggerString = std::move(TriggerString);
	Parms.SendRadius = SendRadius;
	Parms.NPCCodeName = NPCCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SenseEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAISenseTakeLocation            TakeLocation                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALAIController::SenseEvent(const struct FLAISenseTakeLocation& TakeLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SenseEvent");

	Params::LAIController_SenseEvent Parms{};

	Parms.TakeLocation = std::move(TakeLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SetForcePrimaryTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::SetForcePrimaryTarget(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SetForcePrimaryTarget");

	Params::LAIController_SetForcePrimaryTarget Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SetRotationCooltime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CoolTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::SetRotationCooltime(float CoolTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SetRotationCooltime");

	Params::LAIController_SetRotationCooltime Parms{};

	Parms.CoolTime = CoolTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SetSenseEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAISense                               Sense                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::SetSenseEnabled(ELAISense Sense, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SetSenseEnabled");

	Params::LAIController_SetSenseEnabled Parms{};

	Parms.Sense = Sense;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SetSkillGlobalCooltime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::SetSkillGlobalCooltime(float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SetSkillGlobalCooltime");

	Params::LAIController_SetSkillGlobalCooltime Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.SetSkillList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FLNPCStandbySkill>        SkillList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bResetSkillCooltime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALAIController::SetSkillList(const TArray<struct FLNPCStandbySkill>& SkillList, bool bResetSkillCooltime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "SetSkillList");

	Params::LAIController_SetSkillList Parms{};

	Parms.SkillList = std::move(SkillList);
	Parms.bResetSkillCooltime = bResetSkillCooltime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.Sight_Check
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AddSightDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::Sight_Check(class AActor* Actor, float AddSightDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "Sight_Check");

	Params::LAIController_Sight_Check Parms{};

	Parms.Actor = Actor;
	Parms.AddSightDistance = AddSightDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.StartAI
// (Native, Public, BlueprintCallable)

void ALAIController::StartAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "StartAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.StopAI
// (Native, Public, BlueprintCallable)

void ALAIController::StopAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "StopAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.StopLastMovement
// (Final, Native, Public, BlueprintCallable)

void ALAIController::StopLastMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "StopLastMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.UnChangeExtraState
// (Final, Native, Public, BlueprintCallable)

void ALAIController::UnChangeExtraState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "UnChangeExtraState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.UpdatePauseLogic
// (Final, Native, Public, BlueprintCallable)

void ALAIController::UpdatePauseLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "UpdatePauseLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIController.UseSkill
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSkillCooltime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGlobalCooltime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceToLaunch                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLNPCSkillLaunchResult           OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ALAIController::UseSkill(class FName SkillId, bool bUseSkillCooltime, bool bUseGlobalCooltime, bool bForceToLaunch, struct FLNPCSkillLaunchResult* OutResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "UseSkill");

	Params::LAIController_UseSkill Parms{};

	Parms.SkillId = SkillId;
	Parms.bUseSkillCooltime = bUseSkillCooltime;
	Parms.bUseGlobalCooltime = bUseGlobalCooltime;
	Parms.bForceToLaunch = bForceToLaunch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function ProjectP.LAIController.UseSkillForce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSkillCooltime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGlobalCooltime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALAIController::UseSkillForce(class FName SkillId, bool bUseSkillCooltime, bool bUseGlobalCooltime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "UseSkillForce");

	Params::LAIController_UseSkillForce Parms{};

	Parms.SkillId = SkillId;
	Parms.bUseSkillCooltime = bUseSkillCooltime;
	Parms.bUseGlobalCooltime = bUseGlobalCooltime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.FindPause
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             PauseName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::FindPause(class FName PauseName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "FindPause");

	Params::LAIController_FindPause Parms{};

	Parms.PauseName = PauseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.FindPauseMetaName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MetaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::FindPauseMetaName(class FName MetaName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "FindPauseMetaName");

	Params::LAIController_FindPauseMetaName Parms{};

	Parms.MetaName = MetaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.FindPauseOnlyMetaName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MetaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::FindPauseOnlyMetaName(class FName MetaName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "FindPauseOnlyMetaName");

	Params::LAIController_FindPauseOnlyMetaName Parms{};

	Parms.MetaName = MetaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetElapsedTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TimerCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALAIController::GetElapsedTimer(class FName TimerCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetElapsedTimer");

	Params::LAIController_GetElapsedTimer Parms{};

	Parms.TimerCodeName = TimerCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetGlobalSkillCooltime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALAIController::GetGlobalSkillCooltime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetGlobalSkillCooltime");

	Params::LAIController_GetGlobalSkillCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetLastMoveDestLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALAIController::GetLastMoveDestLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetLastMoveDestLocation");

	Params::LAIController_GetLastMoveDestLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetLastMovementID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLAIMovementID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementID ALAIController::GetLastMovementID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetLastMovementID");

	Params::LAIController_GetLastMovementID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetNavData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ANavigationData*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ANavigationData* ALAIController::GetNavData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetNavData");

	Params::LAIController_GetNavData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetRotationCooltime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALAIController::GetRotationCooltime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetRotationCooltime");

	Params::LAIController_GetRotationCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetSelectedSkillApproachDist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALAIController::GetSelectedSkillApproachDist() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetSelectedSkillApproachDist");

	Params::LAIController_GetSelectedSkillApproachDist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetSkillCooltimes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<class FName, float>          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<class FName, float> ALAIController::GetSkillCooltimes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetSkillCooltimes");

	Params::LAIController_GetSkillCooltimes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetSkillTargetLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::GetSkillTargetLocation(struct FVector* Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetSkillTargetLocation");

	Params::LAIController_GetSkillTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.GetTargetNearAllyNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bCheckDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALAIController::GetTargetNearAllyNum(bool bCheckDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "GetTargetNearAllyNum");

	Params::LAIController_GetTargetNearAllyNum Parms{};

	Parms.bCheckDistance = bCheckDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsMasterExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsMasterExist() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsMasterExist");

	Params::LAIController_IsMasterExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsMoveBlocking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsMoveBlocking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsMoveBlocking");

	Params::LAIController_IsMoveBlocking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsMoving");

	Params::LAIController_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsPauseAI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsPauseAI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsPauseAI");

	Params::LAIController_IsPauseAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsRequestMovement
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLAIMovementID                   MovementID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsRequestMovement(const struct FLAIMovementID& MovementID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsRequestMovement");

	Params::LAIController_IsRequestMovement Parms{};

	Parms.MovementID = std::move(MovementID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsRunningAI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsRunningAI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsRunningAI");

	Params::LAIController_IsRunningAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsRunningMoveBehavior
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLAIMoveBehaviorID               BehaviorID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsRunningMoveBehavior(const struct FLAIMoveBehaviorID& BehaviorID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsRunningMoveBehavior");

	Params::LAIController_IsRunningMoveBehavior Parms{};

	Parms.BehaviorID = std::move(BehaviorID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsSkillMoveApproachDistReached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsSkillMoveApproachDistReached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsSkillMoveApproachDistReached");

	Params::LAIController_IsSkillMoveApproachDistReached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsTargetExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsTargetExist() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsTargetExist");

	Params::LAIController_IsTargetExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsTicketMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsTicketMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsTicketMove");

	Params::LAIController_IsTicketMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIController.IsWarningExist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALAIController::IsWarningExist() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAIController", "IsWarningExist");

	Params::LAIController_IsWarningExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.AddPauseAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PauseName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintain                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::AddPauseAI(class AActor* Actor, class FName PauseName, bool bMaintain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "AddPauseAI");

	Params::LAIUtilFuncLibrary_AddPauseAI Parms{};

	Parms.Actor = Actor;
	Parms.PauseName = PauseName;
	Parms.bMaintain = bMaintain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIUtilFuncLibrary.CanMoveToLocation_Nav
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CanMoveToLocation_Nav(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, struct FVector* HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CanMoveToLocation_Nav");

	Params::LAIUtilFuncLibrary_CanMoveToLocation_Nav Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CanMoveToLocation_Trace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSubtractTargetCapsuleSize                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CanMoveToLocation_Trace(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, bool bSubtractTargetCapsuleSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CanMoveToLocation_Trace");

	Params::LAIUtilFuncLibrary_CanMoveToLocation_Trace Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.bSubtractTargetCapsuleSize = bSubtractTargetCapsuleSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckAngleBetween
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CriterionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CriterionRotation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeginDegree                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndDegree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckAngleBetween(const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, const struct FVector& TargetLocation, int32 BeginDegree, int32 EndDegree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckAngleBetween");

	Params::LAIUtilFuncLibrary_CheckAngleBetween Parms{};

	Parms.CriterionLocation = std::move(CriterionLocation);
	Parms.CriterionRotation = std::move(CriterionRotation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.BeginDegree = BeginDegree;
	Parms.EndDegree = EndDegree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckAngleBetweenActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeginDegree                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndDegree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckAngleBetweenActor(class AActor* CriterionActor, class AActor* TargetActor, int32 BeginDegree, int32 EndDegree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckAngleBetweenActor");

	Params::LAIUtilFuncLibrary_CheckAngleBetweenActor Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.TargetActor = TargetActor;
	Parms.BeginDegree = BeginDegree;
	Parms.EndDegree = EndDegree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckAngleBetweenDeviation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CriterionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CriterionRotation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DeviationAngle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckAngleBetweenDeviation(const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, const struct FVector& TargetLocation, int32 DeviationAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckAngleBetweenDeviation");

	Params::LAIUtilFuncLibrary_CheckAngleBetweenDeviation Parms{};

	Parms.CriterionLocation = std::move(CriterionLocation);
	Parms.CriterionRotation = std::move(CriterionRotation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.DeviationAngle = DeviationAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckBackSideLocation2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AroundActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckBackSideLocation2D(class AActor* CriterionActor, class AActor* AroundActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckBackSideLocation2D");

	Params::LAIUtilFuncLibrary_CheckBackSideLocation2D Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.AroundActor = AroundActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckEnemyAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           EnemyActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckEnemyAttack(class AActor* EnemyActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckEnemyAttack");

	Params::LAIUtilFuncLibrary_CheckEnemyAttack Parms{};

	Parms.EnemyActor = EnemyActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckHostileType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHostileType                           HostileType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckHostileType(class AActor* CriterionActor, class AActor* TargetActor, ELHostileType HostileType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckHostileType");

	Params::LAIUtilFuncLibrary_CheckHostileType Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.TargetActor = TargetActor;
	Parms.HostileType = HostileType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckInCameraView
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckInCameraView(class AActor* Target, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckInCameraView");

	Params::LAIUtilFuncLibrary_CheckInCameraView Parms{};

	Parms.Target = Target;
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckInsideDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          P1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          P2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InsideLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckInsideDistance(const struct FVector& P1, const struct FVector& P2, float InsideLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckInsideDistance");

	Params::LAIUtilFuncLibrary_CheckInsideDistance Parms{};

	Parms.P1 = std::move(P1);
	Parms.P2 = std::move(P2);
	Parms.InsideLength = InsideLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckInsideDistance2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          P1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          P2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InsideLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckInsideDistance2D(const struct FVector& P1, const struct FVector& P2, float InsideLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckInsideDistance2D");

	Params::LAIUtilFuncLibrary_CheckInsideDistance2D Parms{};

	Parms.P1 = std::move(P1);
	Parms.P2 = std::move(P2);
	Parms.InsideLength = InsideLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckInsideDistance2DAndHeight
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          P1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          P2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InsideLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InsideHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckInsideDistance2DAndHeight(const struct FVector& P1, const struct FVector& P2, float InsideLength, float InsideHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckInsideDistance2DAndHeight");

	Params::LAIUtilFuncLibrary_CheckInsideDistance2DAndHeight Parms{};

	Parms.P1 = std::move(P1);
	Parms.P2 = std::move(P2);
	Parms.InsideLength = InsideLength;
	Parms.InsideHeight = InsideHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckInsidePathDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AroundActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InsideLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CacheName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckInsidePathDistance(class AActor* CriterionActor, class AActor* AroundActor, float InsideLength, class FName CacheName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckInsidePathDistance");

	Params::LAIUtilFuncLibrary_CheckInsidePathDistance Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.AroundActor = AroundActor;
	Parms.InsideLength = InsideLength;
	Parms.CacheName = CacheName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckMoveHeight
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceDelta                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckMoveHeight(class ALCharacter* Character, const struct FVector& TraceDelta, bool bDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckMoveHeight");

	Params::LAIUtilFuncLibrary_CheckMoveHeight Parms{};

	Parms.Character = Character;
	Parms.TraceDelta = std::move(TraceDelta);
	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckPathDirect(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckPathDirect");

	Params::LAIUtilFuncLibrary_CheckPathDirect Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirectNavi
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckPathDirectNavi(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckPathDirectNavi");

	Params::LAIUtilFuncLibrary_CheckPathDirectNavi Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirectNavi_Lagacy
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckPathDirectNavi_Lagacy(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckPathDirectNavi_Lagacy");

	Params::LAIUtilFuncLibrary_CheckPathDirectNavi_Lagacy Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckPathDirectProjectile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckPathDirectProjectile(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckPathDirectProjectile");

	Params::LAIUtilFuncLibrary_CheckPathDirectProjectile Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckPathNavi
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckPathNavi(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckPathNavi");

	Params::LAIUtilFuncLibrary_CheckPathNavi Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckRangeAngleBetween
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CriterionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CriterionRotation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeginDegree                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndDegree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckRangeAngleBetween(const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, const struct FVector& TargetLocation, float MinRange, float MaxRange, int32 BeginDegree, int32 EndDegree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckRangeAngleBetween");

	Params::LAIUtilFuncLibrary_CheckRangeAngleBetween Parms{};

	Parms.CriterionLocation = std::move(CriterionLocation);
	Parms.CriterionRotation = std::move(CriterionRotation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.BeginDegree = BeginDegree;
	Parms.EndDegree = EndDegree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckRangeBetween
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CriterionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckRangeBetween(const struct FVector& CriterionLocation, const struct FVector& TargetLocation, float MinRange, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckRangeBetween");

	Params::LAIUtilFuncLibrary_CheckRangeBetween Parms{};

	Parms.CriterionLocation = std::move(CriterionLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckRangeBetweenActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckRangeBetweenActor(class AActor* CriterionActor, class AActor* TargetActor, float MinRange, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckRangeBetweenActor");

	Params::LAIUtilFuncLibrary_CheckRangeBetweenActor Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.TargetActor = TargetActor;
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckTargetAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeginDegree                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndDegree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckTargetAngle(const struct FLAICheckOwner& CheckOwner, const struct FVector& TargetLocation, int32 BeginDegree, int32 EndDegree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckTargetAngle");

	Params::LAIUtilFuncLibrary_CheckTargetAngle Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.BeginDegree = BeginDegree;
	Parms.EndDegree = EndDegree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckTargetHeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckTargetHeight(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckTargetHeight");

	Params::LAIUtilFuncLibrary_CheckTargetHeight Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckTargetRangeHeightAngleDist
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CheckHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BeginDegree                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndDegree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckType                      RangeCheckType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckTargetRangeHeightAngleDist(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float CheckHeight, int32 BeginDegree, int32 EndDegree, float MinRange, float MaxRange, ELAIRangeCheckType RangeCheckType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckTargetRangeHeightAngleDist");

	Params::LAIUtilFuncLibrary_CheckTargetRangeHeightAngleDist Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.CheckHeight = CheckHeight;
	Parms.BeginDegree = BeginDegree;
	Parms.EndDegree = EndDegree;
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.RangeCheckType = RangeCheckType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CheckTargetRangeType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ELAIRangeCheckType                      RangeCheckType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CheckTargetRangeType(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, ELAIRangeCheckType RangeCheckType, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CheckTargetRangeType");

	Params::LAIUtilFuncLibrary_CheckTargetRangeType Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.RangeCheckType = RangeCheckType;
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.CollideCeiling
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CheckHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::CollideCeiling(const struct FLAICheckOwner& CheckOwner, float CheckHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "CollideCeiling");

	Params::LAIUtilFuncLibrary_CollideCeiling Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckHeight = CheckHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.DirectionAsActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementDirection            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementDirection ULAIUtilFuncLibrary::DirectionAsActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "DirectionAsActor");

	Params::LAIUtilFuncLibrary_DirectionAsActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.DirectionAsLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementDirection            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementDirection ULAIUtilFuncLibrary::DirectionAsLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "DirectionAsLocation");

	Params::LAIUtilFuncLibrary_DirectionAsLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.DirectionAsType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALAIController*                   Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIDirectionType                       DirectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementDirection            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementDirection ULAIUtilFuncLibrary::DirectionAsType(class ALAIController* Controller, ELAIDirectionType DirectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "DirectionAsType");

	Params::LAIUtilFuncLibrary_DirectionAsType Parms{};

	Parms.Controller = Controller;
	Parms.DirectionType = DirectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.EmptyMovementID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAIMovementID                   MovementID                                             (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::EmptyMovementID(struct FLAIMovementID& MovementID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "EmptyMovementID");

	Params::LAIUtilFuncLibrary_EmptyMovementID Parms{};

	Parms.MovementID = std::move(MovementID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MovementID = std::move(Parms.MovementID);
}


// Function ProjectP.LAIUtilFuncLibrary.GetAgentDeltaLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::GetAgentDeltaLocation(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetAgentDeltaLocation");

	Params::LAIUtilFuncLibrary_GetAgentDeltaLocation Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetAIController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCController*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALNPCController* ULAIUtilFuncLibrary::GetAIController(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetAIController");

	Params::LAIUtilFuncLibrary_GetAIController Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetAIEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::GetAIEnabled(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetAIEnabled");

	Params::LAIUtilFuncLibrary_GetAIEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetBlackboardValueAsLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBTNode*                          NodeOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBlackboardKeySelector           Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::GetBlackboardValueAsLocation(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetBlackboardValueAsLocation");

	Params::LAIUtilFuncLibrary_GetBlackboardValueAsLocation Parms{};

	Parms.NodeOwner = NodeOwner;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetRandomInInterval
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLFloatInterval                  Interval                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULAIUtilFuncLibrary::GetRandomInInterval(const struct FLFloatInterval& Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetRandomInInterval");

	Params::LAIUtilFuncLibrary_GetRandomInInterval Parms{};

	Parms.Interval = std::move(Interval);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAILocationSampler              Sampler                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::GetRandomLocation(struct FLAILocationSampler& Sampler, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetRandomLocation");

	Params::LAIUtilFuncLibrary_GetRandomLocation Parms{};

	Parms.Sampler = std::move(Sampler);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Sampler = std::move(Parms.Sampler);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocationCriterionDistanceAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAILocationSampler              Sampler                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CriterionLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CriterionRotation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BeginAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::GetRandomLocationCriterionDistanceAngle(struct FLAILocationSampler& Sampler, struct FVector* Location, const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, float MinDistance, float MaxDistance, float BeginAngle, float EndAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetRandomLocationCriterionDistanceAngle");

	Params::LAIUtilFuncLibrary_GetRandomLocationCriterionDistanceAngle Parms{};

	Parms.Sampler = std::move(Sampler);
	Parms.CriterionLocation = std::move(CriterionLocation);
	Parms.CriterionRotation = std::move(CriterionRotation);
	Parms.MinDistance = MinDistance;
	Parms.MaxDistance = MaxDistance;
	Parms.BeginAngle = BeginAngle;
	Parms.EndAngle = EndAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Sampler = std::move(Parms.Sampler);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocationInDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAILocationSampler              Sampler                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::GetRandomLocationInDistance(struct FLAILocationSampler& Sampler, struct FVector* Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetRandomLocationInDistance");

	Params::LAIUtilFuncLibrary_GetRandomLocationInDistance Parms{};

	Parms.Sampler = std::move(Sampler);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Sampler = std::move(Parms.Sampler);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetRandomLocationTargetBaseDistanceAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAILocationSampler              Sampler                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIObjective                    Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BeginAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::GetRandomLocationTargetBaseDistanceAngle(struct FLAILocationSampler& Sampler, struct FVector* Location, const struct FLAIObjective& Target, float MinDistance, float MaxDistance, float BeginAngle, float EndAngle, float TraceHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetRandomLocationTargetBaseDistanceAngle");

	Params::LAIUtilFuncLibrary_GetRandomLocationTargetBaseDistanceAngle Parms{};

	Parms.Sampler = std::move(Sampler);
	Parms.Target = std::move(Target);
	Parms.MinDistance = MinDistance;
	Parms.MaxDistance = MaxDistance;
	Parms.BeginAngle = BeginAngle;
	Parms.EndAngle = EndAngle;
	Parms.TraceHeight = TraceHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Sampler = std::move(Parms.Sampler);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetReachedCylinderExtent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OwnerRadiusScaleFactor                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::GetReachedCylinderExtent(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float OwnerRadiusScaleFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetReachedCylinderExtent");

	Params::LAIUtilFuncLibrary_GetReachedCylinderExtent Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.OwnerRadiusScaleFactor = OwnerRadiusScaleFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetTraceCharacterMoveObstacleStartLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::GetTraceCharacterMoveObstacleStartLocation(class ALCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetTraceCharacterMoveObstacleStartLocation");

	Params::LAIUtilFuncLibrary_GetTraceCharacterMoveObstacleStartLocation Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GetTraceStartEndLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartTrace                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndTrace                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIObjective                    StartActor                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    EndActor                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::GetTraceStartEndLocation(struct FVector* StartTrace, struct FVector* EndTrace, const struct FLAIObjective& StartActor, const struct FLAIObjective& EndActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GetTraceStartEndLocation");

	Params::LAIUtilFuncLibrary_GetTraceStartEndLocation Parms{};

	Parms.StartActor = std::move(StartActor);
	Parms.EndActor = std::move(EndActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StartTrace != nullptr)
		*StartTrace = std::move(Parms.StartTrace);

	if (EndTrace != nullptr)
		*EndTrace = std::move(Parms.EndTrace);
}


// Function ProjectP.LAIUtilFuncLibrary.GoalAsActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementGoal                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementGoal ULAIUtilFuncLibrary::GoalAsActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GoalAsActor");

	Params::LAIUtilFuncLibrary_GoalAsActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GoalAsLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementGoal                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementGoal ULAIUtilFuncLibrary::GoalAsLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GoalAsLocation");

	Params::LAIUtilFuncLibrary_GoalAsLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.GoalAsType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALAIController*                   Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAITargetType                          TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIMovementGoal                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIMovementGoal ULAIUtilFuncLibrary::GoalAsType(class ALAIController* Controller, ELAITargetType TargetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "GoalAsType");

	Params::LAIUtilFuncLibrary_GoalAsType Parms{};

	Parms.Controller = Controller;
	Parms.TargetType = TargetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.IsAttackable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::IsAttackable(class AActor* CriterionActor, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "IsAttackable");

	Params::LAIUtilFuncLibrary_IsAttackable Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.IsEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::IsEnemy(class AActor* CriterionActor, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "IsEnemy");

	Params::LAIUtilFuncLibrary_IsEnemy Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.IsEnemyFaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFactionType                            CritrionFaction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFactionType                            TargetFaction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::IsEnemyFaction(EFactionType CritrionFaction, EFactionType TargetFaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "IsEnemyFaction");

	Params::LAIUtilFuncLibrary_IsEnemyFaction Parms{};

	Parms.CritrionFaction = CritrionFaction;
	Parms.TargetFaction = TargetFaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.IsInsideCylinder
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CylinderExtent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CylinderOrigin                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::IsInsideCylinder(const struct FVector& CylinderExtent, const struct FVector& CylinderOrigin, const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "IsInsideCylinder");

	Params::LAIUtilFuncLibrary_IsInsideCylinder Parms{};

	Parms.CylinderExtent = std::move(CylinderExtent);
	Parms.CylinderOrigin = std::move(CylinderOrigin);
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.IsMonsterFactionActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::IsMonsterFactionActor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "IsMonsterFactionActor");

	Params::LAIUtilFuncLibrary_IsMonsterFactionActor Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementDirection            MovementDirection                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULAIUtilFuncLibrary::MovementDirectionGetActor(const struct FLAIMovementDirection& MovementDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementDirectionGetActor");

	Params::LAIUtilFuncLibrary_MovementDirectionGetActor Parms{};

	Parms.MovementDirection = std::move(MovementDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementDirection            MovementDirection                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ALCharacter*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCharacter* ULAIUtilFuncLibrary::MovementDirectionGetCharacter(const struct FLAIMovementDirection& MovementDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementDirectionGetCharacter");

	Params::LAIUtilFuncLibrary_MovementDirectionGetCharacter Parms{};

	Parms.MovementDirection = std::move(MovementDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementDirection            MovementDirection                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::MovementDirectionGetLocation(const struct FLAIMovementDirection& MovementDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementDirectionGetLocation");

	Params::LAIUtilFuncLibrary_MovementDirectionGetLocation Parms{};

	Parms.MovementDirection = std::move(MovementDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionGetRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementDirection            MovementDirection                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULAIUtilFuncLibrary::MovementDirectionGetRotation(const struct FLAIMovementDirection& MovementDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementDirectionGetRotation");

	Params::LAIUtilFuncLibrary_MovementDirectionGetRotation Parms{};

	Parms.MovementDirection = std::move(MovementDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementDirectionIsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementDirection            MovementDirection                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::MovementDirectionIsValid(const struct FLAIMovementDirection& MovementDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementDirectionIsValid");

	Params::LAIUtilFuncLibrary_MovementDirectionIsValid Parms{};

	Parms.MovementDirection = std::move(MovementDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementGoal                 MovementGoal                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULAIUtilFuncLibrary::MovementGoalGetActor(const struct FLAIMovementGoal& MovementGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementGoalGetActor");

	Params::LAIUtilFuncLibrary_MovementGoalGetActor Parms{};

	Parms.MovementGoal = std::move(MovementGoal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementGoal                 MovementGoal                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ALCharacter*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCharacter* ULAIUtilFuncLibrary::MovementGoalGetCharacter(const struct FLAIMovementGoal& MovementGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementGoalGetCharacter");

	Params::LAIUtilFuncLibrary_MovementGoalGetCharacter Parms{};

	Parms.MovementGoal = std::move(MovementGoal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementGoal                 MovementGoal                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::MovementGoalGetLocation(const struct FLAIMovementGoal& MovementGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementGoalGetLocation");

	Params::LAIUtilFuncLibrary_MovementGoalGetLocation Parms{};

	Parms.MovementGoal = std::move(MovementGoal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementGoalGetRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementGoal                 MovementGoal                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULAIUtilFuncLibrary::MovementGoalGetRotation(const struct FLAIMovementGoal& MovementGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementGoalGetRotation");

	Params::LAIUtilFuncLibrary_MovementGoalGetRotation Parms{};

	Parms.MovementGoal = std::move(MovementGoal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementGoalIsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIMovementGoal                 MovementGoal                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::MovementGoalIsValid(const struct FLAIMovementGoal& MovementGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementGoalIsValid");

	Params::LAIUtilFuncLibrary_MovementGoalIsValid Parms{};

	Parms.MovementGoal = std::move(MovementGoal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.MovementGoalSetCustomArriveDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAIMovementGoal                 MovementGoal                                           (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ArriveDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::MovementGoalSetCustomArriveDistance(struct FLAIMovementGoal& MovementGoal, float ArriveDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "MovementGoalSetCustomArriveDistance");

	Params::LAIUtilFuncLibrary_MovementGoalSetCustomArriveDistance Parms{};

	Parms.MovementGoal = std::move(MovementGoal);
	Parms.ArriveDistance = ArriveDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MovementGoal = std::move(Parms.MovementGoal);
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveAsActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIObjective                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIObjective ULAIUtilFuncLibrary::ObjectiveAsActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveAsActor");

	Params::LAIUtilFuncLibrary_ObjectiveAsActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveAsLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIObjective                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIObjective ULAIUtilFuncLibrary::ObjectiveAsLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveAsLocation");

	Params::LAIUtilFuncLibrary_ObjectiveAsLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveAsType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALAIController*                   Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAITargetType                          TargetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAIObjective                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAIObjective ULAIUtilFuncLibrary::ObjectiveAsType(class ALAIController* Controller, ELAITargetType TargetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveAsType");

	Params::LAIUtilFuncLibrary_ObjectiveAsType Parms{};

	Parms.Controller = Controller;
	Parms.TargetType = TargetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIObjective                    Objective                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULAIUtilFuncLibrary::ObjectiveGetActor(const struct FLAIObjective& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveGetActor");

	Params::LAIUtilFuncLibrary_ObjectiveGetActor Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetAgentLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIObjective                    Objective                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::ObjectiveGetAgentLocation(const struct FLAIObjective& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveGetAgentLocation");

	Params::LAIUtilFuncLibrary_ObjectiveGetAgentLocation Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIObjective                    Objective                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ALCharacter*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCharacter* ULAIUtilFuncLibrary::ObjectiveGetCharacter(const struct FLAIObjective& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveGetCharacter");

	Params::LAIUtilFuncLibrary_ObjectiveGetCharacter Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIObjective                    Objective                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULAIUtilFuncLibrary::ObjectiveGetLocation(const struct FLAIObjective& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveGetLocation");

	Params::LAIUtilFuncLibrary_ObjectiveGetLocation Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveGetRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIObjective                    Objective                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULAIUtilFuncLibrary::ObjectiveGetRotation(const struct FLAIObjective& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveGetRotation");

	Params::LAIUtilFuncLibrary_ObjectiveGetRotation Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.ObjectiveIsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLAIObjective                    Objective                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::ObjectiveIsValid(const struct FLAIObjective& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "ObjectiveIsValid");

	Params::LAIUtilFuncLibrary_ObjectiveIsValid Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.PropagationTest
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CriterionActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AroundLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InsideLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CacheName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestVertAndHoriTrace                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::PropagationTest(class AActor* CriterionActor, const struct FVector& AroundLocation, float InsideLength, class FName CacheName, bool bTestVertAndHoriTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "PropagationTest");

	Params::LAIUtilFuncLibrary_PropagationTest Parms{};

	Parms.CriterionActor = CriterionActor;
	Parms.AroundLocation = std::move(AroundLocation);
	Parms.InsideLength = InsideLength;
	Parms.CacheName = CacheName;
	Parms.bTestVertAndHoriTrace = bTestVertAndHoriTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.RangeCheck_AllDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::RangeCheck_AllDistance(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "RangeCheck_AllDistance");

	Params::LAIUtilFuncLibrary_RangeCheck_AllDistance Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.RangeCheck_Distance2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAICheckOwner                   CheckOwner                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLAIObjective                    CheckTarget                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MinRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeMinMaxType                     MinMaxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAIRangeCheckFailReason                FailReason                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::RangeCheck_Distance2D(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "RangeCheck_Distance2D");

	Params::LAIUtilFuncLibrary_RangeCheck_Distance2D Parms{};

	Parms.CheckOwner = std::move(CheckOwner);
	Parms.CheckTarget = std::move(CheckTarget);
	Parms.MinRange = MinRange;
	Parms.MaxRange = MaxRange;
	Parms.MinMaxType = MinMaxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FailReason != nullptr)
		*FailReason = Parms.FailReason;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.RemovePauseAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PauseName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintain                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::RemovePauseAI(class AActor* Actor, class FName PauseName, bool bMaintain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "RemovePauseAI");

	Params::LAIUtilFuncLibrary_RemovePauseAI Parms{};

	Parms.Actor = Actor;
	Parms.PauseName = PauseName;
	Parms.bMaintain = bMaintain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIUtilFuncLibrary.SampleLocations
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLAILocationSampler              Sampler                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ALAIController*                   Querier                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SampleOrigin                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReSampleDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SampleDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpaceBetween                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::SampleLocations(struct FLAILocationSampler& Sampler, class ALAIController* Querier, const struct FVector& SampleOrigin, float ReSampleDistance, float SampleDistance, float SpaceBetween)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "SampleLocations");

	Params::LAIUtilFuncLibrary_SampleLocations Parms{};

	Parms.Sampler = std::move(Sampler);
	Parms.Querier = Querier;
	Parms.SampleOrigin = std::move(SampleOrigin);
	Parms.ReSampleDistance = ReSampleDistance;
	Parms.SampleDistance = SampleDistance;
	Parms.SpaceBetween = SpaceBetween;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Sampler = std::move(Parms.Sampler);

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.SetAIEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::SetAIEnabled(const class UObject* WorldContextObject, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "SetAIEnabled");

	Params::LAIUtilFuncLibrary_SetAIEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAIUtilFuncLibrary.TestCanWalkOnNavi
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAIUtilFuncLibrary::TestCanWalkOnNavi(class ALCharacter* Character, const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "TestCanWalkOnNavi");

	Params::LAIUtilFuncLibrary_TestCanWalkOnNavi Parms{};

	Parms.Character = Character;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAIUtilFuncLibrary.TraceMidpointWall
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bHasWall                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasMidpointWall                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           CheckOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceStart                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceEnd                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GoalLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::TraceMidpointWall(bool* bHasWall, bool* bHasMidpointWall, bool bDebug, class AActor* CheckOwner, const struct FVector& TraceStart, const struct FVector& TraceEnd, const struct FVector& GoalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "TraceMidpointWall");

	Params::LAIUtilFuncLibrary_TraceMidpointWall Parms{};

	Parms.bDebug = bDebug;
	Parms.CheckOwner = CheckOwner;
	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceEnd = std::move(TraceEnd);
	Parms.GoalLocation = std::move(GoalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bHasWall != nullptr)
		*bHasWall = Parms.bHasWall;

	if (bHasMidpointWall != nullptr)
		*bHasMidpointWall = Parms.bHasMidpointWall;
}


// Function ProjectP.LAIUtilFuncLibrary.UpdateAIEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAIUtilFuncLibrary::UpdateAIEnabled(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAIUtilFuncLibrary", "UpdateAIEnabled");

	Params::LAIUtilFuncLibrary_UpdateAIEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.BindAnimFSMEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MachineName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     StateNameArray                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULAnimInstance::BindAnimFSMEvent(class FName MachineName, const TArray<class FName>& StateNameArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "BindAnimFSMEvent");

	Params::LAnimInstance_BindAnimFSMEvent Parms{};

	Parms.MachineName = MachineName;
	Parms.StateNameArray = std::move(StateNameArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.DecreaseStretchBoneAll
// (Final, Native, Public, BlueprintCallable)

void ULAnimInstance::DecreaseStretchBoneAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "DecreaseStretchBoneAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.DoRagdollFreezeEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAnimInstance::DoRagdollFreezeEnable(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "DoRagdollFreezeEnable");

	Params::LAnimInstance_DoRagdollFreezeEnable Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.GetEmptyBoneRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERelativeTransformSpace                 TransformSpace                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ULAnimInstance::GetEmptyBoneRotation(class FName BoneName, ERelativeTransformSpace TransformSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "GetEmptyBoneRotation");

	Params::LAnimInstance_GetEmptyBoneRotation Parms{};

	Parms.BoneName = BoneName;
	Parms.TransformSpace = TransformSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAnimInstance.GetOwnerBaseRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULAnimInstance::GetOwnerBaseRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "GetOwnerBaseRotation");

	Params::LAnimInstance_GetOwnerBaseRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAnimInstance.OnGraphStateChanged_Entry
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAnimNode_StateMachine           Machine                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   PrevStateIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextStateIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MachineName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAnimInstance::OnGraphStateChanged_Entry(const struct FAnimNode_StateMachine& Machine, int32 PrevStateIndex, int32 NextStateIndex, class FName MachineName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "OnGraphStateChanged_Entry");

	Params::LAnimInstance_OnGraphStateChanged_Entry Parms{};

	Parms.Machine = std::move(Machine);
	Parms.PrevStateIndex = PrevStateIndex;
	Parms.NextStateIndex = NextStateIndex;
	Parms.MachineName = MachineName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.OnGraphStateChanged_Exit
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAnimNode_StateMachine           Machine                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   PrevStateIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextStateIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MachineName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAnimInstance::OnGraphStateChanged_Exit(const struct FAnimNode_StateMachine& Machine, int32 PrevStateIndex, int32 NextStateIndex, class FName MachineName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "OnGraphStateChanged_Exit");

	Params::LAnimInstance_OnGraphStateChanged_Exit Parms{};

	Parms.Machine = std::move(Machine);
	Parms.PrevStateIndex = PrevStateIndex;
	Parms.NextStateIndex = NextStateIndex;
	Parms.MachineName = MachineName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.PlaySlotStartLoopEndAnimationAsDynamicMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                StartAsset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                LoopAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                EndAsset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ULAnimInstance::PlaySlotStartLoopEndAnimationAsDynamicMontage(class FName SlotNodeName, class UAnimSequenceBase* StartAsset, class UAnimSequenceBase* LoopAsset, class UAnimSequenceBase* EndAsset, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "PlaySlotStartLoopEndAnimationAsDynamicMontage");

	Params::LAnimInstance_PlaySlotStartLoopEndAnimationAsDynamicMontage Parms{};

	Parms.SlotNodeName = SlotNodeName;
	Parms.StartAsset = StartAsset;
	Parms.LoopAsset = LoopAsset;
	Parms.EndAsset = EndAsset;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAnimInstance.SetAdditiveHitFlipFlop
// (Final, Native, Public, BlueprintCallable)

void ULAnimInstance::SetAdditiveHitFlipFlop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "SetAdditiveHitFlipFlop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.SetAdditiveHitType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAdditiveHitType                       AdditiveHitType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAnimInstance::SetAdditiveHitType(ELAdditiveHitType AdditiveHitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "SetAdditiveHitType");

	Params::LAnimInstance_SetAdditiveHitType Parms{};

	Parms.AdditiveHitType = AdditiveHitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.SetSequenceBindingPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPlaying                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULAnimInstance::SetSequenceBindingPlaying(bool InPlaying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "SetSequenceBindingPlaying");

	Params::LAnimInstance_SetSequenceBindingPlaying Parms{};

	Parms.InPlaying = InPlaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LAnimInstance.GetAnimSwitchOnOff
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SwitchName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULAnimInstance::GetAnimSwitchOnOff(class FName SwitchName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "GetAnimSwitchOnOff");

	Params::LAnimInstance_GetAnimSwitchOnOff Parms{};

	Parms.SwitchName = SwitchName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAnimInstance.GetBoneNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLDefinedBoneNames         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FLDefinedBoneNames ULAnimInstance::GetBoneNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "GetBoneNames");

	Params::LAnimInstance_GetBoneNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAnimInstance.GetRigStretchBoneDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLRigStretchBone                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLRigStretchBone ULAnimInstance::GetRigStretchBoneDistance(class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "GetRigStretchBoneDistance");

	Params::LAnimInstance_GetRigStretchBoneDistance Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAnimInstance.GetStretchBoneDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULAnimInstance::GetStretchBoneDistance(class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimInstance", "GetStretchBoneDistance");

	Params::LAnimInstance_GetStretchBoneDistance Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LIKUtilFuncLibrary.FootIK_CalcuateOffset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULAnimInstance*                   AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLInverseKinemetic               IK                                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLFootIKContext                  FootIKContext                                          (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULIKUtilFuncLibrary::FootIK_CalcuateOffset(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, struct FLFootIKContext& FootIKContext, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIKUtilFuncLibrary", "FootIK_CalcuateOffset");

	Params::LIKUtilFuncLibrary_FootIK_CalcuateOffset Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.IK = std::move(IK);
	Parms.FootIKContext = std::move(FootIKContext);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	IK = std::move(Parms.IK);
	FootIKContext = std::move(Parms.FootIKContext);
}


// Function ProjectP.LIKUtilFuncLibrary.FootIK_GetPelvisOffset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULAnimInstance*                   AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLInverseKinemetic               IK                                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FLFootIKContext>          FootIKContexts                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULIKUtilFuncLibrary::FootIK_GetPelvisOffset(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, const TArray<struct FLFootIKContext>& FootIKContexts, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIKUtilFuncLibrary", "FootIK_GetPelvisOffset");

	Params::LIKUtilFuncLibrary_FootIK_GetPelvisOffset Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.IK = std::move(IK);
	Parms.FootIKContexts = std::move(FootIKContexts);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	IK = std::move(Parms.IK);
}


// Function ProjectP.LIKUtilFuncLibrary.FootIK_Trace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULAnimInstance*                   AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLInverseKinemetic               IK                                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLFootIKContext                  FootIKContext                                          (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULIKUtilFuncLibrary::FootIK_Trace(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, struct FLFootIKContext& FootIKContext, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIKUtilFuncLibrary", "FootIK_Trace");

	Params::LIKUtilFuncLibrary_FootIK_Trace Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.IK = std::move(IK);
	Parms.FootIKContext = std::move(FootIKContext);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	IK = std::move(Parms.IK);
	FootIKContext = std::move(Parms.FootIKContext);
}


// Function ProjectP.LIKUtilFuncLibrary.IK_Update
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULAnimInstance*                   AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLInverseKinemetic               IK                                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULIKUtilFuncLibrary::IK_Update(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LIKUtilFuncLibrary", "IK_Update");

	Params::LIKUtilFuncLibrary_IK_Update Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.IK = std::move(IK);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	IK = std::move(Parms.IK);
}


// Function ProjectP.LAnimNotifyState_Trail_Inner.OverridePSTemplate
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* ULAnimNotifyState_Trail_Inner::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LAnimNotifyState_Trail_Inner", "OverridePSTemplate");

	Params::LAnimNotifyState_Trail_Inner_OverridePSTemplate Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LAssetLoader.FindOrLoadAssetSlowly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           Asset                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ULAssetLoader::FindOrLoadAssetSlowly(TSoftObjectPtr<class UObject> Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAssetLoader", "FindOrLoadAssetSlowly");

	Params::LAssetLoader_FindOrLoadAssetSlowly Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LAssetLoader.FindOrLoadClassSlowly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             AssetClass                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ULAssetLoader::FindOrLoadClassSlowly(TSoftClassPtr<class UClass> AssetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LAssetLoader", "FindOrLoadClassSlowly");

	Params::LAssetLoader_FindOrLoadClassSlowly Parms{};

	Parms.AssetClass = AssetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBDecorator_BlueprintBase.GetBehaivorTreeNodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULBDecorator_BlueprintBase::GetBehaivorTreeNodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBDecorator_BlueprintBase", "GetBehaivorTreeNodeName");

	Params::LBDecorator_BlueprintBase_GetBehaivorTreeNodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBDecorator_BlueprintBase.OnPostEditChangeProperty
// (Event, Public, BlueprintEvent)

void ULBDecorator_BlueprintBase::OnPostEditChangeProperty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBDecorator_BlueprintBase", "OnPostEditChangeProperty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LBDecorator_BlueprintBase.SetBehaivorTreeNodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBDecorator_BlueprintBase::SetBehaivorTreeNodeName(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBDecorator_BlueprintBase", "SetBehaivorTreeNodeName");

	Params::LBDecorator_BlueprintBase_SetBehaivorTreeNodeName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Common.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyStainCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class ULMaterialVarying> InMaterialVaryingRef                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartTimeDelay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRemainTimeForRewind                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardTimeScale                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRewindTimeScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InRewindOnRemove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Common::Initialize(class ALCharacter* InOwner, class FName InCodeName, ELBodyStainCategory InCategory, int32 InPriority, TSoftObjectPtr<class ULMaterialVarying> InMaterialVaryingRef, float InStartTimeDelay, float InRemainTimeForRewind, float InForwardTimeScale, float InRewindTimeScale, bool InRewindOnRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Common", "Initialize");

	Params::LBodyStain_Common_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InCodeName = InCodeName;
	Parms.InCategory = InCategory;
	Parms.InPriority = InPriority;
	Parms.InMaterialVaryingRef = InMaterialVaryingRef;
	Parms.InStartTimeDelay = InStartTimeDelay;
	Parms.InRemainTimeForRewind = InRemainTimeForRewind;
	Parms.InForwardTimeScale = InForwardTimeScale;
	Parms.InRewindTimeScale = InRewindTimeScale;
	Parms.InRewindOnRemove = InRewindOnRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Common.Restart
// (Final, Native, Public, BlueprintCallable)

void ULBodyStain_Common::Restart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Common", "Restart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Common.IsRewinding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULBodyStain_Common::IsRewinding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Common", "IsRewinding");

	Params::LBodyStain_Common_IsRewinding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBodyStain_Blood.Initialize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ALCharacter*                      InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyStainCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InWetColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeApplyWet                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeRemainWet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeRewindWet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Blood::Initialize(class ALCharacter* InOwner, ELBodyStainCategory InCategory, int32 InPriority, int32 InLevel, float InAmount, const struct FLinearColor& InWetColor, float InTimeApplyWet, float InTimeRemainWet, float InTimeRewindWet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Blood", "Initialize");

	Params::LBodyStain_Blood_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InCategory = InCategory;
	Parms.InPriority = InPriority;
	Parms.InLevel = InLevel;
	Parms.InAmount = InAmount;
	Parms.InWetColor = std::move(InWetColor);
	Parms.InTimeApplyWet = InTimeApplyWet;
	Parms.InTimeRemainWet = InTimeRemainWet;
	Parms.InTimeRewindWet = InTimeRewindWet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Blood.UpdateColorAndAmount
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InBloodColor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Blood::UpdateColorAndAmount(int32 InLevel, const struct FLinearColor& InBloodColor, float InAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Blood", "UpdateColorAndAmount");

	Params::LBodyStain_Blood_UpdateColorAndAmount Parms{};

	Parms.InLevel = InLevel;
	Parms.InBloodColor = std::move(InBloodColor);
	Parms.InAmount = InAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Body.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeApplyWet_by_Sink                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeApplyWet_by_WaterDrop                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeRemainWet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeRewindWet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Wet_Body::Initialize(class ALCharacter* InOwner, float InTimeApplyWet_by_Sink, float InTimeApplyWet_by_WaterDrop, float InTimeRemainWet, float InTimeRewindWet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Body", "Initialize");

	Params::LBodyStain_Wet_Body_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InTimeApplyWet_by_Sink = InTimeApplyWet_by_Sink;
	Parms.InTimeApplyWet_by_WaterDrop = InTimeApplyWet_by_WaterDrop;
	Parms.InTimeRemainWet = InTimeRemainWet;
	Parms.InTimeRewindWet = InTimeRewindWet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Body.SetFinished
// (Final, Native, Public)

void ULBodyStain_Wet_Body::SetFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Body", "SetFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Body.SetTargetAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyWetReasonType                     WetReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Wet_Body::SetTargetAmount(float InAmount, ELBodyWetReasonType WetReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Body", "SetTargetAmount");

	Params::LBodyStain_Wet_Body_SetTargetAmount Parms{};

	Parms.InAmount = InAmount;
	Parms.WetReason = WetReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Body.SetTargetColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyWetReasonType                     WetReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Wet_Body::SetTargetColor(const struct FLinearColor& InColor, ELBodyWetReasonType WetReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Body", "SetTargetColor");

	Params::LBodyStain_Wet_Body_SetTargetColor Parms{};

	Parms.InColor = std::move(InColor);
	Parms.WetReason = WetReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Leg.ApplyWetColor
// (Final, Native, Public, BlueprintCallable)

void ULBodyStain_Wet_Leg::ApplyWetColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Leg", "ApplyWetColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Leg.Initialize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ALCharacter*                      InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InPhysicalSurface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InWetColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority_Wet_Leg                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeRemainWet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDrySpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Wet_Leg::Initialize(class ALCharacter* InOwner, ELPhysicalSurfaceType InPhysicalSurface, const struct FLinearColor& InWetColor, int32 InPriority_Wet_Leg, float InTimeRemainWet, float InDrySpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Leg", "Initialize");

	Params::LBodyStain_Wet_Leg_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InPhysicalSurface = InPhysicalSurface;
	Parms.InWetColor = std::move(InWetColor);
	Parms.InPriority_Wet_Leg = InPriority_Wet_Leg;
	Parms.InTimeRemainWet = InTimeRemainWet;
	Parms.InDrySpeed = InDrySpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Leg.SetTargetColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Wet_Leg::SetTargetColor(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Leg", "SetTargetColor");

	Params::LBodyStain_Wet_Leg_SetTargetColor Parms{};

	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Wet_Leg.SetTargetHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Wet_Leg::SetTargetHeight(float InHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Wet_Leg", "SetTargetHeight");

	Params::LBodyStain_Wet_Leg_SetTargetHeight Parms{};

	Parms.InHeight = InHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Burn.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyStainCategory                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBurnAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InEmissiveFade                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime_Apply_Burn                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime_Rewind_Burn                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime_Remain_Dust                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime_Rewind_Dust                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStain_Burn::Initialize(class ALCharacter* InOwner, class FName InCodeName, ELBodyStainCategory InType, int32 InPriority, float InBurnAmount, float InEmissiveFade, float InTime_Apply_Burn, float InTime_Rewind_Burn, float InTime_Remain_Dust, float InTime_Rewind_Dust)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Burn", "Initialize");

	Params::LBodyStain_Burn_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InCodeName = InCodeName;
	Parms.InType = InType;
	Parms.InPriority = InPriority;
	Parms.InBurnAmount = InBurnAmount;
	Parms.InEmissiveFade = InEmissiveFade;
	Parms.InTime_Apply_Burn = InTime_Apply_Burn;
	Parms.InTime_Rewind_Burn = InTime_Rewind_Burn;
	Parms.InTime_Remain_Dust = InTime_Remain_Dust;
	Parms.InTime_Rewind_Dust = InTime_Rewind_Dust;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Burn.Restart
// (Final, Native, Public, BlueprintCallable)

void ULBodyStain_Burn::Restart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Burn", "Restart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Burn.Rewind_Dust
// (Final, Native, Public)

void ULBodyStain_Burn::Rewind_Dust()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Burn", "Rewind_Dust");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStain_Burn.SetFinished
// (Final, Native, Public)

void ULBodyStain_Burn::SetFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStain_Burn", "SetFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.AddLoopWetBodyInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsWaterDrop                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::AddLoopWetBodyInfo(class AActor* Instigator, ELPhysicalSurfaceType PhysicalSurface, float InAmount, bool IsWaterDrop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "AddLoopWetBodyInfo");

	Params::LBodyStainComponent_AddLoopWetBodyInfo Parms{};

	Parms.Instigator = Instigator;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.InAmount = InAmount;
	Parms.IsWaterDrop = IsWaterDrop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.ApplyBodyStainData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULBodyStain_Base*                 BodyStain                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimePlayFrom                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::ApplyBodyStainData(class ULBodyStain_Base* BodyStain, float TimePlayFrom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "ApplyBodyStainData");

	Params::LBodyStainComponent_ApplyBodyStainData Parms{};

	Parms.BodyStain = BodyStain;
	Parms.TimePlayFrom = TimePlayFrom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.GetBodyStain
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELBodyStainCategory                     InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULBodyStain_Base*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULBodyStain_Base* ULBodyStainComponent::GetBodyStain(ELBodyStainCategory InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "GetBodyStain");

	Params::LBodyStainComponent_GetBodyStain Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBodyStainComponent.GetBodyStain_by_CodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULBodyStain_Base*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULBodyStain_Base* ULBodyStainComponent::GetBodyStain_by_CodeName(class FName InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "GetBodyStain_by_CodeName");

	Params::LBodyStainComponent_GetBodyStain_by_CodeName Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LBodyStainComponent.OnBloodOptionChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::OnBloodOptionChanged(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "OnBloodOptionChanged");

	Params::LBodyStainComponent_OnBloodOptionChanged Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.OnRemoveBodyStain
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyStainCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::OnRemoveBodyStain(class FName InCodeName, ELBodyStainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "OnRemoveBodyStain");

	Params::LBodyStainComponent_OnRemoveBodyStain Parms{};

	Parms.InCodeName = InCodeName;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.OnRewindBodyStain
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBodyStainCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::OnRewindBodyStain(class FName InCodeName, ELBodyStainCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "OnRewindBodyStain");

	Params::LBodyStainComponent_OnRewindBodyStain Parms{};

	Parms.InCodeName = InCodeName;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.PlayStain_Abnormal
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::PlayStain_Abnormal(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "PlayStain_Abnormal");

	Params::LBodyStainComponent_PlayStain_Abnormal Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LBodyStainComponent.PlayStain_Blood
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELBloodEffectType                       BloodType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InBloodLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ApplyTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::PlayStain_Blood(ELBloodEffectType BloodType, int32 InBloodLevel, float ApplyTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "PlayStain_Blood");

	Params::LBodyStainComponent_PlayStain_Blood Parms{};

	Parms.BloodType = BloodType;
	Parms.InBloodLevel = InBloodLevel;
	Parms.ApplyTime = ApplyTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LBodyStainComponent.PlayStain_Wet_Body
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsWaterDrop                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::PlayStain_Wet_Body(ELPhysicalSurfaceType PhysicalSurface, float InAmount, bool IsWaterDrop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "PlayStain_Wet_Body");

	Params::LBodyStainComponent_PlayStain_Wet_Body Parms{};

	Parms.PhysicalSurface = PhysicalSurface;
	Parms.InAmount = InAmount;
	Parms.IsWaterDrop = IsWaterDrop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LBodyStainComponent.PlayStain_Wet_Leg
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELPhysicalSurfaceType                   SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::PlayStain_Wet_Leg(ELPhysicalSurfaceType SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "PlayStain_Wet_Leg");

	Params::LBodyStainComponent_PlayStain_Wet_Leg Parms{};

	Parms.SurfaceType = SurfaceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LBodyStainComponent.Refresh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::Refresh(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "Refresh");

	Params::LBodyStainComponent_Refresh Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.RemoveAll
// (Final, Native, Public, BlueprintCallable)

void ULBodyStainComponent::RemoveAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "RemoveAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.RemoveBodyStain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::RemoveBodyStain(class FName InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "RemoveBodyStain");

	Params::LBodyStainComponent_RemoveBodyStain Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.RemoveLoopWetBodyInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::RemoveLoopWetBodyInfo(class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "RemoveLoopWetBodyInfo");

	Params::LBodyStainComponent_RemoveLoopWetBodyInfo Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.RewindBodyStain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULBodyStainComponent::RewindBodyStain(class FName InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "RewindBodyStain");

	Params::LBodyStainComponent_RewindBodyStain Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LBodyStainComponent.UpdateWaterSoakHeight
// (Final, Native, Public)

void ULBodyStainComponent::UpdateWaterSoakHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LBodyStainComponent", "UpdateWaterSoakHeight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraUtilFuncLibrary.CalculateCameraLocationFromPC
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArmLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ControlRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULCameraUtilFuncLibrary::CalculateCameraLocationFromPC(class ALCameraWork* CameraWork, float ArmLength, const struct FRotator& ControlRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "CalculateCameraLocationFromPC");

	Params::LCameraUtilFuncLibrary_CalculateCameraLocationFromPC Parms{};

	Parms.CameraWork = CameraWork;
	Parms.ArmLength = ArmLength;
	Parms.ControlRotation = std::move(ControlRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCameraCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALPCCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALPCCharacter* ULCameraUtilFuncLibrary::GetCameraCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCameraCharacter");

	Params::LCameraUtilFuncLibrary_GetCameraCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCameraManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCameraManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCameraManager* ULCameraUtilFuncLibrary::GetCameraManager(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCameraManager");

	Params::LCameraUtilFuncLibrary_GetCameraManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCameraSocketLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULCameraUtilFuncLibrary::GetCameraSocketLocation(class ALCameraWork* CameraWork, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCameraSocketLocation");

	Params::LCameraUtilFuncLibrary_GetCameraSocketLocation Parms{};

	Parms.CameraWork = CameraWork;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCameraSocketRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULCameraUtilFuncLibrary::GetCameraSocketRotation(class ALCameraWork* CameraWork, class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCameraSocketRotation");

	Params::LCameraUtilFuncLibrary_GetCameraSocketRotation Parms{};

	Parms.CameraWork = CameraWork;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCameraTargetArmLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCameraUtilFuncLibrary::GetCameraTargetArmLength(class ALCameraWork* CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCameraTargetArmLength");

	Params::LCameraUtilFuncLibrary_GetCameraTargetArmLength Parms{};

	Parms.CameraWork = CameraWork;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCameraTargetArmLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULCameraUtilFuncLibrary::GetCameraTargetArmLocation(class ALCameraWork* CameraWork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCameraTargetArmLocation");

	Params::LCameraUtilFuncLibrary_GetCameraTargetArmLocation Parms{};

	Parms.CameraWork = CameraWork;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.GetCharacterSocketTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULCameraUtilFuncLibrary::GetCharacterSocketTransform(class ALCharacter* Character, class FName SocketName, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "GetCharacterSocketTransform");

	Params::LCameraUtilFuncLibrary_GetCharacterSocketTransform Parms{};

	Parms.Character = Character;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function ProjectP.LCameraUtilFuncLibrary.LinearStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCameraUtilFuncLibrary::LinearStep(float Min, float Max, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "LinearStep");

	Params::LCameraUtilFuncLibrary_LinearStep Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraUtilFuncLibrary.MakeLookatCharacter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ActorRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULCameraUtilFuncLibrary::MakeLookatCharacter(class ALCharacter* Character, class FName SocketName, const struct FRotator& ActorRotation, float Distance, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "MakeLookatCharacter");

	Params::LCameraUtilFuncLibrary_MakeLookatCharacter Parms{};

	Parms.Character = Character;
	Parms.SocketName = SocketName;
	Parms.ActorRotation = std::move(ActorRotation);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function ProjectP.LCameraUtilFuncLibrary.MakeLookatTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          CameraLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULCameraUtilFuncLibrary::MakeLookatTargetLocation(const struct FVector& CameraLocation, const struct FVector& TargetLocation, float Distance, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "MakeLookatTargetLocation");

	Params::LCameraUtilFuncLibrary_MakeLookatTargetLocation Parms{};

	Parms.CameraLocation = std::move(CameraLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function ProjectP.LCameraUtilFuncLibrary.SetCameraCharacterControlRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ALCameraWork*                     CameraWork                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ControlRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULCameraUtilFuncLibrary::SetCameraCharacterControlRotation(class ALCameraWork* CameraWork, const struct FRotator& ControlRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCameraUtilFuncLibrary", "SetCameraCharacterControlRotation");

	Params::LCameraUtilFuncLibrary_SetCameraCharacterControlRotation Parms{};

	Parms.CameraWork = CameraWork;
	Parms.ControlRotation = std::move(ControlRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelObject.GetDelayInteractTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALLevelObject::GetDelayInteractTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "GetDelayInteractTime");

	Params::LLevelObject_GetDelayInteractTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLevelObject.GetInteractTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALLevelObject::GetInteractTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "GetInteractTime");

	Params::LLevelObject_GetInteractTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLevelObject.OnChangeState
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLevelObject::OnChangeState(int32 TargetState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OnChangeState");

	Params::LLevelObject_OnChangeState Parms{};

	Parms.TargetState = TargetState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLevelObject.OnInteractionEnd
// (Event, Public, BlueprintEvent)

void ALLevelObject::OnInteractionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OnInteractionEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LLevelObject.OnInteractionStart
// (Event, Public, BlueprintEvent)

void ALLevelObject::OnInteractionStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OnInteractionStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LLevelObject.OnLevelObjectCommand
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             CommandName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLevelObject::OnLevelObjectCommand(class FName CommandName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OnLevelObjectCommand");

	Params::LLevelObject_OnLevelObjectCommand Parms{};

	Parms.CommandName = CommandName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLevelObject.OwnerSpotChangePropState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLevelObject::OwnerSpotChangePropState(int32 TargetState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OwnerSpotChangePropState");

	Params::LLevelObject_OwnerSpotChangePropState Parms{};

	Parms.TargetState = TargetState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelObject.OwnerSpotCheckLinkedNpcSpot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELLinkedNpcSpotExecuteType              ExecuteType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLevelObject::OwnerSpotCheckLinkedNpcSpot(ELLinkedNpcSpotExecuteType ExecuteType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OwnerSpotCheckLinkedNpcSpot");

	Params::LLevelObject_OwnerSpotCheckLinkedNpcSpot Parms{};

	Parms.ExecuteType = ExecuteType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelObject.OwnerSpotCheckNextPropState
// (Final, Native, Public, BlueprintCallable)

void ALLevelObject::OwnerSpotCheckNextPropState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "OwnerSpotCheckNextPropState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelObject.RemovePropProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   ProjectileHandleId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLevelObject::RemovePropProjectile(int64 ProjectileHandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "RemovePropProjectile");

	Params::LLevelObject_RemovePropProjectile Parms{};

	Parms.ProjectileHandleId = ProjectileHandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelObject.SpawnPropProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ProjectileCodeName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  MuzzleSocket                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ALLevelObject::SpawnPropProjectile(class FName ProjectileCodeName, class USceneComponent* MuzzleSocket, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelObject", "SpawnPropProjectile");

	Params::LLevelObject_SpawnPropProjectile Parms{};

	Parms.ProjectileCodeName = ProjectileCodeName;
	Parms.MuzzleSocket = MuzzleSocket;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCarcassBodyObject.BurnAutomation
// (Event, Public, BlueprintEvent)

void ALCarcassBodyObject::BurnAutomation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "BurnAutomation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LCarcassBodyObject.CheckAbnormalStateBuildUp
// (Final, Native, Protected)

void ALCarcassBodyObject::CheckAbnormalStateBuildUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "CheckAbnormalStateBuildUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCarcassBodyObject.CheckIsSafe
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCarcassBodyObject::CheckIsSafe(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "CheckIsSafe");

	Params::LCarcassBodyObject_CheckIsSafe Parms{};

	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LCarcassBodyObject.ClearCharacterOverlapState
// (Final, Native, Public, BlueprintCallable)

void ALCarcassBodyObject::ClearCharacterOverlapState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "ClearCharacterOverlapState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCarcassBodyObject.GetFluidDepth
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALCarcassBodyObject::GetFluidDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "GetFluidDepth");

	Params::LCarcassBodyObject_GetFluidDepth Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LCarcassBodyObject.GetSurfaceHeight
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALCarcassBodyObject::GetSurfaceHeight(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "GetSurfaceHeight");

	Params::LCarcassBodyObject_GetSurfaceHeight Parms{};

	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LCarcassBodyObject.OnProcessHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo              HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALCarcassBodyObject::OnProcessHit(const struct FLProjectileHitInfo& HitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "OnProcessHit");

	Params::LCarcassBodyObject_OnProcessHit Parms{};

	Parms.HitInfo = std::move(HitInfo);
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCarcassBodyObject.RemoveCharacterOverlapState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCarcassBodyObject::RemoveCharacterOverlapState(class ALCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "RemoveCharacterOverlapState");

	Params::LCarcassBodyObject_RemoveCharacterOverlapState Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCarcassBodyObject.SetCharacterOverlapState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCarcassBodyObjectOverlapState         OverlapState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCarcassBodyObject::SetCharacterOverlapState(class ALCharacter* Character, ELCarcassBodyObjectOverlapState OverlapState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "SetCharacterOverlapState");

	Params::LCarcassBodyObject_SetCharacterOverlapState Parms{};

	Parms.Character = Character;
	Parms.OverlapState = OverlapState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCarcassBodyObject.GetCharacterOverlapState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELCarcassBodyObjectOverlapState         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELCarcassBodyObjectOverlapState ALCarcassBodyObject::GetCharacterOverlapState(class ALCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCarcassBodyObject", "GetCharacterOverlapState");

	Params::LCarcassBodyObject_GetCharacterOverlapState Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.AddManagedParticle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFXSystemComponent*               Particle                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::AddManagedParticle(class UFXSystemComponent* Particle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "AddManagedParticle");

	Params::LCharacter_AddManagedParticle Parms{};

	Parms.Particle = Particle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.AddRadialImpulseToBody
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MarginFromPrevious                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::AddRadialImpulseToBody(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bVelChange, float MarginFromPrevious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "AddRadialImpulseToBody");

	Params::LCharacter_AddRadialImpulseToBody Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.bVelChange = bVelChange;
	Parms.MarginFromPrevious = MarginFromPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.AddStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AdditionalStat                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::AddStat(ELSecondStat InStat, int32 AdditionalStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "AddStat");

	Params::LCharacter_AddStat Parms{};

	Parms.InStat = InStat;
	Parms.AdditionalStat = AdditionalStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.ApplyMeshScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MeshScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::ApplyMeshScale(float MeshScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ApplyMeshScale");

	Params::LCharacter_ApplyMeshScale Parms{};

	Parms.MeshScale = MeshScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.CaptureFallingMotionTransitionInfo
// (Final, Native, Public, BlueprintCallable)

void ALCharacter::CaptureFallingMotionTransitionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "CaptureFallingMotionTransitionInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.ChangeActionGroup
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionGroupTableCodeName                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::ChangeActionGroup(class FName ActionGroupTableCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ChangeActionGroup");

	Params::LCharacter_ChangeActionGroup Parms{};

	Parms.ActionGroupTableCodeName = ActionGroupTableCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.ChangeCollisionState
// (Native, Public, BlueprintCallable)
// Parameters:
// ELCollisionState                        InCollisionState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::ChangeCollisionState(ELCollisionState InCollisionState, bool ForceChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ChangeCollisionState");

	Params::LCharacter_ChangeCollisionState Parms{};

	Parms.InCollisionState = InCollisionState;
	Parms.ForceChange = ForceChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.ChangeCommonActionGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CommonActionGroup                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocomotionActionGroup                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::ChangeCommonActionGroup(class FName CommonActionGroup, class FName LocomotionActionGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ChangeCommonActionGroup");

	Params::LCharacter_ChangeCommonActionGroup Parms{};

	Parms.CommonActionGroup = CommonActionGroup;
	Parms.LocomotionActionGroup = LocomotionActionGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.ChangeLocomotion
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::ChangeLocomotion(class FName ActionGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ChangeLocomotion");

	Params::LCharacter_ChangeLocomotion Parms{};

	Parms.ActionGroup = ActionGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.ChangeWeaponAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AnimState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::ChangeWeaponAnimState(ELWeaponAttachPointType AttachPointType, ELWeaponPartType PartType, class FName AnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ChangeWeaponAnimState");

	Params::LCharacter_ChangeWeaponAnimState Parms{};

	Parms.AttachPointType = AttachPointType;
	Parms.PartType = PartType;
	Parms.AnimState = AnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.ClearWeaponAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::ClearWeaponAnimState(ELWeaponAttachPointType AttachPointType, ELWeaponPartType PartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ClearWeaponAnimState");

	Params::LCharacter_ClearWeaponAnimState Parms{};

	Parms.AttachPointType = AttachPointType;
	Parms.PartType = PartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.DeactiveAllManagedParticle
// (Final, Native, Public, BlueprintCallable)

void ALCharacter::DeactiveAllManagedParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "DeactiveAllManagedParticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.DeadToEvent
// (Native, Public, BlueprintCallable)

void ALCharacter::DeadToEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "DeadToEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.EventHitStart
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALCharacter::EventHitStart(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "EventHitStart");

	Params::LCharacter_EventHitStart Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.GameObject_RegisterStateManagedComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  TargetActorComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::GameObject_RegisterStateManagedComponent(class UActorComponent* TargetActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GameObject_RegisterStateManagedComponent");

	Params::LCharacter_GameObject_RegisterStateManagedComponent Parms{};

	Parms.TargetActorComponent = TargetActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GameObject_UnregisterStateManagedComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  TargetActorComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::GameObject_UnregisterStateManagedComponent(class UActorComponent* TargetActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GameObject_UnregisterStateManagedComponent");

	Params::LCharacter_GameObject_UnregisterStateManagedComponent Parms{};

	Parms.TargetActorComponent = TargetActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GetFocusRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ALCharacter::GetFocusRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetFocusRotation");

	Params::LCharacter_GetFocusRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GetFocusTarget
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALCharacter::GetFocusTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetFocusTarget");

	Params::LCharacter_GetFocusTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GetHPPercent
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   HPPercent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RegainHPPercent                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::GetHPPercent(float* HPPercent, float* RegainHPPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetHPPercent");

	Params::LCharacter_GetHPPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HPPercent != nullptr)
		*HPPercent = Parms.HPPercent;

	if (RegainHPPercent != nullptr)
		*RegainHPPercent = Parms.RegainHPPercent;
}


// Function ProjectP.LCharacter.GetSimplePhysicalSurface
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* ALCharacter::GetSimplePhysicalSurface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetSimplePhysicalSurface");

	Params::LCharacter_GetSimplePhysicalSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.IsAboveNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::IsAboveNavigation(bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "IsAboveNavigation");

	Params::LCharacter_IsAboveNavigation Parms{};

	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.IsDead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::IsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "IsDead");

	Params::LCharacter_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.MoveMeshComponentToCapsuleBottom
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MeshOffset                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintainMeshView                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::MoveMeshComponentToCapsuleBottom(const struct FVector& MeshOffset, bool bMaintainMeshView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "MoveMeshComponentToCapsuleBottom");

	Params::LCharacter_MoveMeshComponentToCapsuleBottom Parms{};

	Parms.MeshOffset = std::move(MeshOffset);
	Parms.bMaintainMeshView = bMaintainMeshView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.MoveMeshComponentToCapsuleCenter
// (Final, Native, Public, BlueprintCallable)

void ALCharacter::MoveMeshComponentToCapsuleCenter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "MoveMeshComponentToCapsuleCenter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnActionStarted
// (Native, Public)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        StartedAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnActionStarted(class ULActMgrComponent* InActMgrComponent, class ULActBase* StartedAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnActionStarted");

	Params::LCharacter_OnActionStarted Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.StartedAction = StartedAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnActionStopCalled
// (Native, Public)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        StoppingAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnActionStopCalled(class ULActMgrComponent* InActMgrComponent, class ULActBase* StoppingAction, class ULActBase* ReasonAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnActionStopCalled");

	Params::LCharacter_OnActionStopCalled Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.StoppingAction = StoppingAction;
	Parms.ReasonAction = ReasonAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnApplyNeedShrink
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALCharacter::OnApplyNeedShrink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnApplyNeedShrink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LCharacter.OnApplyRunningAbnormal
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsApply                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AbnormalCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnApplyRunningAbnormal(bool IsApply, class FName AbnormalCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnApplyRunningAbnormal");

	Params::LCharacter_OnApplyRunningAbnormal Parms{};

	Parms.IsApply = IsApply;
	Parms.AbnormalCodeName = AbnormalCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnCanHitOccurDecoMesh
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::OnCanHitOccurDecoMesh(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnCanHitOccurDecoMesh");

	Params::LCharacter_OnCanHitOccurDecoMesh Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.OnEquipmentWeaponStateChanged
// (Native, Public)
// Parameters:
// ELWeaponStateChangeType                 WeaponStateChangeType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnEquipmentWeaponStateChanged(ELWeaponStateChangeType WeaponStateChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnEquipmentWeaponStateChanged");

	Params::LCharacter_OnEquipmentWeaponStateChanged Parms{};

	Parms.WeaponStateChangeType = WeaponStateChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnPostDead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALCharacter::OnPostDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnPostDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnRagdoll
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnRagdoll(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnRagdoll");

	Params::LCharacter_OnRagdoll Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LCharacter.OnStaminaConsume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnStaminaConsume(int32 InAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnStaminaConsume");

	Params::LCharacter_OnStaminaConsume Parms{};

	Parms.InAmount = InAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OnStatChanged
// (Native, Public)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddedValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrevStatValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OnStatChanged(ELSecondStat StatType, int32 AddedValue, int32 PrevStatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OnStatChanged");

	Params::LCharacter_OnStatChanged Parms{};

	Parms.StatType = StatType;
	Parms.AddedValue = AddedValue;
	Parms.PrevStatValue = PrevStatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.OverwriteFallingStartHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::OverwriteFallingStartHeight(float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "OverwriteFallingStartHeight");

	Params::LCharacter_OverwriteFallingStartHeight Parms{};

	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.PlayMaterialParam
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLMaterialParamCollection        ParamCollection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     SelectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::PlayMaterialParam(const struct FLMaterialParamCollection& ParamCollection, ELMeshSelectionType SelectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "PlayMaterialParam");

	Params::LCharacter_PlayMaterialParam Parms{};

	Parms.ParamCollection = std::move(ParamCollection);
	Parms.SelectType = SelectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.PlayMaterialVarying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     SelectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::PlayMaterialVarying(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, ELMeshSelectionType SelectionType, class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "PlayMaterialVarying");

	Params::LCharacter_PlayMaterialVarying Parms{};

	Parms.MaterialVarying = MaterialVarying;
	Parms.PlayType = PlayType;
	Parms.SelectionType = SelectionType;
	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.PostHitProcess
// (Native, Public, BlueprintCallable)
// Parameters:
// class ULHitProcContext*                 HitProcContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::PostHitProcess(class ULHitProcContext* HitProcContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "PostHitProcess");

	Params::LCharacter_PostHitProcess Parms{};

	Parms.HitProcContext = HitProcContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.PostInitEquipWeapon
// (Event, Public, BlueprintEvent)

void ALCharacter::PostInitEquipWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "PostInitEquipWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LCharacter.ProcessHitContextDeliver
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULHitProcContext*                 LHitProcContext                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::ProcessHitContextDeliver(class ULHitProcContext* LHitProcContext, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ProcessHitContextDeliver");

	Params::LCharacter_ProcessHitContextDeliver Parms{};

	Parms.LHitProcContext = LHitProcContext;

	UObject::ProcessEvent(Func, &Parms);

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LCharacter.ReceiveDamage
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLReceiveDamageParams            Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLReceiveDamageResults           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLReceiveDamageResults ALCharacter::ReceiveDamage(const struct FLReceiveDamageParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ReceiveDamage");

	Params::LCharacter_ReceiveDamage Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.ReceivePartsDamage
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULPartsComponent*                 PartsComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestructionIndexDestoryed                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULHitProcContext*                 HitProcContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::ReceivePartsDamage(class ULPartsComponent* PartsComponent, int32 Damage, bool* bDestructionIndexDestoryed, class ULHitProcContext* HitProcContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ReceivePartsDamage");

	Params::LCharacter_ReceivePartsDamage Parms{};

	Parms.PartsComponent = PartsComponent;
	Parms.Damage = Damage;
	Parms.HitProcContext = HitProcContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bDestructionIndexDestoryed != nullptr)
		*bDestructionIndexDestoryed = Parms.bDestructionIndexDestoryed;
}


// Function ProjectP.LCharacter.ReceivePostBeginPlay
// (Event, Public, BlueprintEvent)

void ALCharacter::ReceivePostBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ReceivePostBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LCharacter.RegisterNavigationInvoker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::RegisterNavigationInvoker(class FName StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "RegisterNavigationInvoker");

	Params::LCharacter_RegisterNavigationInvoker Parms{};

	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.RemoveAllManagedParticle
// (Final, Native, Public, BlueprintCallable)

void ALCharacter::RemoveAllManagedParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "RemoveAllManagedParticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.ResetFallingMotionTransitionInfo
// (Final, Native, Public, BlueprintCallable)

void ALCharacter::ResetFallingMotionTransitionInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "ResetFallingMotionTransitionInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.SetReverseDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReverse                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::SetReverseDirection(bool bReverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "SetReverseDirection");

	Params::LCharacter_SetReverseDirection Parms{};

	Parms.bReverse = bReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.SetRuntimeRootMotionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRootMotion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::SetRuntimeRootMotionEnabled(bool bRootMotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "SetRuntimeRootMotionEnabled");

	Params::LCharacter_SetRuntimeRootMotionEnabled Parms{};

	Parms.bRootMotion = bRootMotion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.StopMaterialVarying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::StopMaterialVarying(class ULMaterialVarying* MaterialVarying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "StopMaterialVarying");

	Params::LCharacter_StopMaterialVarying Parms{};

	Parms.MaterialVarying = MaterialVarying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.TraceAndLandingOnFloor
// (Final, Native, Public, BlueprintCallable)

void ALCharacter::TraceAndLandingOnFloor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "TraceAndLandingOnFloor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.TraceFloatingCeiling
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TestLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TestCapsuleHalfHeight                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ResultLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::TraceFloatingCeiling(const struct FVector& TestLocation, float TestCapsuleHalfHeight, struct FVector* ResultLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "TraceFloatingCeiling");

	Params::LCharacter_TraceFloatingCeiling Parms{};

	Parms.TestLocation = std::move(TestLocation);
	Parms.TestCapsuleHalfHeight = TestCapsuleHalfHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultLocation != nullptr)
		*ResultLocation = std::move(Parms.ResultLocation);

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.TryConsumeElementalGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELSecondStat                            ElementType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumePoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::TryConsumeElementalGauge(ELSecondStat ElementType, int32 ConsumePoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "TryConsumeElementalGauge");

	Params::LCharacter_TryConsumeElementalGauge Parms{};

	Parms.ElementType = ElementType;
	Parms.ConsumePoint = ConsumePoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.TryConsumeTough
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    CheckOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULHitProcContext*                 HitProcContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::TryConsumeTough(int32 InAmount, class AActor* Attacker, const struct FLHitInfo& HitInfo, bool CheckOnly, class ULHitProcContext* HitProcContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "TryConsumeTough");

	Params::LCharacter_TryConsumeTough Parms{};

	Parms.InAmount = InAmount;
	Parms.Attacker = Attacker;
	Parms.HitInfo = std::move(HitInfo);
	Parms.CheckOnly = CheckOnly;
	Parms.HitProcContext = HitProcContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.TrySuppressTough
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::TrySuppressTough()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "TrySuppressTough");

	Params::LCharacter_TrySuppressTough Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.UnregisterNavInvoker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::UnregisterNavInvoker(class FName StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "UnregisterNavInvoker");

	Params::LCharacter_UnregisterNavInvoker Parms{};

	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacter.GetActionGroup
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ActionGroup                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonActionGroup                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocomotionActionGroup                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::GetActionGroup(class FName* ActionGroup, class FName* CommonActionGroup, class FName* LocomotionActionGroup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetActionGroup");

	Params::LCharacter_GetActionGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionGroup != nullptr)
		*ActionGroup = Parms.ActionGroup;

	if (CommonActionGroup != nullptr)
		*CommonActionGroup = Parms.CommonActionGroup;

	if (LocomotionActionGroup != nullptr)
		*LocomotionActionGroup = Parms.LocomotionActionGroup;
}


// Function ProjectP.LCharacter.GetCurrCollisionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELCollisionState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELCollisionState ALCharacter::GetCurrCollisionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetCurrCollisionState");

	Params::LCharacter_GetCurrCollisionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GetFloorPhysicalSurface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface ALCharacter::GetFloorPhysicalSurface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetFloorPhysicalSurface");

	Params::LCharacter_GetFloorPhysicalSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GetNavData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ANavigationData*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ANavigationData* ALCharacter::GetNavData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetNavData");

	Params::LCharacter_GetNavData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.GetNavInvokerRadius
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   TileGenerationRadius                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TileRemovalRadius                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALCharacter::GetNavInvokerRadius(float* TileGenerationRadius, float* TileRemovalRadius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetNavInvokerRadius");

	Params::LCharacter_GetNavInvokerRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TileGenerationRadius != nullptr)
		*TileGenerationRadius = Parms.TileGenerationRadius;

	if (TileRemovalRadius != nullptr)
		*TileRemovalRadius = Parms.TileRemovalRadius;
}


// Function ProjectP.LCharacter.GetOriginTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FTransform ALCharacter::GetOriginTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "GetOriginTransform");

	Params::LCharacter_GetOriginTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.IsRespawnInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::IsRespawnInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "IsRespawnInProgress");

	Params::LCharacter_IsRespawnInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacter.IsRuntimeRootMotionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALCharacter::IsRuntimeRootMotionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacter", "IsRuntimeRootMotionEnabled");

	Params::LCharacter_IsRuntimeRootMotionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacterMovementComponent.AddAccumulatedMovement
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          AccumulatedMovement                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyWalkingOnly                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSetUseCanWalkOnNaviOnly                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSetUseCanWalkOnFloorOnly                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCharacterMovementComponent::AddAccumulatedMovement(const struct FVector& AccumulatedMovement, bool ApplyWalkingOnly, bool InSetUseCanWalkOnNaviOnly, bool InSetUseCanWalkOnFloorOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "AddAccumulatedMovement");

	Params::LCharacterMovementComponent_AddAccumulatedMovement Parms{};

	Parms.AccumulatedMovement = std::move(AccumulatedMovement);
	Parms.ApplyWalkingOnly = ApplyWalkingOnly;
	Parms.InSetUseCanWalkOnNaviOnly = InSetUseCanWalkOnNaviOnly;
	Parms.InSetUseCanWalkOnFloorOnly = InSetUseCanWalkOnFloorOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacterMovementComponent.SetBrakingDecelerationOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBrakingDecelerationOverride                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCharacterMovementComponent::SetBrakingDecelerationOverride(float InBrakingDecelerationOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "SetBrakingDecelerationOverride");

	Params::LCharacterMovementComponent_SetBrakingDecelerationOverride Parms{};

	Parms.InBrakingDecelerationOverride = InBrakingDecelerationOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacterMovementComponent.SetFrictionOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFrictionOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCharacterMovementComponent::SetFrictionOverride(float InFrictionOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "SetFrictionOverride");

	Params::LCharacterMovementComponent_SetFrictionOverride Parms{};

	Parms.InFrictionOverride = InFrictionOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacterMovementComponent.SetIgnoreRootmotionVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    DoIgnore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCharacterMovementComponent::SetIgnoreRootmotionVelocity(bool DoIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "SetIgnoreRootmotionVelocity");

	Params::LCharacterMovementComponent_SetIgnoreRootmotionVelocity Parms{};

	Parms.DoIgnore = DoIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacterMovementComponent.SetUseVelocityControl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InUseVelocityControl                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxWalkSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCharacterMovementComponent::SetUseVelocityControl(bool InUseVelocityControl, float InMaxWalkSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "SetUseVelocityControl");

	Params::LCharacterMovementComponent_SetUseVelocityControl Parms{};

	Parms.InUseVelocityControl = InUseVelocityControl;
	Parms.InMaxWalkSpeed = InMaxWalkSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCharacterMovementComponent.CheckIsValidLandingSpot
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          CapsuleLocation                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCharacterMovementComponent::CheckIsValidLandingSpot(const struct FVector& CapsuleLocation, const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "CheckIsValidLandingSpot");

	Params::LCharacterMovementComponent_CheckIsValidLandingSpot Parms{};

	Parms.CapsuleLocation = std::move(CapsuleLocation);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCharacterMovementComponent.GetUseVelocityControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCharacterMovementComponent::GetUseVelocityControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCharacterMovementComponent", "GetUseVelocityControl");

	Params::LCharacterMovementComponent_GetUseVelocityControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLevelPreloadBoxComponent.OnComponentBeginOverlapProjectile
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULLevelPreloadBoxComponent::OnComponentBeginOverlapProjectile(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelPreloadBoxComponent", "OnComponentBeginOverlapProjectile");

	Params::LLevelPreloadBoxComponent_OnComponentBeginOverlapProjectile Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelPreloadBoxComponent.OnComponentEndOverlapProjectlie
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLevelPreloadBoxComponent::OnComponentEndOverlapProjectlie(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelPreloadBoxComponent", "OnComponentEndOverlapProjectlie");

	Params::LLevelPreloadBoxComponent_OnComponentEndOverlapProjectlie Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.BullsOne
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::BullsOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "BullsOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.CheckDist
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::CheckDist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "CheckDist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.CheckDistReset
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::CheckDistReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "CheckDistReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.DebugHit
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::DebugHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "DebugHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.Die
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::Die()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "Die");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.DisableNotify
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NotifyType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCheatManager::DisableNotify(const class FString& NotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "DisableNotify");

	Params::LCheatManager_DisableNotify Parms{};

	Parms.NotifyType = std::move(NotifyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.EnableNotify
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NotifyType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCheatManager::EnableNotify(const class FString& NotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "EnableNotify");

	Params::LCheatManager_EnableNotify Parms{};

	Parms.NotifyType = std::move(NotifyType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.GetActivePlayerController
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* ULCheatManager::GetActivePlayerController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "GetActivePlayerController");

	Params::LCheatManager_GetActivePlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCheatManager.IsActiveDebugCamera
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCheatManager::IsActiveDebugCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "IsActiveDebugCamera");

	Params::LCheatManager_IsActiveDebugCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCheatManager.OnePunchMan
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::OnePunchMan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "OnePunchMan");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.RedBull
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::RedBull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "RedBull");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.SetDebugCameraSpeedScale
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSpeedScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCheatManager::SetDebugCameraSpeedScale(float InSpeedScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "SetDebugCameraSpeedScale");

	Params::LCheatManager_SetDebugCameraSpeedScale Parms{};

	Parms.InSpeedScale = InSpeedScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.ToggleDebugCameraHUD
// (Final, Exec, Native, Public)

void ULCheatManager::ToggleDebugCameraHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "ToggleDebugCameraHUD");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.ToggleDebugHitCollision
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::ToggleDebugHitCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "ToggleDebugHitCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.ToggleGameCommandBook
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::ToggleGameCommandBook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "ToggleGameCommandBook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCheatManager.Zombie
// (Final, Exec, Native, Public, BlueprintCallable)

void ULCheatManager::Zombie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCheatManager", "Zombie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LComboTableBase.CheckCurrAction_ActionState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             State                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckCurrAction_ActionState(const class FName State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckCurrAction_ActionState");

	Params::LComboTableBase_CheckCurrAction_ActionState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.CheckCurrAction_Category
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ELActionCategory                        Category                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckCurrAction_Category(const ELActionCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckCurrAction_Category");

	Params::LComboTableBase_CheckCurrAction_Category Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.CheckCurrAction_Class
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             Type                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckCurrAction_Class(const TSoftClassPtr<class UClass> Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckCurrAction_Class");

	Params::LComboTableBase_CheckCurrAction_Class Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.CheckCurrAction_SkillID
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckCurrAction_SkillID(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckCurrAction_SkillID");

	Params::LComboTableBase_CheckCurrAction_SkillID Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.CheckCurrAction_Valid
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckCurrAction_Valid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckCurrAction_Valid");

	Params::LComboTableBase_CheckCurrAction_Valid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.CheckCurrActor_Moving
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckCurrActor_Moving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckCurrActor_Moving");

	Params::LComboTableBase_CheckCurrActor_Moving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.CheckLever_Neutral
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    CheckInputted                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::CheckLever_Neutral(bool CheckInputted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "CheckLever_Neutral");

	Params::LComboTableBase_CheckLever_Neutral Parms{};

	Parms.CheckInputted = CheckInputted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.QueryNextAction
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Lever                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        CurrAction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutActionClass                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLActionInfo                     ActionInfo                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class ULActPayloadBase*                 OutPayload                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULComboTableBase::QueryNextAction(class AActor* TargetActor, class FName Command, const struct FVector& Lever, class ULActBase* CurrAction, class FName* OutActionClass, struct FLActionInfo* ActionInfo, class ULActPayloadBase** OutPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "QueryNextAction");

	Params::LComboTableBase_QueryNextAction Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Command = Command;
	Parms.Lever = std::move(Lever);
	Parms.CurrAction = CurrAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActionClass != nullptr)
		*OutActionClass = Parms.OutActionClass;

	if (ActionInfo != nullptr)
		*ActionInfo = std::move(Parms.ActionInfo);

	if (OutPayload != nullptr)
		*OutPayload = Parms.OutPayload;

	return Parms.ReturnValue;
}


// Function ProjectP.LComboTableBase.Select_Skill
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULComboTableBase::Select_Skill(class FName SkillCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "Select_Skill");

	Params::LComboTableBase_Select_Skill Parms{};

	Parms.SkillCodeName = SkillCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LComboTableBase.SelectDir_CurrentLever
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   RotationTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULComboTableBase::SelectDir_CurrentLever(float RotationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "SelectDir_CurrentLever");

	Params::LComboTableBase_SelectDir_CurrentLever Parms{};

	Parms.RotationTime = RotationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LComboTableBase.SelectDir_InputttedLever
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   RotationTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULComboTableBase::SelectDir_InputttedLever(float RotationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "SelectDir_InputttedLever");

	Params::LComboTableBase_SelectDir_InputttedLever Parms{};

	Parms.RotationTime = RotationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LComboTableBase.SelectDir_LockOnDir
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   RotationTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULComboTableBase::SelectDir_LockOnDir(float RotationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "SelectDir_LockOnDir");

	Params::LComboTableBase_SelectDir_LockOnDir Parms{};

	Parms.RotationTime = RotationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LComboTableBase.Traverse
// (Native, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Lever                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        CurrAction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULComboTableBase::Traverse(class AActor* TargetActor, class FName Command, const struct FVector& Lever, class ULActBase* CurrAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LComboTableBase", "Traverse");

	Params::LComboTableBase_Traverse Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Command = Command;
	Parms.Lever = std::move(Lever);
	Parms.CurrAction = CurrAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSequenceActorData.ExecutePlay
// (Final, Native, Protected)

void ULSequenceActorData::ExecutePlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSequenceActorData", "ExecutePlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSequenceActorData.ExecuteSkipUIControl
// (Final, Native, Protected)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSequenceActorData::ExecuteSkipUIControl(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSequenceActorData", "ExecuteSkipUIControl");

	Params::LSequenceActorData_ExecuteSkipUIControl Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSequenceActorData.OnFinishedSequencePlayer
// (Final, Native, Protected)

void ULSequenceActorData::OnFinishedSequencePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSequenceActorData", "OnFinishedSequencePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSequenceActorData.OnFinishedSkipSequenceActor
// (Final, Native, Protected)

void ULSequenceActorData::OnFinishedSkipSequenceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSequenceActorData", "OnFinishedSkipSequenceActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSequenceActorData.OnPlaySequencePlayer
// (Final, Native, Protected)

void ULSequenceActorData::OnPlaySequencePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSequenceActorData", "OnPlaySequencePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSequenceActorData.OnStopSequencePlayer
// (Final, Native, Protected)

void ULSequenceActorData::OnStopSequencePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSequenceActorData", "OnStopSequencePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLiftObject.OnActorBeginOverlapToAudioVolume
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLiftObject::OnActorBeginOverlapToAudioVolume(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLiftObject", "OnActorBeginOverlapToAudioVolume");

	Params::LLiftObject_OnActorBeginOverlapToAudioVolume Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLiftObject.OnActorEndOverlapToAudioVolume
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLiftObject::OnActorEndOverlapToAudioVolume(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLiftObject", "OnActorEndOverlapToAudioVolume");

	Params::LLiftObject_OnActorEndOverlapToAudioVolume Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLiftObject.PlayInteractMotion
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALLiftObject::PlayInteractMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLiftObject", "PlayInteractMotion");

	Params::LLiftObject_PlayInteractMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LLiftObject.SetDoorState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELDoorState                             StateData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLiftObject::SetDoorState(ELDoorState StateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLiftObject", "SetDoorState");

	Params::LLiftObject_SetDoorState Parms{};

	Parms.StateData = StateData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLiftObject.SetLiftObjectState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELLiftObjectState                       StateData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLiftObject::SetLiftObjectState(ELLiftObjectState StateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLiftObject", "SetLiftObjectState");

	Params::LLiftObject_SetLiftObjectState Parms{};

	Parms.StateData = StateData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLiftObject.SetPropLiftState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELPropLiftStateType                     StateData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALLiftObject::SetPropLiftState(ELPropLiftStateType StateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLiftObject", "SetPropLiftState");

	Params::LLiftObject_SetPropLiftState Parms{};

	Parms.StateData = StateData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LQuartzPocket.InstallSlotFromUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSlotIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             QuartzEffectCodeName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuartzPocket::InstallSlotFromUI(int32 InSlotIndex, class FName QuartzEffectCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzPocket", "InstallSlotFromUI");

	Params::LQuartzPocket_InstallSlotFromUI Parms{};

	Parms.InSlotIndex = InSlotIndex;
	Parms.QuartzEffectCodeName = QuartzEffectCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzPocket.GetPocketLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULQuartzPocket::GetPocketLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzPocket", "GetPocketLevel");

	Params::LQuartzPocket_GetPocketLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzPocket.IsPocketUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuartzPocket::IsPocketUnlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzPocket", "IsPocketUnlocked");

	Params::LQuartzPocket_IsPocketUnlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.CheckTargetHittable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::CheckTargetHittable(class AActor* Victim, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "CheckTargetHittable");

	Params::LProjectile_CheckTargetHittable Parms{};

	Parms.Victim = Victim;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.CheckValidFaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::CheckValidFaction(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "CheckValidFaction");

	Params::LProjectile_CheckValidFaction Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.CheckValidOverlapTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::CheckValidOverlapTarget(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "CheckValidOverlapTarget");

	Params::LProjectile_CheckValidOverlapTarget Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.CheckValidTargetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::CheckValidTargetType(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "CheckValidTargetType");

	Params::LProjectile_CheckValidTargetType Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.ClearOverlappedActorList
// (Final, Native, Public, BlueprintCallable)

void ALProjectile::ClearOverlappedActorList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "ClearOverlappedActorList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.GenerateHit
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo              HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile::GenerateHit(const struct FLProjectileHitInfo& HitInfo, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "GenerateHit");

	Params::LProjectile_GenerateHit Parms{};

	Parms.HitInfo = std::move(HitInfo);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.GenerateHit_TargetOnly
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo              ProjectileHitInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::GenerateHit_TargetOnly(const struct FLProjectileHitInfo& ProjectileHitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "GenerateHit_TargetOnly");

	Params::LProjectile_GenerateHit_TargetOnly Parms{};

	Parms.ProjectileHitInfo = std::move(ProjectileHitInfo);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.GenerateHit_TargetOnly_V2
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo_V2           ProjectileHitInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::GenerateHit_TargetOnly_V2(const struct FLProjectileHitInfo_V2& ProjectileHitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "GenerateHit_TargetOnly_V2");

	Params::LProjectile_GenerateHit_TargetOnly_V2 Parms{};

	Parms.ProjectileHitInfo = std::move(ProjectileHitInfo);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.GenerateHit_V2
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo_V2           HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile::GenerateHit_V2(const struct FLProjectileHitInfo_V2& HitInfo, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "GenerateHit_V2");

	Params::LProjectile_GenerateHit_V2 Parms{};

	Parms.HitInfo = std::move(HitInfo);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.GetOverlappedActorList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   OutList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALProjectile::GetOverlappedActorList(TArray<class AActor*>* OutList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "GetOverlappedActorList");

	Params::LProjectile_GetOverlappedActorList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);
}


// Function ProjectP.LProjectile.InitializeFromProjectileDesign
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectile::InitializeFromProjectileDesign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "InitializeFromProjectileDesign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.InitProjectile
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FProjectileInfoPtr               InInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLProjectileSpawnParameter       SpawnParameters                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::InitProjectile(const struct FProjectileInfoPtr& InInfo, const struct FLProjectileSpawnParameter& SpawnParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "InitProjectile");

	Params::LProjectile_InitProjectile Parms{};

	Parms.InInfo = std::move(InInfo);
	Parms.SpawnParameters = std::move(SpawnParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.IsStopByNotify
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::IsStopByNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "IsStopByNotify");

	Params::LProjectile_IsStopByNotify Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.IsStopByRootOwnerDie
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::IsStopByRootOwnerDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "IsStopByRootOwnerDie");

	Params::LProjectile_IsStopByRootOwnerDie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.OnAttachedActorEndPlay
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile::OnAttachedActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnAttachedActorEndPlay");

	Params::LProjectile_OnAttachedActorEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnAttackedByOther
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile::OnAttackedByOther(class AActor* Other, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnAttackedByOther");

	Params::LProjectile_OnAttackedByOther Parms{};

	Parms.Other = Other;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnCollisionBeginOverlap
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnCollisionBeginOverlap");

	Params::LProjectile_OnCollisionBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnCollisionHit
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::OnCollisionHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnCollisionHit");

	Params::LProjectile_OnCollisionHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnDeadParentCharacter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALCharacter*                      DeadCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile::OnDeadParentCharacter(class ALCharacter* DeadCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnDeadParentCharacter");

	Params::LProjectile_OnDeadParentCharacter Parms{};

	Parms.DeadCharacter = DeadCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnDisappear
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELProjectileDestroyReason               Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::OnDisappear(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnDisappear");

	Params::LProjectile_OnDisappear Parms{};

	Parms.Reason = Reason;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnExplode
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELProjectileDestroyReason               Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::OnExplode(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnExplode");

	Params::LProjectile_OnExplode Parms{};

	Parms.Reason = Reason;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.OnLifeTimeOver
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectile::OnLifeTimeOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "OnLifeTimeOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.ProcessHit
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo              HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::ProcessHit(const struct FLProjectileHitInfo& HitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "ProcessHit");

	Params::LProjectile_ProcessHit Parms{};

	Parms.HitInfo = std::move(HitInfo);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.ProcessHitProp
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo              ProjectileHitInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectile::ProcessHitProp(const struct FLProjectileHitInfo& ProjectileHitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "ProcessHitProp");

	Params::LProjectile_ProcessHitProp Parms{};

	Parms.ProjectileHitInfo = std::move(ProjectileHitInfo);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.Reset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectile::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.SenseTarget
// (Final, Native, Public, BlueprintCallable)

void ALProjectile::SenseTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "SenseTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.SpawnChildren
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLChildProjectileSpawnInfo       ChildSpawnInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALProjectile::SpawnChildren(const struct FLChildProjectileSpawnInfo& ChildSpawnInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "SpawnChildren");

	Params::LProjectile_SpawnChildren Parms{};

	Parms.ChildSpawnInfo = std::move(ChildSpawnInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.SpawnProjectileDesignActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectile::SpawnProjectileDesignActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "SpawnProjectileDesignActor");

	Params::LProjectile_SpawnProjectileDesignActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectile.Start
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectile::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.StartCollisionCheck
// (Final, Native, Public, BlueprintCallable)

void ALProjectile::StartCollisionCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "StartCollisionCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.Stop
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectile::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.StopApplyAbnormal
// (Final, Native, Public, BlueprintCallable)

void ALProjectile::StopApplyAbnormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "StopApplyAbnormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.StopGeneratePeriodicHit
// (Final, Native, Public, BlueprintCallable)

void ALProjectile::StopGeneratePeriodicHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "StopGeneratePeriodicHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.StopSpawnChildren
// (Final, Native, Public, BlueprintCallable)

void ALProjectile::StopSpawnChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "StopSpawnChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile.UpdateOverlapEvents
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile::UpdateOverlapEvents(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile", "UpdateOverlapEvents");

	Params::LProjectile_UpdateOverlapEvents Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileHit_PeriodicHandler_V2.Clear
// (Final, Native, Public, BlueprintCallable)

void ULProjectileHit_PeriodicHandler_V2::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileHit_PeriodicHandler_V2", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileHit_PeriodicHandler_V2.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALProjectile*                     InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLProjectileHitInfo_V2           InHitInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULProjectileHit_PeriodicHandler_V2::Initialize(class ALProjectile* InOwner, const struct FLProjectileHitInfo_V2& InHitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileHit_PeriodicHandler_V2", "Initialize");

	Params::LProjectileHit_PeriodicHandler_V2_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InHitInfo = std::move(InHitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileHit_PeriodicHandler_V2.OnGenerateHit
// (Final, Native, Public, BlueprintCallable)

void ULProjectileHit_PeriodicHandler_V2::OnGenerateHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileHit_PeriodicHandler_V2", "OnGenerateHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerItemLocker.AbandonItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RemoveCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerItemLocker::AbandonItem(class ULItem* Item, int32 RemoveCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "AbandonItem");

	Params::LPlayerItemLocker_AbandonItem Parms{};

	Parms.Item = Item;
	Parms.RemoveCount = RemoveCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.AddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerItemLocker::AddItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "AddItem");

	Params::LPlayerItemLocker_AddItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.EmptyItems
// (Final, Native, Public, BlueprintCallable)

void ULPlayerItemLocker::EmptyItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "EmptyItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerItemLocker.FindCategoryItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemSecondCategory                    Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerItemLocker::FindCategoryItems(ELItemSecondCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "FindCategoryItems");

	Params::LPlayerItemLocker_FindCategoryItems Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.FindItemByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULPlayerItemLocker::FindItemByCodeName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "FindItemByCodeName");

	Params::LPlayerItemLocker_FindItemByCodeName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.FindItemsByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerItemLocker::FindItemsByCodeName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "FindItemsByCodeName");

	Params::LPlayerItemLocker_FindItemsByCodeName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.FindUICategoryItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerItemLocker::FindUICategoryItems(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "FindUICategoryItems");

	Params::LPlayerItemLocker_FindUICategoryItems Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerItemLocker::GetAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetAllItems");

	Params::LPlayerItemLocker_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetCommonItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerItemLocker::GetCommonItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetCommonItems");

	Params::LPlayerItemLocker_GetCommonItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetItemCategoryMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<ELItemSecondCategory, struct FLInvenCategoryItemList>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> ULPlayerItemLocker::GetItemCategoryMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetItemCategoryMap");

	Params::LPlayerItemLocker_GetItemCategoryMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetItemTotalCountByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayerItemLocker::GetItemTotalCountByCodeName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetItemTotalCountByCodeName");

	Params::LPlayerItemLocker_GetItemTotalCountByCodeName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetMaxItemCountMovableToInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayerItemLocker::GetMaxItemCountMovableToInventory(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetMaxItemCountMovableToInventory");

	Params::LPlayerItemLocker_GetMaxItemCountMovableToInventory Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetRequirementItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerItemLocker::GetRequirementItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetRequirementItems");

	Params::LPlayerItemLocker_GetRequirementItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetWeaponItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULWeaponItem*>       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULWeaponItem*> ULPlayerItemLocker::GetWeaponItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetWeaponItems");

	Params::LPlayerItemLocker_GetWeaponItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.GetWeaponTotalCountByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HandleCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BladeCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayerItemLocker::GetWeaponTotalCountByCodeName(class FName HandleCodeName, class FName BladeCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "GetWeaponTotalCountByCodeName");

	Params::LPlayerItemLocker_GetWeaponTotalCountByCodeName Parms{};

	Parms.HandleCodeName = HandleCodeName;
	Parms.BladeCodeName = BladeCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.HasItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerItemLocker::HasItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "HasItem");

	Params::LPlayerItemLocker_HasItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.MoveItemToInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bManualMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerItemLocker::MoveItemToInventory(class ULItem* Item, int32 ItemCount, bool bManualMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "MoveItemToInventory");

	Params::LPlayerItemLocker_MoveItemToInventory Parms{};

	Parms.Item = Item;
	Parms.ItemCount = ItemCount;
	Parms.bManualMove = bManualMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.RefillMonadUnitItem
// (Final, Native, Public, BlueprintCallable)

void ULPlayerItemLocker::RefillMonadUnitItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "RefillMonadUnitItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerItemLocker.RemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerItemLocker::RemoveItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "RemoveItem");

	Params::LPlayerItemLocker_RemoveItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerItemLocker.HasSameItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerItemLocker::HasSameItem(class FName ItemCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerItemLocker", "HasSameItem");

	Params::LPlayerItemLocker_HasSameItem Parms{};

	Parms.ItemCodeName = ItemCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.CanStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProduct::CanStackCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "CanStackCount");

	Params::LProduct_CanStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULProduct::GetItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "GetItem");

	Params::LProduct_GetItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.Price
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULProduct::Price()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "Price");

	Params::LProduct_Price Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.StockCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULProduct::StockCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "StockCount");

	Params::LProduct_StockCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.BuyNumMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULProduct::BuyNumMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "BuyNumMax");

	Params::LProduct_BuyNumMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.CanBuyInfinity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProduct::CanBuyInfinity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "CanBuyInfinity");

	Params::LProduct_CanBuyInfinity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.CanDisplayOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProduct::CanDisplayOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "CanDisplayOn");

	Params::LProduct_CanDisplayOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.GetProductType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELShopProductType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELShopProductType ULProduct::GetProductType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "GetProductType");

	Params::LProduct_GetProductType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.IsWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProduct::IsWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "IsWeapon");

	Params::LProduct_IsWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.Needs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLSpecialShopExchangeNeeds       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLSpecialShopExchangeNeeds ULProduct::Needs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "Needs");

	Params::LProduct_Needs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProduct.OriginStockCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULProduct::OriginStockCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProduct", "OriginStockCount");

	Params::LProduct_OriginStockCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSpecialShop.Buy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULProduct*                        InProduct                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProductSpecialShop::Buy(class ULProduct* InProduct, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSpecialShop", "Buy");

	Params::LProductSpecialShop_Buy Parms{};

	Parms.InProduct = InProduct;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSpecialShop.GetBuyCategorys
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<ELItemFirstCategory>               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<ELItemFirstCategory> ULProductSpecialShop::GetBuyCategorys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSpecialShop", "GetBuyCategorys");

	Params::LProductSpecialShop_GetBuyCategorys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSpecialShop.GetBuyList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULProduct*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULProduct*> ULProductSpecialShop::GetBuyList(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSpecialShop", "GetBuyList");

	Params::LProductSpecialShop_GetBuyList Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.GetHarvestRemainSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGoldenTree::GetHarvestRemainSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "GetHarvestRemainSec");

	Params::LGoldenTree_GetHarvestRemainSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.OnGameDataCharacterSync
// (Final, Native, Private)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGoldenTree::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "OnGameDataCharacterSync");

	Params::LGoldenTree_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGoldenTree.GetBoostExcelGoalSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGoldenTree::GetBoostExcelGoalSec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "GetBoostExcelGoalSec");

	Params::LGoldenTree_GetBoostExcelGoalSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.GetBoostExcelSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGoldenTree::GetBoostExcelSec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "GetBoostExcelSec");

	Params::LGoldenTree_GetBoostExcelSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.GetGoldStackLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGoldenTree::GetGoldStackLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "GetGoldStackLimit");

	Params::LGoldenTree_GetGoldStackLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.GetHarvestableCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGoldenTree::GetHarvestableCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "GetHarvestableCount");

	Params::LGoldenTree_GetHarvestableCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELGoldenTreeState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELGoldenTreeState ULGoldenTree::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "GetState");

	Params::LGoldenTree_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.IsBoostNow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGoldenTree::IsBoostNow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "IsBoostNow");

	Params::LGoldenTree_IsBoostNow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGoldenTree.IsPlayerReached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGoldenTree::IsPlayerReached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGoldenTree", "IsPlayerReached");

	Params::LGoldenTree_IsPlayerReached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPropHelpMateSpot.OnInteractionRetry
// (Final, Native, Protected)

void ALPropHelpMateSpot::OnInteractionRetry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropHelpMateSpot", "OnInteractionRetry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropHelpMateSpot.OnOpenPopupHelpMate
// (Final, Native, Protected)

void ALPropHelpMateSpot::OnOpenPopupHelpMate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropHelpMateSpot", "OnOpenPopupHelpMate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropHelpMateSpot.OnUIHelpMatePopupResult
// (Final, Native, Protected)
// Parameters:
// bool                                    PopupResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPropHelpMateSpot::OnUIHelpMatePopupResult(bool PopupResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropHelpMateSpot", "OnUIHelpMatePopupResult");

	Params::LPropHelpMateSpot_OnUIHelpMatePopupResult Parms{};

	Parms.PopupResult = PopupResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropLevelSequenceSpot.OnFinishedCurrentSequenceActor
// (Final, Native, Protected)

void ALPropLevelSequenceSpot::OnFinishedCurrentSequenceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropLevelSequenceSpot", "OnFinishedCurrentSequenceActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProductBuyShop.Buy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULProduct*                        InProduct                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProductBuyShop::Buy(class ULProduct* InProduct, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductBuyShop", "Buy");

	Params::LProductBuyShop_Buy Parms{};

	Parms.InProduct = InProduct;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductBuyShop.GetBuyCategorys
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<ELItemFirstCategory>               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<ELItemFirstCategory> ULProductBuyShop::GetBuyCategorys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductBuyShop", "GetBuyCategorys");

	Params::LProductBuyShop_GetBuyCategorys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductBuyShop.GetBuyList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULProduct*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULProduct*> ULProductBuyShop::GetBuyList(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductBuyShop", "GetBuyList");

	Params::LProductBuyShop_GetBuyList Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTalker.GetCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULTalker::GetCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTalker", "GetCodeName");

	Params::LTalker_GetCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTileView.GetScrollOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULTileView::GetScrollOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTileView", "GetScrollOffset");

	Params::LTileView_GetScrollOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTutorialSystem.CheckBattlePendingList
// (Final, Native, Protected)

void ULTutorialSystem::CheckBattlePendingList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "CheckBattlePendingList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTutorialSystem.ClearTutorialState
// (Final, Native, Public)

void ULTutorialSystem::ClearTutorialState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "ClearTutorialState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTutorialSystem.EndTutorialUI
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             TutorialCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULTutorialSystem::EndTutorialUI(const class FName& TutorialCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "EndTutorialUI");

	Params::LTutorialSystem_EndTutorialUI Parms{};

	Parms.TutorialCodeName = TutorialCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTutorialSystem.ExecuteTutorial
// (Final, Native, Public)
// Parameters:
// class FName                             TutorialCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PriorityPendingData                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULTutorialSystem::ExecuteTutorial(class FName TutorialCodeName, bool PriorityPendingData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "ExecuteTutorial");

	Params::LTutorialSystem_ExecuteTutorial Parms{};

	Parms.TutorialCodeName = TutorialCodeName;
	Parms.PriorityPendingData = PriorityPendingData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTutorialSystem.GetCurrentTutorialList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     OutTutorialList                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULTutorialSystem::GetCurrentTutorialList(TArray<class FName>* OutTutorialList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "GetCurrentTutorialList");

	Params::LTutorialSystem_GetCurrentTutorialList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTutorialList != nullptr)
		*OutTutorialList = std::move(Parms.OutTutorialList);
}


// Function ProjectP.LTutorialSystem.GetDescriptionText
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TutorialCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StepNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULTutorialSystem::GetDescriptionText(const class FName& TutorialCodeName, int32 StepNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "GetDescriptionText");

	Params::LTutorialSystem_GetDescriptionText Parms{};

	Parms.TutorialCodeName = TutorialCodeName;
	Parms.StepNum = StepNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTutorialSystem.GetTitleText
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TutorialCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StepNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULTutorialSystem::GetTitleText(const class FName& TutorialCodeName, int32 StepNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "GetTitleText");

	Params::LTutorialSystem_GetTitleText Parms{};

	Parms.TutorialCodeName = TutorialCodeName;
	Parms.StepNum = StepNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTutorialSystem.GetTutorialMaxStep
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TutorialCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULTutorialSystem::GetTutorialMaxStep(const class FName& TutorialCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "GetTutorialMaxStep");

	Params::LTutorialSystem_GetTutorialMaxStep Parms{};

	Parms.TutorialCodeName = TutorialCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTutorialSystem.GetWindowTutorialCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULTutorialSystem::GetWindowTutorialCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "GetWindowTutorialCodeName");

	Params::LTutorialSystem_GetWindowTutorialCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTutorialSystem.OnGameInitTutorial
// (Final, Native, Protected)

void ULTutorialSystem::OnGameInitTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "OnGameInitTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTutorialSystem.GetTutorialDB_TutorialInfo
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TutorialCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TutorialStep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTutorialInfoPtr                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTutorialInfoPtr ULTutorialSystem::GetTutorialDB_TutorialInfo(const class FName& TutorialCodeName, int32 TutorialStep) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTutorialSystem", "GetTutorialDB_TutorialInfo");

	Params::LTutorialSystem_GetTutorialDB_TutorialInfo Parms{};

	Parms.TutorialCodeName = TutorialCodeName;
	Parms.TutorialStep = TutorialStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmTree.ActivateTreeFromUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmTree::ActivateTreeFromUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmTree", "ActivateTreeFromUI");

	Params::LSlaveArmTree_ActivateTreeFromUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmTree.SetActivate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewActivate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedCalcPlayerStat                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSlaveArmTree::SetActivate(bool bNewActivate, bool bNeedCalcPlayerStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmTree", "SetActivate");

	Params::LSlaveArmTree_SetActivate Parms{};

	Parms.bNewActivate = bNewActivate;
	Parms.bNeedCalcPlayerStat = bNeedCalcPlayerStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.ForceStop
// (Final, Native, Public, BlueprintCallable)

void ULSoundControlComponent::ForceStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "ForceStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.OnBossRoomDestroyed
// (Final, Native, Public)
// Parameters:
// class FString                           BossRoomUniqueId                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundControlComponent::OnBossRoomDestroyed(const class FString& BossRoomUniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "OnBossRoomDestroyed");

	Params::LSoundControlComponent_OnBossRoomDestroyed Parms{};

	Parms.BossRoomUniqueId = std::move(BossRoomUniqueId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.OnGlobalVariableChanged
// (Final, Native, Public)
// Parameters:
// class FName                             InGlobalVariable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundControlComponent::OnGlobalVariableChanged(class FName InGlobalVariable, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "OnGlobalVariableChanged");

	Params::LSoundControlComponent_OnGlobalVariableChanged Parms{};

	Parms.InGlobalVariable = InGlobalVariable;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.OnNpcDead
// (Final, Native, Public)
// Parameters:
// class FString                           NpcSpotUniqueID                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundControlComponent::OnNpcDead(const class FString& NpcSpotUniqueID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "OnNpcDead");

	Params::LSoundControlComponent_OnNpcDead Parms{};

	Parms.NpcSpotUniqueID = std::move(NpcSpotUniqueID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.OnPlayStateChanged
// (Final, Native, Public)
// Parameters:
// EAudioComponentPlayState                PlayState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundControlComponent::OnPlayStateChanged(EAudioComponentPlayState PlayState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "OnPlayStateChanged");

	Params::LSoundControlComponent_OnPlayStateChanged Parms{};

	Parms.PlayState = PlayState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.OnWeatherChanged
// (Final, Native, Public)
// Parameters:
// class FName                             InWeatherCodeName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundControlComponent::OnWeatherChanged(class FName InWeatherCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "OnWeatherChanged");

	Params::LSoundControlComponent_OnWeatherChanged Parms{};

	Parms.InWeatherCodeName = InWeatherCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.Play
// (Final, Native, Public, BlueprintCallable)

void ULSoundControlComponent::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.PlayInstant
// (Final, Native, Public, BlueprintCallable)

void ULSoundControlComponent::PlayInstant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "PlayInstant");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundControlComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void ULSoundControlComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundControlComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileDesign.CheckCustomOverlapDestroyCondition
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALProjectileDesign::CheckCustomOverlapDestroyCondition(class AActor* OverlappedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "CheckCustomOverlapDestroyCondition");

	Params::LProjectileDesign_CheckCustomOverlapDestroyCondition Parms{};

	Parms.OverlappedActor = OverlappedActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileDesign.CheckUseSubstituteSkillHit
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLProjectileHitInfo              ProjectileHitInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALProjectileDesign::CheckUseSubstituteSkillHit(const struct FLProjectileHitInfo& ProjectileHitInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "CheckUseSubstituteSkillHit");

	Params::LProjectileDesign_CheckUseSubstituteSkillHit Parms{};

	Parms.ProjectileHitInfo = std::move(ProjectileHitInfo);
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileDesign.EndProjectileDesign
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectileDesign::EndProjectileDesign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "EndProjectileDesign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileDesign.GetProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALProjectile*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALProjectile* ALProjectileDesign::GetProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "GetProjectile");

	Params::LProjectileDesign_GetProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileDesign.InitProjectile
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectileDesign::InitProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "InitProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileDesign.OnAttakedByOther
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectileDesign::OnAttakedByOther(class AActor* Other, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "OnAttakedByOther");

	Params::LProjectileDesign_OnAttakedByOther Parms{};

	Parms.Other = Other;
	Parms.SkillHitCodeName = SkillHitCodeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LProjectileDesign.OnBounce
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectileDesign::OnBounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "OnBounce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LProjectileDesign.OnDisappear
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELProjectileDestroyReason               Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectileDesign::OnDisappear(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "OnDisappear");

	Params::LProjectileDesign_OnDisappear Parms{};

	Parms.Reason = Reason;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LProjectileDesign.OnExplode
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELProjectileDestroyReason               Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALProjectileDesign::OnExplode(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "OnExplode");

	Params::LProjectileDesign_OnExplode Parms{};

	Parms.Reason = Reason;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LProjectileDesign.OnSpawnChildren
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALProjectile*                     ChildProjectile                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectileDesign::OnSpawnChildren(class ALProjectile* ChildProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "OnSpawnChildren");

	Params::LProjectileDesign_OnSpawnChildren Parms{};

	Parms.ChildProjectile = ChildProjectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LProjectileDesign.Pause
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPauseFlag                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectileDesign::Pause(bool bPauseFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "Pause");

	Params::LProjectileDesign_Pause Parms{};

	Parms.bPauseFlag = bPauseFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileDesign.RefineHitTarget
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               InHitResults                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> ALProjectileDesign::RefineHitTarget(const TArray<struct FHitResult>& InHitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "RefineHitTarget");

	Params::LProjectileDesign_RefineHitTarget Parms{};

	Parms.InHitResults = std::move(InHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileDesign.ReserveDestroy
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALProjectileDesign::ReserveDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileDesign", "ReserveDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LSpecialBuff.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCharacter*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCharacter* ULSpecialBuff::GetOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff", "GetOwner");

	Params::LSpecialBuff_GetOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSpecialBuff.OnAttached
// (Native, Public, BlueprintCallable)

void ULSpecialBuff::OnAttached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff", "OnAttached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff.OnDetached
// (Native, Public, BlueprintCallable)

void ULSpecialBuff::OnDetached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff", "OnDetached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff.Tick
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff::Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff", "Tick");

	Params::LSpecialBuff_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelInactiveInterface.ActivateLevelActor
// (Event, Public, BlueprintEvent)

void ILLevelInactiveInterface::ActivateLevelActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelInactiveInterface", "ActivateLevelActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LLevelInactiveInterface.DeactivateLevelActor
// (Event, Public, BlueprintEvent)

void ILLevelInactiveInterface::DeactivateLevelActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelInactiveInterface", "DeactivateLevelActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LStargazerObject.ResetDilationTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALStargazerObject::ResetDilationTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStargazerObject", "ResetDilationTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStargazerObject.SetStargazerType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELStargazerType                         StateData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALStargazerObject::SetStargazerType(ELStargazerType StateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStargazerObject", "SetStargazerType");

	Params::LStargazerObject_SetStargazerType Parms{};

	Parms.StateData = StateData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStargazerObject.SetStargazerUnstable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Unstable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALStargazerObject::SetStargazerUnstable(bool Unstable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStargazerObject", "SetStargazerUnstable");

	Params::LStargazerObject_SetStargazerUnstable Parms{};

	Parms.Unstable = Unstable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStargazerObject.UpdateDilationTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DilationScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALStargazerObject::UpdateDilationTime(float DeltaTime, float DilationScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStargazerObject", "UpdateDilationTime");

	Params::LStargazerObject_UpdateDilationTime Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.DilationScale = DilationScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMonologControl.GetScriptText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULMonologControl::GetScriptText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMonologControl", "GetScriptText");

	Params::LMonologControl_GetScriptText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMonologControl.OnCompleteSingleMonologPlay
// (Final, Native, Public, BlueprintCallable)

void ULMonologControl::OnCompleteSingleMonologPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMonologControl", "OnCompleteSingleMonologPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMonologControl.PlayRepeat
// (Final, Native, Protected, BlueprintCallable)

void ULMonologControl::PlayRepeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMonologControl", "PlayRepeat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMonologControl.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMonologControl::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMonologControl", "IsValid");

	Params::LMonologControl_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.CanKeep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::CanKeep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "CanKeep");

	Params::LItem_CanKeep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.ChangeCorrection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::ChangeCorrection(ELStatCorrectChangeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "ChangeCorrection");

	Params::LItem_ChangeCorrection Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetAssistUseSlotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELAssistUseItemSlotType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELAssistUseItemSlotType ULItem::GetAssistUseSlotType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetAssistUseSlotType");

	Params::LItem_GetAssistUseSlotType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetEquipSlotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELEquipSlotType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELEquipSlotType ULItem::GetEquipSlotType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetEquipSlotType");

	Params::LItem_GetEquipSlotType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetMaxStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetMaxStackCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetMaxStackCount");

	Params::LItem_GetMaxStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetRawSlaveArmStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetRawSlaveArmStat(ELSecondStat InStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetRawSlaveArmStat");

	Params::LItem_GetRawSlaveArmStat Parms{};

	Parms.InStat = InStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetSlavearmAlteredItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULItem::GetSlavearmAlteredItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetSlavearmAlteredItem");

	Params::LItem_GetSlavearmAlteredItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetSlaveArmStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVirtual                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetSlaveArmStat(class AActor* InOwner, ELSecondStat InStat, bool IsVirtual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetSlaveArmStat");

	Params::LItem_GetSlaveArmStat Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;
	Parms.IsVirtual = IsVirtual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetSlaveArmStatBonus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsVirtual                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetSlaveArmStatBonus(class AActor* InOwner, ELSecondStat InStat, bool IsVirtual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetSlaveArmStatBonus");

	Params::LItem_GetSlaveArmStatBonus Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;
	Parms.IsVirtual = IsVirtual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetUseSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetUseSlotIndex(bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetUseSlotIndex");

	Params::LItem_GetUseSlotIndex Parms{};

	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsEquipped");

	Params::LItem_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsEquippedAssistUseItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsEquippedAssistUseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsEquippedAssistUseItem");

	Params::LItem_IsEquippedAssistUseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsEquippedUseItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    OutIsFirstLine                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsEquippedUseItem(bool* OutIsFirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsEquippedUseItem");

	Params::LItem_IsEquippedUseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIsFirstLine != nullptr)
		*OutIsFirstLine = Parms.OutIsFirstLine;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.Reinforce
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::Reinforce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "Reinforce");

	Params::LItem_Reinforce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.SetComplexItem_UseMainInstead
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    UseMainInstead                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItem::SetComplexItem_UseMainInstead(bool UseMainInstead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "SetComplexItem_UseMainInstead");

	Params::LItem_SetComplexItem_UseMainInstead Parms{};

	Parms.UseMainInstead = UseMainInstead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItem.SetCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItem::SetCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "SetCount");

	Params::LItem_SetCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItem.SetSlavearmAlteredItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           InAlteredItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItem::SetSlavearmAlteredItem(class ULItem* InAlteredItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "SetSlavearmAlteredItem");

	Params::LItem_SetSlavearmAlteredItem Parms{};

	Parms.InAlteredItem = InAlteredItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItem.CanChangeCorrection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::CanChangeCorrection(ELStatCorrectChangeType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "CanChangeCorrection");

	Params::LItem_CanChangeCorrection Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.CanCombineBlade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELBladeShapeType                        BladeShapeType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::CanCombineBlade(ELBladeShapeType BladeShapeType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "CanCombineBlade");

	Params::LItem_CanCombineBlade Parms{};

	Parms.BladeShapeType = BladeShapeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.CanReinforce
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::CanReinforce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "CanReinforce");

	Params::LItem_CanReinforce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.CanStackCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::CanStackCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "CanStackCount");

	Params::LItem_CanStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetChangeCorrectionInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHandleStatCorrectionChangeInfoPtrReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FHandleStatCorrectionChangeInfoPtr ULItem::GetChangeCorrectionInfo(ELStatCorrectChangeType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetChangeCorrectionInfo");

	Params::LItem_GetChangeCorrectionInfo Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetChangedCorrectionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELStatCorrectChangeType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELStatCorrectChangeType ULItem::GetChangedCorrectionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetChangedCorrectionType");

	Params::LItem_GetChangedCorrectionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULItem::GetCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetCodeName");

	Params::LItem_GetCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetCollectionInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemCollectionInfoPtr           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemCollectionInfoPtr ULItem::GetCollectionInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetCollectionInfo");

	Params::LItem_GetCollectionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetCommonInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemCommonInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemCommonInfoPtr ULItem::GetCommonInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetCommonInfo");

	Params::LItem_GetCommonInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetComplexItem_Main
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULItem::GetComplexItem_Main() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetComplexItem_Main");

	Params::LItem_GetComplexItem_Main Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetComplexItem_Unit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULItem::GetComplexItem_Unit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetComplexItem_Unit");

	Params::LItem_GetComplexItem_Unit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetConsumeInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemConsumeInfoPtr              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemConsumeInfoPtr ULItem::GetConsumeInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetConsumeInfo");

	Params::LItem_GetConsumeInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetCorrectionGrade
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELFirstStat                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELStatCorrectChangeType                 WillBeChangeCorrection                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutStackLevel                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHandleCorrectResultGrade              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELHandleCorrectResultGrade ULItem::GetCorrectionGrade(ELFirstStat Type, ELStatCorrectChangeType WillBeChangeCorrection, int32* OutStackLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetCorrectionGrade");

	Params::LItem_GetCorrectionGrade Parms{};

	Parms.Type = Type;
	Parms.WillBeChangeCorrection = WillBeChangeCorrection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStackLevel != nullptr)
		*OutStackLevel = Parms.OutStackLevel;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetCount");

	Params::LItem_GetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetDurabilityAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetDurabilityAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetDurabilityAmount");

	Params::LItem_GetDurabilityAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetFirstCategory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELItemFirstCategory                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELItemFirstCategory ULItem::GetFirstCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetFirstCategory");

	Params::LItem_GetFirstCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetImageResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> ULItem::GetImageResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetImageResource");

	Params::LItem_GetImageResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ULItem::GetItemId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetItemId");

	Params::LItem_GetItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetMaxSharpnessPoint
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeSharpnessStatBonus                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeGrindingReducement                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetMaxSharpnessPoint(bool bIncludeSharpnessStatBonus, bool WillReinforceDiffStat, bool bIncludeGrindingReducement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetMaxSharpnessPoint");

	Params::LItem_GetMaxSharpnessPoint Parms{};

	Parms.bIncludeSharpnessStatBonus = bIncludeSharpnessStatBonus;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;
	Parms.bIncludeGrindingReducement = bIncludeGrindingReducement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetMaxSharpnessPointByType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELBladeSharpnessType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSharpnessStatBonus                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetMaxSharpnessPointByType(ELBladeSharpnessType Type, bool bIncludeSharpnessStatBonus, bool WillReinforceDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetMaxSharpnessPointByType");

	Params::LItem_GetMaxSharpnessPointByType Parms{};

	Parms.Type = Type;
	Parms.bIncludeSharpnessStatBonus = bIncludeSharpnessStatBonus;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetNextReinforceInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemWeaponReinforceInfoPtr      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemWeaponReinforceInfoPtr ULItem::GetNextReinforceInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetNextReinforceInfo");

	Params::LItem_GetNextReinforceInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetPartsInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemPartsInfoPtr                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemPartsInfoPtr ULItem::GetPartsInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetPartsInfo");

	Params::LItem_GetPartsInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetRawWeaponStat
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELStatCorrectChangeType                 WillHandleDiffStat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetRawWeaponStat(ELSecondStat InStat, bool WillReinforceDiffStat, ELStatCorrectChangeType WillHandleDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetRawWeaponStat");

	Params::LItem_GetRawWeaponStat Parms{};

	Parms.InStat = InStat;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;
	Parms.WillHandleDiffStat = WillHandleDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetReinforceInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemWeaponReinforceInfoPtr      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemWeaponReinforceInfoPtr ULItem::GetReinforceInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetReinforceInfo");

	Params::LItem_GetReinforceInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetReinforceLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetReinforceLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetReinforceLevel");

	Params::LItem_GetReinforceLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetSecondCategory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELItemSecondCategory                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELItemSecondCategory ULItem::GetSecondCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetSecondCategory");

	Params::LItem_GetSecondCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetSlaveArmInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemSlaveArmInfoPtr             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemSlaveArmInfoPtr ULItem::GetSlaveArmInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetSlaveArmInfo");

	Params::LItem_GetSlaveArmInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetWeaponBladeInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemBladeInfoPtr                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemBladeInfoPtr ULItem::GetWeaponBladeInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetWeaponBladeInfo");

	Params::LItem_GetWeaponBladeInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetWeaponHandleInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemHandleInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemHandleInfoPtr ULItem::GetWeaponHandleInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetWeaponHandleInfo");

	Params::LItem_GetWeaponHandleInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetWeaponStat
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELStatCorrectChangeType                 WillHandleDiffStat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetWeaponStat(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat, ELStatCorrectChangeType WillHandleDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetWeaponStat");

	Params::LItem_GetWeaponStat Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;
	Parms.WillHandleDiffStat = WillHandleDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetWeaponStatBonus
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELStatCorrectChangeType                 WillHandleDiffStat                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetWeaponStatBonus(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat, ELStatCorrectChangeType WillHandleDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetWeaponStatBonus");

	Params::LItem_GetWeaponStatBonus Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;
	Parms.WillHandleDiffStat = WillHandleDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.GetWeight
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItem::GetWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "GetWeight");

	Params::LItem_GetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsBladeItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsBladeItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsBladeItem");

	Params::LItem_IsBladeItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsChangedCorrection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsChangedCorrection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsChangedCorrection");

	Params::LItem_IsChangedCorrection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsComplexItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsComplexItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsComplexItem");

	Params::LItem_IsComplexItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsHandleItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsHandleItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsHandleItem");

	Params::LItem_IsHandleItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsOnToggled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsOnToggled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsOnToggled");

	Params::LItem_IsOnToggled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsReinforced
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsReinforced() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsReinforced");

	Params::LItem_IsReinforced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsSameGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULItem*                           In                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsSameGroup(class ULItem* In) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsSameGroup");

	Params::LItem_IsSameGroup Parms{};

	Parms.In = In;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsSameItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULItem*                           In                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsSameItem(class ULItem* In) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsSameItem");

	Params::LItem_IsSameItem Parms{};

	Parms.In = In;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsToggleItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsToggleItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsToggleItem");

	Params::LItem_IsToggleItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsWeapon");

	Params::LItem_IsWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsWeaponBlade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsWeaponBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsWeaponBlade");

	Params::LItem_IsWeaponBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsWeaponHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsWeaponHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsWeaponHandle");

	Params::LItem_IsWeaponHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItem.IsWeaponSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItem::IsWeaponSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItem", "IsWeaponSlaveArm");

	Params::LItem_IsWeaponSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LListView.GetScrollOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULListView::GetScrollOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LListView", "GetScrollOffset");

	Params::LListView_GetScrollOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.ChangeShotGunAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELShotGunAmmoType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSlaveArmItem::ChangeShotGunAmmo(ELShotGunAmmoType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "ChangeShotGunAmmo");

	Params::LSlaveArmItem_ChangeShotGunAmmo Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmItem.ChangeSpreadingMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAcidSpreadingModeType                 InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSlaveArmItem::ChangeSpreadingMode(ELAcidSpreadingModeType InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "ChangeSpreadingMode");

	Params::LSlaveArmItem_ChangeSpreadingMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmItem.ConsumeAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConsumeAmmoCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSlaveArmItem::ConsumeAmmo(int32 ConsumeAmmoCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "ConsumeAmmo");

	Params::LSlaveArmItem_ConsumeAmmo Parms{};

	Parms.ConsumeAmmoCount = ConsumeAmmoCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmItem.RefreshUIState
// (Final, Native, Public, BlueprintCallable)

void ULSlaveArmItem::RefreshUIState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "RefreshUIState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmItem.UpdateAmmoUI
// (Final, Native, Public, BlueprintCallable)

void ULSlaveArmItem::UpdateAmmoUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "UpdateAmmoUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmItem.CanCombinedKeyActionEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::CanCombinedKeyActionEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "CanCombinedKeyActionEnable");

	Params::LSlaveArmItem_CanCombinedKeyActionEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsAcidSpreaderSlavearm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsAcidSpreaderSlavearm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsAcidSpreaderSlavearm");

	Params::LSlaveArmItem_IsAcidSpreaderSlavearm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsAegisInCooltime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsAegisInCooltime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsAegisInCooltime");

	Params::LSlaveArmItem_IsAegisInCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsAegisSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsAegisSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsAegisSlaveArm");

	Params::LSlaveArmItem_IsAegisSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsFlameThrowerSlavearm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsFlameThrowerSlavearm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsFlameThrowerSlavearm");

	Params::LSlaveArmItem_IsFlameThrowerSlavearm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsFulminisSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsFulminisSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsFulminisSlaveArm");

	Params::LSlaveArmItem_IsFulminisSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsNormalSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsNormalSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsNormalSlaveArm");

	Params::LSlaveArmItem_IsNormalSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsPileBunkerSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsPileBunkerSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsPileBunkerSlaveArm");

	Params::LSlaveArmItem_IsPileBunkerSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsPuppetStringSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsPuppetStringSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsPuppetStringSlaveArm");

	Params::LSlaveArmItem_IsPuppetStringSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsShotGunSlavearm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsShotGunSlavearm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsShotGunSlavearm");

	Params::LSlaveArmItem_IsShotGunSlavearm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmItem.IsSniperCannonSlaveArm
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmItem::IsSniperCannonSlaveArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmItem", "IsSniperCannonSlaveArm");

	Params::LSlaveArmItem_IsSniperCannonSlaveArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogDebugInfo.ToString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULDialogDebugInfo::ToString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogDebugInfo", "ToString");

	Params::LDialogDebugInfo_ToString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemDropSystem.GainDropErgoData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SpotUniqueID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemDropSystem::GainDropErgoData(const class FString& SpotUniqueID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemDropSystem", "GainDropErgoData");

	Params::LItemDropSystem_GainDropErgoData Parms{};

	Parms.SpotUniqueID = std::move(SpotUniqueID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitProcContext.AttackerActionAtHitStarted
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        OutActionAtHitStarted                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::AttackerActionAtHitStarted(EExecutePin* Branches, class ULActBase** OutActionAtHitStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "AttackerActionAtHitStarted");

	Params::LHitProcContext_AttackerActionAtHitStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutActionAtHitStarted != nullptr)
		*OutActionAtHitStarted = Parms.OutActionAtHitStarted;
}


// Function ProjectP.LHitProcContext.AttackerActMgrComp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActMgrComponent*                OutActMgrComponent                                     (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::AttackerActMgrComp(EExecutePin* Branches, class ULActMgrComponent** OutActMgrComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "AttackerActMgrComp");

	Params::LHitProcContext_AttackerActMgrComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutActMgrComponent != nullptr)
		*OutActMgrComponent = Parms.OutActMgrComponent;
}


// Function ProjectP.LHitProcContext.AttackerAs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELHitProcObjectType                     Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCharacter*                      OutCharacter                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALPCCharacter*                    OutPC                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCCharacter*                   OutNPC                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALDynamicDamageVolumeActor*       OutDamageVolume                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALProjectile*                     OutProjectile                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::AttackerAs(ELHitProcObjectType* Branches, class ALCharacter** OutCharacter, class ALPCCharacter** OutPC, class ALNPCCharacter** OutNPC, class ALDynamicDamageVolumeActor** OutDamageVolume, class ALProjectile** OutProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "AttackerAs");

	Params::LHitProcContext_AttackerAs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutCharacter != nullptr)
		*OutCharacter = Parms.OutCharacter;

	if (OutPC != nullptr)
		*OutPC = Parms.OutPC;

	if (OutNPC != nullptr)
		*OutNPC = Parms.OutNPC;

	if (OutDamageVolume != nullptr)
		*OutDamageVolume = Parms.OutDamageVolume;

	if (OutProjectile != nullptr)
		*OutProjectile = Parms.OutProjectile;
}


// Function ProjectP.LHitProcContext.AttackerHitProcComp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULHitProcComponent*               OutHitProcComponent                                    (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::AttackerHitProcComp(EExecutePin* Branches, class ULHitProcComponent** OutHitProcComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "AttackerHitProcComp");

	Params::LHitProcContext_AttackerHitProcComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutHitProcComponent != nullptr)
		*OutHitProcComponent = Parms.OutHitProcComponent;
}


// Function ProjectP.LHitProcContext.AttackerStatComp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULStatComponent*                  OutStatComponent                                       (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::AttackerStatComp(EExecutePin* Branches, class ULStatComponent** OutStatComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "AttackerStatComp");

	Params::LHitProcContext_AttackerStatComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutStatComponent != nullptr)
		*OutStatComponent = Parms.OutStatComponent;
}


// Function ProjectP.LHitProcContext.AttackerWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         OutWeapon                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::AttackerWeapon(EExecutePin* Branches, class ALWeapon** OutWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "AttackerWeapon");

	Params::LHitProcContext_AttackerWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutWeapon != nullptr)
		*OutWeapon = Parms.OutWeapon;
}


// Function ProjectP.LHitProcContext.ChangeSkillHitBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InSkillHitCodeName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULHitProcContext::ChangeSkillHitBP(class FName InSkillHitCodeName, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "ChangeSkillHitBP");

	Params::LHitProcContext_ChangeSkillHitBP Parms{};

	Parms.InSkillHitCodeName = InSkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitProcContext.OnPrepareBP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULHitProcContext::OnPrepareBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "OnPrepareBP");

	Params::LHitProcContext_OnPrepareBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LHitProcContext.OnResetBP
// (Event, Public, BlueprintEvent)

void ULHitProcContext::OnResetBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "OnResetBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LHitProcContext.PrepareBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InAttacker                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InVictim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLHitInfo                        InHitInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULHitProcContext::PrepareBP(class AActor* InAttacker, class AActor* InVictim, const struct FHitResult& InHitResult, const struct FLHitInfo& InHitInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "PrepareBP");

	Params::LHitProcContext_PrepareBP Parms{};

	Parms.InAttacker = InAttacker;
	Parms.InVictim = InVictim;
	Parms.InHitResult = std::move(InHitResult);
	Parms.InHitInfo = std::move(InHitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitProcContext.Reset
// (Final, Native, Public, BlueprintCallable)

void ULHitProcContext::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitProcContext.VictimActionAtHitStarted
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        OutActionAtHitStarted                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::VictimActionAtHitStarted(EExecutePin* Branches, class ULActBase** OutActionAtHitStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "VictimActionAtHitStarted");

	Params::LHitProcContext_VictimActionAtHitStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutActionAtHitStarted != nullptr)
		*OutActionAtHitStarted = Parms.OutActionAtHitStarted;
}


// Function ProjectP.LHitProcContext.VictimActMgrComp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActMgrComponent*                OutActMgrComponent                                     (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::VictimActMgrComp(EExecutePin* Branches, class ULActMgrComponent** OutActMgrComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "VictimActMgrComp");

	Params::LHitProcContext_VictimActMgrComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutActMgrComponent != nullptr)
		*OutActMgrComponent = Parms.OutActMgrComponent;
}


// Function ProjectP.LHitProcContext.VictimAs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELHitProcObjectType                     Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCharacter*                      OutCharacter                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALPCCharacter*                    OutPC                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCCharacter*                   OutNPC                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALDynamicDamageVolumeActor*       OutDamageVolume                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALProjectile*                     OutProjectile                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::VictimAs(ELHitProcObjectType* Branches, class ALCharacter** OutCharacter, class ALPCCharacter** OutPC, class ALNPCCharacter** OutNPC, class ALDynamicDamageVolumeActor** OutDamageVolume, class ALProjectile** OutProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "VictimAs");

	Params::LHitProcContext_VictimAs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutCharacter != nullptr)
		*OutCharacter = Parms.OutCharacter;

	if (OutPC != nullptr)
		*OutPC = Parms.OutPC;

	if (OutNPC != nullptr)
		*OutNPC = Parms.OutNPC;

	if (OutDamageVolume != nullptr)
		*OutDamageVolume = Parms.OutDamageVolume;

	if (OutProjectile != nullptr)
		*OutProjectile = Parms.OutProjectile;
}


// Function ProjectP.LHitProcContext.VictimHitProcComp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULHitProcComponent*               OutHitProcComponent                                    (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::VictimHitProcComp(EExecutePin* Branches, class ULHitProcComponent** OutHitProcComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "VictimHitProcComp");

	Params::LHitProcContext_VictimHitProcComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutHitProcComponent != nullptr)
		*OutHitProcComponent = Parms.OutHitProcComponent;
}


// Function ProjectP.LHitProcContext.VictimStatComp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULStatComponent*                  OutStatComponent                                       (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::VictimStatComp(EExecutePin* Branches, class ULStatComponent** OutStatComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "VictimStatComp");

	Params::LHitProcContext_VictimStatComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutStatComponent != nullptr)
		*OutStatComponent = Parms.OutStatComponent;
}


// Function ProjectP.LHitProcContext.VictimWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         OutWeapon                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcContext::VictimWeapon(EExecutePin* Branches, class ALWeapon** OutWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcContext", "VictimWeapon");

	Params::LHitProcContext_VictimWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	if (OutWeapon != nullptr)
		*OutWeapon = Parms.OutWeapon;
}


// Function ProjectP.LOptionSystemData.GetDefault_EnableAlignmentToCamera
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefault_EnableAlignmentToCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefault_EnableAlignmentToCamera");

	Params::LOptionSystemData_GetDefault_EnableAlignmentToCamera Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefault_EnableCameraShake
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefault_EnableCameraShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefault_EnableCameraShake");

	Params::LOptionSystemData_GetDefault_EnableCameraShake Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefault_EnableMoveCameraUpDown
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefault_EnableMoveCameraUpDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefault_EnableMoveCameraUpDown");

	Params::LOptionSystemData_GetDefault_EnableMoveCameraUpDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultCameraInvert
// (Event, Public, BlueprintEvent)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultCameraInvert(ECameraDirectOption InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultCameraInvert");

	Params::LOptionSystemData_GetDefaultCameraInvert Parms{};

	Parms.InRotator = InRotator;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultCameraSpeedIdx
// (Event, Public, BlueprintEvent)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultCameraSpeedIdx(ECameraDirectOption InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultCameraSpeedIdx");

	Params::LOptionSystemData_GetDefaultCameraSpeedIdx Parms{};

	Parms.InRotator = InRotator;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultDeadZoneIdx
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    LeftStick                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultDeadZoneIdx(bool LeftStick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultDeadZoneIdx");

	Params::LOptionSystemData_GetDefaultDeadZoneIdx Parms{};

	Parms.LeftStick = LeftStick;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultEnableBloodExpression
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultEnableBloodExpression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultEnableBloodExpression");

	Params::LOptionSystemData_GetDefaultEnableBloodExpression Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultEnableMotionBlur
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultEnableMotionBlur()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultEnableMotionBlur");

	Params::LOptionSystemData_GetDefaultEnableMotionBlur Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultEnableTutorialPopup
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultEnableTutorialPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultEnableTutorialPopup");

	Params::LOptionSystemData_GetDefaultEnableTutorialPopup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultEnableVideoSubtitle
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultEnableVideoSubtitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultEnableVideoSubtitle");

	Params::LOptionSystemData_GetDefaultEnableVideoSubtitle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultForceFeedbackIdx
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultForceFeedbackIdx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultForceFeedbackIdx");

	Params::LOptionSystemData_GetDefaultForceFeedbackIdx Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultFramerateLimit
// (Event, Public, BlueprintEvent)
// Parameters:
// ELFramerateLimit                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELFramerateLimit ALOptionSystemData::GetDefaultFramerateLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultFramerateLimit");

	Params::LOptionSystemData_GetDefaultFramerateLimit Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultFullscreenMode
// (Event, Public, BlueprintEvent)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode ALOptionSystemData::GetDefaultFullscreenMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultFullscreenMode");

	Params::LOptionSystemData_GetDefaultFullscreenMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultHUDVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// ELHUDVisible                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELHUDVisible ALOptionSystemData::GetDefaultHUDVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultHUDVisibility");

	Params::LOptionSystemData_GetDefaultHUDVisibility Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultInputPresetName
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALOptionSystemData::GetDefaultInputPresetName(bool IsGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultInputPresetName");

	Params::LOptionSystemData_GetDefaultInputPresetName Parms{};

	Parms.IsGamePad = IsGamePad;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultLanguage
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALOptionSystemData::GetDefaultLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultLanguage");

	Params::LOptionSystemData_GetDefaultLanguage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultLockOnImportanceWeightMultiply
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultLockOnImportanceWeightMultiply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultLockOnImportanceWeightMultiply");

	Params::LOptionSystemData_GetDefaultLockOnImportanceWeightMultiply Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultPlayStyleOption
// (Event, Public, BlueprintEvent)
// Parameters:
// EPlayStyleOption                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayStyleOption ALOptionSystemData::GetDefaultPlayStyleOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultPlayStyleOption");

	Params::LOptionSystemData_GetDefaultPlayStyleOption Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultScalabilityLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// ELScalabilityLevel                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELScalabilityLevel ALOptionSystemData::GetDefaultScalabilityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultScalabilityLevel");

	Params::LOptionSystemData_GetDefaultScalabilityLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultScreenResolution
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint ALOptionSystemData::GetDefaultScreenResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultScreenResolution");

	Params::LOptionSystemData_GetDefaultScreenResolution Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultSelectableMouseSensitivityMultiplyIdx
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultSelectableMouseSensitivityMultiplyIdx()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultSelectableMouseSensitivityMultiplyIdx");

	Params::LOptionSystemData_GetDefaultSelectableMouseSensitivityMultiplyIdx Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultSubtitleSize
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultSubtitleSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultSubtitleSize");

	Params::LOptionSystemData_GetDefaultSubtitleSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultUseAutoNewTargetLockOn
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultUseAutoNewTargetLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultUseAutoNewTargetLockOn");

	Params::LOptionSystemData_GetDefaultUseAutoNewTargetLockOn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultUseAutoTargeting
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultUseAutoTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultUseAutoTargeting");

	Params::LOptionSystemData_GetDefaultUseAutoTargeting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultUseHDR
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultUseHDR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultUseHDR");

	Params::LOptionSystemData_GetDefaultUseHDR Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultVolumeIdx
// (Event, Public, BlueprintEvent)
// Parameters:
// ELVolumeType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALOptionSystemData::GetDefaultVolumeIdx(ELVolumeType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultVolumeIdx");

	Params::LOptionSystemData_GetDefaultVolumeIdx Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetDefaultVSyncEnabled
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALOptionSystemData::GetDefaultVSyncEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetDefaultVSyncEnabled");

	Params::LOptionSystemData_GetDefaultVSyncEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableCameraSpeeds
// (Event, Public, BlueprintEvent)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> ALOptionSystemData::GetSelectableCameraSpeeds(ECameraDirectOption InRotator, bool IsPad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableCameraSpeeds");

	Params::LOptionSystemData_GetSelectableCameraSpeeds Parms{};

	Parms.InRotator = InRotator;
	Parms.IsPad = IsPad;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableDeadZone
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    LeftStick                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> ALOptionSystemData::GetSelectableDeadZone(bool LeftStick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableDeadZone");

	Params::LOptionSystemData_GetSelectableDeadZone Parms{};

	Parms.LeftStick = LeftStick;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableForceFeedback
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> ALOptionSystemData::GetSelectableForceFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableForceFeedback");

	Params::LOptionSystemData_GetSelectableForceFeedback Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableFramerateLimits
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> ALOptionSystemData::GetSelectableFramerateLimits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableFramerateLimits");

	Params::LOptionSystemData_GetSelectableFramerateLimits Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableLanguages
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ALOptionSystemData::GetSelectableLanguages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableLanguages");

	Params::LOptionSystemData_GetSelectableLanguages Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableLockOnImportanceWeightMultiply
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<struct FLLockOnImportanceWeight> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLLockOnImportanceWeight> ALOptionSystemData::GetSelectableLockOnImportanceWeightMultiply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableLockOnImportanceWeightMultiply");

	Params::LOptionSystemData_GetSelectableLockOnImportanceWeightMultiply Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableMouseSensitivityMultiply
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> ALOptionSystemData::GetSelectableMouseSensitivityMultiply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableMouseSensitivityMultiply");

	Params::LOptionSystemData_GetSelectableMouseSensitivityMultiply Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystemData.GetSelectableVolumes
// (Event, Public, BlueprintEvent)
// Parameters:
// ELVolumeType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> ALOptionSystemData::GetSelectableVolumes(ELVolumeType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystemData", "GetSelectableVolumes");

	Params::LOptionSystemData_GetSelectableVolumes Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.ChangeCorrectionHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::ChangeCorrectionHandle(ELStatCorrectChangeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "ChangeCorrectionHandle");

	Params::LWeaponItem_ChangeCorrectionHandle Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.ConsumeSharpness
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InConsumePoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CanBreakWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsConsumed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         TargetWeaponActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponItem::ConsumeSharpness(int32 InConsumePoint, bool CanBreakWeapon, bool* bIsConsumed, class ALWeapon* TargetWeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "ConsumeSharpness");

	Params::LWeaponItem_ConsumeSharpness Parms{};

	Parms.InConsumePoint = InConsumePoint;
	Parms.CanBreakWeapon = CanBreakWeapon;
	Parms.TargetWeaponActor = TargetWeaponActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsConsumed != nullptr)
		*bIsConsumed = Parms.bIsConsumed;
}


// Function ProjectP.LWeaponItem.GetSharpnessAbnormalStateCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELBladeSharpnessType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULWeaponItem::GetSharpnessAbnormalStateCodeName(ELBladeSharpnessType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetSharpnessAbnormalStateCodeName");

	Params::LWeaponItem_GetSharpnessAbnormalStateCodeName Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetSharpnessDamageRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELBladeSharpnessType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWeaponItem::GetSharpnessDamageRatio(ELBladeSharpnessType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetSharpnessDamageRatio");

	Params::LWeaponItem_GetSharpnessDamageRatio Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetSharpnessDestructionRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELBladeSharpnessType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWeaponItem::GetSharpnessDestructionRatio(ELBladeSharpnessType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetSharpnessDestructionRatio");

	Params::LWeaponItem_GetSharpnessDestructionRatio Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetSharpnessRepulseLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetSharpnessRepulseLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetSharpnessRepulseLevel");

	Params::LWeaponItem_GetSharpnessRepulseLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.IsOnHand
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::IsOnHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "IsOnHand");

	Params::LWeaponItem_IsOnHand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.ReinforceBlade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::ReinforceBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "ReinforceBlade");

	Params::LWeaponItem_ReinforceBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.RestoreSharpness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPoint                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsGrinding                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponItem::RestoreSharpness(int32 InPoint, bool IsGrinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "RestoreSharpness");

	Params::LWeaponItem_RestoreSharpness Parms{};

	Parms.InPoint = InPoint;
	Parms.IsGrinding = IsGrinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeaponItem.SetHeroicWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHeroic                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponItem::SetHeroicWeapon(bool bHeroic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "SetHeroicWeapon");

	Params::LWeaponItem_SetHeroicWeapon Parms{};

	Parms.bHeroic = bHeroic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeaponItem.SetSharpnessPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSharpnessPoint                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsGrinding                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponItem::SetSharpnessPoint(int32 InSharpnessPoint, bool IsGrinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "SetSharpnessPoint");

	Params::LWeaponItem_SetSharpnessPoint Parms{};

	Parms.InSharpnessPoint = InSharpnessPoint;
	Parms.IsGrinding = IsGrinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeaponItem.CanChangeCorrectionHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::CanChangeCorrectionHandle(ELStatCorrectChangeType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "CanChangeCorrectionHandle");

	Params::LWeaponItem_CanChangeCorrectionHandle Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.CanReinforceBlade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::CanReinforceBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "CanReinforceBlade");

	Params::LWeaponItem_CanReinforceBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULWeaponItem::GetBladeCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeCodeName");

	Params::LWeaponItem_GetBladeCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeCommonInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemCommonInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemCommonInfoPtr ULWeaponItem::GetBladeCommonInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeCommonInfo");

	Params::LWeaponItem_GetBladeCommonInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeImageResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> ULWeaponItem::GetBladeImageResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeImageResource");

	Params::LWeaponItem_GetBladeImageResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemBladeInfoPtr                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemBladeInfoPtr ULWeaponItem::GetBladeInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeInfo");

	Params::LWeaponItem_GetBladeInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeReinforceInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemWeaponReinforceInfoPtr      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemWeaponReinforceInfoPtr ULWeaponItem::GetBladeReinforceInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeReinforceInfo");

	Params::LWeaponItem_GetBladeReinforceInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetBladeStat(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeStat");

	Params::LWeaponItem_GetBladeStat Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetBladeStatBonus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetBladeStatBonus(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetBladeStatBonus");

	Params::LWeaponItem_GetBladeStatBonus Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetCurrentSharpnessPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetCurrentSharpnessPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetCurrentSharpnessPoint");

	Params::LWeaponItem_GetCurrentSharpnessPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetCurrentSharpnessType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELBladeSharpnessType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELBladeSharpnessType ULWeaponItem::GetCurrentSharpnessType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetCurrentSharpnessType");

	Params::LWeaponItem_GetCurrentSharpnessType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleChangeCorrectionInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHandleStatCorrectionChangeInfoPtrReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FHandleStatCorrectionChangeInfoPtr ULWeaponItem::GetHandleChangeCorrectionInfo(ELStatCorrectChangeType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleChangeCorrectionInfo");

	Params::LWeaponItem_GetHandleChangeCorrectionInfo Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleChangedCorrectionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELStatCorrectChangeType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELStatCorrectChangeType ULWeaponItem::GetHandleChangedCorrectionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleChangedCorrectionType");

	Params::LWeaponItem_GetHandleChangedCorrectionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULWeaponItem::GetHandleCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleCodeName");

	Params::LWeaponItem_GetHandleCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleCommonInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemCommonInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemCommonInfoPtr ULWeaponItem::GetHandleCommonInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleCommonInfo");

	Params::LWeaponItem_GetHandleCommonInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleCorrectionGrade
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELFirstStat                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELStatCorrectChangeType                 WillBeChangeCorrection                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutStackLevel                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHandleCorrectResultGrade              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELHandleCorrectResultGrade ULWeaponItem::GetHandleCorrectionGrade(ELFirstStat Type, ELStatCorrectChangeType WillBeChangeCorrection, int32* OutStackLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleCorrectionGrade");

	Params::LWeaponItem_GetHandleCorrectionGrade Parms{};

	Parms.Type = Type;
	Parms.WillBeChangeCorrection = WillBeChangeCorrection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStackLevel != nullptr)
		*OutStackLevel = Parms.OutStackLevel;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleImageResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> ULWeaponItem::GetHandleImageResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleImageResource");

	Params::LWeaponItem_GetHandleImageResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemHandleInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemHandleInfoPtr ULWeaponItem::GetHandleInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleInfo");

	Params::LWeaponItem_GetHandleInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetHandleStat(class AActor* InOwner, ELSecondStat InStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleStat");

	Params::LWeaponItem_GetHandleStat Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHandleStatBonus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetHandleStatBonus(class AActor* InOwner, ELSecondStat InStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHandleStatBonus");

	Params::LWeaponItem_GetHandleStatBonus Parms{};

	Parms.InOwner = InOwner;
	Parms.InStat = InStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetHeroicImageResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> ULWeaponItem::GetHeroicImageResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetHeroicImageResource");

	Params::LWeaponItem_GetHeroicImageResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetNecessityFirstStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELFirstStat                             InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetNecessityFirstStat(ELFirstStat InStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetNecessityFirstStat");

	Params::LWeaponItem_GetNecessityFirstStat Parms{};

	Parms.InStat = InStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetNextBladeReinforceInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemWeaponReinforceInfoPtr      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemWeaponReinforceInfoPtr ULWeaponItem::GetNextBladeReinforceInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetNextBladeReinforceInfo");

	Params::LWeaponItem_GetNextBladeReinforceInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetRawBladeStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WillReinforceDiffStat                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetRawBladeStat(ELSecondStat InStat, bool WillReinforceDiffStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetRawBladeStat");

	Params::LWeaponItem_GetRawBladeStat Parms{};

	Parms.InStat = InStat;
	Parms.WillReinforceDiffStat = WillReinforceDiffStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetRawHandleStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULWeaponItem::GetRawHandleStat(ELSecondStat InStat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetRawHandleStat");

	Params::LWeaponItem_GetRawHandleStat Parms{};

	Parms.InStat = InStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetSeparatedWeaponParts
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULItem*                           OutHandleItem                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           OutBladeItem                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponItem::GetSeparatedWeaponParts(class ULItem** OutHandleItem, class ULItem** OutBladeItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetSeparatedWeaponParts");

	Params::LWeaponItem_GetSeparatedWeaponParts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandleItem != nullptr)
		*OutHandleItem = Parms.OutHandleItem;

	if (OutBladeItem != nullptr)
		*OutBladeItem = Parms.OutBladeItem;
}


// Function ProjectP.LWeaponItem.GetSharpnessRecoverRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWeaponItem::GetSharpnessRecoverRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetSharpnessRecoverRatio");

	Params::LWeaponItem_GetSharpnessRecoverRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetWeaponElementalType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELElementDamageType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELElementDamageType ULWeaponItem::GetWeaponElementalType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetWeaponElementalType");

	Params::LWeaponItem_GetWeaponElementalType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.GetWeaponName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULWeaponItem::GetWeaponName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "GetWeaponName");

	Params::LWeaponItem_GetWeaponName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.HasBlade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::HasBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "HasBlade");

	Params::LWeaponItem_HasBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.IsChangedCorrectionHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::IsChangedCorrectionHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "IsChangedCorrectionHandle");

	Params::LWeaponItem_IsChangedCorrectionHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.IsHeroicWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::IsHeroicWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "IsHeroicWeapon");

	Params::LWeaponItem_IsHeroicWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.IsOriginalWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::IsOriginalWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "IsOriginalWeapon");

	Params::LWeaponItem_IsOriginalWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.IsReinforcedBlade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::IsReinforcedBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "IsReinforcedBlade");

	Params::LWeaponItem_IsReinforcedBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.IsSharpnessMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWeaponItem::IsSharpnessMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "IsSharpnessMax");

	Params::LWeaponItem_IsSharpnessMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponItem.SeparateWeaponPart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULWeaponItem::SeparateWeaponPart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponItem", "SeparateWeaponPart");

	Params::LWeaponItem_SeparateWeaponPart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSubOption.ResetToDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSubOption::ResetToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSubOption", "ResetToDefault");

	Params::LSubOption_ResetToDefault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDispalySoundOption.ApplySoundOptionMultiply
// (Final, Native, Public)
// Parameters:
// ELVolumeType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULDispalySoundOption::ApplySoundOptionMultiply(ELVolumeType InType, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDispalySoundOption", "ApplySoundOptionMultiply");

	Params::LDispalySoundOption_ApplySoundOptionMultiply Parms{};

	Parms.InType = InType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDispalySoundOption.GetVolumeStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELVolumeType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULDispalySoundOption::GetVolumeStep(ELVolumeType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDispalySoundOption", "GetVolumeStep");

	Params::LDispalySoundOption_GetVolumeStep Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDispalySoundOption.SetVolumeStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELVolumeType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULDispalySoundOption::SetVolumeStep(ELVolumeType InType, int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDispalySoundOption", "SetVolumeStep");

	Params::LDispalySoundOption_SetVolumeStep Parms{};

	Parms.InType = InType;
	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractComponent.OnCloseDialog
// (Final, Native, Protected)

void ULInteractComponent::OnCloseDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnCloseDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_Interact
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentBeginOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentBeginOverlapped_Interact");

	Params::LInteractComponent_OnComponentBeginOverlapped_Interact Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_InteractVolume
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentBeginOverlapped_InteractVolume(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentBeginOverlapped_InteractVolume");

	Params::LInteractComponent_OnComponentBeginOverlapped_InteractVolume Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_LookAt
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentBeginOverlapped_LookAt(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentBeginOverlapped_LookAt");

	Params::LInteractComponent_OnComponentBeginOverlapped_LookAt Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentBeginOverlapped_Radius
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentBeginOverlapped_Radius(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentBeginOverlapped_Radius");

	Params::LInteractComponent_OnComponentBeginOverlapped_Radius Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_Interact
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentEndOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentEndOverlapped_Interact");

	Params::LInteractComponent_OnComponentEndOverlapped_Interact Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_InteractVolume
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentEndOverlapped_InteractVolume(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentEndOverlapped_InteractVolume");

	Params::LInteractComponent_OnComponentEndOverlapped_InteractVolume Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_LookAt
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentEndOverlapped_LookAt(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentEndOverlapped_LookAt");

	Params::LInteractComponent_OnComponentEndOverlapped_LookAt Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnComponentEndOverlapped_Radius
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULInteractComponent::OnComponentEndOverlapped_Radius(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnComponentEndOverlapped_Radius");

	Params::LInteractComponent_OnComponentEndOverlapped_Radius Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractComponent.OnOpenDialog
// (Final, Native, Protected)

void ULInteractComponent::OnOpenDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractComponent", "OnOpenDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LKeySettingOption.ApplyBackupCustomizedInputInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELInputOptionType                       InControllerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULKeySettingOption::ApplyBackupCustomizedInputInfo(ELInputOptionType InControllerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "ApplyBackupCustomizedInputInfo");

	Params::LKeySettingOption_ApplyBackupCustomizedInputInfo Parms{};

	Parms.InControllerType = InControllerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LKeySettingOption.ApplyCustomizedInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELInputOptionType                       InControllerType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeySettingOption::ApplyCustomizedInput(ELInputOptionType InControllerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "ApplyCustomizedInput");

	Params::LKeySettingOption_ApplyCustomizedInput Parms{};

	Parms.InControllerType = InControllerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeySettingOption.ChangeInputKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeySettingOption::ChangeInputKey(class FName InputAction, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "ChangeInputKey");

	Params::LKeySettingOption_ChangeInputKey Parms{};

	Parms.InputAction = InputAction;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeySettingOption.FindPresetInputAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InPresetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPCActionKeyType ULKeySettingOption::FindPresetInputAction(class FName InPresetName, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "FindPresetInputAction");

	Params::LKeySettingOption_FindPresetInputAction Parms{};

	Parms.InPresetName = InPresetName;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeySettingOption.FindPresetInputActionKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InPresetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPCActionKeyType                       KeyType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey ULKeySettingOption::FindPresetInputActionKey(class FName InPresetName, ELPCActionKeyType KeyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "FindPresetInputActionKey");

	Params::LKeySettingOption_FindPresetInputActionKey Parms{};

	Parms.InPresetName = InPresetName;
	Parms.KeyType = KeyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeySettingOption.GetCurrentPresetName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULKeySettingOption::GetCurrentPresetName(bool IsGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "GetCurrentPresetName");

	Params::LKeySettingOption_GetCurrentPresetName Parms{};

	Parms.IsGamePad = IsGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeySettingOption.GetSelectablePresetNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IsGamePad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULKeySettingOption::GetSelectablePresetNames(bool IsGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "GetSelectablePresetNames");

	Params::LKeySettingOption_GetSelectablePresetNames Parms{};

	Parms.IsGamePad = IsGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeySettingOption.OnClosedWindow
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULKeySettingOption::OnClosedWindow(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "OnClosedWindow");

	Params::LKeySettingOption_OnClosedWindow Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LKeySettingOption.SetBackupCustomizedInputInfo
// (Final, Native, Public, BlueprintCallable)

void ULKeySettingOption::SetBackupCustomizedInputInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "SetBackupCustomizedInputInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LKeySettingOption.SetChangePreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InPresetName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeySettingOption::SetChangePreset(class FName InPresetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeySettingOption", "SetChangePreset");

	Params::LKeySettingOption_SetChangePreset Parms{};

	Parms.InPresetName = InPresetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsActor.BoneMerging
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALPartsActor::BoneMerging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "BoneMerging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsActor.BoneMergingSkeletalMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPartsActor::BoneMergingSkeletalMesh(class USkeletalMeshComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "BoneMergingSkeletalMesh");

	Params::LPartsActor_BoneMergingSkeletalMesh Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsActor.DropParts
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          LastImpulseDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPartsActor::DropParts(const struct FVector& LastImpulseDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "DropParts");

	Params::LPartsActor_DropParts Parms{};

	Parms.LastImpulseDirection = std::move(LastImpulseDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsActor.FindDropMeshes
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMeshComponent*> ALPartsActor::FindDropMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "FindDropMeshes");

	Params::LPartsActor_FindDropMeshes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsActor.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCharacter*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCharacter* ALPartsActor::GetOwnerCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "GetOwnerCharacter");

	Params::LPartsActor_GetOwnerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsActor.GetPartsAttachParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ALPartsActor::GetPartsAttachParent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "GetPartsAttachParent");

	Params::LPartsActor_GetPartsAttachParent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsActor.GetPartsComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ALPartsActor::GetPartsComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "GetPartsComponent");

	Params::LPartsActor_GetPartsComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsActor.OnChangeNextDestructState
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALPartsActor::OnChangeNextDestructState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "OnChangeNextDestructState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPartsActor.OnPartsDestroyed
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALPartsActor::OnPartsDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "OnPartsDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPartsActor.OnRespawn
// (Native, Event, Public, BlueprintEvent)

void ALPartsActor::OnRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "OnRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsActor.PartsActivate
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ALPartsActor::PartsActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "PartsActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPartsActor.PartsDeactivate
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ALPartsActor::PartsDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsActor", "PartsDeactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LInteractSystem.Dev_InteractStartTransform
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULInteractSystem::Dev_InteractStartTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractSystem", "Dev_InteractStartTransform");

	Params::LInteractSystem_Dev_InteractStartTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractSystem.GetDialogDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULDialogDebugInfo*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULDialogDebugInfo* ULInteractSystem::GetDialogDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractSystem", "GetDialogDebugInfo");

	Params::LInteractSystem_GetDialogDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractSystem.GetLastDialogingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULInteractSystem::GetLastDialogingActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractSystem", "GetLastDialogingActor");

	Params::LInteractSystem_GetLastDialogingActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractSystem.OnBlockDialog
// (Final, Native, Protected)
// Parameters:
// bool                                    InBlock                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULInteractSystem::OnBlockDialog(bool InBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractSystem", "OnBlockDialog");

	Params::LInteractSystem_OnBlockDialog Parms{};

	Parms.InBlock = InBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractSystem.OnClosedDialog
// (Final, Native, Protected)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULInteractSystem::OnClosedDialog(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractSystem", "OnClosedDialog");

	Params::LInteractSystem_OnClosedDialog Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSkeletalMeshActor.OnRep_ReplicatedMaterial0
// (Native, Public)

void ALLevelSkeletalMeshActor::OnRep_ReplicatedMaterial0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSkeletalMeshActor", "OnRep_ReplicatedMaterial0");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSkeletalMeshActor.OnRep_ReplicatedMaterial1
// (Native, Public)

void ALLevelSkeletalMeshActor::OnRep_ReplicatedMaterial1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSkeletalMeshActor", "OnRep_ReplicatedMaterial1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSkeletalMeshActor.OnRep_ReplicatedMesh
// (Native, Public)

void ALLevelSkeletalMeshActor::OnRep_ReplicatedMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSkeletalMeshActor", "OnRep_ReplicatedMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSkeletalMeshActor.OnRep_ReplicatedPhysAsset
// (Native, Public)

void ALLevelSkeletalMeshActor::OnRep_ReplicatedPhysAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSkeletalMeshActor", "OnRep_ReplicatedPhysAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDamageCollisionComponent.BeginOverlapDamageCollision
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULDamageCollisionComponent::BeginOverlapDamageCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDamageCollisionComponent", "BeginOverlapDamageCollision");

	Params::LDamageCollisionComponent_BeginOverlapDamageCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDamageCollisionComponent.EndOverlapDamageCollision
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULDamageCollisionComponent::EndOverlapDamageCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDamageCollisionComponent", "EndOverlapDamageCollision");

	Params::LDamageCollisionComponent_EndOverlapDamageCollision Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTransformDataAsset.AddObjectTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             TargetObjectName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       LocationTransform                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULTransformDataAsset::AddObjectTransform(class FName TargetObjectName, const struct FTransform& LocationTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTransformDataAsset", "AddObjectTransform");

	Params::LTransformDataAsset_AddObjectTransform Parms{};

	Parms.TargetObjectName = TargetObjectName;
	Parms.LocationTransform = std::move(LocationTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTransformDataAsset.ClearAllData
// (Final, Native, Public, BlueprintCallable)

void ULTransformDataAsset::ClearAllData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTransformDataAsset", "ClearAllData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTransformDataAsset.PrintData
// (Final, Native, Public, BlueprintCallable)

void ULTransformDataAsset::PrintData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTransformDataAsset", "PrintData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpotDataAsset.ClearAllData
// (Final, Native, Public, BlueprintCallable)

void ULSpotDataAsset::ClearAllData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpotDataAsset", "ClearAllData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPreloadDataAsset.ClearAllData
// (Final, Native, Public, BlueprintCallable)

void ULPreloadDataAsset::ClearAllData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPreloadDataAsset", "ClearAllData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_On_FrenzyAction.OnEnterActionState
// (Final, Native, Public)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_On_FrenzyAction::OnEnterActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_On_FrenzyAction", "OnEnterActionState");

	Params::LSpecialBuff_Abnormal_On_FrenzyAction_OnEnterActionState Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_On_FrenzyAction.OnLeaveActionState
// (Final, Native, Public)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_On_FrenzyAction::OnLeaveActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_On_FrenzyAction", "OnLeaveActionState");

	Params::LSpecialBuff_Abnormal_On_FrenzyAction_OnLeaveActionState Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGeneralName.LName_Action_SpawnIdle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_Action_SpawnIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_Action_SpawnIdle");

	Params::LGeneralName_LName_Action_SpawnIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_Action_TurnAround
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_Action_TurnAround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_Action_TurnAround");

	Params::LGeneralName_LName_Action_TurnAround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_CommonAnim_Run_F
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_CommonAnim_Run_F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_CommonAnim_Run_F");

	Params::LGeneralName_LName_CommonAnim_Run_F Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_B
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_CommonAnim_Walk_B()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_CommonAnim_Walk_B");

	Params::LGeneralName_LName_CommonAnim_Walk_B Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_F
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_CommonAnim_Walk_F()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_CommonAnim_Walk_F");

	Params::LGeneralName_LName_CommonAnim_Walk_F Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_L
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_CommonAnim_Walk_L()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_CommonAnim_Walk_L");

	Params::LGeneralName_LName_CommonAnim_Walk_L Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_CommonAnim_Walk_R
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_CommonAnim_Walk_R()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_CommonAnim_Walk_R");

	Params::LGeneralName_LName_CommonAnim_Walk_R Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_Hair
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_Hair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_Hair");

	Params::LGeneralName_LName_Hair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_Head
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_Head()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_Head");

	Params::LGeneralName_LName_Head Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_MontageSection_End
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_MontageSection_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_MontageSection_End");

	Params::LGeneralName_LName_MontageSection_End Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_None");

	Params::LGeneralName_LName_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_NPCPause_SpotTrigger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_NPCPause_SpotTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_NPCPause_SpotTrigger");

	Params::LGeneralName_LName_NPCPause_SpotTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGeneralName.LName_NPCPauseMeta_Action
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGeneralName::LName_NPCPauseMeta_Action()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGeneralName", "LName_NPCPauseMeta_Action");

	Params::LGeneralName_LName_NPCPauseMeta_Action Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitColMgrComponent.OnComponentBeginOverlapped
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitColMgrComponent::OnComponentBeginOverlapped(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitColMgrComponent", "OnComponentBeginOverlapped");

	Params::LHitColMgrComponent_OnComponentBeginOverlapped Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitColMgrComponent.OnComponentEndOverlapped
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitColMgrComponent::OnComponentEndOverlapped(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitColMgrComponent", "OnComponentEndOverlapped");

	Params::LHitColMgrComponent_OnComponentEndOverlapped Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LAttack");

	Params::LCollisionChannel_CollisionChannel_LAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LAudio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LAudio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LAudio");

	Params::LCollisionChannel_CollisionChannel_LAudio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LCapsuleBig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LCapsuleBig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LCapsuleBig");

	Params::LCollisionChannel_CollisionChannel_LCapsuleBig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LCapsuleNormal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LCapsuleNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LCapsuleNormal");

	Params::LCollisionChannel_CollisionChannel_LCapsuleNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LCapsulePC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LCapsulePC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LCapsulePC");

	Params::LCollisionChannel_CollisionChannel_LCapsulePC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LCloud
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LCloud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LCloud");

	Params::LCollisionChannel_CollisionChannel_LCloud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LIK
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LIK");

	Params::LCollisionChannel_CollisionChannel_LIK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LPhysicsBodyBig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LPhysicsBodyBig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LPhysicsBodyBig");

	Params::LCollisionChannel_CollisionChannel_LPhysicsBodyBig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LPhysicsBodyNormal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LPhysicsBodyNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LPhysicsBodyNormal");

	Params::LCollisionChannel_CollisionChannel_LPhysicsBodyNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LPhysicsBodyVisual
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LPhysicsBodyVisual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LPhysicsBodyVisual");

	Params::LCollisionChannel_CollisionChannel_LPhysicsBodyVisual Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LProjectile
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LProjectile");

	Params::LCollisionChannel_CollisionChannel_LProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LRepulse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LRepulse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LRepulse");

	Params::LCollisionChannel_CollisionChannel_LRepulse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LSpark
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LSpark()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LSpark");

	Params::LCollisionChannel_CollisionChannel_LSpark Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionChannel.CollisionChannel_LWaterVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel ULCollisionChannel::CollisionChannel_LWaterVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionChannel", "CollisionChannel_LWaterVolume");

	Params::LCollisionChannel_CollisionChannel_LWaterVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLevelUtilFuncLibrary.ChangePropStateBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLevelUtilFuncLibrary::ChangePropStateBP(class AActor* TargetActor, int32 TargetState, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelUtilFuncLibrary", "ChangePropStateBP");

	Params::LLevelUtilFuncLibrary_ChangePropStateBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetState = TargetState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LLevelUtilFuncLibrary.CheckNextPropStateBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLevelUtilFuncLibrary::CheckNextPropStateBP(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelUtilFuncLibrary", "CheckNextPropStateBP");

	Params::LLevelUtilFuncLibrary_CheckNextPropStateBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelUtilFuncLibrary.GetPropComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPropComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPropComponent* ULLevelUtilFuncLibrary::GetPropComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelUtilFuncLibrary", "GetPropComponentBP");

	Params::LLevelUtilFuncLibrary_GetPropComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_BlockAll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_BlockAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_BlockAll");

	Params::LCollisionProfile_CollisionProfile_BlockAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_BlockAllDynamic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_BlockAllDynamic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_BlockAllDynamic");

	Params::LCollisionProfile_CollisionProfile_BlockAllDynamic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_CharacterMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_CharacterMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_CharacterMesh");

	Params::LCollisionProfile_CollisionProfile_CharacterMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_Destructible
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_Destructible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_Destructible");

	Params::LCollisionProfile_CollisionProfile_Destructible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_IgnoreOnlyPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_IgnoreOnlyPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_IgnoreOnlyPawn");

	Params::LCollisionProfile_CollisionProfile_IgnoreOnlyPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_InvisibleWall
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_InvisibleWall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_InvisibleWall");

	Params::LCollisionProfile_CollisionProfile_InvisibleWall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_InvisibleWallDynamic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_InvisibleWallDynamic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_InvisibleWallDynamic");

	Params::LCollisionProfile_CollisionProfile_InvisibleWallDynamic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LAttack_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LAttack_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LAttack_Base");

	Params::LCollisionProfile_CollisionProfile_LAttack_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LAttack_Range
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LAttack_Range()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LAttack_Range");

	Params::LCollisionProfile_CollisionProfile_LAttack_Range Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LBlock_Obstacle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LBlock_Obstacle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LBlock_Obstacle");

	Params::LCollisionProfile_CollisionProfile_LBlock_Obstacle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LBlock_Obstacle_Projectile
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LBlock_Obstacle_Projectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LBlock_Obstacle_Projectile");

	Params::LCollisionProfile_CollisionProfile_LBlock_Obstacle_Projectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LBlockAll_MovingEnvironment
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LBlockAll_MovingEnvironment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LBlockAll_MovingEnvironment");

	Params::LCollisionProfile_CollisionProfile_LBlockAll_MovingEnvironment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LBlockAll_ThruCamera
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LBlockAll_ThruCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LBlockAll_ThruCamera");

	Params::LCollisionProfile_CollisionProfile_LBlockAll_ThruCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LBlockingVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LBlockingVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LBlockingVolume");

	Params::LCollisionProfile_CollisionProfile_LBlockingVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCamera_Block
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCamera_Block()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCamera_Block");

	Params::LCollisionProfile_CollisionProfile_LCamera_Block Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_BlockAll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleAll_BlockAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleAll_BlockAll");

	Params::LCollisionProfile_CollisionProfile_LCapsuleAll_BlockAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_Penetrate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleAll_Penetrate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleAll_Penetrate");

	Params::LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_Penetrate_Fly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleAll_Penetrate_Fly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleAll_Penetrate_Fly");

	Params::LCollisionProfile_CollisionProfile_LCapsuleAll_Penetrate_Fly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleAll_TestOverlap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleAll_TestOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleAll_TestOverlap");

	Params::LCollisionProfile_CollisionProfile_LCapsuleAll_TestOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleBig_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleBig_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleBig_Base");

	Params::LCollisionProfile_CollisionProfile_LCapsuleBig_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleBig_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleBig_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleBig_Dead");

	Params::LCollisionProfile_CollisionProfile_LCapsuleBig_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleBig_Ghost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleBig_Ghost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleBig_Ghost");

	Params::LCollisionProfile_CollisionProfile_LCapsuleBig_Ghost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNormal_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNormal_Base");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNormal_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNormal_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNormal_Dead");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNormal_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Ghost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNormal_Ghost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNormal_Ghost");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Ghost_Hittable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNormal_Ghost_Hittable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNormal_Ghost_Hittable");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNormal_Ghost_Hittable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Hittable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNormal_Hittable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNormal_Hittable");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNormal_Hittable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNormal_Penetrate_Hittable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNormal_Penetrate_Hittable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNormal_Penetrate_Hittable");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNormal_Penetrate_Hittable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsuleNPC_TestOverlap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsuleNPC_TestOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsuleNPC_TestOverlap");

	Params::LCollisionProfile_CollisionProfile_LCapsuleNPC_TestOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsulePC_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsulePC_Base");

	Params::LCollisionProfile_CollisionProfile_LCapsulePC_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsulePC_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsulePC_Dead");

	Params::LCollisionProfile_CollisionProfile_LCapsulePC_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_Ghost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsulePC_Ghost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsulePC_Ghost");

	Params::LCollisionProfile_CollisionProfile_LCapsulePC_Ghost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LCapsulePC_TestOverlap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LCapsulePC_TestOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LCapsulePC_TestOverlap");

	Params::LCollisionProfile_CollisionProfile_LCapsulePC_TestOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LDecoMesh_Attack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LDecoMesh_Attack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LDecoMesh_Attack");

	Params::LCollisionProfile_CollisionProfile_LDecoMesh_Attack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LDecoMesh_DropEnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LDecoMesh_DropEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LDecoMesh_DropEnd");

	Params::LCollisionProfile_CollisionProfile_LDecoMesh_DropEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LDecoMesh_DropStart
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LDecoMesh_DropStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LDecoMesh_DropStart");

	Params::LCollisionProfile_CollisionProfile_LDecoMesh_DropStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LDestructible_Chunk
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LDestructible_Chunk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LDestructible_Chunk");

	Params::LCollisionProfile_CollisionProfile_LDestructible_Chunk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LEnvironmentVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LEnvironmentVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LEnvironmentVolume");

	Params::LCollisionProfile_CollisionProfile_LEnvironmentVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LFloorPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LFloorPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LFloorPC");

	Params::LCollisionProfile_CollisionProfile_LFloorPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LInteract_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LInteract_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LInteract_Base");

	Params::LCollisionProfile_CollisionProfile_LInteract_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LInteract_CapsuleBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LInteract_CapsuleBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LInteract_CapsuleBase");

	Params::LCollisionProfile_CollisionProfile_LInteract_CapsuleBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBody_Explosion_Cut
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBody_Explosion_Cut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBody_Explosion_Cut");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBody_Explosion_Cut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyBig_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyBig_Base");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyBig_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyBig_Dead");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Dying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyBig_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyBig_Dying");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Dying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Ghost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyBig_Ghost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyBig_Ghost");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Ghost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyBig_Penetrate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyBig_Penetrate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyBig_Penetrate");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyBig_Penetrate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyNormal_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyNormal_Base");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyNormal_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyNormal_Dead");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Dying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyNormal_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyNormal_Dying");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Dying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Ghost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyNormal_Ghost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyNormal_Ghost");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Ghost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_Penetrate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyNormal_Penetrate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyNormal_Penetrate");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_Penetrate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyNormal_SimulateOnly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyNormal_SimulateOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyNormal_SimulateOnly");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyNormal_SimulateOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyPC_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyPC_Base");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Dead
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyPC_Dead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyPC_Dead");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Dying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyPC_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyPC_Dying");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Dying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Ghost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyPC_Ghost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyPC_Ghost");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Ghost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_Penetrate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyPC_Penetrate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyPC_Penetrate");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyPC_Penetrate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyPC_SimulateOnly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyPC_SimulateOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyPC_SimulateOnly");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyPC_SimulateOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LPhysicsBodyVisual_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LPhysicsBodyVisual_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LPhysicsBodyVisual_Base");

	Params::LCollisionProfile_CollisionProfile_LPhysicsBodyVisual_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_LProjectile_Base
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_LProjectile_Base()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_LProjectile_Base");

	Params::LCollisionProfile_CollisionProfile_LProjectile_Base Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_NoCollision
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_NoCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_NoCollision");

	Params::LCollisionProfile_CollisionProfile_NoCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_None");

	Params::LCollisionProfile_CollisionProfile_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_OverlapAll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_OverlapAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_OverlapAll");

	Params::LCollisionProfile_CollisionProfile_OverlapAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_OverlapAllDynamic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_OverlapAllDynamic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_OverlapAllDynamic");

	Params::LCollisionProfile_CollisionProfile_OverlapAllDynamic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_OverlapOnlyPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_OverlapOnlyPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_OverlapOnlyPawn");

	Params::LCollisionProfile_CollisionProfile_OverlapOnlyPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_Pawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_Pawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_Pawn");

	Params::LCollisionProfile_CollisionProfile_Pawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_PhysicsActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_PhysicsActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_PhysicsActor");

	Params::LCollisionProfile_CollisionProfile_PhysicsActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_Ragdoll
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_Ragdoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_Ragdoll");

	Params::LCollisionProfile_CollisionProfile_Ragdoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_Spectator
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_Spectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_Spectator");

	Params::LCollisionProfile_CollisionProfile_Spectator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_Trigger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_Trigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_Trigger");

	Params::LCollisionProfile_CollisionProfile_Trigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_UI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_UI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_UI");

	Params::LCollisionProfile_CollisionProfile_UI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCollisionProfile.CollisionProfile_Vehicle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCollisionProfile::CollisionProfile_Vehicle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LCollisionProfile", "CollisionProfile_Vehicle");

	Params::LCollisionProfile_CollisionProfile_Vehicle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComponentTag.CollisionProfile_LFootCollision
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULComponentTag::CollisionProfile_LFootCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LComponentTag", "CollisionProfile_LFootCollision");

	Params::LComponentTag_CollisionProfile_LFootCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LComponentTag.CollisionProfile_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULComponentTag::CollisionProfile_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LComponentTag", "CollisionProfile_None");

	Params::LComponentTag_CollisionProfile_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructStaticMeshComponent.OnDestructOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULDestructStaticMeshComponent::OnDestructOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructStaticMeshComponent", "OnDestructOverlap");

	Params::LDestructStaticMeshComponent_OnDestructOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructSkeletalMeshComponent.OnDestructOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULDestructSkeletalMeshComponent::OnDestructOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructSkeletalMeshComponent", "OnDestructOverlap");

	Params::LDestructSkeletalMeshComponent_OnDestructOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructibleComponent.HideStaticMeshProcess
// (Final, Native, Protected)

void ULDestructibleComponent::HideStaticMeshProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructibleComponent", "HideStaticMeshProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructibleComponent.OnDestructFracture
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          HitPoint                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULDestructibleComponent::OnDestructFracture(const struct FVector& HitPoint, const struct FVector& HitDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructibleComponent", "OnDestructFracture");

	Params::LDestructibleComponent_OnDestructFracture Parms{};

	Parms.HitPoint = std::move(HitPoint);
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructibleComponent.OnDestructOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULDestructibleComponent::OnDestructOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructibleComponent", "OnDestructOverlap");

	Params::LDestructibleComponent_OnDestructOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHumanitySystem.OnHumanityAcquisitionPopupEnded
// (Final, Native, Protected)

void ULHumanitySystem::OnHumanityAcquisitionPopupEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHumanitySystem", "OnHumanityAcquisitionPopupEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.CanRepulse
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALDestructionObject::CanRepulse(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "CanRepulse");

	Params::LDestructionObject_CanRepulse Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.DoHitDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDestructionObject::DoHitDirection(const struct FVector& HitLocation, const struct FVector& HitDirection, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "DoHitDirection");

	Params::LDestructionObject_DoHitDirection Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitDirection = std::move(HitDirection);
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.DoHitFully
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDestructionObject::DoHitFully(const struct FVector& HitLocation, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "DoHitFully");

	Params::LDestructionObject_DoHitFully Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.DoHitRadius
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDestructionObject::DoHitRadius(const struct FVector& HitLocation, float Radius, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "DoHitRadius");

	Params::LDestructionObject_DoHitRadius Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.Radius = Radius;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.DoHitSelf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDestructionObject::DoHitSelf(float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "DoHitSelf");

	Params::LDestructionObject_DoHitSelf Parms{};

	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.GetCurrectHPDestructionProp
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALDestructionObject::GetCurrectHPDestructionProp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "GetCurrectHPDestructionProp");

	Params::LDestructionObject_GetCurrectHPDestructionProp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.OnDestructCrashed
// (Event, Protected, BlueprintEvent)

void ALDestructionObject::OnDestructCrashed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "OnDestructCrashed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LDestructionObject.ProcessHit
// (Native, Event, Protected, BlueprintEvent)

void ALDestructionObject::ProcessHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "ProcessHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.PushCrashedChunks
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PushLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALDestructionObject::PushCrashedChunks(const struct FVector& PushLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "PushCrashedChunks");

	Params::LDestructionObject_PushCrashedChunks Parms{};

	Parms.PushLocation = std::move(PushLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.ResetCrashed
// (Final, Native, Protected, BlueprintCallable)

void ALDestructionObject::ResetCrashed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "ResetCrashed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDestructionObject.GetControlShapeObjectSpot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALDestructionObject::GetControlShapeObjectSpot(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "GetControlShapeObjectSpot");

	Params::LDestructionObject_GetControlShapeObjectSpot Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.GetControlShapeObjectSpotLastIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALDestructionObject::GetControlShapeObjectSpotLastIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "GetControlShapeObjectSpotLastIndex");

	Params::LDestructionObject_GetControlShapeObjectSpotLastIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.GetControlVolumeSpot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALDestructionObject::GetControlVolumeSpot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "GetControlVolumeSpot");

	Params::LDestructionObject_GetControlVolumeSpot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.GetOverridePhysicalSurface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELPhysicalSurfaceType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPhysicalSurfaceType ALDestructionObject::GetOverridePhysicalSurface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "GetOverridePhysicalSurface");

	Params::LDestructionObject_GetOverridePhysicalSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.GetPhysicalSurfaceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELPhysicalSurfaceType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPhysicalSurfaceType ALDestructionObject::GetPhysicalSurfaceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "GetPhysicalSurfaceType");

	Params::LDestructionObject_GetPhysicalSurfaceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDestructionObject.IsCrashedAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALDestructionObject::IsCrashedAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDestructionObject", "IsCrashedAll");

	Params::LDestructionObject_IsCrashedAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDevSystem.AddUserGameCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLGameCommandBookEntity          Command                                                (Parm, NativeAccessSpecifierPublic)

void ULDevSystem::AddUserGameCommand(const struct FLGameCommandBookEntity& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "AddUserGameCommand");

	Params::LDevSystem_AddUserGameCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.BindGameCommandBookHotKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLGameCommandBookEntity          Command                                                (Parm, NativeAccessSpecifierPublic)

void ULDevSystem::BindGameCommandBookHotKey(const struct FLGameCommandBookEntity& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "BindGameCommandBookHotKey");

	Params::LDevSystem_BindGameCommandBookHotKey Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.EmptyUserCommands
// (Final, Native, Public, BlueprintCallable)

void ULDevSystem::EmptyUserCommands()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "EmptyUserCommands");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.ExecuteGameCommand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLGameCommandBookEntity          Command                                                (Parm, NativeAccessSpecifierPublic)

void ULDevSystem::ExecuteGameCommand(const struct FLGameCommandBookEntity& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "ExecuteGameCommand");

	Params::LDevSystem_ExecuteGameCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.GetDebugTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULDevSystem::GetDebugTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "GetDebugTargetActor");

	Params::LDevSystem_GetDebugTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDevSystem.GetNpcActorOnlyOne
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALNPCCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALNPCCharacter* ULDevSystem::GetNpcActorOnlyOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "GetNpcActorOnlyOne");

	Params::LDevSystem_GetNpcActorOnlyOne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDevSystem.LoadGameCommands
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FLGameCommandBookEntity>  DefaultCommands                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLGameCommandBookEntity>  UserCommands                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLGameCommandBookEntity>  DefaultChapterCommands                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLGameCommandBookEntity>  DefaultMoneyCommands                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULDevSystem::LoadGameCommands(TArray<struct FLGameCommandBookEntity>* DefaultCommands, TArray<struct FLGameCommandBookEntity>* UserCommands, TArray<struct FLGameCommandBookEntity>* DefaultChapterCommands, TArray<struct FLGameCommandBookEntity>* DefaultMoneyCommands)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "LoadGameCommands");

	Params::LDevSystem_LoadGameCommands Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DefaultCommands != nullptr)
		*DefaultCommands = std::move(Parms.DefaultCommands);

	if (UserCommands != nullptr)
		*UserCommands = std::move(Parms.UserCommands);

	if (DefaultChapterCommands != nullptr)
		*DefaultChapterCommands = std::move(Parms.DefaultChapterCommands);

	if (DefaultMoneyCommands != nullptr)
		*DefaultMoneyCommands = std::move(Parms.DefaultMoneyCommands);
}


// Function ProjectP.LDevSystem.SaveUserGameCommands
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FLGameCommandBookEntity>  UserCommands                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULDevSystem::SaveUserGameCommands(const TArray<struct FLGameCommandBookEntity>& UserCommands)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "SaveUserGameCommands");

	Params::LDevSystem_SaveUserGameCommands Parms{};

	Parms.UserCommands = std::move(UserCommands);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.StartRecordCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FrameRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LookatZOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULDevSystem::StartRecordCamera(float FrameRate, int32 LookatZOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "StartRecordCamera");

	Params::LDevSystem_StartRecordCamera Parms{};

	Parms.FrameRate = FrameRate;
	Parms.LookatZOffset = LookatZOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.StopRecordCamera
// (Final, Native, Public, BlueprintCallable)

void ULDevSystem::StopRecordCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "StopRecordCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.TogglePrintLocation
// (Final, Native, Public, BlueprintCallable)

void ULDevSystem::TogglePrintLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "TogglePrintLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.UnbindGameCommandBookHotKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLGameCommandBookEntity          Command                                                (Parm, NativeAccessSpecifierPublic)

void ULDevSystem::UnbindGameCommandBookHotKey(const struct FLGameCommandBookEntity& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "UnbindGameCommandBookHotKey");

	Params::LDevSystem_UnbindGameCommandBookHotKey Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDevSystem.UnbindGameCommandBookHotKeyAll
// (Final, Native, Public, BlueprintCallable)

void ULDevSystem::UnbindGameCommandBookHotKeyAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDevSystem", "UnbindGameCommandBookHotKeyAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDLCSystem.CheckAvailableDLC
// (Final, Native, Public, BlueprintCallable)

void ULDLCSystem::CheckAvailableDLC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "CheckAvailableDLC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDLCSystem.OnCloseItemReceiveUI
// (Final, Native, Public, BlueprintCallable)

void ULDLCSystem::OnCloseItemReceiveUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "OnCloseItemReceiveUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDLCSystem.OnConnectionCanceled
// (Final, Native, Public, BlueprintCallable)

void ULDLCSystem::OnConnectionCanceled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "OnConnectionCanceled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDLCSystem.OnConnectionFailed
// (Final, Native, Public)

void ULDLCSystem::OnConnectionFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "OnConnectionFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDLCSystem.PopOutPendingDLC_Account
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELRewardType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULDLCSystem::PopOutPendingDLC_Account(ELRewardType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "PopOutPendingDLC_Account");

	Params::LDLCSystem_PopOutPendingDLC_Account Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDLCSystem.PopOutPendingDLC_Character
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELRewardType                            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULDLCSystem::PopOutPendingDLC_Character(ELRewardType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "PopOutPendingDLC_Character");

	Params::LDLCSystem_PopOutPendingDLC_Character Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDLCSystem.PrintPreview
// (Final, Native, Public, BlueprintCallable)

void ULDLCSystem::PrintPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "PrintPreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDLCSystem.GetPendingDLCList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULDLCSystem::GetPendingDLCList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDLCSystem", "GetPendingDLCList");

	Params::LDLCSystem_GetPendingDLCList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCSpot.OnComponentBeginOverlapPathway
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALNPCSpot::OnComponentBeginOverlapPathway(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCSpot", "OnComponentBeginOverlapPathway");

	Params::LNPCSpot_OnComponentBeginOverlapPathway Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCSpot.OnWakeUpSpawnedNpc
// (Final, Native, Protected)

void ALNPCSpot::OnWakeUpSpawnedNpc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCSpot", "OnWakeUpSpawnedNpc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlatformSystem.ConfirmNeowizAuth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PW                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExternalAccount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlatformSystem::ConfirmNeowizAuth(const class FString& ID, const class FString& PW, bool ExternalAccount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "ConfirmNeowizAuth");

	Params::LPlatformSystem_ConfirmNeowizAuth Parms{};

	Parms.ID = std::move(ID);
	Parms.PW = std::move(PW);
	Parms.ExternalAccount = ExternalAccount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlatformSystem.ExecuteNeowizAuthRefresh
// (Final, Native, Public)

void ULPlatformSystem::ExecuteNeowizAuthRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "ExecuteNeowizAuthRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlatformSystem.GetChunkInstallProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULPlatformSystem::GetChunkInstallProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "GetChunkInstallProgress");

	Params::LPlatformSystem_GetChunkInstallProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.GetGameVersionString
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULPlatformSystem::GetGameVersionString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "GetGameVersionString");

	Params::LPlatformSystem_GetGameVersionString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.GetLaunchActivityErrortype
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELLaunchActivityErrorType               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELLaunchActivityErrorType ULPlatformSystem::GetLaunchActivityErrortype()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "GetLaunchActivityErrortype");

	Params::LPlatformSystem_GetLaunchActivityErrortype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.GetPlatformName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULPlatformSystem::GetPlatformName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "GetPlatformName");

	Params::LPlatformSystem_GetPlatformName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.GetPlayerNickName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULPlatformSystem::GetPlayerNickName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "GetPlayerNickName");

	Params::LPlatformSystem_GetPlayerNickName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.IsChunkInstallComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlatformSystem::IsChunkInstallComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "IsChunkInstallComplete");

	Params::LPlatformSystem_IsChunkInstallComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.IsLaunchActivity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlatformSystem::IsLaunchActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "IsLaunchActivity");

	Params::LPlatformSystem_IsLaunchActivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.IsNeowizAuthExternalAccount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlatformSystem::IsNeowizAuthExternalAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "IsNeowizAuthExternalAccount");

	Params::LPlatformSystem_IsNeowizAuthExternalAccount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.IsValidNeowizAuth
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlatformSystem::IsValidNeowizAuth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "IsValidNeowizAuth");

	Params::LPlatformSystem_IsValidNeowizAuth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.PrintLoginStatusTest
// (Final, Native, Public)

void ULPlatformSystem::PrintLoginStatusTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "PrintLoginStatusTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlatformSystem.ResetActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlatformSystem::ResetActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "ResetActivity");

	Params::LPlatformSystem_ResetActivity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlatformSystem.ResetLaunchActivity
// (Final, Native, Public, BlueprintCallable)

void ULPlatformSystem::ResetLaunchActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "ResetLaunchActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlatformSystem.ResumeActivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlatformSystem::ResumeActivity(int32 InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlatformSystem", "ResumeActivity");

	Params::LPlatformSystem_ResumeActivity Parms{};

	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGlobalEnvActor.EnableShadowDistanceFading
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALGlobalEnvActor::EnableShadowDistanceFading(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "EnableShadowDistanceFading");

	Params::LGlobalEnvActor_EnableShadowDistanceFading Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGlobalEnvActor.GetEditorCameraPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          OutCameraPostion                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALGlobalEnvActor::GetEditorCameraPosition(struct FVector* OutCameraPostion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "GetEditorCameraPosition");

	Params::LGlobalEnvActor_GetEditorCameraPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCameraPostion != nullptr)
		*OutCameraPostion = std::move(Parms.OutCameraPostion);

	return Parms.ReturnValue;
}


// Function ProjectP.LGlobalEnvActor.IsBlending
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALGlobalEnvActor::IsBlending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "IsBlending");

	Params::LGlobalEnvActor_IsBlending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGlobalEnvActor.OnSetActiveEnvironment
// (Final, Native, Public)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALGlobalEnvActor::OnSetActiveEnvironment(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "OnSetActiveEnvironment");

	Params::LGlobalEnvActor_OnSetActiveEnvironment Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGlobalEnvActor.OnStartPostProcessing_BP
// (Event, Public, BlueprintEvent)

void ALGlobalEnvActor::OnStartPostProcessing_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "OnStartPostProcessing_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LGlobalEnvActor.SetPreviewTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALGlobalEnvActor::SetPreviewTarget(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "SetPreviewTarget");

	Params::LGlobalEnvActor_SetPreviewTarget Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGlobalEnvActor.SpawnCustomLightning
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALGlobalEnvActor::SpawnCustomLightning(float Delay, float Direction, float Intensity, float Distance, float Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "SpawnCustomLightning");

	Params::LGlobalEnvActor_SpawnCustomLightning Parms{};

	Parms.Delay = Delay;
	Parms.Direction = Direction;
	Parms.Intensity = Intensity;
	Parms.Distance = Distance;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LGlobalEnvActor.StartBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TargetName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALGlobalEnvActor::StartBlend(class FName TargetName, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGlobalEnvActor", "StartBlend");

	Params::LGlobalEnvActor_StartBlend Parms{};

	Parms.TargetName = TargetName;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.AddNpcHitParts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NpcPartsCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillCodeNameOnDestroy                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Primitive                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPartsEnableWhenSpawn                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::AddNpcHitParts(class FName NpcPartsCodeName, class FName SkillCodeNameOnDestroy, class UPrimitiveComponent* Primitive, bool bPartsEnableWhenSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "AddNpcHitParts");

	Params::LEquipmentComponent_AddNpcHitParts Parms{};

	Parms.NpcPartsCodeName = NpcPartsCodeName;
	Parms.SkillCodeNameOnDestroy = SkillCodeNameOnDestroy;
	Parms.Primitive = Primitive;
	Parms.bPartsEnableWhenSpawn = bPartsEnableWhenSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.ChangeTransformWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 MasterWeaponAttachPoint                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 WeaponAttachPoint1                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeaponHandleCodeName1                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeaponBladeCodeName1                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponAttachPointType                 WeaponAttachPoint2                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeaponHandleCodeName2                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeaponBladeCodeName2                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::ChangeTransformWeapon(ELWeaponAttachPointType MasterWeaponAttachPoint, ELWeaponAttachPointType WeaponAttachPoint1, class FName WeaponHandleCodeName1, class FName WeaponBladeCodeName1, ELWeaponAttachPointType WeaponAttachPoint2, class FName WeaponHandleCodeName2, class FName WeaponBladeCodeName2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "ChangeTransformWeapon");

	Params::LEquipmentComponent_ChangeTransformWeapon Parms{};

	Parms.MasterWeaponAttachPoint = MasterWeaponAttachPoint;
	Parms.WeaponAttachPoint1 = WeaponAttachPoint1;
	Parms.WeaponHandleCodeName1 = WeaponHandleCodeName1;
	Parms.WeaponBladeCodeName1 = WeaponBladeCodeName1;
	Parms.WeaponAttachPoint2 = WeaponAttachPoint2;
	Parms.WeaponHandleCodeName2 = WeaponHandleCodeName2;
	Parms.WeaponBladeCodeName2 = WeaponBladeCodeName2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.CheckHitPartsWeakElement
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLCalcDamageData                 CalcDamageData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::CheckHitPartsWeakElement(class FName HitPartsName, const struct FLCalcDamageData& CalcDamageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "CheckHitPartsWeakElement");

	Params::LEquipmentComponent_CheckHitPartsWeakElement Parms{};

	Parms.HitPartsName = HitPartsName;
	Parms.CalcDamageData = std::move(CalcDamageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.CreateDecoShape
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachSocketName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bResponseCollision                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebugDraw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UShapeComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UShapeComponent* ULEquipmentComponent::CreateDecoShape(class FName MeshName, const struct FVector& Size, class FName AttachSocketName, const struct FRotator& Rotation, bool bResponseCollision, bool bDebugDraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "CreateDecoShape");

	Params::LEquipmentComponent_CreateDecoShape Parms{};

	Parms.MeshName = MeshName;
	Parms.Size = std::move(Size);
	Parms.AttachSocketName = AttachSocketName;
	Parms.Rotation = std::move(Rotation);
	Parms.bResponseCollision = bResponseCollision;
	Parms.bDebugDraw = bDebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.CreateDecoStaticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachSocketName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResponseCollision                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisappear                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ULEquipmentComponent::CreateDecoStaticMesh(class FName MeshName, class UStaticMesh* StaticMesh, class FName AttachSocketName, bool bResponseCollision, bool bDisappear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "CreateDecoStaticMesh");

	Params::LEquipmentComponent_CreateDecoStaticMesh Parms{};

	Parms.MeshName = MeshName;
	Parms.StaticMesh = StaticMesh;
	Parms.AttachSocketName = AttachSocketName;
	Parms.bResponseCollision = bResponseCollision;
	Parms.bDisappear = bDisappear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.DeactivatePartsAll
// (Final, Native, Public, BlueprintCallable)

void ULEquipmentComponent::DeactivatePartsAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DeactivatePartsAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.DestroyDecoMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::DestroyDecoMesh(class FName MeshName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DestroyDecoMesh");

	Params::LEquipmentComponent_DestroyDecoMesh Parms{};

	Parms.MeshName = MeshName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.DoHeadCostumeOff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    DoOff                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::DoHeadCostumeOff(bool DoOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DoHeadCostumeOff");

	Params::LEquipmentComponent_DoHeadCostumeOff Parms{};

	Parms.DoOff = DoOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.DropDecoMeshes
// (Final, Native, Public, BlueprintCallable)

void ULEquipmentComponent::DropDecoMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DropDecoMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.DropPhysicsDecoStaticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnorePawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ULEquipmentComponent::DropPhysicsDecoStaticMesh(class FName MeshName, bool IgnorePawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DropPhysicsDecoStaticMesh");

	Params::LEquipmentComponent_DropPhysicsDecoStaticMesh Parms{};

	Parms.MeshName = MeshName;
	Parms.IgnorePawn = IgnorePawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.DropPickedWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::DropPickedWeapon(ELWeaponAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DropPickedWeapon");

	Params::LEquipmentComponent_DropPickedWeapon Parms{};

	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.DropPickedWeaponAll
// (Final, Native, Public, BlueprintCallable)

void ULEquipmentComponent::DropPickedWeaponAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "DropPickedWeaponAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.FindDecoStaticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ULEquipmentComponent::FindDecoStaticMesh(class FName MeshName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "FindDecoStaticMesh");

	Params::LEquipmentComponent_FindDecoStaticMesh Parms{};

	Parms.MeshName = MeshName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.FindPartsActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PartsIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALPartsActor*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALPartsActor* ULEquipmentComponent::FindPartsActor(int32 PartsIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "FindPartsActor");

	Params::LEquipmentComponent_FindPartsActor Parms{};

	Parms.PartsIndex = PartsIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.FindPartsCompByAttachPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELPartsAttachPointType                  AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULEquipmentComponent::FindPartsCompByAttachPoint(ELPartsAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "FindPartsCompByAttachPoint");

	Params::LEquipmentComponent_FindPartsCompByAttachPoint Parms{};

	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.FindPartsCompByLinkBodyBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULEquipmentComponent::FindPartsCompByLinkBodyBone(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "FindPartsCompByLinkBodyBone");

	Params::LEquipmentComponent_FindPartsCompByLinkBodyBone Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.FindPartsCompByNPCPartsCodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NpcPartsCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULEquipmentComponent::FindPartsCompByNPCPartsCodeName(class FName NpcPartsCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "FindPartsCompByNPCPartsCodeName");

	Params::LEquipmentComponent_FindPartsCompByNPCPartsCodeName Parms{};

	Parms.NpcPartsCodeName = NpcPartsCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetHitPartsNameByPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULEquipmentComponent::GetHitPartsNameByPrimitive(class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetHitPartsNameByPrimitive");

	Params::LEquipmentComponent_GetHitPartsNameByPrimitive Parms{};

	Parms.Primitive = Primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetPartsComp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PartsIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULPartsComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPartsComponent* ULEquipmentComponent::GetPartsComp(int32 PartsIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetPartsComp");

	Params::LEquipmentComponent_GetPartsComp Parms{};

	Parms.PartsIndex = PartsIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetPickedWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::GetPickedWeaponActor(ELWeaponAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetPickedWeaponActor");

	Params::LEquipmentComponent_GetPickedWeaponActor Parms{};

	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetSelectedWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::GetSelectedWeaponActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetSelectedWeaponActor");

	Params::LEquipmentComponent_GetSelectedWeaponActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetSelectedWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULEquipmentComponent::GetSelectedWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetSelectedWeaponIndex");

	Params::LEquipmentComponent_GetSelectedWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetSlaveArmInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULSlaveArmInfo*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSlaveArmInfo* ULEquipmentComponent::GetSlaveArmInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetSlaveArmInfo");

	Params::LEquipmentComponent_GetSlaveArmInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::GetWeaponActor(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetWeaponActor");

	Params::LEquipmentComponent_GetWeaponActor Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetWeaponByComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::GetWeaponByComponent(class UPrimitiveComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetWeaponByComponent");

	Params::LEquipmentComponent_GetWeaponByComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetWeaponByULItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::GetWeaponByULItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetWeaponByULItem");

	Params::LEquipmentComponent_GetWeaponByULItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetWeaponItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULWeaponItem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWeaponItem* ULEquipmentComponent::GetWeaponItem(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetWeaponItem");

	Params::LEquipmentComponent_GetWeaponItem Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.HasDecoMeshResponseCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::HasDecoMeshResponseCollision(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "HasDecoMeshResponseCollision");

	Params::LEquipmentComponent_HasDecoMeshResponseCollision Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.IsDecoMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::IsDecoMesh(class UPrimitiveComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "IsDecoMesh");

	Params::LEquipmentComponent_IsDecoMesh Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.IsHitPartsByPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::IsHitPartsByPrimitive(class UPrimitiveComponent* Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "IsHitPartsByPrimitive");

	Params::LEquipmentComponent_IsHitPartsByPrimitive Parms{};

	Parms.Primitive = Primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.PickWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPickWeaponChangeMotionType            ChangeMotionType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::PickWeapon(ELWeaponAttachPointType AttachPointType, int32 Index_0, ELPickWeaponChangeMotionType ChangeMotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "PickWeapon");

	Params::LEquipmentComponent_PickWeapon Parms{};

	Parms.AttachPointType = AttachPointType;
	Parms.Index_0 = Index_0;
	Parms.ChangeMotionType = ChangeMotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.ResetDeco
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::ResetDeco(class FName MeshName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "ResetDeco");

	Params::LEquipmentComponent_ResetDeco Parms{};

	Parms.MeshName = MeshName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.ResetDecoStaticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ULEquipmentComponent::ResetDecoStaticMesh(class FName MeshName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "ResetDecoStaticMesh");

	Params::LEquipmentComponent_ResetDecoStaticMesh Parms{};

	Parms.MeshName = MeshName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.ResetWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::ResetWeapon(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "ResetWeapon");

	Params::LEquipmentComponent_ResetWeapon Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.ResetWeaponAll
// (Final, Native, Public, BlueprintCallable)

void ULEquipmentComponent::ResetWeaponAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "ResetWeaponAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.RespawnWeaponByItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::RespawnWeaponByItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "RespawnWeaponByItem");

	Params::LEquipmentComponent_RespawnWeaponByItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SelectSlaveArm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SelectSlaveArm(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SelectSlaveArm");

	Params::LEquipmentComponent_SelectSlaveArm Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SelectWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SelectWeapon(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SelectWeapon");

	Params::LEquipmentComponent_SelectWeapon Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SetDecoHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SetDecoHidden(class FName MeshName, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SetDecoHidden");

	Params::LEquipmentComponent_SetDecoHidden Parms{};

	Parms.MeshName = MeshName;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SetDecoNoCollsion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MeshName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SetDecoNoCollsion(class FName MeshName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SetDecoNoCollsion");

	Params::LEquipmentComponent_SetDecoNoCollsion Parms{};

	Parms.MeshName = MeshName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SetParts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SetParts(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SetParts");

	Params::LEquipmentComponent_SetParts Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SetSlaveArmByItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SetSlaveArmByItem(int32 Index_0, class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SetSlaveArmByItem");

	Params::LEquipmentComponent_SetSlaveArmByItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SetWeaponByItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SetWeaponByItem(int32 Index_0, class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SetWeaponByItem");

	Params::LEquipmentComponent_SetWeaponByItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SetWeaponByItemWeaponMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemWeaponMonsterCodeName                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::SetWeaponByItemWeaponMonster(int32 Index_0, class FName ItemWeaponMonsterCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SetWeaponByItemWeaponMonster");

	Params::LEquipmentComponent_SetWeaponByItemWeaponMonster Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemWeaponMonsterCodeName = ItemWeaponMonsterCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.SpawnWeapon
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::SpawnWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SpawnWeapon");

	Params::LEquipmentComponent_SpawnWeapon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.SpawnWeaponWithClass
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class ALWeapon>             HandleWeaponClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ALWeapon>             BladeWeaponClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULEquipmentComponent::SpawnWeaponWithClass(TSubclassOf<class ALWeapon> HandleWeaponClass, TSubclassOf<class ALWeapon> BladeWeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "SpawnWeaponWithClass");

	Params::LEquipmentComponent_SpawnWeaponWithClass Parms{};

	Parms.HandleWeaponClass = HandleWeaponClass;
	Parms.BladeWeaponClass = BladeWeaponClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.UnChangeTransformWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 OriginalWeaponAttachPoint                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::UnChangeTransformWeapon(ELWeaponAttachPointType OriginalWeaponAttachPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "UnChangeTransformWeapon");

	Params::LEquipmentComponent_UnChangeTransformWeapon Parms{};

	Parms.OriginalWeaponAttachPoint = OriginalWeaponAttachPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.UnPickWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPickWeaponChangeMotionType            ChangeMotionType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::UnPickWeapon(ELWeaponAttachPointType AttachPointType, ELPickWeaponChangeMotionType ChangeMotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "UnPickWeapon");

	Params::LEquipmentComponent_UnPickWeapon Parms{};

	Parms.AttachPointType = AttachPointType;
	Parms.ChangeMotionType = ChangeMotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.WeaponOff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::WeaponOff(ELWeaponAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "WeaponOff");

	Params::LEquipmentComponent_WeaponOff Parms{};

	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.WeaponOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::WeaponOn(ELWeaponAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "WeaponOn");

	Params::LEquipmentComponent_WeaponOn Parms{};

	Parms.AttachPointType = AttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.WeaponOnOffOwnerHidden
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOnOff                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEquipmentComponent::WeaponOnOffOwnerHidden(bool bOnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "WeaponOnOffOwnerHidden");

	Params::LEquipmentComponent_WeaponOnOffOwnerHidden Parms{};

	Parms.bOnOff = bOnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEquipmentComponent.CheckHitPartsRepulseHitRangeAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::CheckHitPartsRepulseHitRangeAngle(class FName HitPartsName, class AActor* Attacker, class AActor* Victim) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "CheckHitPartsRepulseHitRangeAngle");

	Params::LEquipmentComponent_CheckHitPartsRepulseHitRangeAngle Parms{};

	Parms.HitPartsName = HitPartsName;
	Parms.Attacker = Attacker;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.CheckHitPartsRepulseLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalDamageType                    InPhysicalDamageType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAttackRepulseLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::CheckHitPartsRepulseLevel(class FName HitPartsName, ELPhysicalDamageType InPhysicalDamageType, int32 InAttackRepulseLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "CheckHitPartsRepulseLevel");

	Params::LEquipmentComponent_CheckHitPartsRepulseLevel Parms{};

	Parms.HitPartsName = HitPartsName;
	Parms.InPhysicalDamageType = InPhysicalDamageType;
	Parms.InAttackRepulseLevel = InAttackRepulseLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetCurrentMeshBody
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* ULEquipmentComponent::GetCurrentMeshBody() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetCurrentMeshBody");

	Params::LEquipmentComponent_GetCurrentMeshBody Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetHitPartsSkillCodeNameOnDestory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULEquipmentComponent::GetHitPartsSkillCodeNameOnDestory(class FName HitPartsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetHitPartsSkillCodeNameOnDestory");

	Params::LEquipmentComponent_GetHitPartsSkillCodeNameOnDestory Parms{};

	Parms.HitPartsName = HitPartsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetPartsComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ULPartsComponent*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class ULPartsComponent*> ULEquipmentComponent::GetPartsComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetPartsComponents");

	Params::LEquipmentComponent_GetPartsComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.GetWeakElementSkillCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULEquipmentComponent::GetWeakElementSkillCodeName(class FName HitPartsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "GetWeakElementSkillCodeName");

	Params::LEquipmentComponent_GetWeakElementSkillCodeName Parms{};

	Parms.HitPartsName = HitPartsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.IsBodyNeedShrink
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::IsBodyNeedShrink() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "IsBodyNeedShrink");

	Params::LEquipmentComponent_IsBodyNeedShrink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.IsHitPartsDestoryed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::IsHitPartsDestoryed(class FName HitPartsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "IsHitPartsDestoryed");

	Params::LEquipmentComponent_IsHitPartsDestoryed Parms{};

	Parms.HitPartsName = HitPartsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEquipmentComponent.IsHitPartsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULEquipmentComponent::IsHitPartsEnabled(class FName HitPartsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEquipmentComponent", "IsHitPartsEnabled");

	Params::LEquipmentComponent_IsHitPartsEnabled Parms{};

	Parms.HitPartsName = HitPartsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LEventDispatcherSystem.CaptureMomentCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMomentConditionCaptureInfo      CapturedInfo                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::CaptureMomentCondition(const struct FMomentConditionCaptureInfo& CapturedInfo, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "CaptureMomentCondition");

	Params::LEventDispatcherSystem_CaptureMomentCondition Parms{};

	Parms.CapturedInfo = std::move(CapturedInfo);
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.OnUIConfirmNewGamePlus
// (Final, Native, Public)
// Parameters:
// bool                                    IsConfirm                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::OnUIConfirmNewGamePlus(bool IsConfirm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "OnUIConfirmNewGamePlus");

	Params::LEventDispatcherSystem_OnUIConfirmNewGamePlus Parms{};

	Parms.IsConfirm = IsConfirm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.OnUIMsgYouDieEnd
// (Final, Native, Public)

void ULEventDispatcherSystem::OnUIMsgYouDieEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "OnUIMsgYouDieEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.RaiseSenseToActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Reciever                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAISenseTakeLocation            TakeLocation                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::RaiseSenseToActor(class AActor* Reciever, const struct FLAISenseTakeLocation& TakeLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "RaiseSenseToActor");

	Params::LEventDispatcherSystem_RaiseSenseToActor Parms{};

	Parms.Reciever = Reciever;
	Parms.TakeLocation = std::move(TakeLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.RaiseSenseToActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAISenseTakeLocation            TakeLocation                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::RaiseSenseToActors(const struct FLAISenseTakeLocation& TakeLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "RaiseSenseToActors");

	Params::LEventDispatcherSystem_RaiseSenseToActors Parms{};

	Parms.TakeLocation = std::move(TakeLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.SendHelpSignal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::SendHelpSignal(class AActor* Target, float OverrideRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "SendHelpSignal");

	Params::LEventDispatcherSystem_SendHelpSignal Parms{};

	Parms.Target = Target;
	Parms.OverrideRange = OverrideRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.SenseTargetToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Reciever                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAISense                               Sense                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::SenseTargetToActor(class AActor* Reciever, ELAISense Sense, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "SenseTargetToActor");

	Params::LEventDispatcherSystem_SenseTargetToActor Parms{};

	Parms.Reciever = Reciever;
	Parms.Sense = Sense;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LEventDispatcherSystem.SenseTargetToCharacters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAISense                               Sense                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULEventDispatcherSystem::SenseTargetToCharacters(ELAISense Sense, class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LEventDispatcherSystem", "SenseTargetToCharacters");

	Params::LEventDispatcherSystem_SenseTargetToCharacters Parms{};

	Parms.Sense = Sense;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LExiledNpcArea.OnComponentBeginOverlapped_Warning_Inner
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALExiledNpcArea::OnComponentBeginOverlapped_Warning_Inner(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LExiledNpcArea", "OnComponentBeginOverlapped_Warning_Inner");

	Params::LExiledNpcArea_OnComponentBeginOverlapped_Warning_Inner Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LExiledNpcArea.OnComponentBeginOverlapped_Warning_Outer
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALExiledNpcArea::OnComponentBeginOverlapped_Warning_Outer(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LExiledNpcArea", "OnComponentBeginOverlapped_Warning_Outer");

	Params::LExiledNpcArea_OnComponentBeginOverlapped_Warning_Outer Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LExiledNpcArea.OnComponentEndOverlapped_Warning_Inner
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALExiledNpcArea::OnComponentEndOverlapped_Warning_Inner(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LExiledNpcArea", "OnComponentEndOverlapped_Warning_Inner");

	Params::LExiledNpcArea_OnComponentEndOverlapped_Warning_Inner Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LExiledNpcArea.OnComponentEndOverlapped_Warning_Outer
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALExiledNpcArea::OnComponentEndOverlapped_Warning_Outer(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LExiledNpcArea", "OnComponentEndOverlapped_Warning_Outer");

	Params::LExiledNpcArea_OnComponentEndOverlapped_Warning_Outer Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LExiledNpcSystem.MakeNewContextBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULExiledNpcSystem::MakeNewContextBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LExiledNpcSystem", "MakeNewContextBP");

	Params::LExiledNpcSystem_MakeNewContextBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFrenzyComponent.ActivateFrenzy
// (Final, Native, Public, BlueprintCallable)

void ULFrenzyComponent::ActivateFrenzy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFrenzyComponent", "ActivateFrenzy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFrenzyComponent.DeactivateFrenzy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bExhaustAllFrenzyPoint                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFrenzyComponent::DeactivateFrenzy(bool bExhaustAllFrenzyPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFrenzyComponent", "DeactivateFrenzy");

	Params::LFrenzyComponent_DeactivateFrenzy Parms{};

	Parms.bExhaustAllFrenzyPoint = bExhaustAllFrenzyPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFrenzyComponent.OnFrenzySkillEnded
// (Final, Native, Public, BlueprintCallable)

void ULFrenzyComponent::OnFrenzySkillEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFrenzyComponent", "OnFrenzySkillEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFrenzyComponent.OnFrenzySkillUsed
// (Final, Native, Public, BlueprintCallable)

void ULFrenzyComponent::OnFrenzySkillUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFrenzyComponent", "OnFrenzySkillUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFrenzyComponent.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFrenzyComponent::IsActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFrenzyComponent", "IsActivated");

	Params::LFrenzyComponent_IsActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCSpotTriggerComponent.OnComponentBeginOverlapSpotTrigger
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULNPCSpotTriggerComponent::OnComponentBeginOverlapSpotTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCSpotTriggerComponent", "OnComponentBeginOverlapSpotTrigger");

	Params::LNPCSpotTriggerComponent_OnComponentBeginOverlapSpotTrigger Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCSpotTriggerComponent.OnRemovePauseAI
// (Final, Native, Protected)

void ULNPCSpotTriggerComponent::OnRemovePauseAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCSpotTriggerComponent", "OnRemovePauseAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCSpotTriggerComponent.OnSpotTriggerRetry
// (Final, Native, Protected)

void ULNPCSpotTriggerComponent::OnSpotTriggerRetry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCSpotTriggerComponent", "OnSpotTriggerRetry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXVaryingComponent.IsPlayingVaryingName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFXVaryingComponent::IsPlayingVaryingName(class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXVaryingComponent", "IsPlayingVaryingName");

	Params::LFXVaryingComponent_IsPlayingVaryingName Parms{};

	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFXVaryingComponent.PlayVaryingWithMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetToDefault                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXVaryingComponent::PlayVaryingWithMesh(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, class UMeshComponent* MeshComp, bool bResetToDefault, class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXVaryingComponent", "PlayVaryingWithMesh");

	Params::LFXVaryingComponent_PlayVaryingWithMesh Parms{};

	Parms.MaterialVarying = MaterialVarying;
	Parms.PlayType = PlayType;
	Parms.MeshComp = MeshComp;
	Parms.bResetToDefault = bResetToDefault;
	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXVaryingComponent.PlayVaryingWithMeshes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>           MeshComps                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bResetToDefault                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXVaryingComponent::PlayVaryingWithMeshes(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, const TArray<class UMeshComponent*>& MeshComps, bool bResetToDefault, class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXVaryingComponent", "PlayVaryingWithMeshes");

	Params::LFXVaryingComponent_PlayVaryingWithMeshes Parms{};

	Parms.MaterialVarying = MaterialVarying;
	Parms.PlayType = PlayType;
	Parms.MeshComps = std::move(MeshComps);
	Parms.bResetToDefault = bResetToDefault;
	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXVaryingComponent.StopVaryingAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetToDefault                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXVaryingComponent::StopVaryingAll(bool bResetToDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXVaryingComponent", "StopVaryingAll");

	Params::LFXVaryingComponent_StopVaryingAll Parms{};

	Parms.bResetToDefault = bResetToDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeaponFXVaryingComponent.ApplyMaterialFx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InMaterialFxCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponFXVaryingComponent::ApplyMaterialFx(class FName InMaterialFxCodename, class UMeshComponent* MeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponFXVaryingComponent", "ApplyMaterialFx");

	Params::LWeaponFXVaryingComponent_ApplyMaterialFx Parms{};

	Parms.InMaterialFxCodename = InMaterialFxCodename;
	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeaponFXVaryingComponent.RemoveMaterialFx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InMaterialFxCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWeaponFXVaryingComponent::RemoveMaterialFx(class FName InMaterialFxCodename, class UMeshComponent* MeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponFXVaryingComponent", "RemoveMaterialFx");

	Params::LWeaponFXVaryingComponent_RemoveMaterialFx Parms{};

	Parms.InMaterialFxCodename = InMaterialFxCodename;
	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.ChangeCurrentLocationToHomeLocation
// (Final, Native, Public, BlueprintCallable)

void ALNPCCharacter::ChangeCurrentLocationToHomeLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "ChangeCurrentLocationToHomeLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.ChangePhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionGroupTableCodeName                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::ChangePhase(class FName ActionGroupTableCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "ChangePhase");

	Params::LNPCCharacter_ChangePhase Parms{};

	Parms.ActionGroupTableCodeName = ActionGroupTableCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.DeadCharacterBP
// (Event, Public, BlueprintEvent)

void ALNPCCharacter::DeadCharacterBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "DeadCharacterBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCCharacter.DoExitFunctionTimeDespawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::DoExitFunctionTimeDespawn(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "DoExitFunctionTimeDespawn");

	Params::LNPCCharacter_DoExitFunctionTimeDespawn Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.DoExitFunctionTimeInvisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::DoExitFunctionTimeInvisible(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "DoExitFunctionTimeInvisible");

	Params::LNPCCharacter_DoExitFunctionTimeInvisible Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.DoExitFunctionTimeLookHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULMaterialVarying*                HideVarying                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::DoExitFunctionTimeLookHide(float Time, class ULMaterialVarying* HideVarying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "DoExitFunctionTimeLookHide");

	Params::LNPCCharacter_DoExitFunctionTimeLookHide Parms{};

	Parms.Time = Time;
	Parms.HideVarying = HideVarying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.DoPlay_RedButterfly
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::DoPlay_RedButterfly(float StartDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "DoPlay_RedButterfly");

	Params::LNPCCharacter_DoPlay_RedButterfly Parms{};

	Parms.StartDelay = StartDelay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCCharacter.FindRootMotionJumpContext
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLRootMotionJumpContext          OutContext                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::FindRootMotionJumpContext(class FName SkillCodeName, struct FLRootMotionJumpContext* OutContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "FindRootMotionJumpContext");

	Params::LNPCCharacter_FindRootMotionJumpContext Parms{};

	Parms.SkillCodeName = SkillCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutContext != nullptr)
		*OutContext = std::move(Parms.OutContext);

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.HasShareData_Event
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::HasShareData_Event(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "HasShareData_Event");

	Params::LNPCCharacter_HasShareData_Event Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.HeadTagBindingBP
// (Event, Public, BlueprintEvent)

void ALNPCCharacter::HeadTagBindingBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "HeadTagBindingBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCCharacter.HeadTagSettingBP
// (Event, Public, BlueprintEvent)

void ALNPCCharacter::HeadTagSettingBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "HeadTagSettingBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCCharacter.HeadTagVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::HeadTagVisibility(bool InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "HeadTagVisibility");

	Params::LNPCCharacter_HeadTagVisibility Parms{};

	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.InitPhase
// (Final, Native, Public, BlueprintCallable)

void ALNPCCharacter::InitPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "InitPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.IsPlaying_RedButterfly
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::IsPlaying_RedButterfly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "IsPlaying_RedButterfly");

	Params::LNPCCharacter_IsPlaying_RedButterfly Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.OnActiveGroupping_RedButterfly
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALNPCSpot*                        InGrouppingPropVolume                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnActiveGroupping_RedButterfly(class ALNPCSpot* InGrouppingPropVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnActiveGroupping_RedButterfly");

	Params::LNPCCharacter_OnActiveGroupping_RedButterfly Parms{};

	Parms.InGrouppingPropVolume = InGrouppingPropVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCCharacter.OnChangePhase
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ActionGroupTableCodeName                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CommonActionPath                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LocomotoinActionPath                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnChangePhase(class FName ActionGroupTableCodeName, class FName CommonActionPath, class FName LocomotoinActionPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnChangePhase");

	Params::LNPCCharacter_OnChangePhase Parms{};

	Parms.ActionGroupTableCodeName = ActionGroupTableCodeName;
	Parms.CommonActionPath = CommonActionPath;
	Parms.LocomotoinActionPath = LocomotoinActionPath;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCCharacter.OnExitCharacter
// (Event, Protected, BlueprintEvent)

void ALNPCCharacter::OnExitCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnExitCharacter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCCharacter.OnGroggyOccurred
// (Final, Native, Public)
// Parameters:
// bool                                    IsStarted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnGroggyOccurred(bool IsStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnGroggyOccurred");

	Params::LNPCCharacter_OnGroggyOccurred Parms{};

	Parms.IsStarted = IsStarted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.OnRespawnBP
// (Event, Public, BlueprintEvent)

void ALNPCCharacter::OnRespawnBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnRespawnBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCCharacter.OnSleepStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSleepState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnSleepStateChanged(bool bSleepState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnSleepStateChanged");

	Params::LNPCCharacter_OnSleepStateChanged Parms{};

	Parms.bSleepState = bSleepState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCCharacter.OnStartAI
// (Event, Public, BlueprintEvent)

void ALNPCCharacter::OnStartAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnStartAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCCharacter.OnSwapNPC
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALNPCCharacter*                   BeforeNPC                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCCharacter*                   AfterNPC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnSwapNPC(class ALNPCCharacter* BeforeNPC, class ALNPCCharacter* AfterNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnSwapNPC");

	Params::LNPCCharacter_OnSwapNPC Parms{};

	Parms.BeforeNPC = BeforeNPC;
	Parms.AfterNPC = AfterNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCCharacter.OnWatchActionStateAfterRemove
// (Final, Native, Protected)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnWatchActionStateAfterRemove(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnWatchActionStateAfterRemove");

	Params::LNPCCharacter_OnWatchActionStateAfterRemove Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.OnWatchActionStateBeforeAdd
// (Final, Native, Protected)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::OnWatchActionStateBeforeAdd(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "OnWatchActionStateBeforeAdd");

	Params::LNPCCharacter_OnWatchActionStateBeforeAdd Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.PlayAction_CommonMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CommonMontageCodeName                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlayAction_CommonMontage(class FName CommonMontageCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlayAction_CommonMontage");

	Params::LNPCCharacter_PlayAction_CommonMontage Parms{};

	Parms.CommonMontageCodeName = CommonMontageCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.PlayAction_RotationToAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   YawAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlayAction_RotationToAngle(float YawAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlayAction_RotationToAngle");

	Params::LNPCCharacter_PlayAction_RotationToAngle Parms{};

	Parms.YawAngle = YawAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.PlayAction_RotationToHome
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlayAction_RotationToHome()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlayAction_RotationToHome");

	Params::LNPCCharacter_PlayAction_RotationToHome Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.PlayAction_RotationToTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CoolTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaySpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlayAction_RotationToTarget(float CoolTime, float PlaySpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlayAction_RotationToTarget");

	Params::LNPCCharacter_PlayAction_RotationToTarget Parms{};

	Parms.CoolTime = CoolTime;
	Parms.PlaySpeed = PlaySpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.PlayAction_SpawnIdle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlayAction_SpawnIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlayAction_SpawnIdle");

	Params::LNPCCharacter_PlayAction_SpawnIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.PlayAction_TalkerIdle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlayAction_TalkerIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlayAction_TalkerIdle");

	Params::LNPCCharacter_PlayAction_TalkerIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.PlaySkill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SkillCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULActBase* ALNPCCharacter::PlaySkill(class FName SkillCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "PlaySkill");

	Params::LNPCCharacter_PlaySkill Parms{};

	Parms.SkillCodeName = SkillCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.SetCombatStateBP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCombatState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::SetCombatStateBP(bool bCombatState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "SetCombatStateBP");

	Params::LNPCCharacter_SetCombatStateBP Parms{};

	Parms.bCombatState = bCombatState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCCharacter.SetGroggyPointAdjustRatio
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FLGroggyPointAdjustRatio> Override                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALNPCCharacter::SetGroggyPointAdjustRatio(const TArray<struct FLGroggyPointAdjustRatio>& Override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "SetGroggyPointAdjustRatio");

	Params::LNPCCharacter_SetGroggyPointAdjustRatio Parms{};

	Parms.Override = std::move(Override);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.SetScarecrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::SetScarecrow(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "SetScarecrow");

	Params::LNPCCharacter_SetScarecrow Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.SetShareData_Event
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::SetShareData_Event(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "SetShareData_Event");

	Params::LNPCCharacter_SetShareData_Event Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.SetVisibleHPBar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsCombatState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::SetVisibleHPBar(bool IsVisible, bool IsCombatState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "SetVisibleHPBar");

	Params::LNPCCharacter_SetVisibleHPBar Parms{};

	Parms.IsVisible = IsVisible;
	Parms.IsCombatState = IsCombatState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.StartExitNPCFunctions
// (Native, Event, Public, BlueprintEvent)

void ALNPCCharacter::StartExitNPCFunctions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "StartExitNPCFunctions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.StopAction_SpawnIdle
// (Final, Native, Public, BlueprintCallable)

void ALNPCCharacter::StopAction_SpawnIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "StopAction_SpawnIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.SwapNpc
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             NPCCodeName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpawnOffset                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInheritHP                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSpawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetSwapAtRespawn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnOnSpot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCCharacter::SwapNpc(const class FName& NPCCodeName, const struct FVector& SpawnOffset, bool bInheritHP, bool bForceSpawn, bool bResetSwapAtRespawn, bool bSpawnOnSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "SwapNpc");

	Params::LNPCCharacter_SwapNpc Parms{};

	Parms.NPCCodeName = NPCCodeName;
	Parms.SpawnOffset = std::move(SpawnOffset);
	Parms.bInheritHP = bInheritHP;
	Parms.bForceSpawn = bForceSpawn;
	Parms.bResetSwapAtRespawn = bResetSwapAtRespawn;
	Parms.bSpawnOnSpot = bSpawnOnSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCCharacter.TryGroggy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConsumePoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CheckOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::TryGroggy(int32 ConsumePoint, bool CheckOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "TryGroggy");

	Params::LNPCCharacter_TryGroggy Parms{};

	Parms.ConsumePoint = ConsumePoint;
	Parms.CheckOnly = CheckOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.TryGroggyEnableTimeAdd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::TryGroggyEnableTimeAdd(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "TryGroggyEnableTimeAdd");

	Params::LNPCCharacter_TryGroggyEnableTimeAdd Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.TrySuppressGroggy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::TrySuppressGroggy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "TrySuppressGroggy");

	Params::LNPCCharacter_TrySuppressGroggy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.CheckHitRepulse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELPhysicalDamageType                    InPhyscialDamageType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAttackRepulseLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::CheckHitRepulse(ELPhysicalDamageType InPhyscialDamageType, int32 InAttackRepulseLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "CheckHitRepulse");

	Params::LNPCCharacter_CheckHitRepulse Parms{};

	Parms.InPhyscialDamageType = InPhyscialDamageType;
	Parms.InAttackRepulseLevel = InAttackRepulseLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.CheckPartsHitRepulse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELPhysicalDamageType                    InPhyscialDamageType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAttackRepulseLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitPartsName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::CheckPartsHitRepulse(ELPhysicalDamageType InPhyscialDamageType, int32 InAttackRepulseLevel, class FName HitPartsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "CheckPartsHitRepulse");

	Params::LNPCCharacter_CheckPartsHitRepulse Parms{};

	Parms.InPhyscialDamageType = InPhyscialDamageType;
	Parms.InAttackRepulseLevel = InAttackRepulseLevel;
	Parms.HitPartsName = HitPartsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.GetMoveSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALNPCCharacter::GetMoveSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "GetMoveSpeed");

	Params::LNPCCharacter_GetMoveSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.GetNPCInfoActionGroupCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALNPCCharacter::GetNPCInfoActionGroupCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "GetNPCInfoActionGroupCodeName");

	Params::LNPCCharacter_GetNPCInfoActionGroupCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.GetScaledFloatingStateCeilingCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALNPCCharacter::GetScaledFloatingStateCeilingCapsuleHalfHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "GetScaledFloatingStateCeilingCapsuleHalfHeight");

	Params::LNPCCharacter_GetScaledFloatingStateCeilingCapsuleHalfHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.GetSightDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALNPCCharacter::GetSightDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "GetSightDistance");

	Params::LNPCCharacter_GetSightDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.GetTargetDetectRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALNPCCharacter::GetTargetDetectRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "GetTargetDetectRange");

	Params::LNPCCharacter_GetTargetDetectRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCCharacter.IsCombatState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCCharacter::IsCombatState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCCharacter", "IsCombatState");

	Params::LNPCCharacter_IsCombatState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFXComponent.DelayDeactiveSystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::DelayDeactiveSystem(class UNiagaraComponent* NiagaraComponent, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "DelayDeactiveSystem");

	Params::LFXComponent_DelayDeactiveSystem Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.FXCommand_DeactiveTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UFXSystemComponent*>       FXs                                                    (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   DeactiveTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::FXCommand_DeactiveTime(const TArray<class UFXSystemComponent*>& FXs, float DeactiveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "FXCommand_DeactiveTime");

	Params::LFXComponent_FXCommand_DeactiveTime Parms{};

	Parms.FXs = std::move(FXs);
	Parms.DeactiveTime = DeactiveTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.FXCommand_DoEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELFXCommandEventType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::FXCommand_DoEvent(ELFXCommandEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "FXCommand_DoEvent");

	Params::LFXComponent_FXCommand_DoEvent Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.FXCommands_DeactiveEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UFXSystemComponent*>       FXs                                                    (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELFXCommandEventType                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::FXCommands_DeactiveEvent(const TArray<class UFXSystemComponent*>& FXs, ELFXCommandEventType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "FXCommands_DeactiveEvent");

	Params::LFXComponent_FXCommands_DeactiveEvent Parms{};

	Parms.FXs = std::move(FXs);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.HideManagedNiagaraComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHide                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::HideManagedNiagaraComponents(bool bHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "HideManagedNiagaraComponents");

	Params::LFXComponent_HideManagedNiagaraComponents Parms{};

	Parms.bHide = bHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.IsPlayingVaryingName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFXComponent::IsPlayingVaryingName(class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "IsPlayingVaryingName");

	Params::LFXComponent_IsPlayingVaryingName Parms{};

	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFXComponent.PlayBodyDurabilityConsumeFX
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELPartsAttachPointType                  AttachPointType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayBodyDurabilityConsumeFX(ELPartsAttachPointType AttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayBodyDurabilityConsumeFX");

	Params::LFXComponent_PlayBodyDurabilityConsumeFX Parms{};

	Parms.AttachPointType = AttachPointType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXComponent.PlayDeadHide
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bDissolveEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayDeadHide(bool bDissolveEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayDeadHide");

	Params::LFXComponent_PlayDeadHide Parms{};

	Parms.bDissolveEffect = bDissolveEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXComponent.PlayElementPartsHitFX
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class UNiagaraSystem*                   System                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayElementPartsHitFX(class UNiagaraSystem* System, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayElementPartsHitFX");

	Params::LFXComponent_PlayElementPartsHitFX Parms{};

	Parms.System = System;
	Parms.HitLocation = std::move(HitLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXComponent.PlayHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDissolveEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULMaterialVarying*                HideVarying                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VaryingName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayHide(bool bDissolveEffect, class ULMaterialVarying* HideVarying, const class FName VaryingName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayHide");

	Params::LFXComponent_PlayHide Parms{};

	Parms.bDissolveEffect = bDissolveEffect;
	Parms.HideVarying = HideVarying;
	Parms.VaryingName = VaryingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.PlayHitRegionFX
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLHitFXPlayData                  HitFXPlayData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULFXComponent::PlayHitRegionFX(const struct FLHitFXPlayData& HitFXPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayHitRegionFX");

	Params::LFXComponent_PlayHitRegionFX Parms{};

	Parms.HitFXPlayData = std::move(HitFXPlayData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXComponent.PlayMaterialParamScalar
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PlayerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInterface*>       Materials                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FLMaterialParamScalar>    Scalar                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULFXComponent::PlayMaterialParamScalar(class FName PlayerName, const TArray<class UMaterialInterface*>& Materials, const TArray<struct FLMaterialParamScalar>& Scalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayMaterialParamScalar");

	Params::LFXComponent_PlayMaterialParamScalar Parms{};

	Parms.PlayerName = PlayerName;
	Parms.Materials = std::move(Materials);
	Parms.Scalar = std::move(Scalar);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.PlayMaterialParamScalarSingle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PlayerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInterface*>       Materials                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLMaterialParamScalar            Scalar                                                 (Parm, NativeAccessSpecifierPublic)

void ULFXComponent::PlayMaterialParamScalarSingle(class FName PlayerName, const TArray<class UMaterialInterface*>& Materials, const struct FLMaterialParamScalar& Scalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayMaterialParamScalarSingle");

	Params::LFXComponent_PlayMaterialParamScalarSingle Parms{};

	Parms.PlayerName = PlayerName;
	Parms.Materials = std::move(Materials);
	Parms.Scalar = std::move(Scalar);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.PlayMaterialVaryingValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FLMaterialVaryingScalar>  ScalarValues                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLMaterialVaryingColor>   ColorValues                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>           MeshComponents                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayMaterialVaryingValues(const TArray<struct FLMaterialVaryingScalar>& ScalarValues, const TArray<struct FLMaterialVaryingColor>& ColorValues, ELMaterialVaryingPlayType PlayType, const TArray<class UMeshComponent*>& MeshComponents, class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayMaterialVaryingValues");

	Params::LFXComponent_PlayMaterialVaryingValues Parms{};

	Parms.ScalarValues = std::move(ScalarValues);
	Parms.ColorValues = std::move(ColorValues);
	Parms.PlayType = PlayType;
	Parms.MeshComponents = std::move(MeshComponents);
	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.PlayMaterialVaryingWithMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMeshComponent*                   MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayMaterialVaryingWithMesh(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, class UMeshComponent* MeshComp, class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayMaterialVaryingWithMesh");

	Params::LFXComponent_PlayMaterialVaryingWithMesh Parms{};

	Parms.MaterialVarying = MaterialVarying;
	Parms.PlayType = PlayType;
	Parms.MeshComp = MeshComp;
	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.PlayMaterialVaryingWithMeshes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               PlayType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>           MeshComps                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             PlayName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayMaterialVaryingWithMeshes(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, const TArray<class UMeshComponent*>& MeshComps, class FName PlayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayMaterialVaryingWithMeshes");

	Params::LFXComponent_PlayMaterialVaryingWithMeshes Parms{};

	Parms.MaterialVarying = MaterialVarying;
	Parms.PlayType = PlayType;
	Parms.MeshComps = std::move(MeshComps);
	Parms.PlayName = PlayName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.PlayTrail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  PSTemplate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FirstSocketName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SecondSocketName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::PlayTrail(class UObject* Instigator, class UParticleSystem* PSTemplate, class FName FirstSocketName, class FName SecondSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "PlayTrail");

	Params::LFXComponent_PlayTrail Parms{};

	Parms.Instigator = Instigator;
	Parms.PSTemplate = PSTemplate;
	Parms.FirstSocketName = FirstSocketName;
	Parms.SecondSocketName = SecondSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.RefreshHide
// (Final, Native, Public, BlueprintCallable)

void ULFXComponent::RefreshHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "RefreshHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.RefreshHideWeapon
// (Final, Native, Public, BlueprintCallable)

void ULFXComponent::RefreshHideWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "RefreshHideWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.ResetToDefaultMaterial
// (Final, Native, Public, BlueprintCallable)

void ULFXComponent::ResetToDefaultMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "ResetToDefaultMaterial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.SetUseResetToDefaultMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::SetUseResetToDefaultMaterial(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "SetUseResetToDefaultMaterial");

	Params::LFXComponent_SetUseResetToDefaultMaterial Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.StartSplashBloodFX
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALCharacter*                      Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         AttackerWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELBloodEffectType                       BloodType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackerStiffenDurationTime                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::StartSplashBloodFX(class ALCharacter* Attacker, class ALWeapon* AttackerWeapon, ELBloodEffectType BloodType, float AttackerStiffenDurationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StartSplashBloodFX");

	Params::LFXComponent_StartSplashBloodFX Parms{};

	Parms.Attacker = Attacker;
	Parms.AttackerWeapon = AttackerWeapon;
	Parms.BloodType = BloodType;
	Parms.AttackerStiffenDurationTime = AttackerStiffenDurationTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXComponent.StopHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDissolveEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::StopHide(bool bDissolveEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StopHide");

	Params::LFXComponent_StopHide Parms{};

	Parms.bDissolveEffect = bDissolveEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.StopMaterialParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PlayerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::StopMaterialParam(class FName PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StopMaterialParam");

	Params::LFXComponent_StopMaterialParam Parms{};

	Parms.PlayerName = PlayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.StopMaterialVarying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULMaterialVarying*                MaterialVarying                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::StopMaterialVarying(class ULMaterialVarying* MaterialVarying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StopMaterialVarying");

	Params::LFXComponent_StopMaterialVarying Parms{};

	Parms.MaterialVarying = MaterialVarying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.StopMaterialVaryingAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ResetToDefault                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::StopMaterialVaryingAll(bool ResetToDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StopMaterialVaryingAll");

	Params::LFXComponent_StopMaterialVaryingAll Parms{};

	Parms.ResetToDefault = ResetToDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.StopSplashBloodFX
// (Event, Public, BlueprintEvent)

void ULFXComponent::StopSplashBloodFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StopSplashBloodFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LFXComponent.StopTrail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReserveStopTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXComponent::StopTrail(class UObject* Instigator, float ReserveStopTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "StopTrail");

	Params::LFXComponent_StopTrail Parms{};

	Parms.Instigator = Instigator;
	Parms.ReserveStopTime = ReserveStopTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXComponent.IsHide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFXComponent::IsHide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXComponent", "IsHide");

	Params::LFXComponent_IsHide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystemData.ActiveFuryAttack
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALNPCCharacter*                   InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVolumeModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAttachedEffectSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLAttachedEffectSet ALFXSystemData::ActiveFuryAttack(class ALNPCCharacter* InTarget, bool bActive, float InVolumeModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "ActiveFuryAttack");

	Params::LFXSystemData_ActiveFuryAttack Parms{};

	Parms.InTarget = InTarget;
	Parms.bActive = bActive;
	Parms.InVolumeModifier = InVolumeModifier;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystemData.GetWeaponMaterialVarying
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             MaterialFxCodename                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class ULMaterialVarying> ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class ULMaterialVarying> ALFXSystemData::GetWeaponMaterialVarying(class FName MaterialFxCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "GetWeaponMaterialVarying");

	Params::LFXSystemData_GetWeaponMaterialVarying Parms{};

	Parms.MaterialFxCodename = MaterialFxCodename;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystemData.GetWeaponTrailElementFX
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ElementFXCodename                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* ALFXSystemData::GetWeaponTrailElementFX(class FName ElementFXCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "GetWeaponTrailElementFX");

	Params::LFXSystemData_GetWeaponTrailElementFX Parms{};

	Parms.ElementFXCodename = ElementFXCodename;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystemData.OnBeginTalk
// (Event, Public, BlueprintEvent)

void ALFXSystemData::OnBeginTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnBeginTalk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LFXSystemData.OnBuffEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachedSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAttachedEffectSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLAttachedEffectSet ALFXSystemData::OnBuffEffect(class AActor* Actor, class FName EventName, ELPhysicalSurfaceType PhysicalSurface, class FName AttachedSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnBuffEffect");

	Params::LFXSystemData_OnBuffEffect Parms{};

	Parms.Actor = Actor;
	Parms.EventName = EventName;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.AttachedSocketName = AttachedSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystemData.OnDisappear
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALCharacter*                      Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::OnDisappear(class ALCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnDisappear");

	Params::LFXSystemData_OnDisappear Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.OnEndTalk
// (Event, Public, BlueprintEvent)

void ALFXSystemData::OnEndTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnEndTalk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LFXSystemData.OnFrenzyModeMV
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALCharacter*                      InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFrenzyMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::OnFrenzyModeMV(class ALCharacter* InTarget, bool bFrenzyMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnFrenzyModeMV");

	Params::LFXSystemData_OnFrenzyModeMV Parms{};

	Parms.InTarget = InTarget;
	Parms.bFrenzyMode = bFrenzyMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.OnParalyzationOcurred
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::OnParalyzationOcurred(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnParalyzationOcurred");

	Params::LFXSystemData_OnParalyzationOcurred Parms{};

	Parms.Victim = Victim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.OnPulseRecharged
// (Event, Public, BlueprintEvent)

void ALFXSystemData::OnPulseRecharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnPulseRecharged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LFXSystemData.OnTorsionCoilPostProcess
// (Event, Public, BlueprintEvent)

void ALFXSystemData::OnTorsionCoilPostProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnTorsionCoilPostProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LFXSystemData.OnWeaponBladeDestroyEffect
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::OnWeaponBladeDestroyEffect(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "OnWeaponBladeDestroyEffect");

	Params::LFXSystemData_OnWeaponBladeDestroyEffect Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.PlayHitEffect
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLHitFXPlayData                  HitFXPlayData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALFXSystemData::PlayHitEffect(const struct FLHitFXPlayData& HitFXPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "PlayHitEffect");

	Params::LFXSystemData_PlayHitEffect Parms{};

	Parms.HitFXPlayData = std::move(HitFXPlayData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.PlaySocketTracerHitEffect_FX
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       HitTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerPhysicalSurface                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundPhysicalSurface                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::PlaySocketTracerHitEffect_FX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "PlaySocketTracerHitEffect_FX");

	Params::LFXSystemData_PlaySocketTracerHitEffect_FX Parms{};

	Parms.EventName = EventName;
	Parms.HitTransform = std::move(HitTransform);
	Parms.AttackerPhysicalSurface = AttackerPhysicalSurface;
	Parms.GroundPhysicalSurface = GroundPhysicalSurface;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.PlaySocketTracerHitEffect_SFX
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       HitTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerPhysicalSurface                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundPhysicalSurface                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::PlaySocketTracerHitEffect_SFX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "PlaySocketTracerHitEffect_SFX");

	Params::LFXSystemData_PlaySocketTracerHitEffect_SFX Parms{};

	Parms.EventName = EventName;
	Parms.HitTransform = std::move(HitTransform);
	Parms.AttackerPhysicalSurface = AttackerPhysicalSurface;
	Parms.GroundPhysicalSurface = GroundPhysicalSurface;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.SetBloodOnOff
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bOnOff                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFXSystemData::SetBloodOnOff(bool bOnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "SetBloodOnOff");

	Params::LFXSystemData_SetBloodOnOff Parms{};

	Parms.bOnOff = bOnOff;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystemData.SetFatalIndicatorState
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             IndicatorKey                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCharacter*                      TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFatalIndicatorState                   PrevState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFatalIndicatorState                   CurrentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       FxTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ALFXSystemData::SetFatalIndicatorState(class FName IndicatorKey, class ALCharacter* TargetActor, ELFatalIndicatorState PrevState, ELFatalIndicatorState CurrentState, const struct FTransform& FxTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystemData", "SetFatalIndicatorState");

	Params::LFXSystemData_SetFatalIndicatorState Parms{};

	Parms.IndicatorKey = IndicatorKey;
	Parms.TargetActor = TargetActor;
	Parms.PrevState = PrevState;
	Parms.CurrentState = CurrentState;
	Parms.FxTransform = std::move(FxTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LFXSystem.DetachEffectHardly
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAttachedEffectSet              Attached                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULFXSystem::DetachEffectHardly(struct FLAttachedEffectSet* Attached)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DetachEffectHardly");

	Params::LFXSystem_DetachEffectHardly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Attached != nullptr)
		*Attached = std::move(Parms.Attached);
}


// Function ProjectP.LFXSystem.DoFrenzyModeMV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALCharacter*                      InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFrenzyMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::DoFrenzyModeMV(class ALCharacter* InTarget, bool bFrenzyMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DoFrenzyModeMV");

	Params::LFXSystem_DoFrenzyModeMV Parms{};

	Parms.InTarget = InTarget;
	Parms.bFrenzyMode = bFrenzyMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.DoHitEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLHitFXPlayData                  HitFXPlayData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULFXSystem::DoHitEffect(const struct FLHitFXPlayData& HitFXPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DoHitEffect");

	Params::LFXSystem_DoHitEffect Parms{};

	Parms.HitFXPlayData = std::move(HitFXPlayData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.DoSmashEffect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLSmashFXPlayData                SmashFxPlayData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULFXSystem::DoSmashEffect(const struct FLSmashFXPlayData& SmashFxPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DoSmashEffect");

	Params::LFXSystem_DoSmashEffect Parms{};

	Parms.SmashFxPlayData = std::move(SmashFxPlayData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.DoSocketTracerHitEffect_FX
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       HitTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerPhysicalSurface                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundPhysicalSurface                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::DoSocketTracerHitEffect_FX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DoSocketTracerHitEffect_FX");

	Params::LFXSystem_DoSocketTracerHitEffect_FX Parms{};

	Parms.EventName = EventName;
	Parms.HitTransform = std::move(HitTransform);
	Parms.AttackerPhysicalSurface = AttackerPhysicalSurface;
	Parms.GroundPhysicalSurface = GroundPhysicalSurface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.DoSocketTracerHitEffect_SFX
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       HitTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerPhysicalSurface                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundPhysicalSurface                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::DoSocketTracerHitEffect_SFX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DoSocketTracerHitEffect_SFX");

	Params::LFXSystem_DoSocketTracerHitEffect_SFX Parms{};

	Parms.EventName = EventName;
	Parms.HitTransform = std::move(HitTransform);
	Parms.AttackerPhysicalSurface = AttackerPhysicalSurface;
	Parms.GroundPhysicalSurface = GroundPhysicalSurface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.DoWeaponBladeDestroyEffect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::DoWeaponBladeDestroyEffect(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "DoWeaponBladeDestroyEffect");

	Params::LFXSystem_DoWeaponBladeDestroyEffect Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.GetWeaponMaterialVarying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MaterialFxCodename                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class ULMaterialVarying> ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class ULMaterialVarying> ULFXSystem::GetWeaponMaterialVarying(class FName MaterialFxCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "GetWeaponMaterialVarying");

	Params::LFXSystem_GetWeaponMaterialVarying Parms{};

	Parms.MaterialFxCodename = MaterialFxCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystem.GetWeaponTrailElementFX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ElementFXCodename                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* ULFXSystem::GetWeaponTrailElementFX(class FName ElementFXCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "GetWeaponTrailElementFX");

	Params::LFXSystem_GetWeaponTrailElementFX Parms{};

	Parms.ElementFXCodename = ElementFXCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFXSystem.OnBeginTalk
// (Final, Native, Public, BlueprintCallable)

void ULFXSystem::OnBeginTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnBeginTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnDetachNiagaraDelegate
// (Final, Native, Public)
// Parameters:
// class UNiagaraComponent*                InNiagaraComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::OnDetachNiagaraDelegate(class UNiagaraComponent* InNiagaraComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnDetachNiagaraDelegate");

	Params::LFXSystem_OnDetachNiagaraDelegate Parms{};

	Parms.InNiagaraComp = InNiagaraComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnDetachParticleDelegate
// (Final, Native, Public)
// Parameters:
// class UParticleSystemComponent*         InParticleComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::OnDetachParticleDelegate(class UParticleSystemComponent* InParticleComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnDetachParticleDelegate");

	Params::LFXSystem_OnDetachParticleDelegate Parms{};

	Parms.InParticleComp = InParticleComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnEndTalk
// (Final, Native, Public, BlueprintCallable)

void ULFXSystem::OnEndTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnEndTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnFuryAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALNPCCharacter*                   InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVolumeModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::OnFuryAttack(class ALNPCCharacter* InTarget, float InVolumeModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnFuryAttack");

	Params::LFXSystem_OnFuryAttack Parms{};

	Parms.InTarget = InTarget;
	Parms.InVolumeModifier = InVolumeModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnParalyzationOcurred
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::OnParalyzationOcurred(class AActor* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnParalyzationOcurred");

	Params::LFXSystem_OnParalyzationOcurred Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnPulseRecharged
// (Final, Native, Public, BlueprintCallable)

void ULFXSystem::OnPulseRecharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnPulseRecharged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.OnTorsionCoilPostProcess
// (Final, Native, Public, BlueprintCallable)

void ULFXSystem::OnTorsionCoilPostProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "OnTorsionCoilPostProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.PlayDeadSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DeadActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFXSystem::PlayDeadSound(class AActor* DeadActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "PlayDeadSound");

	Params::LFXSystem_PlayDeadSound Parms{};

	Parms.DeadActor = DeadActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LFXSystem.SetFatalIndicatorState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             IndicatorKey                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALCharacter*                      TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFatalIndicatorState                   PrevState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFatalIndicatorState                   CurrentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       FxTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULFXSystem::SetFatalIndicatorState(class FName IndicatorKey, class ALCharacter* TargetActor, ELFatalIndicatorState PrevState, ELFatalIndicatorState CurrentState, const struct FTransform& FxTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFXSystem", "SetFatalIndicatorState");

	Params::LFXSystem_SetFatalIndicatorState Parms{};

	Parms.IndicatorKey = IndicatorKey;
	Parms.TargetActor = TargetActor;
	Parms.PrevState = PrevState;
	Parms.CurrentState = CurrentState;
	Parms.FxTransform = std::move(FxTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGallerySystemData.GetSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALGallerySystemData::GetSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystemData", "GetSpawned");

	Params::LGallerySystemData_GetSpawned Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LGallerySystemData.Spawn
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             CodeName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACineCameraActor*                 InPreviewCam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPreviewCam_OriginZ                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALGallerySystemData::Spawn(const class FName& CodeName, const struct FVector& InLocation, class ACineCameraActor* InPreviewCam, float InPreviewCam_OriginZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystemData", "Spawn");

	Params::LGallerySystemData_Spawn Parms{};

	Parms.CodeName = CodeName;
	Parms.InLocation = std::move(InLocation);
	Parms.InPreviewCam = InPreviewCam;
	Parms.InPreviewCam_OriginZ = InPreviewCam_OriginZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LGallerySystem.GetRecollectionAssetInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLGalleryAssetTableRowType       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLGalleryAssetTableRowType ULGallerySystem::GetRecollectionAssetInfo(const class FName& CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystem", "GetRecollectionAssetInfo");

	Params::LGallerySystem_GetRecollectionAssetInfo Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGallerySystem.GetRecollections
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FLDiplayableGallery>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLDiplayableGallery> ULGallerySystem::GetRecollections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystem", "GetRecollections");

	Params::LGallerySystem_GetRecollections Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGallerySystem.GetSpawnedModel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULGallerySystem::GetSpawnedModel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystem", "GetSpawnedModel");

	Params::LGallerySystem_GetSpawnedModel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGallerySystem.SpawnModel
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             CodeName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACineCameraActor*                 InPreviewCam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPreviewCam_OriginZ                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGallerySystem::SpawnModel(const class FName& CodeName, const struct FVector& InLocation, class ACineCameraActor* InPreviewCam, float InPreviewCam_OriginZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystem", "SpawnModel");

	Params::LGallerySystem_SpawnModel Parms{};

	Parms.CodeName = CodeName;
	Parms.InLocation = std::move(InLocation);
	Parms.InPreviewCam = InPreviewCam;
	Parms.InPreviewCam_OriginZ = InPreviewCam_OriginZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGallerySystem.SuccessSpawnModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InSpawnModel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGallerySystem::SuccessSpawnModel(class AActor* InSpawnModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGallerySystem", "SuccessSpawnModel");

	Params::LGallerySystem_SuccessSpawnModel Parms{};

	Parms.InSpawnModel = InSpawnModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LRecordCameraData.GetSampleFrame
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   FlowTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULRecordCameraData::GetSampleFrame(float FlowTime, struct FVector* Location, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LRecordCameraData", "GetSampleFrame");

	Params::LRecordCameraData_GetSampleFrame Parms{};

	Parms.FlowTime = FlowTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function ProjectP.LRecordCameraData.SampleFrame
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULRecordCameraData::SampleFrame(float DeltaTime, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LRecordCameraData", "SampleFrame");

	Params::LRecordCameraData_SampleFrame Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LReasonForDeathInfo.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULReasonForDeathInfo::IsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LReasonForDeathInfo", "IsDead");

	Params::LReasonForDeathInfo_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LReasonForDeathInfo.MakeNewRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELDieCauseType                          InDieCauseType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULReasonForDeathInfo::MakeNewRecord(class AActor* TargetActor, ELDieCauseType InDieCauseType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LReasonForDeathInfo", "MakeNewRecord");

	Params::LReasonForDeathInfo_MakeNewRecord Parms{};

	Parms.TargetActor = TargetActor;
	Parms.InDieCauseType = InDieCauseType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LReasonForDeathInfo.Reset
// (Final, Native, Public, BlueprintCallable)

void ULReasonForDeathInfo::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LReasonForDeathInfo", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildUpRecover
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAbnormalStateBuildUpRecover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAbnormalStateBuildUpRecover");

	Params::LCommonConstantValues_GetAbnormalStateBuildUpRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildUpRecoverDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetAbnormalStateBuildUpRecoverDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAbnormalStateBuildUpRecoverDelay");

	Params::LCommonConstantValues_GetAbnormalStateBuildUpRecoverDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildupRecoverRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetAbnormalStateBuildupRecoverRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAbnormalStateBuildupRecoverRate");

	Params::LCommonConstantValues_GetAbnormalStateBuildupRecoverRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAbnormalStateBuildupRecoverWait
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetAbnormalStateBuildupRecoverWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAbnormalStateBuildupRecoverWait");

	Params::LCommonConstantValues_GetAbnormalStateBuildupRecoverWait Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAbnormalStatePenaltyBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetAbnormalStatePenaltyBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAbnormalStatePenaltyBase");

	Params::LCommonConstantValues_GetAbnormalStatePenaltyBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAbnormalStatePenaltyExponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAbnormalStatePenaltyExponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAbnormalStatePenaltyExponent");

	Params::LCommonConstantValues_GetAbnormalStatePenaltyExponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAfterEndingCookieMovie
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetAfterEndingCookieMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAfterEndingCookieMovie");

	Params::LCommonConstantValues_GetAfterEndingCookieMovie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAggro_Target_Range
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAggro_Target_Range()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAggro_Target_Range");

	Params::LCommonConstantValues_GetAggro_Target_Range Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetASZombieHPSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetASZombieHPSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetASZombieHPSet");

	Params::LCommonConstantValues_GetASZombieHPSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAttackDefenceAdd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAttackDefenceAdd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAttackDefenceAdd");

	Params::LCommonConstantValues_GetAttackDefenceAdd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAttackDefenceExponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAttackDefenceExponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAttackDefenceExponent");

	Params::LCommonConstantValues_GetAttackDefenceExponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAttackDefenceScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAttackDefenceScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAttackDefenceScale");

	Params::LCommonConstantValues_GetAttackDefenceScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAttackScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetAttackScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAttackScale");

	Params::LCommonConstantValues_GetAttackScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAttackSpeedRatioMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetAttackSpeedRatioMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAttackSpeedRatioMax");

	Params::LCommonConstantValues_GetAttackSpeedRatioMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetAttackSpeedRatioMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetAttackSpeedRatioMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetAttackSpeedRatioMin");

	Params::LCommonConstantValues_GetAttackSpeedRatioMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBladeElementAttackBuff_Acid
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetBladeElementAttackBuff_Acid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBladeElementAttackBuff_Acid");

	Params::LCommonConstantValues_GetBladeElementAttackBuff_Acid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBladeElementAttackBuff_Electric
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetBladeElementAttackBuff_Electric()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBladeElementAttackBuff_Electric");

	Params::LCommonConstantValues_GetBladeElementAttackBuff_Electric Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBladeElementAttackBuff_Fire
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetBladeElementAttackBuff_Fire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBladeElementAttackBuff_Fire");

	Params::LCommonConstantValues_GetBladeElementAttackBuff_Fire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBladeNeedStatLackAtkRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetBladeNeedStatLackAtkRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBladeNeedStatLackAtkRatio");

	Params::LCommonConstantValues_GetBladeNeedStatLackAtkRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBladeNeedStatLackDestructionRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetBladeNeedStatLackDestructionRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBladeNeedStatLackDestructionRatio");

	Params::LCommonConstantValues_GetBladeNeedStatLackDestructionRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBladeNeedStatLackStaminaRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetBladeNeedStatLackStaminaRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBladeNeedStatLackStaminaRatio");

	Params::LCommonConstantValues_GetBladeNeedStatLackStaminaRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBossRaxasiaShieldBrokenName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetBossRaxasiaShieldBrokenName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBossRaxasiaShieldBrokenName");

	Params::LCommonConstantValues_GetBossRaxasiaShieldBrokenName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBossRaxasiaShieldName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetBossRaxasiaShieldName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBossRaxasiaShieldName");

	Params::LCommonConstantValues_GetBossRaxasiaShieldName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBossRoom_Ergodrop_relocation_check_state
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetBossRoom_Ergodrop_relocation_check_state()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBossRoom_Ergodrop_relocation_check_state");

	Params::LCommonConstantValues_GetBossRoom_Ergodrop_relocation_check_state Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBuildUpRecoverIncBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetBuildUpRecoverIncBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBuildUpRecoverIncBase");

	Params::LCommonConstantValues_GetBuildUpRecoverIncBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetBuildUpRecoverIncExponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetBuildUpRecoverIncExponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetBuildUpRecoverIncExponent");

	Params::LCommonConstantValues_GetBuildUpRecoverIncExponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCatDustEffectRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetCatDustEffectRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCatDustEffectRange");

	Params::LCommonConstantValues_GetCatDustEffectRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCatDustRangeDecreaseRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetCatDustRangeDecreaseRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCatDustRangeDecreaseRatio");

	Params::LCommonConstantValues_GetCatDustRangeDecreaseRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCatDustSensitiveDecreaseTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetCatDustSensitiveDecreaseTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCatDustSensitiveDecreaseTime");

	Params::LCommonConstantValues_GetCatDustSensitiveDecreaseTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCH06BossKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetCH06BossKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCH06BossKill");

	Params::LCommonConstantValues_GetCH06BossKill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCH13BossKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetCH13BossKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCH13BossKill");

	Params::LCommonConstantValues_GetCH13BossKill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetConsumeReturnClockBlockCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetConsumeReturnClockBlockCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetConsumeReturnClockBlockCondition");

	Params::LCommonConstantValues_GetConsumeReturnClockBlockCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetConsumeReturnClockBlockMsg
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetConsumeReturnClockBlockMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetConsumeReturnClockBlockMsg");

	Params::LCommonConstantValues_GetConsumeReturnClockBlockMsg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCopper2setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetCopper2setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCopper2setAbnormalState");

	Params::LCommonConstantValues_GetCopper2setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetCopper3setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetCopper3setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetCopper3setAbnormalState");

	Params::LCommonConstantValues_GetCopper3setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDashParryCooltime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetDashParryCooltime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDashParryCooltime");

	Params::LCommonConstantValues_GetDashParryCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDefaultCostumeCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetDefaultCostumeCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDefaultCostumeCodeName");

	Params::LCommonConstantValues_GetDefaultCostumeCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDefenceFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetDefenceFactor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDefenceFactor");

	Params::LCommonConstantValues_GetDefenceFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDefenceScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetDefenceScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDefenceScale");

	Params::LCommonConstantValues_GetDefenceScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDialogInputTerm
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetDialogInputTerm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDialogInputTerm");

	Params::LCommonConstantValues_GetDialogInputTerm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDialogNextSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetDialogNextSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDialogNextSpeed");

	Params::LCommonConstantValues_GetDialogNextSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDialogVoiceFadeoutSec
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetDialogVoiceFadeoutSec()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDialogVoiceFadeoutSec");

	Params::LCommonConstantValues_GetDialogVoiceFadeoutSec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDialogVoiceTermTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetDialogVoiceTermTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDialogVoiceTermTime");

	Params::LCommonConstantValues_GetDialogVoiceTermTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDoorKeyFail
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetDoorKeyFail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDoorKeyFail");

	Params::LCommonConstantValues_GetDoorKeyFail Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDoorKeySuccess
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetDoorKeySuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDoorKeySuccess");

	Params::LCommonConstantValues_GetDoorKeySuccess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetDropErgoExchangeRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetDropErgoExchangeRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetDropErgoExchangeRate");

	Params::LCommonConstantValues_GetDropErgoExchangeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetElementalAbStateBuildUpRecover
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetElementalAbStateBuildUpRecover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetElementalAbStateBuildUpRecover");

	Params::LCommonConstantValues_GetElementalAbStateBuildUpRecover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetElementalAbStateBuildUpRecoverDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetElementalAbStateBuildUpRecoverDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetElementalAbStateBuildUpRecoverDelay");

	Params::LCommonConstantValues_GetElementalAbStateBuildUpRecoverDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetExiledNpcWarningMsgDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetExiledNpcWarningMsgDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetExiledNpcWarningMsgDelay");

	Params::LCommonConstantValues_GetExiledNpcWarningMsgDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetFrenzyAbnormalCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetFrenzyAbnormalCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetFrenzyAbnormalCodeName");

	Params::LCommonConstantValues_GetFrenzyAbnormalCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetFrenzyPointMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetFrenzyPointMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetFrenzyPointMax");

	Params::LCommonConstantValues_GetFrenzyPointMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldenTreeAccelTimes
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetGoldenTreeAccelTimes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldenTreeAccelTimes");

	Params::LCommonConstantValues_GetGoldenTreeAccelTimes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldenTreeHarvestFirst
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetGoldenTreeHarvestFirst()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldenTreeHarvestFirst");

	Params::LCommonConstantValues_GetGoldenTreeHarvestFirst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldenTreeHarvestItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetGoldenTreeHarvestItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldenTreeHarvestItem");

	Params::LCommonConstantValues_GetGoldenTreeHarvestItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldenTreeHarvestItemNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetGoldenTreeHarvestItemNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldenTreeHarvestItemNum");

	Params::LCommonConstantValues_GetGoldenTreeHarvestItemNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldenTreePropUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ULCommonConstantValues::GetGoldenTreePropUniqueId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldenTreePropUniqueId");

	Params::LCommonConstantValues_GetGoldenTreePropUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldenTreeTimeToHarvesting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetGoldenTreeTimeToHarvesting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldenTreeTimeToHarvesting");

	Params::LCommonConstantValues_GetGoldenTreeTimeToHarvesting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGoldStackLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetGoldStackLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGoldStackLimit");

	Params::LCommonConstantValues_GetGoldStackLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGramophoneAttenuationAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class USoundAttenuation> ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class USoundAttenuation> ULCommonConstantValues::GetGramophoneAttenuationAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGramophoneAttenuationAsset");

	Params::LCommonConstantValues_GetGramophoneAttenuationAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetGuardParryCooltime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetGuardParryCooltime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetGuardParryCooltime");

	Params::LCommonConstantValues_GetGuardParryCooltime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Advance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHandleCorrectChangeCodeName_Advance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleCorrectChangeCodeName_Advance");

	Params::LCommonConstantValues_GetHandleCorrectChangeCodeName_Advance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Clear
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHandleCorrectChangeCodeName_Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleCorrectChangeCodeName_Clear");

	Params::LCommonConstantValues_GetHandleCorrectChangeCodeName_Clear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Motifvity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHandleCorrectChangeCodeName_Motifvity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleCorrectChangeCodeName_Motifvity");

	Params::LCommonConstantValues_GetHandleCorrectChangeCodeName_Motifvity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleCorrectChangeCodeName_Technique
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHandleCorrectChangeCodeName_Technique()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleCorrectChangeCodeName_Technique");

	Params::LCommonConstantValues_GetHandleCorrectChangeCodeName_Technique Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleCorrectionChange_UnderLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetHandleCorrectionChange_UnderLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleCorrectionChange_UnderLimit");

	Params::LCommonConstantValues_GetHandleCorrectionChange_UnderLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleCorrectionChange_UpperStackLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetHandleCorrectionChange_UpperStackLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleCorrectionChange_UpperStackLimit");

	Params::LCommonConstantValues_GetHandleCorrectionChange_UpperStackLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleNeedStatLackAtkRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetHandleNeedStatLackAtkRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleNeedStatLackAtkRatio");

	Params::LCommonConstantValues_GetHandleNeedStatLackAtkRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHandleNeedStatLackGuardSaveStaminaRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetHandleNeedStatLackGuardSaveStaminaRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHandleNeedStatLackGuardSaveStaminaRatio");

	Params::LCommonConstantValues_GetHandleNeedStatLackGuardSaveStaminaRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHelpMateAwakeItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHelpMateAwakeItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHelpMateAwakeItem");

	Params::LCommonConstantValues_GetHelpMateAwakeItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHelpMateDespawnWorldTrigger
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHelpMateDespawnWorldTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHelpMateDespawnWorldTrigger");

	Params::LCommonConstantValues_GetHelpMateDespawnWorldTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHelpMateFailMsg
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHelpMateFailMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHelpMateFailMsg");

	Params::LCommonConstantValues_GetHelpMateFailMsg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHelpMateSuccessMsg
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHelpMateSuccessMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHelpMateSuccessMsg");

	Params::LCommonConstantValues_GetHelpMateSuccessMsg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHitBoom_Projectile_Code_Name
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHitBoom_Projectile_Code_Name()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHitBoom_Projectile_Code_Name");

	Params::LCommonConstantValues_GetHitBoom_Projectile_Code_Name Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHotelTeleportActivateCondition1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHotelTeleportActivateCondition1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHotelTeleportActivateCondition1");

	Params::LCommonConstantValues_GetHotelTeleportActivateCondition1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHotelTeleportActivateCondition2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHotelTeleportActivateCondition2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHotelTeleportActivateCondition2");

	Params::LCommonConstantValues_GetHotelTeleportActivateCondition2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHotelTosionCoilCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHotelTosionCoilCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHotelTosionCoilCodeName");

	Params::LCommonConstantValues_GetHotelTosionCoilCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHotelTosionCoilCodeName2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHotelTosionCoilCodeName2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHotelTosionCoilCodeName2");

	Params::LCommonConstantValues_GetHotelTosionCoilCodeName2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHumanityGain_HighStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetHumanityGain_HighStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHumanityGain_HighStart");

	Params::LCommonConstantValues_GetHumanityGain_HighStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHumanityGainSkill_High
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHumanityGainSkill_High()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHumanityGainSkill_High");

	Params::LCommonConstantValues_GetHumanityGainSkill_High Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHumanityGainSkill_Low
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetHumanityGainSkill_Low()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHumanityGainSkill_Low");

	Params::LCommonConstantValues_GetHumanityGainSkill_Low Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetHumanityMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetHumanityMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetHumanityMax");

	Params::LCommonConstantValues_GetHumanityMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetInitWeatherCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetInitWeatherCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetInitWeatherCodeName");

	Params::LCommonConstantValues_GetInitWeatherCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetIntroSequenceCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetIntroSequenceCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetIntroSequenceCodeName");

	Params::LCommonConstantValues_GetIntroSequenceCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetInventoryMaxBladeSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetInventoryMaxBladeSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetInventoryMaxBladeSlot");

	Params::LCommonConstantValues_GetInventoryMaxBladeSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetInventoryMaxGearSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetInventoryMaxGearSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetInventoryMaxGearSlot");

	Params::LCommonConstantValues_GetInventoryMaxGearSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetInventoryMaxHandleSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetInventoryMaxHandleSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetInventoryMaxHandleSlot");

	Params::LCommonConstantValues_GetInventoryMaxHandleSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetInventoryMaxPartsSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetInventoryMaxPartsSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetInventoryMaxPartsSlot");

	Params::LCommonConstantValues_GetInventoryMaxPartsSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetInventoryMaxWeaponSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetInventoryMaxWeaponSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetInventoryMaxWeaponSlot");

	Params::LCommonConstantValues_GetInventoryMaxWeaponSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetItemValueGradeCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetItemValueGradeCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetItemValueGradeCheck");

	Params::LCommonConstantValues_GetItemValueGradeCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetLevelResetNeedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetLevelResetNeedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetLevelResetNeedItem");

	Params::LCommonConstantValues_GetLevelResetNeedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetLevelResetNeedItemNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetLevelResetNeedItemNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetLevelResetNeedItemNum");

	Params::LCommonConstantValues_GetLevelResetNeedItemNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetLieEffectSequenceCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetLieEffectSequenceCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetLieEffectSequenceCodeName");

	Params::LCommonConstantValues_GetLieEffectSequenceCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetLiftInteractionFailMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetLiftInteractionFailMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetLiftInteractionFailMessage");

	Params::LCommonConstantValues_GetLiftInteractionFailMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetLockerRefillMsgOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCommonConstantValues::GetLockerRefillMsgOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetLockerRefillMsgOn");

	Params::LCommonConstantValues_GetLockerRefillMsgOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetMaxLevelStationStargazer
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetMaxLevelStationStargazer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetMaxLevelStationStargazer");

	Params::LCommonConstantValues_GetMaxLevelStationStargazer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetMaxLevelStationStargazerCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetMaxLevelStationStargazerCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetMaxLevelStationStargazerCondition");

	Params::LCommonConstantValues_GetMaxLevelStationStargazerCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetMonadBuffMainItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetMonadBuffMainItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetMonadBuffMainItem");

	Params::LCommonConstantValues_GetMonadBuffMainItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetMonasterySimonDieCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetMonasterySimonDieCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetMonasterySimonDieCheck");

	Params::LCommonConstantValues_GetMonasterySimonDieCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetMonologueRepeatTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetMonologueRepeatTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetMonologueRepeatTime");

	Params::LCommonConstantValues_GetMonologueRepeatTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetMoviePOrganOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetMoviePOrganOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetMoviePOrganOpen");

	Params::LCommonConstantValues_GetMoviePOrganOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNGP_belt_slot_clear
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetNGP_belt_slot_clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNGP_belt_slot_clear");

	Params::LCommonConstantValues_GetNGP_belt_slot_clear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNoseStaffLargeBLD
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetNoseStaffLargeBLD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNoseStaffLargeBLD");

	Params::LCommonConstantValues_GetNoseStaffLargeBLD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNoseStaffLargeHND
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetNoseStaffLargeHND()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNoseStaffLargeHND");

	Params::LCommonConstantValues_GetNoseStaffLargeHND Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNoseStaffMediumBLD
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetNoseStaffMediumBLD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNoseStaffMediumBLD");

	Params::LCommonConstantValues_GetNoseStaffMediumBLD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNoseStaffMediumHND
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetNoseStaffMediumHND()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNoseStaffMediumHND");

	Params::LCommonConstantValues_GetNoseStaffMediumHND Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNoseStaffSmallHND
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetNoseStaffSmallHND()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNoseStaffSmallHND");

	Params::LCommonConstantValues_GetNoseStaffSmallHND Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetNpcMenuOpenDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetNpcMenuOpenDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetNpcMenuOpenDelay");

	Params::LCommonConstantValues_GetNpcMenuOpenDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetOpeningMovieCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetOpeningMovieCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetOpeningMovieCodeName");

	Params::LCommonConstantValues_GetOpeningMovieCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeBld1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeBld1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeBld1");

	Params::LCommonConstantValues_GetPCActionTypeBld1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeBld2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeBld2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeBld2");

	Params::LCommonConstantValues_GetPCActionTypeBld2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeBld3
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeBld3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeBld3");

	Params::LCommonConstantValues_GetPCActionTypeBld3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeHnd1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeHnd1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeHnd1");

	Params::LCommonConstantValues_GetPCActionTypeHnd1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeHnd2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeHnd2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeHnd2");

	Params::LCommonConstantValues_GetPCActionTypeHnd2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeHnd3
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeHnd3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeHnd3");

	Params::LCommonConstantValues_GetPCActionTypeHnd3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeStat1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeStat1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeStat1");

	Params::LCommonConstantValues_GetPCActionTypeStat1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeStat2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeStat2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeStat2");

	Params::LCommonConstantValues_GetPCActionTypeStat2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCActionTypeStat3
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCActionTypeStat3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCActionTypeStat3");

	Params::LCommonConstantValues_GetPCActionTypeStat3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCDialogMinTurnAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPCDialogMinTurnAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCDialogMinTurnAngle");

	Params::LCommonConstantValues_GetPCDialogMinTurnAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCDialogRotateTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPCDialogRotateTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCDialogRotateTime");

	Params::LCommonConstantValues_GetPCDialogRotateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCInitializeSet1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCInitializeSet1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCInitializeSet1");

	Params::LCommonConstantValues_GetPCInitializeSet1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCInitializeSet2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCInitializeSet2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCInitializeSet2");

	Params::LCommonConstantValues_GetPCInitializeSet2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCInitializeSet3
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCInitializeSet3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCInitializeSet3");

	Params::LCommonConstantValues_GetPCInitializeSet3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCInitializeSet_Factory1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCInitializeSet_Factory1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCInitializeSet_Factory1");

	Params::LCommonConstantValues_GetPCInitializeSet_Factory1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCInitializeSet_Factory2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCInitializeSet_Factory2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCInitializeSet_Factory2");

	Params::LCommonConstantValues_GetPCInitializeSet_Factory2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPCInitializeSet_Factory3
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPCInitializeSet_Factory3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPCInitializeSet_Factory3");

	Params::LCommonConstantValues_GetPCInitializeSet_Factory3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPlayRateExponentOver
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetPlayRateExponentOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPlayRateExponentOver");

	Params::LCommonConstantValues_GetPlayRateExponentOver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPlayRateExponentUnder
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetPlayRateExponentUnder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPlayRateExponentUnder");

	Params::LCommonConstantValues_GetPlayRateExponentUnder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPlayRecordCheckTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPlayRecordCheckTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPlayRecordCheckTime");

	Params::LCommonConstantValues_GetPlayRecordCheckTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevel2RequiredSynergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevel2RequiredSynergyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevel2RequiredSynergyCount");

	Params::LCommonConstantValues_GetPSystemLevel2RequiredSynergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevel3RequiredSynergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevel3RequiredSynergyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevel3RequiredSynergyCount");

	Params::LCommonConstantValues_GetPSystemLevel3RequiredSynergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevel4RequiredSynergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevel4RequiredSynergyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevel4RequiredSynergyCount");

	Params::LCommonConstantValues_GetPSystemLevel4RequiredSynergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevel5RequiredSynergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevel5RequiredSynergyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevel5RequiredSynergyCount");

	Params::LCommonConstantValues_GetPSystemLevel5RequiredSynergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevel6RequiredSynergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevel6RequiredSynergyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevel6RequiredSynergyCount");

	Params::LCommonConstantValues_GetPSystemLevel6RequiredSynergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevel7RequiredSynergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevel7RequiredSynergyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevel7RequiredSynergyCount");

	Params::LCommonConstantValues_GetPSystemLevel7RequiredSynergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevelLimitNewGamePlus0
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevelLimitNewGamePlus0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevelLimitNewGamePlus0");

	Params::LCommonConstantValues_GetPSystemLevelLimitNewGamePlus0 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevelLimitNewGamePlus1
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevelLimitNewGamePlus1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevelLimitNewGamePlus1");

	Params::LCommonConstantValues_GetPSystemLevelLimitNewGamePlus1 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemLevelLimitNewGamePlus2
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemLevelLimitNewGamePlus2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemLevelLimitNewGamePlus2");

	Params::LCommonConstantValues_GetPSystemLevelLimitNewGamePlus2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPSystemMaxLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetPSystemMaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPSystemMaxLevel");

	Params::LCommonConstantValues_GetPSystemMaxLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPulseItemBuffCodenameOnBreaked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPulseItemBuffCodenameOnBreaked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPulseItemBuffCodenameOnBreaked");

	Params::LCommonConstantValues_GetPulseItemBuffCodenameOnBreaked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetPulseItemCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetPulseItemCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetPulseItemCodeName");

	Params::LCommonConstantValues_GetPulseItemCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetQuartzItemCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetQuartzItemCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetQuartzItemCodeName");

	Params::LCommonConstantValues_GetQuartzItemCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetQuartzSystemLevelUpItemCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetQuartzSystemLevelUpItemCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetQuartzSystemLevelUpItemCodeName");

	Params::LCommonConstantValues_GetQuartzSystemLevelUpItemCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetQuartzSystemResetItemCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetQuartzSystemResetItemCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetQuartzSystemResetItemCodeName");

	Params::LCommonConstantValues_GetQuartzSystemResetItemCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetQuartzSystemResetItemNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetQuartzSystemResetItemNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetQuartzSystemResetItemNum");

	Params::LCommonConstantValues_GetQuartzSystemResetItemNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetRaxasiaShieldPartsName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetRaxasiaShieldPartsName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetRaxasiaShieldPartsName");

	Params::LCommonConstantValues_GetRaxasiaShieldPartsName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetReduceFPOnFrenzy
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetReduceFPOnFrenzy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetReduceFPOnFrenzy");

	Params::LCommonConstantValues_GetReduceFPOnFrenzy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetReduceFPOnFrenzyInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetReduceFPOnFrenzyInterval()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetReduceFPOnFrenzyInterval");

	Params::LCommonConstantValues_GetReduceFPOnFrenzyInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetRegainhpMakeRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetRegainhpMakeRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetRegainhpMakeRatio");

	Params::LCommonConstantValues_GetRegainhpMakeRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetResetItemSlotPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCommonConstantValues::GetResetItemSlotPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetResetItemSlotPosition");

	Params::LCommonConstantValues_GetResetItemSlotPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetResurrection_Abnormal_Code_Name
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetResurrection_Abnormal_Code_Name()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetResurrection_Abnormal_Code_Name");

	Params::LCommonConstantValues_GetResurrection_Abnormal_Code_Name Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSellingPriceRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSellingPriceRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSellingPriceRatio");

	Params::LCommonConstantValues_GetSellingPriceRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSequenceHotelBICodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetSequenceHotelBICodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSequenceHotelBICodeName");

	Params::LCommonConstantValues_GetSequenceHotelBICodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessBadAttackMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessBadAttackMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessBadAttackMod");

	Params::LCommonConstantValues_GetSharpnessBadAttackMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessBadDestructionMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessBadDestructionMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessBadDestructionMod");

	Params::LCommonConstantValues_GetSharpnessBadDestructionMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessBrokenAttackMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessBrokenAttackMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessBrokenAttackMod");

	Params::LCommonConstantValues_GetSharpnessBrokenAttackMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessBrokenDestructionMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessBrokenDestructionMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessBrokenDestructionMod");

	Params::LCommonConstantValues_GetSharpnessBrokenDestructionMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessFineAttackMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessFineAttackMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessFineAttackMod");

	Params::LCommonConstantValues_GetSharpnessFineAttackMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessFineDestructionMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessFineDestructionMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessFineDestructionMod");

	Params::LCommonConstantValues_GetSharpnessFineDestructionMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessNormalAttackMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessNormalAttackMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessNormalAttackMod");

	Params::LCommonConstantValues_GetSharpnessNormalAttackMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessNormalDestructionMod
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessNormalDestructionMod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessNormalDestructionMod");

	Params::LCommonConstantValues_GetSharpnessNormalDestructionMod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSharpnessReduceValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSharpnessReduceValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSharpnessReduceValue");

	Params::LCommonConstantValues_GetSharpnessReduceValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetShopPurchaseLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetShopPurchaseLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetShopPurchaseLimit");

	Params::LCommonConstantValues_GetShopPurchaseLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSkillHitDefenceExponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetSkillHitDefenceExponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSkillHitDefenceExponent");

	Params::LCommonConstantValues_GetSkillHitDefenceExponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSlavearmItemAlterUseType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetSlavearmItemAlterUseType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSlavearmItemAlterUseType");

	Params::LCommonConstantValues_GetSlavearmItemAlterUseType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSlaveArmReinforcementResetItemCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetSlaveArmReinforcementResetItemCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSlaveArmReinforcementResetItemCodeName");

	Params::LCommonConstantValues_GetSlaveArmReinforcementResetItemCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSlaveArmReinforcementResetItemNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSlaveArmReinforcementResetItemNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSlaveArmReinforcementResetItemNum");

	Params::LCommonConstantValues_GetSlaveArmReinforcementResetItemNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSprintExhaustTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSprintExhaustTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSprintExhaustTime");

	Params::LCommonConstantValues_GetSprintExhaustTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSprintSpeedRatioMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSprintSpeedRatioMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSprintSpeedRatioMax");

	Params::LCommonConstantValues_GetSprintSpeedRatioMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSprintSpeedRatioMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSprintSpeedRatioMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSprintSpeedRatioMin");

	Params::LCommonConstantValues_GetSprintSpeedRatioMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStaminaConsumeRatioExponentOver
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetStaminaConsumeRatioExponentOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStaminaConsumeRatioExponentOver");

	Params::LCommonConstantValues_GetStaminaConsumeRatioExponentOver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStaminaConsumeRatioExponentUnder
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetStaminaConsumeRatioExponentUnder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStaminaConsumeRatioExponentUnder");

	Params::LCommonConstantValues_GetStaminaConsumeRatioExponentUnder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStealthAbnormalCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetStealthAbnormalCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStealthAbnormalCodeName");

	Params::LCommonConstantValues_GetStealthAbnormalCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStealthImmediatelyAbnormalCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetStealthImmediatelyAbnormalCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStealthImmediatelyAbnormalCodeName");

	Params::LCommonConstantValues_GetStealthImmediatelyAbnormalCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStealthTotallyImmediatelyAbnormalCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetStealthTotallyImmediatelyAbnormalCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStealthTotallyImmediatelyAbnormalCodeName");

	Params::LCommonConstantValues_GetStealthTotallyImmediatelyAbnormalCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStorageMaxSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetStorageMaxSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStorageMaxSlot");

	Params::LCommonConstantValues_GetStorageMaxSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetStorageRequirementsSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetStorageRequirementsSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetStorageRequirementsSlot");

	Params::LCommonConstantValues_GetStorageRequirementsSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetSwapNPCDefaultHPRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetSwapNPCDefaultHPRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetSwapNPCDefaultHPRate");

	Params::LCommonConstantValues_GetSwapNPCDefaultHPRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTalkerDialogRotateTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetTalkerDialogRotateTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTalkerDialogRotateTime");

	Params::LCommonConstantValues_GetTalkerDialogRotateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTalkerTurnLAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTalkerTurnLAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTalkerTurnLAnim");

	Params::LCommonConstantValues_GetTalkerTurnLAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTalkerTurnRAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTalkerTurnRAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTalkerTurnRAnim");

	Params::LCommonConstantValues_GetTalkerTurnRAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTeleporStartSequenceCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTeleporStartSequenceCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTeleporStartSequenceCodeName");

	Params::LCommonConstantValues_GetTeleporStartSequenceCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTeleportEndSequenceCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTeleportEndSequenceCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTeleportEndSequenceCodeName");

	Params::LCommonConstantValues_GetTeleportEndSequenceCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTeleportObjectForNGPDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTeleportObjectForNGPDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTeleportObjectForNGPDelay");

	Params::LCommonConstantValues_GetTeleportObjectForNGPDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTeleportObjectForNGPStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTeleportObjectForNGPStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTeleportObjectForNGPStart");

	Params::LCommonConstantValues_GetTeleportObjectForNGPStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTorsionCoilSetFullSlaveMagazine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCommonConstantValues::GetTorsionCoilSetFullSlaveMagazine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTorsionCoilSetFullSlaveMagazine");

	Params::LCommonConstantValues_GetTorsionCoilSetFullSlaveMagazine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTungsten2setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTungsten2setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTungsten2setAbnormalState");

	Params::LCommonConstantValues_GetTungsten2setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTungsten3setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetTungsten3setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTungsten3setAbnormalState");

	Params::LCommonConstantValues_GetTungsten3setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTutorialPendingLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetTutorialPendingLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTutorialPendingLimit");

	Params::LCommonConstantValues_GetTutorialPendingLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTutorialPendingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetTutorialPendingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTutorialPendingTime");

	Params::LCommonConstantValues_GetTutorialPendingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetTutorialPriorityPendingMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetTutorialPriorityPendingMaxCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetTutorialPriorityPendingMaxCount");

	Params::LCommonConstantValues_GetTutorialPriorityPendingMaxCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetUniqueGrinderMainItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetUniqueGrinderMainItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetUniqueGrinderMainItem");

	Params::LCommonConstantValues_GetUniqueGrinderMainItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetUranium2setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetUranium2setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetUranium2setAbnormalState");

	Params::LCommonConstantValues_GetUranium2setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetUranium3setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetUranium3setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetUranium3setAbnormalState");

	Params::LCommonConstantValues_GetUranium3setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetVibranium2setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetVibranium2setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetVibranium2setAbnormalState");

	Params::LCommonConstantValues_GetVibranium2setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetVibranium3setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetVibranium3setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetVibranium3setAbnormalState");

	Params::LCommonConstantValues_GetVibranium3setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetWalkRunSpeedRatioMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetWalkRunSpeedRatioMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetWalkRunSpeedRatioMax");

	Params::LCommonConstantValues_GetWalkRunSpeedRatioMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetWalkRunSpeedRatioMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetWalkRunSpeedRatioMin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetWalkRunSpeedRatioMin");

	Params::LCommonConstantValues_GetWalkRunSpeedRatioMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetWeaponPhysicalAttackpowerFatalWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCommonConstantValues::GetWeaponPhysicalAttackpowerFatalWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetWeaponPhysicalAttackpowerFatalWeight");

	Params::LCommonConstantValues_GetWeaponPhysicalAttackpowerFatalWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetWeightLimitOverAllowRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULCommonConstantValues::GetWeightLimitOverAllowRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetWeightLimitOverAllowRatio");

	Params::LCommonConstantValues_GetWeightLimitOverAllowRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetWood2setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetWood2setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetWood2setAbnormalState");

	Params::LCommonConstantValues_GetWood2setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCommonConstantValues.GetWood3setAbnormalState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULCommonConstantValues::GetWood3setAbnormalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCommonConstantValues", "GetWood3setAbnormalState");

	Params::LCommonConstantValues_GetWood3setAbnormalState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectDataDB.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULObjectDataDB::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectDataDB", "OnGameDataCharacterSync");

	Params::LObjectDataDB_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.AddPlayedRecord
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             RecordName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::AddPlayedRecord(const class FName& RecordName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "AddPlayedRecord");

	Params::LGameDataSystem_AddPlayedRecord Parms{};

	Parms.RecordName = RecordName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.ApplyActivity
// (Final, Native, Public, BlueprintCallable)

void ULGameDataSystem::ApplyActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "ApplyActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.CalcTeleportList
// (Final, Native, Public, BlueprintCallable)

void ULGameDataSystem::CalcTeleportList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "CalcTeleportList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.CheckAutoSave
// (Final, Native, Protected)

void ULGameDataSystem::CheckAutoSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "CheckAutoSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.ContinueCharacterStorageData
// (Final, Native, Public, BlueprintCallable)

void ULGameDataSystem::ContinueCharacterStorageData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "ContinueCharacterStorageData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.DeleteCharacterStorageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           DeleteName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::DeleteCharacterStorageData(const class FString& DeleteName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "DeleteCharacterStorageData");

	Params::LGameDataSystem_DeleteCharacterStorageData Parms{};

	Parms.DeleteName = std::move(DeleteName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.GetAccountEULAVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetAccountEULAVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetAccountEULAVersion");

	Params::LGameDataSystem_GetAccountEULAVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetActivityIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetActivityIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetActivityIndex");

	Params::LGameDataSystem_GetActivityIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCategoryList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> ULGameDataSystem::GetCategoryList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCategoryList");

	Params::LGameDataSystem_GetCategoryList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCharacterLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetCharacterLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCharacterLevel");

	Params::LGameDataSystem_GetCharacterLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetCharacterName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCharacterName");

	Params::LGameDataSystem_GetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCharacterStoragePlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           FindName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetCharacterStoragePlayTime(const class FString& FindName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCharacterStoragePlayTime");

	Params::LGameDataSystem_GetCharacterStoragePlayTime Parms{};

	Parms.FindName = std::move(FindName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCharacterStorageSaveDateTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        InDateTime                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetCharacterStorageSaveDateTime(const struct FDateTime& InDateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCharacterStorageSaveDateTime");

	Params::LGameDataSystem_GetCharacterStorageSaveDateTime Parms{};

	Parms.InDateTime = std::move(InDateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetConstantValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULCommonConstantValues*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULCommonConstantValues* ULGameDataSystem::GetConstantValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetConstantValues");

	Params::LGameDataSystem_GetConstantValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCurrentErgo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetCurrentErgo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCurrentErgo");

	Params::LGameDataSystem_GetCurrentErgo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCurrentHotelTosionCoil
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGameDataSystem::GetCurrentHotelTosionCoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCurrentHotelTosionCoil");

	Params::LGameDataSystem_GetCurrentHotelTosionCoil Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCurrentHumanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetCurrentHumanity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCurrentHumanity");

	Params::LGameDataSystem_GetCurrentHumanity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetCurrentNewGamePlus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetCurrentNewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetCurrentNewGamePlus");

	Params::LGameDataSystem_GetCurrentNewGamePlus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetDepartureTeleportObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGameDataSystem::GetDepartureTeleportObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetDepartureTeleportObject");

	Params::LGameDataSystem_GetDepartureTeleportObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetDropErgo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetDropErgo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetDropErgo");

	Params::LGameDataSystem_GetDropErgo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetEULAVersion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetEULAVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetEULAVersion");

	Params::LGameDataSystem_GetEULAVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetForceStartChapter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetForceStartChapter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetForceStartChapter");

	Params::LGameDataSystem_GetForceStartChapter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetGlobalVariableData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InCodeName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetGlobalVariableData(const class FName& InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetGlobalVariableData");

	Params::LGameDataSystem_GetGlobalVariableData Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetHairCategoryType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELHairCategoryType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELHairCategoryType ULGameDataSystem::GetHairCategoryType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetHairCategoryType");

	Params::LGameDataSystem_GetHairCategoryType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetHumanityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetHumanityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetHumanityLevel");

	Params::LGameDataSystem_GetHumanityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetHumanityRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGameDataSystem::GetHumanityRatio()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetHumanityRatio");

	Params::LGameDataSystem_GetHumanityRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetLatestTorsionCoil
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGameDataSystem::GetLatestTorsionCoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetLatestTorsionCoil");

	Params::LGameDataSystem_GetLatestTorsionCoil Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetLevelUpRequireErgo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CheckLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetLevelUpRequireErgo(int32 CheckLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetLevelUpRequireErgo");

	Params::LGameDataSystem_GetLevelUpRequireErgo Parms{};

	Parms.CheckLevel = CheckLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetMaxLevelUpCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RemainSoul                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetMaxLevelUpCount(int32 PlayerLevel, int32 RemainSoul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetMaxLevelUpCount");

	Params::LGameDataSystem_GetMaxLevelUpCount Parms{};

	Parms.PlayerLevel = PlayerLevel;
	Parms.RemainSoul = RemainSoul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetNewGamePlusProcess
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::GetNewGamePlusProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetNewGamePlusProcess");

	Params::LGameDataSystem_GetNewGamePlusProcess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetNextLevelUpRequireSoul
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetNextLevelUpRequireSoul()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetNextLevelUpRequireSoul");

	Params::LGameDataSystem_GetNextLevelUpRequireSoul Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetPlayerTeleportTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSpawnTransformType                    OutSpawnTransformType                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ULGameDataSystem::GetPlayerTeleportTransform(ELSpawnTransformType* OutSpawnTransformType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetPlayerTeleportTransform");

	Params::LGameDataSystem_GetPlayerTeleportTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnTransformType != nullptr)
		*OutSpawnTransformType = Parms.OutSpawnTransformType;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetRaxasiaShieldBroken
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::GetRaxasiaShieldBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetRaxasiaShieldBroken");

	Params::LGameDataSystem_GetRaxasiaShieldBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetRemainSoul
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurSoul                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LevelUpCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetRemainSoul(int32 CurLevel, int32 CurSoul, int32 LevelUpCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetRemainSoul");

	Params::LGameDataSystem_GetRemainSoul Parms{};

	Parms.CurLevel = CurLevel;
	Parms.CurSoul = CurSoul;
	Parms.LevelUpCount = LevelUpCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetSaveData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FLCharacterStorageData>   OutCharacterList                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::GetSaveData(TArray<struct FLCharacterStorageData>* OutCharacterList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetSaveData");

	Params::LGameDataSystem_GetSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCharacterList != nullptr)
		*OutCharacterList = std::move(Parms.OutCharacterList);

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetTeleportList
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CategoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLTeleportLocation>       OutTeleportLocationList                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::GetTeleportList(int32 CategoryIndex, TArray<struct FLTeleportLocation>* OutTeleportLocationList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetTeleportList");

	Params::LGameDataSystem_GetTeleportList Parms{};

	Parms.CategoryIndex = CategoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTeleportLocationList != nullptr)
		*OutTeleportLocationList = std::move(Parms.OutTeleportLocationList);

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetWeatherCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULGameDataSystem::GetWeatherCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetWeatherCodeName");

	Params::LGameDataSystem_GetWeatherCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsHiddenConditionTeleportToHotel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsHiddenConditionTeleportToHotel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsHiddenConditionTeleportToHotel");

	Params::LGameDataSystem_IsHiddenConditionTeleportToHotel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsLastPlayCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           FindName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsLastPlayCharacter(const class FString& FindName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsLastPlayCharacter");

	Params::LGameDataSystem_IsLastPlayCharacter Parms{};

	Parms.FindName = std::move(FindName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsNormalShutDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsNormalShutDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsNormalShutDown");

	Params::LGameDataSystem_IsNormalShutDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsPlayingNewGamePlusProcess
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsPlayingNewGamePlusProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsPlayingNewGamePlusProcess");

	Params::LGameDataSystem_IsPlayingNewGamePlusProcess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsPossibleTeleportToHotel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsPossibleTeleportToHotel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsPossibleTeleportToHotel");

	Params::LGameDataSystem_IsPossibleTeleportToHotel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsValidLastPlayCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsValidLastPlayCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsValidLastPlayCharacter");

	Params::LGameDataSystem_IsValidLastPlayCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsValidStarterPackContinueCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsValidStarterPackContinueCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsValidStarterPackContinueCharacter");

	Params::LGameDataSystem_IsValidStarterPackContinueCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsValidStarterPackSelectCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SelectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsValidStarterPackSelectCharacter(const class FString& SelectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsValidStarterPackSelectCharacter");

	Params::LGameDataSystem_IsValidStarterPackSelectCharacter Parms{};

	Parms.SelectName = std::move(SelectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.IsValidTeleportTransformByType
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ELSpawnTransformType                    FindType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::IsValidTeleportTransformByType(ELSpawnTransformType FindType, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "IsValidTeleportTransformByType");

	Params::LGameDataSystem_IsValidTeleportTransformByType Parms{};

	Parms.FindType = FindType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.LoadContinueCharacterStorageData
// (Final, Native, Public, BlueprintCallable)

void ULGameDataSystem::LoadContinueCharacterStorageData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "LoadContinueCharacterStorageData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.LoadSelectCharacterStorageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SelectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::LoadSelectCharacterStorageData(const class FString& SelectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "LoadSelectCharacterStorageData");

	Params::LGameDataSystem_LoadSelectCharacterStorageData Parms{};

	Parms.SelectName = std::move(SelectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.NewCharacterStorageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StartChapter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::NewCharacterStorageData(int32 StartChapter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "NewCharacterStorageData");

	Params::LGameDataSystem_NewCharacterStorageData Parms{};

	Parms.StartChapter = StartChapter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.NewGamePlusToPlayStart
// (Final, Native, Public)

void ULGameDataSystem::NewGamePlusToPlayStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "NewGamePlusToPlayStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.ObjDataDB
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULObjectDataDB*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULObjectDataDB* ULGameDataSystem::ObjDataDB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "ObjDataDB");

	Params::LGameDataSystem_ObjDataDB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.OnClosedStargazerDialog
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::OnClosedStargazerDialog(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "OnClosedStargazerDialog");

	Params::LGameDataSystem_OnClosedStargazerDialog Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.OnLoadGameDataInGame
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSaveGame*                       SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::OnLoadGameDataInGame(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "OnLoadGameDataInGame");

	Params::LGameDataSystem_OnLoadGameDataInGame Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.OnLoadGameDataLobby
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSaveGame*                       SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::OnLoadGameDataLobby(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "OnLoadGameDataLobby");

	Params::LGameDataSystem_OnLoadGameDataLobby Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.OnResultEULA
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InAgree                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::OnResultEULA(bool InAgree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "OnResultEULA");

	Params::LGameDataSystem_OnResultEULA Parms{};

	Parms.InAgree = InAgree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.OnSaveGameDataInGame
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::OnSaveGameDataInGame(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "OnSaveGameDataInGame");

	Params::LGameDataSystem_OnSaveGameDataInGame Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.OnSaveGameDataLobby
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::OnSaveGameDataLobby(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "OnSaveGameDataLobby");

	Params::LGameDataSystem_OnSaveGameDataLobby Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.ResetActivityIndex
// (Final, Native, Public, BlueprintCallable)

void ULGameDataSystem::ResetActivityIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "ResetActivityIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.RestoreCharacterStorageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StartChapter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::RestoreCharacterStorageData(int32 StartChapter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "RestoreCharacterStorageData");

	Params::LGameDataSystem_RestoreCharacterStorageData Parms{};

	Parms.StartChapter = StartChapter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.SaveGameDataFromUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsAsyncSave                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NormalShutDown                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::SaveGameDataFromUI(bool IsAsyncSave, bool NormalShutDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "SaveGameDataFromUI");

	Params::LGameDataSystem_SaveGameDataFromUI Parms{};

	Parms.IsAsyncSave = IsAsyncSave;
	Parms.NormalShutDown = NormalShutDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.SelectCharacterStorageData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SelectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::SelectCharacterStorageData(const class FString& SelectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "SelectCharacterStorageData");

	Params::LGameDataSystem_SelectCharacterStorageData Parms{};

	Parms.SelectName = std::move(SelectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.SetActivityIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InActivityIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::SetActivityIndex(int32 InActivityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "SetActivityIndex");

	Params::LGameDataSystem_SetActivityIndex Parms{};

	Parms.InActivityIndex = InActivityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.SetPlayerSpawnFailedMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InMessage                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameDataSystem::SetPlayerSpawnFailedMessage(const class FString& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "SetPlayerSpawnFailedMessage");

	Params::LGameDataSystem_SetPlayerSpawnFailedMessage Parms{};

	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameDataSystem.GetAccountOpenedRecollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::GetAccountOpenedRecollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetAccountOpenedRecollection");

	Params::LGameDataSystem_GetAccountOpenedRecollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetAccountPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetAccountPlayTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetAccountPlayTime");

	Params::LGameDataSystem_GetAccountPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetAccountShowEndingCredit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameDataSystem::GetAccountShowEndingCredit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetAccountShowEndingCredit");

	Params::LGameDataSystem_GetAccountShowEndingCredit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetDeathCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetDeathCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetDeathCount");

	Params::LGameDataSystem_GetDeathCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGameDataSystem::GetPlayTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetPlayTime");

	Params::LGameDataSystem_GetPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameDataSystem.GetReceiveDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGameDataSystem::GetReceiveDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameDataSystem", "GetReceiveDamage");

	Params::LGameDataSystem_GetReceiveDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.ApplyControllerDeadZoneMultiply
// (Final, Native, Public)
// Parameters:
// bool                                    InLeftStick                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGamePadOption::ApplyControllerDeadZoneMultiply(bool InLeftStick, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "ApplyControllerDeadZoneMultiply");

	Params::LGamePadOption_ApplyControllerDeadZoneMultiply Parms{};

	Parms.InLeftStick = InLeftStick;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGamePadOption.ApplyControllerForceFeedbackMultiply
// (Final, Native, Public)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGamePadOption::ApplyControllerForceFeedbackMultiply(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "ApplyControllerForceFeedbackMultiply");

	Params::LGamePadOption_ApplyControllerForceFeedbackMultiply Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGamePadOption.GetDeadZoneStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    LeftStick                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGamePadOption::GetDeadZoneStep(bool LeftStick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "GetDeadZoneStep");

	Params::LGamePadOption_GetDeadZoneStep Parms{};

	Parms.LeftStick = LeftStick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.GetForceFeedbackStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGamePadOption::GetForceFeedbackStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "GetForceFeedbackStep");

	Params::LGamePadOption_GetForceFeedbackStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.GetMoveSpeedStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGamePadOption::GetMoveSpeedStep(ECameraDirectOption InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "GetMoveSpeedStep");

	Params::LGamePadOption_GetMoveSpeedStep Parms{};

	Parms.InRotator = InRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.IsInvertMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGamePadOption::IsInvertMove(ECameraDirectOption InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "IsInvertMove");

	Params::LGamePadOption_IsInvertMove Parms{};

	Parms.InRotator = InRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.ResetEditedInputAction
// (Final, Native, Public, BlueprintCallable)

void ULGamePadOption::ResetEditedInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "ResetEditedInputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGamePadOption.SetDeadZoneStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    LeftStick                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGamePadOption::SetDeadZoneStep(bool LeftStick, int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "SetDeadZoneStep");

	Params::LGamePadOption_SetDeadZoneStep Parms{};

	Parms.LeftStick = LeftStick;
	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.SetForceFeedbackStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGamePadOption::SetForceFeedbackStep(int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "SetForceFeedbackStep");

	Params::LGamePadOption_SetForceFeedbackStep Parms{};

	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.SetInvertMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGamePadOption::SetInvertMove(ECameraDirectOption InRotator, bool InInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "SetInvertMove");

	Params::LGamePadOption_SetInvertMove Parms{};

	Parms.InRotator = InRotator;
	Parms.InInvert = InInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGamePadOption.SetMoveSpeedStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGamePadOption::SetMoveSpeedStep(ECameraDirectOption InRotator, int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGamePadOption", "SetMoveSpeedStep");

	Params::LGamePadOption_SetMoveSpeedStep Parms{};

	Parms.InRotator = InRotator;
	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameInstance.ActiveGameSystemForTest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELGameSubSystemActiveType               ActiveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameInstance::ActiveGameSystemForTest(ELGameSubSystemActiveType ActiveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameInstance", "ActiveGameSystemForTest");

	Params::LGameInstance_ActiveGameSystemForTest Parms{};

	Parms.ActiveType = ActiveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameInstance.ExecBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Cmd                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameInstance::ExecBP(class UWorld* InWorld, const class FString& Cmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "ExecBP");

	Params::LGameInstance_ExecBP Parms{};

	Parms.InWorld = InWorld;
	Parms.Cmd = std::move(Cmd);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LGameInstance.GetEmptyPulseGauge
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   EmptyPulseCount                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EmptyPulseGauge_Current                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EmptyPulseGauge_Max                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EmptyPulseGauge_DefatltMax                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameInstance::GetEmptyPulseGauge(int32* EmptyPulseCount, int32* EmptyPulseGauge_Current, int32* EmptyPulseGauge_Max, int32* EmptyPulseGauge_DefatltMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "GetEmptyPulseGauge");

	Params::LGameInstance_GetEmptyPulseGauge Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EmptyPulseCount != nullptr)
		*EmptyPulseCount = Parms.EmptyPulseCount;

	if (EmptyPulseGauge_Current != nullptr)
		*EmptyPulseGauge_Current = Parms.EmptyPulseGauge_Current;

	if (EmptyPulseGauge_Max != nullptr)
		*EmptyPulseGauge_Max = Parms.EmptyPulseGauge_Max;

	if (EmptyPulseGauge_DefatltMax != nullptr)
		*EmptyPulseGauge_DefatltMax = Parms.EmptyPulseGauge_DefatltMax;
}


// Function ProjectP.LGameInstance.GetGameState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPNGameState                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPNGameState ULGameInstance::GetGameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "GetGameState");

	Params::LGameInstance_GetGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameInstance.IsPlayState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameInstance::IsPlayState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "IsPlayState");

	Params::LGameInstance_IsPlayState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameInstance.MainProcess_PlayExit
// (Final, Native, Public)

void ULGameInstance::MainProcess_PlayExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "MainProcess_PlayExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameInstance.MainProcess_PlayStart
// (Final, Native, Public)

void ULGameInstance::MainProcess_PlayStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "MainProcess_PlayStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameInstance.MainProcess_StartInstance
// (Final, Native, Public)

void ULGameInstance::MainProcess_StartInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "MainProcess_StartInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameInstance.MakeNewCharacterBP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEditor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameInstance::MakeNewCharacterBP(bool bInEditor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "MakeNewCharacterBP");

	Params::LGameInstance_MakeNewCharacterBP Parms{};

	Parms.bInEditor = bInEditor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LGameInstance.OnChangeGameState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPNGameState                            InGameState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExecuteInGameMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameInstance::OnChangeGameState(EPNGameState InGameState, bool ExecuteInGameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "OnChangeGameState");

	Params::LGameInstance_OnChangeGameState Parms{};

	Parms.InGameState = InGameState;
	Parms.ExecuteInGameMode = ExecuteInGameMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameInstance.OnEndAsyncPreLoadScene
// (Final, Native, Public, BlueprintCallable)

void ULGameInstance::OnEndAsyncPreLoadScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameInstance", "OnEndAsyncPreLoadScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LGameModeBase.ChangeGameState
// (Event, Protected, BlueprintEvent)

void ALGameModeBase::ChangeGameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGameModeBase", "ChangeGameState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LItemDropSystemData.SpawnDropErgoData
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FLDropErgoData                   DropErgoData                                           (Parm, NativeAccessSpecifierPublic)

void ALItemDropSystemData::SpawnDropErgoData(const struct FLDropErgoData& DropErgoData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemDropSystemData", "SpawnDropErgoData");

	Params::LItemDropSystemData_SpawnDropErgoData Parms{};

	Parms.DropErgoData = std::move(DropErgoData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LGameSettings.CanHotKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::CanHotKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "CanHotKey");

	Params::LGameSettings_CanHotKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.CanPreload
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELPreloadUsage                          Usage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::CanPreload(ELPreloadUsage Usage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "CanPreload");

	Params::LGameSettings_CanPreload Parms{};

	Parms.Usage = Usage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.CheckGameCommand
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELGameCommandCategory                   CommandCategory                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::CheckGameCommand(ELGameCommandCategory CommandCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "CheckGameCommand");

	Params::LGameSettings_CheckGameCommand Parms{};

	Parms.CommandCategory = CommandCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsBoostAI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsBoostAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsBoostAI");

	Params::LGameSettings_IsBoostAI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsEasyMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsEasyMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsEasyMode");

	Params::LGameSettings_IsEasyMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsEnableActivationSystemV2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsEnableActivationSystemV2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsEnableActivationSystemV2");

	Params::LGameSettings_IsEnableActivationSystemV2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsGameDayBuild
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsGameDayBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsGameDayBuild");

	Params::LGameSettings_IsGameDayBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsNeowizAuth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsNeowizAuth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsNeowizAuth");

	Params::LGameSettings_IsNeowizAuth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsUseActionGroupBuildData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsUseActionGroupBuildData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsUseActionGroupBuildData");

	Params::LGameSettings_IsUseActionGroupBuildData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.IsUseLevelStreaming
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGameSettings::IsUseLevelStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "IsUseLevelStreaming");

	Params::LGameSettings_IsUseLevelStreaming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGameSettings.SetEasyModeEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULGameSettings::SetEasyModeEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LGameSettings", "SetEasyModeEnabled");

	Params::LGameSettings_SetEasyModeEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInputCommand.InputCommand_AssistUseItemDown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_AssistUseItemDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_AssistUseItemDown");

	Params::LInputCommand_InputCommand_AssistUseItemDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_AssistUseItemLeft
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_AssistUseItemLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_AssistUseItemLeft");

	Params::LInputCommand_InputCommand_AssistUseItemLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_AssistUseItemRight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_AssistUseItemRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_AssistUseItemRight");

	Params::LInputCommand_InputCommand_AssistUseItemRight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_AssistUseItemUp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_AssistUseItemUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_AssistUseItemUp");

	Params::LInputCommand_InputCommand_AssistUseItemUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_ChargeCancel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_ChargeCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_ChargeCancel");

	Params::LInputCommand_InputCommand_ChargeCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_Dash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_Dash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_Dash");

	Params::LInputCommand_InputCommand_Dash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_DirectLockOnDash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_DirectLockOnDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_DirectLockOnDash");

	Params::LInputCommand_InputCommand_DirectLockOnDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_DisableSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_DisableSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_DisableSprint");

	Params::LInputCommand_InputCommand_DisableSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_EnableSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_EnableSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_EnableSprint");

	Params::LInputCommand_InputCommand_EnableSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_FableHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_FableHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_FableHandle");

	Params::LInputCommand_InputCommand_FableHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_FableHandle_OnGuardHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_FableHandle_OnGuardHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_FableHandle_OnGuardHit");

	Params::LInputCommand_InputCommand_FableHandle_OnGuardHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_Frenzy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_Frenzy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_Frenzy");

	Params::LInputCommand_InputCommand_Frenzy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_FrenzyRelease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_FrenzyRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_FrenzyRelease");

	Params::LInputCommand_InputCommand_FrenzyRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_Guard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_Guard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_Guard");

	Params::LInputCommand_InputCommand_Guard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_GuardEnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_GuardEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_GuardEnd");

	Params::LInputCommand_InputCommand_GuardEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_LightAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_LightAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_LightAttack");

	Params::LInputCommand_InputCommand_LightAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_None
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_None()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_None");

	Params::LInputCommand_InputCommand_None Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_ObjectInteraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_ObjectInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_ObjectInteraction");

	Params::LInputCommand_InputCommand_ObjectInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_ParryDash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_ParryDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_ParryDash");

	Params::LInputCommand_InputCommand_ParryDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_ParryGuard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_ParryGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_ParryGuard");

	Params::LInputCommand_InputCommand_ParryGuard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_Parrying
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_Parrying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_Parrying");

	Params::LInputCommand_InputCommand_Parrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_SlaveArmPress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_SlaveArmPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_SlaveArmPress");

	Params::LInputCommand_InputCommand_SlaveArmPress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_SlaveArmRelease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_SlaveArmRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_SlaveArmRelease");

	Params::LInputCommand_InputCommand_SlaveArmRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_StartSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_StartSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_StartSprint");

	Params::LInputCommand_InputCommand_StartSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_StartTurning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_StartTurning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_StartTurning");

	Params::LInputCommand_InputCommand_StartTurning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_StopRunning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_StopRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_StopRunning");

	Params::LInputCommand_InputCommand_StopRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_StopSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_StopSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_StopSprint");

	Params::LInputCommand_InputCommand_StopSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_StopTurning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_StopTurning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_StopTurning");

	Params::LInputCommand_InputCommand_StopTurning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_StrongAttack
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_StrongAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_StrongAttack");

	Params::LInputCommand_InputCommand_StrongAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_ToggleWalkMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_ToggleWalkMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_ToggleWalkMode");

	Params::LInputCommand_InputCommand_ToggleWalkMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_TurnSprint
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_TurnSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_TurnSprint");

	Params::LInputCommand_InputCommand_TurnSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_UseItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_UseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_UseItem");

	Params::LInputCommand_InputCommand_UseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_WeaponChange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_WeaponChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_WeaponChange");

	Params::LInputCommand_InputCommand_WeaponChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInputCommand.InputCommand_WeaponChangePrevious
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULInputCommand::InputCommand_WeaponChangePrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LInputCommand", "InputCommand_WeaponChangePrevious");

	Params::LInputCommand_InputCommand_WeaponChangePrevious Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetCurrentLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULPlayOption::GetCurrentLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetCurrentLanguage");

	Params::LPlayOption_GetCurrentLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetEnableTutorialPopup
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::GetEnableTutorialPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetEnableTutorialPopup");

	Params::LPlayOption_GetEnableTutorialPopup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetHUDVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELHUDVisible                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELHUDVisible ULPlayOption::GetHUDVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetHUDVisibility");

	Params::LPlayOption_GetHUDVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetLanguageStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayOption::GetLanguageStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetLanguageStep");

	Params::LPlayOption_GetLanguageStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetLockOnImportanceWeightMultiply
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayOption::GetLockOnImportanceWeightMultiply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetLockOnImportanceWeightMultiply");

	Params::LPlayOption_GetLockOnImportanceWeightMultiply Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetSelectableLanguages
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ULPlayOption::GetSelectableLanguages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetSelectableLanguages");

	Params::LPlayOption_GetSelectableLanguages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetSubtitleSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayOption::GetSubtitleSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetSubtitleSize");

	Params::LPlayOption_GetSubtitleSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetUseAutoNewTargetLockOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::GetUseAutoNewTargetLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetUseAutoNewTargetLockOn");

	Params::LPlayOption_GetUseAutoNewTargetLockOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.GetUseAutoTargeting
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::GetUseAutoTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "GetUseAutoTargeting");

	Params::LPlayOption_GetUseAutoTargeting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.IsBloodExpressionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::IsBloodExpressionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "IsBloodExpressionEnabled");

	Params::LPlayOption_IsBloodExpressionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.IsDirectLockOnDash
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::IsDirectLockOnDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "IsDirectLockOnDash");

	Params::LPlayOption_IsDirectLockOnDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.IsMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::IsMotionBlurEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "IsMotionBlurEnabled");

	Params::LPlayOption_IsMotionBlurEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.IsVideoSubtitleEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::IsVideoSubtitleEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "IsVideoSubtitleEnabled");

	Params::LPlayOption_IsVideoSubtitleEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetDirectLockOnDash
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    TurnOn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetDirectLockOnDash(bool TurnOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetDirectLockOnDash");

	Params::LPlayOption_SetDirectLockOnDash Parms{};

	Parms.TurnOn = TurnOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetEnableBloodExpression
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetEnableBloodExpression(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetEnableBloodExpression");

	Params::LPlayOption_SetEnableBloodExpression Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetEnableTutorialPopup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetEnableTutorialPopup(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetEnableTutorialPopup");

	Params::LPlayOption_SetEnableTutorialPopup Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetEnableVideoSubtitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetEnableVideoSubtitle(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetEnableVideoSubtitle");

	Params::LPlayOption_SetEnableVideoSubtitle Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetHUDVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELHUDVisible                            InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetHUDVisibility(ELHUDVisible InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetHUDVisibility");

	Params::LPlayOption_SetHUDVisibility Parms{};

	Parms.InVisible = InVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetLanguageStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetLanguageStep(int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetLanguageStep");

	Params::LPlayOption_SetLanguageStep Parms{};

	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetLockOnImportanceWeightMultiply
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetLockOnImportanceWeightMultiply(int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetLockOnImportanceWeightMultiply");

	Params::LPlayOption_SetLockOnImportanceWeightMultiply Parms{};

	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetMotionBlurEnabled(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetMotionBlurEnabled");

	Params::LPlayOption_SetMotionBlurEnabled Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetSubtitleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSubtitleSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetSubtitleSize(int32 InSubtitleSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetSubtitleSize");

	Params::LPlayOption_SetSubtitleSize Parms{};

	Parms.InSubtitleSize = InSubtitleSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetUseAutoNewTargetLockOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InAuto                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetUseAutoNewTargetLockOn(bool InAuto)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetUseAutoNewTargetLockOn");

	Params::LPlayOption_SetUseAutoNewTargetLockOn Parms{};

	Parms.InAuto = InAuto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayOption.SetUseAutoTargeting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayOption::SetUseAutoTargeting(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayOption", "SetUseAutoTargeting");

	Params::LPlayOption_SetUseAutoTargeting Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLockOnTargetComponent.DisableLockOn
// (Final, Native, Public, BlueprintCallable)

void ULLockOnTargetComponent::DisableLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnTargetComponent", "DisableLockOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLockOnTargetComponent.EnableLockOn
// (Final, Native, Public, BlueprintCallable)

void ULLockOnTargetComponent::EnableLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnTargetComponent", "EnableLockOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLockOnTargetComponent.IsLockOnEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLockOnTargetComponent::IsLockOnEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnTargetComponent", "IsLockOnEnabled");

	Params::LLockOnTargetComponent_IsLockOnEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCController.CanUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCController::CanUseItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "CanUseItem");

	Params::LPCController_CanUseItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCController.ChangeLockOnTargetOnKeyboard
// (Final, Native, Public, BlueprintCallable)

void ALPCController::ChangeLockOnTargetOnKeyboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "ChangeLockOnTargetOnKeyboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.DoLookUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAxisValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::DoLookUp(float InAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "DoLookUp");

	Params::LPCController_DoLookUp Parms{};

	Parms.InAxisValue = InAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.DoMoveForward
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAxisValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::DoMoveForward(float InAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "DoMoveForward");

	Params::LPCController_DoMoveForward Parms{};

	Parms.InAxisValue = InAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.DoMoveRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAxisValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::DoMoveRight(float InAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "DoMoveRight");

	Params::LPCController_DoMoveRight Parms{};

	Parms.InAxisValue = InAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.DoTargetLockOn
// (Final, Native, Public, BlueprintCallable)

void ALPCController::DoTargetLockOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "DoTargetLockOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.DoTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAxisValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::DoTurn(float InAxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "DoTurn");

	Params::LPCController_DoTurn Parms{};

	Parms.InAxisValue = InAxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.DoUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UseCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::DoUseItem(class ULItem* Item, int32 UseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "DoUseItem");

	Params::LPCController_DoUseItem Parms{};

	Parms.Item = Item;
	Parms.UseCount = UseCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.ExecuteInteractionEvent
// (Final, Native, Public, BlueprintCallable)

void ALPCController::ExecuteInteractionEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "ExecuteInteractionEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.IsInteractionLadder
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCController::IsInteractionLadder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "IsInteractionLadder");

	Params::LPCController_IsInteractionLadder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCController.IsInteractionMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCController::IsInteractionMotion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "IsInteractionMotion");

	Params::LPCController_IsInteractionMotion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCController.IsInteractionStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCController::IsInteractionStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "IsInteractionStatus");

	Params::LPCController_IsInteractionStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCController.OnControllerCommand
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Args                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALPCController::OnControllerCommand(const class FString& Command, const TArray<class FString>& Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "OnControllerCommand");

	Params::LPCController_OnControllerCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.Args = std::move(Args);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCController.OnRecvRespawnFromCharacterBP
// (Event, Public, BlueprintEvent)

void ALPCController::OnRecvRespawnFromCharacterBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "OnRecvRespawnFromCharacterBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPCController.ReceiveOnActionStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        StartedAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::ReceiveOnActionStarted(class ULActMgrComponent* InActMgrComponent, class ULActBase* StartedAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "ReceiveOnActionStarted");

	Params::LPCController_ReceiveOnActionStarted Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.StartedAction = StartedAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCController.ReceiveOnActionStopCalled
// (Event, Public, BlueprintEvent)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        StoppingAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::ReceiveOnActionStopCalled(class ULActMgrComponent* InActMgrComponent, class ULActBase* StoppingAction, class ULActBase* ReasonAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "ReceiveOnActionStopCalled");

	Params::LPCController_ReceiveOnActionStopCalled Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.StoppingAction = StoppingAction;
	Parms.ReasonAction = ReasonAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCController.SetAudioListenerPosition_AudioListenerPositionComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::SetAudioListenerPosition_AudioListenerPositionComponent(const struct FVector& Offset, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "SetAudioListenerPosition_AudioListenerPositionComponent");

	Params::LPCController_SetAudioListenerPosition_AudioListenerPositionComponent Parms{};

	Parms.Offset = std::move(Offset);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.SetAudioListenerPosition_Camera
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::SetAudioListenerPosition_Camera(const struct FVector& Offset, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "SetAudioListenerPosition_Camera");

	Params::LPCController_SetAudioListenerPosition_Camera Parms{};

	Parms.Offset = std::move(Offset);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.SetAudioListenerPosition_Character
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::SetAudioListenerPosition_Character(float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "SetAudioListenerPosition_Character");

	Params::LPCController_SetAudioListenerPosition_Character Parms{};

	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.SetAudioListenerPosition_CustomLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::SetAudioListenerPosition_CustomLocation(const struct FVector& Location, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "SetAudioListenerPosition_CustomLocation");

	Params::LPCController_SetAudioListenerPosition_CustomLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.SetAudioListenerPosition_StatRoom
// (Final, Native, Public, BlueprintCallable)

void ALPCController::SetAudioListenerPosition_StatRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "SetAudioListenerPosition_StatRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.SetInteractionLadder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Motion                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCController::SetInteractionLadder(bool Motion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "SetInteractionLadder");

	Params::LPCController_SetInteractionLadder Parms{};

	Parms.Motion = Motion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCController.GetAudioListenerPositionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELAudioListenerPositionType             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELAudioListenerPositionType ALPCController::GetAudioListenerPositionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCController", "GetAudioListenerPositionType");

	Params::LPCController_GetAudioListenerPositionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMovieSystemData.ClearMovieData
// (Final, Native, Public, BlueprintCallable)

void ALMovieSystemData::ClearMovieData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "ClearMovieData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystemData.DeactivatePauseOnReachedEnd
// (Event, Public, BlueprintEvent)

void ALMovieSystemData::DeactivatePauseOnReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "DeactivatePauseOnReachedEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LMovieSystemData.IsPauseOnReachedEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALMovieSystemData::IsPauseOnReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "IsPauseOnReachedEnd");

	Params::LMovieSystemData_IsPauseOnReachedEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LMovieSystemData.IsPlayingBinkMovie
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALMovieSystemData::IsPlayingBinkMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "IsPlayingBinkMovie");

	Params::LMovieSystemData_IsPlayingBinkMovie Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LMovieSystemData.MovieSeekToLast
// (Event, Public, BlueprintEvent)

void ALMovieSystemData::MovieSeekToLast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "MovieSeekToLast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LMovieSystemData.PlayBinkMovie
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MovieUrl                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPauseOnReachedEnd                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALMovieSystemData::PlayBinkMovie(class FName MovieCodeName, const class FString& MovieUrl, bool bPauseOnReachedEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "PlayBinkMovie");

	Params::LMovieSystemData_PlayBinkMovie Parms{};

	Parms.MovieCodeName = MovieCodeName;
	Parms.MovieUrl = std::move(MovieUrl);
	Parms.bPauseOnReachedEnd = bPauseOnReachedEnd;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LMovieSystemData.StopBinkMovie
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALMovieSystemData::StopBinkMovie(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystemData", "StopBinkMovie");

	Params::LMovieSystemData_StopBinkMovie Parms{};

	Parms.MovieCodeName = MovieCodeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LHeadTagComponent.CanHeadTagVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULHeadTagComponent::CanHeadTagVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHeadTagComponent", "CanHeadTagVisible");

	Params::LHeadTagComponent_CanHeadTagVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitCollisionDynamic.GetCollisionOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALHitCollisionDynamic::GetCollisionOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitCollisionDynamic", "GetCollisionOwner");

	Params::LHitCollisionDynamic_GetCollisionOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitCollisionDynamic.GetPhysicalSurface
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELPhysicalSurfaceType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPhysicalSurfaceType ALHitCollisionDynamic::GetPhysicalSurface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitCollisionDynamic", "GetPhysicalSurface");

	Params::LHitCollisionDynamic_GetPhysicalSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitCollisionDynamic.GetPartsCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALHitCollisionDynamic::GetPartsCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitCollisionDynamic", "GetPartsCodeName");

	Params::LHitCollisionDynamic_GetPartsCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitCollisionDynamic.IsAttackCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALHitCollisionDynamic::IsAttackCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitCollisionDynamic", "IsAttackCollision");

	Params::LHitCollisionDynamic_IsAttackCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitCollisionDynamic.IsGuardCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALHitCollisionDynamic::IsGuardCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitCollisionDynamic", "IsGuardCollision");

	Params::LHitCollisionDynamic_IsGuardCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitCollisionDynamic.IsPartsGuardCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALHitCollisionDynamic::IsPartsGuardCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitCollisionDynamic", "IsPartsGuardCollision");

	Params::LHitCollisionDynamic_IsPartsGuardCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitProcComponent.GetDebugShowRepulseSparkInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULHitProcComponent::GetDebugShowRepulseSparkInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "GetDebugShowRepulseSparkInfo");

	Params::LHitProcComponent_GetDebugShowRepulseSparkInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LHitProcComponent.OnActionStarted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        StartedAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcComponent::OnActionStarted(class ULActMgrComponent* ActMgrComponent, class ULActBase* StartedAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "OnActionStarted");

	Params::LHitProcComponent_OnActionStarted Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.StartedAction = StartedAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitProcComponent.OnActionStopCalled
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        StoppingAction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActBase*                        ReasonAction                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHitProcComponent::OnActionStopCalled(class ULActMgrComponent* ActMgrComponent, class ULActBase* StoppingAction, class ULActBase* ReasonAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "OnActionStopCalled");

	Params::LHitProcComponent_OnActionStopCalled Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.StoppingAction = StoppingAction;
	Parms.ReasonAction = ReasonAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitProcComponent.OnDebugHitOcurred
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitProcComponent::OnDebugHitOcurred(const struct FHitResult& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "OnDebugHitOcurred");

	Params::LHitProcComponent_OnDebugHitOcurred Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LHitProcComponent.OnFxSocketHitOccurred
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFxSocketTracerInfo             SocketTracerInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitProcComponent::OnFxSocketHitOccurred(class ULActMgrComponent* ActMgrComponent, const struct FLFxSocketTracerInfo& SocketTracerInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "OnFxSocketHitOccurred");

	Params::LHitProcComponent_OnFxSocketHitOccurred Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.SocketTracerInfo = std::move(SocketTracerInfo);
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LHitProcComponent.OnRepulseSocketHitOccurred
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFxSocketTracerInfo             SocketTracerInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitProcComponent::OnRepulseSocketHitOccurred(class ULActMgrComponent* ActMgrComponent, const struct FLFxSocketTracerInfo& SocketTracerInfo, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "OnRepulseSocketHitOccurred");

	Params::LHitProcComponent_OnRepulseSocketHitOccurred Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.SocketTracerInfo = std::move(SocketTracerInfo);
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LHitProcComponent.ProcessHit
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitProcComponent::ProcessHit(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "ProcessHit");

	Params::LHitProcComponent_ProcessHit Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitResult = std::move(HitResult);
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitProcComponent.ProcessHitDecoMesh
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitProcComponent::ProcessHitDecoMesh(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "ProcessHitDecoMesh");

	Params::LHitProcComponent_ProcessHitDecoMesh Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LHitProcComponent.ProcessHitProp
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULHitProcComponent::ProcessHitProp(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "ProcessHitProp");

	Params::LHitProcComponent_ProcessHitProp Parms{};

	Parms.Attacker = Attacker;
	Parms.Victim = Victim;
	Parms.HitResult = std::move(HitResult);
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHitProcComponent.RegisterNewHit
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitContext                     HitContext                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULHitProcComponent::RegisterNewHit(class AActor* Victim, const struct FLHitContext& HitContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHitProcComponent", "RegisterNewHit");

	Params::LHitProcComponent_RegisterNewHit Parms{};

	Parms.Victim = Victim;
	Parms.HitContext = std::move(HitContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractInterface.CalcInteractionResult
// (Native, Public, BlueprintCallable)

void ILInteractInterface::CalcInteractionResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "CalcInteractionResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractInterface.GetInteractionStartTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ILInteractInterface::GetInteractionStartTransform(bool* IsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "GetInteractionStartTransform");

	Params::LInteractInterface_GetInteractionStartTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractInterface.GetInteractionUserAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* ILInteractInterface::GetInteractionUserAnimMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "GetInteractionUserAnimMontage");

	Params::LInteractInterface_GetInteractionUserAnimMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractInterface.HideInteractMessage
// (Native, Public, BlueprintCallable)

void ILInteractInterface::HideInteractMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "HideInteractMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractInterface.InteractionEnd
// (Native, Public, BlueprintCallable)

void ILInteractInterface::InteractionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "InteractionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractInterface.IsValidUserInteractedComp
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ILInteractInterface::IsValidUserInteractedComp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "IsValidUserInteractedComp");

	Params::LInteractInterface_IsValidUserInteractedComp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LInteractInterface.RefreshPlayerInteraction
// (Native, Public, BlueprintCallable)

void ILInteractInterface::RefreshPlayerInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "RefreshPlayerInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LInteractInterface.StopPlayerInteraction
// (Native, Public, BlueprintCallable)

void ILInteractInterface::StopPlayerInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LInteractInterface", "StopPlayerInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDialogControl.Execute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FLDialogExecute                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLDialogExecute ULDialogControl::Execute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "Execute");

	Params::LDialogControl_Execute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.ExecuteSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMenuIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLDialogExecute                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLDialogExecute ULDialogControl::ExecuteSelect(int32 InMenuIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "ExecuteSelect");

	Params::LDialogControl_ExecuteSelect Parms{};

	Parms.InMenuIdx = InMenuIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.GetMenuItemNotifies
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> ULDialogControl::GetMenuItemNotifies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "GetMenuItemNotifies");

	Params::LDialogControl_GetMenuItemNotifies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.GetMenuItemTexts
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> ULDialogControl::GetMenuItemTexts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "GetMenuItemTexts");

	Params::LDialogControl_GetMenuItemTexts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.GetNameText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULDialogControl::GetNameText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "GetNameText");

	Params::LDialogControl_GetNameText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.GetScriptText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULDialogControl::GetScriptText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "GetScriptText");

	Params::LDialogControl_GetScriptText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.OnCloseUIByExecute
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULDialogControl::OnCloseUIByExecute(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "OnCloseUIByExecute");

	Params::LDialogControl_OnCloseUIByExecute Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LDialogControl.StartExecute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULDialogControl::StartExecute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "StartExecute");

	Params::LDialogControl_StartExecute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.GetSelectedMenuInfoPtr
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDialogInfoPtr                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDialogInfoPtr ULDialogControl::GetSelectedMenuInfoPtr() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "GetSelectedMenuInfoPtr");

	Params::LDialogControl_GetSelectedMenuInfoPtr Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.GetTalkerInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTalkerInfoPtr             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTalkerInfoPtr ULDialogControl::GetTalkerInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "GetTalkerInfo");

	Params::LDialogControl_GetTalkerInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.IsHoldSelectDialog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULDialogControl::IsHoldSelectDialog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "IsHoldSelectDialog");

	Params::LDialogControl_IsHoldSelectDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULDialogControl::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "IsValid");

	Params::LDialogControl_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogControl.WillExit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULDialogControl::WillExit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogControl", "WillExit");

	Params::LDialogControl_WillExit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LDialogDB.GetDialog
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             DialogCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLDisplayableDialog              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLDisplayableDialog ULDialogDB::GetDialog(class FName DialogCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LDialogDB", "GetDialog");

	Params::LDialogDB_GetDialog Parms{};

	Parms.DialogCodeName = DialogCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.AbandonItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RemoveCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::AbandonItem(class ULItem* Item, int32 RemoveCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "AbandonItem");

	Params::LPlayerInventory_AbandonItem Parms{};

	Parms.Item = Item;
	Parms.RemoveCount = RemoveCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.AddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::AddItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "AddItem");

	Params::LPlayerInventory_AddItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.BlockNewNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InBlocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerInventory::BlockNewNotification(bool InBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "BlockNewNotification");

	Params::LPlayerInventory_BlockNewNotification Parms{};

	Parms.InBlocked = InBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerInventory.ClearAllNotification
// (Final, Native, Public, BlueprintCallable)

void ULPlayerInventory::ClearAllNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "ClearAllNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerInventory.ClearAllNotification_Inven
// (Final, Native, Public, BlueprintCallable)

void ULPlayerInventory::ClearAllNotification_Inven()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "ClearAllNotification_Inven");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerInventory.ClearCategoryNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerInventory::ClearCategoryNotification(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "ClearCategoryNotification");

	Params::LPlayerInventory_ClearCategoryNotification Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerInventory.ConsumeItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumeCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::ConsumeItem(class ULItem* Item, int32 ConsumeCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "ConsumeItem");

	Params::LPlayerInventory_ConsumeItem Parms{};

	Parms.Item = Item;
	Parms.ConsumeCount = ConsumeCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.ConsumeItemByCodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumeCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::ConsumeItemByCodeName(class FName CodeName, int32 ConsumeCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "ConsumeItemByCodeName");

	Params::LPlayerInventory_ConsumeItemByCodeName Parms{};

	Parms.CodeName = CodeName;
	Parms.ConsumeCount = ConsumeCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.EmptyItems
// (Final, Native, Public, BlueprintCallable)

void ULPlayerInventory::EmptyItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "EmptyItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerInventory.FindBladeItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerInventory::FindBladeItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "FindBladeItems");

	Params::LPlayerInventory_FindBladeItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.FindCategoryItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemSecondCategory                    Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerInventory::FindCategoryItems(ELItemSecondCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "FindCategoryItems");

	Params::LPlayerInventory_FindCategoryItems Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.FindHandleItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerInventory::FindHandleItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "FindHandleItems");

	Params::LPlayerInventory_FindHandleItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.FindItemByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULPlayerInventory::FindItemByCodeName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "FindItemByCodeName");

	Params::LPlayerInventory_FindItemByCodeName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.FindItemsByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerInventory::FindItemsByCodeName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "FindItemsByCodeName");

	Params::LPlayerInventory_FindItemsByCodeName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.FindUICategoryItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULPlayerInventory::FindUICategoryItems(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "FindUICategoryItems");

	Params::LPlayerInventory_FindUICategoryItems Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerInventory::GetAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetAllItems");

	Params::LPlayerInventory_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetBladeItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerInventory::GetBladeItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetBladeItems");

	Params::LPlayerInventory_GetBladeItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetGearItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerInventory::GetGearItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetGearItems");

	Params::LPlayerInventory_GetGearItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetHandleItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerInventory::GetHandleItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetHandleItems");

	Params::LPlayerInventory_GetHandleItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetItemCategoryMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<ELItemSecondCategory, struct FLInvenCategoryItemList>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> ULPlayerInventory::GetItemCategoryMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetItemCategoryMap");

	Params::LPlayerInventory_GetItemCategoryMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetItemTotalCountByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayerInventory::GetItemTotalCountByCodeName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetItemTotalCountByCodeName");

	Params::LPlayerInventory_GetItemTotalCountByCodeName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetPartsItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULItem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULItem*> ULPlayerInventory::GetPartsItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetPartsItems");

	Params::LPlayerInventory_GetPartsItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetSlaveArmItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULSlaveArmItem*>     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULSlaveArmItem*> ULPlayerInventory::GetSlaveArmItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetSlaveArmItems");

	Params::LPlayerInventory_GetSlaveArmItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetWeaponItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class ULWeaponItem*>       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ULWeaponItem*> ULPlayerInventory::GetWeaponItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetWeaponItems");

	Params::LPlayerInventory_GetWeaponItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetWeaponItems_SortedByEquipSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ULWeaponItem*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULWeaponItem*> ULPlayerInventory::GetWeaponItems_SortedByEquipSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetWeaponItems_SortedByEquipSlot");

	Params::LPlayerInventory_GetWeaponItems_SortedByEquipSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.GetWeaponTotalCountByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             HandleCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BladeCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPlayerInventory::GetWeaponTotalCountByCodeName(class FName HandleCodeName, class FName BladeCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "GetWeaponTotalCountByCodeName");

	Params::LPlayerInventory_GetWeaponTotalCountByCodeName Parms{};

	Parms.HandleCodeName = HandleCodeName;
	Parms.BladeCodeName = BladeCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.HasItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::HasItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "HasItem");

	Params::LPlayerInventory_HasItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.IsNotiCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::IsNotiCategory(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "IsNotiCategory");

	Params::LPlayerInventory_IsNotiCategory Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.IsNotiItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           InItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::IsNotiItem(class ULItem* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "IsNotiItem");

	Params::LPlayerInventory_IsNotiItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.MoveItemToLocker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELItemGainResult                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELItemGainResult ULPlayerInventory::MoveItemToLocker(class ULItem* Item, int32 ItemCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "MoveItemToLocker");

	Params::LPlayerInventory_MoveItemToLocker Parms{};

	Parms.Item = Item;
	Parms.ItemCount = ItemCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.RechargeConsumeItems
// (Final, Native, Public, BlueprintCallable)

void ULPlayerInventory::RechargeConsumeItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "RechargeConsumeItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerInventory.RemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::RemoveItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "RemoveItem");

	Params::LPlayerInventory_RemoveItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerInventory.HasSameItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerInventory::HasSameItem(class FName ItemCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerInventory", "HasSameItem");

	Params::LPlayerInventory_HasSameItem Parms{};

	Parms.ItemCodeName = ItemCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNpcSpotDieData.ExecuteChangeWeather
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteChangeWeather()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteChangeWeather");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteDeadBossAlert
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteDeadBossAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteDeadBossAlert");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteDeadBossAlertAfterCommand
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteDeadBossAlertAfterCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteDeadBossAlertAfterCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteDialog
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteItemAlert
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteItemAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteItemAlert");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteLevelSequence
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteLevelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteLevelSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteMonologue
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteMonologue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteMonologue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteMovie
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ExecuteUiFadeOut
// (Final, Native, Public)

void ULNpcSpotDieData::ExecuteUiFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ExecuteUiFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.NextNpcSpotDieProcess
// (Final, Native, Public)

void ULNpcSpotDieData::NextNpcSpotDieProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "NextNpcSpotDieProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ResponseDialogExit
// (Final, Native, Public)

void ULNpcSpotDieData::ResponseDialogExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ResponseDialogExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ResponseLevelSequenceEnd
// (Final, Native, Public)
// Parameters:
// class FString                           SpotUniqueID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULNpcSpotDieData::ResponseLevelSequenceEnd(const class FString& SpotUniqueID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ResponseLevelSequenceEnd");

	Params::LNpcSpotDieData_ResponseLevelSequenceEnd Parms{};

	Parms.SpotUniqueID = std::move(SpotUniqueID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ResponseMonologueExit
// (Final, Native, Public)

void ULNpcSpotDieData::ResponseMonologueExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ResponseMonologueExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ResponseMovieEnd
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             MovieCodeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULNpcSpotDieData::ResponseMovieEnd(const class FName& MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ResponseMovieEnd");

	Params::LNpcSpotDieData_ResponseMovieEnd Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNpcSpotDieData.ResponseUiFadeOutEnd
// (Final, Native, Public)

void ULNpcSpotDieData::ResponseUiFadeOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNpcSpotDieData", "ResponseUiFadeOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.AbandonItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::AbandonItem(class ULItem* Item, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "AbandonItem");

	Params::LItemSystem_AbandonItem Parms{};

	Parms.Item = Item;
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.ChangeCorrectionHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELStatCorrectChangeType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           HandleOrWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::ChangeCorrectionHandle(ELStatCorrectChangeType Type, class ULItem* HandleOrWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "ChangeCorrectionHandle");

	Params::LItemSystem_ChangeCorrectionHandle Parms{};

	Parms.Type = Type;
	Parms.HandleOrWeapon = HandleOrWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.CheckItemCanUsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UseCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::CheckItemCanUsed(class ULItem* Item, int32 UseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "CheckItemCanUsed");

	Params::LItemSystem_CheckItemCanUsed Parms{};

	Parms.Item = Item;
	Parms.UseCount = UseCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.CombineWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULWeaponItem*                     WeaponToChange                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLWeaponPartInfoForCombine       HandlePart                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLWeaponPartInfoForCombine       BladePart                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ULWeaponItem*                     OutResultWeaponItem                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::CombineWeapon(class ULWeaponItem* WeaponToChange, const struct FLWeaponPartInfoForCombine& HandlePart, const struct FLWeaponPartInfoForCombine& BladePart, class ULWeaponItem** OutResultWeaponItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "CombineWeapon");

	Params::LItemSystem_CombineWeapon Parms{};

	Parms.WeaponToChange = WeaponToChange;
	Parms.HandlePart = std::move(HandlePart);
	Parms.BladePart = std::move(BladePart);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResultWeaponItem != nullptr)
		*OutResultWeaponItem = Parms.OutResultWeaponItem;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.CombineWeaponWithoutRestrictions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULItem*                           HandleItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           BladeItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULWeaponItem*                     OutResultWeaponItem                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::CombineWeaponWithoutRestrictions(class ULItem* HandleItem, class ULItem* BladeItem, class ULWeaponItem** OutResultWeaponItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "CombineWeaponWithoutRestrictions");

	Params::LItemSystem_CombineWeaponWithoutRestrictions Parms{};

	Parms.HandleItem = HandleItem;
	Parms.BladeItem = BladeItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResultWeaponItem != nullptr)
		*OutResultWeaponItem = Parms.OutResultWeaponItem;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.CreateItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULItemSystem::CreateItem(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "CreateItem");

	Params::LItemSystem_CreateItem Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.CreateWeaponItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             HandleCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BladeCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULWeaponItem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWeaponItem* ULItemSystem::CreateWeaponItem(class FName HandleCodeName, class FName BladeCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "CreateWeaponItem");

	Params::LItemSystem_CreateWeaponItem Parms{};

	Parms.HandleCodeName = HandleCodeName;
	Parms.BladeCodeName = BladeCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.DecideForceUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::DecideForceUseItem(bool Result, class FName ItemCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "DecideForceUseItem");

	Params::LItemSystem_DecideForceUseItem Parms{};

	Parms.Result = Result;
	Parms.ItemCodeName = ItemCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.DestoryItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::DestoryItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "DestoryItem");

	Params::LItemSystem_DestoryItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.DivideWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULWeaponItem*                     WeaponItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ResultHandleItem                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ResultBladeItem                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::DivideWeapon(class ULWeaponItem* WeaponItem, class ULItem** ResultHandleItem, class ULItem** ResultBladeItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "DivideWeapon");

	Params::LItemSystem_DivideWeapon Parms{};

	Parms.WeaponItem = WeaponItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultHandleItem != nullptr)
		*ResultHandleItem = Parms.ResultHandleItem;

	if (ResultBladeItem != nullptr)
		*ResultBladeItem = Parms.ResultBladeItem;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.FindSlavearmAlteredConsumeItemInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ConsumeItemCodename                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlavearmAlterItemMatchInfoPtr   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSlavearmAlterItemMatchInfoPtr ULItemSystem::FindSlavearmAlteredConsumeItemInfo(class FName ConsumeItemCodename, class FName SlaveArmItemCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "FindSlavearmAlteredConsumeItemInfo");

	Params::LItemSystem_FindSlavearmAlteredConsumeItemInfo Parms{};

	Parms.ConsumeItemCodename = ConsumeItemCodename;
	Parms.SlaveArmItemCodename = SlaveArmItemCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetBladeListForCombine
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULWeaponItem*                     WeaponToChange                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLWeaponPartInfoForCombine>OutBladeInfoList                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULItemSystem::GetBladeListForCombine(class ULWeaponItem* WeaponToChange, TArray<struct FLWeaponPartInfoForCombine>* OutBladeInfoList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetBladeListForCombine");

	Params::LItemSystem_GetBladeListForCombine Parms{};

	Parms.WeaponToChange = WeaponToChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBladeInfoList != nullptr)
		*OutBladeInfoList = std::move(Parms.OutBladeInfoList);
}


// Function ProjectP.LItemSystem.GetBuyShop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ShopCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULProductBuyShop*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULProductBuyShop* ULItemSystem::GetBuyShop(class FName ShopCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetBuyShop");

	Params::LItemSystem_GetBuyShop Parms{};

	Parms.ShopCodeName = ShopCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetChangeCorrectionHandleNeeds
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ELStatCorrectChangeType                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           InHandleOrWeapon                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutItemCodeName                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutItemCount                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutErgoCount                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::GetChangeCorrectionHandleNeeds(ELStatCorrectChangeType InType, class ULItem* InHandleOrWeapon, class FName* OutItemCodeName, int32* OutItemCount, int32* OutErgoCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetChangeCorrectionHandleNeeds");

	Params::LItemSystem_GetChangeCorrectionHandleNeeds Parms{};

	Parms.InType = InType;
	Parms.InHandleOrWeapon = InHandleOrWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemCodeName != nullptr)
		*OutItemCodeName = Parms.OutItemCodeName;

	if (OutItemCount != nullptr)
		*OutItemCount = Parms.OutItemCount;

	if (OutErgoCount != nullptr)
		*OutErgoCount = Parms.OutErgoCount;
}


// Function ProjectP.LItemSystem.GetCombineResultWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           HandleItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           BladeItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULWeaponItem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWeaponItem* ULItemSystem::GetCombineResultWeapon(class ULItem* HandleItem, class ULItem* BladeItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetCombineResultWeapon");

	Params::LItemSystem_GetCombineResultWeapon Parms{};

	Parms.HandleItem = HandleItem;
	Parms.BladeItem = BladeItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetConsumeItemAlterableState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ConsumeItemCodename                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELConsumeItemSlavearmAtlerableState     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELConsumeItemSlavearmAtlerableState ULItemSystem::GetConsumeItemAlterableState(class FName ConsumeItemCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetConsumeItemAlterableState");

	Params::LItemSystem_GetConsumeItemAlterableState Parms{};

	Parms.ConsumeItemCodename = ConsumeItemCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetHandleListForCombine
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULWeaponItem*                     WeaponToChange                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLWeaponPartInfoForCombine>OutHandleInfoList                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULItemSystem::GetHandleListForCombine(class ULWeaponItem* WeaponToChange, TArray<struct FLWeaponPartInfoForCombine>* OutHandleInfoList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetHandleListForCombine");

	Params::LItemSystem_GetHandleListForCombine Parms{};

	Parms.WeaponToChange = WeaponToChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandleInfoList != nullptr)
		*OutHandleInfoList = std::move(Parms.OutHandleInfoList);
}


// Function ProjectP.LItemSystem.GetItemToggleImageResource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> ULItemSystem::GetItemToggleImageResource(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetItemToggleImageResource");

	Params::LItemSystem_GetItemToggleImageResource Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetNecessaryMaterialForCombineWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULItem*                           HandleItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           BladeItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentCost                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequireCost                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLItemRequireCount>       RequireItems                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULItemSystem::GetNecessaryMaterialForCombineWeapon(class ULItem* HandleItem, class ULItem* BladeItem, int32* CurrentCost, int32* RequireCost, TArray<struct FLItemRequireCount>* RequireItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetNecessaryMaterialForCombineWeapon");

	Params::LItemSystem_GetNecessaryMaterialForCombineWeapon Parms{};

	Parms.HandleItem = HandleItem;
	Parms.BladeItem = BladeItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentCost != nullptr)
		*CurrentCost = Parms.CurrentCost;

	if (RequireCost != nullptr)
		*RequireCost = Parms.RequireCost;

	if (RequireItems != nullptr)
		*RequireItems = std::move(Parms.RequireItems);
}


// Function ProjectP.LItemSystem.GetNecessaryMaterialForDivideWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULWeaponItem*                     WeaponItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentCost                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequireCost                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLItemRequireCount               Item1                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLItemRequireCount               Item2                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void ULItemSystem::GetNecessaryMaterialForDivideWeapon(class ULWeaponItem* WeaponItem, int32* CurrentCost, int32* RequireCost, struct FLItemRequireCount* Item1, struct FLItemRequireCount* Item2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetNecessaryMaterialForDivideWeapon");

	Params::LItemSystem_GetNecessaryMaterialForDivideWeapon Parms{};

	Parms.WeaponItem = WeaponItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentCost != nullptr)
		*CurrentCost = Parms.CurrentCost;

	if (RequireCost != nullptr)
		*RequireCost = Parms.RequireCost;

	if (Item1 != nullptr)
		*Item1 = std::move(Parms.Item1);

	if (Item2 != nullptr)
		*Item2 = std::move(Parms.Item2);
}


// Function ProjectP.LItemSystem.GetPlayerEquipment
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULPlayerEquipment*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPlayerEquipment* ULItemSystem::GetPlayerEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPlayerEquipment");

	Params::LItemSystem_GetPlayerEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPlayerInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULPlayerInventory*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPlayerInventory* ULItemSystem::GetPlayerInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPlayerInventory");

	Params::LItemSystem_GetPlayerInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPlayerItemLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULPlayerItemLocker*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPlayerItemLocker* ULItemSystem::GetPlayerItemLocker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPlayerItemLocker");

	Params::LItemSystem_GetPlayerItemLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPulseGaugeRechargeSystemEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::GetPulseGaugeRechargeSystemEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPulseGaugeRechargeSystemEnable");

	Params::LItemSystem_GetPulseGaugeRechargeSystemEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPulseItemExhaustedCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItemSystem::GetPulseItemExhaustedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPulseItemExhaustedCount");

	Params::LItemSystem_GetPulseItemExhaustedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPulseItemRechargeableCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItemSystem::GetPulseItemRechargeableCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPulseItemRechargeableCount");

	Params::LItemSystem_GetPulseItemRechargeableCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPulseItemRechargedCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULItemSystem::GetPulseItemRechargedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPulseItemRechargedCount");

	Params::LItemSystem_GetPulseItemRechargedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetPulseRechargeable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::GetPulseRechargeable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetPulseRechargeable");

	Params::LItemSystem_GetPulseRechargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetReadyToUseItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ULActBase*                        Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutUseCount                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULItemSystem::GetReadyToUseItem(class ULActBase* Action, int32* OutUseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetReadyToUseItem");

	Params::LItemSystem_GetReadyToUseItem Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUseCount != nullptr)
		*OutUseCount = Parms.OutUseCount;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetSecondCategory_Blade
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<ELItemSecondCategory>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ELItemSecondCategory> ULItemSystem::GetSecondCategory_Blade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetSecondCategory_Blade");

	Params::LItemSystem_GetSecondCategory_Blade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetSecondCategory_FromFirst
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ELItemSecondCategory>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ELItemSecondCategory> ULItemSystem::GetSecondCategory_FromFirst(ELItemFirstCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetSecondCategory_FromFirst");

	Params::LItemSystem_GetSecondCategory_FromFirst Parms{};

	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetSecondCategory_Handle
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<ELItemSecondCategory>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ELItemSecondCategory> ULItemSystem::GetSecondCategory_Handle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetSecondCategory_Handle");

	Params::LItemSystem_GetSecondCategory_Handle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetSellShop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULProductSellShop*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULProductSellShop* ULItemSystem::GetSellShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetSellShop");

	Params::LItemSystem_GetSellShop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetSpecialShop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ShopCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULProductSpecialShop*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULProductSpecialShop* ULItemSystem::GetSpecialShop(class FName ShopCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetSpecialShop");

	Params::LItemSystem_GetSpecialShop Parms{};

	Parms.ShopCodeName = ShopCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.GetUnusableNow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::GetUnusableNow(class FName ItemCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "GetUnusableNow");

	Params::LItemSystem_GetUnusableNow Parms{};

	Parms.ItemCodeName = ItemCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.MakeComplexItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           ComplexItem_Main                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ComplexItem_Unit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::MakeComplexItem(class ULItem* ComplexItem_Main, class ULItem* ComplexItem_Unit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "MakeComplexItem");

	Params::LItemSystem_MakeComplexItem Parms{};

	Parms.ComplexItem_Main = ComplexItem_Main;
	Parms.ComplexItem_Unit = ComplexItem_Unit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.OnClosedWindow
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::OnClosedWindow(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "OnClosedWindow");

	Params::LItemSystem_OnClosedWindow Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "OnGameDataCharacterSync");

	Params::LItemSystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.OnReadLetter
// (Final, Native, Public)
// Parameters:
// class FName                             InLetterName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPageNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::OnReadLetter(class FName InLetterName, int32 InPageNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "OnReadLetter");

	Params::LItemSystem_OnReadLetter Parms{};

	Parms.InLetterName = InLetterName;
	Parms.InPageNum = InPageNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.OnUpdateItemInventory
// (Final, Native, Protected)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::OnUpdateItemInventory(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "OnUpdateItemInventory");

	Params::LItemSystem_OnUpdateItemInventory Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.RechargeConsumeItems
// (Final, Native, Public, BlueprintCallable)

void ULItemSystem::RechargeConsumeItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "RechargeConsumeItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.ReinforceBlade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           BladeOrWeapon                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::ReinforceBlade(class ULItem* BladeOrWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "ReinforceBlade");

	Params::LItemSystem_ReinforceBlade Parms{};

	Parms.BladeOrWeapon = BladeOrWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LItemSystem.RestoreWeaponSharpnessMax
// (Final, Native, Public, BlueprintCallable)

void ULItemSystem::RestoreWeaponSharpnessMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "RestoreWeaponSharpnessMax");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.SetPulseGaugeRechargeSystemEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULItemSystem::SetPulseGaugeRechargeSystemEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "SetPulseGaugeRechargeSystemEnable");

	Params::LItemSystem_SetPulseGaugeRechargeSystemEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LItemSystem.UseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UseCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULItemSystem::UseItem(class ULItem* Item, int32 UseCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LItemSystem", "UseItem");

	Params::LItemSystem_UseItem Parms{};

	Parms.Item = Item;
	Parms.UseCount = UseCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFogGateObject.SetFogGateState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELFogGateState                          StateData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALFogGateObject::SetFogGateState(ELFogGateState StateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFogGateObject", "SetFogGateState");

	Params::LFogGateObject_SetFogGateState Parms{};

	Parms.StateData = StateData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LLevelSequenceSystem.ForceUnLockPlayerAction
// (Final, Native, Public)

void ULLevelSequenceSystem::ForceUnLockPlayerAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSequenceSystem", "ForceUnLockPlayerAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceSystem.GetLastPlayingSequenceActorData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULSequenceActorData*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSequenceActorData* ULLevelSequenceSystem::GetLastPlayingSequenceActorData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSequenceSystem", "GetLastPlayingSequenceActorData");

	Params::LLevelSequenceSystem_GetLastPlayingSequenceActorData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLevelSequenceSystem.GetSequenceActorData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SequenceCodeName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSequenceActorData*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSequenceActorData* ULLevelSequenceSystem::GetSequenceActorData(const class FName& SequenceCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSequenceSystem", "GetSequenceActorData");

	Params::LLevelSequenceSystem_GetSequenceActorData Parms{};

	Parms.SequenceCodeName = SequenceCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLevelSequenceSystem.OnLieDialogEnd
// (Final, Native, Protected)

void ULLevelSequenceSystem::OnLieDialogEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSequenceSystem", "OnLieDialogEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceSystem.OnLieDialogStart
// (Final, Native, Protected)

void ULLevelSequenceSystem::OnLieDialogStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSequenceSystem", "OnLieDialogStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceSystem.SkipPlayingSequence
// (Final, Native, Public, BlueprintCallable)

void ULLevelSequenceSystem::SkipPlayingSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLevelSequenceSystem", "SkipPlayingSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.ActiveFixCameraSpeed
// (Final, Native, Static, Public, BlueprintCallable)

void ULLevelSequenceUtilFuncLibrary::ActiveFixCameraSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "ActiveFixCameraSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.ApplyPCCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Command                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLevelSequenceUtilFuncLibrary::ApplyPCCommand(class FName Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "ApplyPCCommand");

	Params::LLevelSequenceUtilFuncLibrary_ApplyPCCommand Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.DeactiveFixCameraSpeed
// (Final, Native, Static, Public, BlueprintCallable)

void ULLevelSequenceUtilFuncLibrary::DeactiveFixCameraSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "DeactiveFixCameraSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.HidePC
// (Final, Native, Static, Public, BlueprintCallable)

void ULLevelSequenceUtilFuncLibrary::HidePC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "HidePC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.LockPlayerAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevelSequencePlayer*             NeedUnLockPlayerAction                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLevelSequenceUtilFuncLibrary::LockPlayerAction(class ULevelSequencePlayer* NeedUnLockPlayerAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "LockPlayerAction");

	Params::LLevelSequenceUtilFuncLibrary_LockPlayerAction Parms{};

	Parms.NeedUnLockPlayerAction = NeedUnLockPlayerAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.ResetHeadLookatHolding
// (Final, Native, Static, Public, BlueprintCallable)

void ULLevelSequenceUtilFuncLibrary::ResetHeadLookatHolding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "ResetHeadLookatHolding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.ShowPC
// (Final, Native, Static, Public, BlueprintCallable)

void ULLevelSequenceUtilFuncLibrary::ShowPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "ShowPC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLevelSequenceUtilFuncLibrary.UnLockPlayerAction
// (Final, Native, Static, Public, BlueprintCallable)

void ULLevelSequenceUtilFuncLibrary::UnLockPlayerAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LLevelSequenceUtilFuncLibrary", "UnLockPlayerAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLockOnSystem.IsFocusTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CheckActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLockOnSystem::IsFocusTarget(class AActor* CheckActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnSystem", "IsFocusTarget");

	Params::LLockOnSystem_IsFocusTarget Parms{};

	Parms.CheckActor = CheckActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLockOnSystem.GetLockOnTargetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULLockOnSystem::GetLockOnTargetActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnSystem", "GetLockOnTargetActor");

	Params::LLockOnSystem_GetLockOnTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLockOnSystem.GetLockOnTargetPointLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULLockOnSystem::GetLockOnTargetPointLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnSystem", "GetLockOnTargetPointLocation");

	Params::LLockOnSystem_GetLockOnTargetPointLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLockOnSystem.GetLockOnTargetPointLookAtUpperLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULLockOnSystem::GetLockOnTargetPointLookAtUpperLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnSystem", "GetLockOnTargetPointLookAtUpperLocation");

	Params::LLockOnSystem_GetLockOnTargetPointLookAtUpperLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLockOnSystem.IsLockOnMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLockOnSystem::IsLockOnMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLockOnSystem", "IsLockOnMode");

	Params::LLockOnSystem_IsLockOnMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.AddPostProcessMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPostProcessComponent*            PostProcessComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* ULMiscUtilFuncLibrary::AddPostProcessMaterial(class UPostProcessComponent* PostProcessComponent, class UMaterialInterface* Material, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "AddPostProcessMaterial");

	Params::LMiscUtilFuncLibrary_AddPostProcessMaterial Parms{};

	Parms.PostProcessComponent = PostProcessComponent;
	Parms.Material = Material;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.AttachFollowingEnvSound
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InPhysicalSurface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ULMiscUtilFuncLibrary::AttachFollowingEnvSound(class FName InCodeName, ELPhysicalSurfaceType InPhysicalSurface, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "AttachFollowingEnvSound");

	Params::LMiscUtilFuncLibrary_AttachFollowingEnvSound Parms{};

	Parms.InCodeName = InCodeName;
	Parms.InPhysicalSurface = InPhysicalSurface;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.ChangeMaterialColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class UMeshComponent*>           MeshComponents                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::ChangeMaterialColor(const TArray<class UMeshComponent*>& MeshComponents, class FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ChangeMaterialColor");

	Params::LMiscUtilFuncLibrary_ChangeMaterialColor Parms{};

	Parms.MeshComponents = std::move(MeshComponents);
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.ChangeMaterialScalar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UMeshComponent*>           MeshComponents                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::ChangeMaterialScalar(const TArray<class UMeshComponent*>& MeshComponents, class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ChangeMaterialScalar");

	Params::LMiscUtilFuncLibrary_ChangeMaterialScalar Parms{};

	Parms.MeshComponents = std::move(MeshComponents);
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.ClearAndInvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::ClearAndInvalidateTimerHandle(class UObject* WorldContextObject, struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ClearAndInvalidateTimerHandle");

	Params::LMiscUtilFuncLibrary_ClearAndInvalidateTimerHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Handle = std::move(Parms.Handle);
}


// Function ProjectP.LMiscUtilFuncLibrary.ConvertPhysicalSurfaceNameToEnum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InPhysicalSurfaceName                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPhysicalSurfaceType ULMiscUtilFuncLibrary::ConvertPhysicalSurfaceNameToEnum(class FName InPhysicalSurfaceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ConvertPhysicalSurfaceNameToEnum");

	Params::LMiscUtilFuncLibrary_ConvertPhysicalSurfaceNameToEnum Parms{};

	Parms.InPhysicalSurfaceName = InPhysicalSurfaceName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.ConvertPhysicalSurfaceToEnum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        InPhysicalSurface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELPhysicalSurfaceType ULMiscUtilFuncLibrary::ConvertPhysicalSurfaceToEnum(EPhysicalSurface InPhysicalSurface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ConvertPhysicalSurfaceToEnum");

	Params::LMiscUtilFuncLibrary_ConvertPhysicalSurfaceToEnum Parms{};

	Parms.InPhysicalSurface = InPhysicalSurface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.ExecuteContentCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CommandCodeName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::ExecuteContentCommand(class FName CommandCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ExecuteContentCommand");

	Params::LMiscUtilFuncLibrary_ExecuteContentCommand Parms{};

	Parms.CommandCodeName = CommandCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.ExecuteWorldEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ELCallBackEventType                     CallBackEventType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param1                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param2                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::ExecuteWorldEvent(ELCallBackEventType CallBackEventType, const class FString& Param1, const class FString& Param2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ExecuteWorldEvent");

	Params::LMiscUtilFuncLibrary_ExecuteWorldEvent Parms{};

	Parms.CallBackEventType = CallBackEventType;
	Parms.Param1 = std::move(Param1);
	Parms.Param2 = std::move(Param2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindClosestBoneOnPhysicsAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldImpulse                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApproximate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     SearchBoneNames                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ClosestBoneName                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FindClosestBoneOnPhysicsAsset(class USkeletalMeshComponent* MeshComponent, const struct FVector& WorldPosition, const struct FVector& WorldImpulse, bool bApproximate, const TArray<class FName>& SearchBoneNames, class FName* ClosestBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindClosestBoneOnPhysicsAsset");

	Params::LMiscUtilFuncLibrary_FindClosestBoneOnPhysicsAsset Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.WorldPosition = std::move(WorldPosition);
	Parms.WorldImpulse = std::move(WorldImpulse);
	Parms.bApproximate = bApproximate;
	Parms.SearchBoneNames = std::move(SearchBoneNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClosestBoneName != nullptr)
		*ClosestBoneName = Parms.ClosestBoneName;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindComponentForEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FXSocket                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     MeshSelectionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ULMiscUtilFuncLibrary::FindComponentForEffect(class USkeletalMeshComponent* SkeletalMeshComponent, class AActor* Actor, const class FName& FXSocket, ELMeshSelectionType MeshSelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindComponentForEffect");

	Params::LMiscUtilFuncLibrary_FindComponentForEffect Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.Actor = Actor;
	Parms.FXSocket = FXSocket;
	Parms.MeshSelectionType = MeshSelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindLowerBoneList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BoneList                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FindLowerBoneList(class USkeletalMeshComponent* MeshComponent, class FName BoneName, TArray<class FName>* BoneList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindLowerBoneList");

	Params::LMiscUtilFuncLibrary_FindLowerBoneList Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BoneList != nullptr)
		*BoneList = std::move(Parms.BoneList);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindNearbyBoneList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BoneList                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FindNearbyBoneList(class USkeletalMeshComponent* MeshComponent, class FName BoneName, TArray<class FName>* BoneList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindNearbyBoneList");

	Params::LMiscUtilFuncLibrary_FindNearbyBoneList Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BoneList != nullptr)
		*BoneList = std::move(Parms.BoneList);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindNearestFloatInArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           FloatArray                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   InputFloat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULMiscUtilFuncLibrary::FindNearestFloatInArray(const TArray<float>& FloatArray, float InputFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindNearestFloatInArray");

	Params::LMiscUtilFuncLibrary_FindNearestFloatInArray Parms{};

	Parms.FloatArray = std::move(FloatArray);
	Parms.InputFloat = InputFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindSplashBloodFx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELBloodEffectType                       InBloodType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   OutParticle                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  OutTrail                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FindSplashBloodFx(ELBloodEffectType InBloodType, class UNiagaraSystem** OutParticle, class UParticleSystem** OutTrail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindSplashBloodFx");

	Params::LMiscUtilFuncLibrary_FindSplashBloodFx Parms{};

	Parms.InBloodType = InBloodType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutParticle != nullptr)
		*OutParticle = Parms.OutParticle;

	if (OutTrail != nullptr)
		*OutTrail = Parms.OutTrail;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindWeatherFx
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   OutNiagara                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, float>                OutDefaultScalarVariables                              (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<class FName, struct FColor>        OutDefautlColorVariables                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FindWeatherFx(class FName InCodeName, class UNiagaraSystem** OutNiagara, struct FVector* OutOffset, TMap<class FName, float>* OutDefaultScalarVariables, TMap<class FName, struct FColor>* OutDefautlColorVariables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindWeatherFx");

	Params::LMiscUtilFuncLibrary_FindWeatherFx Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNiagara != nullptr)
		*OutNiagara = Parms.OutNiagara;

	if (OutOffset != nullptr)
		*OutOffset = std::move(Parms.OutOffset);

	if (OutDefaultScalarVariables != nullptr)
		*OutDefaultScalarVariables = std::move(Parms.OutDefaultScalarVariables);

	if (OutDefautlColorVariables != nullptr)
		*OutDefautlColorVariables = std::move(Parms.OutDefautlColorVariables);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FindWeatherSound
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       OutSound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, float>                OutDefaultScalarVariables                              (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<class FName, struct FColor>        OutDefautlColorVariables                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FindWeatherSound(class FName InCodeName, class USoundBase** OutSound, TMap<class FName, float>* OutDefaultScalarVariables, TMap<class FName, struct FColor>* OutDefautlColorVariables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FindWeatherSound");

	Params::LMiscUtilFuncLibrary_FindWeatherSound Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSound != nullptr)
		*OutSound = Parms.OutSound;

	if (OutDefaultScalarVariables != nullptr)
		*OutDefaultScalarVariables = std::move(Parms.OutDefaultScalarVariables);

	if (OutDefautlColorVariables != nullptr)
		*OutDefautlColorVariables = std::move(Parms.OutDefautlColorVariables);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.FlushAudioCache
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::FlushAudioCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "FlushAudioCache");

	Params::LMiscUtilFuncLibrary_FlushAudioCache Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GameObject_Activate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceReset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::GameObject_Activate(class AActor* TargetActor, bool ForceReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GameObject_Activate");

	Params::LMiscUtilFuncLibrary_GameObject_Activate Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ForceReset = ForceReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GameObject_Deactivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::GameObject_Deactivate(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GameObject_Deactivate");

	Params::LMiscUtilFuncLibrary_GameObject_Deactivate Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GameObject_GetState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameObjectState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELGameObjectState ULMiscUtilFuncLibrary::GameObject_GetState(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GameObject_GetState");

	Params::LMiscUtilFuncLibrary_GameObject_GetState Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetBuildConfiguration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Configuration                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::GetBuildConfiguration(class FString* Configuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetBuildConfiguration");

	Params::LMiscUtilFuncLibrary_GetBuildConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configuration != nullptr)
		*Configuration = std::move(Parms.Configuration);
}


// Function ProjectP.LMiscUtilFuncLibrary.GetConstantValues
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULCommonConstantValues*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULCommonConstantValues* ULMiscUtilFuncLibrary::GetConstantValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetConstantValues");

	Params::LMiscUtilFuncLibrary_GetConstantValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetCurrentLever
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APawn*                            TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULMiscUtilFuncLibrary::GetCurrentLever(class APawn* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetCurrentLever");

	Params::LMiscUtilFuncLibrary_GetCurrentLever Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetEquipmentComponentBP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULEquipmentComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULEquipmentComponent* ULMiscUtilFuncLibrary::GetEquipmentComponentBP(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetEquipmentComponentBP");

	Params::LMiscUtilFuncLibrary_GetEquipmentComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetFXComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULFXComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULFXComponent* ULMiscUtilFuncLibrary::GetFXComponent(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetFXComponent");

	Params::LMiscUtilFuncLibrary_GetFXComponent Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetHitSweepLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULMiscUtilFuncLibrary::GetHitSweepLocation(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetHitSweepLocation");

	Params::LMiscUtilFuncLibrary_GetHitSweepLocation Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetLBodyStainComponentBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULBodyStainComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULBodyStainComponent* ULMiscUtilFuncLibrary::GetLBodyStainComponentBP(class AActor* TargetActor, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetLBodyStainComponentBP");

	Params::LMiscUtilFuncLibrary_GetLBodyStainComponentBP Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetMeshComponentsBySelectionType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>           OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     SelectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::GetMeshComponentsBySelectionType(class AActor* Actor, TArray<class UMeshComponent*>* OutComponents, ELMeshSelectionType SelectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetMeshComponentsBySelectionType");

	Params::LMiscUtilFuncLibrary_GetMeshComponentsBySelectionType Parms{};

	Parms.Actor = Actor;
	Parms.SelectType = SelectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);
}


// Function ProjectP.LMiscUtilFuncLibrary.GetNPCSpot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InUniqueSpotId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCSpot*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALNPCSpot* ULMiscUtilFuncLibrary::GetNPCSpot(const class FString& InUniqueSpotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetNPCSpot");

	Params::LMiscUtilFuncLibrary_GetNPCSpot Parms{};

	Parms.InUniqueSpotId = std::move(InUniqueSpotId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetObjectFName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULMiscUtilFuncLibrary::GetObjectFName(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetObjectFName");

	Params::LMiscUtilFuncLibrary_GetObjectFName Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetObjectName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULMiscUtilFuncLibrary::GetObjectName(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetObjectName");

	Params::LMiscUtilFuncLibrary_GetObjectName Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetProjectileCorrectionGrade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELFirstStat                             Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ConsumeItem                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponCorrectionPhysicalGrade         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELWeaponCorrectionPhysicalGrade ULMiscUtilFuncLibrary::GetProjectileCorrectionGrade(ELFirstStat Stat, const class ULItem* ConsumeItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetProjectileCorrectionGrade");

	Params::LMiscUtilFuncLibrary_GetProjectileCorrectionGrade Parms{};

	Parms.Stat = Stat;
	Parms.ConsumeItem = ConsumeItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetRigidBodyBoneList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     BoneList                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::GetRigidBodyBoneList(class USkeletalMeshComponent* MeshComponent, TArray<class FName>* BoneList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetRigidBodyBoneList");

	Params::LMiscUtilFuncLibrary_GetRigidBodyBoneList Parms{};

	Parms.MeshComponent = MeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BoneList != nullptr)
		*BoneList = std::move(Parms.BoneList);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetRigidBodyBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          BoundExtent                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::GetRigidBodyBox(class USkeletalMeshComponent* MeshComponent, class FName BoneName, struct FVector* Location, struct FRotator* Rotation, struct FVector* BoundExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetRigidBodyBox");

	Params::LMiscUtilFuncLibrary_GetRigidBodyBox Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	if (BoundExtent != nullptr)
		*BoundExtent = std::move(Parms.BoundExtent);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetRigidBodyBoxNearby
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          BoundExtent                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::GetRigidBodyBoxNearby(class USkeletalMeshComponent* MeshComponent, class FName BoneName, struct FVector* Location, struct FRotator* Rotation, struct FVector* BoundExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetRigidBodyBoxNearby");

	Params::LMiscUtilFuncLibrary_GetRigidBodyBoxNearby Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	if (BoundExtent != nullptr)
		*BoundExtent = std::move(Parms.BoundExtent);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetShaderPrecompileRemainingCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULMiscUtilFuncLibrary::GetShaderPrecompileRemainingCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetShaderPrecompileRemainingCount");

	Params::LMiscUtilFuncLibrary_GetShaderPrecompileRemainingCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetSlaveArmCorrectionGrade
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELFirstStat                             Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           SlaveArmItem                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELWeaponCorrectionPhysicalGrade         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELWeaponCorrectionPhysicalGrade ULMiscUtilFuncLibrary::GetSlaveArmCorrectionGrade(ELFirstStat Stat, const class ULItem* SlaveArmItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetSlaveArmCorrectionGrade");

	Params::LMiscUtilFuncLibrary_GetSlaveArmCorrectionGrade Parms{};

	Parms.Stat = Stat;
	Parms.SlaveArmItem = SlaveArmItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetSpecialBuffLocalText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutName                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText                             OutTooltip                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::GetSpecialBuffLocalText(class FName CodeName, class FText* OutName, class FText* OutTooltip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetSpecialBuffLocalText");

	Params::LMiscUtilFuncLibrary_GetSpecialBuffLocalText Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = std::move(Parms.OutName);

	if (OutTooltip != nullptr)
		*OutTooltip = std::move(Parms.OutTooltip);
}


// Function ProjectP.LMiscUtilFuncLibrary.GetStatRoomPC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALStatRoomPCCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALStatRoomPCCharacter* ULMiscUtilFuncLibrary::GetStatRoomPC(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetStatRoomPC");

	Params::LMiscUtilFuncLibrary_GetStatRoomPC Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.GetWeaponMeshComponentsBySelectionType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALWeapon*                         WeaponActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMeshComponent*>           OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ELMeshSelectionType                     SelectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::GetWeaponMeshComponentsBySelectionType(class ALWeapon* WeaponActor, TArray<class UMeshComponent*>* OutComponents, ELMeshSelectionType SelectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "GetWeaponMeshComponentsBySelectionType");

	Params::LMiscUtilFuncLibrary_GetWeaponMeshComponentsBySelectionType Parms{};

	Parms.WeaponActor = WeaponActor;
	Parms.SelectType = SelectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);
}


// Function ProjectP.LMiscUtilFuncLibrary.HideManagedNiagaraComponentsBP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Hide                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::HideManagedNiagaraComponentsBP(class AActor* TargetActor, bool Hide, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "HideManagedNiagaraComponentsBP");

	Params::LMiscUtilFuncLibrary_HideManagedNiagaraComponentsBP Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Hide = Hide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ProjectP.LMiscUtilFuncLibrary.IsLiquidSurface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELPhysicalSurfaceType                   PhysicalSurfaceType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::IsLiquidSurface(ELPhysicalSurfaceType PhysicalSurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "IsLiquidSurface");

	Params::LMiscUtilFuncLibrary_IsLiquidSurface Parms{};

	Parms.PhysicalSurfaceType = PhysicalSurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.IsNearPC
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::IsNearPC(class UObject* WorldContextObject, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "IsNearPC");

	Params::LMiscUtilFuncLibrary_IsNearPC Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.IsPCInBox
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBoxComponent*                    Box                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::IsPCInBox(const class UObject* WorldContextObject, class UBoxComponent* Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "IsPCInBox");

	Params::LMiscUtilFuncLibrary_IsPCInBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Box = Box;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.IsRightAcceptButton
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::IsRightAcceptButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "IsRightAcceptButton");

	Params::LMiscUtilFuncLibrary_IsRightAcceptButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.IsValidEventCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ConditionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::IsValidEventCondition(class FName ConditionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "IsValidEventCondition");

	Params::LMiscUtilFuncLibrary_IsValidEventCondition Parms{};

	Parms.ConditionName = ConditionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.LoadAndAddComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             TargetComponentClass                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* ULMiscUtilFuncLibrary::LoadAndAddComponent(class AActor* TargetActor, TSoftClassPtr<class UClass> TargetComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "LoadAndAddComponent");

	Params::LMiscUtilFuncLibrary_LoadAndAddComponent Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetComponentClass = TargetComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.LoadAndAttachToComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  AttachTargetComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             TargetComponentClass                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ULMiscUtilFuncLibrary::LoadAndAttachToComponent(class USceneComponent* AttachTargetComponent, TSoftClassPtr<class UClass> TargetComponentClass, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "LoadAndAttachToComponent");

	Params::LMiscUtilFuncLibrary_LoadAndAttachToComponent Parms{};

	Parms.AttachTargetComponent = AttachTargetComponent;
	Parms.TargetComponentClass = TargetComponentClass;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.LogBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          LogInstigator                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowScreen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShowScreenDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::LogBP(class UObject* WorldContextObject, const class FString& Msg, class UObject* LogInstigator, bool ShowScreen, float ShowScreenDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "LogBP");

	Params::LMiscUtilFuncLibrary_LogBP Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Msg = std::move(Msg);
	Parms.LogInstigator = LogInstigator;
	Parms.ShowScreen = ShowScreen;
	Parms.ShowScreenDuration = ShowScreenDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.LogForWarningBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          LogInstigator                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowScreen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShowScreenDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::LogForWarningBP(class UObject* WorldContextObject, const class FString& Msg, class UObject* LogInstigator, bool ShowScreen, float ShowScreenDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "LogForWarningBP");

	Params::LMiscUtilFuncLibrary_LogForWarningBP Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Msg = std::move(Msg);
	Parms.LogInstigator = LogInstigator;
	Parms.ShowScreen = ShowScreen;
	Parms.ShowScreenDuration = ShowScreenDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.MessagePump
// (Final, Native, Static, Public, BlueprintCallable)

void ULMiscUtilFuncLibrary::MessagePump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "MessagePump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayCameraShake
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TableCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Epicenter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::PlayCameraShake(class UObject* WorldContextObject, class FName TableCodeName, const struct FVector& Epicenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayCameraShake");

	Params::LMiscUtilFuncLibrary_PlayCameraShake Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TableCodeName = TableCodeName;
	Parms.Epicenter = std::move(Epicenter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayCharacterSoundAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CharacterSoundTypeCodeName                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ULMiscUtilFuncLibrary::PlayCharacterSoundAtLocation(const class UObject* WorldContextObject, class FName EventName, class FName CharacterSoundTypeCodeName, const struct FTransform& SpawnTransform, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayCharacterSoundAtLocation");

	Params::LMiscUtilFuncLibrary_PlayCharacterSoundAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = EventName;
	Parms.CharacterSoundTypeCodeName = CharacterSoundTypeCodeName;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayCharacterSoundAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CharacterSoundTypeCodeName                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ULMiscUtilFuncLibrary::PlayCharacterSoundAttached(class FName EventName, class FName CharacterSoundTypeCodeName, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayCharacterSoundAttached");

	Params::LMiscUtilFuncLibrary_PlayCharacterSoundAttached Parms{};

	Parms.EventName = EventName;
	Parms.CharacterSoundTypeCodeName = CharacterSoundTypeCodeName;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayExplosiveKillFx
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     TargetFxSocketArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::PlayExplosiveKillFx(class AActor* TargetActor, class FName EventName, class FName Attribute, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, const TArray<class FName>& TargetFxSocketArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayExplosiveKillFx");

	Params::LMiscUtilFuncLibrary_PlayExplosiveKillFx Parms{};

	Parms.TargetActor = TargetActor;
	Parms.EventName = EventName;
	Parms.Attribute = Attribute;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.TargetFxSocketArray = std::move(TargetFxSocketArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayFxCommon_Attach
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayFx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlaySound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAttachedEffectSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLAttachedEffectSet ULMiscUtilFuncLibrary::PlayFxCommon_Attach(class AActor* TargetActor, class FName EventName, class FName SocketName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy, bool bPlayFx, bool bPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayFxCommon_Attach");

	Params::LMiscUtilFuncLibrary_PlayFxCommon_Attach Parms{};

	Parms.TargetActor = TargetActor;
	Parms.EventName = EventName;
	Parms.SocketName = SocketName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.bPlayFx = bPlayFx;
	Parms.bPlaySound = bPlaySound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayFxCommon_Location
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayFx                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlaySound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PlayFxCommon_Location(class AActor* TargetActor, class FName EventName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, float VolumeMultiplier, bool bPlayFx, bool bPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayFxCommon_Location");

	Params::LMiscUtilFuncLibrary_PlayFxCommon_Location Parms{};

	Parms.TargetActor = TargetActor;
	Parms.EventName = EventName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.bPlayFx = bPlayFx;
	Parms.bPlaySound = bPlaySound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayHitFx
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitFXType                             InHitFxType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitFX_SecondaryType                   InSecondType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InAttackerMaterial                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSwingPowerType                        InPower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFxVictimType                          VictimType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::PlayHitFx(class UObject* WorldContextObject, class AActor* Victim, ELHitFXType InHitFxType, ELHitFX_SecondaryType InSecondType, ELPhysicalSurfaceType InAttackerMaterial, class FName Attribute, ELSwingPowerType InPower, ELFxVictimType VictimType, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayHitFx");

	Params::LMiscUtilFuncLibrary_PlayHitFx Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Victim = Victim;
	Parms.InHitFxType = InHitFxType;
	Parms.InSecondType = InSecondType;
	Parms.InAttackerMaterial = InAttackerMaterial;
	Parms.Attribute = Attribute;
	Parms.InPower = InPower;
	Parms.VictimType = VictimType;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayHitFxAttached
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToAttach                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitFXType                             InHitFxType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitFX_SecondaryType                   InSecondType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InAttackerMaterial                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSwingPowerType                        InPower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFxVictimType                          VictimType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::PlayHitFxAttached(class AActor* ActorToAttach, ELHitFXType InHitFxType, ELHitFX_SecondaryType InSecondType, ELPhysicalSurfaceType InAttackerMaterial, class FName Attribute, ELSwingPowerType InPower, ELFxVictimType VictimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayHitFxAttached");

	Params::LMiscUtilFuncLibrary_PlayHitFxAttached Parms{};

	Parms.ActorToAttach = ActorToAttach;
	Parms.InHitFxType = InHitFxType;
	Parms.InSecondType = InSecondType;
	Parms.InAttackerMaterial = InAttackerMaterial;
	Parms.Attribute = Attribute;
	Parms.InPower = InPower;
	Parms.VictimType = VictimType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayHitSFX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitSoundType                          InHitSoundType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELHitSound_SecondaryType                InSecondType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Attribute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InAttackerMaterial                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InPhysicalSurface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSwingPowerType                        InPower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFxVictimType                          VictimType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlay2DSound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::PlayHitSFX(class UObject* WorldContextObject, ELHitSoundType InHitSoundType, ELHitSound_SecondaryType InSecondType, class FName Attribute, ELPhysicalSurfaceType InAttackerMaterial, ELPhysicalSurfaceType InPhysicalSurface, ELSwingPowerType InPower, ELFxVictimType VictimType, const struct FTransform& SpawnTransform, float VolumeMultiplier, float PitchMultiplier, class AActor* OwningActor, bool bPlay2DSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayHitSFX");

	Params::LMiscUtilFuncLibrary_PlayHitSFX Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InHitSoundType = InHitSoundType;
	Parms.InSecondType = InSecondType;
	Parms.Attribute = Attribute;
	Parms.InAttackerMaterial = InAttackerMaterial;
	Parms.InPhysicalSurface = InPhysicalSurface;
	Parms.InPower = InPower;
	Parms.VictimType = VictimType;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.OwningActor = OwningActor;
	Parms.bPlay2DSound = bPlay2DSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceFxAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceFXConditionType        InCondition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* ULMiscUtilFuncLibrary::PlayPhysicalSurfaceFxAtLocation(const class UObject* WorldContextObject, class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, const struct FTransform& SpawnTransform, bool bAutoDestroy, class AActor* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayPhysicalSurfaceFxAtLocation");

	Params::LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = EventName;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.InCondition = InCondition;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceFxAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceFXConditionType        InCondition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* ULMiscUtilFuncLibrary::PlayPhysicalSurfaceFxAttached(class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayPhysicalSurfaceFxAttached");

	Params::LMiscUtilFuncLibrary_PlayPhysicalSurfaceFxAttached Parms{};

	Parms.EventName = EventName;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.InCondition = InCondition;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceSoundAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceFXConditionType        InCondition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   CurveValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ULMiscUtilFuncLibrary::PlayPhysicalSurfaceSoundAtLocation(const class UObject* WorldContextObject, class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, const struct FTransform& SpawnTransform, float CurveValue, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayPhysicalSurfaceSoundAtLocation");

	Params::LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = EventName;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.InCondition = InCondition;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CurveValue = CurveValue;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayPhysicalSurfaceSoundAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceFXConditionType        InCondition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurveValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ULMiscUtilFuncLibrary::PlayPhysicalSurfaceSoundAttached(class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float CurveValue, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayPhysicalSurfaceSoundAttached");

	Params::LMiscUtilFuncLibrary_PlayPhysicalSurfaceSoundAttached Parms{};

	Parms.EventName = EventName;
	Parms.PhysicalSurface = PhysicalSurface;
	Parms.InCondition = InCondition;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.CurveValue = CurveValue;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayRepulseFx
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PlayRepulseFx(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayRepulseFx");

	Params::LMiscUtilFuncLibrary_PlayRepulseFx Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AttackerMaterial = AttackerMaterial;
	Parms.GroundMaterial = GroundMaterial;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlayRepulseSound
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   VolumeModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchModifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PlayRepulseSound(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform, float VolumeModifier, float PitchModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlayRepulseSound");

	Params::LMiscUtilFuncLibrary_PlayRepulseSound Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AttackerMaterial = AttackerMaterial;
	Parms.GroundMaterial = GroundMaterial;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.VolumeModifier = VolumeModifier;
	Parms.PitchModifier = PitchModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlaySmashFX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InAttackMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   InGroundMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSwingPowerType                        InPower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::PlaySmashFX(class UObject* WorldContextObject, ELPhysicalSurfaceType InAttackMaterial, ELPhysicalSurfaceType InGroundMaterial, ELSwingPowerType InPower, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlaySmashFX");

	Params::LMiscUtilFuncLibrary_PlaySmashFX Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InAttackMaterial = InAttackMaterial;
	Parms.InGroundMaterial = InGroundMaterial;
	Parms.InPower = InPower;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlaySparkFx
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PlaySparkFx(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlaySparkFx");

	Params::LMiscUtilFuncLibrary_PlaySparkFx Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AttackerMaterial = AttackerMaterial;
	Parms.GroundMaterial = GroundMaterial;
	Parms.SpawnTransform = std::move(SpawnTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlaySparkSound
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   AttackerMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELPhysicalSurfaceType                   GroundMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   VolumeModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchModifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PlaySparkSound(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform, float VolumeModifier, float PitchModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlaySparkSound");

	Params::LMiscUtilFuncLibrary_PlaySparkSound Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AttackerMaterial = AttackerMaterial;
	Parms.GroundMaterial = GroundMaterial;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.VolumeModifier = VolumeModifier;
	Parms.PitchModifier = PitchModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PlaySwingSFX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  OutSwingSfxComponent                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  OutEnchantSfxComponent                                 (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  TargetComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSkillMotionType                       InMotionType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSwingPowerType                        InPower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELAbnormalEnchantType                   InEnchantType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetSocketName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OffsetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPcSound                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PlaySwingSFX(class UAudioComponent** OutSwingSfxComponent, class UAudioComponent** OutEnchantSfxComponent, class USceneComponent* TargetComponent, class FName InCodeName, ELSkillMotionType InMotionType, ELSwingPowerType InPower, ELAbnormalEnchantType InEnchantType, class FName TargetSocketName, const struct FVector& OffsetLocation, float VolumeMultiplier, float PitchMultiplier, bool IsPcSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PlaySwingSFX");

	Params::LMiscUtilFuncLibrary_PlaySwingSFX Parms{};

	Parms.TargetComponent = TargetComponent;
	Parms.InCodeName = InCodeName;
	Parms.InMotionType = InMotionType;
	Parms.InPower = InPower;
	Parms.InEnchantType = InEnchantType;
	Parms.TargetSocketName = TargetSocketName;
	Parms.OffsetLocation = std::move(OffsetLocation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.IsPcSound = IsPcSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSwingSfxComponent != nullptr)
		*OutSwingSfxComponent = Parms.OutSwingSfxComponent;

	if (OutEnchantSfxComponent != nullptr)
		*OutEnchantSfxComponent = Parms.OutEnchantSfxComponent;
}


// Function ProjectP.LMiscUtilFuncLibrary.PrintActionGroupPathAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionGroupCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PrintActionGroupPathAssets(class FName ActionGroupCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PrintActionGroupPathAssets");

	Params::LMiscUtilFuncLibrary_PrintActionGroupPathAssets Parms{};

	Parms.ActionGroupCodeName = ActionGroupCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.PrintNPCLoadAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             NPCCodeName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::PrintNPCLoadAssets(class FName NPCCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "PrintNPCLoadAssets");

	Params::LMiscUtilFuncLibrary_PrintNPCLoadAssets Parms{};

	Parms.NPCCodeName = NPCCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.ProjectWorldToScreenNormalized
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          WorldPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D ULMiscUtilFuncLibrary::ProjectWorldToScreenNormalized(const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "ProjectWorldToScreenNormalized");

	Params::LMiscUtilFuncLibrary_ProjectWorldToScreenNormalized Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.Proto_EquipSubWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             HandleCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BladeCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULMiscUtilFuncLibrary::Proto_EquipSubWeapon(class FName HandleCodeName, class FName BladeCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "Proto_EquipSubWeapon");

	Params::LMiscUtilFuncLibrary_Proto_EquipSubWeapon Parms{};

	Parms.HandleCodeName = HandleCodeName;
	Parms.BladeCodeName = BladeCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.Proto_GetSubWeapon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ULMiscUtilFuncLibrary::Proto_GetSubWeapon(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "Proto_GetSubWeapon");

	Params::LMiscUtilFuncLibrary_Proto_GetSubWeapon Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.Proto_GetSubWeaponIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULMiscUtilFuncLibrary::Proto_GetSubWeaponIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "Proto_GetSubWeaponIndex");

	Params::LMiscUtilFuncLibrary_Proto_GetSubWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.Proto_ResetSubWeapon
// (Final, Native, Static, Public, BlueprintCallable)

void ULMiscUtilFuncLibrary::Proto_ResetSubWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "Proto_ResetSubWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.RemovePostProcessMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPostProcessComponent*            PostProcessComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         MaterialInstnaceDynamic                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::RemovePostProcessMaterial(class UPostProcessComponent* PostProcessComponent, class UMaterialInstanceDynamic* MaterialInstnaceDynamic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "RemovePostProcessMaterial");

	Params::LMiscUtilFuncLibrary_RemovePostProcessMaterial Parms{};

	Parms.PostProcessComponent = PostProcessComponent;
	Parms.MaterialInstnaceDynamic = MaterialInstnaceDynamic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_AudioListenerPositionComponent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::SetAudioListenerPosition_AudioListenerPositionComponent(const struct FVector& Offset, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SetAudioListenerPosition_AudioListenerPositionComponent");

	Params::LMiscUtilFuncLibrary_SetAudioListenerPosition_AudioListenerPositionComponent Parms{};

	Parms.Offset = std::move(Offset);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_Camera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::SetAudioListenerPosition_Camera(const struct FVector& Offset, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SetAudioListenerPosition_Camera");

	Params::LMiscUtilFuncLibrary_SetAudioListenerPosition_Camera Parms{};

	Parms.Offset = std::move(Offset);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_Character
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::SetAudioListenerPosition_Character(float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SetAudioListenerPosition_Character");

	Params::LMiscUtilFuncLibrary_SetAudioListenerPosition_Character Parms{};

	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_CustomLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LerpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMiscUtilFuncLibrary::SetAudioListenerPosition_CustomLocation(const struct FVector& Location, float LerpDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SetAudioListenerPosition_CustomLocation");

	Params::LMiscUtilFuncLibrary_SetAudioListenerPosition_CustomLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.LerpDuration = LerpDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.SetAudioListenerPosition_StatRoom
// (Final, Native, Static, Public, BlueprintCallable)

void ULMiscUtilFuncLibrary::SetAudioListenerPosition_StatRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SetAudioListenerPosition_StatRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMiscUtilFuncLibrary.SetupMainCamera
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::SetupMainCamera(class ACharacter* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SetupMainCamera");

	Params::LMiscUtilFuncLibrary_SetupMainCamera Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.SpawnForceFeedbackAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IntensityMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackAttenuation*        AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackComponent* ULMiscUtilFuncLibrary::SpawnForceFeedbackAtLocation(const class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SpawnForceFeedbackAtLocation");

	Params::LMiscUtilFuncLibrary_SpawnForceFeedbackAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.SpawnForceFeedbackAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IntensityMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackAttenuation*        AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackComponent* ULMiscUtilFuncLibrary::SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SpawnForceFeedbackAttached");

	Params::LMiscUtilFuncLibrary_SpawnForceFeedbackAttached Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.SpawnMaterialVaryingDecalAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULMaterialVarying*                InMaterialVarying                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELMaterialVaryingPlayType               InPlayType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DecalSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ULDecalComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULDecalComponent* ULMiscUtilFuncLibrary::SpawnMaterialVaryingDecalAtLocation(const class UObject* WorldContextObject, class ULMaterialVarying* InMaterialVarying, ELMaterialVaryingPlayType InPlayType, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SpawnMaterialVaryingDecalAtLocation");

	Params::LMiscUtilFuncLibrary_SpawnMaterialVaryingDecalAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMaterialVarying = InMaterialVarying;
	Parms.InPlayType = InPlayType;
	Parms.DecalSize = std::move(DecalSize);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.SpawnSystemAttachedWithParameters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToAttach                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLNiagaraWithParameters          NiagaraWithParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* ULMiscUtilFuncLibrary::SpawnSystemAttachedWithParameters(class AActor* ActorToAttach, const struct FLNiagaraWithParameters& NiagaraWithParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SpawnSystemAttachedWithParameters");

	Params::LMiscUtilFuncLibrary_SpawnSystemAttachedWithParameters Parms{};

	Parms.ActorToAttach = ActorToAttach;
	Parms.NiagaraWithParameters = std::move(NiagaraWithParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.SpawnWindSourceAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WindSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPointWind                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          VolumeSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULWindSourceComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWindSourceComponent* ULMiscUtilFuncLibrary::SpawnWindSourceAtLocation(const class UObject* WorldContextObject, float WindSpeed, bool bPointWind, const struct FVector& VolumeSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "SpawnWindSourceAtLocation");

	Params::LMiscUtilFuncLibrary_SpawnWindSourceAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WindSpeed = WindSpeed;
	Parms.bPointWind = bPointWind;
	Parms.VolumeSize = std::move(VolumeSize);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LifeSpan = LifeSpan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.TraceForLandingOnFloor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceHalfHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ResultLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::TraceForLandingOnFloor(class UObject* WorldContext, const struct FVector& TraceLocation, float TraceHalfHeight, struct FVector* ResultLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "TraceForLandingOnFloor");

	Params::LMiscUtilFuncLibrary_TraceForLandingOnFloor Parms{};

	Parms.WorldContext = WorldContext;
	Parms.TraceLocation = std::move(TraceLocation);
	Parms.TraceHalfHeight = TraceHalfHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultLocation != nullptr)
		*ResultLocation = std::move(Parms.ResultLocation);

	return Parms.ReturnValue;
}


// Function ProjectP.LMiscUtilFuncLibrary.WasRenderedActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMiscUtilFuncLibrary::WasRenderedActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LMiscUtilFuncLibrary", "WasRenderedActor");

	Params::LMiscUtilFuncLibrary_WasRenderedActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMovieSystem.DeactivatePauseOnReachedEnd
// (Final, Native, Public, BlueprintCallable)

void ULMovieSystem::DeactivatePauseOnReachedEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "DeactivatePauseOnReachedEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.ExecutePlayBinkMovie
// (Final, Native, Protected)

void ULMovieSystem::ExecutePlayBinkMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "ExecutePlayBinkMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.OnMediaClosed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMovieSystem::OnMediaClosed(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "OnMediaClosed");

	Params::LMovieSystem_OnMediaClosed Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.OnMediaOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMovieSystem::OnMediaOpened(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "OnMediaOpened");

	Params::LMovieSystem_OnMediaOpened Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.OnMediaPauseOnReachedEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMovieSystem::OnMediaPauseOnReachedEnd(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "OnMediaPauseOnReachedEnd");

	Params::LMovieSystem_OnMediaPauseOnReachedEnd Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.OnMediaReachedEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMovieSystem::OnMediaReachedEnd(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "OnMediaReachedEnd");

	Params::LMovieSystem_OnMediaReachedEnd Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.PlayBinkMovie
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULMovieSystem::PlayBinkMovie(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "PlayBinkMovie");

	Params::LMovieSystem_PlayBinkMovie Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LMovieSystem.SkipBinkMovie
// (Final, Native, Public, BlueprintCallable)

void ULMovieSystem::SkipBinkMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "SkipBinkMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LMovieSystem.StopBinkMovie
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MovieCodeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULMovieSystem::StopBinkMovie(class FName MovieCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LMovieSystem", "StopBinkMovie");

	Params::LMovieSystem_StopBinkMovie Parms{};

	Parms.MovieCodeName = MovieCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCController.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCController*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALNPCController* ALNPCController::Get(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LNPCController", "Get");

	Params::LNPCController_Get Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCController.DeadCharacterBP
// (Event, Public, BlueprintEvent)

void ALNPCController::DeadCharacterBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "DeadCharacterBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCController.EndCombatState
// (Final, Native, Public, BlueprintCallable)

void ALNPCController::EndCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "EndCombatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCController.GetCheckSkillUseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALNPCController::GetCheckSkillUseCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "GetCheckSkillUseCount");

	Params::LNPCController_GetCheckSkillUseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCController.IsCombatState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCController::IsCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "IsCombatState");

	Params::LNPCController_IsCombatState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LNPCController.OnRespawnBP
// (Event, Public, BlueprintEvent)

void ALNPCController::OnRespawnBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "OnRespawnBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LNPCController.ResetBBKeys
// (Final, Native, Public, BlueprintCallable)

void ALNPCController::ResetBBKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "ResetBBKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCController.RunInitBehaviorTree
// (Event, Public, BlueprintEvent)
// Parameters:
// class UBehaviorTree*                    CustomBehaviroTree                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCController::RunInitBehaviorTree(class UBehaviorTree* CustomBehaviroTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "RunInitBehaviorTree");

	Params::LNPCController_RunInitBehaviorTree Parms{};

	Parms.CustomBehaviroTree = CustomBehaviroTree;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LNPCController.SelectCommonActionBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             CommonActionMontageName                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutActionClassName                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULActPayloadBase*                 OutPayload                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCController::SelectCommonActionBP(const class FName& CommonActionMontageName, class FName* OutActionClassName, class ULActPayloadBase** OutPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "SelectCommonActionBP");

	Params::LNPCController_SelectCommonActionBP Parms{};

	Parms.CommonActionMontageName = CommonActionMontageName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutActionClassName != nullptr)
		*OutActionClassName = Parms.OutActionClassName;

	if (OutPayload != nullptr)
		*OutPayload = Parms.OutPayload;
}


// Function ProjectP.LNPCController.SetActivate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInActivate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALNPCController::SetActivate(bool bInActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "SetActivate");

	Params::LNPCController_SetActivate Parms{};

	Parms.bInActivate = bInActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCController.StartCombatState
// (Final, Native, Public, BlueprintCallable)

void ALNPCController::StartCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "StartCombatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LNPCController.IsActivate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALNPCController::IsActivate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LNPCController", "IsActivate");

	Params::LNPCController_IsActivate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectManagementSystem.AddRemoveFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULObjectManagementSystem::AddRemoveFlag(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "AddRemoveFlag");

	Params::LObjectManagementSystem_AddRemoveFlag Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LObjectManagementSystem.FindFiles
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSoftObjectPath>          OutObjectPaths                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                           Directory                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULObjectManagementSystem::FindFiles(TArray<struct FSoftObjectPath>* OutObjectPaths, const class FString& Directory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "FindFiles");

	Params::LObjectManagementSystem_FindFiles Parms{};

	Parms.Directory = std::move(Directory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjectPaths != nullptr)
		*OutObjectPaths = std::move(Parms.OutObjectPaths);
}


// Function ProjectP.LObjectManagementSystem.GetFluidController
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULObjectManagementSystem::GetFluidController(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "GetFluidController");

	Params::LObjectManagementSystem_GetFluidController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectManagementSystem.GetGoldenTree
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULGoldenTree*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULGoldenTree* ULObjectManagementSystem::GetGoldenTree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "GetGoldenTree");

	Params::LObjectManagementSystem_GetGoldenTree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectManagementSystem.GetPlayerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALPCCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALPCCharacter* ULObjectManagementSystem::GetPlayerCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "GetPlayerCharacter");

	Params::LObjectManagementSystem_GetPlayerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectManagementSystem.OnSetActiveEnvironment
// (Final, Native, Private)
// Parameters:
// bool                                    bWorldActive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULObjectManagementSystem::OnSetActiveEnvironment(bool bWorldActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "OnSetActiveEnvironment");

	Params::LObjectManagementSystem_OnSetActiveEnvironment Parms{};

	Parms.bWorldActive = bWorldActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LObjectManagementSystem.SetFluidController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULObjectManagementSystem::SetFluidController(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "SetFluidController");

	Params::LObjectManagementSystem_SetFluidController Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LObjectManagementSystem.SpawnDestructionObject
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             DestructionObjectCodeName                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTraceAndLandingOnFloor                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALDestructionObject*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALDestructionObject* ULObjectManagementSystem::SpawnDestructionObject(class FName DestructionObjectCodeName, const struct FTransform& SpawnTransform, bool bTraceAndLandingOnFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "SpawnDestructionObject");

	Params::LObjectManagementSystem_SpawnDestructionObject Parms{};

	Parms.DestructionObjectCodeName = DestructionObjectCodeName;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.bTraceAndLandingOnFloor = bTraceAndLandingOnFloor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectManagementSystem.SpawnNPC
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             NPCCodeName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTraceAndLandingOnFloor                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SpawnIdleActionGroupCodeName                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALNPCCharacter*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALNPCCharacter* ULObjectManagementSystem::SpawnNPC(class FName NPCCodeName, const struct FTransform& SpawnTransform, bool bTraceAndLandingOnFloor, class FName SpawnIdleActionGroupCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "SpawnNPC");

	Params::LObjectManagementSystem_SpawnNPC Parms{};

	Parms.NPCCodeName = NPCCodeName;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.bTraceAndLandingOnFloor = bTraceAndLandingOnFloor;
	Parms.SpawnIdleActionGroupCodeName = SpawnIdleActionGroupCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectManagementSystem.FindNPCCharactersAround
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             NPCCodeName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AroundDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ALNPCCharacter*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ALNPCCharacter*> ULObjectManagementSystem::FindNPCCharactersAround(class FName NPCCodeName, float AroundDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectManagementSystem", "FindNPCCharactersAround");

	Params::LObjectManagementSystem_FindNPCCharactersAround Parms{};

	Parms.NPCCodeName = NPCCodeName;
	Parms.AroundDistance = AroundDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPoolingObjectManager.Clear
// (Final, Native, Public, BlueprintCallable)

void ULPoolingObjectManager::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPoolingObjectManager", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPoolingObjectManager.CreateObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ObjectClassPtr                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateOnlySurplusAmount                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPoolingObjectManager::CreateObjects(class UObject* WorldContext, TSoftClassPtr<class UClass> ObjectClassPtr, int32 Count, bool bCreateOnlySurplusAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPoolingObjectManager", "CreateObjects");

	Params::LPoolingObjectManager_CreateObjects Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ObjectClassPtr = ObjectClassPtr;
	Parms.Count = Count;
	Parms.bCreateOnlySurplusAmount = bCreateOnlySurplusAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPoolingObjectManager.CreateWidgets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             WidgetClassPtr                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCreateOnlySurplusAmount                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPoolingObjectManager::CreateWidgets(class UObject* WorldContext, TSoftClassPtr<class UClass> WidgetClassPtr, int32 Count, bool bCreateOnlySurplusAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPoolingObjectManager", "CreateWidgets");

	Params::LPoolingObjectManager_CreateWidgets Parms{};

	Parms.WorldContext = WorldContext;
	Parms.WidgetClassPtr = WidgetClassPtr;
	Parms.Count = Count;
	Parms.bCreateOnlySurplusAmount = bCreateOnlySurplusAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPoolingObjectManager.GetRecyclableObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ObjectClassPtr                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ULPoolingObjectManager::GetRecyclableObject(class UObject* WorldContext, TSoftClassPtr<class UClass> ObjectClassPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPoolingObjectManager", "GetRecyclableObject");

	Params::LPoolingObjectManager_GetRecyclableObject Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ObjectClassPtr = ObjectClassPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPoolingObjectManager.ReturnToRecyclingBin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          TargetObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPoolingObjectManager::ReturnToRecyclingBin(class UObject* WorldContext, class UObject* TargetObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPoolingObjectManager", "ReturnToRecyclingBin");

	Params::LPoolingObjectManager_ReturnToRecyclingBin Parms{};

	Parms.WorldContext = WorldContext;
	Parms.TargetObject = TargetObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPoolingObjectManager.ShrinkRecyclingBin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ObjectClassPtr                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPoolingObjectManager::ShrinkRecyclingBin(class UObject* WorldContext, TSoftClassPtr<class UClass> ObjectClassPtr, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPoolingObjectManager", "ShrinkRecyclingBin");

	Params::LPoolingObjectManager_ShrinkRecyclingBin Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ObjectClassPtr = ObjectClassPtr;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LObjectPoolSystem.CreateNewRecyclables
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             RecyclablesClass                                       (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULObjectPoolSystem::CreateNewRecyclables(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "CreateNewRecyclables");

	Params::LObjectPoolSystem_CreateNewRecyclables Parms{};

	Parms.WorldContext = WorldContext;
	Parms.RecyclablesClass = RecyclablesClass;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectPoolSystem.GetRecyclables
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             RecyclablesClass                                       (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULObjectPoolSystem::GetRecyclables(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "GetRecyclables");

	Params::LObjectPoolSystem_GetRecyclables Parms{};

	Parms.WorldContext = WorldContext;
	Parms.RecyclablesClass = RecyclablesClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectPoolSystem.GetSystemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ALObjectPoolSystemData*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ALObjectPoolSystemData* ULObjectPoolSystem::GetSystemData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "GetSystemData");

	Params::LObjectPoolSystem_GetSystemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectPoolSystem.ResizeRecyclingBin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             RecyclablesClass                                       (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DesiredSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULObjectPoolSystem::ResizeRecyclingBin(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass, int32 DesiredSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "ResizeRecyclingBin");

	Params::LObjectPoolSystem_ResizeRecyclingBin Parms{};

	Parms.WorldContext = WorldContext;
	Parms.RecyclablesClass = RecyclablesClass;
	Parms.DesiredSize = DesiredSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectPoolSystem.ReturnToRecyclingBin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULObjectPoolSystem::ReturnToRecyclingBin(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "ReturnToRecyclingBin");

	Params::LObjectPoolSystem_ReturnToRecyclingBin Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectPoolSystem.ShrinkRecyclingBin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             RecyclablesClass                                       (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DesiredSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULObjectPoolSystem::ShrinkRecyclingBin(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass, int32 DesiredSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "ShrinkRecyclingBin");

	Params::LObjectPoolSystem_ShrinkRecyclingBin Parms{};

	Parms.WorldContext = WorldContext;
	Parms.RecyclablesClass = RecyclablesClass;
	Parms.DesiredSize = DesiredSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LObjectPoolSystem.GetSizeOfRecyclingBin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             RecyclablesClass                                       (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULObjectPoolSystem::GetSizeOfRecyclingBin(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LObjectPoolSystem", "GetSizeOfRecyclingBin");

	Params::LObjectPoolSystem_GetSizeOfRecyclingBin Parms{};

	Parms.WorldContext = WorldContext;
	Parms.RecyclablesClass = RecyclablesClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.ApplyCameraOptionMultiply
// (Final, Native, Public)
// Parameters:
// ECameraDirectOption                     InOptionType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsPad                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCameraOption::ApplyCameraOptionMultiply(ECameraDirectOption InOptionType, bool InIsPad, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "ApplyCameraOptionMultiply");

	Params::LCameraOption_ApplyCameraOptionMultiply Parms{};

	Parms.InOptionType = InOptionType;
	Parms.InIsPad = InIsPad;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraOption.GetMoveSpeedStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELInputOptionType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULCameraOption::GetMoveSpeedStep(ECameraDirectOption InRotator, ELInputOptionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "GetMoveSpeedStep");

	Params::LCameraOption_GetMoveSpeedStep Parms{};

	Parms.InRotator = InRotator;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.IsEnableAlignmentToCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::IsEnableAlignmentToCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "IsEnableAlignmentToCamera");

	Params::LCameraOption_IsEnableAlignmentToCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.IsEnableCameraShake
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::IsEnableCameraShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "IsEnableCameraShake");

	Params::LCameraOption_IsEnableCameraShake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.IsEnableMoveCameraUpDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::IsEnableMoveCameraUpDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "IsEnableMoveCameraUpDown");

	Params::LCameraOption_IsEnableMoveCameraUpDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.IsInvertMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELInputOptionType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::IsInvertMove(ECameraDirectOption InRotator, ELInputOptionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "IsInvertMove");

	Params::LCameraOption_IsInvertMove Parms{};

	Parms.InRotator = InRotator;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.OnChangedInputMode
// (Final, Native, Public)
// Parameters:
// bool                                    bGamePad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULCameraOption::OnChangedInputMode(bool bGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "OnChangedInputMode");

	Params::LCameraOption_OnChangedInputMode Parms{};

	Parms.bGamePad = bGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LCameraOption.SetEnableAlignmentToCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::SetEnableAlignmentToCamera(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "SetEnableAlignmentToCamera");

	Params::LCameraOption_SetEnableAlignmentToCamera Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.SetEnableCameraShake
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::SetEnableCameraShake(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "SetEnableCameraShake");

	Params::LCameraOption_SetEnableCameraShake Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.SetEnableMoveCameraUpDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::SetEnableMoveCameraUpDown(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "SetEnableMoveCameraUpDown");

	Params::LCameraOption_SetEnableMoveCameraUpDown Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.SetInvertMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELInputOptionType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::SetInvertMove(ECameraDirectOption InRotator, bool InInvert, ELInputOptionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "SetInvertMove");

	Params::LCameraOption_SetInvertMove Parms{};

	Parms.InRotator = InRotator;
	Parms.InInvert = InInvert;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LCameraOption.SetMoveSpeedStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELInputOptionType                       InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULCameraOption::SetMoveSpeedStep(ECameraDirectOption InRotator, int32 InStep, ELInputOptionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LCameraOption", "SetMoveSpeedStep");

	Params::LCameraOption_SetMoveSpeedStep Parms{};

	Parms.InRotator = InRotator;
	Parms.InStep = InStep;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.AutoScalabilityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::AutoScalabilityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "AutoScalabilityLevel");

	Params::LGraphicOption_AutoScalabilityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCACAOEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::GetCACAOEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCACAOEnabled");

	Params::LGraphicOption_GetCACAOEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGraphicOption::GetCurrentBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentBrightness");

	Params::LGraphicOption_GetCurrentBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentDLSSMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDLSSMode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDLSSMode ULGraphicOption::GetCurrentDLSSMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentDLSSMode");

	Params::LGraphicOption_GetCurrentDLSSMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentDLSSSharpness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGraphicOption::GetCurrentDLSSSharpness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentDLSSSharpness");

	Params::LGraphicOption_GetCurrentDLSSSharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentFSR1Mode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFSR1Mode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFSR1Mode ULGraphicOption::GetCurrentFSR1Mode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentFSR1Mode");

	Params::LGraphicOption_GetCurrentFSR1Mode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentFSR2Mode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFSR2Mode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFSR2Mode ULGraphicOption::GetCurrentFSR2Mode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentFSR2Mode");

	Params::LGraphicOption_GetCurrentFSR2Mode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentFSR2Sharpness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGraphicOption::GetCurrentFSR2Sharpness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentFSR2Sharpness");

	Params::LGraphicOption_GetCurrentFSR2Sharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentHDRBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGraphicOption::GetCurrentHDRBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentHDRBrightness");

	Params::LGraphicOption_GetCurrentHDRBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentHDRContrast
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGraphicOption::GetCurrentHDRContrast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentHDRContrast");

	Params::LGraphicOption_GetCurrentHDRContrast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentPlayStyleOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayStyleOption                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayStyleOption ULGraphicOption::GetCurrentPlayStyleOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentPlayStyleOption");

	Params::LGraphicOption_GetCurrentPlayStyleOption Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentReflexMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EReflexMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EReflexMode ULGraphicOption::GetCurrentReflexMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentReflexMode");

	Params::LGraphicOption_GetCurrentReflexMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint ULGraphicOption::GetCurrentScreenResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentScreenResolution");

	Params::LGraphicOption_GetCurrentScreenResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentXeSSMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EXeSSMode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EXeSSMode ULGraphicOption::GetCurrentXeSSMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentXeSSMode");

	Params::LGraphicOption_GetCurrentXeSSMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetDetailScalability
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EScalabilityType                        InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELScalabilityDefaultLevel               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELScalabilityDefaultLevel ULGraphicOption::GetDetailScalability(EScalabilityType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetDetailScalability");

	Params::LGraphicOption_GetDetailScalability Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetDLSSGEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::GetDLSSGEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetDLSSGEnabled");

	Params::LGraphicOption_GetDLSSGEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetFrameRateLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULGraphicOption::GetFrameRateLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetFrameRateLimit");

	Params::LGraphicOption_GetFrameRateLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode ULGraphicOption::GetFullscreenMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetFullscreenMode");

	Params::LGraphicOption_GetFullscreenMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetGraphicCardName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULGraphicOption::GetGraphicCardName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetGraphicCardName");

	Params::LGraphicOption_GetGraphicCardName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetScreenResolutionStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULGraphicOption::GetScreenResolutionStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetScreenResolutionStep");

	Params::LGraphicOption_GetScreenResolutionStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetSelectableScreenResolutions
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntPoint>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntPoint> ULGraphicOption::GetSelectableScreenResolutions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetSelectableScreenResolutions");

	Params::LGraphicOption_GetSelectableScreenResolutions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetSupportedDLSSModes
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<EDLSSMode>                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EDLSSMode> ULGraphicOption::GetSupportedDLSSModes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetSupportedDLSSModes");

	Params::LGraphicOption_GetSupportedDLSSModes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.Is120HzModeEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::Is120HzModeEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "Is120HzModeEnabled");

	Params::LGraphicOption_Is120HzModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.Is120HzModeSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::Is120HzModeSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "Is120HzModeSupported");

	Params::LGraphicOption_Is120HzModeSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsCACAOSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsCACAOSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsCACAOSupported");

	Params::LGraphicOption_IsCACAOSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsDLSSGAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsDLSSGAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsDLSSGAvailable");

	Params::LGraphicOption_IsDLSSGAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsDLSSGSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsDLSSGSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsDLSSGSupported");

	Params::LGraphicOption_IsDLSSGSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsDLSSModeSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDLSSMode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsDLSSModeSupported(EDLSSMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsDLSSModeSupported");

	Params::LGraphicOption_IsDLSSModeSupported Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsDLSSSharpnessAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsDLSSSharpnessAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsDLSSSharpnessAvailable");

	Params::LGraphicOption_IsDLSSSharpnessAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsDLSSSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsDLSSSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsDLSSSupported");

	Params::LGraphicOption_IsDLSSSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsFSR1Supported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsFSR1Supported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsFSR1Supported");

	Params::LGraphicOption_IsFSR1Supported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsFSR2SharpnessAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsFSR2SharpnessAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsFSR2SharpnessAvailable");

	Params::LGraphicOption_IsFSR2SharpnessAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsFSR2Supported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsFSR2Supported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsFSR2Supported");

	Params::LGraphicOption_IsFSR2Supported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsHDROutputEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsHDROutputEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsHDROutputEnabled");

	Params::LGraphicOption_IsHDROutputEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsHDROutputSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsHDROutputSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsHDROutputSupported");

	Params::LGraphicOption_IsHDROutputSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsPlayStyleOptionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsPlayStyleOptionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsPlayStyleOptionEnabled");

	Params::LGraphicOption_IsPlayStyleOptionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingAmbientOcclusionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingAmbientOcclusionEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingAmbientOcclusionEnabled");

	Params::LGraphicOption_IsRayTracingAmbientOcclusionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingGlobalIlluminationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingGlobalIlluminationEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingGlobalIlluminationEnabled");

	Params::LGraphicOption_IsRayTracingGlobalIlluminationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingReflectionsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingReflectionsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingReflectionsEnabled");

	Params::LGraphicOption_IsRayTracingReflectionsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingShadowsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingShadowsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingShadowsEnabled");

	Params::LGraphicOption_IsRayTracingShadowsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingSkyLightEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingSkyLightEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingSkyLightEnabled");

	Params::LGraphicOption_IsRayTracingSkyLightEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingSupported");

	Params::LGraphicOption_IsRayTracingSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsRayTracingTranslucencyEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsRayTracingTranslucencyEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsRayTracingTranslucencyEnabled");

	Params::LGraphicOption_IsRayTracingTranslucencyEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsReflexModeAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsReflexModeAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsReflexModeAvailable");

	Params::LGraphicOption_IsReflexModeAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsReflexSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsReflexSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsReflexSupported");

	Params::LGraphicOption_IsReflexSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsVRSEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsVRSEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsVRSEnabled");

	Params::LGraphicOption_IsVRSEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsVRSSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsVRSSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsVRSSupported");

	Params::LGraphicOption_IsVRSSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsVSyncEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsVSyncEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsVSyncEnabled");

	Params::LGraphicOption_IsVSyncEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.IsXeSSSupported
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::IsXeSSSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "IsXeSSSupported");

	Params::LGraphicOption_IsXeSSSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.Set120HzModeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::Set120HzModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "Set120HzModeEnabled");

	Params::LGraphicOption_Set120HzModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetCACAOEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetCACAOEnabled(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetCACAOEnabled");

	Params::LGraphicOption_SetCACAOEnabled Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetCurrentBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InBrightness                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetCurrentBrightness(int32 InBrightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetCurrentBrightness");

	Params::LGraphicOption_SetCurrentBrightness Parms{};

	Parms.InBrightness = InBrightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetCurrentHDRBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InBrightness                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetCurrentHDRBrightness(int32 InBrightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetCurrentHDRBrightness");

	Params::LGraphicOption_SetCurrentHDRBrightness Parms{};

	Parms.InBrightness = InBrightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetCurrentHDRContrast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InContrast                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetCurrentHDRContrast(int32 InContrast)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetCurrentHDRContrast");

	Params::LGraphicOption_SetCurrentHDRContrast Parms{};

	Parms.InContrast = InContrast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetDetailScalability
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EScalabilityType                        InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELScalabilityDefaultLevel               InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetDetailScalability(const EScalabilityType InType, ELScalabilityDefaultLevel InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetDetailScalability");

	Params::LGraphicOption_SetDetailScalability Parms{};

	Parms.InType = InType;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetDLSSGEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetDLSSGEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetDLSSGEnabled");

	Params::LGraphicOption_SetDLSSGEnabled Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetDLSSMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDLSSMode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetDLSSMode(EDLSSMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetDLSSMode");

	Params::LGraphicOption_SetDLSSMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetDLSSSharpness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSharpness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetDLSSSharpness(float InSharpness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetDLSSSharpness");

	Params::LGraphicOption_SetDLSSSharpness Parms{};

	Parms.InSharpness = InSharpness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetFrameRateLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFrameratelimit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetFrameRateLimit(float InFrameratelimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetFrameRateLimit");

	Params::LGraphicOption_SetFrameRateLimit Parms{};

	Parms.InFrameratelimit = InFrameratelimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetFSR1Mode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFSR1Mode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetFSR1Mode(EFSR1Mode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetFSR1Mode");

	Params::LGraphicOption_SetFSR1Mode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetFSR2Mode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFSR2Mode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetFSR2Mode(EFSR2Mode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetFSR2Mode");

	Params::LGraphicOption_SetFSR2Mode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetFSR2Sharpness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSharpness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetFSR2Sharpness(float InSharpness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetFSR2Sharpness");

	Params::LGraphicOption_SetFSR2Sharpness Parms{};

	Parms.InSharpness = InSharpness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetFullscreenMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWindowMode                             InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetFullscreenMode(EWindowMode InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetFullscreenMode");

	Params::LGraphicOption_SetFullscreenMode Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetHDROutputEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetHDROutputEnabled(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetHDROutputEnabled");

	Params::LGraphicOption_SetHDROutputEnabled Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetPlayStyleOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayStyleOption                        InPlayStyle                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetPlayStyleOption(const EPlayStyleOption InPlayStyle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetPlayStyleOption");

	Params::LGraphicOption_SetPlayStyleOption Parms{};

	Parms.InPlayStyle = InPlayStyle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetRayTracingAmbientOcclusionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetRayTracingAmbientOcclusionEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetRayTracingAmbientOcclusionEnabled");

	Params::LGraphicOption_SetRayTracingAmbientOcclusionEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetRayTracingGlobalIlluminationEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetRayTracingGlobalIlluminationEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetRayTracingGlobalIlluminationEnabled");

	Params::LGraphicOption_SetRayTracingGlobalIlluminationEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetRayTracingReflectionsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetRayTracingReflectionsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetRayTracingReflectionsEnabled");

	Params::LGraphicOption_SetRayTracingReflectionsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetRayTracingShadowsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetRayTracingShadowsEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetRayTracingShadowsEnabled");

	Params::LGraphicOption_SetRayTracingShadowsEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetRayTracingSkyLightEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetRayTracingSkyLightEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetRayTracingSkyLightEnabled");

	Params::LGraphicOption_SetRayTracingSkyLightEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetRayTracingTranslucencyEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetRayTracingTranslucencyEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetRayTracingTranslucencyEnabled");

	Params::LGraphicOption_SetRayTracingTranslucencyEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetReflexMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EReflexMode                             InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetReflexMode(EReflexMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetReflexMode");

	Params::LGraphicOption_SetReflexMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetScalabilityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELScalabilityLevel                      InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetScalabilityLevel(ELScalabilityLevel InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetScalabilityLevel");

	Params::LGraphicOption_SetScalabilityLevel Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetScreenResolutionStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetScreenResolutionStep(int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetScreenResolutionStep");

	Params::LGraphicOption_SetScreenResolutionStep Parms{};

	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetVRSEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetVRSEnabled(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetVRSEnabled");

	Params::LGraphicOption_SetVRSEnabled Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetVSyncEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetVSyncEnabled(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetVSyncEnabled");

	Params::LGraphicOption_SetVSyncEnabled Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.SetXeSSMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EXeSSMode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULGraphicOption::SetXeSSMode(EXeSSMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "SetXeSSMode");

	Params::LGraphicOption_SetXeSSMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetCurrentScalabilityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELScalabilityLevel                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELScalabilityLevel ULGraphicOption::GetCurrentScalabilityLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetCurrentScalabilityLevel");

	Params::LGraphicOption_GetCurrentScalabilityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LGraphicOption.GetDesktopResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint ULGraphicOption::GetDesktopResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LGraphicOption", "GetDesktopResolution");

	Params::LGraphicOption_GetDesktopResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.GetMouseSensitivityStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULKeyboardMouseOption::GetMouseSensitivityStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "GetMouseSensitivityStep");

	Params::LKeyboardMouseOption_GetMouseSensitivityStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.GetMouseSensitivityValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULKeyboardMouseOption::GetMouseSensitivityValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "GetMouseSensitivityValue");

	Params::LKeyboardMouseOption_GetMouseSensitivityValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.GetMoveSpeedStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULKeyboardMouseOption::GetMoveSpeedStep(ECameraDirectOption InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "GetMoveSpeedStep");

	Params::LKeyboardMouseOption_GetMoveSpeedStep Parms{};

	Parms.InRotator = InRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.IsInvertMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeyboardMouseOption::IsInvertMove(ECameraDirectOption InRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "IsInvertMove");

	Params::LKeyboardMouseOption_IsInvertMove Parms{};

	Parms.InRotator = InRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.ResetEditedInputAction
// (Final, Native, Public, BlueprintCallable)

void ULKeyboardMouseOption::ResetEditedInputAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "ResetEditedInputAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LKeyboardMouseOption.SetInvertMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InInvert                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeyboardMouseOption::SetInvertMove(ECameraDirectOption InRotator, bool InInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "SetInvertMove");

	Params::LKeyboardMouseOption_SetInvertMove Parms{};

	Parms.InRotator = InRotator;
	Parms.InInvert = InInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.SetMouseSensitivityStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeyboardMouseOption::SetMouseSensitivityStep(int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "SetMouseSensitivityStep");

	Params::LKeyboardMouseOption_SetMouseSensitivityStep Parms{};

	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LKeyboardMouseOption.SetMoveSpeedStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraDirectOption                     InRotator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InStep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULKeyboardMouseOption::SetMoveSpeedStep(ECameraDirectOption InRotator, int32 InStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LKeyboardMouseOption", "SetMoveSpeedStep");

	Params::LKeyboardMouseOption_SetMoveSpeedStep Parms{};

	Parms.InRotator = InRotator;
	Parms.InStep = InStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFirstGameStartOption.GetAutoSaveAlert
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFirstGameStartOption::GetAutoSaveAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFirstGameStartOption", "GetAutoSaveAlert");

	Params::LFirstGameStartOption_GetAutoSaveAlert Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFirstGameStartOption.GetFirstBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFirstGameStartOption::GetFirstBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFirstGameStartOption", "GetFirstBrightness");

	Params::LFirstGameStartOption_GetFirstBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFirstGameStartOption.GetFirstLanguage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULFirstGameStartOption::GetFirstLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFirstGameStartOption", "GetFirstLanguage");

	Params::LFirstGameStartOption_GetFirstLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LFirstGameStartOption.OnClosedWindow
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULFirstGameStartOption::OnClosedWindow(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LFirstGameStartOption", "OnClosedWindow");

	Params::LFirstGameStartOption_OnClosedWindow Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LOptionSystem.GetLocationCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULOptionSystem::GetLocationCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "GetLocationCodeName");

	Params::LOptionSystem_GetLocationCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystem.GetNewGamePlusRound
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULOptionSystem::GetNewGamePlusRound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "GetNewGamePlusRound");

	Params::LOptionSystem_GetNewGamePlusRound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystem.GetPlayerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULOptionSystem::GetPlayerLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "GetPlayerLevel");

	Params::LOptionSystem_GetPlayerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystem.GetPlayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULOptionSystem::GetPlayTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "GetPlayTime");

	Params::LOptionSystem_GetPlayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystem.Load
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULOptionSystem::Load()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "Load");

	Params::LOptionSystem_Load Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LOptionSystem.OnInitLoadOptionGameData
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSaveGame*                       SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULOptionSystem::OnInitLoadOptionGameData(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "OnInitLoadOptionGameData");

	Params::LOptionSystem_OnInitLoadOptionGameData Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LOptionSystem.OnLoadOptionGameData
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSaveGame*                       SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULOptionSystem::OnLoadOptionGameData(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "OnLoadOptionGameData");

	Params::LOptionSystem_OnLoadOptionGameData Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LOptionSystem.OnResetSystemData
// (Final, Native, Protected)

void ULOptionSystem::OnResetSystemData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "OnResetSystemData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LOptionSystem.OnSaveOptionGameData
// (Final, Native, Protected)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELGameDataType                          GameDataType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULOptionSystem::OnSaveOptionGameData(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "OnSaveOptionGameData");

	Params::LOptionSystem_OnSaveOptionGameData Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.bSuccess = bSuccess;
	Parms.GameDataType = GameDataType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LOptionSystem.Save
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULOptionSystem::Save()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LOptionSystem", "Save");

	Params::LOptionSystem_Save Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsAnimInstance.ChangeAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AnimState_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPartsAnimInstance::ChangeAnimState(class FName AnimState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsAnimInstance", "ChangeAnimState");

	Params::LPartsAnimInstance_ChangeAnimState Parms{};

	Parms.AnimState_0 = AnimState_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsAnimInstance.ClearAnimState
// (Final, Native, Public, BlueprintCallable)

void ULPartsAnimInstance::ClearAnimState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsAnimInstance", "ClearAnimState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsComponent.BreakParts
// (Final, Native, Public, BlueprintCallable)

void ULPartsComponent::BreakParts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "BreakParts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsComponent.ChangeNextCompeleteDestructState
// (Final, Native, Public, BlueprintCallable)

void ULPartsComponent::ChangeNextCompeleteDestructState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "ChangeNextCompeleteDestructState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsComponent.ChangeNextDestructState
// (Final, Native, Public, BlueprintCallable)

void ULPartsComponent::ChangeNextDestructState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "ChangeNextDestructState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsComponent.CheckHitJudgmentAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPartsComponent::CheckHitJudgmentAngle(class AActor* Attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "CheckHitJudgmentAngle");

	Params::LPartsComponent_CheckHitJudgmentAngle Parms{};

	Parms.Attacker = Attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.CheckRepulseHitLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELPhysicalDamageType                    InPhysicalDamageType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InAttackRepulseLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPartsComponent::CheckRepulseHitLevel(ELPhysicalDamageType InPhysicalDamageType, int32 InAttackRepulseLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "CheckRepulseHitLevel");

	Params::LPartsComponent_CheckRepulseHitLevel Parms{};

	Parms.InPhysicalDamageType = InPhysicalDamageType;
	Parms.InAttackRepulseLevel = InAttackRepulseLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.GetNPCPartsInfoByDestruction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FNPCPartsInfoPtr                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FNPCPartsInfoPtr ULPartsComponent::GetNPCPartsInfoByDestruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "GetNPCPartsInfoByDestruction");

	Params::LPartsComponent_GetNPCPartsInfoByDestruction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALCharacter*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALCharacter* ULPartsComponent::GetOwnerCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "GetOwnerCharacter");

	Params::LPartsComponent_GetOwnerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.ReceiveDamage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDamaged                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestructionIndexDestoryed                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULHitProcContext*                 HitProcContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPartsComponent::ReceiveDamage(int32 Damage, bool* bDamaged, bool* bDestructionIndexDestoryed, class ULHitProcContext* HitProcContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "ReceiveDamage");

	Params::LPartsComponent_ReceiveDamage Parms{};

	Parms.Damage = Damage;
	Parms.HitProcContext = HitProcContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bDamaged != nullptr)
		*bDamaged = Parms.bDamaged;

	if (bDestructionIndexDestoryed != nullptr)
		*bDestructionIndexDestoryed = Parms.bDestructionIndexDestoryed;
}


// Function ProjectP.LPartsComponent.SetLastImpulseDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ImpulseDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPartsComponent::SetLastImpulseDirection(const struct FVector& ImpulseDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "SetLastImpulseDirection");

	Params::LPartsComponent_SetLastImpulseDirection Parms{};

	Parms.ImpulseDirection = std::move(ImpulseDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsComponent.SetPartsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPartsComponent::SetPartsEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "SetPartsEnabled");

	Params::LPartsComponent_SetPartsEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPartsComponent.GetPartsActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALPartsActor*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALPartsActor* ULPartsComponent::GetPartsActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "GetPartsActor");

	Params::LPartsComponent_GetPartsActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.GetPartsIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULPartsComponent::GetPartsIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "GetPartsIndex");

	Params::LPartsComponent_GetPartsIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.GetPartsSkillCodeNameOnDestory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULPartsComponent::GetPartsSkillCodeNameOnDestory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "GetPartsSkillCodeNameOnDestory");

	Params::LPartsComponent_GetPartsSkillCodeNameOnDestory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.IsCompleteDestruct
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPartsComponent::IsCompleteDestruct() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "IsCompleteDestruct");

	Params::LPartsComponent_IsCompleteDestruct Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.IsHitEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPartsComponent::IsHitEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "IsHitEnabled");

	Params::LPartsComponent_IsHitEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPartsComponent.IsPartsDamageToOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPartsComponent::IsPartsDamageToOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPartsComponent", "IsPartsDamageToOwner");

	Params::LPartsComponent_IsPartsDamageToOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.AttachPCLamp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALPCCharacter::AttachPCLamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "AttachPCLamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.AttachRainHitSound
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELPhysicalSurfaceType                   InPhysicalSurface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRainIntensity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPCHit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::AttachRainHitSound(ELPhysicalSurfaceType InPhysicalSurface, const struct FVector& InLocation, float InRainIntensity, bool IsPCHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "AttachRainHitSound");

	Params::LPCCharacter_AttachRainHitSound Parms{};

	Parms.InPhysicalSurface = InPhysicalSurface;
	Parms.InLocation = std::move(InLocation);
	Parms.InRainIntensity = InRainIntensity;
	Parms.IsPCHit = IsPCHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCCharacter.CheckCanResetAllFirstStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::CheckCanResetAllFirstStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "CheckCanResetAllFirstStat");

	Params::LPCCharacter_CheckCanResetAllFirstStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.CheckClearDeadInvincible
// (Final, Native, Protected)

void ALPCCharacter::CheckClearDeadInvincible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "CheckClearDeadInvincible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ConsumeFrenzyPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFrenzyConsumeReason                   ConsumeReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::ConsumeFrenzyPoint(int32 InAmount, ELFrenzyConsumeReason ConsumeReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ConsumeFrenzyPoint");

	Params::LPCCharacter_ConsumeFrenzyPoint Parms{};

	Parms.InAmount = InAmount;
	Parms.ConsumeReason = ConsumeReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ConsumeSlaveMagazinePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConsumeAmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequirementAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::ConsumeSlaveMagazinePoint(int32 ConsumeAmount, int32 RequirementAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ConsumeSlaveMagazinePoint");

	Params::LPCCharacter_ConsumeSlaveMagazinePoint Parms{};

	Parms.ConsumeAmount = ConsumeAmount;
	Parms.RequirementAmount = RequirementAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.ConvertFrenzyUnitCountToFrenzyPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   FrenzyUnitCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALPCCharacter::ConvertFrenzyUnitCountToFrenzyPoint(int32 FrenzyUnitCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ConvertFrenzyUnitCountToFrenzyPoint");

	Params::LPCCharacter_ConvertFrenzyUnitCountToFrenzyPoint Parms{};

	Parms.FrenzyUnitCount = FrenzyUnitCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.EndAction_GameStart
// (Final, Native, Protected, BlueprintCallable)

void ALPCCharacter::EndAction_GameStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "EndAction_GameStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.EndAction_TeleportEnd
// (Final, Native, Protected, BlueprintCallable)

void ALPCCharacter::EndAction_TeleportEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "EndAction_TeleportEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.Execute_ShowLocationMsg
// (Final, Native, Protected)
// Parameters:
// bool                                    Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::Execute_ShowLocationMsg(bool Teleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "Execute_ShowLocationMsg");

	Params::LPCCharacter_Execute_ShowLocationMsg Parms{};

	Parms.Teleport = Teleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ExecuteAction_GameStart
// (Final, Native, Protected)

void ALPCCharacter::ExecuteAction_GameStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ExecuteAction_GameStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ExecuteAction_Reconnect
// (Final, Native, Protected)

void ALPCCharacter::ExecuteAction_Reconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ExecuteAction_Reconnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ExecuteAction_Teleport_NewGamePlus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::ExecuteAction_Teleport_NewGamePlus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ExecuteAction_Teleport_NewGamePlus");

	Params::LPCCharacter_ExecuteAction_Teleport_NewGamePlus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.ExecuteAction_TeleportEnd_Normal
// (Final, Native, Protected)

void ALPCCharacter::ExecuteAction_TeleportEnd_Normal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ExecuteAction_TeleportEnd_Normal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ExecuteAction_TeleportStart
// (Final, Native, Public)
// Parameters:
// class FName                             TeleportTorsionCoil                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTeleportByClock                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::ExecuteAction_TeleportStart(class FName TeleportTorsionCoil, bool IsTeleportByClock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ExecuteAction_TeleportStart");

	Params::LPCCharacter_ExecuteAction_TeleportStart Parms{};

	Parms.TeleportTorsionCoil = TeleportTorsionCoil;
	Parms.IsTeleportByClock = IsTeleportByClock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ExecuteAppearanceProcessEnd
// (Final, Native, Protected)

void ALPCCharacter::ExecuteAppearanceProcessEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ExecuteAppearanceProcessEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.GainFrenzyPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::GainFrenzyPoint(int32 InAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GainFrenzyPoint");

	Params::LPCCharacter_GainFrenzyPoint Parms{};

	Parms.InAmount = InAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.GetCurrentFrenzyUnitCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALPCCharacter::GetCurrentFrenzyUnitCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetCurrentFrenzyUnitCount");

	Params::LPCCharacter_GetCurrentFrenzyUnitCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetDefaultStatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             DefalutStatName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULStatComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULStatComponent* ALPCCharacter::GetDefaultStatComponent(class FName DefalutStatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetDefaultStatComponent");

	Params::LPCCharacter_GetDefaultStatComponent Parms{};

	Parms.DefalutStatName = DefalutStatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetWeightPenalty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWeightPenaltyInfoPtr            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWeightPenaltyInfoPtr ALPCCharacter::GetWeightPenalty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetWeightPenalty");

	Params::LPCCharacter_GetWeightPenalty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetWeightPenaltyInGivenMaxWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InMaxWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeightPenaltyInfoPtr            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWeightPenaltyInfoPtr ALPCCharacter::GetWeightPenaltyInGivenMaxWeight(int32 InMaxWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetWeightPenaltyInGivenMaxWeight");

	Params::LPCCharacter_GetWeightPenaltyInGivenMaxWeight Parms{};

	Parms.InMaxWeight = InMaxWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.InitialOverlapUpdate
// (Final, Native, Public, BlueprintCallable)

void ALPCCharacter::InitialOverlapUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "InitialOverlapUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.IsEyeColorChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::IsEyeColorChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "IsEyeColorChanged");

	Params::LPCCharacter_IsEyeColorChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.IsFrenzyActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::IsFrenzyActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "IsFrenzyActivated");

	Params::LPCCharacter_IsFrenzyActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.IsStaminaChangeStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::IsStaminaChangeStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "IsStaminaChangeStatus");

	Params::LPCCharacter_IsStaminaChangeStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.OnAlertLamp
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DurationTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnAlertLamp(float DurationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnAlertLamp");

	Params::LPCCharacter_OnAlertLamp Parms{};

	Parms.DurationTime = DurationTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCCharacter.OnBackToHotelTorsionCoil
// (Final, Native, Public)
// Parameters:
// bool                                    UseItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnBackToHotelTorsionCoil(bool UseItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnBackToHotelTorsionCoil");

	Params::LPCCharacter_OnBackToHotelTorsionCoil Parms{};

	Parms.UseItem = UseItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnBackToLatestTorsionCoil
// (Final, Native, Public)
// Parameters:
// bool                                    UseItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnBackToLatestTorsionCoil(bool UseItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnBackToLatestTorsionCoil");

	Params::LPCCharacter_OnBackToLatestTorsionCoil Parms{};

	Parms.UseItem = UseItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnClosedLevelUpOrPOrgan
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnClosedLevelUpOrPOrgan(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnClosedLevelUpOrPOrgan");

	Params::LPCCharacter_OnClosedLevelUpOrPOrgan Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnDialogLampOff
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALPCCharacter::OnDialogLampOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnDialogLampOff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPCCharacter.OnDialogLampOn
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALPCCharacter::OnDialogLampOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnDialogLampOn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPCCharacter.OnExecuteTeleport
// (Final, Native, Public)

void ALPCCharacter::OnExecuteTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnExecuteTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnFinishedIntroSequenceActor
// (Final, Native, Protected)

void ALPCCharacter::OnFinishedIntroSequenceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnFinishedIntroSequenceActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnFinishedPortalSequenceActor
// (Final, Native, Protected)

void ALPCCharacter::OnFinishedPortalSequenceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnFinishedPortalSequenceActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnFrenzyModeMV
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFrenzyMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnFrenzyModeMV(bool bFrenzyMode, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnFrenzyModeMV");

	Params::LPCCharacter_OnFrenzyModeMV Parms{};

	Parms.bFrenzyMode = bFrenzyMode;
	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCCharacter.OnGainExp
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InExp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnGainExp(int32 InExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnGainExp");

	Params::LPCCharacter_OnGainExp Parms{};

	Parms.InExp = InExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnGainHumanity
// (Final, Native, Private)
// Parameters:
// int32                                   InHumanity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnGainHumanity(int32 InHumanity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnGainHumanity");

	Params::LPCCharacter_OnGainHumanity Parms{};

	Parms.InHumanity = InHumanity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnGainItem
// (Final, Native, Private)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ItemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnGainItem(class FName ItemId, int32 ItemCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnGainItem");

	Params::LPCCharacter_OnGainItem Parms{};

	Parms.ItemId = ItemId;
	Parms.ItemCount = ItemCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnGainWeapon
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             Handle                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Blade                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnGainWeapon(const class FName& Handle, const class FName& Blade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnGainWeapon");

	Params::LPCCharacter_OnGainWeapon Parms{};

	Parms.Handle = Handle;
	Parms.Blade = Blade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnGameDataCharacterSync
// (Final, Native, Protected)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnGameDataCharacterSync");

	Params::LPCCharacter_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnInitMainUI
// (Final, Native, Private)
// Parameters:
// class FName                             MainStateName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnInitMainUI(class FName MainStateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnInitMainUI");

	Params::LPCCharacter_OnInitMainUI Parms{};

	Parms.MainStateName = MainStateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnMustBeEqualStatsKeepSamed
// (Final, Native, Public)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnMustBeEqualStatsKeepSamed(ELSecondStat StatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnMustBeEqualStatsKeepSamed");

	Params::LPCCharacter_OnMustBeEqualStatsKeepSamed Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnPlayIntroSequenceActor
// (Final, Native, Protected)

void ALPCCharacter::OnPlayIntroSequenceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnPlayIntroSequenceActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnReadyHUD
// (Final, Native, Private)

void ALPCCharacter::OnReadyHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnReadyHUD");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnUIConfirmTeleport
// (Final, Native, Public)
// Parameters:
// class FName                             TeleportTorsionCoil                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnUIConfirmTeleport(class FName TeleportTorsionCoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnUIConfirmTeleport");

	Params::LPCCharacter_OnUIConfirmTeleport Parms{};

	Parms.TeleportTorsionCoil = TeleportTorsionCoil;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnUseItemBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnUseItemBP(class FName ItemId, bool IsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnUseItemBP");

	Params::LPCCharacter_OnUseItemBP Parms{};

	Parms.ItemId = ItemId;
	Parms.IsOn = IsOn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPCCharacter.OnWatchActionStateAfterRemove
// (Final, Native, Private)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnWatchActionStateAfterRemove(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnWatchActionStateAfterRemove");

	Params::LPCCharacter_OnWatchActionStateAfterRemove Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.OnWatchActionStateBeforeAdd
// (Final, Native, Private)
// Parameters:
// class ULActMgrComponent*                InActMgrComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::OnWatchActionStateBeforeAdd(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "OnWatchActionStateBeforeAdd");

	Params::LPCCharacter_OnWatchActionStateBeforeAdd Parms{};

	Parms.InActMgrComponent = InActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ProcessBeginPlayBP
// (Event, Public, BlueprintEvent)

void ALPCCharacter::ProcessBeginPlayBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ProcessBeginPlayBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPCCharacter.RemoveRainHitSound
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALPCCharacter::RemoveRainHitSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "RemoveRainHitSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPCCharacter.RequestResetAllFirstStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::RequestResetAllFirstStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "RequestResetAllFirstStat");

	Params::LPCCharacter_RequestResetAllFirstStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.RequestResetFX
// (Final, Native, Public, BlueprintCallable)

void ALPCCharacter::RequestResetFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "RequestResetFX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.SelectDefaultStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DefaultStatCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::SelectDefaultStat(class FName DefaultStatCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "SelectDefaultStat");

	Params::LPCCharacter_SelectDefaultStat Parms{};

	Parms.DefaultStatCodeName = DefaultStatCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.ShowUIMsgYouDie
// (Final, Native, Public, BlueprintCallable)

void ALPCCharacter::ShowUIMsgYouDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "ShowUIMsgYouDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.UIActiveLevelUpWidget
// (Final, Native, Private)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResetLevelUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPCCharacter::UIActiveLevelUpWidget(bool IsActive, bool IsResetLevelUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "UIActiveLevelUpWidget");

	Params::LPCCharacter_UIActiveLevelUpWidget Parms{};

	Parms.IsActive = IsActive;
	Parms.IsResetLevelUp = IsResetLevelUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPCCharacter.CheckCanChangeFirstStat
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELFirstStat                             FirstStat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChangeData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutErrorCode                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::CheckCanChangeFirstStat(ELFirstStat FirstStat, int32 ChangeData, int32* OutErrorCode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "CheckCanChangeFirstStat");

	Params::LPCCharacter_CheckCanChangeFirstStat Parms{};

	Parms.FirstStat = FirstStat;
	Parms.ChangeData = ChangeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutErrorCode != nullptr)
		*OutErrorCode = Parms.OutErrorCode;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetCurrentWeaponName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALPCCharacter::GetCurrentWeaponName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetCurrentWeaponName");

	Params::LPCCharacter_GetCurrentWeaponName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetFirstStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELFirstStatDataType                     DataType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFirstStat                             StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALPCCharacter::GetFirstStat(ELFirstStatDataType DataType, ELFirstStat StatType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetFirstStat");

	Params::LPCCharacter_GetFirstStat Parms{};

	Parms.DataType = DataType;
	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetLampMesh
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* ALPCCharacter::GetLampMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetLampMesh");

	Params::LPCCharacter_GetLampMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetMaxWeaponCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALPCCharacter::GetMaxWeaponCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetMaxWeaponCount");

	Params::LPCCharacter_GetMaxWeaponCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.GetWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALPCCharacter::GetWeaponIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "GetWeaponIndex");

	Params::LPCCharacter_GetWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPCCharacter.IsProtectErgoDrop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPCCharacter::IsProtectErgoDrop() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPCCharacter", "IsProtectErgoDrop");

	Params::LPCCharacter_IsProtectErgoDrop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.GetUseRagdollSleepAndWake
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::GetUseRagdollSleepAndWake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LPhysicalAnimationComponent", "GetUseRagdollSleepAndWake");

	Params::LPhysicalAnimationComponent_GetUseRagdollSleepAndWake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ChangePhysicsAssetBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_PhysicsAsset       PhysicsInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ChangePhysicsAssetBP(const struct FLPhysicsInfo_PhysicsAsset& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ChangePhysicsAssetBP");

	Params::LPhysicalAnimationComponent_ChangePhysicsAssetBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ChangeToExplosionBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_Explosion          PhysicsInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ChangeToExplosionBP(const struct FLPhysicsInfo_Explosion& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ChangeToExplosionBP");

	Params::LPhysicalAnimationComponent_ChangeToExplosionBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ChangeToNoPhysicsBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_NoPhysics          PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ChangeToNoPhysicsBP(const struct FLPhysicsInfo_NoPhysics& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ChangeToNoPhysicsBP");

	Params::LPhysicalAnimationComponent_ChangeToNoPhysicsBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ChangeToPhysicalAnimationBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_PhysicalAnimation  PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ChangeToPhysicalAnimationBP(const struct FLPhysicsInfo_PhysicalAnimation& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ChangeToPhysicalAnimationBP");

	Params::LPhysicalAnimationComponent_ChangeToPhysicalAnimationBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ChangeToRagdollBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_RagDoll            PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ChangeToRagdollBP(const struct FLPhysicsInfo_RagDoll& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ChangeToRagdollBP");

	Params::LPhysicalAnimationComponent_ChangeToRagdollBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ChangeToRagdollFreezeBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ChangeToRagdollFreezeBP(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ChangeToRagdollFreezeBP");

	Params::LPhysicalAnimationComponent_ChangeToRagdollFreezeBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.Debug_BindRagdollOverlapWake
// (Event, Public, BlueprintEvent)

void ULPhysicalAnimationComponent::Debug_BindRagdollOverlapWake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "Debug_BindRagdollOverlapWake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPhysicalAnimationComponent.Debug_UnbindRagdollOverlapWake
// (Event, Public, BlueprintEvent)

void ULPhysicalAnimationComponent::Debug_UnbindRagdollOverlapWake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "Debug_UnbindRagdollOverlapWake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LPhysicalAnimationComponent.GetSkeletalMeshComponentBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ULPhysicalAnimationComponent::GetSkeletalMeshComponentBP(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "GetSkeletalMeshComponentBP");

	Params::LPhysicalAnimationComponent_GetSkeletalMeshComponentBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.MakeExplosionInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Murderer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLHitInfo                        HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FLPhysicsInfo_Explosion          ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLPhysicsInfo_Explosion ULPhysicalAnimationComponent::MakeExplosionInfo(class AActor* TargetActor, class AActor* Murderer, const struct FLHitInfo& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "MakeExplosionInfo");

	Params::LPhysicalAnimationComponent_MakeExplosionInfo Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Murderer = Murderer;
	Parms.HitInfo = std::move(HitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnChangePhysicsAssetBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLPhysicsInfo_PhysicsAsset       PhysicsInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::OnChangePhysicsAssetBP(const struct FLPhysicsInfo_PhysicsAsset& PhysicsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnChangePhysicsAssetBP");

	Params::LPhysicalAnimationComponent_OnChangePhysicsAssetBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnChangeToExplosionBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLPhysicsInfo_Explosion          PhysicsInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::OnChangeToExplosionBP(const struct FLPhysicsInfo_Explosion& PhysicsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnChangeToExplosionBP");

	Params::LPhysicalAnimationComponent_OnChangeToExplosionBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnChangeToNoPhysicsBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLPhysicsInfo_NoPhysics          PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::OnChangeToNoPhysicsBP(const struct FLPhysicsInfo_NoPhysics& PhysicsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnChangeToNoPhysicsBP");

	Params::LPhysicalAnimationComponent_OnChangeToNoPhysicsBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnChangeToPhysicalAnimationBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLPhysicsInfo_PhysicalAnimation  PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::OnChangeToPhysicalAnimationBP(const struct FLPhysicsInfo_PhysicalAnimation& PhysicsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnChangeToPhysicalAnimationBP");

	Params::LPhysicalAnimationComponent_OnChangeToPhysicalAnimationBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnChangeToRagdollBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLPhysicsInfo_RagDoll            PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::OnChangeToRagdollBP(const struct FLPhysicsInfo_RagDoll& PhysicsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnChangeToRagdollBP");

	Params::LPhysicalAnimationComponent_OnChangeToRagdollBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnChangeToRagdollFreezeBP
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::OnChangeToRagdollFreezeBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnChangeToRagdollFreezeBP");

	Params::LPhysicalAnimationComponent_OnChangeToRagdollFreezeBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.OnResetBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPhysicalAnimationComponent::OnResetBP(class USkeletalMeshComponent* InSkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "OnResetBP");

	Params::LPhysicalAnimationComponent_OnResetBP Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LPhysicalAnimationComponent.PutAllRigidBodiesToSleep
// (Final, Native, Public, BlueprintCallable)

void ULPhysicalAnimationComponent::PutAllRigidBodiesToSleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "PutAllRigidBodiesToSleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveChangePhysicsAssetBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_PhysicsAsset       PhysicsInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveChangePhysicsAssetBP(const struct FLPhysicsInfo_PhysicsAsset& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveChangePhysicsAssetBP");

	Params::LPhysicalAnimationComponent_ReserveChangePhysicsAssetBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToExplosionBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_Explosion          PhysicsInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveChangeToExplosionBP(const struct FLPhysicsInfo_Explosion& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveChangeToExplosionBP");

	Params::LPhysicalAnimationComponent_ReserveChangeToExplosionBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToNoPhysicsBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_NoPhysics          PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveChangeToNoPhysicsBP(const struct FLPhysicsInfo_NoPhysics& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveChangeToNoPhysicsBP");

	Params::LPhysicalAnimationComponent_ReserveChangeToNoPhysicsBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToPhysicalAnimationBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_PhysicalAnimation  PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveChangeToPhysicalAnimationBP(const struct FLPhysicsInfo_PhysicalAnimation& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveChangeToPhysicalAnimationBP");

	Params::LPhysicalAnimationComponent_ReserveChangeToPhysicalAnimationBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToRagdollBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLPhysicsInfo_RagDoll            PhysicsInfo                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveChangeToRagdollBP(const struct FLPhysicsInfo_RagDoll& PhysicsInfo, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveChangeToRagdollBP");

	Params::LPhysicalAnimationComponent_ReserveChangeToRagdollBP Parms{};

	Parms.PhysicsInfo = std::move(PhysicsInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveChangeToRagdollFreezeBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveChangeToRagdollFreezeBP(EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveChangeToRagdollFreezeBP");

	Params::LPhysicalAnimationComponent_ReserveChangeToRagdollFreezeBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.ReserveResetBP
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FromBeginPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EExecutePin                             Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPhysicalAnimationComponent::ReserveResetBP(class USkeletalMeshComponent* InSkeletalMeshComponent, bool FromBeginPlay, EExecutePin* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ReserveResetBP");

	Params::LPhysicalAnimationComponent_ReserveResetBP Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;
	Parms.FromBeginPlay = FromBeginPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;

	return Parms.ReturnValue;
}


// Function ProjectP.LPhysicalAnimationComponent.Reset
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FromBeginPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPhysicalAnimationComponent::Reset(class USkeletalMeshComponent* InSkeletalMeshComponent, bool FromBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "Reset");

	Params::LPhysicalAnimationComponent_Reset Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;
	Parms.FromBeginPlay = FromBeginPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPhysicalAnimationComponent.ResetExplosionState
// (Final, Native, Public, BlueprintCallable)

void ULPhysicalAnimationComponent::ResetExplosionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "ResetExplosionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPhysicalAnimationComponent.WakeAllRigidBodies
// (Final, Native, Public, BlueprintCallable)

void ULPhysicalAnimationComponent::WakeAllRigidBodies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPhysicalAnimationComponent", "WakeAllRigidBodies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.CheckCanEquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELEquipSlotType                         SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::CheckCanEquipItem(ELEquipSlotType SlotType, class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "CheckCanEquipItem");

	Params::LPlayerEquipment_CheckCanEquipItem Parms{};

	Parms.SlotType = SlotType;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.ChooseNextSlaveArmItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSelectPrevious                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::ChooseNextSlaveArmItem(bool bSelectPrevious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "ChooseNextSlaveArmItem");

	Params::LPlayerEquipment_ChooseNextSlaveArmItem Parms{};

	Parms.bSelectPrevious = bSelectPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.ChooseNextUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSelectPrevious                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::ChooseNextUseItem(bool bSelectPrevious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "ChooseNextUseItem");

	Params::LPlayerEquipment_ChooseNextUseItem Parms{};

	Parms.bSelectPrevious = bSelectPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.ChooseNextWeaponItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSelectPrevious                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::ChooseNextWeaponItem(bool bSelectPrevious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "ChooseNextWeaponItem");

	Params::LPlayerEquipment_ChooseNextWeaponItem Parms{};

	Parms.bSelectPrevious = bSelectPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.EquipAssistUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAssistUseItemSlotType                 SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::EquipAssistUseItem(ELAssistUseItemSlotType SlotType, class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "EquipAssistUseItem");

	Params::LPlayerEquipment_EquipAssistUseItem Parms{};

	Parms.SlotType = SlotType;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.EquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELEquipSlotType                         SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::EquipItem(ELEquipSlotType SlotType, class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "EquipItem");

	Params::LPlayerEquipment_EquipItem Parms{};

	Parms.SlotType = SlotType;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.EquipUseItem_CurrentLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::EquipUseItem_CurrentLine(int32 SlotIndex, class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "EquipUseItem_CurrentLine");

	Params::LPlayerEquipment_EquipUseItem_CurrentLine Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.EquipUseItem_SpecifiedLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::EquipUseItem_SpecifiedLine(int32 SlotIndex, class ULItem* Item, bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "EquipUseItem_SpecifiedLine");

	Params::LPlayerEquipment_EquipUseItem_SpecifiedLine Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.Item = Item;
	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.FindAssistUseItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLAssistUseItemSlot              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLAssistUseItemSlot ULPlayerEquipment::FindAssistUseItem(class FName ItemCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "FindAssistUseItem");

	Params::LPlayerEquipment_FindAssistUseItem Parms{};

	Parms.ItemCodeName = ItemCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.FindEquipItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLEquipItemSlot                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLEquipItemSlot ULPlayerEquipment::FindEquipItem(class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "FindEquipItem");

	Params::LPlayerEquipment_FindEquipItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.FindEquipItems_ByEquipGroupId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InEquipGroupId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLEquipItemSlot>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLEquipItemSlot> ULPlayerEquipment::FindEquipItems_ByEquipGroupId(int32 InEquipGroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "FindEquipItems_ByEquipGroupId");

	Params::LPlayerEquipment_FindEquipItems_ByEquipGroupId Parms{};

	Parms.InEquipGroupId = InEquipGroupId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.FindUseItem_CurrentLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLUseItemSlot                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLUseItemSlot ULPlayerEquipment::FindUseItem_CurrentLine(class FName ItemCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "FindUseItem_CurrentLine");

	Params::LPlayerEquipment_FindUseItem_CurrentLine Parms{};

	Parms.ItemCodeName = ItemCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.FindUseItem_SpecifiedLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemCodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLUseItemSlot                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLUseItemSlot ULPlayerEquipment::FindUseItem_SpecifiedLine(class FName ItemCodeName, bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "FindUseItem_SpecifiedLine");

	Params::LPlayerEquipment_FindUseItem_SpecifiedLine Parms{};

	Parms.ItemCodeName = ItemCodeName;
	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetAssistUseItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELAssistUseItemSlotType                 SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULPlayerEquipment::GetAssistUseItem(ELAssistUseItemSlotType SlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetAssistUseItem");

	Params::LPlayerEquipment_GetAssistUseItem Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetAssistUseItemCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELAssistUseItemSlotType                 SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULPlayerEquipment::GetAssistUseItemCodeName(ELAssistUseItemSlotType SlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetAssistUseItemCodeName");

	Params::LPlayerEquipment_GetAssistUseItemCodeName Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetChosenSlaveArmItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLEquipItemSlot                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLEquipItemSlot ULPlayerEquipment::GetChosenSlaveArmItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetChosenSlaveArmItem");

	Params::LPlayerEquipment_GetChosenSlaveArmItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetChosenUseItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLUseItemSlot                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLUseItemSlot ULPlayerEquipment::GetChosenUseItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetChosenUseItem");

	Params::LPlayerEquipment_GetChosenUseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetChosenWeaponItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLEquipItemSlot                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLEquipItemSlot ULPlayerEquipment::GetChosenWeaponItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetChosenWeaponItem");

	Params::LPlayerEquipment_GetChosenWeaponItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetChosenWeaponItemBP
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALWeapon*                         Weapon                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELEquipSlotType                         EquipSlot                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::GetChosenWeaponItemBP(class ALWeapon** Weapon, ELEquipSlotType* EquipSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetChosenWeaponItemBP");

	Params::LPlayerEquipment_GetChosenWeaponItemBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Weapon != nullptr)
		*Weapon = Parms.Weapon;

	if (EquipSlot != nullptr)
		*EquipSlot = Parms.EquipSlot;
}


// Function ProjectP.LPlayerEquipment.GetEquipItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELEquipSlotType                         SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULPlayerEquipment::GetEquipItem(ELEquipSlotType SlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetEquipItem");

	Params::LPlayerEquipment_GetEquipItem Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetEquipItemSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ELEquipSlotType                         EquipSlotType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFound                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLEquipItemSlot                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLEquipItemSlot ULPlayerEquipment::GetEquipItemSlot(ELEquipSlotType EquipSlotType, bool* bFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetEquipItemSlot");

	Params::LPlayerEquipment_GetEquipItemSlot Parms{};

	Parms.EquipSlotType = EquipSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFound != nullptr)
		*bFound = Parms.bFound;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetEquipSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULItem*                           Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELEquipSlotType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELEquipSlotType ULPlayerEquipment::GetEquipSlot(const class ULItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetEquipSlot");

	Params::LPlayerEquipment_GetEquipSlot Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseItem_CurrentLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULPlayerEquipment::GetUseItem_CurrentLine(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseItem_CurrentLine");

	Params::LPlayerEquipment_GetUseItem_CurrentLine Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseItem_SpecifiedLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULItem*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULItem* ULPlayerEquipment::GetUseItem_SpecifiedLine(int32 SlotIndex, bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseItem_SpecifiedLine");

	Params::LPlayerEquipment_GetUseItem_SpecifiedLine Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseItemCodeName_CurrentLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULPlayerEquipment::GetUseItemCodeName_CurrentLine(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseItemCodeName_CurrentLine");

	Params::LPlayerEquipment_GetUseItemCodeName_CurrentLine Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseItemCodeName_SpecifiedLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULPlayerEquipment::GetUseItemCodeName_SpecifiedLine(int32 SlotIndex, bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseItemCodeName_SpecifiedLine");

	Params::LPlayerEquipment_GetUseItemCodeName_SpecifiedLine Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseItemSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFound                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLUseItemSlot                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLUseItemSlot ULPlayerEquipment::GetUseItemSlot(bool FirstLine, int32 SlotIndex, bool* bFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseItemSlot");

	Params::LPlayerEquipment_GetUseItemSlot Parms{};

	Parms.FirstLine = FirstLine;
	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFound != nullptr)
		*bFound = Parms.bFound;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseSlotsLine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLUseItemSlot>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLUseItemSlot> ULPlayerEquipment::GetUseSlotsLine(bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseSlotsLine");

	Params::LPlayerEquipment_GetUseSlotsLine Parms{};

	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetUseSlotsLine_AllSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FLUseItemSlot>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FLUseItemSlot> ULPlayerEquipment::GetUseSlotsLine_AllSlot(bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetUseSlotsLine_AllSlot");

	Params::LPlayerEquipment_GetUseSlotsLine_AllSlot Parms{};

	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.SetUnlockEquipSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELEquipSlotType                         SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnlock                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::SetUnlockEquipSlot(ELEquipSlotType SlotType, bool bUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "SetUnlockEquipSlot");

	Params::LPlayerEquipment_SetUnlockEquipSlot Parms{};

	Parms.SlotType = SlotType;
	Parms.bUnlock = bUnlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.SetUnlockEquipSlotByCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SlotCategoryType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnlock                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::SetUnlockEquipSlotByCategory(class FName SlotCategoryType, bool bUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "SetUnlockEquipSlotByCategory");

	Params::LPlayerEquipment_SetUnlockEquipSlotByCategory Parms{};

	Parms.SlotCategoryType = SlotCategoryType;
	Parms.bUnlock = bUnlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.SetUnlockEquipUseSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUnlock                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayerEquipment::SetUnlockEquipUseSlot(bool bUnlock, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "SetUnlockEquipUseSlot");

	Params::LPlayerEquipment_SetUnlockEquipUseSlot Parms{};

	Parms.bUnlock = bUnlock;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayerEquipment.SwapUseSlotsLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::SwapUseSlotsLine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "SwapUseSlotsLine");

	Params::LPlayerEquipment_SwapUseSlotsLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.UnEquipAssistUseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELAssistUseItemSlotType                 SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::UnEquipAssistUseItem(ELAssistUseItemSlotType SlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "UnEquipAssistUseItem");

	Params::LPlayerEquipment_UnEquipAssistUseItem Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.UnEquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELEquipSlotType                         SlotType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::UnEquipItem(ELEquipSlotType SlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "UnEquipItem");

	Params::LPlayerEquipment_UnEquipItem Parms{};

	Parms.SlotType = SlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.UnEquipUseItem_CurrentLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::UnEquipUseItem_CurrentLine(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "UnEquipUseItem_CurrentLine");

	Params::LPlayerEquipment_UnEquipUseItem_CurrentLine Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.UnEquipUseItem_SpecifiedLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FirstLine                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::UnEquipUseItem_SpecifiedLine(int32 SlotIndex, bool FirstLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "UnEquipUseItem_SpecifiedLine");

	Params::LPlayerEquipment_UnEquipUseItem_SpecifiedLine Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.FirstLine = FirstLine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetGearArmSlotTypeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<ELEquipSlotType>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ELEquipSlotType> ULPlayerEquipment::GetGearArmSlotTypeList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetGearArmSlotTypeList");

	Params::LPlayerEquipment_GetGearArmSlotTypeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetSlaveArmSlotTypeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<ELEquipSlotType>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ELEquipSlotType> ULPlayerEquipment::GetSlaveArmSlotTypeList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetSlaveArmSlotTypeList");

	Params::LPlayerEquipment_GetSlaveArmSlotTypeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.GetWeaponSlotTypeList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<ELEquipSlotType>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ELEquipSlotType> ULPlayerEquipment::GetWeaponSlotTypeList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "GetWeaponSlotTypeList");

	Params::LPlayerEquipment_GetWeaponSlotTypeList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.IsEquipedPartsSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::IsEquipedPartsSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "IsEquipedPartsSet");

	Params::LPlayerEquipment_IsEquipedPartsSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayerEquipment.IsSelectedUseSlotsLineFirst
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayerEquipment::IsSelectedUseSlotsLineFirst() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayerEquipment", "IsSelectedUseSlotsLineFirst");

	Params::LPlayerEquipment_IsSelectedUseSlotsLineFirst Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.FlushPressedActionBindingKeysExceptAxisKeys
// (Final, Native, Public, BlueprintCallable)

void ULPlayInputSystem::FlushPressedActionBindingKeysExceptAxisKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "FlushPressedActionBindingKeysExceptAxisKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayInputSystem.FlushPressedKeys
// (Final, Native, Public, BlueprintCallable)

void ULPlayInputSystem::FlushPressedKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "FlushPressedKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayInputSystem.SetPlayInputLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    block                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPlayInputSystem::SetPlayInputLock(bool block)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "SetPlayInputLock");

	Params::LPlayInputSystem_SetPlayInputLock Parms{};

	Parms.block = block;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPlayInputSystem.GetInputPlatformName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULPlayInputSystem::GetInputPlatformName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "GetInputPlatformName");

	Params::LPlayInputSystem_GetInputPlatformName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.GetLastInputKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKey                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FKey ULPlayInputSystem::GetLastInputKey() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "GetLastInputKey");

	Params::LPlayInputSystem_GetLastInputKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.GetPlayerInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULPlayerInput*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULPlayerInput* ULPlayInputSystem::GetPlayerInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "GetPlayerInput");

	Params::LPlayInputSystem_GetPlayerInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.IsGamePadMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayInputSystem::IsGamePadMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "IsGamePadMode");

	Params::LPlayInputSystem_IsGamePadMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.IsRightAcceptButton
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayInputSystem::IsRightAcceptButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "IsRightAcceptButton");

	Params::LPlayInputSystem_IsRightAcceptButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.IsUsingPlayStationGamePad
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayInputSystem::IsUsingPlayStationGamePad() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "IsUsingPlayStationGamePad");

	Params::LPlayInputSystem_IsUsingPlayStationGamePad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPlayInputSystem.IsUsingWinDualSense
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPlayInputSystem::IsUsingWinDualSense() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPlayInputSystem", "IsUsingWinDualSense");

	Params::LPlayInputSystem_IsUsingWinDualSense Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSellShop.GetSellCategorys
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<ELItemFirstCategory>               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<ELItemFirstCategory> ULProductSellShop::GetSellCategorys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSellShop", "GetSellCategorys");

	Params::LProductSellShop_GetSellCategorys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSellShop.GetSellList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELItemFirstCategory                     Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULItem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULItem*> ULProductSellShop::GetSellList(ELItemFirstCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSellShop", "GetSellList");

	Params::LProductSellShop_GetSellList Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSellShop.Sell
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULItem*                           InSell                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLockerItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProductSellShop::Sell(class ULItem* InSell, int32 InCount, bool IsLockerItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSellShop", "Sell");

	Params::LProductSellShop_Sell Parms{};

	Parms.InSell = InSell;
	Parms.InCount = InCount;
	Parms.IsLockerItem = IsLockerItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProductSellShop.CalcSellingPrice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULItem*                           InItem                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULProductSellShop::CalcSellingPrice(const class ULItem* InItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProductSellShop", "CalcSellingPrice");

	Params::LProductSellShop_CalcSellingPrice Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileHit_PeriodicHandler.Clear
// (Final, Native, Public, BlueprintCallable)

void ULProjectileHit_PeriodicHandler::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileHit_PeriodicHandler", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileHit_PeriodicHandler.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALProjectile*                     InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLProjectileHitInfo              InHitInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULProjectileHit_PeriodicHandler::Initialize(class ALProjectile* InOwner, const struct FLProjectileHitInfo& InHitInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileHit_PeriodicHandler", "Initialize");

	Params::LProjectileHit_PeriodicHandler_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InHitInfo = std::move(InHitInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileHit_PeriodicHandler.OnGenerateHit
// (Final, Native, Public, BlueprintCallable)

void ULProjectileHit_PeriodicHandler::OnGenerateHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileHit_PeriodicHandler", "OnGenerateHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSpawn_PeriodicHandler.Clear
// (Final, Native, Public, BlueprintCallable)

void ULProjectileSpawn_PeriodicHandler::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSpawn_PeriodicHandler", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSpawn_PeriodicHandler.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALProjectile*                     InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLChildProjectileSpawnInfo       InSpawnInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULProjectileSpawn_PeriodicHandler::Initialize(class ALProjectile* InOwner, const struct FLChildProjectileSpawnInfo& InSpawnInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSpawn_PeriodicHandler", "Initialize");

	Params::LProjectileSpawn_PeriodicHandler_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InSpawnInfo = std::move(InSpawnInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSpawn_PeriodicHandler.OnSpawn
// (Final, Native, Public, BlueprintCallable)

void ULProjectileSpawn_PeriodicHandler::OnSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSpawn_PeriodicHandler", "OnSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile_AbnormalApplyInRange.Clear
// (Final, Native, Public, BlueprintCallable)

void ULProjectile_AbnormalApplyInRange::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile_AbnormalApplyInRange", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile_AbnormalApplyInRange.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALProjectile*                     InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLProjectileAbnormalApplyInRangeInfoInAbnormalApplyInfo                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULProjectile_AbnormalApplyInRange::Initialize(class ALProjectile* InOwner, const struct FLProjectileAbnormalApplyInRangeInfo& InAbnormalApplyInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile_AbnormalApplyInRange", "Initialize");

	Params::LProjectile_AbnormalApplyInRange_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InAbnormalApplyInfo = std::move(InAbnormalApplyInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile_AbnormalApplyInRange.OnActorBeginOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULProjectile_AbnormalApplyInRange::OnActorBeginOverlap(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile_AbnormalApplyInRange", "OnActorBeginOverlap");

	Params::LProjectile_AbnormalApplyInRange_OnActorBeginOverlap Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile_AbnormalApplyInRange.OnActorEndOverlap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULProjectile_AbnormalApplyInRange::OnActorEndOverlap(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile_AbnormalApplyInRange", "OnActorEndOverlap");

	Params::LProjectile_AbnormalApplyInRange_OnActorEndOverlap Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile_Chase.ChangeChasingState
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// ELChaseProjectileState                  NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALProjectile_Chase::ChangeChasingState(ELChaseProjectileState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile_Chase", "ChangeChasingState");

	Params::LProjectile_Chase_ChangeChasingState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectile_Chase.UpdateChaseProjectileState
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void ALProjectile_Chase::UpdateChaseProjectileState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectile_Chase", "UpdateChaseProjectileState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSystem.AddUniqueSkillHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULProjectileSystem::AddUniqueSkillHit(class AActor* Victim, class FName SkillHitCodeName, float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "AddUniqueSkillHit");

	Params::LProjectileSystem_AddUniqueSkillHit Parms{};

	Parms.Victim = Victim;
	Parms.SkillHitCodeName = SkillHitCodeName;
	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSystem.ClearAllProjectile
// (Final, Native, Public, BlueprintCallable)

void ULProjectileSystem::ClearAllProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "ClearAllProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSystem.FindAngularProjectileAngle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          FireLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GravityForce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULProjectileSystem::FindAngularProjectileAngle(const struct FVector& FireLocation, const struct FVector& TargetLocation, float Speed, float GravityForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "FindAngularProjectileAngle");

	Params::LProjectileSystem_FindAngularProjectileAngle Parms{};

	Parms.FireLocation = std::move(FireLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Speed = Speed;
	Parms.GravityForce = GravityForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileSystem.FindAngularProjectileSpeed
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          FireLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULProjectileSystem::FindAngularProjectileSpeed(const struct FVector& FireLocation, const struct FVector& TargetLocation, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "FindAngularProjectileSpeed");

	Params::LProjectileSystem_FindAngularProjectileSpeed Parms{};

	Parms.FireLocation = std::move(FireLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileSystem.FindAngularProjectileVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          FireLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULProjectileSystem::FindAngularProjectileVelocity(const struct FVector& FireLocation, const struct FVector& TargetLocation, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "FindAngularProjectileVelocity");

	Params::LProjectileSystem_FindAngularProjectileVelocity Parms{};

	Parms.FireLocation = std::move(FireLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileSystem.IsSkillHitIgnored
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillHitCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProjectileSystem::IsSkillHitIgnored(class AActor* Victim, class FName SkillHitCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "IsSkillHitIgnored");

	Params::LProjectileSystem_IsSkillHitIgnored Parms{};

	Parms.Victim = Victim;
	Parms.SkillHitCodeName = SkillHitCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileSystem.LaunchProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLProjectileSpawnParameter       SpawnParameters                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ALProjectile*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALProjectile* ULProjectileSystem::LaunchProjectile(class AActor* Instigator, const struct FLProjectileSpawnParameter& SpawnParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "LaunchProjectile");

	Params::LProjectileSystem_LaunchProjectile Parms{};

	Parms.Instigator = Instigator;
	Parms.SpawnParameters = std::move(SpawnParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileSystem.PauseAllProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    PauseFlag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULProjectileSystem::PauseAllProjectile(bool PauseFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "PauseAllProjectile");

	Params::LProjectileSystem_PauseAllProjectile Parms{};

	Parms.PauseFlag = PauseFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSystem.RemoveProjectile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   ProjectileHandleId                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULProjectileSystem::RemoveProjectile(int64 ProjectileHandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "RemoveProjectile");

	Params::LProjectileSystem_RemoveProjectile Parms{};

	Parms.ProjectileHandleId = ProjectileHandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LProjectileSystem.BoxOverlapMultiByProfile
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALProjectile*                     Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLOverlapResult>          OutOverlaps                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rot                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProjectileSystem::BoxOverlapMultiByProfile(class ALProjectile* Projectile, TArray<struct FLOverlapResult>* OutOverlaps, const struct FVector& Pos, const struct FRotator& Rot, const struct FVector& Extent, class FName ProfileName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "BoxOverlapMultiByProfile");

	Params::LProjectileSystem_BoxOverlapMultiByProfile Parms{};

	Parms.Projectile = Projectile;
	Parms.Pos = std::move(Pos);
	Parms.Rot = std::move(Rot);
	Parms.Extent = std::move(Extent);
	Parms.ProfileName = ProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverlaps != nullptr)
		*OutOverlaps = std::move(Parms.OutOverlaps);

	return Parms.ReturnValue;
}


// Function ProjectP.LProjectileSystem.SphereOverlapMultiByProfile
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALProjectile*                     Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLOverlapResult>          OutOverlaps                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rot                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULProjectileSystem::SphereOverlapMultiByProfile(class ALProjectile* Projectile, TArray<struct FLOverlapResult>* OutOverlaps, const struct FVector& Pos, const struct FRotator& Rot, float Radius, class FName ProfileName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LProjectileSystem", "SphereOverlapMultiByProfile");

	Params::LProjectileSystem_SphereOverlapMultiByProfile Parms{};

	Parms.Projectile = Projectile;
	Parms.Pos = std::move(Pos);
	Parms.Rot = std::move(Rot);
	Parms.Radius = Radius;
	Parms.ProfileName = ProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutOverlaps != nullptr)
		*OutOverlaps = std::move(Parms.OutOverlaps);

	return Parms.ReturnValue;
}


// Function ProjectP.LSpotProjectileSpawn_PeriodicHandler.Clear
// (Final, Native, Public, BlueprintCallable)

void ULSpotProjectileSpawn_PeriodicHandler::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpotProjectileSpawn_PeriodicHandler", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpotProjectileSpawn_PeriodicHandler.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALProjectilePropActor*            InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLProjectilePropSpawnParameter   InSpawnInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULSpotProjectileSpawn_PeriodicHandler::Initialize(class ALProjectilePropActor* InOwner, const struct FLProjectilePropSpawnParameter& InSpawnInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpotProjectileSpawn_PeriodicHandler", "Initialize");

	Params::LSpotProjectileSpawn_PeriodicHandler_Initialize Parms{};

	Parms.InOwner = InOwner;
	Parms.InSpawnInfo = std::move(InSpawnInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpotProjectileSpawn_PeriodicHandler.SpawnProjectile
// (Final, Native, Public, BlueprintCallable)

void ULSpotProjectileSpawn_PeriodicHandler::SpawnProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpotProjectileSpawn_PeriodicHandler", "SpawnProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropComponent.IsFixCameraOnInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULPropComponent::IsFixCameraOnInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropComponent", "IsFixCameraOnInteraction");

	Params::LPropComponent_IsFixCameraOnInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPropComponent.OnComponentBeginOverlapped_Interact
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULPropComponent::OnComponentBeginOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropComponent", "OnComponentBeginOverlapped_Interact");

	Params::LPropComponent_OnComponentBeginOverlapped_Interact Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropComponent.OnComponentEndOverlapped_Interact
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULPropComponent::OnComponentEndOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropComponent", "OnComponentEndOverlapped_Interact");

	Params::LPropComponent_OnComponentEndOverlapped_Interact Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropDestructionSpot.DoFracture
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALPropDestructionSpot::DoFracture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropDestructionSpot", "DoFracture");

	Params::LPropDestructionSpot_DoFracture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPropDestructionSpot.OnDestructionObjectCrashed
// (Final, Native, Protected)

void ALPropDestructionSpot::OnDestructionObjectCrashed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropDestructionSpot", "OnDestructionObjectCrashed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropDestructionSpot.SetCodeNameByBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPropDestructionSpot::SetCodeNameByBP(class FName InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropDestructionSpot", "SetCodeNameByBP");

	Params::LPropDestructionSpot_SetCodeNameByBP Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropLadderSpot.GetPropLadderInfo
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FindState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPropLadderInfoPtr         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FPropLadderInfoPtr ALPropLadderSpot::GetPropLadderInfo(int32 FindState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropLadderSpot", "GetPropLadderInfo");

	Params::LPropLadderSpot_GetPropLadderInfo Parms{};

	Parms.FindState = FindState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LPropLiftSpot.OnComponentBeginOverlapPropLiftOverlapPawn
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALPropLiftSpot::OnComponentBeginOverlapPropLiftOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropLiftSpot", "OnComponentBeginOverlapPropLiftOverlapPawn");

	Params::LPropLiftSpot_OnComponentBeginOverlapPropLiftOverlapPawn Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropLiftSpot.OnComponentBeginOverlapSetLiftStartPoint
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALPropLiftSpot::OnComponentBeginOverlapSetLiftStartPoint(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropLiftSpot", "OnComponentBeginOverlapSetLiftStartPoint");

	Params::LPropLiftSpot_OnComponentBeginOverlapSetLiftStartPoint Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropLiftSpot.OnComponentEndOverlapPropLiftOverlapPawn
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALPropLiftSpot::OnComponentEndOverlapPropLiftOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropLiftSpot", "OnComponentEndOverlapPropLiftOverlapPawn");

	Params::LPropLiftSpot_OnComponentEndOverlapPropLiftOverlapPawn Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropNavigationComponent.SetNavObstacleArea
// (Final, Native, Public, BlueprintCallable)

void ULPropNavigationComponent::SetNavObstacleArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropNavigationComponent", "SetNavObstacleArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropNavigationComponent.SetNavWalkableArea
// (Final, Native, Public, BlueprintCallable)

void ULPropNavigationComponent::SetNavWalkableArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropNavigationComponent", "SetNavWalkableArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LPropVolumeSpot.CheckAbnormalStateBuildUp
// (Final, Native, Protected)

void ALPropVolumeSpot::CheckAbnormalStateBuildUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LPropVolumeSpot", "CheckAbnormalStateBuildUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LQuartzSystem.CheckCanResetAllQuartz
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bIgnoreRequirements                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuartzSystem::CheckCanResetAllQuartz(bool bIgnoreRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "CheckCanResetAllQuartz");

	Params::LQuartzSystem_CheckCanResetAllQuartz Parms{};

	Parms.bIgnoreRequirements = bIgnoreRequirements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetPocketData
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             PocketCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULQuartzPocket*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULQuartzPocket* ULQuartzSystem::GetPocketData(class FName PocketCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetPocketData");

	Params::LQuartzSystem_GetPocketData Parms{};

	Parms.PocketCodeName = PocketCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetPocketDataByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InPocketIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULQuartzPocket*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULQuartzPocket* ULQuartzSystem::GetPocketDataByIndex(int32 InPocketIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetPocketDataByIndex");

	Params::LQuartzSystem_GetPocketDataByIndex Parms{};

	Parms.InPocketIndex = InPocketIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetQuartzEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             QuartzEffectCodeName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULQuartzEffect*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULQuartzEffect* ULQuartzSystem::GetQuartzEffect(class FName QuartzEffectCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetQuartzEffect");

	Params::LQuartzSystem_GetQuartzEffect Parms{};

	Parms.QuartzEffectCodeName = QuartzEffectCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetRequireItemsForReset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FName, int32>                OutRequireItems                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void ULQuartzSystem::GetRequireItemsForReset(TMap<class FName, int32>* OutRequireItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetRequireItemsForReset");

	Params::LQuartzSystem_GetRequireItemsForReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRequireItems != nullptr)
		*OutRequireItems = std::move(Parms.OutRequireItems);
}


// Function ProjectP.LQuartzSystem.GetReturnItemsAfterReset
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FName, int32>                OutReturnItems                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void ULQuartzSystem::GetReturnItemsAfterReset(TMap<class FName, int32>* OutReturnItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetReturnItemsAfterReset");

	Params::LQuartzSystem_GetReturnItemsAfterReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutReturnItems != nullptr)
		*OutReturnItems = std::move(Parms.OutReturnItems);
}


// Function ProjectP.LQuartzSystem.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULQuartzSystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "OnGameDataCharacterSync");

	Params::LQuartzSystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LQuartzSystem.RequestResetAllQuartz
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIgnoreRequirements                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuartzSystem::RequestResetAllQuartz(bool bIgnoreRequirements)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "RequestResetAllQuartz");

	Params::LQuartzSystem_RequestResetAllQuartz Parms{};

	Parms.bIgnoreRequirements = bIgnoreRequirements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.RequestUpgradeCoreLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuartzSystem::RequestUpgradeCoreLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "RequestUpgradeCoreLevel");

	Params::LQuartzSystem_RequestUpgradeCoreLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.ResetAllQuartz
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewgamePlus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULQuartzSystem::ResetAllQuartz(bool bForceReset, bool bNewgamePlus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "ResetAllQuartz");

	Params::LQuartzSystem_ResetAllQuartz Parms{};

	Parms.bForceReset = bForceReset;
	Parms.bNewgamePlus = bNewgamePlus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LQuartzSystem.GetCoreItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULQuartzSystem::GetCoreItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetCoreItemCount");

	Params::LQuartzSystem_GetCoreItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetEnabledCoreLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULQuartzSystem::GetEnabledCoreLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetEnabledCoreLevel");

	Params::LQuartzSystem_GetEnabledCoreLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetEnabledQuartzMenu
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuartzSystem::GetEnabledQuartzMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetEnabledQuartzMenu");

	Params::LQuartzSystem_GetEnabledQuartzMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetMaxLevelLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULQuartzSystem::GetMaxLevelLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetMaxLevelLimit");

	Params::LQuartzSystem_GetMaxLevelLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuartzSystem.GetQuartzItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULQuartzSystem::GetQuartzItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuartzSystem", "GetQuartzItemCount");

	Params::LQuartzSystem_GetQuartzItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LQuestSystem.GetQuestIconFromTeleportName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             FindTeleport                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UObject>>   OutQuestIconList                                       (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULQuestSystem::GetQuestIconFromTeleportName(class FName FindTeleport, TArray<TSoftObjectPtr<class UObject>>* OutQuestIconList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuestSystem", "GetQuestIconFromTeleportName");

	Params::LQuestSystem_GetQuestIconFromTeleportName Parms{};

	Parms.FindTeleport = FindTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutQuestIconList != nullptr)
		*OutQuestIconList = std::move(Parms.OutQuestIconList);

	return Parms.ReturnValue;
}


// Function ProjectP.LQuestSystem.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULQuestSystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LQuestSystem", "OnGameDataCharacterSync");

	Params::LQuestSystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.RichImageRowFunctionLibrary.GetImage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRichImageRow                    Row                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* URichImageRowFunctionLibrary::GetImage(const struct FRichImageRow& Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RichImageRowFunctionLibrary", "GetImage");

	Params::RichImageRowFunctionLibrary_GetImage Parms{};

	Parms.Row = std::move(Row);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSaveGameSystem.LoadGameDelegateFunction
// (Final, Native, Protected)
// Parameters:
// class FString                           InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InUserIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        LoadedSave                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSaveGameSystem::LoadGameDelegateFunction(const class FString& InSlotName, const int32 InUserIndex, class USaveGame* LoadedSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSaveGameSystem", "LoadGameDelegateFunction");

	Params::LSaveGameSystem_LoadGameDelegateFunction Parms{};

	Parms.InSlotName = std::move(InSlotName);
	Parms.InUserIndex = InUserIndex;
	Parms.LoadedSave = LoadedSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSaveGameSystem.SaveGameDelegateFunction
// (Final, Native, Protected)
// Parameters:
// class FString                           InSlotName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InUserIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSaveGameSystem::SaveGameDelegateFunction(const class FString& InSlotName, const int32 InUserIndex, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSaveGameSystem", "SaveGameDelegateFunction");

	Params::LSaveGameSystem_SaveGameDelegateFunction Parms{};

	Parms.InSlotName = std::move(InSlotName);
	Parms.InUserIndex = InUserIndex;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmPage.CheckCanReset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmPage::CheckCanReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "CheckCanReset");

	Params::LSlaveArmPage_CheckCanReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmPage.GetCanReset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmPage::GetCanReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "GetCanReset");

	Params::LSlaveArmPage_GetCanReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmPage.GetRequireItemsToReset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> ULSlaveArmPage::GetRequireItemsToReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "GetRequireItemsToReset");

	Params::LSlaveArmPage_GetRequireItemsToReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmPage.GetReturnItemsAfterReset
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<class FName, int32>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, int32> ULSlaveArmPage::GetReturnItemsAfterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "GetReturnItemsAfterReset");

	Params::LSlaveArmPage_GetReturnItemsAfterReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmPage.IsFullyReinforced
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmPage::IsFullyReinforced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "IsFullyReinforced");

	Params::LSlaveArmPage_IsFullyReinforced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmPage.RequestReset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmPage::RequestReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "RequestReset");

	Params::LSlaveArmPage_RequestReset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmPage.Reset
// (Final, Native, Public)
// Parameters:
// bool                                    bForceReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSlaveArmPage::Reset(bool bForceReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "Reset");

	Params::LSlaveArmPage_Reset Parms{};

	Parms.bForceReset = bForceReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmPage.GetNextReinforceTree
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULSlaveArmTree*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSlaveArmTree* ULSlaveArmPage::GetNextReinforceTree() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmPage", "GetNextReinforceTree");

	Params::LSlaveArmPage_GetNextReinforceTree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.CheckHaveEnoughMagazinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmReinforcementSystem::CheckHaveEnoughMagazinePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "CheckHaveEnoughMagazinePoint");

	Params::LSlaveArmReinforcementSystem_CheckHaveEnoughMagazinePoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.CheckPageActivated
// (Final, Native, Public, BlueprintCallable)

void ULSlaveArmReinforcementSystem::CheckPageActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "CheckPageActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmReinforcementSystem.FindTreeByCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmTreeCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSlaveArmTree*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSlaveArmTree* ULSlaveArmReinforcementSystem::FindTreeByCodeName(class FName SlaveArmTreeCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "FindTreeByCodeName");

	Params::LSlaveArmReinforcementSystem_FindTreeByCodeName Parms{};

	Parms.SlaveArmTreeCodename = SlaveArmTreeCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.FindTreeByDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Depth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSlaveArmTree*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSlaveArmTree* ULSlaveArmReinforcementSystem::FindTreeByDepth(class FName SlaveArmItemCodename, int32 Depth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "FindTreeByDepth");

	Params::LSlaveArmReinforcementSystem_FindTreeByDepth Parms{};

	Parms.SlaveArmItemCodename = SlaveArmItemCodename;
	Parms.Depth = Depth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.FindTreeByPageCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmPageCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULSlaveArmTree*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULSlaveArmTree*> ULSlaveArmReinforcementSystem::FindTreeByPageCodeName(class FName SlaveArmPageCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "FindTreeByPageCodeName");

	Params::LSlaveArmReinforcementSystem_FindTreeByPageCodeName Parms{};

	Parms.SlaveArmPageCodename = SlaveArmPageCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetConsumeMagazinePointMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSlaveArmReinforcementSystem::GetConsumeMagazinePointMultiplier(class FName SlaveArmCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetConsumeMagazinePointMultiplier");

	Params::LSlaveArmReinforcementSystem_GetConsumeMagazinePointMultiplier Parms{};

	Parms.SlaveArmCodeName = SlaveArmCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetIncreasedAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemSlaveArmCodeName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULSlaveArmReinforcementSystem::GetIncreasedAmmo(class FName ItemSlaveArmCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetIncreasedAmmo");

	Params::LSlaveArmReinforcementSystem_GetIncreasedAmmo Parms{};

	Parms.ItemSlaveArmCodeName = ItemSlaveArmCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetReinforcedHitIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BaseHitIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULSlaveArmReinforcementSystem::GetReinforcedHitIndex(class FName SlaveArmItemCodename, int32 BaseHitIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetReinforcedHitIndex");

	Params::LSlaveArmReinforcementSystem_GetReinforcedHitIndex Parms{};

	Parms.SlaveArmItemCodename = SlaveArmItemCodename;
	Parms.BaseHitIndex = BaseHitIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetReinforcedProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BaseProjectileID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULSlaveArmReinforcementSystem::GetReinforcedProjectile(class FName SlaveArmItemCodename, class FName BaseProjectileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetReinforcedProjectile");

	Params::LSlaveArmReinforcementSystem_GetReinforcedProjectile Parms{};

	Parms.SlaveArmItemCodename = SlaveArmItemCodename;
	Parms.BaseProjectileID = BaseProjectileID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetReinforcementInfoList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlavearmReinforcementInfoname                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSlaveArmReinforcementInfoPtr>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSlaveArmReinforcementInfoPtr> ULSlaveArmReinforcementSystem::GetReinforcementInfoList(class FName SlavearmReinforcementInfoname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetReinforcementInfoList");

	Params::LSlaveArmReinforcementSystem_GetReinforcementInfoList Parms{};

	Parms.SlavearmReinforcementInfoname = SlavearmReinforcementInfoname;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmPage
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmPageCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSlaveArmPage*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSlaveArmPage* ULSlaveArmReinforcementSystem::GetSlaveArmPage(class FName SlaveArmPageCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmPage");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmPage Parms{};

	Parms.SlaveArmPageCodename = SlaveArmPageCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmPageBySlaveArmCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULSlaveArmPage*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULSlaveArmPage* ULSlaveArmReinforcementSystem::GetSlaveArmPageBySlaveArmCodeName(class FName SlaveArmItemCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmPageBySlaveArmCodeName");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmPageBySlaveArmCodeName Parms{};

	Parms.SlaveArmItemCodename = SlaveArmItemCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmPageList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ULSlaveArmPage*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULSlaveArmPage*> ULSlaveArmReinforcementSystem::GetSlaveArmPageList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmPageList");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmPageList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmSkillCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULSlaveArmReinforcementSystem::GetSlaveArmSkillCodeName(class FName SlaveArmItemCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmSkillCodeName");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmSkillCodeName Parms{};

	Parms.SlaveArmItemCodename = SlaveArmItemCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ItemSlaveArmCodeName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            InStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULSlaveArmReinforcementSystem::GetSlaveArmStat(class FName ItemSlaveArmCodeName, ELSecondStat InStat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmStat");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmStat Parms{};

	Parms.ItemSlaveArmCodeName = ItemSlaveArmCodeName;
	Parms.InStat = InStat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmTreeListByPageCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmPageCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULSlaveArmTree*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULSlaveArmTree*> ULSlaveArmReinforcementSystem::GetSlaveArmTreeListByPageCodeName(class FName SlaveArmPageCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmTreeListByPageCodeName");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmTreeListByPageCodeName Parms{};

	Parms.SlaveArmPageCodename = SlaveArmPageCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.GetSlaveArmTreeListBySlaveArmCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmItemCodename                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULSlaveArmTree*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULSlaveArmTree*> ULSlaveArmReinforcementSystem::GetSlaveArmTreeListBySlaveArmCodeName(class FName SlaveArmItemCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "GetSlaveArmTreeListBySlaveArmCodeName");

	Params::LSlaveArmReinforcementSystem_GetSlaveArmTreeListBySlaveArmCodeName Parms{};

	Parms.SlaveArmItemCodename = SlaveArmItemCodename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.HasReinforcement
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SlaveArmReinfocementCodeName                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSlaveArmReinforcementSystem::HasReinforcement(class FName SlaveArmReinfocementCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "HasReinforcement");

	Params::LSlaveArmReinforcementSystem_HasReinforcement Parms{};

	Parms.SlaveArmReinfocementCodeName = SlaveArmReinfocementCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSlaveArmReinforcementSystem.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSlaveArmReinforcementSystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "OnGameDataCharacterSync");

	Params::LSlaveArmReinforcementSystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSlaveArmReinforcementSystem.OnOpenUI
// (Final, Native, Public, BlueprintCallable)

void ULSlaveArmReinforcementSystem::OnOpenUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSlaveArmReinforcementSystem", "OnOpenUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystemData.GetBaseSoundMix
// (Event, Public, BlueprintEvent)
// Parameters:
// class USoundMix*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundMix* ALSoundSystemData::GetBaseSoundMix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "GetBaseSoundMix");

	Params::LSoundSystemData_GetBaseSoundMix Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystemData.GetGlobalMuteSoundMixes
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class USoundMix*>                MuteMixes                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALSoundSystemData::GetGlobalMuteSoundMixes(TArray<class USoundMix*>* MuteMixes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "GetGlobalMuteSoundMixes");

	Params::LSoundSystemData_GetGlobalMuteSoundMixes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MuteMixes != nullptr)
		*MuteMixes = std::move(Parms.MuteMixes);
}


// Function ProjectP.LSoundSystemData.GetSoundVolumeFadeTime
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALSoundSystemData::GetSoundVolumeFadeTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "GetSoundVolumeFadeTime");

	Params::LSoundSystemData_GetSoundVolumeFadeTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystemData.OnCompletePlayDialogSound
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALSoundSystemData::OnCompletePlayDialogSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnCompletePlayDialogSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LSoundSystemData.OnFadeMuteSound
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bMute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALSoundSystemData::OnFadeMuteSound(bool bMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnFadeMuteSound");

	Params::LSoundSystemData_OnFadeMuteSound Parms{};

	Parms.bMute = bMute;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LSoundSystemData.OnPlayBGM
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             SoundName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlayResult                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALSoundSystemData::OnPlayBGM(class FName SoundName, bool* PlayResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnPlayBGM");

	Params::LSoundSystemData_OnPlayBGM Parms{};

	Parms.SoundName = SoundName;

	UObject::ProcessEvent(Func, &Parms);

	if (PlayResult != nullptr)
		*PlayResult = Parms.PlayResult;
}


// Function ProjectP.LSoundSystemData.OnPlayDialogSound
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FDialogInfoPtr                   InDialog                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALSoundSystemData::OnPlayDialogSound(const struct FDialogInfoPtr& InDialog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnPlayDialogSound");

	Params::LSoundSystemData_OnPlayDialogSound Parms{};

	Parms.InDialog = std::move(InDialog);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystemData.OnPlayRecord
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALPropSpot*                       InSoundSource                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALSoundSystemData::OnPlayRecord(class FName RecordCodeName, class ALPropSpot* InSoundSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnPlayRecord");

	Params::LSoundSystemData_OnPlayRecord Parms{};

	Parms.RecordCodeName = RecordCodeName;
	Parms.InSoundSource = InSoundSource;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystemData.OnPreCompletePlayDialogSound
// (Event, Public, BlueprintEvent)

void ALSoundSystemData::OnPreCompletePlayDialogSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnPreCompletePlayDialogSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LSoundSystemData.OnStopBGM
// (Event, Public, BlueprintEvent)

void ALSoundSystemData::OnStopBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnStopBGM");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LSoundSystemData.OnStopDialogSound
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SkipFadeOut                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALSoundSystemData::OnStopDialogSound(bool SkipFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnStopDialogSound");

	Params::LSoundSystemData_OnStopDialogSound Parms{};

	Parms.SkipFadeOut = SkipFadeOut;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystemData.OnStopRecord
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALSoundSystemData::OnStopRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystemData", "OnStopRecord");

	Params::LSoundSystemData_OnStopRecord Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.AcquireHumanityRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::AcquireHumanityRecord(class FName RecordCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "AcquireHumanityRecord");

	Params::LSoundSystem_AcquireHumanityRecord Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.AddSoundControlComponentToRefresh
// (Final, Native, Public)
// Parameters:
// class ULSoundControlComponent*          Comp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::AddSoundControlComponentToRefresh(class ULSoundControlComponent* Comp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "AddSoundControlComponentToRefresh");

	Params::LSoundSystem_AddSoundControlComponentToRefresh Parms{};

	Parms.Comp = Comp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.CheckPlayBGM_FromNpc
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SoundName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowSoundNameUI                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::CheckPlayBGM_FromNpc(const class FName& NpcName, const class FName& SoundName, bool bShowSoundNameUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "CheckPlayBGM_FromNpc");

	Params::LSoundSystem_CheckPlayBGM_FromNpc Parms{};

	Parms.NpcName = NpcName;
	Parms.SoundName = SoundName;
	Parms.bShowSoundNameUI = bShowSoundNameUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.CheckStopBGM
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SoundName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::CheckStopBGM(const class FName& SoundName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "CheckStopBGM");

	Params::LSoundSystem_CheckStopBGM Parms{};

	Parms.SoundName = SoundName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.CheckStopBGM_FromNpc
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NpcName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SoundName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::CheckStopBGM_FromNpc(const class FName& NpcName, const class FName& SoundName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "CheckStopBGM_FromNpc");

	Params::LSoundSystem_CheckStopBGM_FromNpc Parms{};

	Parms.NpcName = NpcName;
	Parms.SoundName = SoundName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.ClearSoundControlComponentsToRefresh
// (Final, Native, Public)

void ULSoundSystem::ClearSoundControlComponentsToRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "ClearSoundControlComponentsToRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.ClearSoundMix
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundMix*                        SoundMix                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::ClearSoundMix(class USoundMix* SoundMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "ClearSoundMix");

	Params::LSoundSystem_ClearSoundMix Parms{};

	Parms.SoundMix = SoundMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.DoCompletePlayDialogSound
// (Final, Native, Public, BlueprintCallable)

void ULSoundSystem::DoCompletePlayDialogSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoCompletePlayDialogSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.DoNextPlayRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoNextPlayRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoNextPlayRecord");

	Params::LSoundSystem_DoNextPlayRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.DoPlayBGM
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SoundName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowSoundNameUI                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoPlayBGM(const class FName& SoundName, bool bShowSoundNameUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoPlayBGM");

	Params::LSoundSystem_DoPlayBGM Parms{};

	Parms.SoundName = SoundName;
	Parms.bShowSoundNameUI = bShowSoundNameUI;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.DoPlayDialogSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDialogInfoPtr                   InDialog                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoPlayDialogSound(const struct FDialogInfoPtr& InDialog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoPlayDialogSound");

	Params::LSoundSystem_DoPlayDialogSound Parms{};

	Parms.InDialog = std::move(InDialog);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.DoPlayRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoPlayRecord(class FName RecordCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoPlayRecord");

	Params::LSoundSystem_DoPlayRecord Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.DoPrevPlayRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoPrevPlayRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoPrevPlayRecord");

	Params::LSoundSystem_DoPrevPlayRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.DoStopBGM
// (Final, Native, Public, BlueprintCallable)

void ULSoundSystem::DoStopBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoStopBGM");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.DoStopDialogSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    SkipFadeOut                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoStopDialogSound(bool SkipFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoStopDialogSound");

	Params::LSoundSystem_DoStopDialogSound Parms{};

	Parms.SkipFadeOut = SkipFadeOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.DoStopRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::DoStopRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "DoStopRecord");

	Params::LSoundSystem_DoStopRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.FadeMuteSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::FadeMuteSound(bool bMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "FadeMuteSound");

	Params::LSoundSystem_FadeMuteSound Parms{};

	Parms.bMute = bMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.FindPlayableRecordFromPlayingNow
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    FindNext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULSoundSystem::FindPlayableRecordFromPlayingNow(bool FindNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "FindPlayableRecordFromPlayingNow");

	Params::LSoundSystem_FindPlayableRecordFromPlayingNow Parms{};

	Parms.FindNext = FindNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetAllRecordList
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FItemCommonInfo>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FItemCommonInfo> ULSoundSystem::GetAllRecordList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetAllRecordList");

	Params::LSoundSystem_GetAllRecordList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetClassVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundClass*                      TargetSoundClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetClassVolume(class USoundClass* TargetSoundClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetClassVolume");

	Params::LSoundSystem_GetClassVolume Parms{};

	Parms.TargetSoundClass = TargetSoundClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetDialogSound
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutUseSoundMix                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundCue*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundCue* ULSoundSystem::GetDialogSound(class FName RowName, bool* OutUseSoundMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetDialogSound");

	Params::LSoundSystem_GetDialogSound Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUseSoundMix != nullptr)
		*OutUseSoundMix = Parms.OutUseSoundMix;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetMultifliedVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELVolumeType                            FindType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetMultifliedVolume(ELVolumeType FindType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetMultifliedVolume");

	Params::LSoundSystem_GetMultifliedVolume Parms{};

	Parms.FindType = FindType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetRecordCue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundCue*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundCue* ULSoundSystem::GetRecordCue(class FName RecordCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetRecordCue");

	Params::LSoundSystem_GetRecordCue Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetRecordCurrentDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundWave*                       PlayingSoundWave                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackPercent                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetRecordCurrentDuration(const class USoundWave* PlayingSoundWave, const float PlaybackPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetRecordCurrentDuration");

	Params::LSoundSystem_GetRecordCurrentDuration Parms{};

	Parms.PlayingSoundWave = PlayingSoundWave;
	Parms.PlaybackPercent = PlaybackPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetRecordDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetRecordDuration(class FName RecordCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetRecordDuration");

	Params::LSoundSystem_GetRecordDuration Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetSwishMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetSwishMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetSwishMultiplier");

	Params::LSoundSystem_GetSwishMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELVolumeType                            FindType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetVolume(ELVolumeType FindType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetVolume");

	Params::LSoundSystem_GetVolume Parms{};

	Parms.FindType = FindType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.IsPlayableUISound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::IsPlayableUISound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "IsPlayableUISound");

	Params::LSoundSystem_IsPlayableUISound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.IsPlayingBGM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::IsPlayingBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "IsPlayingBGM");

	Params::LSoundSystem_IsPlayingBGM Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.IsPushedSoundMix
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USoundMix*                        SoundMix                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::IsPushedSoundMix(class USoundMix* SoundMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "IsPushedSoundMix");

	Params::LSoundSystem_IsPushedSoundMix Parms{};

	Parms.SoundMix = SoundMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.MuteAllSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFade                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::MuteAllSound(bool bMute, bool bFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "MuteAllSound");

	Params::LSoundSystem_MuteAllSound Parms{};

	Parms.bMute = bMute;
	Parms.bFade = bFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.MuteSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::MuteSound(bool bMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "MuteSound");

	Params::LSoundSystem_MuteSound Parms{};

	Parms.bMute = bMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.MuteUISound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Mute                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::MuteUISound(bool Mute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "MuteUISound");

	Params::LSoundSystem_MuteUISound Parms{};

	Parms.Mute = Mute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.OnExecuteTeleport
// (Final, Native, Public)

void ULSoundSystem::OnExecuteTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "OnExecuteTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.OnRecordPlaybackPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundWave*                       PlayingSoundWave                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackPercent                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::OnRecordPlaybackPercent(const class USoundWave* PlayingSoundWave, const float PlaybackPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "OnRecordPlaybackPercent");

	Params::LSoundSystem_OnRecordPlaybackPercent Parms{};

	Parms.PlayingSoundWave = PlayingSoundWave;
	Parms.PlaybackPercent = PlaybackPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.PlaySound2DFromSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::PlaySound2DFromSequence(class USoundBase* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "PlaySound2DFromSequence");

	Params::LSoundSystem_PlaySound2DFromSequence Parms{};

	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.PopSoundMixFromSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundMix*                        SoundMix                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::PopSoundMixFromSequence(class USoundMix* SoundMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "PopSoundMixFromSequence");

	Params::LSoundSystem_PopSoundMixFromSequence Parms{};

	Parms.SoundMix = SoundMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.PushSoundMix_MustFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundMix*                        SoundMix                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::PushSoundMix_MustFadeIn(class USoundMix* SoundMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "PushSoundMix_MustFadeIn");

	Params::LSoundSystem_PushSoundMix_MustFadeIn Parms{};

	Parms.SoundMix = SoundMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.PushSoundMixFromSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundMix*                        SoundMix                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::PushSoundMixFromSequence(class USoundMix* SoundMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "PushSoundMixFromSequence");

	Params::LSoundSystem_PushSoundMixFromSequence Parms{};

	Parms.SoundMix = SoundMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.RefreshRecordState
// (Final, Native, Public, BlueprintCallable)

void ULSoundSystem::RefreshRecordState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "RefreshRecordState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.SetPendingNextPlayRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSoundSystem::SetPendingNextPlayRecord(class FName RecordCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "SetPendingNextPlayRecord");

	Params::LSoundSystem_SetPendingNextPlayRecord Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSoundSystem.SetVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELVolumeType                            FindType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::SetVolume(ELVolumeType FindType, float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "SetVolume");

	Params::LSoundSystem_SetVolume Parms{};

	Parms.FindType = FindType;
	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetAudioVolumeConcurrency
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAudioComponent*                  InAudioComp                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULSoundSystem::GetAudioVolumeConcurrency(const class UAudioComponent* InAudioComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetAudioVolumeConcurrency");

	Params::LSoundSystem_GetAudioVolumeConcurrency Parms{};

	Parms.InAudioComp = InAudioComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.GetIsAsncLoadingMapCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::GetIsAsncLoadingMapCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "GetIsAsncLoadingMapCompleted");

	Params::LSoundSystem_GetIsAsncLoadingMapCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.IsNotiRecord
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::IsNotiRecord(class FName RecordCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "IsNotiRecord");

	Params::LSoundSystem_IsNotiRecord Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.IsRecord_CanAquireHumanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::IsRecord_CanAquireHumanity(class FName RecordCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "IsRecord_CanAquireHumanity");

	Params::LSoundSystem_IsRecord_CanAquireHumanity Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSoundSystem.IsRecordHavingHumanity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RecordCodeName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSoundSystem::IsRecordHavingHumanity(class FName RecordCodeName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSoundSystem", "IsRecordHavingHumanity");

	Params::LSoundSystem_IsRecordHavingHumanity Parms{};

	Parms.RecordCodeName = RecordCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSpecialBuff_Abnormal_By_HP.OnUpdateHP
// (Final, Native, Public)
// Parameters:
// int32                                   CurrentHP                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxHP                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_By_HP::OnUpdateHP(int32 CurrentHP, int32 MaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_By_HP", "OnUpdateHP");

	Params::LSpecialBuff_Abnormal_By_HP_OnUpdateHP Parms{};

	Parms.CurrentHP = CurrentHP;
	Parms.MaxHP = MaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_By_WeaponChange.ApplyAbnormal
// (Final, Native, Public)

void ULSpecialBuff_Abnormal_By_WeaponChange::ApplyAbnormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_By_WeaponChange", "ApplyAbnormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack.ApplyAbnormal
// (Final, Native, Public)

void ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack::ApplyAbnormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack", "ApplyAbnormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Resurrection.OnUpdateHP
// (Final, Native, Public)
// Parameters:
// int32                                   CurrentHP                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxHP                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Resurrection::OnUpdateHP(int32 CurrentHP, int32 MaxHP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Resurrection", "OnUpdateHP");

	Params::LSpecialBuff_Resurrection_OnUpdateHP Parms{};

	Parms.CurrentHP = CurrentHP;
	Parms.MaxHP = MaxHP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_On_PulseRechargeState.OnEnterActionState
// (Final, Native, Public)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_On_PulseRechargeState::OnEnterActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_On_PulseRechargeState", "OnEnterActionState");

	Params::LSpecialBuff_Abnormal_On_PulseRechargeState_OnEnterActionState Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_On_PulseRechargeState.OnLeaveActionState
// (Final, Native, Public)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPair                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_On_PulseRechargeState::OnLeaveActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_On_PulseRechargeState", "OnLeaveActionState");

	Params::LSpecialBuff_Abnormal_On_PulseRechargeState_OnLeaveActionState Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.ActionState = ActionState;
	Parms.IsPair = IsPair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_On_Debuff.OnApplyRunningAbnormal
// (Final, Native, Public)
// Parameters:
// bool                                    IsApply                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AbnormalCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_On_Debuff::OnApplyRunningAbnormal(bool IsApply, class FName AbnormalCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_On_Debuff", "OnApplyRunningAbnormal");

	Params::LSpecialBuff_Abnormal_On_Debuff_OnApplyRunningAbnormal Parms{};

	Parms.IsApply = IsApply;
	Parms.AbnormalCodeName = AbnormalCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuff_Abnormal_By_Pulse_ExhastedCount.ApplyAbnormal
// (Final, Native, Public)
// Parameters:
// int32                                   ExhastedCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount::ApplyAbnormal(int32 ExhastedCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuff_Abnormal_By_Pulse_ExhastedCount", "ApplyAbnormal");

	Params::LSpecialBuff_Abnormal_By_Pulse_ExhastedCount_ApplyAbnormal Parms{};

	Parms.ExhastedCount = ExhastedCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuffSystem.AddBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpecialBuffCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuffSystem::AddBuff(class FName SpecialBuffCodeName, class FName Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "AddBuff");

	Params::LSpecialBuffSystem_AddBuff Parms{};

	Parms.SpecialBuffCodeName = SpecialBuffCodeName;
	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuffSystem.CheckHaveBuff
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSpecialBuffType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSpecialBuffSystem::CheckHaveBuff(ELSpecialBuffType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "CheckHaveBuff");

	Params::LSpecialBuffSystem_CheckHaveBuff Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSpecialBuffSystem.GetAppliedBuff
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSpecialBuffType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ULSpecialBuff*>            OutBuffInfoList                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSpecialBuffSystem::GetAppliedBuff(ELSpecialBuffType Type, TArray<class ULSpecialBuff*>* OutBuffInfoList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "GetAppliedBuff");

	Params::LSpecialBuffSystem_GetAppliedBuff Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBuffInfoList != nullptr)
		*OutBuffInfoList = std::move(Parms.OutBuffInfoList);

	return Parms.ReturnValue;
}


// Function ProjectP.LSpecialBuffSystem.GetAppliedBuffAll
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ULSpecialBuff*>            OutBuffInfoList                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULSpecialBuffSystem::GetAppliedBuffAll(TArray<class ULSpecialBuff*>* OutBuffInfoList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "GetAppliedBuffAll");

	Params::LSpecialBuffSystem_GetAppliedBuffAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBuffInfoList != nullptr)
		*OutBuffInfoList = std::move(Parms.OutBuffInfoList);

	return Parms.ReturnValue;
}


// Function ProjectP.LSpecialBuffSystem.GetAppliedBuffTotalAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSpecialBuffType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULSpecialBuffSystem::GetAppliedBuffTotalAmount(ELSpecialBuffType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "GetAppliedBuffTotalAmount");

	Params::LSpecialBuffSystem_GetAppliedBuffTotalAmount Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LSpecialBuffSystem.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuffSystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "OnGameDataCharacterSync");

	Params::LSpecialBuffSystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuffSystem.OnHumanityChangesSpecialBuff
// (Final, Native, Public)
// Parameters:
// struct FHumanizationBuffAlterInfoPtr    BuffAlterInfo                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULSpecialBuffSystem::OnHumanityChangesSpecialBuff(const struct FHumanizationBuffAlterInfoPtr& BuffAlterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "OnHumanityChangesSpecialBuff");

	Params::LSpecialBuffSystem_OnHumanityChangesSpecialBuff Parms{};

	Parms.BuffAlterInfo = std::move(BuffAlterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuffSystem.OnPerfectGuardSuccessOnFuryAttack
// (Final, Native, Public, BlueprintCallable)

void ULSpecialBuffSystem::OnPerfectGuardSuccessOnFuryAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "OnPerfectGuardSuccessOnFuryAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuffSystem.OnStatChanged
// (Final, Native, Public)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddedValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrevStatValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuffSystem::OnStatChanged(ELSecondStat StatType, int32 AddedValue, int32 PrevStatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "OnStatChanged");

	Params::LSpecialBuffSystem_OnStatChanged Parms{};

	Parms.StatType = StatType;
	Parms.AddedValue = AddedValue;
	Parms.PrevStatValue = PrevStatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LSpecialBuffSystem.RemoveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SpecialBuffCodeName                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULSpecialBuffSystem::RemoveBuff(class FName SpecialBuffCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LSpecialBuffSystem", "RemoveBuff");

	Params::LSpecialBuffSystem_RemoveBuff Parms{};

	Parms.SpecialBuffCodeName = SpecialBuffCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatComponent.EndStaminaRestore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULStatComponent::EndStaminaRestore(class UObject* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "EndStaminaRestore");

	Params::LStatComponent_EndStaminaRestore Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatComponent.GetCharacterRawStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULStatComponent::GetCharacterRawStat(ELSecondStat StatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "GetCharacterRawStat");

	Params::LStatComponent_GetCharacterRawStat Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.GetCharacterStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULStatComponent::GetCharacterStat(ELSecondStat StatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "GetCharacterStat");

	Params::LStatComponent_GetCharacterStat Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.GetStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELStatDataType                          DataType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULStatComponent::GetStat(ELStatDataType DataType, ELSecondStat StatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "GetStat");

	Params::LStatComponent_GetStat Parms{};

	Parms.DataType = DataType;
	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.GetStatByPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CalcRatio                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULStatComponent::GetStatByPercent(ELSecondStat StatType, float CalcRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "GetStatByPercent");

	Params::LStatComponent_GetStatByPercent Parms{};

	Parms.StatType = StatType;
	Parms.CalcRatio = CalcRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.GetStatInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Current                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Ratio                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULStatComponent::GetStatInfo(ELSecondStat StatType, int32* Current, int32* Max, float* Ratio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "GetStatInfo");

	Params::LStatComponent_GetStatInfo Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Current != nullptr)
		*Current = Parms.Current;

	if (Max != nullptr)
		*Max = Parms.Max;

	if (Ratio != nullptr)
		*Ratio = Parms.Ratio;
}


// Function ProjectP.LStatComponent.GetStatPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULStatComponent::GetStatPercent(ELSecondStat StatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "GetStatPercent");

	Params::LStatComponent_GetStatPercent Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.RecoveryMaxStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULStatComponent::RecoveryMaxStat(ELSecondStat StatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "RecoveryMaxStat");

	Params::LStatComponent_RecoveryMaxStat Parms{};

	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.RecoveryStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELSecondStat                            StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULStatComponent::RecoveryStat(ELSecondStat StatType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "RecoveryStat");

	Params::LStatComponent_RecoveryStat Parms{};

	Parms.StatType = StatType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatComponent.StartStaminaRestore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Ratio                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULStatComponent::StartStaminaRestore(float Ratio, class UObject* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatComponent", "StartStaminaRestore");

	Params::LStatComponent_StartStaminaRestore Parms{};

	Parms.Ratio = Ratio;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatRoomPCCharacter.AttachPCLamp
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALStatRoomPCCharacter::AttachPCLamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "AttachPCLamp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LStatRoomPCCharacter.CheckCanChangeFirstStat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ELFirstStat                             FirstStat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChangeData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutErrorCode                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALStatRoomPCCharacter::CheckCanChangeFirstStat(ELFirstStat FirstStat, int32 ChangeData, int32* OutErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "CheckCanChangeFirstStat");

	Params::LStatRoomPCCharacter_CheckCanChangeFirstStat Parms{};

	Parms.FirstStat = FirstStat;
	Parms.ChangeData = ChangeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutErrorCode != nullptr)
		*OutErrorCode = Parms.OutErrorCode;

	return Parms.ReturnValue;
}


// Function ProjectP.LStatRoomPCCharacter.GetDiffStat_ByFirstStat
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FLSecondStatDiffData>     Common_SecondStatDiff                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLSecondStatDiffData>     Weapon1_SecondStatDiff                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLSecondStatDiffData>     Weapon2_SecondStatDiff                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLSecondStatDiffData>     Weapon3_SecondStatDiff                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLSecondStatDiffData>     SlaveArm1_SecondStatDiff                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLSecondStatDiffData>     SlaveArm2_SecondStatDiff                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FLSecondStatDiffData>     SlaveArm3_SecondStatDiff                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALStatRoomPCCharacter::GetDiffStat_ByFirstStat(TArray<struct FLSecondStatDiffData>* Common_SecondStatDiff, TArray<struct FLSecondStatDiffData>* Weapon1_SecondStatDiff, TArray<struct FLSecondStatDiffData>* Weapon2_SecondStatDiff, TArray<struct FLSecondStatDiffData>* Weapon3_SecondStatDiff, TArray<struct FLSecondStatDiffData>* SlaveArm1_SecondStatDiff, TArray<struct FLSecondStatDiffData>* SlaveArm2_SecondStatDiff, TArray<struct FLSecondStatDiffData>* SlaveArm3_SecondStatDiff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "GetDiffStat_ByFirstStat");

	Params::LStatRoomPCCharacter_GetDiffStat_ByFirstStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Common_SecondStatDiff != nullptr)
		*Common_SecondStatDiff = std::move(Parms.Common_SecondStatDiff);

	if (Weapon1_SecondStatDiff != nullptr)
		*Weapon1_SecondStatDiff = std::move(Parms.Weapon1_SecondStatDiff);

	if (Weapon2_SecondStatDiff != nullptr)
		*Weapon2_SecondStatDiff = std::move(Parms.Weapon2_SecondStatDiff);

	if (Weapon3_SecondStatDiff != nullptr)
		*Weapon3_SecondStatDiff = std::move(Parms.Weapon3_SecondStatDiff);

	if (SlaveArm1_SecondStatDiff != nullptr)
		*SlaveArm1_SecondStatDiff = std::move(Parms.SlaveArm1_SecondStatDiff);

	if (SlaveArm2_SecondStatDiff != nullptr)
		*SlaveArm2_SecondStatDiff = std::move(Parms.SlaveArm2_SecondStatDiff);

	if (SlaveArm3_SecondStatDiff != nullptr)
		*SlaveArm3_SecondStatDiff = std::move(Parms.SlaveArm3_SecondStatDiff);
}


// Function ProjectP.LStatRoomPCCharacter.OnActiveMesh
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALStatRoomPCCharacter::OnActiveMesh(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "OnActiveMesh");

	Params::LStatRoomPCCharacter_OnActiveMesh Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatRoomPCCharacter.OnSetActiveEnvironment
// (Final, Native, Public)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALStatRoomPCCharacter::OnSetActiveEnvironment(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "OnSetActiveEnvironment");

	Params::LStatRoomPCCharacter_OnSetActiveEnvironment Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatRoomPCCharacter.UIChangeFirstStat
// (Final, Native, Public)
// Parameters:
// ELFirstStat                             FirstStat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChangeData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALStatRoomPCCharacter::UIChangeFirstStat(ELFirstStat FirstStat, int32 ChangeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "UIChangeFirstStat");

	Params::LStatRoomPCCharacter_UIChangeFirstStat Parms{};

	Parms.FirstStat = FirstStat;
	Parms.ChangeData = ChangeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatRoomPCCharacter.UIConfirmCharacterStat
// (Final, Native, Public)

void ALStatRoomPCCharacter::UIConfirmCharacterStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "UIConfirmCharacterStat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LStatRoomPCCharacter.GetFirstStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELFirstStatDataType                     DataType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELFirstStat                             StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALStatRoomPCCharacter::GetFirstStat(ELFirstStatDataType DataType, ELFirstStat StatType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LStatRoomPCCharacter", "GetFirstStat");

	Params::LStatRoomPCCharacter_GetFirstStat Parms{};

	Parms.DataType = DataType;
	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTeleportObjectSpot.GetSpawnPointTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ALTeleportObjectSpot::GetSpawnPointTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "GetSpawnPointTransform");

	Params::LTeleportObjectSpot_GetSpawnPointTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTeleportObjectSpot.GetTeleportObjectCodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALTeleportObjectSpot::GetTeleportObjectCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "GetTeleportObjectCodeName");

	Params::LTeleportObjectSpot_GetTeleportObjectCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTeleportObjectSpot.IsPortal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALTeleportObjectSpot::IsPortal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "IsPortal");

	Params::LTeleportObjectSpot_IsPortal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTeleportObjectSpot.OnClosedWindow
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALTeleportObjectSpot::OnClosedWindow(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "OnClosedWindow");

	Params::LTeleportObjectSpot_OnClosedWindow Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.OnCompleteTorsionCoilActiveAlert
// (Final, Native, Public)

void ALTeleportObjectSpot::OnCompleteTorsionCoilActiveAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "OnCompleteTorsionCoilActiveAlert");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.OnComponentBeginOverlapPropOverlapPawn
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALTeleportObjectSpot::OnComponentBeginOverlapPropOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "OnComponentBeginOverlapPropOverlapPawn");

	Params::LTeleportObjectSpot_OnComponentBeginOverlapPropOverlapPawn Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.OnComponentEndOverlapPropOverlapPawn
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALTeleportObjectSpot::OnComponentEndOverlapPropOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "OnComponentEndOverlapPropOverlapPawn");

	Params::LTeleportObjectSpot_OnComponentEndOverlapPropOverlapPawn Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.OnFinishedPortalSequenceActor
// (Final, Native, Protected)

void ALTeleportObjectSpot::OnFinishedPortalSequenceActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "OnFinishedPortalSequenceActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.OnInteractTorsionCoil
// (Final, Native, Public)

void ALTeleportObjectSpot::OnInteractTorsionCoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "OnInteractTorsionCoil");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.RefreshStargazerUnstable
// (Final, Native, Protected)

void ALTeleportObjectSpot::RefreshStargazerUnstable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "RefreshStargazerUnstable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTeleportObjectSpot.SetTeleportObjectCodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCodeName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALTeleportObjectSpot::SetTeleportObjectCodeName(class FName InCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LTeleportObjectSpot", "SetTeleportObjectCodeName");

	Params::LTeleportObjectSpot_SetTeleportObjectCodeName Parms{};

	Parms.InCodeName = InCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LTextLocalization.GetGameStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           CodeName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULTextLocalization::GetGameStr(const class FString& CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LTextLocalization", "GetGameStr");

	Params::LTextLocalization_GetGameStr Parms{};

	Parms.CodeName = std::move(CodeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTextLocalization.GetGameStrWithName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULTextLocalization::GetGameStrWithName(class FName CodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LTextLocalization", "GetGameStrWithName");

	Params::LTextLocalization_GetGameStrWithName Parms{};

	Parms.CodeName = CodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LTextLocalization.InitLoadLocalization
// (Final, Native, Static, Public, BlueprintCallable)

void ULTextLocalization::InitLoadLocalization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LTextLocalization", "InitLoadLocalization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.AddSystemMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)

void ULUISystem::AddSystemMessage(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "AddSystemMessage");

	Params::LUISystem_AddSystemMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.CompleteLoadingGauge
// (Final, Native, Public, BlueprintCallable)

void ULUISystem::CompleteLoadingGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "CompleteLoadingGauge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.CompleteNotify_UI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InUIName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULUISystem::CompleteNotify_UI(const class FString& InUIName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "CompleteNotify_UI");

	Params::LUISystem_CompleteNotify_UI Parms{};

	Parms.InUIName = std::move(InUIName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.CreateMainWidget
// (Final, Native, Public, BlueprintCallable)

void ULUISystem::CreateMainWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "CreateMainWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.GetAlertBlock
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULUISystem::GetAlertBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "GetAlertBlock");

	Params::LUISystem_GetAlertBlock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LUISystem.GetLoadingScreenHandler
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULLoadingScreenHandler*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULLoadingScreenHandler* ULUISystem::GetLoadingScreenHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "GetLoadingScreenHandler");

	Params::LUISystem_GetLoadingScreenHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LUISystem.IsNotified_UI
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InUIName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULUISystem::IsNotified_UI(const class FString& InUIName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "IsNotified_UI");

	Params::LUISystem_IsNotified_UI Parms{};

	Parms.InUIName = std::move(InUIName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LUISystem.OnFirstSelectActionTypeForcly
// (Final, Native, Public, BlueprintCallable)

void ULUISystem::OnFirstSelectActionTypeForcly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "OnFirstSelectActionTypeForcly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.OnGameDataCharacterSync
// (Final, Native, Public)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULUISystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "OnGameDataCharacterSync");

	Params::LUISystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.RemoveSystemMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)

void ULUISystem::RemoveSystemMessage(const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "RemoveSystemMessage");

	Params::LUISystem_RemoveSystemMessage Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.StartLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELLoadingScreenType                     Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULUISystem::StartLoadingScreen(ELLoadingScreenType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "StartLoadingScreen");

	Params::LUISystem_StartLoadingScreen Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.StopLoadingScreen
// (Final, Native, Public, BlueprintCallable)

void ULUISystem::StopLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "StopLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LUISystem.GetMainWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULWidget*                         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWidget* ULUISystem::GetMainWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LUISystem", "GetMainWidget");

	Params::LUISystem_GetMainWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.ForceSuccess
// (Final, Native, Public, BlueprintCallable)

void ULLoadingScreenHandler::ForceSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "ForceSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.GetProgressRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckLevelLoadOnly                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULLoadingScreenHandler::GetProgressRate(float DeltaTime, bool bCheckLevelLoadOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetProgressRate");

	Params::LLoadingScreenHandler_GetProgressRate Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.bCheckLevelLoadOnly = bCheckLevelLoadOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.GetSelectedLoadingScreenTableCodeName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULLoadingScreenHandler::GetSelectedLoadingScreenTableCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetSelectedLoadingScreenTableCodeName");

	Params::LLoadingScreenHandler_GetSelectedLoadingScreenTableCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.InvisibleLoading
// (Final, Native, Public, BlueprintCallable)

void ULLoadingScreenHandler::InvisibleLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "InvisibleLoading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.MoveLifeTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLoadingScreenHandler::MoveLifeTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "MoveLifeTime");

	Params::LLoadingScreenHandler_MoveLifeTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.NextIndicatorIndex
// (Final, Native, Public, BlueprintCallable)

void ULLoadingScreenHandler::NextIndicatorIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "NextIndicatorIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.SelectLoadingScreenTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULDataTableSystem*                DataTableSystem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULQuestSystem*                    QuestSystem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLoadingScreenHandler::SelectLoadingScreenTable(class ULDataTableSystem* DataTableSystem, class ULQuestSystem* QuestSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "SelectLoadingScreenTable");

	Params::LLoadingScreenHandler_SelectLoadingScreenTable Parms{};

	Parms.DataTableSystem = DataTableSystem;
	Parms.QuestSystem = QuestSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.SetIndicatorIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLoadingScreenHandler::SetIndicatorIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "SetIndicatorIndex");

	Params::LLoadingScreenHandler_SetIndicatorIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.StartLoadingSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLLoadingScreenContext           LoadingContext                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULLoadingScreenHandler::StartLoadingSequence(const struct FLLoadingScreenContext& LoadingContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "StartLoadingSequence");

	Params::LLoadingScreenHandler_StartLoadingSequence Parms{};

	Parms.LoadingContext = std::move(LoadingContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.StopLoadingSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELLoadingScreenUsage                    Usage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLoadingScreenHandler::StopLoadingSequence(ELLoadingScreenUsage Usage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "StopLoadingSequence");

	Params::LLoadingScreenHandler_StopLoadingSequence Parms{};

	Parms.Usage = Usage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.VisibleLoading
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMainLoading                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULLoadingScreenHandler::VisibleLoading(bool bMainLoading)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "VisibleLoading");

	Params::LLoadingScreenHandler_VisibleLoading Parms{};

	Parms.bMainLoading = bMainLoading;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LLoadingScreenHandler.GetIndicatorIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULLoadingScreenHandler::GetIndicatorIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetIndicatorIndex");

	Params::LLoadingScreenHandler_GetIndicatorIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.GetLifeTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULLoadingScreenHandler::GetLifeTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetLifeTime");

	Params::LLoadingScreenHandler_GetLifeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.GetSelectedImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> ULLoadingScreenHandler::GetSelectedImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetSelectedImage");

	Params::LLoadingScreenHandler_GetSelectedImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.GetSelectedTipGameStringCodeNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> ULLoadingScreenHandler::GetSelectedTipGameStringCodeNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetSelectedTipGameStringCodeNames");

	Params::LLoadingScreenHandler_GetSelectedTipGameStringCodeNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.GetUsage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELLoadingScreenUsage                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELLoadingScreenUsage ULLoadingScreenHandler::GetUsage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "GetUsage");

	Params::LLoadingScreenHandler_GetUsage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.IsLoadingComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLoadingScreenHandler::IsLoadingComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "IsLoadingComplete");

	Params::LLoadingScreenHandler_IsLoadingComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.IsLoadingSequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLoadingScreenHandler::IsLoadingSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "IsLoadingSequence");

	Params::LLoadingScreenHandler_IsLoadingSequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.IsLoadingVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLoadingScreenHandler::IsLoadingVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "IsLoadingVisible");

	Params::LLoadingScreenHandler_IsLoadingVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LLoadingScreenHandler.IsMovieEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULLoadingScreenHandler::IsMovieEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LLoadingScreenHandler", "IsMovieEnabled");

	Params::LLoadingScreenHandler_IsMovieEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeaponDerbisBlade.GetActiveMeshComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMeshComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMeshComponent* ALWeaponDerbisBlade::GetActiveMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeaponDerbisBlade", "GetActiveMeshComponent");

	Params::LWeaponDerbisBlade_GetActiveMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.ApplyElement
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ElementName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ApplyElement(class FName ElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ApplyElement");

	Params::LWeapon_ApplyElement Parms{};

	Parms.ElementName = ElementName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.ApplyFxParameter_BladeLength
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLAttachedEffectSet              EffectSet                                              (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALWeapon::ApplyFxParameter_BladeLength(struct FLAttachedEffectSet* EffectSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ApplyFxParameter_BladeLength");

	Params::LWeapon_ApplyFxParameter_BladeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EffectSet != nullptr)
		*EffectSet = std::move(Parms.EffectSet);
}


// Function ProjectP.LWeapon.ApplyMaterialVarying
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MaterialFxCodename                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ApplyMaterialVarying(class FName MaterialFxCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ApplyMaterialVarying");

	Params::LWeapon_ApplyMaterialVarying Parms{};

	Parms.MaterialFxCodename = MaterialFxCodename;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.BreakBlade
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ImpulseDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::BreakBlade(const struct FVector& ImpulseDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "BreakBlade");

	Params::LWeapon_BreakBlade Parms{};

	Parms.ImpulseDirection = std::move(ImpulseDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.BrokenBlade
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::BrokenBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "BrokenBlade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.BrokenBladeOnBuild
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::BrokenBladeOnBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "BrokenBladeOnBuild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.BuildEachCollision_AutoLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                CollisionComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsuleOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::BuildEachCollision_AutoLocation(class UCapsuleComponent* CollisionComp, const struct FVector& CapsuleOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "BuildEachCollision_AutoLocation");

	Params::LWeapon_BuildEachCollision_AutoLocation Parms{};

	Parms.CollisionComp = CollisionComp;
	Parms.CapsuleOffset = std::move(CapsuleOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.BuildEachCollision_AutoSize
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                CollisionComp                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleHalfHeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::BuildEachCollision_AutoSize(class UCapsuleComponent* CollisionComp, class USkeletalMeshComponent* MeshComp, float CapsuleRadius, float CapsuleHalfHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "BuildEachCollision_AutoSize");

	Params::LWeapon_BuildEachCollision_AutoSize Parms{};

	Parms.CollisionComp = CollisionComp;
	Parms.MeshComp = MeshComp;
	Parms.CapsuleRadius = CapsuleRadius;
	Parms.CapsuleHalfHeight = CapsuleHalfHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.BuildWeapon
// (Event, Public, BlueprintEvent)

void ALWeapon::BuildWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "BuildWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.ChangeAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AnimState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ChangeAnimState(ELWeaponPartType PartType, class FName AnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ChangeAnimState");

	Params::LWeapon_ChangeAnimState Parms{};

	Parms.PartType = PartType;
	Parms.AnimState = AnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.ChangeAnimStateInner
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InAnimState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ChangeAnimStateInner(ELWeaponPartType PartType, class FName InAnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ChangeAnimStateInner");

	Params::LWeapon_ChangeAnimStateInner Parms{};

	Parms.PartType = PartType;
	Parms.InAnimState = InAnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.ClearAnimState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ClearAnimState(ELWeaponPartType PartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ClearAnimState");

	Params::LWeapon_ClearAnimState Parms{};

	Parms.PartType = PartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.CreateDebrisMeshAndDrop
// (Final, Native, Protected, BlueprintCallable)

void ALWeapon::CreateDebrisMeshAndDrop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "CreateDebrisMeshAndDrop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.CreateHandleTemplate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ALWeapon*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALWeapon* ALWeapon::CreateHandleTemplate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "CreateHandleTemplate");

	Params::LWeapon_CreateHandleTemplate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.CreateSweepTracer
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::CreateSweepTracer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "CreateSweepTracer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.DecreaseDestructionDurability
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Durability                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVictimGuard                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsumed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestructed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::DecreaseDestructionDurability(int32 Durability, bool bVictimGuard, bool* bConsumed, bool* bDestructed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "DecreaseDestructionDurability");

	Params::LWeapon_DecreaseDestructionDurability Parms{};

	Parms.Durability = Durability;
	Parms.bVictimGuard = bVictimGuard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bConsumed != nullptr)
		*bConsumed = Parms.bConsumed;

	if (bDestructed != nullptr)
		*bDestructed = Parms.bDestructed;
}


// Function ProjectP.LWeapon.DoDropBrokenBlade
// (Final, Native, Protected, BlueprintCallable)

void ALWeapon::DoDropBrokenBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "DoDropBrokenBlade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.DoDropBrokenBladeMeshes
// (Final, Native, Protected, BlueprintCallable)

void ALWeapon::DoDropBrokenBladeMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "DoDropBrokenBladeMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.DoDropWeaponMeshes
// (Final, Native, Protected, BlueprintCallable)

void ALWeapon::DoDropWeaponMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "DoDropWeaponMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.DropWeapon
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::DropWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "DropWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.GetBladeCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULWeaponBladeComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWeaponBladeComponent* ALWeapon::GetBladeCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetBladeCollision");

	Params::LWeapon_GetBladeCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetBladeCommonInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FItemCommonInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemCommonInfoPtr ALWeapon::GetBladeCommonInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetBladeCommonInfo");

	Params::LWeapon_GetBladeCommonInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetBrokenBladeOnBuild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::GetBrokenBladeOnBuild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetBrokenBladeOnBuild");

	Params::LWeapon_GetBrokenBladeOnBuild Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetHandleCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::GetHandleCapsuleRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetHandleCapsuleRadius");

	Params::LWeapon_GetHandleCapsuleRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetHandleCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULWeaponHandleComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWeaponHandleComponent* ALWeapon::GetHandleCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetHandleCollision");

	Params::LWeapon_GetHandleCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetHandleCommonInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FItemCommonInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemCommonInfoPtr ALWeapon::GetHandleCommonInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetHandleCommonInfo");

	Params::LWeapon_GetHandleCommonInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULWeaponItem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWeaponItem* ALWeapon::GetItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetItem");

	Params::LWeapon_GetItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetMonsterWeaponInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FItemWeaponMonsterPtr            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemWeaponMonsterPtr ALWeapon::GetMonsterWeaponInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetMonsterWeaponInfo");

	Params::LWeapon_GetMonsterWeaponInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetSkillDist
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AddSkillDist                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkillDistMin                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkillDistMax                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SkillDistRateMin                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SkillDistRateMax                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::GetSkillDist(int32* AddSkillDist, int32* SkillDistMin, int32* SkillDistMax, float* SkillDistRateMin, float* SkillDistRateMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetSkillDist");

	Params::LWeapon_GetSkillDist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AddSkillDist != nullptr)
		*AddSkillDist = Parms.AddSkillDist;

	if (SkillDistMin != nullptr)
		*SkillDistMin = Parms.SkillDistMin;

	if (SkillDistMax != nullptr)
		*SkillDistMax = Parms.SkillDistMax;

	if (SkillDistRateMin != nullptr)
		*SkillDistRateMin = Parms.SkillDistRateMin;

	if (SkillDistRateMax != nullptr)
		*SkillDistRateMax = Parms.SkillDistRateMax;
}


// Function ProjectP.LWeapon.GetSkillHitCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALWeapon::GetSkillHitCodeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetSkillHitCodeName");

	Params::LWeapon_GetSkillHitCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.JoinHandleAndBlade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bBrokenBladeBuild                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::JoinHandleAndBlade(bool bBrokenBladeBuild)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "JoinHandleAndBlade");

	Params::LWeapon_JoinHandleAndBlade Parms{};

	Parms.bBrokenBladeBuild = bBrokenBladeBuild;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.JoinHandleAndBladeMeshComponents
// (Event, Public, BlueprintEvent)

void ALWeapon::JoinHandleAndBladeMeshComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "JoinHandleAndBladeMeshComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.OnApplyRunningAbnormal
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsApply                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AbnormalCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::OnApplyRunningAbnormal(bool IsApply, class FName AbnormalCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnApplyRunningAbnormal");

	Params::LWeapon_OnApplyRunningAbnormal Parms{};

	Parms.IsApply = IsApply;
	Parms.AbnormalCodeName = AbnormalCodeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.OnBreakBlade
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          BreakPointLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::OnBreakBlade(const struct FVector& BreakPointLocation, const struct FVector& ImpulseDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnBreakBlade");

	Params::LWeapon_OnBreakBlade Parms{};

	Parms.BreakPointLocation = std::move(BreakPointLocation);
	Parms.ImpulseDirection = std::move(ImpulseDirection);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.OnDropWeapon
// (Event, Public, BlueprintEvent)

void ALWeapon::OnDropWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnDropWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.OnDuplicateHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALWeapon*                         DuplicatedHandle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::OnDuplicateHandle(class ALWeapon* DuplicatedHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnDuplicateHandle");

	Params::LWeapon_OnDuplicateHandle Parms{};

	Parms.DuplicatedHandle = DuplicatedHandle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.OnFxSocketTraceEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// class ULActMgrComponent*                ActMgrComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLFxSocketTracerInfo             SocketTraceInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALWeapon::OnFxSocketTraceEvent(class ULActMgrComponent* ActMgrComponent, const struct FLFxSocketTracerInfo& SocketTraceInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnFxSocketTraceEvent");

	Params::LWeapon_OnFxSocketTraceEvent Parms{};

	Parms.ActMgrComponent = ActMgrComponent;
	Parms.SocketTraceInfo = std::move(SocketTraceInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.OnJoinHandleAndBlade
// (Event, Public, BlueprintEvent)

void ALWeapon::OnJoinHandleAndBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnJoinHandleAndBlade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.OnUpdateBreakBlade
// (Event, Public, BlueprintEvent)

void ALWeapon::OnUpdateBreakBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnUpdateBreakBlade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.OnWeaponChanged
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ALWeapon*                         From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALWeapon*                         To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::OnWeaponChanged(class ALWeapon* From, class ALWeapon* To)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnWeaponChanged");

	Params::LWeapon_OnWeaponChanged Parms{};

	Parms.From = From;
	Parms.To = To;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.OnWeaponHitDamage
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALWeapon::OnWeaponHitDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnWeaponHitDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.OnWeaponOnOff
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bOnOff                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::OnWeaponOnOff(bool bOnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnWeaponOnOff");

	Params::LWeapon_OnWeaponOnOff Parms{};

	Parms.bOnOff = bOnOff;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.OnWeaponOwnerDead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ALWeapon::OnWeaponOwnerDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnWeaponOwnerDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.OnWeaponRespawn
// (Event, Public, BlueprintEvent)

void ALWeapon::OnWeaponRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "OnWeaponRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.PlayDurabilityConsumeFX
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALWeapon::PlayDurabilityConsumeFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "PlayDurabilityConsumeFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.PlayTrailElementFX
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALWeapon::PlayTrailElementFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "PlayTrailElementFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.ProcessDestructionDurability
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   ConsumeAmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessConsume                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestructNow                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ProcessDestructionDurability(int32 ConsumeAmount, const struct FVector& ImpulseDirection, bool* bSuccessConsume, bool* bDestructNow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ProcessDestructionDurability");

	Params::LWeapon_ProcessDestructionDurability Parms{};

	Parms.ConsumeAmount = ConsumeAmount;
	Parms.ImpulseDirection = std::move(ImpulseDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccessConsume != nullptr)
		*bSuccessConsume = Parms.bSuccessConsume;

	if (bDestructNow != nullptr)
		*bDestructNow = Parms.bDestructNow;
}


// Function ProjectP.LWeapon.RemoveDebrisMesh
// (Final, Native, Protected, BlueprintCallable)

void ALWeapon::RemoveDebrisMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "RemoveDebrisMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.RemoveElement
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ElementName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::RemoveElement(class FName ElementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "RemoveElement");

	Params::LWeapon_RemoveElement Parms{};

	Parms.ElementName = ElementName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.RemoveMaterialVarying
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             MaterialFxCodename                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::RemoveMaterialVarying(class FName MaterialFxCodename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "RemoveMaterialVarying");

	Params::LWeapon_RemoveMaterialVarying Parms{};

	Parms.MaterialFxCodename = MaterialFxCodename;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.ReplaceBreakBlade
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ImpulseDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::ReplaceBreakBlade(const struct FVector& ImpulseDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ReplaceBreakBlade");

	Params::LWeapon_ReplaceBreakBlade Parms{};

	Parms.ImpulseDirection = std::move(ImpulseDirection);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWeapon.RespawnWeapon
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::RespawnWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "RespawnWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.SetAnimRateScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponPartType                        PartType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::SetAnimRateScale(ELWeaponPartType PartType, float ScaleRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "SetAnimRateScale");

	Params::LWeapon_SetAnimRateScale Parms{};

	Parms.PartType = PartType;
	Parms.ScaleRate = ScaleRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.SetMonsterWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemMonsterWeaponCodeName                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::SetMonsterWeapon(const class FName& ItemMonsterWeaponCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "SetMonsterWeapon");

	Params::LWeapon_SetMonsterWeapon Parms{};

	Parms.ItemMonsterWeaponCodeName = ItemMonsterWeaponCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.SetWeaponAttachmentInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWeaponAttachPointType                 InWeaponAttachPointType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::SetWeaponAttachmentInfo(ELWeaponAttachPointType InWeaponAttachPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "SetWeaponAttachmentInfo");

	Params::LWeapon_SetWeaponAttachmentInfo Parms{};

	Parms.InWeaponAttachPointType = InWeaponAttachPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.SetWeaponClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ALWeapon>             InHandleWeaponClass                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ALWeapon>             InBladeWeaponClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::SetWeaponClass(TSubclassOf<class ALWeapon> InHandleWeaponClass, TSubclassOf<class ALWeapon> InBladeWeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "SetWeaponClass");

	Params::LWeapon_SetWeaponClass Parms{};

	Parms.InHandleWeaponClass = InHandleWeaponClass;
	Parms.InBladeWeaponClass = InBladeWeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.SetWeaponItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULWeaponItem*                     Item_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWeapon::SetWeaponItem(class ULWeaponItem* Item_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "SetWeaponItem");

	Params::LWeapon_SetWeaponItem Parms{};

	Parms.Item_0 = Item_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.StartHideDerbisBlade
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALWeapon::StartHideDerbisBlade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "StartHideDerbisBlade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.StopTrailElementFX
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALWeapon::StopTrailElementFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "StopTrailElementFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWeapon.WeaponOff
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::WeaponOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "WeaponOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.WeaponOffBareHand
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::WeaponOffBareHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "WeaponOffBareHand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.WeaponOffOwnerHidden
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::WeaponOffOwnerHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "WeaponOffOwnerHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.WeaponOn
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::WeaponOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "WeaponOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.WeaponOnBareHand
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::WeaponOnBareHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "WeaponOnBareHand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.WeaponOnOwnerHidden
// (Final, Native, Public, BlueprintCallable)

void ALWeapon::WeaponOnOwnerHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "WeaponOnOwnerHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWeapon.CanJoinHandleBlade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::CanJoinHandleBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "CanJoinHandleBlade");

	Params::LWeapon_CanJoinHandleBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetAddtiveSkillHitCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALWeapon::GetAddtiveSkillHitCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetAddtiveSkillHitCodeName");

	Params::LWeapon_GetAddtiveSkillHitCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetAtkPowerRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::GetAtkPowerRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetAtkPowerRate");

	Params::LWeapon_GetAtkPowerRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetAttachPointBlade
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALWeapon::GetAttachPointBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetAttachPointBlade");

	Params::LWeapon_GetAttachPointBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetBladeFableArtsSkillInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSkillInfoPtr                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSkillInfoPtr ALWeapon::GetBladeFableArtsSkillInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetBladeFableArtsSkillInfo");

	Params::LWeapon_GetBladeFableArtsSkillInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetBladeInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemBladeInfoPtr                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemBladeInfoPtr ALWeapon::GetBladeInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetBladeInfo");

	Params::LWeapon_GetBladeInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetBladeLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::GetBladeLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetBladeLength");

	Params::LWeapon_GetBladeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetDestructionDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALWeapon::GetDestructionDurability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetDestructionDurability");

	Params::LWeapon_GetDestructionDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetEquipAbnormalCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ALWeapon::GetEquipAbnormalCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetEquipAbnormalCodeName");

	Params::LWeapon_GetEquipAbnormalCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetHandleFableArtsSkillInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSkillInfoPtr                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSkillInfoPtr ALWeapon::GetHandleFableArtsSkillInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetHandleFableArtsSkillInfo");

	Params::LWeapon_GetHandleFableArtsSkillInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetHandleInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemHandleInfoPtr               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FItemHandleInfoPtr ALWeapon::GetHandleInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetHandleInfo");

	Params::LWeapon_GetHandleInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetMaxDestructionDurability
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALWeapon::GetMaxDestructionDurability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetMaxDestructionDurability");

	Params::LWeapon_GetMaxDestructionDurability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetMotionSpeedRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::GetMotionSpeedRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetMotionSpeedRate");

	Params::LWeapon_GetMotionSpeedRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetMulpleRateAtkPowerAfterBoken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::GetMulpleRateAtkPowerAfterBoken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetMulpleRateAtkPowerAfterBoken");

	Params::LWeapon_GetMulpleRateAtkPowerAfterBoken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetMulpleRateDestructionPowerAfterBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::GetMulpleRateDestructionPowerAfterBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetMulpleRateDestructionPowerAfterBroken");

	Params::LWeapon_GetMulpleRateDestructionPowerAfterBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetWeaponAttachPointType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELWeaponAttachPointType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELWeaponAttachPointType ALWeapon::GetWeaponAttachPointType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetWeaponAttachPointType");

	Params::LWeapon_GetWeaponAttachPointType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.GetWeaponOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALWeapon::GetWeaponOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "GetWeaponOwner");

	Params::LWeapon_GetWeaponOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.HasBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::HasBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "HasBroken");

	Params::LWeapon_HasBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.HasCollisionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::HasCollisionComponent(class UPrimitiveComponent* Component) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "HasCollisionComponent");

	Params::LWeapon_HasCollisionComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsDroped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsDroped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsDroped");

	Params::LWeapon_IsDroped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsMonsterWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsMonsterWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsMonsterWeapon");

	Params::LWeapon_IsMonsterWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsNewBreakBlade
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsNewBreakBlade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsNewBreakBlade");

	Params::LWeapon_IsNewBreakBlade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsPickedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsPickedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsPickedWeapon");

	Params::LWeapon_IsPickedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsRemoveAbnormalStateAfterBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsRemoveAbnormalStateAfterBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsRemoveAbnormalStateAfterBroken");

	Params::LWeapon_IsRemoveAbnormalStateAfterBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsWeaponOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsWeaponOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsWeaponOn");

	Params::LWeapon_IsWeaponOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.IsWeaponOnOwnerHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALWeapon::IsWeaponOnOwnerHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "IsWeaponOnOwnerHidden");

	Params::LWeapon_IsWeaponOnOwnerHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWeapon.ToughRecoveryDelayTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALWeapon::ToughRecoveryDelayTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWeapon", "ToughRecoveryDelayTime");

	Params::LWeapon_ToughRecoveryDelayTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWidget.CompleteSetBrush_FromAsyncTexture
// (Final, Native, Private)

void ULWidget::CompleteSetBrush_FromAsyncTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "CompleteSetBrush_FromAsyncTexture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.ListenForInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float AxisValue)>        Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULWidget::ListenForInputAxis(class FName AxisName, bool bConsume, TDelegate<void(float AxisValue)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "ListenForInputAxis");

	Params::LWidget_ListenForInputAxis Parms{};

	Parms.AxisName = AxisName;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.SetBrush_FromAsyncTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UImage*                           InImage                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           InSoftObject                                           (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::SetBrush_FromAsyncTexture(class UImage* InImage, TSoftObjectPtr<class UObject> InSoftObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "SetBrush_FromAsyncTexture");

	Params::LWidget_SetBrush_FromAsyncTexture Parms{};

	Parms.InImage = InImage;
	Parms.InSoftObject = InSoftObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.StopListeningForInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::StopListeningForInputAxis(class FName AxisName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "StopListeningForInputAxis");

	Params::LWidget_StopListeningForInputAxis Parms{};

	Parms.AxisName = AxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_CanvasMove
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_CanvasMove(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_CanvasMove");

	Params::LWidget_Tween_CanvasMove Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_CanvasSize
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_CanvasSize(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_CanvasSize");

	Params::LWidget_Tween_CanvasSize Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_ColorAndOpacity
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_ColorAndOpacity(class UWidget* Widget, const struct FLinearColor& Start, const struct FLinearColor& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_ColorAndOpacity");

	Params::LWidget_Tween_ColorAndOpacity Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_ContentFloatValue
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_ContentFloatValue(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_ContentFloatValue");

	Params::LWidget_Tween_ContentFloatValue Parms{};

	Parms.Widget = Widget;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_ContentsColorAndOpacity
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_ContentsColorAndOpacity(class UWidget* Widget, const struct FLinearColor& Start, const struct FLinearColor& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_ContentsColorAndOpacity");

	Params::LWidget_Tween_ContentsColorAndOpacity Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_MaterialColor
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_MaterialColor(class UWidget* Widget, class FName ParameterName, const struct FLinearColor& Start, const struct FLinearColor& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_MaterialColor");

	Params::LWidget_Tween_MaterialColor Parms{};

	Parms.Widget = Widget;
	Parms.ParameterName = ParameterName;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_MaterialScalar
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_MaterialScalar(class UWidget* Widget, class FName ParameterName, float Start, float End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_MaterialScalar");

	Params::LWidget_Tween_MaterialScalar Parms{};

	Parms.Widget = Widget;
	Parms.ParameterName = ParameterName;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_Opacity
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_Opacity(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_Opacity");

	Params::LWidget_Tween_Opacity Parms{};

	Parms.Widget = Widget;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_RenderAngle
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_RenderAngle(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_RenderAngle");

	Params::LWidget_Tween_RenderAngle Parms{};

	Parms.Widget = Widget;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_RenderOpacity
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_RenderOpacity(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_RenderOpacity");

	Params::LWidget_Tween_RenderOpacity Parms{};

	Parms.Widget = Widget;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_RenderScale
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_RenderScale(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_RenderScale");

	Params::LWidget_Tween_RenderScale Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_RenderTransform
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWidgetTransform                 Start                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWidgetTransform                 End                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_RenderTransform(class UWidget* Widget, const struct FWidgetTransform& Start, const struct FWidgetTransform& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_RenderTransform");

	Params::LWidget_Tween_RenderTransform Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_RenderTranslation
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTweenEase                       Ease                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_RenderTranslation(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_RenderTranslation");

	Params::LWidget_Tween_RenderTranslation Parms{};

	Parms.Widget = Widget;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Ease = std::move(Ease);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_Reset
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Category_Name                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_Reset(class FName Category_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_Reset");

	Params::LWidget_Tween_Reset Parms{};

	Parms.Category_Name = Category_Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWidget.Tween_Start
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Category_Name                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWidget::Tween_Start(class FName Category_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWidget", "Tween_Start");

	Params::LWidget_Tween_Start Parms{};

	Parms.Category_Name = Category_Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LHeadTagWidget.OnAttachToActor
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ULHeadTagWidget::OnAttachToActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHeadTagWidget", "OnAttachToActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LHeadTagWidget.OnDetachFromActor
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ULHeadTagWidget::OnDetachFromActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHeadTagWidget", "OnDetachFromActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LHeadTagWidget.RefreshHeadTagVisibleTimer
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULHeadTagWidget::RefreshHeadTagVisibleTimer(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LHeadTagWidget", "RefreshHeadTagVisibleTimer");

	Params::LHeadTagWidget_RefreshHeadTagVisibleTimer Parms{};

	Parms.InVisible = InVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWireActor.Initialize
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALWireActor::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWireActor", "Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWorldEventComponent.OnClosedLevelUpWindow
// (Final, Native, Protected)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldEventComponent::OnClosedLevelUpWindow(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldEventComponent", "OnClosedLevelUpWindow");

	Params::LWorldEventComponent_OnClosedLevelUpWindow Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldEventSystem.CommandUIFadeOutEnd
// (Final, Native, Public)

void ULWorldEventSystem::CommandUIFadeOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldEventSystem", "CommandUIFadeOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldEventSystem.ExecuteContentCommand
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             CommandName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldEventSystem::ExecuteContentCommand(const class FName& CommandName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldEventSystem", "ExecuteContentCommand");

	Params::LWorldEventSystem_ExecuteContentCommand Parms{};

	Parms.CommandName = CommandName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldEventSystem.IsValidEventConditionBP
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             CommandName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldEventSystem::IsValidEventConditionBP(const class FName& CommandName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldEventSystem", "IsValidEventConditionBP");

	Params::LWorldEventSystem_IsValidEventConditionBP Parms{};

	Parms.CommandName = CommandName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldEventSystem.OnClosedWindow
// (Final, Native, Public)
// Parameters:
// class FName                             WidgetTableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldEventSystem::OnClosedWindow(class FName WidgetTableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldEventSystem", "OnClosedWindow");

	Params::LWorldEventSystem_OnClosedWindow Parms{};

	Parms.WidgetTableName = WidgetTableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadSystem.AsyncLoadAfterOpenWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCreateForPIE                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadSystem::AsyncLoadAfterOpenWorld(bool bCreateForPIE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "AsyncLoadAfterOpenWorld");

	Params::LWorldLoadSystem_AsyncLoadAfterOpenWorld Parms{};

	Parms.bCreateForPIE = bCreateForPIE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadSystem.AsyncWaitLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TeleportCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadSystem::AsyncWaitLevel(class FName TeleportCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "AsyncWaitLevel");

	Params::LWorldLoadSystem_AsyncWaitLevel Parms{};

	Parms.TeleportCodeName = TeleportCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadSystem.GetAsyncLoadPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWorldLoadSystem::GetAsyncLoadPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "GetAsyncLoadPercentage");

	Params::LWorldLoadSystem_GetAsyncLoadPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadSystem.GetWorldLoadScreenInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULWorldLoadScreenInfo*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULWorldLoadScreenInfo* ULWorldLoadSystem::GetWorldLoadScreenInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "GetWorldLoadScreenInfo");

	Params::LWorldLoadSystem_GetWorldLoadScreenInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadSystem.MakeLoadAlwaysLoadLevelStreaming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadSystem::MakeLoadAlwaysLoadLevelStreaming(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "MakeLoadAlwaysLoadLevelStreaming");

	Params::LWorldLoadSystem_MakeLoadAlwaysLoadLevelStreaming Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadSystem.OnGameDataCharacterSync
// (Final, Native, Protected)
// Parameters:
// class ULCharacterSaveGame*              CharacterSaveGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadSystem::OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "OnGameDataCharacterSync");

	Params::LWorldLoadSystem_OnGameDataCharacterSync Parms{};

	Parms.CharacterSaveGame = CharacterSaveGame;
	Parms.bLoad = bLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadSystem.CanSpawnActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldLoadSystem::CanSpawnActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "CanSpawnActors");

	Params::LWorldLoadSystem_CanSpawnActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadSystem.GetLoadingStats
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   Stats                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULWorldLoadSystem::GetLoadingStats(TArray<class FString>* Stats) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "GetLoadingStats");

	Params::LWorldLoadSystem_GetLoadingStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Stats != nullptr)
		*Stats = std::move(Parms.Stats);
}


// Function ProjectP.LWorldLoadSystem.IsAsyncWorldLoading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldLoadSystem::IsAsyncWorldLoading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "IsAsyncWorldLoading");

	Params::LWorldLoadSystem_IsAsyncWorldLoading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadSystem.IsAsyncWorldLoadMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldLoadSystem::IsAsyncWorldLoadMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "IsAsyncWorldLoadMode");

	Params::LWorldLoadSystem_IsAsyncWorldLoadMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadSystem.IsAsyncWorldLoadModeInCurrentWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldLoadSystem::IsAsyncWorldLoadModeInCurrentWorld(class UWorld* World) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "IsAsyncWorldLoadModeInCurrentWorld");

	Params::LWorldLoadSystem_IsAsyncWorldLoadModeInCurrentWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadSystem.IsStartAsyncLoadMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldLoadSystem::IsStartAsyncLoadMap(class FName LevelName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadSystem", "IsStartAsyncLoadMap");

	Params::LWorldLoadSystem_IsStartAsyncLoadMap Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadManager.AddKeepLoadingObjectsInTask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Objects                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULWorldLoadManager::AddKeepLoadingObjectsInTask(const TArray<class UObject*>& Objects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "AddKeepLoadingObjectsInTask");

	Params::LWorldLoadManager_AddKeepLoadingObjectsInTask Parms{};

	Parms.Objects = std::move(Objects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.AddKeepWorldObjectsInTask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Objects                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULWorldLoadManager::AddKeepWorldObjectsInTask(const TArray<class UObject*>& Objects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "AddKeepWorldObjectsInTask");

	Params::LWorldLoadManager_AddKeepWorldObjectsInTask Parms{};

	Parms.Objects = std::move(Objects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.AsyncLoadAfterOpenWorld
// (Final, Native, Public, BlueprintCallable)

void ULWorldLoadManager::AsyncLoadAfterOpenWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "AsyncLoadAfterOpenWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.AsyncWaitLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TeleportCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadManager::AsyncWaitLevel(class FName TeleportCodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "AsyncWaitLevel");

	Params::LWorldLoadManager_AsyncWaitLevel Parms{};

	Parms.TeleportCodeName = TeleportCodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.EmptyKeepLoadingObjectsInTask
// (Final, Native, Public, BlueprintCallable)

void ULWorldLoadManager::EmptyKeepLoadingObjectsInTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "EmptyKeepLoadingObjectsInTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.EmptyKeepWorldObjectsInTask
// (Final, Native, Public, BlueprintCallable)

void ULWorldLoadManager::EmptyKeepWorldObjectsInTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "EmptyKeepWorldObjectsInTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.GetLoadPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWorldLoadManager::GetLoadPercentage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "GetLoadPercentage");

	Params::LWorldLoadManager_GetLoadPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldLoadManager.MakeLoadAlwaysLoadLevelStreaming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadManager::MakeLoadAlwaysLoadLevelStreaming(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "MakeLoadAlwaysLoadLevelStreaming");

	Params::LWorldLoadManager_MakeLoadAlwaysLoadLevelStreaming Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.TickAsyncWorldLoading
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldLoadManager::TickAsyncWorldLoading(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "TickAsyncWorldLoading");

	Params::LWorldLoadManager_TickAsyncWorldLoading Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldLoadManager.GetLoadingStats
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   Stats                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULWorldLoadManager::GetLoadingStats(TArray<class FString>* Stats) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "GetLoadingStats");

	Params::LWorldLoadManager_GetLoadingStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Stats != nullptr)
		*Stats = std::move(Parms.Stats);
}


// Function ProjectP.LWorldLoadManager.IsAsyncWorldLoading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldLoadManager::IsAsyncWorldLoading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldLoadManager", "IsAsyncWorldLoading");

	Params::LWorldLoadManager_IsAsyncWorldLoading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystemData.ChangeLightScenario
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             UnLoadLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LoadLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWorldSystemData::ChangeLightScenario(class FName UnLoadLevel, class FName LoadLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystemData", "ChangeLightScenario");

	Params::LWorldSystemData_ChangeLightScenario Parms{};

	Parms.UnLoadLevel = UnLoadLevel;
	Parms.LoadLevel = LoadLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWorldSystemData.OnMoveToTeleportSpotSameLevelLoadingFinished
// (Event, Public, BlueprintEvent)

void ALWorldSystemData::OnMoveToTeleportSpotSameLevelLoadingFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystemData", "OnMoveToTeleportSpotSameLevelLoadingFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ProjectP.LWorldSystemData.ProcessMoveToTeleportSpotSameLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             TeleportCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInGameLoadingScreen                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALWorldSystemData::ProcessMoveToTeleportSpotSameLevel(class FName TeleportCodeName, bool bInGameLoadingScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystemData", "ProcessMoveToTeleportSpotSameLevel");

	Params::LWorldSystemData_ProcessMoveToTeleportSpotSameLevel Parms{};

	Parms.TeleportCodeName = TeleportCodeName;
	Parms.bInGameLoadingScreen = bInGameLoadingScreen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ProjectP.LWorldSystem.ApplyWeather
// (Final, Native, Protected)
// Parameters:
// class FName                             InWeatherCodeName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomChangeTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::ApplyWeather(class FName InWeatherCodeName, float CustomChangeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "ApplyWeather");

	Params::LWorldSystem_ApplyWeather Parms{};

	Parms.InWeatherCodeName = InWeatherCodeName;
	Parms.CustomChangeTime = CustomChangeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.ChangeWeather
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InWeatherCodeName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomChangeTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::ChangeWeather(class FName InWeatherCodeName, float CustomChangeTime, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "ChangeWeather");

	Params::LWorldSystem_ChangeWeather Parms{};

	Parms.InWeatherCodeName = InWeatherCodeName;
	Parms.CustomChangeTime = CustomChangeTime;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.FinishLoadingScreenSameLevel
// (Final, Native, Protected, BlueprintCallable)

void ULWorldSystem::FinishLoadingScreenSameLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "FinishLoadingScreenSameLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.GetEndingCreditVelocityMultiply
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWorldSystem::GetEndingCreditVelocityMultiply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "GetEndingCreditVelocityMultiply");

	Params::LWorldSystem_GetEndingCreditVelocityMultiply Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystem.GetGlobalEnvActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALGlobalEnvActor*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALGlobalEnvActor* ULWorldSystem::GetGlobalEnvActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "GetGlobalEnvActor");

	Params::LWorldSystem_GetGlobalEnvActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystem.GetIsShowControlGuide
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldSystem::GetIsShowControlGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "GetIsShowControlGuide");

	Params::LWorldSystem_GetIsShowControlGuide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystem.GetWorldLoadingProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckLevelLoadOnly                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULWorldSystem::GetWorldLoadingProgress(float DeltaTime, bool bCheckLevelLoadOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "GetWorldLoadingProgress");

	Params::LWorldSystem_GetWorldLoadingProgress Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.bCheckLevelLoadOnly = bCheckLevelLoadOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystem.GotoReservedLevel
// (Final, Native, Public, BlueprintCallable)

void ULWorldSystem::GotoReservedLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "GotoReservedLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.IsShowControlGuide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldSystem::IsShowControlGuide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "IsShowControlGuide");

	Params::LWorldSystem_IsShowControlGuide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystem.IsUseEndingCreditVelocityMultiply
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULWorldSystem::IsUseEndingCreditVelocityMultiply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "IsUseEndingCreditVelocityMultiply");

	Params::LWorldSystem_IsUseEndingCreditVelocityMultiply Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ProjectP.LWorldSystem.MuteOffOnLoadingScreenOff
// (Final, Native, Public)

void ULWorldSystem::MuteOffOnLoadingScreenOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "MuteOffOnLoadingScreenOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.NewOpenWorld_Inner
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMainLoading                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::NewOpenWorld_Inner(const class FName& LevelName, bool bMainLoading)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "NewOpenWorld_Inner");

	Params::LWorldSystem_NewOpenWorld_Inner Parms{};

	Parms.LevelName = LevelName;
	Parms.bMainLoading = bMainLoading;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.NewOpenWorld_Outer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowLoadingScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::NewOpenWorld_Outer(const class FName& LevelName, bool bShowLoadingScreen, bool bPlayStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "NewOpenWorld_Outer");

	Params::LWorldSystem_NewOpenWorld_Outer Parms{};

	Parms.LevelName = LevelName;
	Parms.bShowLoadingScreen = bShowLoadingScreen;
	Parms.bPlayStart = bPlayStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.OnGlobalVariableChange
// (Final, Native, Public)
// Parameters:
// class FName                             InGlobalVariable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::OnGlobalVariableChange(class FName InGlobalVariable, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "OnGlobalVariableChange");

	Params::LWorldSystem_OnGlobalVariableChange Parms{};

	Parms.InGlobalVariable = InGlobalVariable;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.OnLoadedStatRoom
// (Final, Native, Public)

void ULWorldSystem::OnLoadedStatRoom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "OnLoadedStatRoom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.OnLoadingScreenFinished
// (Final, Native, Public)

void ULWorldSystem::OnLoadingScreenFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "OnLoadingScreenFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.OpenWorldFromMapType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELWorldMapType                          TargetMapType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowLoadingScreen                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::OpenWorldFromMapType(ELWorldMapType TargetMapType, bool bShowLoadingScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "OpenWorldFromMapType");

	Params::LWorldSystem_OpenWorldFromMapType Parms{};

	Parms.TargetMapType = TargetMapType;
	Parms.bShowLoadingScreen = bShowLoadingScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.ProcessMoveToTeleportSpotSameLevel
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             TeleportCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInGameLoadingScreen                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::ProcessMoveToTeleportSpotSameLevel(class FName TeleportCodeName, bool bInGameLoadingScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "ProcessMoveToTeleportSpotSameLevel");

	Params::LWorldSystem_ProcessMoveToTeleportSpotSameLevel Parms{};

	Parms.TeleportCodeName = TeleportCodeName;
	Parms.bInGameLoadingScreen = bInGameLoadingScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.ProcessStartOnLoadingScreenFinished
// (Final, Native, Public)

void ULWorldSystem::ProcessStartOnLoadingScreenFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "ProcessStartOnLoadingScreenFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.SetEndingCreditVelocityMultiply
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVelocityMultiply                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::SetEndingCreditVelocityMultiply(float InVelocityMultiply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "SetEndingCreditVelocityMultiply");

	Params::LWorldSystem_SetEndingCreditVelocityMultiply Parms{};

	Parms.InVelocityMultiply = InVelocityMultiply;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.SetGlobalDither
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFlag                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::SetGlobalDither(bool InFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "SetGlobalDither");

	Params::LWorldSystem_SetGlobalDither Parms{};

	Parms.InFlag = InFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.SetGlobalEnvActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALGlobalEnvActor*                 InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::SetGlobalEnvActor(class ALGlobalEnvActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "SetGlobalEnvActor");

	Params::LWorldSystem_SetGlobalEnvActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.SetIsShowControlGuide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsShowControlGuide                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::SetIsShowControlGuide(bool InIsShowControlGuide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "SetIsShowControlGuide");

	Params::LWorldSystem_SetIsShowControlGuide Parms{};

	Parms.InIsShowControlGuide = InIsShowControlGuide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.ShowLocationMsg
// (Final, Native, Public)

void ULWorldSystem::ShowLocationMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "ShowLocationMsg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.TeleportToObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TeleportCodeName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInGameLoadingScreen                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReservedLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartWithLoadingLevel                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULWorldSystem::TeleportToObject(class FName TeleportCodeName, bool bInGameLoadingScreen, bool bReservedLevel, bool bStartWithLoadingLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "TeleportToObject");

	Params::LWorldSystem_TeleportToObject Parms{};

	Parms.TeleportCodeName = TeleportCodeName;
	Parms.bInGameLoadingScreen = bInGameLoadingScreen;
	Parms.bReservedLevel = bReservedLevel;
	Parms.bStartWithLoadingLevel = bStartWithLoadingLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ProjectP.LWorldSystem.GetAppliedWeatherCodeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULWorldSystem::GetAppliedWeatherCodeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LWorldSystem", "GetAppliedWeatherCodeName");

	Params::LWorldSystem_GetAppliedWeatherCodeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

