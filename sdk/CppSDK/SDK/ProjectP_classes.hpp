#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ProjectP

#include "Basic.hpp"

#include "PhysicsCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "ProjectP_structs.hpp"
#include "ProjectPContentInfo_structs.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "UMG_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "ApexDestruction_classes.hpp"
#include "Niagara_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CinematicCamera_classes.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class ProjectP.LActPayloadBase
// 0x0008 (0x0030 - 0x0028)
class ULActPayloadBase : public UObject
{
public:
	class FName                                   CodeName;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayloadBase">();
	}
	static class ULActPayloadBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayloadBase>();
	}
};
static_assert(alignof(ULActPayloadBase) == 0x000008, "Wrong alignment on ULActPayloadBase");
static_assert(sizeof(ULActPayloadBase) == 0x000030, "Wrong size on ULActPayloadBase");
static_assert(offsetof(ULActPayloadBase, CodeName) == 0x000028, "Member 'ULActPayloadBase::CodeName' has a wrong offset!");

// Class ProjectP.LWeaponAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class ULWeaponAnimInstance : public UAnimInstance
{
public:
	class FName                                   AnimState;                                         // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeAnimState(class FName AnimState_0);
	void ClearAnimState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponAnimInstance">();
	}
	static class ULWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWeaponAnimInstance>();
	}
};
static_assert(alignof(ULWeaponAnimInstance) == 0x000010, "Wrong alignment on ULWeaponAnimInstance");
static_assert(sizeof(ULWeaponAnimInstance) == 0x0002C0, "Wrong size on ULWeaponAnimInstance");
static_assert(offsetof(ULWeaponAnimInstance, AnimState) == 0x0002B8, "Member 'ULWeaponAnimInstance::AnimState' has a wrong offset!");

// Class ProjectP.LSpot
// 0x00E8 (0x02C8 - 0x01E0)
class ALSpot : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELSpotType                                    SpotType;                                          // 0x01E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OwnerLevelName;                                    // 0x01EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstanceId;                                        // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpotUniqueID;                                      // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpotCodeName;                                      // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldEventCodeName;                                // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActorSpawnable;                                    // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDistanceScale;                                // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDistanceScaleByCode;                          // 0x0220(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysSpawnIgnoreCollisions : 1;                  // 0x0224(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpotVolumeOverlapCount;                            // 0x0228(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeSpotVolume : 1;                            // 0x022C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTouchedTalker : 1;                                // 0x022C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TalkerCodeName;                                    // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLSpotOptionInfo                       OptionInfo;                                        // 0x0238(0x0001)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLPreloadBox                           SpawnPreloadInstance;                              // 0x0240(0x0030)(Transient, NativeAccessSpecifierPublic)
	struct FLPreloadBox                           PreloadInstance;                                   // 0x0270(0x0030)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x11];                                     // 0x02A0(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ReserveActorSpawn;                                 // 0x02B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReserveActorDespawn;                               // 0x02B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3[0x5];                                      // 0x02B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpotMatchInfoPtr                      SpotMatchInfo;                                     // 0x02B8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          CheckedSpotMatchInfo;                              // 0x02C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResultSpotMatchInfo;                               // 0x02C1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPreloadSpotSetting                          PreloadSpotSetting;                                // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3[0x5];                                      // 0x02C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpot">();
	}
	static class ALSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSpot>();
	}
};
static_assert(alignof(ALSpot) == 0x000008, "Wrong alignment on ALSpot");
static_assert(sizeof(ALSpot) == 0x0002C8, "Wrong size on ALSpot");
static_assert(offsetof(ALSpot, SpotType) == 0x0001E8, "Member 'ALSpot::SpotType' has a wrong offset!");
static_assert(offsetof(ALSpot, OwnerLevelName) == 0x0001EC, "Member 'ALSpot::OwnerLevelName' has a wrong offset!");
static_assert(offsetof(ALSpot, InstanceId) == 0x0001F4, "Member 'ALSpot::InstanceId' has a wrong offset!");
static_assert(offsetof(ALSpot, SpotUniqueID) == 0x0001F8, "Member 'ALSpot::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(ALSpot, SpotCodeName) == 0x000208, "Member 'ALSpot::SpotCodeName' has a wrong offset!");
static_assert(offsetof(ALSpot, WorldEventCodeName) == 0x000210, "Member 'ALSpot::WorldEventCodeName' has a wrong offset!");
static_assert(offsetof(ALSpot, ActorSpawnable) == 0x000218, "Member 'ALSpot::ActorSpawnable' has a wrong offset!");
static_assert(offsetof(ALSpot, SpawnDistanceScale) == 0x00021C, "Member 'ALSpot::SpawnDistanceScale' has a wrong offset!");
static_assert(offsetof(ALSpot, SpawnDistanceScaleByCode) == 0x000220, "Member 'ALSpot::SpawnDistanceScaleByCode' has a wrong offset!");
static_assert(offsetof(ALSpot, SpotVolumeOverlapCount) == 0x000228, "Member 'ALSpot::SpotVolumeOverlapCount' has a wrong offset!");
static_assert(offsetof(ALSpot, TalkerCodeName) == 0x000230, "Member 'ALSpot::TalkerCodeName' has a wrong offset!");
static_assert(offsetof(ALSpot, OptionInfo) == 0x000238, "Member 'ALSpot::OptionInfo' has a wrong offset!");
static_assert(offsetof(ALSpot, SpawnPreloadInstance) == 0x000240, "Member 'ALSpot::SpawnPreloadInstance' has a wrong offset!");
static_assert(offsetof(ALSpot, PreloadInstance) == 0x000270, "Member 'ALSpot::PreloadInstance' has a wrong offset!");
static_assert(offsetof(ALSpot, ReserveActorSpawn) == 0x0002B1, "Member 'ALSpot::ReserveActorSpawn' has a wrong offset!");
static_assert(offsetof(ALSpot, ReserveActorDespawn) == 0x0002B2, "Member 'ALSpot::ReserveActorDespawn' has a wrong offset!");
static_assert(offsetof(ALSpot, SpotMatchInfo) == 0x0002B8, "Member 'ALSpot::SpotMatchInfo' has a wrong offset!");
static_assert(offsetof(ALSpot, CheckedSpotMatchInfo) == 0x0002C0, "Member 'ALSpot::CheckedSpotMatchInfo' has a wrong offset!");
static_assert(offsetof(ALSpot, ResultSpotMatchInfo) == 0x0002C1, "Member 'ALSpot::ResultSpotMatchInfo' has a wrong offset!");
static_assert(offsetof(ALSpot, PreloadSpotSetting) == 0x0002C2, "Member 'ALSpot::PreloadSpotSetting' has a wrong offset!");

// Class ProjectP.LPropSpot
// 0x0088 (0x0350 - 0x02C8)
class ALPropSpot : public ALSpot
{
public:
	int32                                         PropState;                                         // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  SpawnedActor;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveFlag;                                          // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RespawnFlag;                                       // 0x02D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLLinkedPropInfo>               LinkedPropInfoList;                                // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FLLinkedNpcSpot>                LinkedNpcSpotList;                                 // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class ULPropComponent*                        PropComponent;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWorldEventComponent*                  WorldEventComponent;                               // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        SpotSoundComponent;                                // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropInteractCollisionComponent*       InteractCollisionComponent;                        // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropInteractStartComponent*           InteractStartComponent;                            // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropSoundLocationComponent*           SoundLocationComponent;                            // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReservedLinkedState;                               // 0x0330(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSpawnedActor;                                    // 0x0338(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangePropStateFromLevelObject(int32 TargetState);
	void OnCheckLinkedNpcSpotFromLevelObject(ELLinkedNpcSpotExecuteType ExecuteType);
	void OnCheckNextPropStateFromLevelObject();
	void OnComponentBeginOverlapPropVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlapPropVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropSpot">();
	}
	static class ALPropSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropSpot>();
	}
};
static_assert(alignof(ALPropSpot) == 0x000008, "Wrong alignment on ALPropSpot");
static_assert(sizeof(ALPropSpot) == 0x000350, "Wrong size on ALPropSpot");
static_assert(offsetof(ALPropSpot, PropState) == 0x0002C8, "Member 'ALPropSpot::PropState' has a wrong offset!");
static_assert(offsetof(ALPropSpot, SpawnedActor) == 0x0002D0, "Member 'ALPropSpot::SpawnedActor' has a wrong offset!");
static_assert(offsetof(ALPropSpot, SaveFlag) == 0x0002D8, "Member 'ALPropSpot::SaveFlag' has a wrong offset!");
static_assert(offsetof(ALPropSpot, RespawnFlag) == 0x0002D9, "Member 'ALPropSpot::RespawnFlag' has a wrong offset!");
static_assert(offsetof(ALPropSpot, LinkedPropInfoList) == 0x0002E0, "Member 'ALPropSpot::LinkedPropInfoList' has a wrong offset!");
static_assert(offsetof(ALPropSpot, LinkedNpcSpotList) == 0x0002F0, "Member 'ALPropSpot::LinkedNpcSpotList' has a wrong offset!");
static_assert(offsetof(ALPropSpot, PropComponent) == 0x000300, "Member 'ALPropSpot::PropComponent' has a wrong offset!");
static_assert(offsetof(ALPropSpot, WorldEventComponent) == 0x000308, "Member 'ALPropSpot::WorldEventComponent' has a wrong offset!");
static_assert(offsetof(ALPropSpot, SpotSoundComponent) == 0x000310, "Member 'ALPropSpot::SpotSoundComponent' has a wrong offset!");
static_assert(offsetof(ALPropSpot, InteractCollisionComponent) == 0x000318, "Member 'ALPropSpot::InteractCollisionComponent' has a wrong offset!");
static_assert(offsetof(ALPropSpot, InteractStartComponent) == 0x000320, "Member 'ALPropSpot::InteractStartComponent' has a wrong offset!");
static_assert(offsetof(ALPropSpot, SoundLocationComponent) == 0x000328, "Member 'ALPropSpot::SoundLocationComponent' has a wrong offset!");
static_assert(offsetof(ALPropSpot, ReservedLinkedState) == 0x000330, "Member 'ALPropSpot::ReservedLinkedState' has a wrong offset!");
static_assert(offsetof(ALPropSpot, OnSpawnedActor) == 0x000338, "Member 'ALPropSpot::OnSpawnedActor' has a wrong offset!");

// Class ProjectP.LBossRoomSpot
// 0x00A8 (0x03F8 - 0x0350)
class ALBossRoomSpot : public ALPropSpot
{
public:
	TArray<class ALPropShapeObjectSpot*>          FogGateSpotList;                                   // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ALPropDoorSpot*                         BossDoorSpot;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPropShapeObjectSpot*                  BossDoorShapeObjectSpot;                           // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ALNPCSpot*>                      BossNpcSpotList;                                   // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ALNPCSpot*>                      RelationNpcSpotList;                               // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           RelationNpcCodeNameList;                           // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ALPropHelpMateSpot*                     PropHelpMateSpot;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCSpot*                              NPCHelpMateSpot;                                   // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropVolumeComponent*                  PC_ErgoDrop_Fix_Volume;                            // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        PC_ErgoDrop_Fix_Pos;                               // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BossNpcCodeName;                                   // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BossIsDead;                                        // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayerInVolume;                                  // 0x03C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NpcDefaultState;                                   // 0x03CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BossRoomActiveState;                               // 0x03CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALPropSpot>              ControlledBossDoor;                                // 0x03CC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CheckDefaultStatus;                                // 0x03D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DefaultActorSpawnableList;                         // 0x03D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ALNPCCharacter*>                 StoppedNPCs;                                       // 0x03E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnDeadSpawnNpc(class ALNPCSpot* TargetNpcSpot);
	void OnSpawnedActor(class ALPropSpot* TargetPropSpot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBossRoomSpot">();
	}
	static class ALBossRoomSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALBossRoomSpot>();
	}
};
static_assert(alignof(ALBossRoomSpot) == 0x000008, "Wrong alignment on ALBossRoomSpot");
static_assert(sizeof(ALBossRoomSpot) == 0x0003F8, "Wrong size on ALBossRoomSpot");
static_assert(offsetof(ALBossRoomSpot, FogGateSpotList) == 0x000350, "Member 'ALBossRoomSpot::FogGateSpotList' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, BossDoorSpot) == 0x000360, "Member 'ALBossRoomSpot::BossDoorSpot' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, BossDoorShapeObjectSpot) == 0x000368, "Member 'ALBossRoomSpot::BossDoorShapeObjectSpot' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, BossNpcSpotList) == 0x000370, "Member 'ALBossRoomSpot::BossNpcSpotList' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, RelationNpcSpotList) == 0x000380, "Member 'ALBossRoomSpot::RelationNpcSpotList' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, RelationNpcCodeNameList) == 0x000390, "Member 'ALBossRoomSpot::RelationNpcCodeNameList' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, PropHelpMateSpot) == 0x0003A0, "Member 'ALBossRoomSpot::PropHelpMateSpot' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, NPCHelpMateSpot) == 0x0003A8, "Member 'ALBossRoomSpot::NPCHelpMateSpot' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, PC_ErgoDrop_Fix_Volume) == 0x0003B0, "Member 'ALBossRoomSpot::PC_ErgoDrop_Fix_Volume' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, PC_ErgoDrop_Fix_Pos) == 0x0003B8, "Member 'ALBossRoomSpot::PC_ErgoDrop_Fix_Pos' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, BossNpcCodeName) == 0x0003C0, "Member 'ALBossRoomSpot::BossNpcCodeName' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, BossIsDead) == 0x0003C8, "Member 'ALBossRoomSpot::BossIsDead' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, IsPlayerInVolume) == 0x0003C9, "Member 'ALBossRoomSpot::IsPlayerInVolume' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, NpcDefaultState) == 0x0003CA, "Member 'ALBossRoomSpot::NpcDefaultState' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, BossRoomActiveState) == 0x0003CB, "Member 'ALBossRoomSpot::BossRoomActiveState' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, ControlledBossDoor) == 0x0003CC, "Member 'ALBossRoomSpot::ControlledBossDoor' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, CheckDefaultStatus) == 0x0003D4, "Member 'ALBossRoomSpot::CheckDefaultStatus' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, DefaultActorSpawnableList) == 0x0003D8, "Member 'ALBossRoomSpot::DefaultActorSpawnableList' has a wrong offset!");
static_assert(offsetof(ALBossRoomSpot, StoppedNPCs) == 0x0003E8, "Member 'ALBossRoomSpot::StoppedNPCs' has a wrong offset!");

// Class ProjectP.LDurableAbnormalBPFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULDurableAbnormalBPFuncLibrary final : public UObject
{
public:
	static struct FAbnormalStateCommonInfoPtr GetInfo(const struct FLDurableAbnormalBPPtr& In);
	static int64 GetUniqueId(const struct FLDurableAbnormalBPPtr& In);

	int32 GetRemainDuration(const struct FLDurableAbnormalBPPtr& In);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDurableAbnormalBPFuncLibrary">();
	}
	static class ULDurableAbnormalBPFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDurableAbnormalBPFuncLibrary>();
	}
};
static_assert(alignof(ULDurableAbnormalBPFuncLibrary) == 0x000008, "Wrong alignment on ULDurableAbnormalBPFuncLibrary");
static_assert(sizeof(ULDurableAbnormalBPFuncLibrary) == 0x000028, "Wrong size on ULDurableAbnormalBPFuncLibrary");

// Class ProjectP.LAnimNotifyStateBase
// 0x0010 (0x0040 - 0x0030)
class ULAnimNotifyStateBase : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enabled;                                           // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyStateBase">();
	}
	static class ULAnimNotifyStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyStateBase>();
	}
};
static_assert(alignof(ULAnimNotifyStateBase) == 0x000008, "Wrong alignment on ULAnimNotifyStateBase");
static_assert(sizeof(ULAnimNotifyStateBase) == 0x000040, "Wrong size on ULAnimNotifyStateBase");
static_assert(offsetof(ULAnimNotifyStateBase, Enabled) == 0x000038, "Member 'ULAnimNotifyStateBase::Enabled' has a wrong offset!");

// Class ProjectP.LAnimNotify_RunNotiEnd_SendNPCWorldTrigger
// 0x0028 (0x0068 - 0x0040)
class ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger final : public ULAnimNotifyStateBase
{
public:
	ELAISendWorldTriggerType                      TriggerType;                                       // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TriggerString;                                     // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendRadius;                                        // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCCodeName;                                       // 0x005C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_RunNotiEnd_SendNPCWorldTrigger">();
	}
	static class ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger>();
	}
};
static_assert(alignof(ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger) == 0x000008, "Wrong alignment on ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger");
static_assert(sizeof(ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger) == 0x000068, "Wrong size on ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger");
static_assert(offsetof(ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger, TriggerType) == 0x000040, "Member 'ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger::TriggerType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger, TriggerString) == 0x000048, "Member 'ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger::TriggerString' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger, SendRadius) == 0x000058, "Member 'ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger::SendRadius' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger, NPCCodeName) == 0x00005C, "Member 'ULAnimNotify_RunNotiEnd_SendNPCWorldTrigger::NPCCodeName' has a wrong offset!");

// Class ProjectP.LBTComposite_Bool
// 0x0000 (0x0090 - 0x0090)
class ULBTComposite_Bool final : public UBTCompositeNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBTComposite_Bool">();
	}
	static class ULBTComposite_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBTComposite_Bool>();
	}
};
static_assert(alignof(ULBTComposite_Bool) == 0x000008, "Wrong alignment on ULBTComposite_Bool");
static_assert(sizeof(ULBTComposite_Bool) == 0x000090, "Wrong size on ULBTComposite_Bool");

// Class ProjectP.LActPayload_HitAnim
// 0x0160 (0x0190 - 0x0030)
class ULActPayload_HitAnim final : public ULActPayloadBase
{
public:
	class AActor*                                 Attacker;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0038(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          Cached_IsBackHit;                                  // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_HitAnim">();
	}
	static class ULActPayload_HitAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_HitAnim>();
	}
};
static_assert(alignof(ULActPayload_HitAnim) == 0x000008, "Wrong alignment on ULActPayload_HitAnim");
static_assert(sizeof(ULActPayload_HitAnim) == 0x000190, "Wrong size on ULActPayload_HitAnim");
static_assert(offsetof(ULActPayload_HitAnim, Attacker) == 0x000030, "Member 'ULActPayload_HitAnim::Attacker' has a wrong offset!");
static_assert(offsetof(ULActPayload_HitAnim, HitInfo) == 0x000038, "Member 'ULActPayload_HitAnim::HitInfo' has a wrong offset!");
static_assert(offsetof(ULActPayload_HitAnim, Cached_IsBackHit) == 0x000188, "Member 'ULActPayload_HitAnim::Cached_IsBackHit' has a wrong offset!");

// Class ProjectP.LAbnormalCalculator
// 0x0008 (0x0030 - 0x0028)
class ULAbnormalCalculator final : public UObject
{
public:
	TWeakObjectPtr<class ALCharacter>             OwnerCharacter;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAbnormalCalculator">();
	}
	static class ULAbnormalCalculator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAbnormalCalculator>();
	}
};
static_assert(alignof(ULAbnormalCalculator) == 0x000008, "Wrong alignment on ULAbnormalCalculator");
static_assert(sizeof(ULAbnormalCalculator) == 0x000030, "Wrong size on ULAbnormalCalculator");
static_assert(offsetof(ULAbnormalCalculator, OwnerCharacter) == 0x000028, "Member 'ULAbnormalCalculator::OwnerCharacter' has a wrong offset!");

// Class ProjectP.LHitCollisionBoxComponent
// 0x0000 (0x0470 - 0x0470)
class ULHitCollisionBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitCollisionBoxComponent">();
	}
	static class ULHitCollisionBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHitCollisionBoxComponent>();
	}
};
static_assert(alignof(ULHitCollisionBoxComponent) == 0x000010, "Wrong alignment on ULHitCollisionBoxComponent");
static_assert(sizeof(ULHitCollisionBoxComponent) == 0x000470, "Wrong size on ULHitCollisionBoxComponent");

// Class ProjectP.LAbnormalComponent
// 0x0130 (0x01E0 - 0x00B0)
class ULAbnormalComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALCharacter>             OwnerCharacter;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULAbnormalCalculator*                   AbnormalCalculator;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLAbnormalFromOther>            AppliedFromOthers;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnApplyRunningAbnormal;                            // 0x0108(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0xC8];                                     // 0x0118(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BuildupHitBP(const struct FLCalcBuildupData& InBuildupData);
	TArray<struct FLCalcBuildupData> CalcDirectBuildupHitByHit(const struct FLHitInfo& InHitInfo, int32 InSkillBuildupDamage, int32 InFireBuildupDamage, int32 InElectricBuildupDamage, int32 InAcidBuildupDamage);
	int32 GetAppliedAbnormalMaxDurationByUniqueId(int64 InAbnormalUniqueId);
	int32 GetAppliedAbnormalRemainDurationByUniqueId(int64 InAbnormalUniqueId);
	void OnBrokenBlade();
	void OnCaptureMoment(class AActor* Owner, const struct FMomentConditionCaptureInfo& Capture);
	void OnChooseOtherWeapon(const struct FLEquipItemSlot& EquipSlot);
	void OnPlayHideFX(bool IsHide);
	void OnRemoveAbnormalNiagaraFX(class UNiagaraComponent* InNiagaraComp);
	void OnRemoveAbnormalParticleFX(class UParticleSystemComponent* InParticleComp);
	void OnSatisfiedBuffAlter(const struct FHumanizationBuffAlterInfoPtr& InActiveBuffAlterInfo);
	int64 PutOn(const class FName& InAbnormalCodeName, bool ForceNewAbnormal);
	int64 PutOnByPayload(const class FName& InAbnormalCodeName, const struct FLAbnormalPayload& InPayload);
	int64 PutOnWithInstigator(const class FName& InAbnormalCodeName, class UObject* InInstigator);
	int64 PutOnWithReason(const class FName& InAbnormalCodeName, const class FName& InReasonCodeName);
	void RequestBroadcast_NPCElementUI();
	void TakeOff(const class FName& InAbnormalCodeName, bool Immediately);
	void TakeOffAllByInstigator(class UObject* InInstigator, bool Immediately);
	void TakeOffByGroup(const class FName& IGroupCodeName, bool Immediately);
	void TakeOffByInstigator(const class FName& InAbnormalCodeName, class UObject* InInstigator, bool Immediately);
	void TakeOffByUniqueId(int64 InAbnormalUniqueId, bool Immediately);
	bool TakeOffWithRefCount(int64 InAbnormalUniqueId, bool Immediately);

	TArray<struct FLDurableAbnormalBPPtr> GetAppliedAbnormals() const;
	bool IsAppliedAbnormal(const class FName& InAbnormalCodeName) const;
	int32 IsAppliedAbnormalCount(const class FName& InAbnormalCodeName) const;
	bool IsAppliedGroupAbnormal(const class FName& GroupCodename) const;
	bool IsBuildupAbnormal(const class FName& InAbnormalCodeName) const;
	bool IsGaugeAbnormal(const class FName& InAbnormalCodeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAbnormalComponent">();
	}
	static class ULAbnormalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAbnormalComponent>();
	}
};
static_assert(alignof(ULAbnormalComponent) == 0x000008, "Wrong alignment on ULAbnormalComponent");
static_assert(sizeof(ULAbnormalComponent) == 0x0001E0, "Wrong size on ULAbnormalComponent");
static_assert(offsetof(ULAbnormalComponent, OwnerCharacter) == 0x0000C0, "Member 'ULAbnormalComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ULAbnormalComponent, AbnormalCalculator) == 0x0000C8, "Member 'ULAbnormalComponent::AbnormalCalculator' has a wrong offset!");
static_assert(offsetof(ULAbnormalComponent, AppliedFromOthers) == 0x0000E0, "Member 'ULAbnormalComponent::AppliedFromOthers' has a wrong offset!");
static_assert(offsetof(ULAbnormalComponent, OnApplyRunningAbnormal) == 0x000108, "Member 'ULAbnormalComponent::OnApplyRunningAbnormal' has a wrong offset!");

// Class ProjectP.LGameSubSystem
// 0x0048 (0x0078 - 0x0030)
class ULGameSubSystem : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnedSystemData;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 SystemLibraryClass;                                // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 SystemDataClass;                                   // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 DefaultSystemData;                                 // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InitialPriority;                                   // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameSubSystem">();
	}
	static class ULGameSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameSubSystem>();
	}
};
static_assert(alignof(ULGameSubSystem) == 0x000008, "Wrong alignment on ULGameSubSystem");
static_assert(sizeof(ULGameSubSystem) == 0x000078, "Wrong size on ULGameSubSystem");
static_assert(offsetof(ULGameSubSystem, SpawnedSystemData) == 0x000048, "Member 'ULGameSubSystem::SpawnedSystemData' has a wrong offset!");
static_assert(offsetof(ULGameSubSystem, SystemLibraryClass) == 0x000058, "Member 'ULGameSubSystem::SystemLibraryClass' has a wrong offset!");
static_assert(offsetof(ULGameSubSystem, SystemDataClass) == 0x000060, "Member 'ULGameSubSystem::SystemDataClass' has a wrong offset!");
static_assert(offsetof(ULGameSubSystem, DefaultSystemData) == 0x000068, "Member 'ULGameSubSystem::DefaultSystemData' has a wrong offset!");
static_assert(offsetof(ULGameSubSystem, InitialPriority) == 0x000070, "Member 'ULGameSubSystem::InitialPriority' has a wrong offset!");

// Class ProjectP.LBTask_BlueprintBase
// 0x0008 (0x00B0 - 0x00A8)
class ULBTask_BlueprintBase : public UBTTask_BlueprintBase
{
public:
	class ALAIController*                         LAIOwner;                                          // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetBehaivorTreeNodeName();
	void OnPostEditChangeProperty();
	void SetBehaivorTreeNodeName(const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBTask_BlueprintBase">();
	}
	static class ULBTask_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBTask_BlueprintBase>();
	}
};
static_assert(alignof(ULBTask_BlueprintBase) == 0x000008, "Wrong alignment on ULBTask_BlueprintBase");
static_assert(sizeof(ULBTask_BlueprintBase) == 0x0000B0, "Wrong size on ULBTask_BlueprintBase");
static_assert(offsetof(ULBTask_BlueprintBase, LAIOwner) == 0x0000A8, "Member 'ULBTask_BlueprintBase::LAIOwner' has a wrong offset!");

// Class ProjectP.LDynamicDamageVolumeActor
// 0x0080 (0x0260 - 0x01E0)
class ALDynamicDamageVolumeActor : public AActor
{
public:
	struct FDynamicDamageVolumeInfoPtr            Info;                                              // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x50];                                     // 0x01E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableTick;                                       // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDynamicDamageVolume_TargetInfo> TargetList;                                        // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRemoveOverlappedActor_when_EndOverlap;            // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0xF];                                      // 0x0251(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDamagePerTime(class ALCharacter* TargetActor);
	void ApplyDamage(class AActor* TargetActor, const struct FHitResult& HitResult, class FName Skill_Hit_Override);
	TArray<class AActor*> GetOverlappedActors();
	void OnBeginOverlap(class AActor* Actor, const struct FHitResult& HitResult);
	void OnEndOverlap(class AActor* Actor);
	void RemoveDamagePerTime(class AActor* TargetActor);
	void Reset();
	void ResetDynamicDamageVolumeInfo(class FName InCodeName);
	void SetOverlappedActors(const TArray<class AActor*>& InActorList);
	void Start();
	void Stop();
	void UpdateOverlapEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDynamicDamageVolumeActor">();
	}
	static class ALDynamicDamageVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDynamicDamageVolumeActor>();
	}
};
static_assert(alignof(ALDynamicDamageVolumeActor) == 0x000008, "Wrong alignment on ALDynamicDamageVolumeActor");
static_assert(sizeof(ALDynamicDamageVolumeActor) == 0x000260, "Wrong size on ALDynamicDamageVolumeActor");
static_assert(offsetof(ALDynamicDamageVolumeActor, Info) == 0x0001E0, "Member 'ALDynamicDamageVolumeActor::Info' has a wrong offset!");
static_assert(offsetof(ALDynamicDamageVolumeActor, bEnableTick) == 0x000238, "Member 'ALDynamicDamageVolumeActor::bEnableTick' has a wrong offset!");
static_assert(offsetof(ALDynamicDamageVolumeActor, TargetList) == 0x000240, "Member 'ALDynamicDamageVolumeActor::TargetList' has a wrong offset!");
static_assert(offsetof(ALDynamicDamageVolumeActor, bRemoveOverlappedActor_when_EndOverlap) == 0x000250, "Member 'ALDynamicDamageVolumeActor::bRemoveOverlappedActor_when_EndOverlap' has a wrong offset!");

// Class ProjectP.LAchievementSystem
// 0x0118 (0x0190 - 0x0078)
class ULAchievementSystem final : public ULGameSubSystem
{
public:
	bool                                          bVisibleCompleteUI;                                // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FLAchievementHierarchyInfo> AchievementDB;                                     // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<ELCallBackEventType, struct FLAchievementDetailInfoList> AutoCompleteAchievementDB;                         // 0x00D0(0x0050)(Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCompleteAchievement;                             // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleteAchievementDetail;                       // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<ELCallBackEventType, struct FLAchievementDetailInfoList> CompleteAchievementList;                           // 0x0140(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	class FString MakeAchievementLog(const class FName& AchievementCodeName);
	void OnSendPlatform(class FName AchievementCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAchievementSystem">();
	}
	static class ULAchievementSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAchievementSystem>();
	}
};
static_assert(alignof(ULAchievementSystem) == 0x000008, "Wrong alignment on ULAchievementSystem");
static_assert(sizeof(ULAchievementSystem) == 0x000190, "Wrong size on ULAchievementSystem");
static_assert(offsetof(ULAchievementSystem, bVisibleCompleteUI) == 0x000078, "Member 'ULAchievementSystem::bVisibleCompleteUI' has a wrong offset!");
static_assert(offsetof(ULAchievementSystem, AchievementDB) == 0x000080, "Member 'ULAchievementSystem::AchievementDB' has a wrong offset!");
static_assert(offsetof(ULAchievementSystem, AutoCompleteAchievementDB) == 0x0000D0, "Member 'ULAchievementSystem::AutoCompleteAchievementDB' has a wrong offset!");
static_assert(offsetof(ULAchievementSystem, OnCompleteAchievement) == 0x000120, "Member 'ULAchievementSystem::OnCompleteAchievement' has a wrong offset!");
static_assert(offsetof(ULAchievementSystem, OnCompleteAchievementDetail) == 0x000130, "Member 'ULAchievementSystem::OnCompleteAchievementDetail' has a wrong offset!");
static_assert(offsetof(ULAchievementSystem, CompleteAchievementList) == 0x000140, "Member 'ULAchievementSystem::CompleteAchievementList' has a wrong offset!");

// Class ProjectP.LAnimNotifyBase
// 0x0010 (0x0048 - 0x0038)
class ULAnimNotifyBase : public UAnimNotify
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enabled;                                           // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyBase">();
	}
	static class ULAnimNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyBase>();
	}
};
static_assert(alignof(ULAnimNotifyBase) == 0x000008, "Wrong alignment on ULAnimNotifyBase");
static_assert(sizeof(ULAnimNotifyBase) == 0x000048, "Wrong size on ULAnimNotifyBase");
static_assert(offsetof(ULAnimNotifyBase, Enabled) == 0x000040, "Member 'ULAnimNotifyBase::Enabled' has a wrong offset!");

// Class ProjectP.LAnimNotify_LaunchWire
// 0x0010 (0x0058 - 0x0048)
class ULAnimNotify_LaunchWire final : public ULAnimNotifyBase
{
public:
	TSubclassOf<class AActor>                     ActorToSpawn;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnSocketName;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_LaunchWire">();
	}
	static class ULAnimNotify_LaunchWire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_LaunchWire>();
	}
};
static_assert(alignof(ULAnimNotify_LaunchWire) == 0x000008, "Wrong alignment on ULAnimNotify_LaunchWire");
static_assert(sizeof(ULAnimNotify_LaunchWire) == 0x000058, "Wrong size on ULAnimNotify_LaunchWire");
static_assert(offsetof(ULAnimNotify_LaunchWire, ActorToSpawn) == 0x000048, "Member 'ULAnimNotify_LaunchWire::ActorToSpawn' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_LaunchWire, SpawnSocketName) == 0x000050, "Member 'ULAnimNotify_LaunchWire::SpawnSocketName' has a wrong offset!");

// Class ProjectP.LBTask_Test
// 0x0018 (0x0088 - 0x0070)
class ULBTask_Test final : public UBTTaskNode
{
public:
	EBTNodeResult                                 ResultType;                                        // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressingTime;                                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVLogToEachTask;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALAIController*                         LAIOwner;                                          // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBTask_Test">();
	}
	static class ULBTask_Test* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBTask_Test>();
	}
};
static_assert(alignof(ULBTask_Test) == 0x000008, "Wrong alignment on ULBTask_Test");
static_assert(sizeof(ULBTask_Test) == 0x000088, "Wrong size on ULBTask_Test");
static_assert(offsetof(ULBTask_Test, ResultType) == 0x000070, "Member 'ULBTask_Test::ResultType' has a wrong offset!");
static_assert(offsetof(ULBTask_Test, ProgressingTime) == 0x000074, "Member 'ULBTask_Test::ProgressingTime' has a wrong offset!");
static_assert(offsetof(ULBTask_Test, bVLogToEachTask) == 0x000078, "Member 'ULBTask_Test::bVLogToEachTask' has a wrong offset!");
static_assert(offsetof(ULBTask_Test, LAIOwner) == 0x000080, "Member 'ULBTask_Test::LAIOwner' has a wrong offset!");

// Class ProjectP.LActionClass
// 0x0000 (0x0028 - 0x0028)
class ULActionClass final : public UObject
{
public:
	static class FName ULActionClass_Climb();
	static class FName ULActionClass_Common();
	static class FName ULActionClass_CommonMontage();
	static class FName ULActionClass_Dialoging();
	static class FName ULActionClass_Die();
	static class FName ULActionClass_DMG_STAND();
	static class FName ULActionClass_Down_Away();
	static class FName ULActionClass_Down_Drag();
	static class FName ULActionClass_Down_Stamp();
	static class FName ULActionClass_Down_Up();
	static class FName ULActionClass_Draw_Weapon();
	static class FName ULActionClass_Falling();
	static class FName ULActionClass_FatalAttack();
	static class FName ULActionClass_FatalAttack_Victim();
	static class FName ULActionClass_FatalAttack_Victim_BeforeHit();
	static class FName ULActionClass_FatalAttack_Victim_End();
	static class FName ULActionClass_FloatingHit();
	static class FName ULActionClass_Game_Start();
	static class FName ULActionClass_GetUpDash();
	static class FName ULActionClass_Grab();
	static class FName ULActionClass_Grabbed();
	static class FName ULActionClass_GrabRelease();
	static class FName ULActionClass_Grinder_Element();
	static class FName ULActionClass_Groggy();
	static class FName ULActionClass_Guard();
	static class FName ULActionClass_Guard_Break();
	static class FName ULActionClass_Guard_Hit_Heavy();
	static class FName ULActionClass_Guard_Hit_Normal();
	static class FName ULActionClass_Guard_Reflect();
	static class FName ULActionClass_Guard_Repulse();
	static class FName ULActionClass_IdleTurn();
	static class FName ULActionClass_IdleTurnEnd();
	static class FName ULActionClass_Interaction();
	static class FName ULActionClass_Jump();
	static class FName ULActionClass_KnockBack();
	static class FName ULActionClass_Landing();
	static class FName ULActionClass_Multiple();
	static class FName ULActionClass_None();
	static class FName ULActionClass_NpcGuard_Break();
	static class FName ULActionClass_NpcGuard_Hit();
	static class FName ULActionClass_NpcGuard_Hit_Repulse();
	static class FName ULActionClass_Object_Repulse();
	static class FName ULActionClass_Paralyzation();
	static class FName ULActionClass_Parry();
	static class FName ULActionClass_Put_Weapon();
	static class FName ULActionClass_SkillFailed();
	static class FName ULActionClass_SlaveArm();
	static class FName ULActionClass_SlaveArm_Visual_Idle();
	static class FName ULActionClass_SpawnIdle();
	static class FName ULActionClass_Sprint();
	static class FName ULActionClass_Sprint_Exhausted();
	static class FName ULActionClass_Sprint_TurnAround();
	static class FName ULActionClass_StopRunning();
	static class FName ULActionClass_StopSprint();
	static class FName ULActionClass_TalkerIdle();
	static class FName ULActionClass_Teleport_End();
	static class FName ULActionClass_Teleport_NewGamePlus();
	static class FName ULActionClass_Teleport_Start();
	static class FName ULActionClass_ToughSpecialHit();
	static class FName ULActionClass_TurnAround();
	static class FName ULActionClass_Use_Item();
	static class FName ULActionClass_Weapon_Change();
	static class FName ULActionClass_Wire_Following();
	static class FName ULActionClass_Wire_Hit();
	static class FName ULActionClass_Wire_Pulling();
	static class FName ULActionClass_WireAction();
	static class FName ULActionClass_WireJumpSmash();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionClass">();
	}
	static class ULActionClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActionClass>();
	}
};
static_assert(alignof(ULActionClass) == 0x000008, "Wrong alignment on ULActionClass");
static_assert(sizeof(ULActionClass) == 0x000028, "Wrong size on ULActionClass");

// Class ProjectP.LBTComposite_ForceSequence
// 0x0000 (0x0090 - 0x0090)
class ULBTComposite_ForceSequence final : public UBTCompositeNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBTComposite_ForceSequence">();
	}
	static class ULBTComposite_ForceSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBTComposite_ForceSequence>();
	}
};
static_assert(alignof(ULBTComposite_ForceSequence) == 0x000008, "Wrong alignment on ULBTComposite_ForceSequence");
static_assert(sizeof(ULBTComposite_ForceSequence) == 0x000090, "Wrong size on ULBTComposite_ForceSequence");

// Class ProjectP.LEnvSettings
// 0x08C8 (0x08F0 - 0x0028)
class ULEnvSettings : public UObject
{
public:
	struct FLDirectionalLightSettings             DirectionalLight;                                  // 0x0028(0x005C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLDirectionalLightNoShadowSettings     DirectionalLightNoShadow;                          // 0x0084(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLDirectionalLightNoShadowSettings     DirectionalLightCharacter;                         // 0x00B0(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSkyLightSettings                     SkyLight;                                          // 0x00DC(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLHeightFogSettings                    HeightFog;                                         // 0x00F8(0x006C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSkySphereSettings                    SkySphere;                                         // 0x0164(0x0094)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLCloudSettings                        Cloud;                                             // 0x01F8(0x008C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLWeatherSettings                      Weather;                                           // 0x0284(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLLightningSettings                    Lightning;                                         // 0x02C4(0x0074)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcess;                                       // 0x0340(0x05B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnApplySetting_BP(float LocalWeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LEnvSettings">();
	}
	static class ULEnvSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULEnvSettings>();
	}
};
static_assert(alignof(ULEnvSettings) == 0x000010, "Wrong alignment on ULEnvSettings");
static_assert(sizeof(ULEnvSettings) == 0x0008F0, "Wrong size on ULEnvSettings");
static_assert(offsetof(ULEnvSettings, DirectionalLight) == 0x000028, "Member 'ULEnvSettings::DirectionalLight' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, DirectionalLightNoShadow) == 0x000084, "Member 'ULEnvSettings::DirectionalLightNoShadow' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, DirectionalLightCharacter) == 0x0000B0, "Member 'ULEnvSettings::DirectionalLightCharacter' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, SkyLight) == 0x0000DC, "Member 'ULEnvSettings::SkyLight' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, HeightFog) == 0x0000F8, "Member 'ULEnvSettings::HeightFog' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, SkySphere) == 0x000164, "Member 'ULEnvSettings::SkySphere' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, Cloud) == 0x0001F8, "Member 'ULEnvSettings::Cloud' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, Weather) == 0x000284, "Member 'ULEnvSettings::Weather' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, Lightning) == 0x0002C4, "Member 'ULEnvSettings::Lightning' has a wrong offset!");
static_assert(offsetof(ULEnvSettings, PostProcess) == 0x000340, "Member 'ULEnvSettings::PostProcess' has a wrong offset!");

// Class ProjectP.LActPayload_UseItem
// 0x0010 (0x0040 - 0x0030)
class ULActPayload_UseItem final : public ULActPayloadBase
{
public:
	class ULItem*                                 Item;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELItemUseOccurredFrom                         ItemUsedFrom;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassedSlavearmAlterProcess;                      // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_UseItem">();
	}
	static class ULActPayload_UseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_UseItem>();
	}
};
static_assert(alignof(ULActPayload_UseItem) == 0x000008, "Wrong alignment on ULActPayload_UseItem");
static_assert(sizeof(ULActPayload_UseItem) == 0x000040, "Wrong size on ULActPayload_UseItem");
static_assert(offsetof(ULActPayload_UseItem, Item) == 0x000030, "Member 'ULActPayload_UseItem::Item' has a wrong offset!");
static_assert(offsetof(ULActPayload_UseItem, UseCount) == 0x000038, "Member 'ULActPayload_UseItem::UseCount' has a wrong offset!");
static_assert(offsetof(ULActPayload_UseItem, ItemUsedFrom) == 0x00003C, "Member 'ULActPayload_UseItem::ItemUsedFrom' has a wrong offset!");
static_assert(offsetof(ULActPayload_UseItem, IsPassedSlavearmAlterProcess) == 0x00003D, "Member 'ULActPayload_UseItem::IsPassedSlavearmAlterProcess' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_EnableFatalATK
// 0x00A8 (0x00E8 - 0x0040)
class ULAnimNotifyState_EnableFatalATK final : public ULAnimNotifyStateBase
{
public:
	struct FLFatalAttackInfo                      FatalAttackInfo;                                   // 0x0040(0x0054)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo_Add;                               // 0x0094(0x0054)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_EnableFatalATK">();
	}
	static class ULAnimNotifyState_EnableFatalATK* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_EnableFatalATK>();
	}
};
static_assert(alignof(ULAnimNotifyState_EnableFatalATK) == 0x000008, "Wrong alignment on ULAnimNotifyState_EnableFatalATK");
static_assert(sizeof(ULAnimNotifyState_EnableFatalATK) == 0x0000E8, "Wrong size on ULAnimNotifyState_EnableFatalATK");
static_assert(offsetof(ULAnimNotifyState_EnableFatalATK, FatalAttackInfo) == 0x000040, "Member 'ULAnimNotifyState_EnableFatalATK::FatalAttackInfo' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableFatalATK, FatalAttackInfo_Add) == 0x000094, "Member 'ULAnimNotifyState_EnableFatalATK::FatalAttackInfo_Add' has a wrong offset!");

// Class ProjectP.LBTreeFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULBTreeFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetBlackboardValueAsLocation(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBTreeFuncLibrary">();
	}
	static class ULBTreeFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBTreeFuncLibrary>();
	}
};
static_assert(alignof(ULBTreeFuncLibrary) == 0x000008, "Wrong alignment on ULBTreeFuncLibrary");
static_assert(sizeof(ULBTreeFuncLibrary) == 0x000028, "Wrong size on ULBTreeFuncLibrary");

// Class ProjectP.LActPayload_Interaction
// 0x0010 (0x0040 - 0x0030)
class ULActPayload_Interaction final : public ULActPayloadBase
{
public:
	TScriptInterface<class ILInteractInterface>   InteractingComponent;                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_Interaction">();
	}
	static class ULActPayload_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_Interaction>();
	}
};
static_assert(alignof(ULActPayload_Interaction) == 0x000008, "Wrong alignment on ULActPayload_Interaction");
static_assert(sizeof(ULActPayload_Interaction) == 0x000040, "Wrong size on ULActPayload_Interaction");
static_assert(offsetof(ULActPayload_Interaction, InteractingComponent) == 0x000030, "Member 'ULActPayload_Interaction::InteractingComponent' has a wrong offset!");

// Class ProjectP.LBTreeStateMachineData
// 0x0060 (0x0090 - 0x0030)
class ULBTreeStateMachineData : public UDataAsset
{
public:
	TMap<class FName, struct FLBTreeState>        States;                                            // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FLNPCSpecCondActivatorSet>      SpecConditionActivators;                           // 0x0080(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBTreeStateMachineData">();
	}
	static class ULBTreeStateMachineData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBTreeStateMachineData>();
	}
};
static_assert(alignof(ULBTreeStateMachineData) == 0x000008, "Wrong alignment on ULBTreeStateMachineData");
static_assert(sizeof(ULBTreeStateMachineData) == 0x000090, "Wrong size on ULBTreeStateMachineData");
static_assert(offsetof(ULBTreeStateMachineData, States) == 0x000030, "Member 'ULBTreeStateMachineData::States' has a wrong offset!");
static_assert(offsetof(ULBTreeStateMachineData, SpecConditionActivators) == 0x000080, "Member 'ULBTreeStateMachineData::SpecConditionActivators' has a wrong offset!");

// Class ProjectP.LWorldLoadScreenInfo
// 0x0070 (0x0098 - 0x0028)
class ULWorldLoadScreenInfo final : public UObject
{
public:
	struct FLoadingScreenInfoPtr                  ScreenInfo;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLoadingTipInfoPtr>             TipInfos;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x58];                                      // 0x0040(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldLoadScreenInfo">();
	}
	static class ULWorldLoadScreenInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWorldLoadScreenInfo>();
	}
};
static_assert(alignof(ULWorldLoadScreenInfo) == 0x000008, "Wrong alignment on ULWorldLoadScreenInfo");
static_assert(sizeof(ULWorldLoadScreenInfo) == 0x000098, "Wrong size on ULWorldLoadScreenInfo");
static_assert(offsetof(ULWorldLoadScreenInfo, ScreenInfo) == 0x000028, "Member 'ULWorldLoadScreenInfo::ScreenInfo' has a wrong offset!");
static_assert(offsetof(ULWorldLoadScreenInfo, TipInfos) == 0x000030, "Member 'ULWorldLoadScreenInfo::TipInfos' has a wrong offset!");

// Class ProjectP.LActPayload_Die
// 0x0008 (0x0038 - 0x0030)
class ULActPayload_Die final : public ULActPayloadBase
{
public:
	TWeakObjectPtr<class ULReasonForDeathInfo>    ReasonInfo;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_Die">();
	}
	static class ULActPayload_Die* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_Die>();
	}
};
static_assert(alignof(ULActPayload_Die) == 0x000008, "Wrong alignment on ULActPayload_Die");
static_assert(sizeof(ULActPayload_Die) == 0x000038, "Wrong size on ULActPayload_Die");
static_assert(offsetof(ULActPayload_Die, ReasonInfo) == 0x000030, "Member 'ULActPayload_Die::ReasonInfo' has a wrong offset!");

// Class ProjectP.LAnimNotify_Unbuff
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_Unbuff final : public ULAnimNotifyBase
{
public:
	class FName                                   BuffCodeName;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_Unbuff">();
	}
	static class ULAnimNotify_Unbuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_Unbuff>();
	}
};
static_assert(alignof(ULAnimNotify_Unbuff) == 0x000008, "Wrong alignment on ULAnimNotify_Unbuff");
static_assert(sizeof(ULAnimNotify_Unbuff) == 0x000050, "Wrong size on ULAnimNotify_Unbuff");
static_assert(offsetof(ULAnimNotify_Unbuff, BuffCodeName) == 0x000048, "Member 'ULAnimNotify_Unbuff::BuffCodeName' has a wrong offset!");

// Class ProjectP.LActPayload_TurnAround
// 0x0018 (0x0048 - 0x0030)
class ULActPayload_TurnAround final : public ULActPayloadBase
{
public:
	bool                                          bMoveRotation;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleTurnAround;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolTime;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddCooltime;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlaySpeed;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_TurnAround">();
	}
	static class ULActPayload_TurnAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_TurnAround>();
	}
};
static_assert(alignof(ULActPayload_TurnAround) == 0x000008, "Wrong alignment on ULActPayload_TurnAround");
static_assert(sizeof(ULActPayload_TurnAround) == 0x000048, "Wrong size on ULActPayload_TurnAround");
static_assert(offsetof(ULActPayload_TurnAround, bMoveRotation) == 0x000030, "Member 'ULActPayload_TurnAround::bMoveRotation' has a wrong offset!");
static_assert(offsetof(ULActPayload_TurnAround, AngleTurnAround) == 0x000034, "Member 'ULActPayload_TurnAround::AngleTurnAround' has a wrong offset!");
static_assert(offsetof(ULActPayload_TurnAround, CoolTime) == 0x000038, "Member 'ULActPayload_TurnAround::CoolTime' has a wrong offset!");
static_assert(offsetof(ULActPayload_TurnAround, bAddCooltime) == 0x00003C, "Member 'ULActPayload_TurnAround::bAddCooltime' has a wrong offset!");
static_assert(offsetof(ULActPayload_TurnAround, PlaySpeed) == 0x000040, "Member 'ULActPayload_TurnAround::PlaySpeed' has a wrong offset!");

// Class ProjectP.LActPayload_CommonAction
// 0x0008 (0x0038 - 0x0030)
class ULActPayload_CommonAction final : public ULActPayloadBase
{
public:
	class FName                                   CommonActionMontageCodeName;                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_CommonAction">();
	}
	static class ULActPayload_CommonAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_CommonAction>();
	}
};
static_assert(alignof(ULActPayload_CommonAction) == 0x000008, "Wrong alignment on ULActPayload_CommonAction");
static_assert(sizeof(ULActPayload_CommonAction) == 0x000038, "Wrong size on ULActPayload_CommonAction");
static_assert(offsetof(ULActPayload_CommonAction, CommonActionMontageCodeName) == 0x000030, "Member 'ULActPayload_CommonAction::CommonActionMontageCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_UseHeadLookat
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_UseHeadLookat final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_UseHeadLookat">();
	}
	static class ULAnimNotifyState_UseHeadLookat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_UseHeadLookat>();
	}
};
static_assert(alignof(ULAnimNotifyState_UseHeadLookat) == 0x000008, "Wrong alignment on ULAnimNotifyState_UseHeadLookat");
static_assert(sizeof(ULAnimNotifyState_UseHeadLookat) == 0x000040, "Wrong size on ULAnimNotifyState_UseHeadLookat");

// Class ProjectP.LActPayload_SlaveArm
// 0x0008 (0x0038 - 0x0030)
class ULActPayload_SlaveArm final : public ULActPayloadBase
{
public:
	ELActionCategory                              PreviousActionCategory;                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FulminisChargingStep;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_SlaveArm">();
	}
	static class ULActPayload_SlaveArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_SlaveArm>();
	}
};
static_assert(alignof(ULActPayload_SlaveArm) == 0x000008, "Wrong alignment on ULActPayload_SlaveArm");
static_assert(sizeof(ULActPayload_SlaveArm) == 0x000038, "Wrong size on ULActPayload_SlaveArm");
static_assert(offsetof(ULActPayload_SlaveArm, PreviousActionCategory) == 0x000030, "Member 'ULActPayload_SlaveArm::PreviousActionCategory' has a wrong offset!");
static_assert(offsetof(ULActPayload_SlaveArm, FulminisChargingStep) == 0x000034, "Member 'ULActPayload_SlaveArm::FulminisChargingStep' has a wrong offset!");

// Class ProjectP.LButton
// 0x0038 (0x0468 - 0x0430)
class ULButton final : public UButton
{
public:
	FMulticastInlineDelegateProperty_             OnFocused;                                         // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnfocused;                                       // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSelected;                                         // 0x0460(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSelected(bool bSelected_0);

	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LButton">();
	}
	static class ULButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULButton>();
	}
};
static_assert(alignof(ULButton) == 0x000008, "Wrong alignment on ULButton");
static_assert(sizeof(ULButton) == 0x000468, "Wrong size on ULButton");
static_assert(offsetof(ULButton, OnFocused) == 0x000430, "Member 'ULButton::OnFocused' has a wrong offset!");
static_assert(offsetof(ULButton, OnUnfocused) == 0x000440, "Member 'ULButton::OnUnfocused' has a wrong offset!");
static_assert(offsetof(ULButton, bSelected) == 0x000460, "Member 'ULButton::bSelected' has a wrong offset!");

// Class ProjectP.ProjectPGameModeBase
// 0x0000 (0x0280 - 0x0280)
class AProjectPGameModeBase final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectPGameModeBase">();
	}
	static class AProjectPGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProjectPGameModeBase>();
	}
};
static_assert(alignof(AProjectPGameModeBase) == 0x000008, "Wrong alignment on AProjectPGameModeBase");
static_assert(sizeof(AProjectPGameModeBase) == 0x000280, "Wrong size on AProjectPGameModeBase");

// Class ProjectP.LActPayload_GrabRelease
// 0x0058 (0x0088 - 0x0030)
class ULActPayload_GrabRelease final : public ULActPayloadBase
{
public:
	struct FLGrabResultInfo                       GrabResultInfo;                                    // 0x0030(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGrabReleaseInfo                      GrabReleaseInfo;                                   // 0x0068(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_GrabRelease">();
	}
	static class ULActPayload_GrabRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_GrabRelease>();
	}
};
static_assert(alignof(ULActPayload_GrabRelease) == 0x000008, "Wrong alignment on ULActPayload_GrabRelease");
static_assert(sizeof(ULActPayload_GrabRelease) == 0x000088, "Wrong size on ULActPayload_GrabRelease");
static_assert(offsetof(ULActPayload_GrabRelease, GrabResultInfo) == 0x000030, "Member 'ULActPayload_GrabRelease::GrabResultInfo' has a wrong offset!");
static_assert(offsetof(ULActPayload_GrabRelease, GrabReleaseInfo) == 0x000068, "Member 'ULActPayload_GrabRelease::GrabReleaseInfo' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_GuardCheck_Reflect
// 0x0090 (0x00D0 - 0x0040)
class ULAnimNotifyState_GuardCheck_Reflect final : public ULAnimNotifyStateBase
{
public:
	int32                                         GuardRangeAngleStart;                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitCollisionInfo                     HitInfo;                                           // 0x0048(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GuardCheck_Reflect">();
	}
	static class ULAnimNotifyState_GuardCheck_Reflect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GuardCheck_Reflect>();
	}
};
static_assert(alignof(ULAnimNotifyState_GuardCheck_Reflect) == 0x000008, "Wrong alignment on ULAnimNotifyState_GuardCheck_Reflect");
static_assert(sizeof(ULAnimNotifyState_GuardCheck_Reflect) == 0x0000D0, "Wrong size on ULAnimNotifyState_GuardCheck_Reflect");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Reflect, GuardRangeAngleStart) == 0x000040, "Member 'ULAnimNotifyState_GuardCheck_Reflect::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Reflect, GuardRangeAngleEnd) == 0x000044, "Member 'ULAnimNotifyState_GuardCheck_Reflect::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Reflect, HitInfo) == 0x000048, "Member 'ULAnimNotifyState_GuardCheck_Reflect::HitInfo' has a wrong offset!");

// Class ProjectP.LCalcStatFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULCalcStatFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ApplyMaxStatMultiplier(class AActor* TargetChar, ELSecondStat SecondStatType, float Muliplier);
	static float CalcConsumeFrenzyAmount(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, int32 FrenzyAmount);
	static float CalcConsumeGuardWeaponSharpness(class AActor* Victim);
	static int32 CalcConsumeWeaponSharpness_Attacker(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, class ULPartsComponent* HitPartsComp);
	static int32 CalcConsumeWeaponSharpness_Victim(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, class ULPartsComponent* HitPartsComp);
	static void CalcDamage(struct FLCalcDamageData& CalcDamageData, class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, const struct FHitResult& HitResult, class ULHitProcContext* HitProcContext);
	static void CalcElementalDamage(struct FLCalcDamageData& CalcDamageData, class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, const struct FHitResult& HitResult, class ULHitProcContext* HitProcContext);
	static float CalcEquipmentWeightRatio(class AActor* TargetActor);
	static float CalcEquipmentWeightRatioInGivenMaxWeight(class AActor* TargetActor, int32 InMaxWeight);
	static float CalcFallingDamage(class AActor* TargetActor);
	static float CalcFrenzyPoint_ForAttacker(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static float CalcFrenzyPoint_ForVictim(class AActor* Victim, const struct FLHitInfo& HitInfo, class ALWeapon* VictimWeapon, bool bPerfectGuard);
	static float CalcGroggy_ConsumablePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, float* OutGroggyAttackDamage, class ULPartsComponent* ReduceByPartsComp);
	static float CalcGroggy_MaintainTime(class AActor* TargetChar, const struct FLHitInfo& HitInfo);
	static float CalcGroggyEnableTimeAdd(class AActor* Attacker, class AActor* Victim, bool IsPerfectGuard, bool IsFuryAttack);
	static int32 CalcGuard_ConsumablePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static float CalcGuard_GuardHitDuration(class AActor* TargetActor, const struct FLHitInfo& HitInfo);
	static float CalcGuard_PenetrationPower(class AActor* TargetActor, class FName SkillHitCodeName);
	static bool CalcHitIntensity(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, float* OutHitIntensity);
	static float CalcParalyzation_ConsumablePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static float CalcParalyzation_MaintainTime(class AActor* TargetChar);
	static float CalcPulseRechargePoint(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static float CalcRigidity(class AActor* TargetActor, class ALWeapon* Weapon);
	static float CalcTough_DamageFinal(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, float* OutToughAttackDamage);
	static float CalcTough_DamagePrimary(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static float CalcTough_DamageSecondary(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static bool CheckVictimInCounterEnableBP(class AActor* Attacker, class AActor* Victim, EExecutePin* Branches);
	static float GetAttackRatio_by_Stat(class AActor* Attacker, const struct FLHitInfo& HitInfo, ELPhysicalDamageType PhysicalDamageType);
	static int32 GetCharacterElementalAttack(class AActor* Character, class FName SkillHitCodeName, ELElementDamageType ElementalDamageType);
	static int32 GetCharacterElementalDefence(class AActor* Character, ELElementDamageType ElementalDamageType);
	static int32 GetCharacterPhysicalAttack(class AActor* Character, const struct FLHitInfo& HitInfo, ELPhysicalDamageType PhysicalDamageType);
	static int32 GetCharacterPhysicalDefence(class AActor* Character, ELPhysicalDamageType PhysicalDamageType);
	static float GetDestructionPower(class AActor* Attacker, const struct FLHitInfo& HitInfo);
	static int32 GetDynamicDamageVolumeElementalAttack(class ALDynamicDamageVolumeActor* DynamicDamageVolume, ELElementDamageType ElementalType);
	static int32 GetDynamicDamageVolumePhysicalAttack(class ALDynamicDamageVolumeActor* DynamicDamageVolume);
	static int32 GetFirstStat(class UObject* WorldContextObject, ELFirstStatDataType DataType, ELFirstStat StatType, bool IsVirtual);
	static TArray<struct FLFirstStatData> GetFirstStatDataList(class UObject* WorldContextObject, bool IsVirtual);
	static int32 GetGuardPoint(class AActor* TargetActor);
	static int32 GetProjectileElementalAttack(class ALProjectile* Projectile, ELElementDamageType ElementalType);
	static int32 GetProjectilePhysicalAttack(class ALProjectile* Projectile);
	static int32 GetPulseRechargePointMax(int32 RechargeCount);
	static int32 GetSlaveArmElementalAttack(class AActor* Attacker, ELElementDamageType ElementalType);
	static int32 GetSlaveArmPhysicalAttack(class AActor* Attacker);
	static float GetSpecialBuffAttackMultiplier(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo);
	static class ULStatComponent* GetStatComponentBP(class AActor* TargetActor, EExecutePin* Branches);
	static int32 GetTotalDamage(struct FLCalcDamageData& CalcDamageData);
	static int32 GetWeaponSkillElementalAttack(class AActor* Character, class ALWeapon* AttackerWeapon, ELElementDamageType ElementalDamageType);
	static int32 GetWeaponSkillPhysicalAttack(class AActor* Character, class ALWeapon* AttackerWeapon, ELPhysicalDamageType PhysicalDamageType);
	static bool HasElementDamage(const struct FLCalcDamageData& CalcDamageData, ELElementDamageType ElementDamageType);
	static bool IsElementalAttack(class AActor* Attacker, const struct FLHitInfo& HitInfo, ELElementDamageType ElementalType);
	static bool IsElementalAttack_Impl(class AActor* Attacker, class FName SkillHitCodeName, class ALWeapon* AttackerWeapon, ELElementDamageType ElementalType);
	static ELPhysicalDamageType PickPhysicalDamagedType(class AActor* Attacker, const struct FLHitInfo& HitInfo);
	static void Test_ApplyCharacterStat(class AActor* Target, ELSecondStat StatType, int32 InputStat, bool ApplyMax, bool Broadcast);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCalcStatFuncLibrary">();
	}
	static class ULCalcStatFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCalcStatFuncLibrary>();
	}
};
static_assert(alignof(ULCalcStatFuncLibrary) == 0x000008, "Wrong alignment on ULCalcStatFuncLibrary");
static_assert(sizeof(ULCalcStatFuncLibrary) == 0x000028, "Wrong size on ULCalcStatFuncLibrary");

// Class ProjectP.LAnimNotifyState_CameraWork
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_CameraWork final : public ULAnimNotifyStateBase
{
public:
	class FName                                   CameraWorkName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DontStopWhenNotifyEnd;                             // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ALCameraWork*                           CameraWork;                                        // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_CameraWork">();
	}
	static class ULAnimNotifyState_CameraWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_CameraWork>();
	}
};
static_assert(alignof(ULAnimNotifyState_CameraWork) == 0x000008, "Wrong alignment on ULAnimNotifyState_CameraWork");
static_assert(sizeof(ULAnimNotifyState_CameraWork) == 0x000058, "Wrong size on ULAnimNotifyState_CameraWork");
static_assert(offsetof(ULAnimNotifyState_CameraWork, CameraWorkName) == 0x000040, "Member 'ULAnimNotifyState_CameraWork::CameraWorkName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CameraWork, DurationTime) == 0x000048, "Member 'ULAnimNotifyState_CameraWork::DurationTime' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CameraWork, DontStopWhenNotifyEnd) == 0x00004C, "Member 'ULAnimNotifyState_CameraWork::DontStopWhenNotifyEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CameraWork, CameraWork) == 0x000050, "Member 'ULAnimNotifyState_CameraWork::CameraWork' has a wrong offset!");

// Class ProjectP.LActPayload_Teleport
// 0x0010 (0x0040 - 0x0030)
class ULActPayload_Teleport final : public ULActPayloadBase
{
public:
	bool                                          ActionTeleportStart;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TeleportTarget;                                    // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActionTeleportEnd;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActionReconnect;                                   // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Teleport_by_Clock;                                 // 0x003E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_Teleport">();
	}
	static class ULActPayload_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_Teleport>();
	}
};
static_assert(alignof(ULActPayload_Teleport) == 0x000008, "Wrong alignment on ULActPayload_Teleport");
static_assert(sizeof(ULActPayload_Teleport) == 0x000040, "Wrong size on ULActPayload_Teleport");
static_assert(offsetof(ULActPayload_Teleport, ActionTeleportStart) == 0x000030, "Member 'ULActPayload_Teleport::ActionTeleportStart' has a wrong offset!");
static_assert(offsetof(ULActPayload_Teleport, TeleportTarget) == 0x000034, "Member 'ULActPayload_Teleport::TeleportTarget' has a wrong offset!");
static_assert(offsetof(ULActPayload_Teleport, ActionTeleportEnd) == 0x00003C, "Member 'ULActPayload_Teleport::ActionTeleportEnd' has a wrong offset!");
static_assert(offsetof(ULActPayload_Teleport, ActionReconnect) == 0x00003D, "Member 'ULActPayload_Teleport::ActionReconnect' has a wrong offset!");
static_assert(offsetof(ULActPayload_Teleport, Teleport_by_Clock) == 0x00003E, "Member 'ULActPayload_Teleport::Teleport_by_Clock' has a wrong offset!");

// Class ProjectP.LActPayload_Dialoging
// 0x0008 (0x0038 - 0x0030)
class ULActPayload_Dialoging final : public ULActPayloadBase
{
public:
	bool                                          CancelPrevMotion;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActPayload_Dialoging">();
	}
	static class ULActPayload_Dialoging* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActPayload_Dialoging>();
	}
};
static_assert(alignof(ULActPayload_Dialoging) == 0x000008, "Wrong alignment on ULActPayload_Dialoging");
static_assert(sizeof(ULActPayload_Dialoging) == 0x000038, "Wrong size on ULActPayload_Dialoging");
static_assert(offsetof(ULActPayload_Dialoging, CancelPrevMotion) == 0x000030, "Member 'ULActPayload_Dialoging::CancelPrevMotion' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayCharacterSD
// 0x0068 (0x00B0 - 0x0048)
class ULAnimNotify_PlayCharacterSD final : public ULAnimNotifyBase
{
public:
	class FName                                   EventName;                                         // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0060(0x0030)(BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0090(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeModifier;                                    // 0x0094(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCharacterSoundType                   TestCharacterSoundType;                            // 0x009C(0x0008)(Edit, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayCharacterSD">();
	}
	static class ULAnimNotify_PlayCharacterSD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayCharacterSD>();
	}
};
static_assert(alignof(ULAnimNotify_PlayCharacterSD) == 0x000010, "Wrong alignment on ULAnimNotify_PlayCharacterSD");
static_assert(sizeof(ULAnimNotify_PlayCharacterSD) == 0x0000B0, "Wrong size on ULAnimNotify_PlayCharacterSD");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, EventName) == 0x000048, "Member 'ULAnimNotify_PlayCharacterSD::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, SocketName) == 0x000050, "Member 'ULAnimNotify_PlayCharacterSD::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, Offset) == 0x000060, "Member 'ULAnimNotify_PlayCharacterSD::Offset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, bAttached) == 0x000090, "Member 'ULAnimNotify_PlayCharacterSD::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, VolumeModifier) == 0x000094, "Member 'ULAnimNotify_PlayCharacterSD::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, MeshSelectionType) == 0x000098, "Member 'ULAnimNotify_PlayCharacterSD::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayCharacterSD, TestCharacterSoundType) == 0x00009C, "Member 'ULAnimNotify_PlayCharacterSD::TestCharacterSoundType' has a wrong offset!");

// Class ProjectP.LCameraManager
// 0x0250 (0x2C00 - 0x29B0)
class ALCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_29B0[0xC8];                                    // 0x29B0(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLPlayerCameraData                     DefaultCameraData;                                 // 0x2A78(0x003C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLRotationAccordingToMovement          RotationAccordingToMovement;                       // 0x2AB4(0x0050)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B04[0x4];                                     // 0x2B04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCameraMovingPitch                    MovingPitch;                                       // 0x2B08(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnableImmediateControlRotation;                   // 0x2B30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B31[0x3];                                     // 0x2B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImmediateControlRotationSpeed;                     // 0x2B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               BodyLookAtCameraRotation;                          // 0x2B38(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B44[0x4];                                     // 0x2B44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULCameraWorkManager*                    WorkManager;                                       // 0x2B48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraRotationLagSpeed;                            // 0x2B50(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitToDefault;                                    // 0x2B54(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B55[0xAB];                                    // 0x2B55(0x00AB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestoryCameraWork(class ALCameraWork* CameraWork);
	void DisableShoulderView();
	void EnableMoveCameraUpDown(bool bEnable);
	void EnableShoulderView(const struct FVector& Offset, float BlendInTime, float BlendOutTime);
	struct FRotator GetBasicCameraRotation();
	class ALCameraWork* NewCameraWork(class FName CameraWorkName);
	void OnStopWorkFinish(class ALCameraWork* CameraWork);
	class ALCameraWork* PlayCameraWork(class FName CameraWorkName, class UObject* ObjectContext, const struct FTransform& TransformContext, float DurationTime);
	void RegisterCameraWork(class ALCameraWork* CameraWork);
	void ResetAllModifiers(class UObject* InInstigator);
	void ResetCameraDistanceModifier(class UObject* InInstigator);
	void ResetCameraLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID);
	void ResetCameraRotationLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID);
	void ResetLocationOffsetModifier(const struct FLCameraAttrModifierID& ModifierID);
	void SetCameraDistanceModifier(class UObject* InInstigator, float Distance, ELCameraModifierPriority Priority);
	void SetCameraLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID, float CameraLagSpeed, ELCameraModifierPriority Priority, const struct FLCameraAttrModifierBlendTime& BlendTime);
	void SetCameraRotationLagSpeedModifier(const struct FLCameraAttrModifierID& ModifierID, float CameraRotationLagSpeed_0, ELCameraModifierPriority Priority, const struct FLCameraAttrModifierBlendTime& BlendTime);
	void SetCharacterFastMovement(bool bFastMovement);
	void SetCineCamera(bool bAlignToCineCamera, bool bAlignToPlayerBack);
	void SetCinematicPlay(bool bPlaying);
	void SetControlRotation(const struct FRotator& Rotation);
	void SetControlRotationBack_Player();
	void SetControlRotationBack_PlayerInit();
	void SetControlRotationSmooth(const struct FRotator& Rotation);
	void SetDialogCamera(bool bEnable);
	void SetFollowingCamera(bool bFollowing);
	void SetLadderCamera(bool bLadderCamera);
	void SetLocationOffsetModifier(const struct FLCameraAttrModifierID& ModifierID, const struct FVector& LocationOffset, ELCameraModifierPriority Priority, const struct FLCameraAttrModifierBlendTime& BlendTime);
	void SetLockOnCamera();
	void SetMovingCamera();
	void SpawnCameraWorkByName(class FName CameraWorkName, class ALCameraWork** CameraWork);

	struct FRotator GetBodyLookAtCameraRotation() const;
	float GetCameraDistanceValue() const;
	const struct FLPlayerCameraData GetDefaultCameraData() const;
	class ALCameraWork* GetPlayingCameraWork() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCameraManager">();
	}
	static class ALCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALCameraManager>();
	}
};
static_assert(alignof(ALCameraManager) == 0x000010, "Wrong alignment on ALCameraManager");
static_assert(sizeof(ALCameraManager) == 0x002C00, "Wrong size on ALCameraManager");
static_assert(offsetof(ALCameraManager, DefaultCameraData) == 0x002A78, "Member 'ALCameraManager::DefaultCameraData' has a wrong offset!");
static_assert(offsetof(ALCameraManager, RotationAccordingToMovement) == 0x002AB4, "Member 'ALCameraManager::RotationAccordingToMovement' has a wrong offset!");
static_assert(offsetof(ALCameraManager, MovingPitch) == 0x002B08, "Member 'ALCameraManager::MovingPitch' has a wrong offset!");
static_assert(offsetof(ALCameraManager, bEnableImmediateControlRotation) == 0x002B30, "Member 'ALCameraManager::bEnableImmediateControlRotation' has a wrong offset!");
static_assert(offsetof(ALCameraManager, ImmediateControlRotationSpeed) == 0x002B34, "Member 'ALCameraManager::ImmediateControlRotationSpeed' has a wrong offset!");
static_assert(offsetof(ALCameraManager, BodyLookAtCameraRotation) == 0x002B38, "Member 'ALCameraManager::BodyLookAtCameraRotation' has a wrong offset!");
static_assert(offsetof(ALCameraManager, WorkManager) == 0x002B48, "Member 'ALCameraManager::WorkManager' has a wrong offset!");
static_assert(offsetof(ALCameraManager, CameraRotationLagSpeed) == 0x002B50, "Member 'ALCameraManager::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(ALCameraManager, bInitToDefault) == 0x002B54, "Member 'ALCameraManager::bInitToDefault' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_RunNotiEnd_Unbuff
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_RunNotiEnd_Unbuff final : public ULAnimNotifyStateBase
{
public:
	class FName                                   BuffCodeName;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_RunNotiEnd_Unbuff">();
	}
	static class ULAnimNotifyState_RunNotiEnd_Unbuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_RunNotiEnd_Unbuff>();
	}
};
static_assert(alignof(ULAnimNotifyState_RunNotiEnd_Unbuff) == 0x000008, "Wrong alignment on ULAnimNotifyState_RunNotiEnd_Unbuff");
static_assert(sizeof(ULAnimNotifyState_RunNotiEnd_Unbuff) == 0x000048, "Wrong size on ULAnimNotifyState_RunNotiEnd_Unbuff");
static_assert(offsetof(ULAnimNotifyState_RunNotiEnd_Unbuff, BuffCodeName) == 0x000040, "Member 'ULAnimNotifyState_RunNotiEnd_Unbuff::BuffCodeName' has a wrong offset!");

// Class ProjectP.LActionStopReason
// 0x0000 (0x0028 - 0x0028)
class ULActionStopReason final : public UObject
{
public:
	static class FName ActionStopReason_CancelDash();
	static class FName ActionStopReason_CancelMove();
	static class FName ActionStopReason_ChangeCostume();
	static class FName ActionStopReason_EscapeFromInfiniteGrabbing();
	static class FName ActionStopReason_Explode();
	static class FName ActionStopReason_GrabFailed();
	static class FName ActionStopReason_None();
	static class FName ActionStopReason_PayloadInvalid();
	static class FName ActionStopReason_PlayAnimFailed();
	static class FName ActionStopReason_PlayLevelSequenceBySpot();
	static class FName ActionStopReason_Sequencer();
	static class FName ActionStopReason_StaminaExhausted();
	static class FName ActionStopReason_Tutorial();
	static class FName ActionStopReason_UnexpectedBehaviour();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionStopReason">();
	}
	static class ULActionStopReason* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActionStopReason>();
	}
};
static_assert(alignof(ULActionStopReason) == 0x000008, "Wrong alignment on ULActionStopReason");
static_assert(sizeof(ULActionStopReason) == 0x000028, "Wrong size on ULActionStopReason");

// Class ProjectP.LCameraWork
// 0x0120 (0x0300 - 0x01E0)
class ALCameraWork : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnStopWorkFinish;                                  // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLViewTargetTransitionParams           BlendInTransitionParams;                           // 0x01F0(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLViewTargetTransitionParams           BlendOutTransitionParams;                          // 0x01FC(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CustomTransform;                                   // 0x0210(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOnBlend;                                       // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOnFullyBlend;                                  // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendAlpha;                                        // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCameraWorkBlendState                        BlendState;                                        // 0x0254(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCameraWorkViewInfo                   BlendChangeViewInfo;                               // 0x0258(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLCameraWorkViewInfo                   RecentlyViewInfo;                                  // 0x0274(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLCameraWorkViewInfo                   ResultViewInfo;                                    // 0x0290(0x001C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULCameraWorkManager*                    WorkManager;                                       // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALCameraManager*                        CameraOwner;                                       // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWorking;                                     // 0x02C0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 ObjectContext;                                     // 0x02C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformContext;                                  // 0x02D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	void Delegate_OnStopWorkFinish__DelegateSignature(class ALCameraWork* CameraWork);
	void OnChangeBlend(ELCameraWorkBlendState CameraWorkBlendState);
	void OnPreWork(bool* bCanStartWorking);
	void OnStartWork();
	void OnStopWork();
	void ResetWork(class APlayerCameraManager* Manager, class ULCameraWorkManager* WorkManager_0);
	void SetPostProcess(float PostProcessBlendWeight, const struct FPostProcessSettings& PostProcessSettings);
	void SetViewInfo(const struct FLCameraWorkViewInfo& ViewInfo);
	bool StartWork(float DurationTime_0);
	void StopWork();
	void StopWorkFinish();
	void UpdatePostProcess(float DeltaTime);
	void UpdateTargetView(float DeltaTime);
	void UpdateTargetViewBlendIn(float DeltaTime);
	void UpdateTargetViewBlendInFully(float DeltaTime);
	void UpdateTargetViewBlendOut(float DeltaTime);

	float GetElapsedAlpha(float Multiflier) const;
	bool HasDurationTime() const;
	bool IsWorking() const;
	void UpdateElapsedAlphaForBlend(float* LastElapsedAlaph, float* ResultAlpha, float MultiflierIn) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCameraWork">();
	}
	static class ALCameraWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALCameraWork>();
	}
};
static_assert(alignof(ALCameraWork) == 0x000010, "Wrong alignment on ALCameraWork");
static_assert(sizeof(ALCameraWork) == 0x000300, "Wrong size on ALCameraWork");
static_assert(offsetof(ALCameraWork, OnStopWorkFinish) == 0x0001E0, "Member 'ALCameraWork::OnStopWorkFinish' has a wrong offset!");
static_assert(offsetof(ALCameraWork, BlendInTransitionParams) == 0x0001F0, "Member 'ALCameraWork::BlendInTransitionParams' has a wrong offset!");
static_assert(offsetof(ALCameraWork, BlendOutTransitionParams) == 0x0001FC, "Member 'ALCameraWork::BlendOutTransitionParams' has a wrong offset!");
static_assert(offsetof(ALCameraWork, CustomTransform) == 0x000210, "Member 'ALCameraWork::CustomTransform' has a wrong offset!");
static_assert(offsetof(ALCameraWork, DurationTime) == 0x000240, "Member 'ALCameraWork::DurationTime' has a wrong offset!");
static_assert(offsetof(ALCameraWork, ElapsedTime) == 0x000244, "Member 'ALCameraWork::ElapsedTime' has a wrong offset!");
static_assert(offsetof(ALCameraWork, TimeOnBlend) == 0x000248, "Member 'ALCameraWork::TimeOnBlend' has a wrong offset!");
static_assert(offsetof(ALCameraWork, TimeOnFullyBlend) == 0x00024C, "Member 'ALCameraWork::TimeOnFullyBlend' has a wrong offset!");
static_assert(offsetof(ALCameraWork, BlendAlpha) == 0x000250, "Member 'ALCameraWork::BlendAlpha' has a wrong offset!");
static_assert(offsetof(ALCameraWork, BlendState) == 0x000254, "Member 'ALCameraWork::BlendState' has a wrong offset!");
static_assert(offsetof(ALCameraWork, BlendChangeViewInfo) == 0x000258, "Member 'ALCameraWork::BlendChangeViewInfo' has a wrong offset!");
static_assert(offsetof(ALCameraWork, RecentlyViewInfo) == 0x000274, "Member 'ALCameraWork::RecentlyViewInfo' has a wrong offset!");
static_assert(offsetof(ALCameraWork, ResultViewInfo) == 0x000290, "Member 'ALCameraWork::ResultViewInfo' has a wrong offset!");
static_assert(offsetof(ALCameraWork, WorkManager) == 0x0002B0, "Member 'ALCameraWork::WorkManager' has a wrong offset!");
static_assert(offsetof(ALCameraWork, CameraOwner) == 0x0002B8, "Member 'ALCameraWork::CameraOwner' has a wrong offset!");
static_assert(offsetof(ALCameraWork, bStartWorking) == 0x0002C0, "Member 'ALCameraWork::bStartWorking' has a wrong offset!");
static_assert(offsetof(ALCameraWork, ObjectContext) == 0x0002C4, "Member 'ALCameraWork::ObjectContext' has a wrong offset!");
static_assert(offsetof(ALCameraWork, TransformContext) == 0x0002D0, "Member 'ALCameraWork::TransformContext' has a wrong offset!");

// Class ProjectP.LActBase
// 0x0128 (0x0150 - 0x0028)
class ULActBase : public UObject
{
public:
	uint8                                         Pad_28[0x9];                                       // 0x0028(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Reusable;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Tickable;                                          // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PlayingActor;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActMgrComponent*                      ActMgr;                                            // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLActionInfo                           Info;                                              // 0x0048(0x0060)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActPayloadBase*                       Payload;                                           // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x90];                                      // 0x00C0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddActionState(class FName ActionState);
	void AddInitActionState(class FName ActionState);
	void ChangeActionImmuneState(bool Enable);
	bool OnPreProcessAction();
	void OnReset();
	void OnStart();
	void OnStop(class ULActBase* ReasonAction, class FName Reason);
	void OnStopByMe(class ULActBase* StoppingAction);
	void OnTick(float DeltaTime);
	bool ProcessValidLandingSpot(const struct FVector& CapsuleLocation, const struct FHitResult& Hit, bool IsValidLandingSpot);
	void RemoveActionState(class FName ActionState);
	void RemoveInitActionState(class FName ActionState);
	bool Reset();
	bool SetActPayload(class ULActPayloadBase* InActPayload);
	bool SetTickable(bool InTickable);
	bool Start();
	bool Stop(class ULActBase* ReasonAction, class FName Reason);

	float GetActionTime_End() const;
	float GetActionTime_Start() const;
	class ULActPayloadBase* GetActPayload() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActBase">();
	}
	static class ULActBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActBase>();
	}
};
static_assert(alignof(ULActBase) == 0x000008, "Wrong alignment on ULActBase");
static_assert(sizeof(ULActBase) == 0x000150, "Wrong size on ULActBase");
static_assert(offsetof(ULActBase, Reusable) == 0x000031, "Member 'ULActBase::Reusable' has a wrong offset!");
static_assert(offsetof(ULActBase, Tickable) == 0x000032, "Member 'ULActBase::Tickable' has a wrong offset!");
static_assert(offsetof(ULActBase, PlayingActor) == 0x000038, "Member 'ULActBase::PlayingActor' has a wrong offset!");
static_assert(offsetof(ULActBase, ActMgr) == 0x000040, "Member 'ULActBase::ActMgr' has a wrong offset!");
static_assert(offsetof(ULActBase, Info) == 0x000048, "Member 'ULActBase::Info' has a wrong offset!");
static_assert(offsetof(ULActBase, Payload) == 0x0000B8, "Member 'ULActBase::Payload' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyInput_Parrying
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_Parrying final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_Parrying">();
	}
	static class ULAnimNotifyState_ApplyInput_Parrying* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_Parrying>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_Parrying) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_Parrying");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_Parrying) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_Parrying");

// Class ProjectP.LCameraWorkManager
// 0x0010 (0x0038 - 0x0028)
class ULCameraWorkManager final : public UObject
{
public:
	class ALCameraWork*                           CameraWorkPrevious;                                // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALCameraWork*                           CameraWorkCurrent;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCameraWorkManager">();
	}
	static class ULCameraWorkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCameraWorkManager>();
	}
};
static_assert(alignof(ULCameraWorkManager) == 0x000008, "Wrong alignment on ULCameraWorkManager");
static_assert(sizeof(ULCameraWorkManager) == 0x000038, "Wrong size on ULCameraWorkManager");
static_assert(offsetof(ULCameraWorkManager, CameraWorkPrevious) == 0x000028, "Member 'ULCameraWorkManager::CameraWorkPrevious' has a wrong offset!");
static_assert(offsetof(ULCameraWorkManager, CameraWorkCurrent) == 0x000030, "Member 'ULCameraWorkManager::CameraWorkCurrent' has a wrong offset!");

// Class ProjectP.LAnimNotify_ApplyActionState
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotify_ApplyActionState final : public ULAnimNotifyStateBase
{
public:
	TArray<class FName>                           ActionStateArray;                                  // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_ApplyActionState">();
	}
	static class ULAnimNotify_ApplyActionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_ApplyActionState>();
	}
};
static_assert(alignof(ULAnimNotify_ApplyActionState) == 0x000008, "Wrong alignment on ULAnimNotify_ApplyActionState");
static_assert(sizeof(ULAnimNotify_ApplyActionState) == 0x000050, "Wrong size on ULAnimNotify_ApplyActionState");
static_assert(offsetof(ULAnimNotify_ApplyActionState, ActionStateArray) == 0x000040, "Member 'ULAnimNotify_ApplyActionState::ActionStateArray' has a wrong offset!");

// Class ProjectP.LAction_SingleAnim
// 0x00E0 (0x0230 - 0x0150)
class ULAction_SingleAnim : public ULActBase
{
public:
	class UAnimSequenceBase*                      TargetAnim;                                        // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StopAllPreviousMontages : 1;                       // 0x0164(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         StopAnimOnShutdown : 1;                            // 0x0164(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrMontageInstanceID;                             // 0x0168(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             PlayingChar;                                       // 0x0170(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAbsoluteRootMotionContext            AbsoluteRootMotionContext;                         // 0x0178(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     StartRotationModifierHandle;                       // 0x01D8(0x0004)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLConditionalAnimBranchContext> Cached_ConditionalAnimBranchArray;                 // 0x01E0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x40];                                     // 0x01F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BindOnCurrMontageBlendOutStarted(int32 MontageInstanceID);
	bool BindOnCurrMontageEnded(int32 MontageInstanceID);
	void ConditionalAnimBranch(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSoftObjectPtr<class UAnimMontage> Montage, ELConditionalAnimBranch* OutBranchResult, class UObject** OutInstigator);
	void ConditionalAnimBranch_WithMontageInstanceID(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 MontageInstanceID, ELConditionalAnimBranch* OutBranchResult, class UObject** OutInstigator);
	class UAnimInstance* GetAnimInst();
	class UAnimInstance* GetAnimInstBP(EExecutePin* Branches);
	class UAnimMontage* GetCurrMontage();
	int32 GetCurrMontageInstanceID(class UAnimInstance** AnimInstance, EExecutePin* Branches);
	class ACharacter* GetPlayingCharacter();
	void InitSingleAnim(bool LoadPayload);
	void MakeAbsoluteRootMotionContextBP(class UAnimMontage* AnimMontage, const struct FTransform& StartTransform, const struct FTransform& EndTransform, float StartBlendTime, float EndBlendTime, float SetManualFinishTime, bool FixStartRotation, ELAbsoluteRootMotionModeType AbsoluteRootMotionModeType, EExecutePin* Branches);
	void OnAbsoluteRootMotionFinished(class UAnimMontage* Montage, bool bInterrupted, int32 MontageInstanceID);
	void OnCurrMontageBlendOutStarted(class UAnimMontage* Montage, bool bInterrupted, int32 MontageInstanceID);
	void OnCurrMontageEnded(class UAnimMontage* Montage, bool bInterrupted, int32 MontageInstanceID);
	bool OnLanded(class ACharacter* LandingChar, const struct FHitResult& Hit);
	bool OnMoveBlockedBy(class ACharacter* BlockedChar, const struct FHitResult& Hit);
	void OverwriteAbsoluteRootMotionContext_StopRemainTimeCompensateMargin(float InStopRemainTimeCompensateMargin);
	void PlayCommomAnimBP(class FName CommomAnim, int32* MontageInstanceID, class UAnimMontage** Montage, EExecutePin* Branches);
	int32 PlayTargetAnim(bool UseAbsoluteRootMotion);
	int32 PlayTargetAnimBP(bool UseAbsoluteRootMotion, EExecutePin* Branches);
	int32 PlayTargetAnimExBP(bool UseAbsoluteRootMotion, float OverrideMontageBlendIn, bool ForceOverride, EExecutePin* Branches);
	void RefreshStartRotation();
	void SetAbsoluteRootMotionContext(const struct FLAbsoluteRootMotionContext& InAbsoluteRootMotionContext);
	void StartActionRotation(bool NeedRotator);
	bool StopTargetAnim();
	void UnBindOnCurrMontageEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAction_SingleAnim">();
	}
	static class ULAction_SingleAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAction_SingleAnim>();
	}
};
static_assert(alignof(ULAction_SingleAnim) == 0x000008, "Wrong alignment on ULAction_SingleAnim");
static_assert(sizeof(ULAction_SingleAnim) == 0x000230, "Wrong size on ULAction_SingleAnim");
static_assert(offsetof(ULAction_SingleAnim, TargetAnim) == 0x000150, "Member 'ULAction_SingleAnim::TargetAnim' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, SlotNodeName) == 0x000158, "Member 'ULAction_SingleAnim::SlotNodeName' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, BlendOutTime) == 0x000160, "Member 'ULAction_SingleAnim::BlendOutTime' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, CurrMontageInstanceID) == 0x000168, "Member 'ULAction_SingleAnim::CurrMontageInstanceID' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, PlayingChar) == 0x000170, "Member 'ULAction_SingleAnim::PlayingChar' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, AbsoluteRootMotionContext) == 0x000178, "Member 'ULAction_SingleAnim::AbsoluteRootMotionContext' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, StartRotationModifierHandle) == 0x0001D8, "Member 'ULAction_SingleAnim::StartRotationModifierHandle' has a wrong offset!");
static_assert(offsetof(ULAction_SingleAnim, Cached_ConditionalAnimBranchArray) == 0x0001E0, "Member 'ULAction_SingleAnim::Cached_ConditionalAnimBranchArray' has a wrong offset!");

// Class ProjectP.LAction_LoopAnim
// 0x0028 (0x0258 - 0x0230)
class ULAction_LoopAnim : public ULAction_SingleAnim
{
public:
	class FName                                   LoopCancelByLanding;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopCancelByCommand;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSection;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelLoopAnim(class FName JumpToSectionName);
	void Init_LoopAnim(bool LoadPayload);
	bool IsLoopAnim();
	void NextLoopAnim(class FName JumpToSectionName);
	void OnCommandOccurred(class ULActMgrComponent* ActMgrComponent, class AActor* TargetActor, class FName Command, const struct FVector& Lever, bool SkipCommandPrerequisitiesCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAction_LoopAnim">();
	}
	static class ULAction_LoopAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAction_LoopAnim>();
	}
};
static_assert(alignof(ULAction_LoopAnim) == 0x000008, "Wrong alignment on ULAction_LoopAnim");
static_assert(sizeof(ULAction_LoopAnim) == 0x000258, "Wrong size on ULAction_LoopAnim");
static_assert(offsetof(ULAction_LoopAnim, LoopCancelByLanding) == 0x000230, "Member 'ULAction_LoopAnim::LoopCancelByLanding' has a wrong offset!");
static_assert(offsetof(ULAction_LoopAnim, LoopCancelByCommand) == 0x000238, "Member 'ULAction_LoopAnim::LoopCancelByCommand' has a wrong offset!");
static_assert(offsetof(ULAction_LoopAnim, StartSection) == 0x000240, "Member 'ULAction_LoopAnim::StartSection' has a wrong offset!");

// Class ProjectP.LAnimNotify_TestNotify
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_TestNotify final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_TestNotify">();
	}
	static class ULAnimNotify_TestNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_TestNotify>();
	}
};
static_assert(alignof(ULAnimNotify_TestNotify) == 0x000008, "Wrong alignment on ULAnimNotify_TestNotify");
static_assert(sizeof(ULAnimNotify_TestNotify) == 0x000048, "Wrong size on ULAnimNotify_TestNotify");

// Class ProjectP.LAction_HitAnim
// 0x01A8 (0x0400 - 0x0258)
class ULAction_HitAnim : public ULAction_LoopAnim
{
public:
	class ULActPayload_HitAnim*                   Cached_Payload_HitAnim;                            // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkillHitInfoPtr                       Cached_SkillHitInfoPtr;                            // 0x0260(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSkillHitInfoPtr                       Cached_SkillHitInfoPtr_Origin;                     // 0x0268(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Cached_Attacker;                                   // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              Cached_HitInfo;                                    // 0x0278(0x0150)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Cached_SkillHit_Replaced;                          // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionType                               Cached_HitMotionType;                              // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionType                               Cached_HitMotionType_Original;                     // 0x03D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D2[0x2];                                      // 0x03D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cached_HitAnimDuration;                            // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELKnockBackDirectionType                      Cached_KnockbackDirection;                         // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cached_KnockbackDuration;                          // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cached_KnockbackScale;                             // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cached_KnockbackDistance;                          // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cached_BoundHeight;                                // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cached_BoundDuration;                              // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_HitCameraShakeCodeName;                     // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_LastPlayedHitAnim;                          // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 PlayHitAnim(class FName HitAnim);
	void PlayHitAnimBP(class FName HitAnim, int32* MontageInstanceID, class UAnimMontage** Montage, EExecutePin* Branches);
	void SetLastPlayedHitAnim(class FName HitAnim);
	bool UpdateHitMotionReplace(ELHitMotionType OriginHitMotionType);
	bool UpdateSkillHitReplace(class FName NewSkillHitCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAction_HitAnim">();
	}
	static class ULAction_HitAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAction_HitAnim>();
	}
};
static_assert(alignof(ULAction_HitAnim) == 0x000008, "Wrong alignment on ULAction_HitAnim");
static_assert(sizeof(ULAction_HitAnim) == 0x000400, "Wrong size on ULAction_HitAnim");
static_assert(offsetof(ULAction_HitAnim, Cached_Payload_HitAnim) == 0x000258, "Member 'ULAction_HitAnim::Cached_Payload_HitAnim' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_SkillHitInfoPtr) == 0x000260, "Member 'ULAction_HitAnim::Cached_SkillHitInfoPtr' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_SkillHitInfoPtr_Origin) == 0x000268, "Member 'ULAction_HitAnim::Cached_SkillHitInfoPtr_Origin' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_Attacker) == 0x000270, "Member 'ULAction_HitAnim::Cached_Attacker' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_HitInfo) == 0x000278, "Member 'ULAction_HitAnim::Cached_HitInfo' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_SkillHit_Replaced) == 0x0003C8, "Member 'ULAction_HitAnim::Cached_SkillHit_Replaced' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_HitMotionType) == 0x0003D0, "Member 'ULAction_HitAnim::Cached_HitMotionType' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_HitMotionType_Original) == 0x0003D1, "Member 'ULAction_HitAnim::Cached_HitMotionType_Original' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_HitAnimDuration) == 0x0003D4, "Member 'ULAction_HitAnim::Cached_HitAnimDuration' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_KnockbackDirection) == 0x0003D8, "Member 'ULAction_HitAnim::Cached_KnockbackDirection' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_KnockbackDuration) == 0x0003DC, "Member 'ULAction_HitAnim::Cached_KnockbackDuration' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_KnockbackScale) == 0x0003E0, "Member 'ULAction_HitAnim::Cached_KnockbackScale' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_KnockbackDistance) == 0x0003E4, "Member 'ULAction_HitAnim::Cached_KnockbackDistance' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_BoundHeight) == 0x0003E8, "Member 'ULAction_HitAnim::Cached_BoundHeight' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_BoundDuration) == 0x0003EC, "Member 'ULAction_HitAnim::Cached_BoundDuration' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_HitCameraShakeCodeName) == 0x0003F0, "Member 'ULAction_HitAnim::Cached_HitCameraShakeCodeName' has a wrong offset!");
static_assert(offsetof(ULAction_HitAnim, Cached_LastPlayedHitAnim) == 0x0003F8, "Member 'ULAction_HitAnim::Cached_LastPlayedHitAnim' has a wrong offset!");

// Class ProjectP.LAction_MultiAnim
// 0x0018 (0x0270 - 0x0258)
class ULAction_MultiAnim : public ULAction_LoopAnim
{
public:
	TArray<class UAnimSequenceBase*>              TargetAnimArray;                                   // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrChosenAnimIndex;                               // 0x0268(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNewAnimPlayed();
	int32 OnSelectNextAnim(class UAnimMontage* Montage, bool bInterrupted, int32 CurrentAnimIndex);
	int32 PlayTargetAnimByIndexBP(int32 TargetAnimIndex, EExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAction_MultiAnim">();
	}
	static class ULAction_MultiAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAction_MultiAnim>();
	}
};
static_assert(alignof(ULAction_MultiAnim) == 0x000008, "Wrong alignment on ULAction_MultiAnim");
static_assert(sizeof(ULAction_MultiAnim) == 0x000270, "Wrong size on ULAction_MultiAnim");
static_assert(offsetof(ULAction_MultiAnim, TargetAnimArray) == 0x000258, "Member 'ULAction_MultiAnim::TargetAnimArray' has a wrong offset!");
static_assert(offsetof(ULAction_MultiAnim, CurrChosenAnimIndex) == 0x000268, "Member 'ULAction_MultiAnim::CurrChosenAnimIndex' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_UseSmashLookAt
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_UseSmashLookAt final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_UseSmashLookAt">();
	}
	static class ULAnimNotifyState_UseSmashLookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_UseSmashLookAt>();
	}
};
static_assert(alignof(ULAnimNotifyState_UseSmashLookAt) == 0x000008, "Wrong alignment on ULAnimNotifyState_UseSmashLookAt");
static_assert(sizeof(ULAnimNotifyState_UseSmashLookAt) == 0x000040, "Wrong size on ULAnimNotifyState_UseSmashLookAt");

// Class ProjectP.LAction_SlaveArmVisual
// 0x0000 (0x0258 - 0x0258)
class ULAction_SlaveArmVisual : public ULAction_LoopAnim
{
public:
	float GetSlaveArmAdditiveAlpha();
	class UAnimSequenceBase* GetSlaveArmAdditiveAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAction_SlaveArmVisual">();
	}
	static class ULAction_SlaveArmVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAction_SlaveArmVisual>();
	}
};
static_assert(alignof(ULAction_SlaveArmVisual) == 0x000008, "Wrong alignment on ULAction_SlaveArmVisual");
static_assert(sizeof(ULAction_SlaveArmVisual) == 0x000258, "Wrong size on ULAction_SlaveArmVisual");

// Class ProjectP.LAction_Dialoging
// 0x0010 (0x0268 - 0x0258)
class ULAction_Dialoging : public ULAction_LoopAnim
{
public:
	class FName                                   CommonActionCodeName;                              // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Finished;                                          // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel_StopAfterToWait();
	bool IsPlayingMainAnim();
	bool IsPlayingRotateAnim();
	void StopAfterToWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAction_Dialoging">();
	}
	static class ULAction_Dialoging* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAction_Dialoging>();
	}
};
static_assert(alignof(ULAction_Dialoging) == 0x000008, "Wrong alignment on ULAction_Dialoging");
static_assert(sizeof(ULAction_Dialoging) == 0x000268, "Wrong size on ULAction_Dialoging");
static_assert(offsetof(ULAction_Dialoging, CommonActionCodeName) == 0x000258, "Member 'ULAction_Dialoging::CommonActionCodeName' has a wrong offset!");
static_assert(offsetof(ULAction_Dialoging, Finished) == 0x000260, "Member 'ULAction_Dialoging::Finished' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_GroundWalking
// 0x0020 (0x0060 - 0x0040)
class ULAnimNotifyState_GroundWalking final : public ULAnimNotifyStateBase
{
public:
	class UCurveVector*                           MoveCurve;                                         // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0048(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFixedDir;                                       // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0xB];                                       // 0x0055(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GroundWalking">();
	}
	static class ULAnimNotifyState_GroundWalking* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GroundWalking>();
	}
};
static_assert(alignof(ULAnimNotifyState_GroundWalking) == 0x000008, "Wrong alignment on ULAnimNotifyState_GroundWalking");
static_assert(sizeof(ULAnimNotifyState_GroundWalking) == 0x000060, "Wrong size on ULAnimNotifyState_GroundWalking");
static_assert(offsetof(ULAnimNotifyState_GroundWalking, MoveCurve) == 0x000040, "Member 'ULAnimNotifyState_GroundWalking::MoveCurve' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GroundWalking, Movement) == 0x000048, "Member 'ULAnimNotifyState_GroundWalking::Movement' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GroundWalking, UseFixedDir) == 0x000054, "Member 'ULAnimNotifyState_GroundWalking::UseFixedDir' has a wrong offset!");

// Class ProjectP.LActionStateDebugInfo
// 0x0000 (0x0028 - 0x0028)
class ULActionStateDebugInfo final : public UObject
{
public:
	static class FString ActionStateDebugInfo_From_Action();
	static class FString ActionStateDebugInfo_From_Notify();
	static class FString ActionStateDebugInfo_From_Notify_ApplyInput();
	static class FString ActionStateDebugInfo_From_NotifyEndMarked();
	static class FString ActionStateDebugInfo_None();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionStateDebugInfo">();
	}
	static class ULActionStateDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActionStateDebugInfo>();
	}
};
static_assert(alignof(ULActionStateDebugInfo) == 0x000008, "Wrong alignment on ULActionStateDebugInfo");
static_assert(sizeof(ULActionStateDebugInfo) == 0x000028, "Wrong size on ULActionStateDebugInfo");

// Class ProjectP.LActionState
// 0x0000 (0x0028 - 0x0028)
class ULActionState final : public UObject
{
public:
	static class FName ActionState_Aggro_Target();
	static class FName ActionState_AIState_Force_Return_CHK();
	static class FName ActionState_AITargetList_Disable();
	static class FName ActionState_AITargetList_DisableInDialog();
	static class FName ActionState_Allow_AcquireGroggyPoint();
	static class FName ActionState_Allow_ChargeCancel();
	static class FName ActionState_Allow_Dash_Heavy();
	static class FName ActionState_Allow_Dash_Light();
	static class FName ActionState_Allow_Dying();
	static class FName ActionState_Allow_FableCancel();
	static class FName ActionState_Allow_GuardRepulse();
	static class FName ActionState_Allow_LieDying();
	static class FName ActionState_Allow_RepairCancel();
	static class FName ActionState_AllowAction_Sequence();
	static class FName ActionState_AllowInput_Dash();
	static class FName ActionState_AllowInput_DoubleDash();
	static class FName ActionState_AllowInput_FableHandle();
	static class FName ActionState_AllowInput_Frenzy();
	static class FName ActionState_AllowInput_GetUpDash();
	static class FName ActionState_AllowInput_Guard();
	static class FName ActionState_AllowInput_LightAttack();
	static class FName ActionState_AllowInput_Movement();
	static class FName ActionState_AllowInput_Movement_Forced();
	static class FName ActionState_AllowInput_Parrying();
	static class FName ActionState_AllowInput_Rotation();
	static class FName ActionState_AllowInput_Rotation_Forced();
	static class FName ActionState_AllowInput_SlaveArm();
	static class FName ActionState_AllowInput_StrongAttack();
	static class FName ActionState_AllowInput_UseItem();
	static class FName ActionState_AllowInput_WeaponChange();
	static class FName ActionState_ApplyInput();
	static class FName ActionState_BladeWeight();
	static class FName ActionState_Can_Dodge_Zero_Stamina();
	static class FName ActionState_CancelMove();
	static class FName ActionState_Cinematic();
	static class FName ActionState_ClimbDown();
	static class FName ActionState_ClimbUp();
	static class FName ActionState_ConsumeMovement();
	static class FName ActionState_ConsumeRotation();
	static class FName ActionState_Dash_Disable();
	static class FName ActionState_Dash_SuperHeavy();
	static class FName ActionState_Dead();
	static class FName ActionState_DeadInvincible_DeadCharacter();
	static class FName ActionState_DeadInvincible_WorldCommand();
	static class FName ActionState_DepenetrateFromEnv();
	static class FName ActionState_DestructionDefence();
	static class FName ActionState_Dialoging();
	static class FName ActionState_Disable_Footstep();
	static class FName ActionState_Disable_LockOnRotation();
	static class FName ActionState_Disable_Send_HelpSignal();
	static class FName ActionState_Disable_TransformModifier_MoveActor();
	static class FName ActionState_Dodge();
	static class FName ActionState_DoubleDash_Enable();
	static class FName ActionState_Dying();
	static class FName ActionState_ExitReposition_Disable();
	static class FName ActionState_Fable_Buff_Blade();
	static class FName ActionState_Fable_Buff_Handle();
	static class FName ActionState_FableArt();
	static class FName ActionState_Falling();
	static class FName ActionState_FallingFromDownDrag_B();
	static class FName ActionState_FallingFromDownDrag_F();
	static class FName ActionState_FallingStart();
	static class FName ActionState_FatalAttack_As_Attacker();
	static class FName ActionState_FatalAttack_As_Victim();
	static class FName ActionState_FatalAttack_Counter_Enable();
	static class FName ActionState_FatalAttack_Disable();
	static class FName ActionState_FatalAttack_Enable();
	static class FName ActionState_FatalAttack_Enable_Forced();
	static class FName ActionState_Floating();
	static class FName ActionState_FloatingCeiling();
	static class FName ActionState_FloatingHit_Enable();
	static class FName ActionState_Frenzy();
	static class FName ActionState_FuryAttack();
	static class FName ActionState_FuryAttackGuardEnable();
	static class FName ActionState_GetUpDash_Disable();
	static class FName ActionState_GetUpDash_Enable();
	static class FName ActionState_Grab();
	static class FName ActionState_Grabbed();
	static class FName ActionState_GrappleGun_Reflect();
	static class FName ActionState_Groggy();
	static class FName ActionState_Groggy_Enable();
	static class FName ActionState_Groggy_Enable_Time_Added();
	static class FName ActionState_Guard_Hit();
	static class FName ActionState_GuardEx_CoolTime();
	static class FName ActionState_HeadCostumeOff_Sequence();
	static class FName ActionState_Heal_Guard_Regain_Maintain();
	static class FName ActionState_Hide();
	static class FName ActionState_HitBoom();
	static class FName ActionState_HitBoom_CoolTime();
	static class FName ActionState_HitCheck();
	static class FName ActionState_Ignore_Damage();
	static class FName ActionState_Ignore_Drop_Ergo();
	static class FName ActionState_Ignore_FallingLateralFriction();
	static class FName ActionState_Ignore_Invincible_OnDamagedByAbnormal();
	static class FName ActionState_Ignore_LeverSpeed_ABP();
	static class FName ActionState_Ignore_Repulse_All();
	static class FName ActionState_IK_Disable();
	static class FName ActionState_Immune_Damage();
	static class FName ActionState_Immune_Elemental();
	static class FName ActionState_Immune_Groggy();
	static class FName ActionState_Immune_Hit();
	static class FName ActionState_Immune_HitActionDMGStand();
	static class FName ActionState_Immune_HitActionDownAwayUp();
	static class FName ActionState_Immune_HitActionDownDragStamp();
	static class FName ActionState_Immune_HitActionGrab();
	static class FName ActionState_Immune_HitActionKnockBack();
	static class FName ActionState_Immune_Immune_Abnormal_Fire_Point();
	static class FName ActionState_Immune_Paralyzation();
	static class FName ActionState_Immune_Special_Elemental();
	static class FName ActionState_Immune_Tough();
	static class FName ActionState_Invincible();
	static class FName ActionState_Key_Pressed_Guard();
	static class FName ActionState_Key_Pressed_Sprint();
	static class FName ActionState_LockCameraMovement();
	static class FName ActionState_LockCancelMove();
	static class FName ActionState_LockDieAction();
	static class FName ActionState_LockFalling();
	static class FName ActionState_LockInput_Movement_Forced();
	static class FName ActionState_LockInput_Rotation_Forced();
	static class FName ActionState_LockMovement();
	static class FName ActionState_LockOn_Disable();
	static class FName ActionState_LockOn_DisablePC();
	static class FName ActionState_LockOnRotateTarget();
	static class FName ActionState_LockParry_Dash();
	static class FName ActionState_LockParry_Guard();
	static class FName ActionState_LockPerfectGuard();
	static class FName ActionState_LockPlayerAction_Movie();
	static class FName ActionState_LockPlayerAction_Sequence();
	static class FName ActionState_LockPlayerAction_Sequence_CameraEnable();
	static class FName ActionState_LockProcessCommand();
	static class FName ActionState_LockRotation();
	static class FName ActionState_LockUseSkill();
	static class FName ActionState_LockUseSkill_ExceptItem();
	static class FName ActionState_LockUseSkill_ExceptItem_SkipTest();
	static class FName ActionState_LookAt_AimToTarget();
	static class FName ActionState_LookAt_Disable();
	static class FName ActionState_LookAt_FixAimToTarget();
	static class FName ActionState_LookAt_Head();
	static class FName ActionState_LookAt_Head_Disable();
	static class FName ActionState_LookAt_Smash();
	static class FName ActionState_LookAt_UpperBody();
	static class FName ActionState_None();
	static class FName ActionState_NotifyApplyInput_Dash();
	static class FName ActionState_NotifyApplyInput_Guard();
	static class FName ActionState_NotifyApplyInput_LightAttack();
	static class FName ActionState_NotifyApplyInput_StrongAttack();
	static class FName ActionState_OnGuardHit_Attacker();
	static class FName ActionState_OnGuardHit_Victim();
	static class FName ActionState_OutOfBossRoom();
	static class FName ActionState_Paralyzation();
	static class FName ActionState_Paralyzation_Enable();
	static class FName ActionState_Peace();
	static class FName ActionState_PerBodyCollisionProfileApplied();
	static class FName ActionState_Perception_Disable();
	static class FName ActionState_Perfect_Guard_Tough_Damage_Enable();
	static class FName ActionState_PhysicsSimulation();
	static class FName ActionState_Prepare_Spawn();
	static class FName ActionState_PreventFallingDamage();
	static class FName ActionState_Pulse_Rechargeable();
	static class FName ActionState_PushingReposition_Disable();
	static class FName ActionState_RepairWeapon();
	static class FName ActionState_ReserveInput();
	static class FName ActionState_ReserveInput_Attack();
	static class FName ActionState_ReserveInput_Dash();
	static class FName ActionState_ReserveInput_Special();
	static class FName ActionState_Resurrection();
	static class FName ActionState_Resurrection_Used();
	static class FName ActionState_RideOnLift();
	static class FName ActionState_RisingAttack_Enable();
	static class FName ActionState_Rootmotion_Velocity_Cap();
	static class FName ActionState_SA_NicolaTail_Active();
	static class FName ActionState_SA_NicolaTail_Counter();
	static class FName ActionState_SA_PileBunker_Lock();
	static class FName ActionState_Shotgun_Hold();
	static class FName ActionState_Show_Weapon_Forced();
	static class FName ActionState_SlaveArm_Disable();
	static class FName ActionState_Sleep();
	static class FName ActionState_SpawnIdle();
	static class FName ActionState_Sprint_Disable();
	static class FName ActionState_Sprint_Enable();
	static class FName ActionState_Stance_Always_Guard();
	static class FName ActionState_Stance_Always_Guard_Off();
	static class FName ActionState_Stance_Arm_Guard();
	static class FName ActionState_Stance_Arm_NoStiffen_Guard();
	static class FName ActionState_Stance_Guard();
	static class FName ActionState_Stance_NoStiffen_Guard();
	static class FName ActionState_Stance_Parrying();
	static class FName ActionState_Stance_Perfect_Guard();
	static class FName ActionState_Stance_Reflect_Guard();
	static class FName ActionState_Stance_Stance_BareHand();
	static class FName ActionState_Stance_Sword_OneHand();
	static class FName ActionState_Stance_Sword_TwoHand();
	static class FName ActionState_Stance_Weapon_Axe();
	static class FName ActionState_Stance_Weapon_Axe2();
	static class FName ActionState_Stance_Weapon_Blade();
	static class FName ActionState_Stance_Weapon_Blade2();
	static class FName ActionState_Stance_Weapon_Spear();
	static class FName ActionState_Stance_Weapon_Spear2();
	static class FName ActionState_Stance_Weapon_Sword();
	static class FName ActionState_Stance_Weapon_Sword2();
	static class FName ActionState_StandGuard();
	static class FName ActionState_StandGuardEnable();
	static class FName ActionState_Start_Rotation();
	static class FName ActionState_StopSprint();
	static class FName ActionState_SuperArmor();
	static class FName ActionState_ToggleWalkMode();
	static class FName ActionState_TransitAnimation_Dead();
	static class FName ActionState_TryLockInput_Movement();
	static class FName ActionState_TryLockInput_Rotation();
	static class FName ActionState_Tutorial_Walk();
	static class FName ActionState_Use_FSM_For_LowerBody();
	static class FName ActionState_UseItem_Disable();
	static class FName ActionState_Victim_Counter_Enable();
	static class FName ActionState_Weapon_Transform();
	static class FName ActionState_WeaponHideByNotify_EX1();
	static class FName ActionState_WeaponHideByNotify_EX2();
	static class FName ActionState_WeaponHideByNotify_EX3();
	static class FName ActionState_WeaponHideByNotify_L();
	static class FName ActionState_WeaponHideByNotify_R();
	static class FName ActionState_Weight_Advantage_Enable();
	static class FName ActionState_WeightPenalty_Decrease_L1_Change();
	static class FName ActionState_Zombie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionState">();
	}
	static class ULActionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActionState>();
	}
};
static_assert(alignof(ULActionState) == 0x000008, "Wrong alignment on ULActionState");
static_assert(sizeof(ULActionState) == 0x000028, "Wrong size on ULActionState");

// Class ProjectP.LAnimNotifyState_GuardCheck
// 0x0090 (0x00D0 - 0x0040)
class ULAnimNotifyState_GuardCheck final : public ULAnimNotifyStateBase
{
public:
	int32                                         GuardRangeAngleStart;                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitCollisionInfo                     HitInfo;                                           // 0x0048(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GuardCheck">();
	}
	static class ULAnimNotifyState_GuardCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GuardCheck>();
	}
};
static_assert(alignof(ULAnimNotifyState_GuardCheck) == 0x000008, "Wrong alignment on ULAnimNotifyState_GuardCheck");
static_assert(sizeof(ULAnimNotifyState_GuardCheck) == 0x0000D0, "Wrong size on ULAnimNotifyState_GuardCheck");
static_assert(offsetof(ULAnimNotifyState_GuardCheck, GuardRangeAngleStart) == 0x000040, "Member 'ULAnimNotifyState_GuardCheck::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck, GuardRangeAngleEnd) == 0x000044, "Member 'ULAnimNotifyState_GuardCheck::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck, HitInfo) == 0x000048, "Member 'ULAnimNotifyState_GuardCheck::HitInfo' has a wrong offset!");

// Class ProjectP.LActionSystemData
// 0x03B0 (0x0590 - 0x01E0)
class ALActionSystemData : public AActor
{
public:
	bool                                          HitCollisionDynamic_UseEnhancedOverlapCheck;       // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExitReposition_PushingPowerToPcSlave;              // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExitReposition_ForceUse;                           // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x3];                                      // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExitReposition_RepositionSpeed;                    // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitReposition_RepositionRotationSpeed;            // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitReposition_OverrideIdleMoveSpeedWeight;        // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dash_Front_End;                                    // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dash_Right_End;                                    // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dash_Back_End;                                     // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dash_Left_End;                                     // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StiffenDelayDefender;                              // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RF_Start;                                          // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RB_Start;                                          // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BR_Start;                                          // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BL_Start;                                          // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LB_Start;                                          // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LF_Start;                                          // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FL_Start;                                          // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitRotateTime;                                     // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackRotateTime;                               // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownRotateTime;                                    // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PerfectGuardBuff;                                  // 0x0234(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuardDuration;                              // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SparkFxInterval;                                   // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SparkSFxInterval;                                  // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncroachingEscapeAngle;                            // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PCRotationSpeed;                                   // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PCRotationSpeed_Skill;                             // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PC_Sprint_TurnAround_Lever_Threshold;              // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PC_LockOn_Turn_Angle_Start_Threshold;              // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PC_LockOn_Turn_Angle_Stop_Threshold;               // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnRotationInterpSpeed;                         // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PC_Running_Stop_MaxSpeed_Weight;                   // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PC_Sprint_Stop_MaxSpeed_Weight;                    // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PC_Sprint_TurnAround_MaxSpeed_Weight;              // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PCAllowRotationEndTimeLimit;                       // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingStuckExitTime;                              // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOverrideMontageBlendIn;                         // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MontageSlotNameForSeparateAnimRateScalingArray;    // 0x0280(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_HitDurationRatio;                     // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_KnockbackDurationRatio;               // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_KnockbackDistanceRatio;               // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_ReduceRate;                           // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_Stamina_ReduceRate;                   // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffen_Duration_PerfectGuard;                     // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffen_PlayRate_PerfectGuard;                     // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuardDamageReductionRatio;                  // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuardLockDuration;                          // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNoneLockOnAttackGuide;                          // 0x02B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FallingDieVariable;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidityConstant;                                  // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RgidityRatioPerfectGuard;                          // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardEx_CoolTime;                                  // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardRegainDelayTime;                              // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRegainRecoveryRatioGuarding;                  // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardRegainHealRatioParrying;                      // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardRegainDamageRatio;                            // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnGuardHit_RetainTime;                             // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AllowLockOnInAction : 1;                           // 0x02DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFallingHeightOverrideInfo>    FallingHeightOverrideArray;                        // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ELActionCategory>                      WallSlidingCategory_CH_OnMoveArray;                // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WallSlidingMultiplier_CH_OnMove;                   // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallSlidingMultiplier_CH_OnAction;                 // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ELActionCategory>                      WallSlidingCategory_ENV_OnActionArray;             // 0x0308(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WallSlidingMultiplier_ENV_OnMove;                  // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallSlidingMultiplier_ENV_OnAction;                // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClass_Down_Drag;                             // 0x0320(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClass_Down_Away;                             // 0x0348(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClass_Down_Up;                               // 0x0370(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClass_Down_Stamp;                            // 0x0398(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClass_Knock_Back;                            // 0x03C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMaxSharpnessReduceRatio_by_Grinding;         // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponSharpnesReduceMultiplier_by_Grinding_Count;  // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JustRepairSharpnessRatio;                          // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JustRepairDuration;                                // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFreezeTime;                                 // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollInteractionTime;                            // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           RagdollPreventPerBodyCollisionOff;                 // 0x0400(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GroggyDamageRatioJustToughZero;                    // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopAfterSprintTime;                               // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintTurnLeverNeutralThreshHoldTime;              // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_GroggyEnable_AddTime_Normal;          // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectGuard_GroggyEnable_AddTime_Fury;            // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hit_Intencity_KnockBack;                           // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hit_Intencity_Down;                                // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fatal_Margin_Time;                                 // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fatal_Angle_Limit;                                 // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fatal_Angle_Speed_Limit;                           // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fatal_Angle_RecordTime_Limit;                      // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatalCheckLeverAngle;                              // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Fatal_UseLineRotationForAlwaysType;                // 0x0440(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FatalSocket_LocationPivot;                         // 0x0444(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LookAtTriangle_Bottom;                 // 0x044C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LookAtTriangle_Top_R;                  // 0x0454(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LookAtTriangle_Top_L;                  // 0x045C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_FxTableCodeName;                         // 0x0464(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_FxTableCodeName;                     // 0x046C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_FxTableCodeName_Carcass;                 // 0x0474(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_FxTableCodeName_Carcass;             // 0x047C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explosion_AdditionalKillPower_ToUp;                // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explosion_AdditionalKillPower_RootToCut;           // 0x0488(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_DetachBoneName_Head;                 // 0x048C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_DetachBoneName_Arm_R;                // 0x0494(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_DetachBoneName_Arm_L;                // 0x049C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_DetachBoneName_Upper;                // 0x04A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_HideBoneName_Head;                   // 0x04AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_HideBoneName_Arm_R;                  // 0x04B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Explosion_Cut_HideBoneName_Arm_L;                  // 0x04BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Explosion_FxSocketNameArray_All_Carcass;           // 0x04C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Explosion_FxSocketNameArray_All;                   // 0x04D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Explosion_FxSocketNameArray_Head;                  // 0x04E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Explosion_FxSocketNameArray_Arm_R;                 // 0x04F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Explosion_FxSocketNameArray_Arm_L;                 // 0x0508(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Explosion_FxSocketNameArray_Upper;                 // 0x0518(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreLeverSpeedForBlendSpace;                     // 0x0528(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ELActionCategory>                      UseLeverSpeedForBlendSpace;                        // 0x0538(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Rootmotion_Velocity_Cap;                           // 0x0548(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FakeBrakingSpeedForAction;                         // 0x054C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTransitionTimeDown;                            // 0x0550(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkTransitionTimeUp;                              // 0x0554(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkTransitionTimeDown;                            // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunTransitionTimeUp;                               // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunTransitionTimeDown;                             // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintTransitionTimeUp;                            // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x28];                                     // 0x0568(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool FindHandBloodMaterial_ForCurrentBody(class UMaterialInstance** OutMaterial);
	bool FindPixelDepthOffsetData_ForCurrentFace(class UTexture** OutMask, float* OutIntensity);
	bool FindShrinkMesh_ForCurrentBody(class ALCharacter* TargetCharacter, class USkeletalMesh** OutMesh);
	bool OnApplyNeedShrink(class ALCharacter* TargetCharacter);
	void RemoveFatalLocationIndicator(class AActor* TargetActor, const struct FLFatalAttackInfo& FatalAttackInfo, int32 SuccessFatalAttackInfoIndex);
	void SetFatalLocationIndicatorState(const struct FLFatalIndicatorFxState& IndicatorFx);
	void SpawnFatalLocationIndicator(class AActor* TargetActor, const struct FLFatalAttackInfo& FatalAttackInfo);
	void UpdateFatalLocationIndicator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionSystemData">();
	}
	static class ALActionSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALActionSystemData>();
	}
};
static_assert(alignof(ALActionSystemData) == 0x000008, "Wrong alignment on ALActionSystemData");
static_assert(sizeof(ALActionSystemData) == 0x000590, "Wrong size on ALActionSystemData");
static_assert(offsetof(ALActionSystemData, HitCollisionDynamic_UseEnhancedOverlapCheck) == 0x0001E0, "Member 'ALActionSystemData::HitCollisionDynamic_UseEnhancedOverlapCheck' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ExitReposition_PushingPowerToPcSlave) == 0x0001E4, "Member 'ALActionSystemData::ExitReposition_PushingPowerToPcSlave' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ExitReposition_ForceUse) == 0x0001E8, "Member 'ALActionSystemData::ExitReposition_ForceUse' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ExitReposition_RepositionSpeed) == 0x0001EC, "Member 'ALActionSystemData::ExitReposition_RepositionSpeed' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ExitReposition_RepositionRotationSpeed) == 0x0001F0, "Member 'ALActionSystemData::ExitReposition_RepositionRotationSpeed' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ExitReposition_OverrideIdleMoveSpeedWeight) == 0x0001F4, "Member 'ALActionSystemData::ExitReposition_OverrideIdleMoveSpeedWeight' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Dash_Front_End) == 0x0001F8, "Member 'ALActionSystemData::Dash_Front_End' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Dash_Right_End) == 0x0001FC, "Member 'ALActionSystemData::Dash_Right_End' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Dash_Back_End) == 0x000200, "Member 'ALActionSystemData::Dash_Back_End' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Dash_Left_End) == 0x000204, "Member 'ALActionSystemData::Dash_Left_End' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, StiffenDelayDefender) == 0x000208, "Member 'ALActionSystemData::StiffenDelayDefender' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RF_Start) == 0x00020C, "Member 'ALActionSystemData::RF_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RB_Start) == 0x000210, "Member 'ALActionSystemData::RB_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, BR_Start) == 0x000214, "Member 'ALActionSystemData::BR_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, BL_Start) == 0x000218, "Member 'ALActionSystemData::BL_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, LB_Start) == 0x00021C, "Member 'ALActionSystemData::LB_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, LF_Start) == 0x000220, "Member 'ALActionSystemData::LF_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FL_Start) == 0x000224, "Member 'ALActionSystemData::FL_Start' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, HitRotateTime) == 0x000228, "Member 'ALActionSystemData::HitRotateTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, KnockbackRotateTime) == 0x00022C, "Member 'ALActionSystemData::KnockbackRotateTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, DownRotateTime) == 0x000230, "Member 'ALActionSystemData::DownRotateTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuardBuff) == 0x000234, "Member 'ALActionSystemData::PerfectGuardBuff' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuardDuration) == 0x00023C, "Member 'ALActionSystemData::PerfectGuardDuration' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, SparkFxInterval) == 0x000240, "Member 'ALActionSystemData::SparkFxInterval' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, SparkSFxInterval) == 0x000244, "Member 'ALActionSystemData::SparkSFxInterval' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, EncroachingEscapeAngle) == 0x000248, "Member 'ALActionSystemData::EncroachingEscapeAngle' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PCRotationSpeed) == 0x00024C, "Member 'ALActionSystemData::PCRotationSpeed' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PCRotationSpeed_Skill) == 0x000250, "Member 'ALActionSystemData::PCRotationSpeed_Skill' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PC_Sprint_TurnAround_Lever_Threshold) == 0x000254, "Member 'ALActionSystemData::PC_Sprint_TurnAround_Lever_Threshold' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PC_LockOn_Turn_Angle_Start_Threshold) == 0x000258, "Member 'ALActionSystemData::PC_LockOn_Turn_Angle_Start_Threshold' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PC_LockOn_Turn_Angle_Stop_Threshold) == 0x00025C, "Member 'ALActionSystemData::PC_LockOn_Turn_Angle_Stop_Threshold' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, LockOnRotationInterpSpeed) == 0x000260, "Member 'ALActionSystemData::LockOnRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PC_Running_Stop_MaxSpeed_Weight) == 0x000264, "Member 'ALActionSystemData::PC_Running_Stop_MaxSpeed_Weight' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PC_Sprint_Stop_MaxSpeed_Weight) == 0x000268, "Member 'ALActionSystemData::PC_Sprint_Stop_MaxSpeed_Weight' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PC_Sprint_TurnAround_MaxSpeed_Weight) == 0x00026C, "Member 'ALActionSystemData::PC_Sprint_TurnAround_MaxSpeed_Weight' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PCAllowRotationEndTimeLimit) == 0x000270, "Member 'ALActionSystemData::PCAllowRotationEndTimeLimit' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FallingStuckExitTime) == 0x000274, "Member 'ALActionSystemData::FallingStuckExitTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, UseOverrideMontageBlendIn) == 0x000278, "Member 'ALActionSystemData::UseOverrideMontageBlendIn' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, MontageSlotNameForSeparateAnimRateScalingArray) == 0x000280, "Member 'ALActionSystemData::MontageSlotNameForSeparateAnimRateScalingArray' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_HitDurationRatio) == 0x000290, "Member 'ALActionSystemData::PerfectGuard_HitDurationRatio' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_KnockbackDurationRatio) == 0x000294, "Member 'ALActionSystemData::PerfectGuard_KnockbackDurationRatio' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_KnockbackDistanceRatio) == 0x000298, "Member 'ALActionSystemData::PerfectGuard_KnockbackDistanceRatio' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_ReduceRate) == 0x00029C, "Member 'ALActionSystemData::PerfectGuard_ReduceRate' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_Stamina_ReduceRate) == 0x0002A0, "Member 'ALActionSystemData::PerfectGuard_Stamina_ReduceRate' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Stiffen_Duration_PerfectGuard) == 0x0002A4, "Member 'ALActionSystemData::Stiffen_Duration_PerfectGuard' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Stiffen_PlayRate_PerfectGuard) == 0x0002A8, "Member 'ALActionSystemData::Stiffen_PlayRate_PerfectGuard' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuardDamageReductionRatio) == 0x0002AC, "Member 'ALActionSystemData::PerfectGuardDamageReductionRatio' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuardLockDuration) == 0x0002B0, "Member 'ALActionSystemData::PerfectGuardLockDuration' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, UseNoneLockOnAttackGuide) == 0x0002B4, "Member 'ALActionSystemData::UseNoneLockOnAttackGuide' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FallingDieVariable) == 0x0002B8, "Member 'ALActionSystemData::FallingDieVariable' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RigidityConstant) == 0x0002BC, "Member 'ALActionSystemData::RigidityConstant' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RgidityRatioPerfectGuard) == 0x0002C0, "Member 'ALActionSystemData::RgidityRatioPerfectGuard' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, GuardEx_CoolTime) == 0x0002C4, "Member 'ALActionSystemData::GuardEx_CoolTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, GuardRegainDelayTime) == 0x0002C8, "Member 'ALActionSystemData::GuardRegainDelayTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, GuardRegainRecoveryRatioGuarding) == 0x0002CC, "Member 'ALActionSystemData::GuardRegainRecoveryRatioGuarding' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, GuardRegainHealRatioParrying) == 0x0002D0, "Member 'ALActionSystemData::GuardRegainHealRatioParrying' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, GuardRegainDamageRatio) == 0x0002D4, "Member 'ALActionSystemData::GuardRegainDamageRatio' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, OnGuardHit_RetainTime) == 0x0002D8, "Member 'ALActionSystemData::OnGuardHit_RetainTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FallingHeightOverrideArray) == 0x0002E0, "Member 'ALActionSystemData::FallingHeightOverrideArray' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WallSlidingCategory_CH_OnMoveArray) == 0x0002F0, "Member 'ALActionSystemData::WallSlidingCategory_CH_OnMoveArray' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WallSlidingMultiplier_CH_OnMove) == 0x000300, "Member 'ALActionSystemData::WallSlidingMultiplier_CH_OnMove' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WallSlidingMultiplier_CH_OnAction) == 0x000304, "Member 'ALActionSystemData::WallSlidingMultiplier_CH_OnAction' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WallSlidingCategory_ENV_OnActionArray) == 0x000308, "Member 'ALActionSystemData::WallSlidingCategory_ENV_OnActionArray' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WallSlidingMultiplier_ENV_OnMove) == 0x000318, "Member 'ALActionSystemData::WallSlidingMultiplier_ENV_OnMove' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WallSlidingMultiplier_ENV_OnAction) == 0x00031C, "Member 'ALActionSystemData::WallSlidingMultiplier_ENV_OnAction' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ActionClass_Down_Drag) == 0x000320, "Member 'ALActionSystemData::ActionClass_Down_Drag' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ActionClass_Down_Away) == 0x000348, "Member 'ALActionSystemData::ActionClass_Down_Away' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ActionClass_Down_Up) == 0x000370, "Member 'ALActionSystemData::ActionClass_Down_Up' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ActionClass_Down_Stamp) == 0x000398, "Member 'ALActionSystemData::ActionClass_Down_Stamp' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, ActionClass_Knock_Back) == 0x0003C0, "Member 'ALActionSystemData::ActionClass_Knock_Back' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WeaponMaxSharpnessReduceRatio_by_Grinding) == 0x0003E8, "Member 'ALActionSystemData::WeaponMaxSharpnessReduceRatio_by_Grinding' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WeaponSharpnesReduceMultiplier_by_Grinding_Count) == 0x0003EC, "Member 'ALActionSystemData::WeaponSharpnesReduceMultiplier_by_Grinding_Count' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, JustRepairSharpnessRatio) == 0x0003F0, "Member 'ALActionSystemData::JustRepairSharpnessRatio' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, JustRepairDuration) == 0x0003F4, "Member 'ALActionSystemData::JustRepairDuration' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RagdollFreezeTime) == 0x0003F8, "Member 'ALActionSystemData::RagdollFreezeTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RagdollInteractionTime) == 0x0003FC, "Member 'ALActionSystemData::RagdollInteractionTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RagdollPreventPerBodyCollisionOff) == 0x000400, "Member 'ALActionSystemData::RagdollPreventPerBodyCollisionOff' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, GroggyDamageRatioJustToughZero) == 0x000410, "Member 'ALActionSystemData::GroggyDamageRatioJustToughZero' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, StopAfterSprintTime) == 0x000414, "Member 'ALActionSystemData::StopAfterSprintTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, SprintTurnLeverNeutralThreshHoldTime) == 0x000418, "Member 'ALActionSystemData::SprintTurnLeverNeutralThreshHoldTime' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_GroggyEnable_AddTime_Normal) == 0x00041C, "Member 'ALActionSystemData::PerfectGuard_GroggyEnable_AddTime_Normal' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, PerfectGuard_GroggyEnable_AddTime_Fury) == 0x000420, "Member 'ALActionSystemData::PerfectGuard_GroggyEnable_AddTime_Fury' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Hit_Intencity_KnockBack) == 0x000424, "Member 'ALActionSystemData::Hit_Intencity_KnockBack' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Hit_Intencity_Down) == 0x000428, "Member 'ALActionSystemData::Hit_Intencity_Down' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Fatal_Margin_Time) == 0x00042C, "Member 'ALActionSystemData::Fatal_Margin_Time' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Fatal_Angle_Limit) == 0x000430, "Member 'ALActionSystemData::Fatal_Angle_Limit' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Fatal_Angle_Speed_Limit) == 0x000434, "Member 'ALActionSystemData::Fatal_Angle_Speed_Limit' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Fatal_Angle_RecordTime_Limit) == 0x000438, "Member 'ALActionSystemData::Fatal_Angle_RecordTime_Limit' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FatalCheckLeverAngle) == 0x00043C, "Member 'ALActionSystemData::FatalCheckLeverAngle' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Fatal_UseLineRotationForAlwaysType) == 0x000440, "Member 'ALActionSystemData::Fatal_UseLineRotationForAlwaysType' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FatalSocket_LocationPivot) == 0x000444, "Member 'ALActionSystemData::FatalSocket_LocationPivot' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FatalSocket_LookAtTriangle_Bottom) == 0x00044C, "Member 'ALActionSystemData::FatalSocket_LookAtTriangle_Bottom' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FatalSocket_LookAtTriangle_Top_R) == 0x000454, "Member 'ALActionSystemData::FatalSocket_LookAtTriangle_Top_R' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FatalSocket_LookAtTriangle_Top_L) == 0x00045C, "Member 'ALActionSystemData::FatalSocket_LookAtTriangle_Top_L' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxTableCodeName) == 0x000464, "Member 'ALActionSystemData::Explosion_FxTableCodeName' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_FxTableCodeName) == 0x00046C, "Member 'ALActionSystemData::Explosion_Cut_FxTableCodeName' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxTableCodeName_Carcass) == 0x000474, "Member 'ALActionSystemData::Explosion_FxTableCodeName_Carcass' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_FxTableCodeName_Carcass) == 0x00047C, "Member 'ALActionSystemData::Explosion_Cut_FxTableCodeName_Carcass' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_AdditionalKillPower_ToUp) == 0x000484, "Member 'ALActionSystemData::Explosion_AdditionalKillPower_ToUp' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_AdditionalKillPower_RootToCut) == 0x000488, "Member 'ALActionSystemData::Explosion_AdditionalKillPower_RootToCut' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_DetachBoneName_Head) == 0x00048C, "Member 'ALActionSystemData::Explosion_Cut_DetachBoneName_Head' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_DetachBoneName_Arm_R) == 0x000494, "Member 'ALActionSystemData::Explosion_Cut_DetachBoneName_Arm_R' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_DetachBoneName_Arm_L) == 0x00049C, "Member 'ALActionSystemData::Explosion_Cut_DetachBoneName_Arm_L' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_DetachBoneName_Upper) == 0x0004A4, "Member 'ALActionSystemData::Explosion_Cut_DetachBoneName_Upper' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_HideBoneName_Head) == 0x0004AC, "Member 'ALActionSystemData::Explosion_Cut_HideBoneName_Head' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_HideBoneName_Arm_R) == 0x0004B4, "Member 'ALActionSystemData::Explosion_Cut_HideBoneName_Arm_R' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_Cut_HideBoneName_Arm_L) == 0x0004BC, "Member 'ALActionSystemData::Explosion_Cut_HideBoneName_Arm_L' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxSocketNameArray_All_Carcass) == 0x0004C8, "Member 'ALActionSystemData::Explosion_FxSocketNameArray_All_Carcass' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxSocketNameArray_All) == 0x0004D8, "Member 'ALActionSystemData::Explosion_FxSocketNameArray_All' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxSocketNameArray_Head) == 0x0004E8, "Member 'ALActionSystemData::Explosion_FxSocketNameArray_Head' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxSocketNameArray_Arm_R) == 0x0004F8, "Member 'ALActionSystemData::Explosion_FxSocketNameArray_Arm_R' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxSocketNameArray_Arm_L) == 0x000508, "Member 'ALActionSystemData::Explosion_FxSocketNameArray_Arm_L' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Explosion_FxSocketNameArray_Upper) == 0x000518, "Member 'ALActionSystemData::Explosion_FxSocketNameArray_Upper' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, IgnoreLeverSpeedForBlendSpace) == 0x000528, "Member 'ALActionSystemData::IgnoreLeverSpeedForBlendSpace' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, UseLeverSpeedForBlendSpace) == 0x000538, "Member 'ALActionSystemData::UseLeverSpeedForBlendSpace' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, Rootmotion_Velocity_Cap) == 0x000548, "Member 'ALActionSystemData::Rootmotion_Velocity_Cap' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, FakeBrakingSpeedForAction) == 0x00054C, "Member 'ALActionSystemData::FakeBrakingSpeedForAction' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, IdleTransitionTimeDown) == 0x000550, "Member 'ALActionSystemData::IdleTransitionTimeDown' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WalkTransitionTimeUp) == 0x000554, "Member 'ALActionSystemData::WalkTransitionTimeUp' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, WalkTransitionTimeDown) == 0x000558, "Member 'ALActionSystemData::WalkTransitionTimeDown' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RunTransitionTimeUp) == 0x00055C, "Member 'ALActionSystemData::RunTransitionTimeUp' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, RunTransitionTimeDown) == 0x000560, "Member 'ALActionSystemData::RunTransitionTimeDown' has a wrong offset!");
static_assert(offsetof(ALActionSystemData, SprintTransitionTimeUp) == 0x000564, "Member 'ALActionSystemData::SprintTransitionTimeUp' has a wrong offset!");

// Class ProjectP.LActionSystem
// 0x00F8 (0x0170 - 0x0078)
class ULActionSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0xC];                                       // 0x0078(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowActionLogAlways;                              // 0x0084(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELExplosionMeshType                           TEST_ExplodeType;                                  // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TEST_PartsDestory;                                 // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponAttachSocketName_R;                          // 0x0088(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachSocketName_L;                          // 0x0090(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLDeadExplosionTable                   DeadExplosionTable;                                // 0x0098(0x0008)(Transient, NativeAccessSpecifierPublic)
	struct FLActionGroupTable                     ActionGroupTable;                                  // 0x00A0(0x0008)(Transient, NativeAccessSpecifierPublic)
	struct FLNPCAssetTable                        NPCAssetTable;                                     // 0x00A8(0x0008)(Transient, NativeAccessSpecifierPublic)
	struct FLWeaponAssetTable                     WeaponAssetTable;                                  // 0x00B0(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLPartsAssetTable                      PartsAssetTable;                                   // 0x00B8(0x0008)(Transient, NativeAccessSpecifierPublic)
	class ALActionSystemData*                     ActionSystemData;                                  // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0xA8];                                      // 0x00C8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddFatalIndicator(class AActor* TargetActor);
	bool OnApplyNeedShrink(class ALCharacter* TargetCharacter);
	void RemoveFatalIndicator(class AActor* TargetActor, int32 SuccessFatalAttackInfoIndex);

	float GetBL_Start() const;
	float GetBR_Start() const;
	float GetDash_Back_End() const;
	float GetDash_Front_End() const;
	float GetDash_Left_End() const;
	float GetDash_Right_End() const;
	float GetDownRotateTime() const;
	int32 GetFallingDieVariable() const;
	void GetFatalTargetPointLocation(int32 Index_0, struct FVector* WorldLocation, bool* InRange) const;
	float GetFL_Start() const;
	float GetGroggyDamageRatioJustToughZero() const;
	float GetGuardEx_CoolTime() const;
	float GetGuardRegainDamageRatio() const;
	float GetGuardRegainDelayTime() const;
	float GetGuardRegainHealRatioParrying() const;
	int32 GetGuardRegainRecoveryRatioGuarding() const;
	float GetHit_Intencity_Down() const;
	float GetHit_Intencity_KnockBack() const;
	float GetHitRotateTime() const;
	float GetJustRepairDuration() const;
	float GetJustRepairSharpnessRatio() const;
	float GetKnockbackRotateTime() const;
	float GetLB_Start() const;
	float GetLF_Start() const;
	float GetOnGuardHit_RetainTime() const;
	float GetPerfectGuard_HitDurationRatio() const;
	float GetPerfectGuard_KnockbackDistanceRatio() const;
	float GetPerfectGuard_KnockbackDurationRatio() const;
	float GetPerfectGuard_ReduceRate() const;
	float GetPerfectGuard_Stamina_ReduceRate() const;
	float GetRagdollFreezeTime() const;
	float GetRagdollInteractionTime() const;
	float GetRB_Start() const;
	float GetRF_Start() const;
	float GetRgidityRatioPerfectGuard() const;
	float GetRigidityConstant() const;
	float GetSparkFxInterval() const;
	float GetSparkSFxInterval() const;
	float GetStiffen_Duration_PerfectGuard() const;
	float GetStiffen_PlayRate_PerfectGuard() const;
	float GetStiffenDelayDefender() const;
	float GetStopAfterSprintTime() const;
	float GetWeaponMaxSharpnessReduceRatio_By_Grinding() const;
	float GetWeaponSharpnessReduceMultiplier_By_Grinding_count() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionSystem">();
	}
	static class ULActionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActionSystem>();
	}
};
static_assert(alignof(ULActionSystem) == 0x000008, "Wrong alignment on ULActionSystem");
static_assert(sizeof(ULActionSystem) == 0x000170, "Wrong size on ULActionSystem");
static_assert(offsetof(ULActionSystem, bShowActionLogAlways) == 0x000084, "Member 'ULActionSystem::bShowActionLogAlways' has a wrong offset!");
static_assert(offsetof(ULActionSystem, TEST_ExplodeType) == 0x000085, "Member 'ULActionSystem::TEST_ExplodeType' has a wrong offset!");
static_assert(offsetof(ULActionSystem, TEST_PartsDestory) == 0x000086, "Member 'ULActionSystem::TEST_PartsDestory' has a wrong offset!");
static_assert(offsetof(ULActionSystem, WeaponAttachSocketName_R) == 0x000088, "Member 'ULActionSystem::WeaponAttachSocketName_R' has a wrong offset!");
static_assert(offsetof(ULActionSystem, WeaponAttachSocketName_L) == 0x000090, "Member 'ULActionSystem::WeaponAttachSocketName_L' has a wrong offset!");
static_assert(offsetof(ULActionSystem, DeadExplosionTable) == 0x000098, "Member 'ULActionSystem::DeadExplosionTable' has a wrong offset!");
static_assert(offsetof(ULActionSystem, ActionGroupTable) == 0x0000A0, "Member 'ULActionSystem::ActionGroupTable' has a wrong offset!");
static_assert(offsetof(ULActionSystem, NPCAssetTable) == 0x0000A8, "Member 'ULActionSystem::NPCAssetTable' has a wrong offset!");
static_assert(offsetof(ULActionSystem, WeaponAssetTable) == 0x0000B0, "Member 'ULActionSystem::WeaponAssetTable' has a wrong offset!");
static_assert(offsetof(ULActionSystem, PartsAssetTable) == 0x0000B8, "Member 'ULActionSystem::PartsAssetTable' has a wrong offset!");
static_assert(offsetof(ULActionSystem, ActionSystemData) == 0x0000C0, "Member 'ULActionSystem::ActionSystemData' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayDecal
// 0x0048 (0x0090 - 0x0048)
class ULAnimNotify_PlayDecal final : public ULAnimNotifyBase
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x0068(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRandomRotate;                                   // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayDecal">();
	}
	static class ULAnimNotify_PlayDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayDecal>();
	}
};
static_assert(alignof(ULAnimNotify_PlayDecal) == 0x000008, "Wrong alignment on ULAnimNotify_PlayDecal");
static_assert(sizeof(ULAnimNotify_PlayDecal) == 0x000090, "Wrong size on ULAnimNotify_PlayDecal");
static_assert(offsetof(ULAnimNotify_PlayDecal, Material) == 0x000048, "Member 'ULAnimNotify_PlayDecal::Material' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayDecal, LocationOffset) == 0x000050, "Member 'ULAnimNotify_PlayDecal::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayDecal, RotationOffset) == 0x00005C, "Member 'ULAnimNotify_PlayDecal::RotationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayDecal, DecalSize) == 0x000068, "Member 'ULAnimNotify_PlayDecal::DecalSize' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayDecal, LifeSpan) == 0x000074, "Member 'ULAnimNotify_PlayDecal::LifeSpan' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayDecal, UseRandomRotate) == 0x000078, "Member 'ULAnimNotify_PlayDecal::UseRandomRotate' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayDecal, DisableWhenWeaponInListBroken) == 0x000080, "Member 'ULAnimNotify_PlayDecal::DisableWhenWeaponInListBroken' has a wrong offset!");

// Class ProjectP.LActionUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULActionUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddInputActionKeyMapping(class FName InputAction, const struct FInputActionKeyMapping& Mapping);
	static bool AddInputAxisKeyMapping(class FName InputAction, const struct FInputAxisKeyMapping& Mapping);
	static float CalcHitAngleBP(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, struct FVector* OutHitOrigin, EExecutePin* Branches);
	static struct FVector CalcParabolicMoveVelocity(const struct FVector& StartLocation, const struct FVector& EndLocation, float Duration, float Gravity);
	static void ChangeCollisionState(class AActor* TargetActor, ELCollisionState CollisionState);
	static void ChangeFloatingState(class AActor* TargetActor, bool bEnable, bool bApplyCeiling);
	static void ChangeHairCategoryType(ELHairCategoryType HairCategoryType);
	static bool ChangeInputPreset(class FName PresetName);
	static bool ChangePerBodyCollisionProfile(class AActor* TargetActor, bool TurnOffOverlapBody, bool TurnOffSecondaryBody, const class FName CollisionProfile_ChangeTarget, const class FName CollisionProfile_Other, int32* OutCount_AllBody, int32* OutCount_ChangeByOverlap, int32* OutCount_ChangedBySecondary);
	static int32 ChangeWeaponAnimState(class AActor* Actor, ELWeaponAttachPointType AttachPointType, ELWeaponPartType PartType, class FName AnimState);
	static void ChangeWeaponAnimStateWithPickedIndex(class AActor* Actor, int32 PickedIndex, ELWeaponPartType PartType, class FName AnimState);
	static void CheatFalling(class AActor* TargetActor);
	static void CheatFly(class AActor* TargetActor);
	static void CheatGhost(class AActor* TargetActor);
	static void CheatWalk(class AActor* TargetActor);
	static bool CheckAlwaysGuard(class AActor* Attacker, class AActor* Victim);
	static bool CheckCollisionOwnerTypeBP(const class UPrimitiveComponent* CollisionComponent, ELCollisionOwnerType CheckType, EExecutePin* Branches);
	static bool CheckFatalAttackConditionsBP(class AActor* CheckTarget, const struct FLFatalAttackInfo& CheckFatalAttackInfo, bool AllowFatalTrailMargin, EExecutePin* Branches);
	static bool CheckGrabBP(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, EExecutePin* Branches);
	static struct FHitResult CheckObstacleOnPathBP(class UPrimitiveComponent* CheckTargetComponent, const TArray<struct FVector>& PathArray, EExecutePin* Branches);
	static int32 CollectLCharacterInRange(const struct FVector& TestOrigin, const float Range, const TArray<class ALCharacter*>& IgnoredCharacterArray, TArray<class ALCharacter*>* OutCollectedCharacterArray);
	static struct FRotator ComputeFatalOffsetRotationBP(class AActor* CheckTarget, EExecutePin* Branches);
	static ELPCActionKeyType ConvertToActionKey(const class FString& InActionName);
	static class FString ConvertToActionKeyString(ELPCActionKeyType InActionKey);
	static void DecreaseWeaponDestructDurability(class AActor* Attacker, class AActor* Victim, int32 DurabilityAmount, const struct FVector& BreakDirection, bool bVictimGuard, bool bPlayHitAction, class FName* OutPlayActionClassCodeName);
	static bool DoChangeCharBlockType(class AActor* TargetActor, ELCharacterCollisionType CharacterCollisionType, bool UseStack);
	static bool DoChangeWeapon(class AActor* TargetActor, bool SelectPrevious);
	static void DoCharacterKillZone(class AActor* Actor, bool bUseCustomDieUIShowTime, float DieUI_StartDelay, bool bDoExecuteSequence);
	static bool DoGrabBP(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, EExecutePin* Branches);
	static bool DoGrabReleaseBP(class AActor* TargetActor, const struct FLGrabReleaseInfo& GrabReleaseInfo, EExecutePin* Branches);
	static bool DoHideBone(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName, bool Hide);
	static bool DoIdleMove(class AActor* TargetActor, bool bCalledFromNotify);
	static void DoNPCSuicide(class AActor* Actor, ELNPCSuicideType SuicideType, class FName DeadCodeName, bool bItemGet, bool bExpGet, bool bUseOverrideRespawnState, bool bRespawnEnable, bool bPlayDeadSound);
	static bool DoRespawn(class AActor* TargetActor);
	static bool DoWeaponOffBP(class AActor* TargetActor, EExecutePin* Branches);
	static bool DoWeaponOnBP(class AActor* TargetActor, EExecutePin* Branches);
	static struct FTransform ExtractMontageBoneTransformBP(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage, const class FName BoneName, const float Position, bool ExtractRootmotion, EExecutePin* Branches);
	static struct FTransform ExtractRootMotionFromTrackRangeBP(class UAnimInstance* AnimInstance, class UAnimMontage* AnimMontage, const float StartPosition, const float EndPosition, EExecutePin* Branches);
	static TArray<class FName> FindActionKeyInputAction(const struct FKey& Key, bool Alt, bool Ctrl, bool Shift, bool Cmd);
	static bool FindActionState(class AActor* Actor, class FName ActionState);
	static struct FLFxSocketTracerInfo FindActiveFxSocketTracerInfo(class AActor* TargetActor, const struct FLGameObjectHandle& Handle, EExecutePin* Branches);
	static TArray<class FName> FindAxisKeyInputAction(const struct FKey& Key, bool Alt, bool Ctrl, bool Shift, bool Cmd);
	static struct FItemSlaveArmInfoPtr FindEquippedItemSlaveArmInfoBP(class AActor* TargetActor, EExecutePin* Branches);
	static class AActor* FindFatalAttackTargetBP(class AActor* Attacker, struct FLFatalAttackInfo* OutFatalAttackInfo, EExecutePin* Branches);
	static void FindHandBloodMaterial_ForCurrentBodyBP(class UMaterialInstance** OutMaterial, EExecutePin* Branches);
	static struct FHitIndexInfoPtr FindHitIndexInfoBP(class FName SkillCodeName, int32 HitIndex, EExecutePin* Branches);
	static struct FHitMotionReplaceInfoPtr FindHitMotionReplaceInfoBP(class FName HitMotionReplaceGroupCodeName, ELHitMotionType OriginHitMotionType, EExecutePin* Branches);
	static class AActor* FindNoneLockOnAutoGuideTarget(class AActor* TargetActor);
	static class ALPartsActor* FindPartsActor(class AActor* Actor, int32 PartsIndex);
	static class ULPartsComponent* FindPartsComponent(class AActor* Actor, int32 PartsIndex);
	static void FindPixelDepthOffsetData_ForCurrentFaceBP(class UTexture** OutMask, float* OutIntensity, EExecutePin* Branches);
	static ELPCActionKeyType FindPresetInputAction(class FName InPresetName, const struct FKey& Key);
	static struct FKey FindPresetInputActionKey(class FName InPresetName, ELPCActionKeyType KeyType);
	static void FindShrinkMesh_ForCurrentBodyBP(class ALCharacter* TargetCharacter, class USkeletalMesh** OutMesh, EExecutePin* Branches);
	static class USceneComponent* FindSocketOwnerComponent(class AActor* TargetActor, class FName SocketName, ELMeshSelectionType MeshSelectionType);
	static bool FindWeaponDestructDurability(class AActor* Actor, ELWeaponAttachPointType WeaponAttachPoint, struct FLWeaponDestructDurabilityEnable* WeaponDestructDurabilityEnable_0);
	static class FName GetActionClassCodeNameBySkillHit(class AActor* Victim, class FName SkillHitCodeName);
	static class ULItem* GetActiveSlaveArmItemBP(class AActor* TargetActor, EExecutePin* Branches);
	static class FName GetActiveSlaveArmSkillCodeNameBP(class AActor* TargetActor, EExecutePin* Branches);
	static class FName GetActiveUseItemSkillCodeNameBP(class ULActPayloadBase* InOptionalPayloadItem, EExecutePin* Branches);
	static class ULActMgrComponent* GetActMgrComponent(class AActor* TargetActor);
	static class ULActMgrComponent* GetActMgrComponentBP(class AActor* TargetActor, EExecutePin* Branches);
	static class FName GetAssistUseItemSkillCodeNameBP(ELAssistUseItemSlotType InSlotType, EExecutePin* Branches);
	static class ULPartsComponent* GetBodyWeaponByAttachPoint(class AActor* TargetActor, ELPartsAttachPointType AttachPointType);
	static class ULPartsComponent* GetBodyWeaponBySkillHit(class AActor* TargetActor, class FName SkillHitCodeName);
	static bool GetCommandConsumed(class FName Command);
	static float GetCommandRaisedTime(class FName Command);
	static class UAnimMontage* GetCommonAnim(class AActor* TargetActor, class FName CommonCodeName);
	static class UAnimMontage* GetCommonAnimBP(class AActor* TargetActor, class FName CommonCodeName, EExecutePin* Branches);
	static class UAnimMontage* GetCommonAnimExBP(class AActor* TargetActor, class FName CommonCodeName, float* OutOverrideMontageBlendIn, EExecutePin* Branches);
	static ELActionCategory GetCurrentActionCategory(class AActor* TargetActor, bool ExceptHitAction);
	static bool GetCurrentGrabResultBP(class AActor* TargetActor, struct FLGrabResultInfo* OutGrabResultInfo, EExecutePin* Branches);
	static ELPCActionKeyType GetCurrentPresetInputAction(bool IsGamePad, const struct FKey& Key);
	static struct FKey GetCurrentPresetInputActionKey(bool IsGamePad, ELPCActionKeyType KeyType);
	static class ULReasonForDeathInfo* GetDeathInfo(class AActor* TargetActor);
	static ELSecondStat GetDebuffResistStat(ELAbnormalAbstateClass InAbnormalAbstateClass);
	static class UAnimMontage* GetDieAnim(class AActor* TargetActor, const class ULReasonForDeathInfo* ReasonInfo);
	static class UAnimMontage* GetDieAnimEx(class AActor* TargetActor, const class ULReasonForDeathInfo* ReasonInfo, float* OutOverrideMontageBlendIn);
	static ELSecondStat GetElementalStat(ELElementDamageType ElementalType, ELDamageBranchType ElementalStatType);
	static class FName GetEndCommonAnimBP(class AActor* TargetActor, class FName CommonCodeName, EExecutePin* Branches);
	static class UAnimMontage* GetFallingAnim(class AActor* TargetActor);
	static class UAnimMontage* GetFallingAnimEx(class AActor* TargetActor, float* OutOverrideMontageBlendIn);
	static class AActor* GetGrabAttackerBP(class AActor* Victim, EExecutePin* Branches);
	static class AActor* GetGrabVictimBP(class AActor* Attacker, EExecutePin* Branches);
	static ELHairCategoryType GetHairCategoryType();
	static class ULHitProcComponent* GetHitProcComponentBP(class AActor* TargetActor, EExecutePin* Branches);
	static TArray<struct FKey> GetInputKeyForAction(class FName InputAction, bool Gamepad);
	static TArray<struct FKey> GetInputKeyForAxis(class FName InputAction, bool Gamepad);
	static class UAnimMontage* GetLandingAnim(class AActor* TargetActor);
	static class UAnimMontage* GetLandingAnimEx(class AActor* TargetActor, float* OutOverrideMontageBlendIn);
	static class ULActBase* GetLastPlayingAction(class AActor* TargetActor, bool ExceptHitAction);
	static class ULCharacterMovementComponent* GetLCharacterMovementComponentBP(class AActor* TargetActor, EExecutePin* Branches);
	static ELMeshSelectionType GetMeshSelectionTypeByWeaponAttachType(ELWeaponAttachPointType WeaponAttachPointType);
	static float GetMontage_CurrentPlayPositionBP(class UAnimInstance* AnimInst, int32 MontageInstanceID, EExecutePin* Branches);
	static class FName GetMontage_CurrentSectionBP(class UAnimInstance* AnimInst, int32 MontageInstanceID, EExecutePin* Branches);
	static float GetMontage_PlayLengthWithRateScaleBP(class UAnimMontage* Montage, EExecutePin* Branches);
	static float GetMontage_PlayRateBP(class UAnimMontage* Montage, EExecutePin* Branches);
	static float GetMontage_SectionLength(class UAnimMontage* InMontage, int32 InSection);
	static class ULPhysicalAnimationComponent* GetPhysicalAnimationComponentBP(class AActor* TargetActor, EExecutePin* Branches);
	static ELSecondStat GetPhysicalStat(ELPhysicalDamageType PhysicalType, ELDamageBranchType ElementalStatType);
	static class UAnimSequenceBase* GetSkillAnim(class AActor* TargetActor, class FName SkillCodeName);
	static class ALWeapon* GetWeapon(class AActor* TargetActor);
	static class FName GetWeaponAttachPointSocket(class AActor* TargetActor, ELWeaponAttachPointType AttachPointType);
	static ELWeaponAttachPointType GetWeaponAttachTypeByMeshSelectionType(ELMeshSelectionType MeshSelectionType);
	static class ALWeapon* GetWeaponByAttachPoint(class AActor* TargetActor, ELWeaponAttachPointType AttachPointType);
	static class ALWeapon* GetWeaponByItem(class AActor* TargetActor);
	static class ALWeapon* GetWeaponBySkillHit(class AActor* TargetActor, class FName SkillHitCodeName);
	static bool IsAttackAction(ELActionCategory ActionCategory);
	static bool IsCommandPressed(class FName Command);
	static bool IsCounterAlwaysBP(EExecutePin* Branches);
	static bool IsDashAction(ELActionCategory ActionCategory);
	static bool IsFatalHitActionClassName(class FName ActionClassName);
	static bool IsHitAction(ELActionCategory ActionCategory);
	static bool IsInGrabProcessBP(class AActor* TargetActor, EExecutePin* Branches);
	static bool IsInIdleMoveState(class AActor* TargetActor);
	static bool IsLandWalkable(const struct FVector& LandNormal);
	static bool IsPlayingSequence();
	static bool IsSkillHitTypeWeapon(ELSkillHitType SkillHitType);
	static bool IsValidGameObjectHandle(const struct FLGameObjectHandle& Handle);
	static class ALHitCollisionDynamic* LaunchHitCollisionDynamic(class AActor* Instigator, const struct FLHitCollisionInfo& HitColInfo, const struct FLHitContext& HitContext);
	static class ALHitCollisionDynamic* LaunchHitCollisionDynamicWithGrab(class AActor* Instigator, const struct FLHitCollisionInfo& HitColInfo, const struct FLHitContext& HitContext, const struct FLGrabInfo& GrabInfo);
	static struct FLGameObjectHandle LaunchTraceAttack(class AActor* TargetActor, class FName SkillHitName, ELSocketTraceType SocketTraceType, bool IsBroken, class UObject* LifeOwner);
	static struct FLGameObjectHandle LaunchTraceAttack_by_NonHitNotify(class AActor* TargetActor, class ALWeapon* WeaponActor, ELSocketTraceType SocketTraceType, class FName TraceStartSocket, class FName TraceEndSocket, float TraceSphereRadius, float LifeSpan, ELPhysicalSurfaceType PhysicalSurface, bool IsBroken, class UObject* LifeOwner);
	static bool LockPCActions(const class UObject* WorldContextObject, bool AllowMoveOnly);
	static void OnStartFatalAttack(class AActor* Attacker);
	static void OnStopFatalAttack(class AActor* Attacker);
	static bool OverrideAnimationAssetBP(class UAnimInstance* AnimInstance, class UAnimationAsset* AnimationAsset, class FName MachineName, class FName StateName, EExecutePin* Branches);
	static bool PauseMontage(class UAnimInstance* AnimInst, int32 MontageInstanceID, bool Pause);
	static class ULActBase* PlayActionClass(class AActor* Target, class FName ActionClassCodeName, class ULActPayloadBase* Payload);
	static int32 PlayAnimAsDynamicMontage(class UAnimInstance* AnimInst, class UAnimSequenceBase* Anim, class FName InSlotNodeName, class UAnimMontage** OutMontage, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static class ULActBase* PlayCommonMontage(class AActor* Target, class FName CommonMontageCodeName);
	static class ULActBase* PlayHitActionBP(class AActor* Attacker, class AActor* Victim, class FName HitActionClassCodeName, const struct FLHitInfo& HitInfo, EExecutePin* Branches);
	static int32 PlayLoopAnimAsDynamicMontage(class UAnimInstance* AnimInst, class UAnimSequenceBase* StartAnim, class UAnimSequenceBase* LoopAnim, class UAnimSequenceBase* EndAnim, class FName InSlotNodeName, class UAnimMontage** OutMontage, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	static int32 PlayMontage(class UAnimInstance* AnimInst, class UAnimMontage* Montage, float InPlayRate, float InTimeToStartMontageAt, bool bStopAllMontages);
	static class ULActBase* PlaySkillActionBP(class AActor* Target, class FName SkillCodeName, const struct FLAction_StartRotationInfo& StartRotationInfo, class ULActPayloadBase* Payload, EExecutePin* Branches);
	static void PlaySocketTracerFx(class AActor* OwnerActor, const struct FLFxSocketTracerInfo& FxSocketTracerInfo, const struct FHitResult& HitResult, bool bPlayFx, bool bPlaySound);
	static bool ProcessHit(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult, const struct FLHitInfo& HitInfo, class ULHitColMgrComponent* LHitColMgrComponent);
	static void PutOnBuff(class AActor* TargetActor, class FName BuffCodeName, class UObject* InInstigator);
	static bool RecordDieCauseHitDirectionBP(class AActor* TargetActor, class AActor* Attacker, EExecutePin* Branches);
	static bool RecreateClothingActors(class AActor* TargetActor);
	static bool RemoveInputActionKeyMapping(class FName InputAction, bool IsGamePad);
	static bool RemoveInputAxisKeyMapping(class FName InputAction, bool IsGamePad);
	static bool ResetInputKeyMapping();
	static class FName SelectCommonActionMontageCodeNameByHitMotionBP(class AActor* TargetActor, ELHitMotionType HitMotionType, ELHitMotionDirectionType HitMotionDirectionType, class FName TryExcludeCodeName, EExecutePin* Branches);
	static void SetAllPhysicsAngularVelocityInRadians(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FVector& NewVel, bool bAddToCurrent);
	static void SetAllPhysicsLinearVelocity(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FVector& NewVel, bool bAddToCurrent);
	static bool SetAxisValueUpperLimit(class AActor* TargetActor, float Limit);
	static void SetCommandConsumed(class FName Command, bool Consumed);
	static void SetFullBodyWhenMoveStopped(class AActor* TargetActor, bool bEnable);
	static bool SetMainAnimFSMState(class AActor* TargetActor, ELAnimFSMState MainAnimFSMState);
	static bool SetMontage_AutoBlendOut(class UAnimInstance* AnimInst, int32 MontageInstanceID, bool UseAutoBlendOut);
	static bool SetMontage_ExpireAllBranchingPointWhenBlendOutStartedBP(class UAnimInstance* AnimInst, int32 MontageInstanceID, bool Value, EExecutePin* Branches);
	static bool SetMontage_NextSection(class UAnimInstance* AnimInst, int32 MontageInstanceID, class FName SectionNameToChange, class FName NextSection);
	static void SetMoveIgnoreMask_Monster(class ACharacter* TargetCharacter, bool Ignore);
	static void SetMoveIgnoreMask_Movement_Related(class ACharacter* TargetCharacter, bool Ignore);
	static bool SetNoSkeletonUpdate(class AActor* TargetActor, bool TurnOff);
	static bool SetPerBoneMotionBlur(class USkinnedMeshComponent* SkinnedMeshComponent, bool TurnOn);
	static void SetStaminaSprintStatus(class AActor* TargetActor, bool Status);
	static bool SetUpdateOverlapsOnAnimationFinalize(class AActor* TargetActor, bool bUpdateOverlap);
	static class ALDynamicDamageVolumeActor* SpawnDynamicDamageVolumeActor(class AActor* Instigator, class FName DynamicDamageVolumeCodeName, const struct FTransform& SpawnTransform);
	static void StartHide(class AActor* TargetActor, bool bUseDissolveEffect);
	static void StopHide(class AActor* TargetActor, bool bUseDissolveEffect);
	static bool StopMontage(class UAnimInstance* AnimInst, int32 MontageInstanceID, float BlendOutTime);
	static ELAngleRangeType SwitchAngleToType(class AActor* TargetActor, float Angle);
	static ELAngleRangeType_2Way SwitchAngleToType_2Way(class AActor* TargetActor, float Angle);
	static ELAngleRangeType_4Way SwitchAngleToType_4Way(class AActor* TargetActor, float Angle);
	static void TakeOffBuff(class AActor* TargetActor, class FName BuffCodeName);
	static void Test_ContentCommand(class FName CommandCodeName);
	static void Test_DeadCharacter(class AActor* TargetActor);
	static void Test_ForceToggleCommmand(class FName ToggleCommand, bool TurnOn);
	static bool UndoLastChangeCharBlockType(class AActor* TargetActor, bool UndoToOrigin);
	static bool UnlockPCActions(const class UObject* WorldContextObject);
	static void UpdateWeaponOnOffByBareHand(class AActor* TargetActor);
	static void WeaponDestructDurabilityDisable(class AActor* Actor, ELWeaponAttachPointType WeaponAttachPoint, bool bUsageGuard);
	static void WeaponDestructDurabilityEnable(class AActor* Actor, ELWeaponAttachPointType WeaponAttackPoint, int32 StartAngle, int32 EndAngle, int32 Distance, bool bUsageGuard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActionUtilFuncLibrary">();
	}
	static class ULActionUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActionUtilFuncLibrary>();
	}
};
static_assert(alignof(ULActionUtilFuncLibrary) == 0x000008, "Wrong alignment on ULActionUtilFuncLibrary");
static_assert(sizeof(ULActionUtilFuncLibrary) == 0x000028, "Wrong size on ULActionUtilFuncLibrary");

// Class ProjectP.LActMgrComponent
// 0x0B50 (0x0C00 - 0x00B0)
class ULActMgrComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x4];                                       // 0x00B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Test_OptionLevel;                                  // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCommandOccurred;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TargetComboTable;                                  // 0x00C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnActionStarted;                                   // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActionStopCalled;                                // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x140];                                    // 0x0160(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              CachedLastStoppedAction;                           // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x20];                                     // 0x02A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULActBase*>                      ActiveActionArray;                                 // 0x02C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class ULActBase*>                      ReusableActionArray;                               // 0x02D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x250];                                    // 0x02E8(0x0250)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBladeWeightInfoPtr                    BladeWeightInfoInHandle;                           // 0x0538(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBladeWeightInfoPtr                    BladeWeightInfoInBlade;                            // 0x0540(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class ULReasonForDeathInfo*                   ReasonForDeathInfo;                                // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0xC];                                      // 0x0550(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GuardRangeAngleStart;                              // 0x055C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_564[0x34];                                     // 0x0564(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLWeaponDestructDurabilityEnable> WeaponDestructDurabilityEnables;                   // 0x0598(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A8[0x40];                                     // 0x05A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGameObjectHandle                     Cached_GlobalMotionSpeedRatioHandle;               // 0x05E8(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Cached_ForceOverrideDieMotionCodeName;             // 0x05EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_ForceOverrideDieMotionCodeName_Selected;    // 0x05F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_LastPlayedHitCommonActionMontage;           // 0x05FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cached_LastPlayedHitCommonActionMontage_Count;     // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFatalAttackResultInfo                Cached_CurrentFatalAttackResultInfo;               // 0x0608(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      Cached_CurrentFatalAttackInfo;                     // 0x0630(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo;                                   // 0x0684(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo_Add;                               // 0x06D8(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C[0x14];                                     // 0x072C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          GuardCmdRaised;                                    // 0x0740(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_741[0x7];                                      // 0x0741(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, class ALHitCollisionDynamic*> HitCollisionDynamicMap;                            // 0x0748(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class UObject*, struct FHitCollisionDynamicArray> HitCollisionDynamicArrayMap;                       // 0x0798(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E8[0x50];                                     // 0x07E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  SkillTarget;                                       // 0x0838(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SkillTargetLocation;                               // 0x0840(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidSkillTargetLocation;                         // 0x084C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84D[0x8B];                                     // 0x084D(0x008B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGrabResultInfo                       CurrentGrabResultInfo;                             // 0x08D8(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class ULActPayload_GrabRelease*               Cached_ActPayload_GrabRelease;                     // 0x0910(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_918[0x2A8];                                    // 0x0918(0x02A8)(Fixing Size After Last Property [ Dumper-7 ])
	class ULComboTableBase*                       CurrComboTable;                                    // 0x0BC0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC8[0x38];                                     // 0x0BC8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddActionState(class FName State, bool UsePair, class UObject* Instigator, class ULActBase* OwnerAction, ELImmuneSourceType ImmuneSourceType, const class FString& DebugInfo);
	struct FLGameObjectHandle AddActionState_AutoRemove(float LifeSpan, class FName State, bool UsePair, class UObject* Instigator, class ULActBase* OwnerAction, ELImmuneSourceType ImmuneSourceType, float ExpirationTime, const class FString& DebugInfo);
	bool AddActionStateArray(const TArray<class FName>& StateArray, bool UsePair, class UObject* Instigator, class ULActBase* OwnerAction, ELImmuneSourceType ImmuneSourceType, const class FString& DebugInfo);
	struct FLGameObjectHandle AddAnimRateScale(ELAnimRateScaleOperationType OperationType, float RateScale, float Duration, class UObject* Instigator, class USkeletalMeshComponent* SkeletalMeshComponent, class UAnimMontage* AnimMontage);
	struct FLGameObjectHandle AddAnimRootMotionTranslationScale(ELAnimRootMotionScaleOperationType OperationType, float RateScale, float Duration, class UObject* Instigator, float RateScale_Vertical, float RateScale_Horizontal);
	struct FLGameObjectHandle AddFxSocketTracer(const struct FLFxSocketTracerInfo& Info, bool StartCheck);
	void AddPreInputCommand(const struct FLReservedCommand& ReservedCommand);
	void AddToHitGroup(class AActor* Victim, int32 HitGroup);
	void BindTransformModifierToAction(class ULActBase* OwnerAction, const struct FLGameObjectHandle& Handle);
	void CachePlayedHitCommonActionMontageCodeName(class FName HitCommonActionMontageCodeName);
	bool CheckFxSocketTracer_Redo(const struct FLGameObjectHandle& Handle);
	bool CheckFxSocketTracer_Stop(const struct FLGameObjectHandle& Handle);
	bool ClearActionState(class FName State);
	void ClearPreInputCommand();
	void FuncForClearPreInputCommand(class UAnimMontage* Montage, bool Interrupted);
	class ULActBase* GetActionFromAssetName(class AActor* TargetActor, class FName BaseActionClassCodeName, class FName AssetName);
	class ULActBase* GetActionFromTable(class AActor* TargetActor, class FName CodeName);
	class ULActBase* GetAvailableAction(class AActor* TargetActor, const TSoftClassPtr<class UClass> Type);
	class ALHitCollisionDynamic* GetDefaultSpawnedGuardCollisionDynamic();
	class ULActBase* GetPlayingAction(const TSoftClassPtr<class UClass> Type);
	class ULAction_SlaveArmVisual* GetSlaveArmActionForVisualActionBP(EExecutePin* Branches);
	void OnBoneTransformsFinalized_ForGrab();
	bool PlayAction_Die(class AActor* TargetActor);
	bool PlayAction_SkillFailed(class AActor* TargetActor, class FName FailedSkillCodeName);
	bool PreProcessCommand(class AActor* TargetActor, class FName Command, const struct FVector& Lever);
	bool ProcessAction(class AActor* TargetActor, class ULActBase* TargetAction, class ULActPayloadBase* Payload);
	class ULActBase* ProcessCommand(class AActor* TargetActor, class FName Command, const struct FVector& Lever, bool SkipCommandPrerequisitiesCheck, float CommandEventTime, bool ForceQueryCommand, bool IsReserved);
	bool QueryNextAction(class AActor* TargetActor, class FName Command, const struct FVector& Lever, class ULActBase* CurrAction, class FName* OutActionClass, struct FLActionInfo* OutActionInfo, class ULActPayloadBase** OutPayload);
	bool RegisterFxSocketTracerEvent(const struct FLGameObjectHandle& Handle, const TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)>& SocketTraceEvent);
	struct FLGameObjectHandle RegisterWatchingCommand(class FName Command, bool CheckReservedCommand, class ULActBase* OwnerAction);
	bool RemoveActionState(class FName State, bool UsePair, class UObject* Instigator, ELImmuneSourceType ImmuneSourceType, bool ValidOnThisFrame);
	void RemoveActionState_AutoRemove(const struct FLGameObjectHandle& Handle);
	bool RemoveActionStateArray(const TArray<class FName>& StateArray, bool UsePair, class UObject* Instigator, ELImmuneSourceType ImmuneSourceType, bool ValidOnThisFrame);
	bool RemoveAllAnimRateScale();
	bool RemoveAllAnimRootMotionTranslationScale();
	bool RemoveAllFxSocketTracer();
	bool RemoveAnimRateScale(const struct FLGameObjectHandle& Handle);
	bool RemoveAnimRateScaleByInstigator(class UObject* Instigator);
	bool RemoveAnimRootMotionTranslationScale(const struct FLGameObjectHandle& Handle);
	bool RemoveAnimRootMotionTranslationScaleByInstigator(class UObject* Instigator);
	bool RemoveFxSocketTracer(const struct FLGameObjectHandle& Handle);
	bool SetComboTable(TSoftClassPtr<class UClass> Type);
	void SetSkillTarget(class AActor* Target);
	void SetSkillTargetLocation(const struct FVector& Location);
	int32 StartMeshRotatingOnFloor(float RotSpeed);
	void StartSkillMove(class FName SkillMoveID, float Duration);
	bool StartSyncTransformToTarget(const struct FLSyncTransformToTargetInfo& Info);
	struct FLGameObjectHandle StartTransformModifier_MoveActor(class AActor* TargetActor, const struct FVector& Movement, float Duration, bool FixedDir, bool UseStepUp, class UCurveVector* MoveCurve, const struct FRotator& MoveRot, bool CheckNavPath, bool InvokeBlockEvent, bool CheckFloor);
	struct FLGameObjectHandle StartTransformModifier_MoveActor_MoveOnly(class AActor* TargetActor, const struct FVector& Movement, float Duration, bool UseStepUp, class UCurveVector* MoveCurve, bool CheckNavPath, float ApplyFakeVelocity, bool InvokeBlockEvent, bool CheckFloor);
	struct FLGameObjectHandle StartTransformModifier_MoveActor_Walking(class AActor* TargetActor, const struct FVector& Movement, float Duration, bool FixedDir, class UCurveVector* MoveCurve, const struct FRotator& MoveRot, bool CheckNavPath, bool CheckFloor);
	struct FLGameObjectHandle StartTransformModifier_MoveActor_Walking_MoveOnly(class AActor* TargetActor, const struct FVector& Movement, float Duration, class UCurveVector* MoveCurve, bool CheckNavPath, float ApplyFakeVelocity, bool CheckFloor);
	struct FLGameObjectHandle StartTransformModifier_MoveActor_Walking_Tracking(class AActor* TargetActor, struct FLTransformModifierInfo_MoveActor_Walking_Tracking* Info);
	struct FLGameObjectHandle StartTransformModifier_RotateActor(class AActor* TargetActor, const struct FRotator& Rot, float Duration, class UCurveFloat* RotSpeedCurve);
	struct FLGameObjectHandle StartTransformModifier_RotateActor_AddYaw(class AActor* TargetActor, float AddYaw, float Duration, class UCurveFloat* RotSpeedCurve);
	struct FLGameObjectHandle StartTransformModifier_RotateActor_ToLocation(class AActor* TargetActor, const struct FVector& FaceToLocation, float Duration);
	struct FLGameObjectHandle StartTransformModifier_RotateActor_ToYaw(class AActor* TargetActor, float FinalYaw, float YawSpeed, float Duration);
	struct FLGameObjectHandle StartTransformModifier_RotateActor_Tracking(class AActor* TargetActor, struct FLTransformModifierInfo_RotateActor_Tracking* Info);
	void StopAction(const TSoftClassPtr<class UClass> Type, class ULActBase* ReasonAction, class FName Reason);
	void StopAllAction(class ULActBase* ReasonAction, class FName Reason, bool IncludeDecorateAction);
	void StopAllTransformModifier(float CompensationTime);
	int32 StopMeshRotatingOnFloor(float RotSpeed, bool StopImmediate);
	void StopSkillMove();
	void StopSyncTransformToTarget();
	void StopTransformModifier(const struct FLGameObjectHandle& Handle, float CompensationTime);
	bool UnregisterFxSocketTracerEvent(const struct FLGameObjectHandle& Handle, const TDelegate<void(class ULActMgrComponent* ActMgrComponent, struct FLFxSocketTracerInfo& SocketTracerInfo, struct FHitResult& HitResult)>& SocketTraceEvent);
	void UnregisterWatchingCommand(const struct FLGameObjectHandle& Handle);

	bool AleadyInHitGroup(class AActor* Victim, int32 HitGroup) const;
	bool CheckLastPlayingActionClass(const TSoftClassPtr<class UClass> Type) const;
	bool FindActionState(class FName State) const;
	bool FindActionStateAny(const TArray<class FName>& StateArray) const;
	int32 GetActionFrameCount() const;
	class ULComboTableBase* GetComboTable() const;
	class ULActBase* GetLastPlayingAction(bool ExceptHitAction, bool IncludeJustStopped, bool ExcludeDecorateAction, bool IncludePendingOnStart) const;
	class ULActBase* GetLastPlayingDecorateAction(bool IncludePendingOnStart) const;
	struct FLReservedCommand GetLastPreInputCommand() const;
	struct FVector GetSkillTargetLocation() const;
	void GetStandGuardRangeAngle(int32* RangeAngleStart, int32* RangeAngleEnd) const;
	bool IsInSkillMove() const;
	bool IsTransformModifierActive(const struct FLGameObjectHandle& Handle) const;
	bool IsValidSkillTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LActMgrComponent">();
	}
	static class ULActMgrComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULActMgrComponent>();
	}
};
static_assert(alignof(ULActMgrComponent) == 0x000008, "Wrong alignment on ULActMgrComponent");
static_assert(sizeof(ULActMgrComponent) == 0x000C00, "Wrong size on ULActMgrComponent");
static_assert(offsetof(ULActMgrComponent, Test_OptionLevel) == 0x0000B4, "Member 'ULActMgrComponent::Test_OptionLevel' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, OnCommandOccurred) == 0x0000B8, "Member 'ULActMgrComponent::OnCommandOccurred' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, TargetComboTable) == 0x0000C8, "Member 'ULActMgrComponent::TargetComboTable' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, OnActionStarted) == 0x000140, "Member 'ULActMgrComponent::OnActionStarted' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, OnActionStopCalled) == 0x000150, "Member 'ULActMgrComponent::OnActionStopCalled' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, CachedLastStoppedAction) == 0x0002A0, "Member 'ULActMgrComponent::CachedLastStoppedAction' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, ActiveActionArray) == 0x0002C8, "Member 'ULActMgrComponent::ActiveActionArray' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, ReusableActionArray) == 0x0002D8, "Member 'ULActMgrComponent::ReusableActionArray' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, BladeWeightInfoInHandle) == 0x000538, "Member 'ULActMgrComponent::BladeWeightInfoInHandle' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, BladeWeightInfoInBlade) == 0x000540, "Member 'ULActMgrComponent::BladeWeightInfoInBlade' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, ReasonForDeathInfo) == 0x000548, "Member 'ULActMgrComponent::ReasonForDeathInfo' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, GuardRangeAngleStart) == 0x00055C, "Member 'ULActMgrComponent::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, GuardRangeAngleEnd) == 0x000560, "Member 'ULActMgrComponent::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, WeaponDestructDurabilityEnables) == 0x000598, "Member 'ULActMgrComponent::WeaponDestructDurabilityEnables' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_GlobalMotionSpeedRatioHandle) == 0x0005E8, "Member 'ULActMgrComponent::Cached_GlobalMotionSpeedRatioHandle' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_ForceOverrideDieMotionCodeName) == 0x0005EC, "Member 'ULActMgrComponent::Cached_ForceOverrideDieMotionCodeName' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_ForceOverrideDieMotionCodeName_Selected) == 0x0005F4, "Member 'ULActMgrComponent::Cached_ForceOverrideDieMotionCodeName_Selected' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_LastPlayedHitCommonActionMontage) == 0x0005FC, "Member 'ULActMgrComponent::Cached_LastPlayedHitCommonActionMontage' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_LastPlayedHitCommonActionMontage_Count) == 0x000604, "Member 'ULActMgrComponent::Cached_LastPlayedHitCommonActionMontage_Count' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_CurrentFatalAttackResultInfo) == 0x000608, "Member 'ULActMgrComponent::Cached_CurrentFatalAttackResultInfo' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_CurrentFatalAttackInfo) == 0x000630, "Member 'ULActMgrComponent::Cached_CurrentFatalAttackInfo' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, FatalAttackInfo) == 0x000684, "Member 'ULActMgrComponent::FatalAttackInfo' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, FatalAttackInfo_Add) == 0x0006D8, "Member 'ULActMgrComponent::FatalAttackInfo_Add' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, GuardCmdRaised) == 0x000740, "Member 'ULActMgrComponent::GuardCmdRaised' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, HitCollisionDynamicMap) == 0x000748, "Member 'ULActMgrComponent::HitCollisionDynamicMap' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, HitCollisionDynamicArrayMap) == 0x000798, "Member 'ULActMgrComponent::HitCollisionDynamicArrayMap' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, SkillTarget) == 0x000838, "Member 'ULActMgrComponent::SkillTarget' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, SkillTargetLocation) == 0x000840, "Member 'ULActMgrComponent::SkillTargetLocation' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, bValidSkillTargetLocation) == 0x00084C, "Member 'ULActMgrComponent::bValidSkillTargetLocation' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, CurrentGrabResultInfo) == 0x0008D8, "Member 'ULActMgrComponent::CurrentGrabResultInfo' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, Cached_ActPayload_GrabRelease) == 0x000910, "Member 'ULActMgrComponent::Cached_ActPayload_GrabRelease' has a wrong offset!");
static_assert(offsetof(ULActMgrComponent, CurrComboTable) == 0x000BC0, "Member 'ULActMgrComponent::CurrComboTable' has a wrong offset!");

// Class ProjectP.LAIController
// 0x0AD0 (0x0DB8 - 0x02E8)
class ALAIController : public AAIController
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSenseApplied;                                    // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         bDebugTargeting : 1;                               // 0x0300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugSkill : 1;                                   // 0x0300(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDebugMovement : 1;                                // 0x0300(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReactivePathFinding : 1;                          // 0x0300(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableCantMove : 1;                               // 0x0300(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CantMoveCheckTime;                                 // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CantMoveRandomMoveTime;                            // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRunningAI : 1;                                    // 0x030C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        MyNavData;                                         // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELAITakeDamageType                            TakeDamageType;                                    // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELAIHitDamageType                             HitDamageType;                                     // 0x0319(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31A[0x2];                                      // 0x031A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitDamageSkillHitCodeName;                         // 0x031C(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELAIRangeCheckFailReason                      RangeCheckFailReason;                              // 0x0324(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_325[0x3];                                      // 0x0325(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLLogicCondition                       LogicCondition;                                    // 0x0328(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<class FString>                           WorldTriggers;                                     // 0x0378(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ALCharacter*                            LCharacter;                                        // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALNPCCharacter*                         OwnerNPC;                                          // 0x03D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x14];                                     // 0x03D8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReserveInitStartAITime;                            // 0x03EC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLAITimer>           Timers;                                            // 0x03F0(0x0050)(Edit, BlueprintVisible, EditConst, Protected, NativeAccessSpecifierProtected)
	class ULBTreeStateMachineData*                BTreeStateMachineData;                             // 0x0440(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLBTreeStateMachine                    BTreeStateMachine;                                 // 0x0448(0x0190)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLNPCTargeting                         Targeting;                                         // 0x05D8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLNPCPerception                        Perception;                                        // 0x0628(0x0130)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         DebugTargetDetectHistory;                          // 0x0758(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLastCanReachTargetResult;                         // 0x0768(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_769[0x3];                                      // 0x0769(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLBBoardKeyBool                        IsSelectSkillBBKey;                                // 0x076C(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_774[0x4];                                      // 0x0774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNPCSkillLauncher                     SkillLauncher;                                     // 0x0778(0x0260)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D8[0x8];                                      // 0x09D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNPCMovement                          Movement;                                          // 0x09E0(0x03C0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLNPCSpecCondActivator                 SpecCondActivator;                                 // 0x0DA0(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddMoveSpeedRate(class FName MoveSpeedRateName, float SpeedRate);
	void AddPauseAI(class FName PauseName, bool bMaintain);
	void BeginPlayControllerBP();
	bool CalculatePathLength(class FName* CalculateName, const struct FVector& StartLocation, const struct FVector& EndLocation, bool bAllowPartialPaths, float* PathLength, struct FVector* DestLocation);
	bool CanReachHome();
	bool CanReachTarget(ELAITargetType TargetType, bool bCheckHeight);
	void ChangeBehaviorTreeState(class FName InStateName);
	void ChangeBehaviorTreeStateForce(class FName InStateName);
	void ChangeCurrentLocationToHomeLocation();
	void ChangeExtraState();
	void ChangeMoveSpeedRate(float Rate);
	void ChangeReverseMoveDirection(bool bReverse);
	bool CheckActionCategoryAndConsume(ELAITargetType TargetType, ELHostileType HostileTargetType, float TargetCheckRange, ELActionCategory CheckActionCategory, const class FName& ActionCategory_AnyCodeName);
	bool CheckMoveReduced(float ThresholdMoveAmount, float HoldingTime);
	bool CheckOnceCondition(class FName ConditionName);
	bool CheckSelectedSkillRangeAngle(class AActor* CheckActor, ELAIRangeMinMaxType MinMaxType, bool bCheckDistance, bool bCheckAngle, bool bCheckHeight, ELAIRangeCheckType OverrideRangeCheckType);
	bool CheckSkillApproachDist(class AActor* CheckActor, ELAIRangeMinMaxType MinMaxType, float MinDist, float MaxDist);
	bool CheckSkillUseCount(ELAIUseSkillCountType UseSkillCountType, int32 Count);
	bool CheckTargetAngleDeviation(const struct FVector& TargetLocation, int32 DeviationAngle);
	bool CheckTargetRangeHeightAngleDist_PrimaryAngle(float MinRange, float MaxRange, int32 BeginDegree, int32 EndDegree, float CheckHeight, ELAIRangeCheckType RangeCheckType, float PrimaryTarget_StartAngle, float PrimaryTarget_EndAngle, float OverrideTargetToSelf_Angle, float OverrideTargetToSelf_Distance);
	bool CheckTargetRangeInAround(ELAIActorClassType ActorClassType, float CheckDistance, ELHostileType TargetHostileType, class FName TargetCodeName);
	bool CheckWorldTriggerVolatile(const class FString& TriggerName);
	bool ChooseUseSkill(bool bCheckRange, bool bCheckAngle, ELAIRangeMinMaxType RangeMinMaxType, const TArray<struct FLNPCStandbySkill>& CustomSkillList, bool bReselectIncludeCooltime);
	void ContinueSkill(class FName SkillCodeName, bool bUseSkillCooltime);
	void DoTeleport(ELAITargetType LocationTargetType, ELAITargetType DirectionTargetType, ELAIDirectionType DirectionType, const struct FLFloatInterval& Distance, const struct FLFloatInterval& Angle);
	void EndPlayControllerBP();
	void ExecuteSkillTask(class FName SkillCodeName, bool bUseSkillCooltime, bool bUseGlobalCooltime, bool bCheckCooltime, bool bCheckGlobalCooltime, bool bForceExecute, struct FLNPCSkillLaunchResult* OutResult);
	class UBehaviorTree* GetCurrentBehaviorTree();
	struct FVector GetHomeLocation();
	class FName GetLastUsedSkillCodeName();
	class AActor* GetMasterActor();
	struct FNPCInfoPtr GetNpcInfo();
	class AActor* GetPrimaryTarget();
	bool GetRandomPointInStrafe(class AActor* TargetActor, float MinDistance, float MaxDistance, float MinAngle, float MaxAngle, struct FVector* RandomLocation, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	class FName GetSelectedSkillCodeName();
	struct FVector GetWarningLocation();
	bool HasMoveGoalReached(const struct FLAIMovementGoal& Goal, bool bProjectPoint, float CustumAcceptibleRadius);
	bool HasMoveReached(const struct FLAIObjective& Target, bool bProjectPoint, float CustumAcceptibleRadius);
	void InitBehaviorTree(class UBehaviorTree* BTree);
	void InitBehaviorTreeState(class FName InStateName);
	void InitStartAI();
	bool IsApplyBoostAI();
	bool IsExistDamageEvent();
	bool IsLaunchSkill(class ULActBase* Action);
	bool IsPathWayMoving();
	bool IsSkillCooltime(class FName SkillId);
	bool IsSkillGlobalCooltime();
	bool IsStrafeMove();
	bool IsWaitOrFinishWayPoint();
	void ManipulateTimer(class FName TimerCodeName, ELAITimerFunctionType FunctionType);
	void ModifyCooltime(ELModifyCooltimeChangeType ChangeType, ELModifyCooltimeTargetType TargetType, const TArray<class FName>& SkillCodeNames, bool bExceptSkillCodeNames, ELAIFloatValueType ValueType, float CoolTime);
	struct FLAIMovementID MoveToGoal(const struct FLAIMovementID& CurrMovementID, const struct FLAIMovementGoal& Goal, const struct FLAIMovementDirection& Direction);
	struct FLAIMoveBehaviorID MoveToPosition(const struct FLAIMovementGoal& Goal, float RotationRate, bool bUseTurnAround, int32 RotateAngleOverride, ELAIMoveSpeedType MoveSpeedType, float MoveSpeed, float RotationCooltime);
	struct FLAIMoveBehaviorID MoveToPositionBack(const struct FLAIMovementGoal& Goal, float RotationRate, ELAIMoveSpeedType MoveSpeedType, float MoveSpeed);
	struct FLAIMovementID MoveToRandomRoamSelf(const struct FLAIMovementID& CurrMovementID, ELAIDirectionType DirectionType, float Distance);
	struct FLAIMovementID MoveToRandomRoamStrafe(const struct FLAIMovementID& CurrMovementID, ELAIDirectionType DirectionType, class AActor* TargetActor, float MinDistance, float MaxDistance, float MinAngle, float MaxAngle);
	struct FLAIMovementID MoveToSkill(const struct FLAIMovementID& CurrMovementID, ELAITargetType TargetType, ELAIDirectionType DirectionType);
	struct FLAIMoveBehaviorID MoveToStrafe(ELAIMoveDirection MoveDirection, float MoveTime, ELAIMoveSpeedType MoveSpeedType, float MoveSpeed);
	struct FLAIMovementID MoveToType(const struct FLAIMovementID& CurrMovementID, ELAITargetType TargetType, ELAIDirectionType DirectionType);
	void OnMovementNavigationQueryFilter(TSubclassOf<class UNavigationQueryFilter>* FilterClass);
	bool QueryTargetCondition(ELQueryTargetConditionType ConditionType);
	void RemoveMoveSpeedRate(class FName MoveSpeedRateName);
	void RemovePauseAI(class FName PauseName, bool bMaintain);
	void RequestMoveToWayPoint(class FName PathWayCodeName, int32 RotateActionDeviationAngle, ELAIMoveSpeedType MoveSpeedType, float MoveSpeedRate);
	void ResetSelectedSkill();
	void ResetTarget();
	void SendWorldTrigger(ELAISendWorldTriggerType TriggerType, const class FString& TriggerString, float SendRadius, class FName NPCCodeName);
	void SenseEvent(const struct FLAISenseTakeLocation& TakeLocation);
	void SetForcePrimaryTarget(class AActor* TargetActor);
	void SetRotationCooltime(float CoolTime);
	void SetSenseEnabled(ELAISense Sense, bool bEnable);
	void SetSkillGlobalCooltime(float Min, float Max);
	void SetSkillList(const TArray<struct FLNPCStandbySkill>& SkillList, bool bResetSkillCooltime);
	bool Sight_Check(class AActor* Actor, float AddSightDistance);
	void StartAI();
	void StopAI();
	void StopLastMovement();
	void UnChangeExtraState();
	void UpdatePauseLogic();
	void UseSkill(class FName SkillId, bool bUseSkillCooltime, bool bUseGlobalCooltime, bool bForceToLaunch, struct FLNPCSkillLaunchResult* OutResult);
	class ULActBase* UseSkillForce(class FName SkillId, bool bUseSkillCooltime, bool bUseGlobalCooltime);

	bool FindPause(class FName PauseName) const;
	bool FindPauseMetaName(class FName MetaName) const;
	bool FindPauseOnlyMetaName(class FName MetaName) const;
	float GetElapsedTimer(class FName TimerCodeName) const;
	float GetGlobalSkillCooltime() const;
	struct FVector GetLastMoveDestLocation() const;
	struct FLAIMovementID GetLastMovementID() const;
	const class ANavigationData* GetNavData() const;
	float GetRotationCooltime() const;
	float GetSelectedSkillApproachDist() const;
	const TMap<class FName, float> GetSkillCooltimes() const;
	bool GetSkillTargetLocation(struct FVector* Location) const;
	int32 GetTargetNearAllyNum(bool bCheckDistance) const;
	bool IsMasterExist() const;
	bool IsMoveBlocking() const;
	bool IsMoving() const;
	bool IsPauseAI() const;
	bool IsRequestMovement(const struct FLAIMovementID& MovementID) const;
	bool IsRunningAI() const;
	bool IsRunningMoveBehavior(const struct FLAIMoveBehaviorID& BehaviorID) const;
	bool IsSkillMoveApproachDistReached() const;
	bool IsTargetExist() const;
	bool IsTicketMove() const;
	bool IsWarningExist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAIController">();
	}
	static class ALAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALAIController>();
	}
};
static_assert(alignof(ALAIController) == 0x000008, "Wrong alignment on ALAIController");
static_assert(sizeof(ALAIController) == 0x000DB8, "Wrong size on ALAIController");
static_assert(offsetof(ALAIController, OnSenseApplied) == 0x0002F0, "Member 'ALAIController::OnSenseApplied' has a wrong offset!");
static_assert(offsetof(ALAIController, CantMoveCheckTime) == 0x000304, "Member 'ALAIController::CantMoveCheckTime' has a wrong offset!");
static_assert(offsetof(ALAIController, CantMoveRandomMoveTime) == 0x000308, "Member 'ALAIController::CantMoveRandomMoveTime' has a wrong offset!");
static_assert(offsetof(ALAIController, MyNavData) == 0x000310, "Member 'ALAIController::MyNavData' has a wrong offset!");
static_assert(offsetof(ALAIController, TakeDamageType) == 0x000318, "Member 'ALAIController::TakeDamageType' has a wrong offset!");
static_assert(offsetof(ALAIController, HitDamageType) == 0x000319, "Member 'ALAIController::HitDamageType' has a wrong offset!");
static_assert(offsetof(ALAIController, HitDamageSkillHitCodeName) == 0x00031C, "Member 'ALAIController::HitDamageSkillHitCodeName' has a wrong offset!");
static_assert(offsetof(ALAIController, RangeCheckFailReason) == 0x000324, "Member 'ALAIController::RangeCheckFailReason' has a wrong offset!");
static_assert(offsetof(ALAIController, LogicCondition) == 0x000328, "Member 'ALAIController::LogicCondition' has a wrong offset!");
static_assert(offsetof(ALAIController, WorldTriggers) == 0x000378, "Member 'ALAIController::WorldTriggers' has a wrong offset!");
static_assert(offsetof(ALAIController, LCharacter) == 0x0003C8, "Member 'ALAIController::LCharacter' has a wrong offset!");
static_assert(offsetof(ALAIController, OwnerNPC) == 0x0003D0, "Member 'ALAIController::OwnerNPC' has a wrong offset!");
static_assert(offsetof(ALAIController, ReserveInitStartAITime) == 0x0003EC, "Member 'ALAIController::ReserveInitStartAITime' has a wrong offset!");
static_assert(offsetof(ALAIController, Timers) == 0x0003F0, "Member 'ALAIController::Timers' has a wrong offset!");
static_assert(offsetof(ALAIController, BTreeStateMachineData) == 0x000440, "Member 'ALAIController::BTreeStateMachineData' has a wrong offset!");
static_assert(offsetof(ALAIController, BTreeStateMachine) == 0x000448, "Member 'ALAIController::BTreeStateMachine' has a wrong offset!");
static_assert(offsetof(ALAIController, Targeting) == 0x0005D8, "Member 'ALAIController::Targeting' has a wrong offset!");
static_assert(offsetof(ALAIController, Perception) == 0x000628, "Member 'ALAIController::Perception' has a wrong offset!");
static_assert(offsetof(ALAIController, DebugTargetDetectHistory) == 0x000758, "Member 'ALAIController::DebugTargetDetectHistory' has a wrong offset!");
static_assert(offsetof(ALAIController, bLastCanReachTargetResult) == 0x000768, "Member 'ALAIController::bLastCanReachTargetResult' has a wrong offset!");
static_assert(offsetof(ALAIController, IsSelectSkillBBKey) == 0x00076C, "Member 'ALAIController::IsSelectSkillBBKey' has a wrong offset!");
static_assert(offsetof(ALAIController, SkillLauncher) == 0x000778, "Member 'ALAIController::SkillLauncher' has a wrong offset!");
static_assert(offsetof(ALAIController, Movement) == 0x0009E0, "Member 'ALAIController::Movement' has a wrong offset!");
static_assert(offsetof(ALAIController, SpecCondActivator) == 0x000DA0, "Member 'ALAIController::SpecCondActivator' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_TimedNiagaraEffect
// 0x0130 (0x0190 - 0x0060)
class ULAnimNotifyState_TimedNiagaraEffect final : public UAnimNotifyState_TimedNiagaraEffect
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseAbsoluteRotation;                               // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x006C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AttachedComponent;                                 // 0x0078(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0088(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x0098(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x00E8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0138(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0188(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_TimedNiagaraEffect">();
	}
	static class ULAnimNotifyState_TimedNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_TimedNiagaraEffect>();
	}
};
static_assert(alignof(ULAnimNotifyState_TimedNiagaraEffect) == 0x000008, "Wrong alignment on ULAnimNotifyState_TimedNiagaraEffect");
static_assert(sizeof(ULAnimNotifyState_TimedNiagaraEffect) == 0x000190, "Wrong size on ULAnimNotifyState_TimedNiagaraEffect");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, UseAbsoluteRotation) == 0x000068, "Member 'ULAnimNotifyState_TimedNiagaraEffect::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, bAttached) == 0x000069, "Member 'ULAnimNotifyState_TimedNiagaraEffect::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, Scale) == 0x00006C, "Member 'ULAnimNotifyState_TimedNiagaraEffect::Scale' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, AttachedComponent) == 0x000078, "Member 'ULAnimNotifyState_TimedNiagaraEffect::AttachedComponent' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, Enabled) == 0x000080, "Member 'ULAnimNotifyState_TimedNiagaraEffect::Enabled' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, DisableWhenWeaponInListBroken) == 0x000088, "Member 'ULAnimNotifyState_TimedNiagaraEffect::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, ApplyVariableFloat) == 0x000098, "Member 'ULAnimNotifyState_TimedNiagaraEffect::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, ApplyVariableVector2) == 0x0000E8, "Member 'ULAnimNotifyState_TimedNiagaraEffect::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, ApplyVariableVector3) == 0x000138, "Member 'ULAnimNotifyState_TimedNiagaraEffect::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedNiagaraEffect, MeshSelectionType) == 0x000188, "Member 'ULAnimNotifyState_TimedNiagaraEffect::MeshSelectionType' has a wrong offset!");

// Class ProjectP.LAIUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULAIUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddPauseAI(class AActor* Actor, class FName PauseName, bool bMaintain);
	static bool CanMoveToLocation_Nav(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, struct FVector* HitLocation);
	static bool CanMoveToLocation_Trace(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, bool bSubtractTargetCapsuleSize);
	static bool CheckAngleBetween(const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, const struct FVector& TargetLocation, int32 BeginDegree, int32 EndDegree);
	static bool CheckAngleBetweenActor(class AActor* CriterionActor, class AActor* TargetActor, int32 BeginDegree, int32 EndDegree);
	static bool CheckAngleBetweenDeviation(const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, const struct FVector& TargetLocation, int32 DeviationAngle);
	static bool CheckBackSideLocation2D(class AActor* CriterionActor, class AActor* AroundActor);
	static bool CheckEnemyAttack(class AActor* EnemyActor);
	static bool CheckHostileType(class AActor* CriterionActor, class AActor* TargetActor, ELHostileType HostileType);
	static bool CheckInCameraView(class AActor* Target, float Distance);
	static bool CheckInsideDistance(const struct FVector& P1, const struct FVector& P2, float InsideLength);
	static bool CheckInsideDistance2D(const struct FVector& P1, const struct FVector& P2, float InsideLength);
	static bool CheckInsideDistance2DAndHeight(const struct FVector& P1, const struct FVector& P2, float InsideLength, float InsideHeight);
	static bool CheckInsidePathDistance(class AActor* CriterionActor, class AActor* AroundActor, float InsideLength, class FName CacheName);
	static bool CheckMoveHeight(class ALCharacter* Character, const struct FVector& TraceDelta, bool bDebug);
	static bool CheckPathDirect(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static bool CheckPathDirectNavi(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static bool CheckPathDirectNavi_Lagacy(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType);
	static bool CheckPathDirectProjectile(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static bool CheckPathNavi(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static bool CheckRangeAngleBetween(const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, const struct FVector& TargetLocation, float MinRange, float MaxRange, int32 BeginDegree, int32 EndDegree);
	static bool CheckRangeBetween(const struct FVector& CriterionLocation, const struct FVector& TargetLocation, float MinRange, float MaxRange);
	static bool CheckRangeBetweenActor(class AActor* CriterionActor, class AActor* TargetActor, float MinRange, float MaxRange);
	static bool CheckTargetAngle(const struct FLAICheckOwner& CheckOwner, const struct FVector& TargetLocation, int32 BeginDegree, int32 EndDegree);
	static bool CheckTargetHeight(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float Height);
	static bool CheckTargetRangeHeightAngleDist(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float CheckHeight, int32 BeginDegree, int32 EndDegree, float MinRange, float MaxRange, ELAIRangeCheckType RangeCheckType, ELAIRangeCheckFailReason* FailReason);
	static bool CheckTargetRangeType(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, ELAIRangeCheckType RangeCheckType, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static bool CollideCeiling(const struct FLAICheckOwner& CheckOwner, float CheckHeight);
	static struct FLAIMovementDirection DirectionAsActor(class AActor* Actor);
	static struct FLAIMovementDirection DirectionAsLocation(const struct FVector& Location);
	static struct FLAIMovementDirection DirectionAsType(class ALAIController* Controller, ELAIDirectionType DirectionType);
	static void EmptyMovementID(struct FLAIMovementID& MovementID);
	static struct FVector GetAgentDeltaLocation(class ACharacter* Character);
	static class ALNPCController* GetAIController(class AActor* Actor);
	static bool GetAIEnabled(const class UObject* WorldContextObject);
	static struct FVector GetBlackboardValueAsLocation(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key);
	static float GetRandomInInterval(const struct FLFloatInterval& Interval);
	static bool GetRandomLocation(struct FLAILocationSampler& Sampler, struct FVector* Location);
	static bool GetRandomLocationCriterionDistanceAngle(struct FLAILocationSampler& Sampler, struct FVector* Location, const struct FVector& CriterionLocation, const struct FRotator& CriterionRotation, float MinDistance, float MaxDistance, float BeginAngle, float EndAngle);
	static bool GetRandomLocationInDistance(struct FLAILocationSampler& Sampler, struct FVector* Location, float Distance);
	static bool GetRandomLocationTargetBaseDistanceAngle(struct FLAILocationSampler& Sampler, struct FVector* Location, const struct FLAIObjective& Target, float MinDistance, float MaxDistance, float BeginAngle, float EndAngle, float TraceHeight);
	static struct FVector GetReachedCylinderExtent(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float OwnerRadiusScaleFactor);
	static struct FVector GetTraceCharacterMoveObstacleStartLocation(class ALCharacter* Character);
	static void GetTraceStartEndLocation(struct FVector* StartTrace, struct FVector* EndTrace, const struct FLAIObjective& StartActor, const struct FLAIObjective& EndActor);
	static struct FLAIMovementGoal GoalAsActor(class AActor* Actor);
	static struct FLAIMovementGoal GoalAsLocation(const struct FVector& Location);
	static struct FLAIMovementGoal GoalAsType(class ALAIController* Controller, ELAITargetType TargetType);
	static bool IsAttackable(class AActor* CriterionActor, class AActor* TargetActor);
	static bool IsEnemy(class AActor* CriterionActor, class AActor* TargetActor);
	static bool IsEnemyFaction(EFactionType CritrionFaction, EFactionType TargetFaction);
	static bool IsInsideCylinder(const struct FVector& CylinderExtent, const struct FVector& CylinderOrigin, const struct FVector& TargetLocation);
	static bool IsMonsterFactionActor(class AActor* TargetActor);
	static class AActor* MovementDirectionGetActor(const struct FLAIMovementDirection& MovementDirection);
	static class ALCharacter* MovementDirectionGetCharacter(const struct FLAIMovementDirection& MovementDirection);
	static struct FVector MovementDirectionGetLocation(const struct FLAIMovementDirection& MovementDirection);
	static struct FRotator MovementDirectionGetRotation(const struct FLAIMovementDirection& MovementDirection);
	static bool MovementDirectionIsValid(const struct FLAIMovementDirection& MovementDirection);
	static class AActor* MovementGoalGetActor(const struct FLAIMovementGoal& MovementGoal);
	static class ALCharacter* MovementGoalGetCharacter(const struct FLAIMovementGoal& MovementGoal);
	static struct FVector MovementGoalGetLocation(const struct FLAIMovementGoal& MovementGoal);
	static struct FRotator MovementGoalGetRotation(const struct FLAIMovementGoal& MovementGoal);
	static bool MovementGoalIsValid(const struct FLAIMovementGoal& MovementGoal);
	static void MovementGoalSetCustomArriveDistance(struct FLAIMovementGoal& MovementGoal, float ArriveDistance);
	static struct FLAIObjective ObjectiveAsActor(class AActor* Actor);
	static struct FLAIObjective ObjectiveAsLocation(const struct FVector& Location);
	static struct FLAIObjective ObjectiveAsType(class ALAIController* Controller, ELAITargetType TargetType);
	static class AActor* ObjectiveGetActor(const struct FLAIObjective& Objective);
	static struct FVector ObjectiveGetAgentLocation(const struct FLAIObjective& Objective);
	static class ALCharacter* ObjectiveGetCharacter(const struct FLAIObjective& Objective);
	static struct FVector ObjectiveGetLocation(const struct FLAIObjective& Objective);
	static struct FRotator ObjectiveGetRotation(const struct FLAIObjective& Objective);
	static bool ObjectiveIsValid(const struct FLAIObjective& Objective);
	static bool PropagationTest(class AActor* CriterionActor, const struct FVector& AroundLocation, float InsideLength, class FName CacheName, bool bTestVertAndHoriTrace);
	static bool RangeCheck_AllDistance(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static bool RangeCheck_Distance2D(const struct FLAICheckOwner& CheckOwner, const struct FLAIObjective& CheckTarget, float MinRange, float MaxRange, ELAIRangeMinMaxType MinMaxType, ELAIRangeCheckFailReason* FailReason);
	static void RemovePauseAI(class AActor* Actor, class FName PauseName, bool bMaintain);
	static bool SampleLocations(struct FLAILocationSampler& Sampler, class ALAIController* Querier, const struct FVector& SampleOrigin, float ReSampleDistance, float SampleDistance, float SpaceBetween);
	static void SetAIEnabled(const class UObject* WorldContextObject, bool bEnable);
	static bool TestCanWalkOnNavi(class ALCharacter* Character, const struct FVector& Start, const struct FVector& End);
	static void TraceMidpointWall(bool* bHasWall, bool* bHasMidpointWall, bool bDebug, class AActor* CheckOwner, const struct FVector& TraceStart, const struct FVector& TraceEnd, const struct FVector& GoalLocation);
	static void UpdateAIEnabled(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAIUtilFuncLibrary">();
	}
	static class ULAIUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAIUtilFuncLibrary>();
	}
};
static_assert(alignof(ULAIUtilFuncLibrary) == 0x000008, "Wrong alignment on ULAIUtilFuncLibrary");
static_assert(sizeof(ULAIUtilFuncLibrary) == 0x000028, "Wrong size on ULAIUtilFuncLibrary");

// Class ProjectP.LAnimInstance
// 0x0430 (0x06F0 - 0x02C0)
class ULAnimInstance : public UAnimInstance
{
public:
	uint8                                         bDebug : 1;                                        // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReflectOnlyInputVelocity : 1;                     // 0x02B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnregisterdAnimInstance : 1;                      // 0x02B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsStatRoomCharacter : 1;                           // 0x02B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsPlayingAction : 1;                              // 0x02B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFloatingState : 1;                              // 0x02B8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableFootIK : 1;                                 // 0x02B8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              HitAdditiveDirection;                              // 0x02BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMainAnimFSMData                       MainFSMData;                                       // 0x02C4(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         FootIKAlpha;                                       // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditivePlayRate;                                  // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMoveBasedRootMotion                  MoveBasedRootMotion;                               // 0x0358(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLDefinedBoneNames                     BoneNames;                                         // 0x0380(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         LookAtType;                                        // 0x03D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLAnimLookAtHead                       LookAtHead;                                        // 0x03D4(0x007C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FLAnimLookAtUpperBody                  LookAtUpperBody;                                   // 0x0450(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLInverseKinemetic>             IKList;                                            // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDialoging : 1;                                    // 0x04A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMontageSlotBlend                     MontageSlotBlend;                                  // 0x04A4(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLStretchBoneList                      StretchBones;                                      // 0x04C0(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FLDebugOption_Movement                 Debug_Option;                                      // 0x0510(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLPhysicsAssetForRigidBodyNode> PhysicsAssetForRigidBodyNodeArray;                 // 0x0558(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLAnimStateMachineInfo> Debug_WatchMachine;                                // 0x0568(0x0050)(Edit, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecvAnimFSMCallback;                             // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnimFSM_StateEntry;                              // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAnimFSM_StateExit;                               // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E8[0x50];                                     // 0x05E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Cached_BoneToMinimizeArray;                        // 0x0638(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneToMinimizeArray;                               // 0x0648(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   BodyMeshLibrary;                                   // 0x0658(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         BodyMeshLibrary_Cached_Index;                      // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class USkeletalMesh>>   HairMeshLibrary;                                   // 0x0670(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         HairMeshLibrary_Cached_Index;                      // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FLAnimStateMachineInfo> BindingAnimFSMInfoMap;                             // 0x0688(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D8[0x18];                                     // 0x06D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindAnimFSMEvent(class FName MachineName, const TArray<class FName>& StateNameArray);
	void DecreaseStretchBoneAll();
	void DoRagdollFreezeEnable(bool Enable);
	struct FTransform GetEmptyBoneRotation(class FName BoneName, ERelativeTransformSpace TransformSpace);
	struct FRotator GetOwnerBaseRotation(const struct FRotator& Rotation);
	void OnGraphStateChanged_Entry(const struct FAnimNode_StateMachine& Machine, int32 PrevStateIndex, int32 NextStateIndex, class FName MachineName);
	void OnGraphStateChanged_Exit(const struct FAnimNode_StateMachine& Machine, int32 PrevStateIndex, int32 NextStateIndex, class FName MachineName);
	class UAnimMontage* PlaySlotStartLoopEndAnimationAsDynamicMontage(class FName SlotNodeName, class UAnimSequenceBase* StartAsset, class UAnimSequenceBase* LoopAsset, class UAnimSequenceBase* EndAsset, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	void SetAdditiveHitFlipFlop();
	void SetAdditiveHitType(ELAdditiveHitType AdditiveHitType);
	void SetSequenceBindingPlaying(bool InPlaying);

	bool GetAnimSwitchOnOff(class FName SwitchName) const;
	const struct FLDefinedBoneNames GetBoneNames() const;
	struct FLRigStretchBone GetRigStretchBoneDistance(class FName BoneName) const;
	float GetStretchBoneDistance(class FName BoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimInstance">();
	}
	static class ULAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimInstance>();
	}
};
static_assert(alignof(ULAnimInstance) == 0x000010, "Wrong alignment on ULAnimInstance");
static_assert(sizeof(ULAnimInstance) == 0x0006F0, "Wrong size on ULAnimInstance");
static_assert(offsetof(ULAnimInstance, HitAdditiveDirection) == 0x0002BC, "Member 'ULAnimInstance::HitAdditiveDirection' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, MainFSMData) == 0x0002C4, "Member 'ULAnimInstance::MainFSMData' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, FootIKAlpha) == 0x00034C, "Member 'ULAnimInstance::FootIKAlpha' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, AdditivePlayRate) == 0x000350, "Member 'ULAnimInstance::AdditivePlayRate' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, MoveBasedRootMotion) == 0x000358, "Member 'ULAnimInstance::MoveBasedRootMotion' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, BoneNames) == 0x000380, "Member 'ULAnimInstance::BoneNames' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, LookAtType) == 0x0003D0, "Member 'ULAnimInstance::LookAtType' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, LookAtHead) == 0x0003D4, "Member 'ULAnimInstance::LookAtHead' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, LookAtUpperBody) == 0x000450, "Member 'ULAnimInstance::LookAtUpperBody' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, IKList) == 0x000490, "Member 'ULAnimInstance::IKList' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, MontageSlotBlend) == 0x0004A4, "Member 'ULAnimInstance::MontageSlotBlend' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, StretchBones) == 0x0004C0, "Member 'ULAnimInstance::StretchBones' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, Debug_Option) == 0x000510, "Member 'ULAnimInstance::Debug_Option' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, PhysicsAssetForRigidBodyNodeArray) == 0x000558, "Member 'ULAnimInstance::PhysicsAssetForRigidBodyNodeArray' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, Debug_WatchMachine) == 0x000568, "Member 'ULAnimInstance::Debug_WatchMachine' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, OnRecvAnimFSMCallback) == 0x0005B8, "Member 'ULAnimInstance::OnRecvAnimFSMCallback' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, OnAnimFSM_StateEntry) == 0x0005C8, "Member 'ULAnimInstance::OnAnimFSM_StateEntry' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, OnAnimFSM_StateExit) == 0x0005D8, "Member 'ULAnimInstance::OnAnimFSM_StateExit' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, Cached_BoneToMinimizeArray) == 0x000638, "Member 'ULAnimInstance::Cached_BoneToMinimizeArray' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, BoneToMinimizeArray) == 0x000648, "Member 'ULAnimInstance::BoneToMinimizeArray' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, BodyMeshLibrary) == 0x000658, "Member 'ULAnimInstance::BodyMeshLibrary' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, BodyMeshLibrary_Cached_Index) == 0x000668, "Member 'ULAnimInstance::BodyMeshLibrary_Cached_Index' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, HairMeshLibrary) == 0x000670, "Member 'ULAnimInstance::HairMeshLibrary' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, HairMeshLibrary_Cached_Index) == 0x000680, "Member 'ULAnimInstance::HairMeshLibrary_Cached_Index' has a wrong offset!");
static_assert(offsetof(ULAnimInstance, BindingAnimFSMInfoMap) == 0x000688, "Member 'ULAnimInstance::BindingAnimFSMInfoMap' has a wrong offset!");

// Class ProjectP.LAnimNotify_Consume_Item
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_Consume_Item final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_Consume_Item">();
	}
	static class ULAnimNotify_Consume_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_Consume_Item>();
	}
};
static_assert(alignof(ULAnimNotify_Consume_Item) == 0x000008, "Wrong alignment on ULAnimNotify_Consume_Item");
static_assert(sizeof(ULAnimNotify_Consume_Item) == 0x000048, "Wrong size on ULAnimNotify_Consume_Item");

// Class ProjectP.LIKUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULIKUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void FootIK_CalcuateOffset(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, struct FLFootIKContext& FootIKContext, float DeltaTime);
	static void FootIK_GetPelvisOffset(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, const TArray<struct FLFootIKContext>& FootIKContexts, float DeltaTime);
	static void FootIK_Trace(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, struct FLFootIKContext& FootIKContext, float DeltaTime);
	static void IK_Update(class ULAnimInstance* AnimInstance, struct FLInverseKinemetic& IK, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LIKUtilFuncLibrary">();
	}
	static class ULIKUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULIKUtilFuncLibrary>();
	}
};
static_assert(alignof(ULIKUtilFuncLibrary) == 0x000008, "Wrong alignment on ULIKUtilFuncLibrary");
static_assert(sizeof(ULIKUtilFuncLibrary) == 0x000028, "Wrong size on ULIKUtilFuncLibrary");

// Class ProjectP.LAnimNotifyState_Trail_Inner
// 0x0038 (0x0068 - 0x0030)
class ULAnimNotifyState_Trail_Inner : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        PSTemplate;                                        // 0x0038(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 AttachedComponent;                                 // 0x0040(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FirstSocketName;                                   // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SecondSocketName;                                  // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Enabled;                                           // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidthScaleCurve;                                   // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecycleSpawnedSystems : 1;                        // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UParticleSystem* OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Trail_Inner">();
	}
	static class ULAnimNotifyState_Trail_Inner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Trail_Inner>();
	}
};
static_assert(alignof(ULAnimNotifyState_Trail_Inner) == 0x000008, "Wrong alignment on ULAnimNotifyState_Trail_Inner");
static_assert(sizeof(ULAnimNotifyState_Trail_Inner) == 0x000068, "Wrong size on ULAnimNotifyState_Trail_Inner");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, PSTemplate) == 0x000038, "Member 'ULAnimNotifyState_Trail_Inner::PSTemplate' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, AttachedComponent) == 0x000040, "Member 'ULAnimNotifyState_Trail_Inner::AttachedComponent' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, FirstSocketName) == 0x000048, "Member 'ULAnimNotifyState_Trail_Inner::FirstSocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, SecondSocketName) == 0x000050, "Member 'ULAnimNotifyState_Trail_Inner::SecondSocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, Enabled) == 0x000058, "Member 'ULAnimNotifyState_Trail_Inner::Enabled' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, WidthScaleMode) == 0x000059, "Member 'ULAnimNotifyState_Trail_Inner::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Trail_Inner, WidthScaleCurve) == 0x00005C, "Member 'ULAnimNotifyState_Trail_Inner::WidthScaleCurve' has a wrong offset!");

// Class ProjectP.LAnimNotify_MaterialVaryingDecal
// 0x0048 (0x0090 - 0x0048)
class ULAnimNotify_MaterialVaryingDecal final : public ULAnimNotifyBase
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x006C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRandomRotate;                                   // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_MaterialVaryingDecal">();
	}
	static class ULAnimNotify_MaterialVaryingDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_MaterialVaryingDecal>();
	}
};
static_assert(alignof(ULAnimNotify_MaterialVaryingDecal) == 0x000008, "Wrong alignment on ULAnimNotify_MaterialVaryingDecal");
static_assert(sizeof(ULAnimNotify_MaterialVaryingDecal) == 0x000090, "Wrong size on ULAnimNotify_MaterialVaryingDecal");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, MaterialVarying) == 0x000048, "Member 'ULAnimNotify_MaterialVaryingDecal::MaterialVarying' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, PlayType) == 0x000050, "Member 'ULAnimNotify_MaterialVaryingDecal::PlayType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, LocationOffset) == 0x000054, "Member 'ULAnimNotify_MaterialVaryingDecal::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, RotationOffset) == 0x000060, "Member 'ULAnimNotify_MaterialVaryingDecal::RotationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, DecalSize) == 0x00006C, "Member 'ULAnimNotify_MaterialVaryingDecal::DecalSize' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, UseRandomRotate) == 0x000078, "Member 'ULAnimNotify_MaterialVaryingDecal::UseRandomRotate' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialVaryingDecal, DisableWhenWeaponInListBroken) == 0x000080, "Member 'ULAnimNotify_MaterialVaryingDecal::DisableWhenWeaponInListBroken' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_CommonTrail
// 0x0088 (0x00F0 - 0x0068)
class ULAnimNotifyState_CommonTrail final : public ULAnimNotifyState_Trail_Inner
{
public:
	uint8                                         UseBladeTrail : 1;                                 // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Test_WeaponBreak : 1;                              // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLBladeTrailType                       TestBladeTrailType;                                // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Normal_FirstSocketName;                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Normal_SecondSocketName;                           // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Break_FirstSocketName;                             // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Break_SecondSocketName;                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELTrailConditionType, class UParticleSystem*> TrailList;                                         // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELTrailConditionType                          Test_Condition;                                    // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_CommonTrail">();
	}
	static class ULAnimNotifyState_CommonTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_CommonTrail>();
	}
};
static_assert(alignof(ULAnimNotifyState_CommonTrail) == 0x000008, "Wrong alignment on ULAnimNotifyState_CommonTrail");
static_assert(sizeof(ULAnimNotifyState_CommonTrail) == 0x0000F0, "Wrong size on ULAnimNotifyState_CommonTrail");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, TestBladeTrailType) == 0x00006C, "Member 'ULAnimNotifyState_CommonTrail::TestBladeTrailType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, MeshSelectionType) == 0x000074, "Member 'ULAnimNotifyState_CommonTrail::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, Normal_FirstSocketName) == 0x000078, "Member 'ULAnimNotifyState_CommonTrail::Normal_FirstSocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, Normal_SecondSocketName) == 0x000080, "Member 'ULAnimNotifyState_CommonTrail::Normal_SecondSocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, Break_FirstSocketName) == 0x000088, "Member 'ULAnimNotifyState_CommonTrail::Break_FirstSocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, Break_SecondSocketName) == 0x000090, "Member 'ULAnimNotifyState_CommonTrail::Break_SecondSocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, TrailList) == 0x000098, "Member 'ULAnimNotifyState_CommonTrail::TrailList' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CommonTrail, Test_Condition) == 0x0000E8, "Member 'ULAnimNotifyState_CommonTrail::Test_Condition' has a wrong offset!");

// Class ProjectP.LAssetLoader
// 0x0000 (0x0028 - 0x0028)
class ULAssetLoader final : public UObject
{
public:
	static class UObject* FindOrLoadAssetSlowly(TSoftObjectPtr<class UObject> Asset);
	static class UClass* FindOrLoadClassSlowly(TSoftClassPtr<class UClass> AssetClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAssetLoader">();
	}
	static class ULAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAssetLoader>();
	}
};
static_assert(alignof(ULAssetLoader) == 0x000008, "Wrong alignment on ULAssetLoader");
static_assert(sizeof(ULAssetLoader) == 0x000028, "Wrong size on ULAssetLoader");

// Class ProjectP.LVolume
// 0x0020 (0x0238 - 0x0218)
class ALVolume : public AVolume
{
public:
	struct FBoxSphereBounds                       LocalBounds;                                       // 0x0218(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVolume">();
	}
	static class ALVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALVolume>();
	}
};
static_assert(alignof(ALVolume) == 0x000008, "Wrong alignment on ALVolume");
static_assert(sizeof(ALVolume) == 0x000238, "Wrong size on ALVolume");
static_assert(offsetof(ALVolume, LocalBounds) == 0x000218, "Member 'ALVolume::LocalBounds' has a wrong offset!");

// Class ProjectP.LAudioOcclusionVolume
// 0x0000 (0x0238 - 0x0238)
class ALAudioOcclusionVolume final : public ALVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAudioOcclusionVolume">();
	}
	static class ALAudioOcclusionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALAudioOcclusionVolume>();
	}
};
static_assert(alignof(ALAudioOcclusionVolume) == 0x000008, "Wrong alignment on ALAudioOcclusionVolume");
static_assert(sizeof(ALAudioOcclusionVolume) == 0x000238, "Wrong size on ALAudioOcclusionVolume");

// Class ProjectP.LBDecorator_BlueprintBase
// 0x0008 (0x00A8 - 0x00A0)
class ULBDecorator_BlueprintBase : public UBTDecorator_BlueprintBase
{
public:
	class ALAIController*                         LAIOwner;                                          // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetBehaivorTreeNodeName();
	void OnPostEditChangeProperty();
	void SetBehaivorTreeNodeName(const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBDecorator_BlueprintBase">();
	}
	static class ULBDecorator_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBDecorator_BlueprintBase>();
	}
};
static_assert(alignof(ULBDecorator_BlueprintBase) == 0x000008, "Wrong alignment on ULBDecorator_BlueprintBase");
static_assert(sizeof(ULBDecorator_BlueprintBase) == 0x0000A8, "Wrong size on ULBDecorator_BlueprintBase");
static_assert(offsetof(ULBDecorator_BlueprintBase, LAIOwner) == 0x0000A0, "Member 'ULBDecorator_BlueprintBase::LAIOwner' has a wrong offset!");

// Class ProjectP.LBehaviorTreeComponent
// 0x0008 (0x02A0 - 0x0298)
class ULBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBehaviorTreeComponent">();
	}
	static class ULBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBehaviorTreeComponent>();
	}
};
static_assert(alignof(ULBehaviorTreeComponent) == 0x000008, "Wrong alignment on ULBehaviorTreeComponent");
static_assert(sizeof(ULBehaviorTreeComponent) == 0x0002A0, "Wrong size on ULBehaviorTreeComponent");

// Class ProjectP.LAnimNotifyState_Drop_DecoMesh
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_Drop_DecoMesh final : public ULAnimNotifyStateBase
{
public:
	class FName                                   DecoMeshName;                                      // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Drop_DecoMesh">();
	}
	static class ULAnimNotifyState_Drop_DecoMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Drop_DecoMesh>();
	}
};
static_assert(alignof(ULAnimNotifyState_Drop_DecoMesh) == 0x000008, "Wrong alignment on ULAnimNotifyState_Drop_DecoMesh");
static_assert(sizeof(ULAnimNotifyState_Drop_DecoMesh) == 0x000048, "Wrong size on ULAnimNotifyState_Drop_DecoMesh");
static_assert(offsetof(ULAnimNotifyState_Drop_DecoMesh, DecoMeshName) == 0x000040, "Member 'ULAnimNotifyState_Drop_DecoMesh::DecoMeshName' has a wrong offset!");

// Class ProjectP.LBodyStain_Base
// 0x0030 (0x0058 - 0x0028)
class ULBodyStain_Base : public UObject
{
public:
	ELBodyStainCategory                           Category;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALCharacter>             Owner;                                             // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CodeName;                                          // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStain_Base">();
	}
	static class ULBodyStain_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStain_Base>();
	}
};
static_assert(alignof(ULBodyStain_Base) == 0x000008, "Wrong alignment on ULBodyStain_Base");
static_assert(sizeof(ULBodyStain_Base) == 0x000058, "Wrong size on ULBodyStain_Base");
static_assert(offsetof(ULBodyStain_Base, Category) == 0x000028, "Member 'ULBodyStain_Base::Category' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Base, Owner) == 0x00002C, "Member 'ULBodyStain_Base::Owner' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Base, CodeName) == 0x000034, "Member 'ULBodyStain_Base::CodeName' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Base, Priority) == 0x00003C, "Member 'ULBodyStain_Base::Priority' has a wrong offset!");

// Class ProjectP.LBodyStain_Common
// 0x00B8 (0x0110 - 0x0058)
class ULBodyStain_Common final : public ULBodyStain_Base
{
public:
	TSoftObjectPtr<class ULMaterialVarying>       MaterialVaryingRef;                                // 0x0058(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainTimeForRewind;                               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardTimeScale;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RewindTimeScale;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMaterialVaryingPlayer                MaterialVaryingPlayer;                             // 0x0090(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class ALCharacter* InOwner, class FName InCodeName, ELBodyStainCategory InCategory, int32 InPriority, TSoftObjectPtr<class ULMaterialVarying> InMaterialVaryingRef, float InStartTimeDelay, float InRemainTimeForRewind, float InForwardTimeScale, float InRewindTimeScale, bool InRewindOnRemove);
	void Restart();

	bool IsRewinding() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStain_Common">();
	}
	static class ULBodyStain_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStain_Common>();
	}
};
static_assert(alignof(ULBodyStain_Common) == 0x000008, "Wrong alignment on ULBodyStain_Common");
static_assert(sizeof(ULBodyStain_Common) == 0x000110, "Wrong size on ULBodyStain_Common");
static_assert(offsetof(ULBodyStain_Common, MaterialVaryingRef) == 0x000058, "Member 'ULBodyStain_Common::MaterialVaryingRef' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Common, RemainTimeForRewind) == 0x000080, "Member 'ULBodyStain_Common::RemainTimeForRewind' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Common, ForwardTimeScale) == 0x000084, "Member 'ULBodyStain_Common::ForwardTimeScale' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Common, RewindTimeScale) == 0x000088, "Member 'ULBodyStain_Common::RewindTimeScale' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Common, MaterialVaryingPlayer) == 0x000090, "Member 'ULBodyStain_Common::MaterialVaryingPlayer' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Always_Guard_Off
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_Always_Guard_Off final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Always_Guard_Off">();
	}
	static class ULAnimNotifyState_Always_Guard_Off* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Always_Guard_Off>();
	}
};
static_assert(alignof(ULAnimNotifyState_Always_Guard_Off) == 0x000008, "Wrong alignment on ULAnimNotifyState_Always_Guard_Off");
static_assert(sizeof(ULAnimNotifyState_Always_Guard_Off) == 0x000040, "Wrong size on ULAnimNotifyState_Always_Guard_Off");

// Class ProjectP.LBodyStain_Blood
// 0x00D0 (0x0128 - 0x0058)
class ULBodyStain_Blood final : public ULBodyStain_Base
{
public:
	int32                                         BloodLevel;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x24];                                      // 0x005C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMaterialParamPlayer                  ParamPlayer;                                       // 0x0080(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class ALCharacter* InOwner, ELBodyStainCategory InCategory, int32 InPriority, int32 InLevel, float InAmount, const struct FLinearColor& InWetColor, float InTimeApplyWet, float InTimeRemainWet, float InTimeRewindWet);
	void UpdateColorAndAmount(int32 InLevel, const struct FLinearColor& InBloodColor, float InAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStain_Blood">();
	}
	static class ULBodyStain_Blood* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStain_Blood>();
	}
};
static_assert(alignof(ULBodyStain_Blood) == 0x000008, "Wrong alignment on ULBodyStain_Blood");
static_assert(sizeof(ULBodyStain_Blood) == 0x000128, "Wrong size on ULBodyStain_Blood");
static_assert(offsetof(ULBodyStain_Blood, BloodLevel) == 0x000058, "Member 'ULBodyStain_Blood::BloodLevel' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Blood, ParamPlayer) == 0x000080, "Member 'ULBodyStain_Blood::ParamPlayer' has a wrong offset!");

// Class ProjectP.LBodyStain_Wet_Body
// 0x0118 (0x0170 - 0x0058)
class ULBodyStain_Wet_Body final : public ULBodyStain_Base
{
public:
	float                                         Current_Amount;                                    // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Current_WetColor;                                  // 0x005C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x1C];                                      // 0x006C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMaterialParamPlayer                  ParamPlayer;                                       // 0x0088(0x0088)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x60];                                     // 0x0110(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class ALCharacter* InOwner, float InTimeApplyWet_by_Sink, float InTimeApplyWet_by_WaterDrop, float InTimeRemainWet, float InTimeRewindWet);
	void SetFinished();
	void SetTargetAmount(float InAmount, ELBodyWetReasonType WetReason);
	void SetTargetColor(const struct FLinearColor& InColor, ELBodyWetReasonType WetReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStain_Wet_Body">();
	}
	static class ULBodyStain_Wet_Body* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStain_Wet_Body>();
	}
};
static_assert(alignof(ULBodyStain_Wet_Body) == 0x000008, "Wrong alignment on ULBodyStain_Wet_Body");
static_assert(sizeof(ULBodyStain_Wet_Body) == 0x000170, "Wrong size on ULBodyStain_Wet_Body");
static_assert(offsetof(ULBodyStain_Wet_Body, Current_Amount) == 0x000058, "Member 'ULBodyStain_Wet_Body::Current_Amount' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Wet_Body, Current_WetColor) == 0x00005C, "Member 'ULBodyStain_Wet_Body::Current_WetColor' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Wet_Body, ParamPlayer) == 0x000088, "Member 'ULBodyStain_Wet_Body::ParamPlayer' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_TransitAnimation_Dead
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_TransitAnimation_Dead final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_TransitAnimation_Dead">();
	}
	static class ULAnimNotifyState_TransitAnimation_Dead* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_TransitAnimation_Dead>();
	}
};
static_assert(alignof(ULAnimNotifyState_TransitAnimation_Dead) == 0x000008, "Wrong alignment on ULAnimNotifyState_TransitAnimation_Dead");
static_assert(sizeof(ULAnimNotifyState_TransitAnimation_Dead) == 0x000040, "Wrong size on ULAnimNotifyState_TransitAnimation_Dead");

// Class ProjectP.LBodyStain_Wet_Leg
// 0x0120 (0x0178 - 0x0058)
class ULBodyStain_Wet_Leg final : public ULBodyStain_Base
{
public:
	float                                         Time_Remain_Wet;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrySpeed;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMaterialParamPlayer                  WetParamPlayer;                                    // 0x0068(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x88];                                      // 0x00F0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyWetColor();
	void Initialize(class ALCharacter* InOwner, ELPhysicalSurfaceType InPhysicalSurface, const struct FLinearColor& InWetColor, int32 InPriority_Wet_Leg, float InTimeRemainWet, float InDrySpeed);
	void SetTargetColor(const struct FLinearColor& InColor);
	void SetTargetHeight(float InHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStain_Wet_Leg">();
	}
	static class ULBodyStain_Wet_Leg* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStain_Wet_Leg>();
	}
};
static_assert(alignof(ULBodyStain_Wet_Leg) == 0x000008, "Wrong alignment on ULBodyStain_Wet_Leg");
static_assert(sizeof(ULBodyStain_Wet_Leg) == 0x000178, "Wrong size on ULBodyStain_Wet_Leg");
static_assert(offsetof(ULBodyStain_Wet_Leg, Time_Remain_Wet) == 0x000058, "Member 'ULBodyStain_Wet_Leg::Time_Remain_Wet' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Wet_Leg, DrySpeed) == 0x000060, "Member 'ULBodyStain_Wet_Leg::DrySpeed' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Wet_Leg, PhysicalSurface) == 0x000064, "Member 'ULBodyStain_Wet_Leg::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Wet_Leg, WetParamPlayer) == 0x000068, "Member 'ULBodyStain_Wet_Leg::WetParamPlayer' has a wrong offset!");

// Class ProjectP.LWeaponBladeComponent
// 0x0000 (0x0460 - 0x0460)
class ULWeaponBladeComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponBladeComponent">();
	}
	static class ULWeaponBladeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWeaponBladeComponent>();
	}
};
static_assert(alignof(ULWeaponBladeComponent) == 0x000010, "Wrong alignment on ULWeaponBladeComponent");
static_assert(sizeof(ULWeaponBladeComponent) == 0x000460, "Wrong size on ULWeaponBladeComponent");

// Class ProjectP.LBodyStain_Burn
// 0x00B8 (0x0110 - 0x0058)
class ULBodyStain_Burn final : public ULBodyStain_Base
{
public:
	float                                         Burn_Amount_Value;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Burn_Emissive_Fade_Value;                          // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_Apply_Burn;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_Rewind_Burn;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_Remain_Dust;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Time_Rewind_Dust;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLMaterialParamPlayer                  ParamPlayer;                                       // 0x0070(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class ALCharacter* InOwner, class FName InCodeName, ELBodyStainCategory InType, int32 InPriority, float InBurnAmount, float InEmissiveFade, float InTime_Apply_Burn, float InTime_Rewind_Burn, float InTime_Remain_Dust, float InTime_Rewind_Dust);
	void Restart();
	void Rewind_Dust();
	void SetFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStain_Burn">();
	}
	static class ULBodyStain_Burn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStain_Burn>();
	}
};
static_assert(alignof(ULBodyStain_Burn) == 0x000008, "Wrong alignment on ULBodyStain_Burn");
static_assert(sizeof(ULBodyStain_Burn) == 0x000110, "Wrong size on ULBodyStain_Burn");
static_assert(offsetof(ULBodyStain_Burn, Burn_Amount_Value) == 0x000058, "Member 'ULBodyStain_Burn::Burn_Amount_Value' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Burn, Burn_Emissive_Fade_Value) == 0x00005C, "Member 'ULBodyStain_Burn::Burn_Emissive_Fade_Value' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Burn, Time_Apply_Burn) == 0x000060, "Member 'ULBodyStain_Burn::Time_Apply_Burn' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Burn, Time_Rewind_Burn) == 0x000064, "Member 'ULBodyStain_Burn::Time_Rewind_Burn' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Burn, Time_Remain_Dust) == 0x000068, "Member 'ULBodyStain_Burn::Time_Remain_Dust' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Burn, Time_Rewind_Dust) == 0x00006C, "Member 'ULBodyStain_Burn::Time_Rewind_Dust' has a wrong offset!");
static_assert(offsetof(ULBodyStain_Burn, ParamPlayer) == 0x000070, "Member 'ULBodyStain_Burn::ParamPlayer' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Swing_SFX
// 0x00A8 (0x00E8 - 0x0040)
class ULAnimNotifyState_Swing_SFX final : public ULAnimNotifyStateBase
{
public:
	class USoundBase*                             OverrideSoundAsset;                                // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Blade_override_Codename;                           // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Handle_override_Codename;                          // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPoint;                                 // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSkillMotionType                             MotionType;                                        // 0x0059(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              SwingPower;                                        // 0x005A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutDuration;                                   // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeVolumeLevel;                                   // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELAbnormalEnchantType, struct FLSoundFadeData> EnchantSoundFadeInfo;                              // 0x0068(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAudioComponent*                        MainAudioComponent_for_Editor;                     // 0x00B8(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        SubAudioComponent_for_Editor;                      // 0x00C0(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        EnchantAudioComponent_for_Editor;                  // 0x00C8(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Generated_Blade_Codename_For_Test;                 // 0x00D0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Generated_Handle_Codename_For_Test;                // 0x00D8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAbnormalEnchantType                         EnchantType_For_Test;                              // 0x00E0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Swing_SFX">();
	}
	static class ULAnimNotifyState_Swing_SFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Swing_SFX>();
	}
};
static_assert(alignof(ULAnimNotifyState_Swing_SFX) == 0x000008, "Wrong alignment on ULAnimNotifyState_Swing_SFX");
static_assert(sizeof(ULAnimNotifyState_Swing_SFX) == 0x0000E8, "Wrong size on ULAnimNotifyState_Swing_SFX");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, OverrideSoundAsset) == 0x000040, "Member 'ULAnimNotifyState_Swing_SFX::OverrideSoundAsset' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, Blade_override_Codename) == 0x000048, "Member 'ULAnimNotifyState_Swing_SFX::Blade_override_Codename' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, Handle_override_Codename) == 0x000050, "Member 'ULAnimNotifyState_Swing_SFX::Handle_override_Codename' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, WeaponAttachPoint) == 0x000058, "Member 'ULAnimNotifyState_Swing_SFX::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, MotionType) == 0x000059, "Member 'ULAnimNotifyState_Swing_SFX::MotionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, SwingPower) == 0x00005A, "Member 'ULAnimNotifyState_Swing_SFX::SwingPower' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, FadeOutDuration) == 0x00005C, "Member 'ULAnimNotifyState_Swing_SFX::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, FadeVolumeLevel) == 0x000060, "Member 'ULAnimNotifyState_Swing_SFX::FadeVolumeLevel' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, EnchantSoundFadeInfo) == 0x000068, "Member 'ULAnimNotifyState_Swing_SFX::EnchantSoundFadeInfo' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, MainAudioComponent_for_Editor) == 0x0000B8, "Member 'ULAnimNotifyState_Swing_SFX::MainAudioComponent_for_Editor' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, SubAudioComponent_for_Editor) == 0x0000C0, "Member 'ULAnimNotifyState_Swing_SFX::SubAudioComponent_for_Editor' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, EnchantAudioComponent_for_Editor) == 0x0000C8, "Member 'ULAnimNotifyState_Swing_SFX::EnchantAudioComponent_for_Editor' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, Generated_Blade_Codename_For_Test) == 0x0000D0, "Member 'ULAnimNotifyState_Swing_SFX::Generated_Blade_Codename_For_Test' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, Generated_Handle_Codename_For_Test) == 0x0000D8, "Member 'ULAnimNotifyState_Swing_SFX::Generated_Handle_Codename_For_Test' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Swing_SFX, EnchantType_For_Test) == 0x0000E0, "Member 'ULAnimNotifyState_Swing_SFX::EnchantType_For_Test' has a wrong offset!");

// Class ProjectP.LBodyStainComponent
// 0x00A8 (0x0158 - 0x00B0)
class ULBodyStainComponent : public UActorComponent
{
public:
	TArray<class ULBodyStain_Base*>               BodyStainList;                                     // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLStain_Loop_Wet_Body_Info>     Loop_Wet_Body_InfoList;                            // 0x00E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Wet_Leg_Height_Offset;                             // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x5C];                                      // 0x00FC(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLoopWetBodyInfo(class AActor* Instigator, ELPhysicalSurfaceType PhysicalSurface, float InAmount, bool IsWaterDrop);
	void ApplyBodyStainData(class ULBodyStain_Base* BodyStain, float TimePlayFrom);
	class ULBodyStain_Base* GetBodyStain(ELBodyStainCategory InType);
	class ULBodyStain_Base* GetBodyStain_by_CodeName(class FName InCodeName);
	void OnBloodOptionChanged(bool bEnable);
	void OnRemoveBodyStain(class FName InCodeName, ELBodyStainCategory InCategory);
	void OnRewindBodyStain(class FName InCodeName, ELBodyStainCategory InCategory);
	void PlayStain_Abnormal(class FName EventName);
	void PlayStain_Blood(ELBloodEffectType BloodType, int32 InBloodLevel, float ApplyTime);
	void PlayStain_Wet_Body(ELPhysicalSurfaceType PhysicalSurface, float InAmount, bool IsWaterDrop);
	void PlayStain_Wet_Leg(ELPhysicalSurfaceType SurfaceType);
	void Refresh(class USkeletalMeshComponent* SkeletalMeshComponent);
	void RemoveAll();
	void RemoveBodyStain(class FName InCodeName);
	void RemoveLoopWetBodyInfo(class AActor* Instigator);
	void RewindBodyStain(class FName InCodeName);
	void UpdateWaterSoakHeight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBodyStainComponent">();
	}
	static class ULBodyStainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBodyStainComponent>();
	}
};
static_assert(alignof(ULBodyStainComponent) == 0x000008, "Wrong alignment on ULBodyStainComponent");
static_assert(sizeof(ULBodyStainComponent) == 0x000158, "Wrong size on ULBodyStainComponent");
static_assert(offsetof(ULBodyStainComponent, BodyStainList) == 0x0000B0, "Member 'ULBodyStainComponent::BodyStainList' has a wrong offset!");
static_assert(offsetof(ULBodyStainComponent, Loop_Wet_Body_InfoList) == 0x0000E0, "Member 'ULBodyStainComponent::Loop_Wet_Body_InfoList' has a wrong offset!");
static_assert(offsetof(ULBodyStainComponent, Wet_Leg_Height_Offset) == 0x0000F8, "Member 'ULBodyStainComponent::Wet_Leg_Height_Offset' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayedDisappearEffect
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_PlayedDisappearEffect final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayedDisappearEffect">();
	}
	static class ULAnimNotify_PlayedDisappearEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayedDisappearEffect>();
	}
};
static_assert(alignof(ULAnimNotify_PlayedDisappearEffect) == 0x000008, "Wrong alignment on ULAnimNotify_PlayedDisappearEffect");
static_assert(sizeof(ULAnimNotify_PlayedDisappearEffect) == 0x000048, "Wrong size on ULAnimNotify_PlayedDisappearEffect");

// Class ProjectP.LAnimNotifyState_ForceFeedback
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_ForceFeedback final : public ULAnimNotifyStateBase
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Looping;                                           // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ForceFeedback">();
	}
	static class ULAnimNotifyState_ForceFeedback* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ForceFeedback>();
	}
};
static_assert(alignof(ULAnimNotifyState_ForceFeedback) == 0x000008, "Wrong alignment on ULAnimNotifyState_ForceFeedback");
static_assert(sizeof(ULAnimNotifyState_ForceFeedback) == 0x000058, "Wrong size on ULAnimNotifyState_ForceFeedback");
static_assert(offsetof(ULAnimNotifyState_ForceFeedback, ForceFeedbackEffect) == 0x000040, "Member 'ULAnimNotifyState_ForceFeedback::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ForceFeedback, Attached) == 0x000048, "Member 'ULAnimNotifyState_ForceFeedback::Attached' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ForceFeedback, Looping) == 0x000049, "Member 'ULAnimNotifyState_ForceFeedback::Looping' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ForceFeedback, Tag) == 0x00004C, "Member 'ULAnimNotifyState_ForceFeedback::Tag' has a wrong offset!");

// Class ProjectP.LBService_BlueprintBase
// 0x0000 (0x0098 - 0x0098)
class ULBService_BlueprintBase final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LBService_BlueprintBase">();
	}
	static class ULBService_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULBService_BlueprintBase>();
	}
};
static_assert(alignof(ULBService_BlueprintBase) == 0x000008, "Wrong alignment on ULBService_BlueprintBase");
static_assert(sizeof(ULBService_BlueprintBase) == 0x000098, "Wrong size on ULBService_BlueprintBase");

// Class ProjectP.LCameraUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULCameraUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalculateCameraLocationFromPC(class ALCameraWork* CameraWork, float ArmLength, const struct FRotator& ControlRotation);
	static class ALPCCharacter* GetCameraCharacter(const class UObject* WorldContextObject);
	static class ALCameraManager* GetCameraManager(const class UObject* WorldContextObject);
	static struct FVector GetCameraSocketLocation(class ALCameraWork* CameraWork, class FName SocketName);
	static struct FRotator GetCameraSocketRotation(class ALCameraWork* CameraWork, class FName SocketName);
	static float GetCameraTargetArmLength(class ALCameraWork* CameraWork);
	static struct FVector GetCameraTargetArmLocation(class ALCameraWork* CameraWork);
	static void GetCharacterSocketTransform(class ALCharacter* Character, class FName SocketName, struct FTransform* OutTransform);
	static float LinearStep(float Min, float Max, float Value);
	static void MakeLookatCharacter(class ALCharacter* Character, class FName SocketName, const struct FRotator& ActorRotation, float Distance, struct FTransform* OutTransform);
	static void MakeLookatTargetLocation(const struct FVector& CameraLocation, const struct FVector& TargetLocation, float Distance, struct FTransform* OutTransform);
	static void SetCameraCharacterControlRotation(class ALCameraWork* CameraWork, const struct FRotator& ControlRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCameraUtilFuncLibrary">();
	}
	static class ULCameraUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCameraUtilFuncLibrary>();
	}
};
static_assert(alignof(ULCameraUtilFuncLibrary) == 0x000008, "Wrong alignment on ULCameraUtilFuncLibrary");
static_assert(sizeof(ULCameraUtilFuncLibrary) == 0x000028, "Wrong size on ULCameraUtilFuncLibrary");

// Class ProjectP.LAnimNotifyState_DestructionDefence
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_DestructionDefence final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DestructionDefence">();
	}
	static class ULAnimNotifyState_DestructionDefence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DestructionDefence>();
	}
};
static_assert(alignof(ULAnimNotifyState_DestructionDefence) == 0x000008, "Wrong alignment on ULAnimNotifyState_DestructionDefence");
static_assert(sizeof(ULAnimNotifyState_DestructionDefence) == 0x000040, "Wrong size on ULAnimNotifyState_DestructionDefence");

// Class ProjectP.LInteractActor
// 0x0030 (0x0210 - 0x01E0)
class ALInteractActor : public AActor
{
public:
	class ULInteractComponent*                    InteractComponent;                                 // 0x01E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULTalker*                               Talker;                                            // 0x01E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastAttachedTalker;                                // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractActor">();
	}
	static class ALInteractActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALInteractActor>();
	}
};
static_assert(alignof(ALInteractActor) == 0x000008, "Wrong alignment on ALInteractActor");
static_assert(sizeof(ALInteractActor) == 0x000210, "Wrong size on ALInteractActor");
static_assert(offsetof(ALInteractActor, InteractComponent) == 0x0001E0, "Member 'ALInteractActor::InteractComponent' has a wrong offset!");
static_assert(offsetof(ALInteractActor, Talker) == 0x0001E8, "Member 'ALInteractActor::Talker' has a wrong offset!");
static_assert(offsetof(ALInteractActor, LastAttachedTalker) == 0x0001F0, "Member 'ALInteractActor::LastAttachedTalker' has a wrong offset!");

// Class ProjectP.LLevelObject
// 0x0050 (0x0260 - 0x0210)
class ALLevelObject : public ALInteractActor
{
public:
	uint8                                         Pad_210[0x50];                                     // 0x0210(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDelayInteractTime();
	float GetInteractTime();
	void OnChangeState(int32 TargetState);
	void OnInteractionEnd();
	void OnInteractionStart();
	void OnLevelObjectCommand(class FName CommandName);
	void OwnerSpotChangePropState(int32 TargetState);
	void OwnerSpotCheckLinkedNpcSpot(ELLinkedNpcSpotExecuteType ExecuteType);
	void OwnerSpotCheckNextPropState();
	void RemovePropProjectile(int64 ProjectileHandleId);
	int64 SpawnPropProjectile(class FName ProjectileCodeName, class USceneComponent* MuzzleSocket, class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelObject">();
	}
	static class ALLevelObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLevelObject>();
	}
};
static_assert(alignof(ALLevelObject) == 0x000008, "Wrong alignment on ALLevelObject");
static_assert(sizeof(ALLevelObject) == 0x000260, "Wrong size on ALLevelObject");

// Class ProjectP.LAnimNotifyState_ReserveInput_Dash
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ReserveInput_Dash final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ReserveInput_Dash">();
	}
	static class ULAnimNotifyState_ReserveInput_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ReserveInput_Dash>();
	}
};
static_assert(alignof(ULAnimNotifyState_ReserveInput_Dash) == 0x000008, "Wrong alignment on ULAnimNotifyState_ReserveInput_Dash");
static_assert(sizeof(ULAnimNotifyState_ReserveInput_Dash) == 0x000040, "Wrong size on ULAnimNotifyState_ReserveInput_Dash");

// Class ProjectP.LCarcassBodyObject
// 0x0080 (0x02E0 - 0x0260)
class ALCarcassBodyObject final : public ALLevelObject
{
public:
	TArray<class FName>                           CarcassHitList;                                    // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PropVolumeCodeName;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BurnLevelSequenceCodeName;                         // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle_AbnormalState_BuildUp;                 // 0x0280(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPropVolumeInfoPtr                     PropVolumeInfoPtr;                                 // 0x0288(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLCarcassBodyOverlapData> OverlappedCharacterDataMap;                        // 0x0290(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void BurnAutomation();
	void CheckAbnormalStateBuildUp();
	bool CheckIsSafe(const struct FVector& InLocation);
	void ClearCharacterOverlapState();
	float GetFluidDepth();
	float GetSurfaceHeight(const struct FVector& InLocation);
	void OnProcessHit(const struct FLProjectileHitInfo& HitInfo, const struct FHitResult& HitResult);
	void RemoveCharacterOverlapState(class ALCharacter* Character);
	void SetCharacterOverlapState(class ALCharacter* Character, ELCarcassBodyObjectOverlapState OverlapState);

	ELCarcassBodyObjectOverlapState GetCharacterOverlapState(class ALCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCarcassBodyObject">();
	}
	static class ALCarcassBodyObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALCarcassBodyObject>();
	}
};
static_assert(alignof(ALCarcassBodyObject) == 0x000008, "Wrong alignment on ALCarcassBodyObject");
static_assert(sizeof(ALCarcassBodyObject) == 0x0002E0, "Wrong size on ALCarcassBodyObject");
static_assert(offsetof(ALCarcassBodyObject, CarcassHitList) == 0x000260, "Member 'ALCarcassBodyObject::CarcassHitList' has a wrong offset!");
static_assert(offsetof(ALCarcassBodyObject, PropVolumeCodeName) == 0x000270, "Member 'ALCarcassBodyObject::PropVolumeCodeName' has a wrong offset!");
static_assert(offsetof(ALCarcassBodyObject, BurnLevelSequenceCodeName) == 0x000278, "Member 'ALCarcassBodyObject::BurnLevelSequenceCodeName' has a wrong offset!");
static_assert(offsetof(ALCarcassBodyObject, TimerHandle_AbnormalState_BuildUp) == 0x000280, "Member 'ALCarcassBodyObject::TimerHandle_AbnormalState_BuildUp' has a wrong offset!");
static_assert(offsetof(ALCarcassBodyObject, PropVolumeInfoPtr) == 0x000288, "Member 'ALCarcassBodyObject::PropVolumeInfoPtr' has a wrong offset!");
static_assert(offsetof(ALCarcassBodyObject, OverlappedCharacterDataMap) == 0x000290, "Member 'ALCarcassBodyObject::OverlappedCharacterDataMap' has a wrong offset!");

// Class ProjectP.LCharacter
// 0x0820 (0x0CA0 - 0x0480)
class ALCharacter : public ACharacter
{
public:
	uint8                                         Pad_478[0x28];                                     // 0x0478(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFootStepLineTrace;                                // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExitReposition_CanPush;                            // 0x04A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A2[0x2];                                      // 0x04A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TEMP_IsHitRight;                                   // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hit_Direction_Count;                               // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysMeshRotatingOnFloor;                         // 0x04AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is4WayHit;                                         // 0x04AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCharacterCollisionType                      CharacterCollisionType;                            // 0x04AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AF[0x11];                                     // 0x04AF(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseCollision_BigCapsule;                           // 0x04C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCollision_BigPhysicsBody;                       // 0x04C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCollision_VisualPhysicsBody;                    // 0x04C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePhysicsHit;                                     // 0x04C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MainCapsule_UseOnlyMove;                           // 0x04C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C5[0x3];                                      // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhysicalAnimationData                 PhysicalAnimationData;                             // 0x04C8(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ELDiePhysicsType                              DiePhysicsType;                                    // 0x04EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4ED[0x3];                                      // 0x04ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicalAnimationRootBoneName;                     // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalForceToDeadBody_Radius;                    // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalForceToDeadBody_OffsetHeight;              // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalForceToDeadBody_Strength;                  // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PhysicalForceToDeadBody_UseLinearFalloff : 1;      // 0x0504(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_505[0x3];                                      // 0x0505(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicalForceToDeadBody_MarginFromPrevious;        // 0x0508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAnimFSMState                                MainAnimFSMState;                                  // 0x050C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodyWhenMoveStopped;                          // 0x050D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50E[0x2];                                      // 0x050E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnAdditiveHeight;                               // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETEST_ExplodeType, class USkeletalMeshComponent*> TEST_ExplodeMeshMap;                               // 0x0518(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TEST_ExplodeLowerMesh;                             // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TEST_ExplodeMesh_Recovery;                         // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TEST_ExplodeMesh_Cut;                              // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultActionGroup;                                // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLCommonActionMontageInfo> CommonActionGroupMap;                              // 0x0588(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLCommonMotionInfo                     CommonMotionInfo;                                  // 0x05D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HitProcComponentClass;                             // 0x05E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActMgrComponentClass;                              // 0x0610(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EquipmentComponentClass;                           // 0x0638(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BodyStainComponentClass;                           // 0x0660(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FrenzyComponentClass;                              // 0x0688(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PhysicalAnimationComponentClass;                   // 0x06B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FXComponentClass;                                  // 0x06D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnJumpedEvent;                                     // 0x0700(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProcessHit;                                      // 0x0710(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostProcessHit;                                  // 0x0720(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostDeadCalled;                                  // 0x0730(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeadCharacter;                                   // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayHide;                                        // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	EFactionType                                  Faction;                                           // 0x0760(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_761[0x1F];                                     // 0x0761(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELExplosionMeshType, struct FLExplosionMeshInfo> ExplodeMeshTypeMap;                                // 0x0780(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Default_Mesh_Body;                                 // 0x07D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Default_Mesh_Face;                                 // 0x07D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Default_Mesh_Hair;                                 // 0x07E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Default_Mesh_Eyewear;                              // 0x07E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  Cached_Mesh_Face;                                  // 0x07F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  Cached_Mesh_Hair;                                  // 0x07F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  Cached_Mesh_Mask;                                  // 0x0800(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  Cached_Mesh_Eyewear;                               // 0x0808(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DelegateUI_ReceiveDamage_HeadTag;                  // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DelegateUI_ReceiveDamage_BossHP;                   // 0x0820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DelegateUI_SetHP;                                  // 0x0830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class ULInteractionCapsuleComponent*          InteractionCapsuleComponent;                       // 0x0840(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULStatComponent*                        StatComponent;                                     // 0x0848(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULAbnormalComponent*                    AbnormalComponent;                                 // 0x0850(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULEquipmentComponent*                   EquipmentComponent;                                // 0x0858(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULBodyStainComponent*                   BodyStainComponent;                                // 0x0860(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPhysicalAnimationComponent*           PhysicalAnimationComponent;                        // 0x0868(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWorldEventComponent*                  WorldEventComponent;                               // 0x0870(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULFrenzyComponent*                      FrenzyComponent;                                   // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULFXComponent*                          FXComponent;                                       // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x0888(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULHitProcComponent*                     HitProcComponent;                                  // 0x0890(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationInvokerComponent*            NavInvokerComponent;                               // 0x0898(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A0[0x50];                                     // 0x08A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ULCharacterBlockCapsuleComponent>> CharacterBlockCapsuleComponentArray;               // 0x08F0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ULCharacterBlockCapsuleStructureComponent>> CharacterBlockCapsuleStructureComponentArray;      // 0x0900(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_910[0x8];                                      // 0x0910(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELExplosionMeshType, TWeakObjectPtr<class ULExplodeSkeletalMeshComponent>> ExplodeSkeletalMeshComponentMap;                   // 0x0918(0x0050)(Edit, ExportObject, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         FallingHeight;                                     // 0x0968(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFallingHeightFromFloor;                         // 0x096C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ragdoll_Impulse_Weight;                            // 0x0970(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_974[0x4];                                      // 0x0974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNestedNameState                      NavInvokerNestedState;                             // 0x0978(0x0010)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_988[0x45];                                     // 0x0988(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	EVisibilityBasedAnimTickOption                DesiredAnimTickOption;                             // 0x09CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9CE[0x2];                                      // 0x09CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastActionGroupTableCodeName;                      // 0x09D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D8[0x8];                                      // 0x09D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OriginTransform;                                   // 0x09E0(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A10[0x34];                                     // 0x0A10(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotateBody_UpperBodyLookatAdditiveRotation;        // 0x0A44(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	ELLookAtUpperBodyType                         LookAtUpperBodyType;                               // 0x0A50(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A51[0x3];                                      // 0x0A51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtUpperBodyScale;                              // 0x0A54(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayBloodSpread_FX;                               // 0x0A58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBloodEffectType                             BloodEffectType;                                   // 0x0A59(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5A[0x6];                                      // 0x0A5A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLMaterialParamPlayer>          MaterialParamPlayers;                              // 0x0A60(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FLMaterialParamDefaults                MaterialParamDefaults;                             // 0x0A70(0x00A0)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_B10[0x10];                                     // 0x0B10(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULInteractComponent*                    InteractComponent;                                 // 0x0B20(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULTalker*                               Talker;                                            // 0x0B28(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastAttachedTalker;                                // 0x0B30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B38[0x18];                                     // 0x0B38(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DitherFadeCodeName;                                // 0x0B50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DitherFadeFaceCodeName;                            // 0x0B58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DitherFadeHairCodeName;                            // 0x0B60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DitherFadeWeaponCodeName;                          // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLLoopAttachFxData>  AttachedLoopFxMap;                                 // 0x0B70(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC0[0xB8];                                     // 0x0BC0(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmashLookatWeaponSlopeRate;                        // 0x0C78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C7C[0x18];                                     // 0x0C7C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Cached_Resurrection_Abnormal_Code_Name;            // 0x0C94(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9C[0x4];                                      // 0x0C9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddManagedParticle(class UFXSystemComponent* Particle);
	bool AddRadialImpulseToBody(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bVelChange, float MarginFromPrevious);
	bool AddStat(ELSecondStat InStat, int32 AdditionalStat);
	void ApplyMeshScale(float MeshScale);
	void CaptureFallingMotionTransitionInfo();
	bool ChangeActionGroup(class FName ActionGroupTableCodeName);
	bool ChangeCollisionState(ELCollisionState InCollisionState, bool ForceChange);
	bool ChangeCommonActionGroup(class FName CommonActionGroup, class FName LocomotionActionGroup);
	void ChangeLocomotion(class FName ActionGroup);
	void ChangeWeaponAnimState(ELWeaponAttachPointType AttachPointType, ELWeaponPartType PartType, class FName AnimState);
	void ClearWeaponAnimState(ELWeaponAttachPointType AttachPointType, ELWeaponPartType PartType);
	void DeactiveAllManagedParticle();
	void DeadToEvent();
	void EventHitStart(class AActor* Attacker, class AActor* Victim, const struct FLHitInfo& HitInfo, const struct FHitResult& HitResult);
	bool GameObject_RegisterStateManagedComponent(class UActorComponent* TargetActorComponent);
	bool GameObject_UnregisterStateManagedComponent(class UActorComponent* TargetActorComponent);
	struct FRotator GetFocusRotation();
	class AActor* GetFocusTarget();
	void GetHPPercent(float* HPPercent, float* RegainHPPercent);
	class UPhysicalMaterial* GetSimplePhysicalSurface();
	bool IsAboveNavigation(bool bForceUpdate);
	bool IsDead();
	void MoveMeshComponentToCapsuleBottom(const struct FVector& MeshOffset, bool bMaintainMeshView);
	void MoveMeshComponentToCapsuleCenter();
	void OnActionStarted(class ULActMgrComponent* InActMgrComponent, class ULActBase* StartedAction);
	void OnActionStopCalled(class ULActMgrComponent* InActMgrComponent, class ULActBase* StoppingAction, class ULActBase* ReasonAction);
	void OnApplyNeedShrink();
	void OnApplyRunningAbnormal(bool IsApply, class FName AbnormalCodeName);
	bool OnCanHitOccurDecoMesh(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult);
	void OnEquipmentWeaponStateChanged(ELWeaponStateChangeType WeaponStateChangeType);
	void OnPostDead();
	void OnRagdoll(bool bEnable);
	void OnStaminaConsume(int32 InAmount);
	void OnStatChanged(ELSecondStat StatType, int32 AddedValue, int32 PrevStatValue);
	void OverwriteFallingStartHeight(float Height);
	void PlayMaterialParam(const struct FLMaterialParamCollection& ParamCollection, ELMeshSelectionType SelectType);
	void PlayMaterialVarying(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, ELMeshSelectionType SelectionType, class FName PlayName);
	void PostHitProcess(class ULHitProcContext* HitProcContext);
	void PostInitEquipWeapon();
	void ProcessHitContextDeliver(class ULHitProcContext* LHitProcContext, EExecutePin* Branches);
	struct FLReceiveDamageResults ReceiveDamage(const struct FLReceiveDamageParams& Params_0);
	void ReceivePartsDamage(class ULPartsComponent* PartsComponent, int32 Damage, bool* bDestructionIndexDestoryed, class ULHitProcContext* HitProcContext);
	void ReceivePostBeginPlay();
	void RegisterNavigationInvoker(class FName StateName);
	void RemoveAllManagedParticle();
	void ResetFallingMotionTransitionInfo();
	void SetReverseDirection(bool bReverse);
	void SetRuntimeRootMotionEnabled(bool bRootMotion);
	void StopMaterialVarying(class ULMaterialVarying* MaterialVarying);
	void TraceAndLandingOnFloor();
	bool TraceFloatingCeiling(const struct FVector& TestLocation, float TestCapsuleHalfHeight, struct FVector* ResultLocation);
	bool TryConsumeElementalGauge(ELSecondStat ElementType, int32 ConsumePoint);
	bool TryConsumeTough(int32 InAmount, class AActor* Attacker, const struct FLHitInfo& HitInfo, bool CheckOnly, class ULHitProcContext* HitProcContext);
	bool TrySuppressTough();
	void UnregisterNavInvoker(class FName StateName);

	void GetActionGroup(class FName* ActionGroup, class FName* CommonActionGroup, class FName* LocomotionActionGroup) const;
	ELCollisionState GetCurrCollisionState() const;
	EPhysicalSurface GetFloorPhysicalSurface() const;
	const class ANavigationData* GetNavData() const;
	void GetNavInvokerRadius(float* TileGenerationRadius, float* TileRemovalRadius) const;
	const struct FTransform GetOriginTransform() const;
	bool IsRespawnInProgress() const;
	bool IsRuntimeRootMotionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCharacter">();
	}
	static class ALCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALCharacter>();
	}
};
static_assert(alignof(ALCharacter) == 0x000010, "Wrong alignment on ALCharacter");
static_assert(sizeof(ALCharacter) == 0x000CA0, "Wrong size on ALCharacter");
static_assert(offsetof(ALCharacter, bFootStepLineTrace) == 0x0004A0, "Member 'ALCharacter::bFootStepLineTrace' has a wrong offset!");
static_assert(offsetof(ALCharacter, ExitReposition_CanPush) == 0x0004A1, "Member 'ALCharacter::ExitReposition_CanPush' has a wrong offset!");
static_assert(offsetof(ALCharacter, TEMP_IsHitRight) == 0x0004A4, "Member 'ALCharacter::TEMP_IsHitRight' has a wrong offset!");
static_assert(offsetof(ALCharacter, Hit_Direction_Count) == 0x0004A8, "Member 'ALCharacter::Hit_Direction_Count' has a wrong offset!");
static_assert(offsetof(ALCharacter, AlwaysMeshRotatingOnFloor) == 0x0004AC, "Member 'ALCharacter::AlwaysMeshRotatingOnFloor' has a wrong offset!");
static_assert(offsetof(ALCharacter, Is4WayHit) == 0x0004AD, "Member 'ALCharacter::Is4WayHit' has a wrong offset!");
static_assert(offsetof(ALCharacter, CharacterCollisionType) == 0x0004AE, "Member 'ALCharacter::CharacterCollisionType' has a wrong offset!");
static_assert(offsetof(ALCharacter, UseCollision_BigCapsule) == 0x0004C0, "Member 'ALCharacter::UseCollision_BigCapsule' has a wrong offset!");
static_assert(offsetof(ALCharacter, UseCollision_BigPhysicsBody) == 0x0004C1, "Member 'ALCharacter::UseCollision_BigPhysicsBody' has a wrong offset!");
static_assert(offsetof(ALCharacter, UseCollision_VisualPhysicsBody) == 0x0004C2, "Member 'ALCharacter::UseCollision_VisualPhysicsBody' has a wrong offset!");
static_assert(offsetof(ALCharacter, UsePhysicsHit) == 0x0004C3, "Member 'ALCharacter::UsePhysicsHit' has a wrong offset!");
static_assert(offsetof(ALCharacter, MainCapsule_UseOnlyMove) == 0x0004C4, "Member 'ALCharacter::MainCapsule_UseOnlyMove' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalAnimationData) == 0x0004C8, "Member 'ALCharacter::PhysicalAnimationData' has a wrong offset!");
static_assert(offsetof(ALCharacter, DiePhysicsType) == 0x0004EC, "Member 'ALCharacter::DiePhysicsType' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalAnimationRootBoneName) == 0x0004F0, "Member 'ALCharacter::PhysicalAnimationRootBoneName' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalForceToDeadBody_Radius) == 0x0004F8, "Member 'ALCharacter::PhysicalForceToDeadBody_Radius' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalForceToDeadBody_OffsetHeight) == 0x0004FC, "Member 'ALCharacter::PhysicalForceToDeadBody_OffsetHeight' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalForceToDeadBody_Strength) == 0x000500, "Member 'ALCharacter::PhysicalForceToDeadBody_Strength' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalForceToDeadBody_MarginFromPrevious) == 0x000508, "Member 'ALCharacter::PhysicalForceToDeadBody_MarginFromPrevious' has a wrong offset!");
static_assert(offsetof(ALCharacter, MainAnimFSMState) == 0x00050C, "Member 'ALCharacter::MainAnimFSMState' has a wrong offset!");
static_assert(offsetof(ALCharacter, bFullBodyWhenMoveStopped) == 0x00050D, "Member 'ALCharacter::bFullBodyWhenMoveStopped' has a wrong offset!");
static_assert(offsetof(ALCharacter, SpawnAdditiveHeight) == 0x000510, "Member 'ALCharacter::SpawnAdditiveHeight' has a wrong offset!");
static_assert(offsetof(ALCharacter, TEST_ExplodeMeshMap) == 0x000518, "Member 'ALCharacter::TEST_ExplodeMeshMap' has a wrong offset!");
static_assert(offsetof(ALCharacter, TEST_ExplodeLowerMesh) == 0x000568, "Member 'ALCharacter::TEST_ExplodeLowerMesh' has a wrong offset!");
static_assert(offsetof(ALCharacter, TEST_ExplodeMesh_Recovery) == 0x000570, "Member 'ALCharacter::TEST_ExplodeMesh_Recovery' has a wrong offset!");
static_assert(offsetof(ALCharacter, TEST_ExplodeMesh_Cut) == 0x000578, "Member 'ALCharacter::TEST_ExplodeMesh_Cut' has a wrong offset!");
static_assert(offsetof(ALCharacter, DefaultActionGroup) == 0x000580, "Member 'ALCharacter::DefaultActionGroup' has a wrong offset!");
static_assert(offsetof(ALCharacter, CommonActionGroupMap) == 0x000588, "Member 'ALCharacter::CommonActionGroupMap' has a wrong offset!");
static_assert(offsetof(ALCharacter, CommonMotionInfo) == 0x0005D8, "Member 'ALCharacter::CommonMotionInfo' has a wrong offset!");
static_assert(offsetof(ALCharacter, HitProcComponentClass) == 0x0005E8, "Member 'ALCharacter::HitProcComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, ActMgrComponentClass) == 0x000610, "Member 'ALCharacter::ActMgrComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, EquipmentComponentClass) == 0x000638, "Member 'ALCharacter::EquipmentComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, BodyStainComponentClass) == 0x000660, "Member 'ALCharacter::BodyStainComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, FrenzyComponentClass) == 0x000688, "Member 'ALCharacter::FrenzyComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalAnimationComponentClass) == 0x0006B0, "Member 'ALCharacter::PhysicalAnimationComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, FXComponentClass) == 0x0006D8, "Member 'ALCharacter::FXComponentClass' has a wrong offset!");
static_assert(offsetof(ALCharacter, OnJumpedEvent) == 0x000700, "Member 'ALCharacter::OnJumpedEvent' has a wrong offset!");
static_assert(offsetof(ALCharacter, OnProcessHit) == 0x000710, "Member 'ALCharacter::OnProcessHit' has a wrong offset!");
static_assert(offsetof(ALCharacter, OnPostProcessHit) == 0x000720, "Member 'ALCharacter::OnPostProcessHit' has a wrong offset!");
static_assert(offsetof(ALCharacter, OnPostDeadCalled) == 0x000730, "Member 'ALCharacter::OnPostDeadCalled' has a wrong offset!");
static_assert(offsetof(ALCharacter, OnDeadCharacter) == 0x000740, "Member 'ALCharacter::OnDeadCharacter' has a wrong offset!");
static_assert(offsetof(ALCharacter, OnPlayHide) == 0x000750, "Member 'ALCharacter::OnPlayHide' has a wrong offset!");
static_assert(offsetof(ALCharacter, Faction) == 0x000760, "Member 'ALCharacter::Faction' has a wrong offset!");
static_assert(offsetof(ALCharacter, ExplodeMeshTypeMap) == 0x000780, "Member 'ALCharacter::ExplodeMeshTypeMap' has a wrong offset!");
static_assert(offsetof(ALCharacter, Default_Mesh_Body) == 0x0007D0, "Member 'ALCharacter::Default_Mesh_Body' has a wrong offset!");
static_assert(offsetof(ALCharacter, Default_Mesh_Face) == 0x0007D8, "Member 'ALCharacter::Default_Mesh_Face' has a wrong offset!");
static_assert(offsetof(ALCharacter, Default_Mesh_Hair) == 0x0007E0, "Member 'ALCharacter::Default_Mesh_Hair' has a wrong offset!");
static_assert(offsetof(ALCharacter, Default_Mesh_Eyewear) == 0x0007E8, "Member 'ALCharacter::Default_Mesh_Eyewear' has a wrong offset!");
static_assert(offsetof(ALCharacter, Cached_Mesh_Face) == 0x0007F0, "Member 'ALCharacter::Cached_Mesh_Face' has a wrong offset!");
static_assert(offsetof(ALCharacter, Cached_Mesh_Hair) == 0x0007F8, "Member 'ALCharacter::Cached_Mesh_Hair' has a wrong offset!");
static_assert(offsetof(ALCharacter, Cached_Mesh_Mask) == 0x000800, "Member 'ALCharacter::Cached_Mesh_Mask' has a wrong offset!");
static_assert(offsetof(ALCharacter, Cached_Mesh_Eyewear) == 0x000808, "Member 'ALCharacter::Cached_Mesh_Eyewear' has a wrong offset!");
static_assert(offsetof(ALCharacter, DelegateUI_ReceiveDamage_HeadTag) == 0x000810, "Member 'ALCharacter::DelegateUI_ReceiveDamage_HeadTag' has a wrong offset!");
static_assert(offsetof(ALCharacter, DelegateUI_ReceiveDamage_BossHP) == 0x000820, "Member 'ALCharacter::DelegateUI_ReceiveDamage_BossHP' has a wrong offset!");
static_assert(offsetof(ALCharacter, DelegateUI_SetHP) == 0x000830, "Member 'ALCharacter::DelegateUI_SetHP' has a wrong offset!");
static_assert(offsetof(ALCharacter, InteractionCapsuleComponent) == 0x000840, "Member 'ALCharacter::InteractionCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, StatComponent) == 0x000848, "Member 'ALCharacter::StatComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, AbnormalComponent) == 0x000850, "Member 'ALCharacter::AbnormalComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, EquipmentComponent) == 0x000858, "Member 'ALCharacter::EquipmentComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, BodyStainComponent) == 0x000860, "Member 'ALCharacter::BodyStainComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, PhysicalAnimationComponent) == 0x000868, "Member 'ALCharacter::PhysicalAnimationComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, WorldEventComponent) == 0x000870, "Member 'ALCharacter::WorldEventComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, FrenzyComponent) == 0x000878, "Member 'ALCharacter::FrenzyComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, FXComponent) == 0x000880, "Member 'ALCharacter::FXComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, ActMgrComponent) == 0x000888, "Member 'ALCharacter::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, HitProcComponent) == 0x000890, "Member 'ALCharacter::HitProcComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, NavInvokerComponent) == 0x000898, "Member 'ALCharacter::NavInvokerComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, CharacterBlockCapsuleComponentArray) == 0x0008F0, "Member 'ALCharacter::CharacterBlockCapsuleComponentArray' has a wrong offset!");
static_assert(offsetof(ALCharacter, CharacterBlockCapsuleStructureComponentArray) == 0x000900, "Member 'ALCharacter::CharacterBlockCapsuleStructureComponentArray' has a wrong offset!");
static_assert(offsetof(ALCharacter, ExplodeSkeletalMeshComponentMap) == 0x000918, "Member 'ALCharacter::ExplodeSkeletalMeshComponentMap' has a wrong offset!");
static_assert(offsetof(ALCharacter, FallingHeight) == 0x000968, "Member 'ALCharacter::FallingHeight' has a wrong offset!");
static_assert(offsetof(ALCharacter, MinFallingHeightFromFloor) == 0x00096C, "Member 'ALCharacter::MinFallingHeightFromFloor' has a wrong offset!");
static_assert(offsetof(ALCharacter, Ragdoll_Impulse_Weight) == 0x000970, "Member 'ALCharacter::Ragdoll_Impulse_Weight' has a wrong offset!");
static_assert(offsetof(ALCharacter, NavInvokerNestedState) == 0x000978, "Member 'ALCharacter::NavInvokerNestedState' has a wrong offset!");
static_assert(offsetof(ALCharacter, DesiredAnimTickOption) == 0x0009CD, "Member 'ALCharacter::DesiredAnimTickOption' has a wrong offset!");
static_assert(offsetof(ALCharacter, LastActionGroupTableCodeName) == 0x0009D0, "Member 'ALCharacter::LastActionGroupTableCodeName' has a wrong offset!");
static_assert(offsetof(ALCharacter, OriginTransform) == 0x0009E0, "Member 'ALCharacter::OriginTransform' has a wrong offset!");
static_assert(offsetof(ALCharacter, RotateBody_UpperBodyLookatAdditiveRotation) == 0x000A44, "Member 'ALCharacter::RotateBody_UpperBodyLookatAdditiveRotation' has a wrong offset!");
static_assert(offsetof(ALCharacter, LookAtUpperBodyType) == 0x000A50, "Member 'ALCharacter::LookAtUpperBodyType' has a wrong offset!");
static_assert(offsetof(ALCharacter, LookAtUpperBodyScale) == 0x000A54, "Member 'ALCharacter::LookAtUpperBodyScale' has a wrong offset!");
static_assert(offsetof(ALCharacter, bPlayBloodSpread_FX) == 0x000A58, "Member 'ALCharacter::bPlayBloodSpread_FX' has a wrong offset!");
static_assert(offsetof(ALCharacter, BloodEffectType) == 0x000A59, "Member 'ALCharacter::BloodEffectType' has a wrong offset!");
static_assert(offsetof(ALCharacter, MaterialParamPlayers) == 0x000A60, "Member 'ALCharacter::MaterialParamPlayers' has a wrong offset!");
static_assert(offsetof(ALCharacter, MaterialParamDefaults) == 0x000A70, "Member 'ALCharacter::MaterialParamDefaults' has a wrong offset!");
static_assert(offsetof(ALCharacter, InteractComponent) == 0x000B20, "Member 'ALCharacter::InteractComponent' has a wrong offset!");
static_assert(offsetof(ALCharacter, Talker) == 0x000B28, "Member 'ALCharacter::Talker' has a wrong offset!");
static_assert(offsetof(ALCharacter, LastAttachedTalker) == 0x000B30, "Member 'ALCharacter::LastAttachedTalker' has a wrong offset!");
static_assert(offsetof(ALCharacter, DitherFadeCodeName) == 0x000B50, "Member 'ALCharacter::DitherFadeCodeName' has a wrong offset!");
static_assert(offsetof(ALCharacter, DitherFadeFaceCodeName) == 0x000B58, "Member 'ALCharacter::DitherFadeFaceCodeName' has a wrong offset!");
static_assert(offsetof(ALCharacter, DitherFadeHairCodeName) == 0x000B60, "Member 'ALCharacter::DitherFadeHairCodeName' has a wrong offset!");
static_assert(offsetof(ALCharacter, DitherFadeWeaponCodeName) == 0x000B68, "Member 'ALCharacter::DitherFadeWeaponCodeName' has a wrong offset!");
static_assert(offsetof(ALCharacter, AttachedLoopFxMap) == 0x000B70, "Member 'ALCharacter::AttachedLoopFxMap' has a wrong offset!");
static_assert(offsetof(ALCharacter, SmashLookatWeaponSlopeRate) == 0x000C78, "Member 'ALCharacter::SmashLookatWeaponSlopeRate' has a wrong offset!");
static_assert(offsetof(ALCharacter, Cached_Resurrection_Abnormal_Code_Name) == 0x000C94, "Member 'ALCharacter::Cached_Resurrection_Abnormal_Code_Name' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_FuryAttack
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_FuryAttack final : public ULAnimNotifyStateBase
{
public:
	float                                         FuryAttack_VolumeModifier;                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_FuryAttack">();
	}
	static class ULAnimNotifyState_FuryAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_FuryAttack>();
	}
};
static_assert(alignof(ULAnimNotifyState_FuryAttack) == 0x000008, "Wrong alignment on ULAnimNotifyState_FuryAttack");
static_assert(sizeof(ULAnimNotifyState_FuryAttack) == 0x000048, "Wrong size on ULAnimNotifyState_FuryAttack");
static_assert(offsetof(ULAnimNotifyState_FuryAttack, FuryAttack_VolumeModifier) == 0x000040, "Member 'ULAnimNotifyState_FuryAttack::FuryAttack_VolumeModifier' has a wrong offset!");

// Class ProjectP.LCharacterBlockCapsuleComponent
// 0x0010 (0x0470 - 0x0460)
class ULCharacterBlockCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         IsHittable : 1;                                    // 0x0460(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         IsMoveBlock : 1;                                   // 0x0460(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         IsMoveBlockInDead : 1;                             // 0x0460(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         IsMoveBlockStartDisable : 1;                       // 0x0460(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         AlwaysStandCapsule : 1;                            // 0x0460(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_461[0xF];                                      // 0x0461(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCharacterBlockCapsuleComponent">();
	}
	static class ULCharacterBlockCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCharacterBlockCapsuleComponent>();
	}
};
static_assert(alignof(ULCharacterBlockCapsuleComponent) == 0x000010, "Wrong alignment on ULCharacterBlockCapsuleComponent");
static_assert(sizeof(ULCharacterBlockCapsuleComponent) == 0x000470, "Wrong size on ULCharacterBlockCapsuleComponent");

// Class ProjectP.LCharacterBlockCapsuleStructureComponent
// 0x0000 (0x0460 - 0x0460)
class ULCharacterBlockCapsuleStructureComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCharacterBlockCapsuleStructureComponent">();
	}
	static class ULCharacterBlockCapsuleStructureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCharacterBlockCapsuleStructureComponent>();
	}
};
static_assert(alignof(ULCharacterBlockCapsuleStructureComponent) == 0x000010, "Wrong alignment on ULCharacterBlockCapsuleStructureComponent");
static_assert(sizeof(ULCharacterBlockCapsuleStructureComponent) == 0x000460, "Wrong size on ULCharacterBlockCapsuleStructureComponent");

// Class ProjectP.LCharacterHitSphereComponent
// 0x0030 (0x0490 - 0x0460)
class ULCharacterHitSphereComponent final : public USphereComponent
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x2F];                                     // 0x0461(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCharacterHitSphereComponent">();
	}
	static class ULCharacterHitSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCharacterHitSphereComponent>();
	}
};
static_assert(alignof(ULCharacterHitSphereComponent) == 0x000010, "Wrong alignment on ULCharacterHitSphereComponent");
static_assert(sizeof(ULCharacterHitSphereComponent) == 0x000490, "Wrong size on ULCharacterHitSphereComponent");
static_assert(offsetof(ULCharacterHitSphereComponent, WeaponAttachPointType) == 0x000460, "Member 'ULCharacterHitSphereComponent::WeaponAttachPointType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_PartsRestore
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_PartsRestore final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_PartsRestore">();
	}
	static class ULAnimNotifyState_PartsRestore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_PartsRestore>();
	}
};
static_assert(alignof(ULAnimNotifyState_PartsRestore) == 0x000008, "Wrong alignment on ULAnimNotifyState_PartsRestore");
static_assert(sizeof(ULAnimNotifyState_PartsRestore) == 0x000048, "Wrong size on ULAnimNotifyState_PartsRestore");
static_assert(offsetof(ULAnimNotifyState_PartsRestore, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_PartsRestore::PartsCodeName' has a wrong offset!");

// Class ProjectP.LCharacterMovementComponent
// 0x0180 (0x0C80 - 0x0B00)
class ULCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B00[0x18];                                     // 0x0B00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomFalling_PerchRadius;                         // 0x0B18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomFalling_FloatingHeight;                      // 0x0B1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomFalling_FloatingHeight_Falling;              // 0x0B20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CustomFalling_KeepMotionSpeed;                     // 0x0B24(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CustomFalling_UseUnrealPerchOnFalling;             // 0x0B25(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B26[0x2];                                      // 0x0B26(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImmediateFallingRemainTimeForPC;                   // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrSpeed;                                         // 0x0B2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedAdjustRatio;                                  // 0x0B30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisValueUpperLimit;                               // 0x0B34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cached_MaxSprintRetainTime;                        // 0x0B38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cached_LeverNeutralStartTime;                      // 0x0B3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShowMaxWalkSpeedControlLog : 1;                    // 0x0B40(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B41[0x3];                                      // 0x0B41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintRetainingTimeWhenFalling;                    // 0x0B44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         UseCanWalkOnFloorOnly : 1;                         // 0x0B48(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         UseCanWalkOnNaviOnly : 1;                          // 0x0B48(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B49[0x3];                                      // 0x0B49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Cached_AccumulatedMovement;                        // 0x0B4C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Cached_AccumulatedMovement_ForAll;                 // 0x0B58(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 Cached_PerchHelper_MovementMode;                   // 0x0B64(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B65[0x3];                                      // 0x0B65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Cached_PerchHelper_PreLocation;                    // 0x0B68(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Cached_PerchHelper_OriginalPerchRadiusThreshold;   // 0x0B74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Cached_PerchHelper_SaveTime;                       // 0x0B78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Cached_InputAxisSpeed;                             // 0x0B7C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B80[0x100];                                    // 0x0B80(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAccumulatedMovement(const struct FVector& AccumulatedMovement, bool ApplyWalkingOnly, bool InSetUseCanWalkOnNaviOnly, bool InSetUseCanWalkOnFloorOnly);
	void SetBrakingDecelerationOverride(float InBrakingDecelerationOverride);
	void SetFrictionOverride(float InFrictionOverride);
	void SetIgnoreRootmotionVelocity(bool DoIgnore);
	void SetUseVelocityControl(bool InUseVelocityControl, float InMaxWalkSpeed);

	bool CheckIsValidLandingSpot(const struct FVector& CapsuleLocation, const struct FHitResult& Hit) const;
	bool GetUseVelocityControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCharacterMovementComponent">();
	}
	static class ULCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCharacterMovementComponent>();
	}
};
static_assert(alignof(ULCharacterMovementComponent) == 0x000010, "Wrong alignment on ULCharacterMovementComponent");
static_assert(sizeof(ULCharacterMovementComponent) == 0x000C80, "Wrong size on ULCharacterMovementComponent");
static_assert(offsetof(ULCharacterMovementComponent, CustomFalling_PerchRadius) == 0x000B18, "Member 'ULCharacterMovementComponent::CustomFalling_PerchRadius' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, CustomFalling_FloatingHeight) == 0x000B1C, "Member 'ULCharacterMovementComponent::CustomFalling_FloatingHeight' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, CustomFalling_FloatingHeight_Falling) == 0x000B20, "Member 'ULCharacterMovementComponent::CustomFalling_FloatingHeight_Falling' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, CustomFalling_KeepMotionSpeed) == 0x000B24, "Member 'ULCharacterMovementComponent::CustomFalling_KeepMotionSpeed' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, CustomFalling_UseUnrealPerchOnFalling) == 0x000B25, "Member 'ULCharacterMovementComponent::CustomFalling_UseUnrealPerchOnFalling' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, ImmediateFallingRemainTimeForPC) == 0x000B28, "Member 'ULCharacterMovementComponent::ImmediateFallingRemainTimeForPC' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, CurrSpeed) == 0x000B2C, "Member 'ULCharacterMovementComponent::CurrSpeed' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, SpeedAdjustRatio) == 0x000B30, "Member 'ULCharacterMovementComponent::SpeedAdjustRatio' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, AxisValueUpperLimit) == 0x000B34, "Member 'ULCharacterMovementComponent::AxisValueUpperLimit' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_MaxSprintRetainTime) == 0x000B38, "Member 'ULCharacterMovementComponent::Cached_MaxSprintRetainTime' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_LeverNeutralStartTime) == 0x000B3C, "Member 'ULCharacterMovementComponent::Cached_LeverNeutralStartTime' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, SprintRetainingTimeWhenFalling) == 0x000B44, "Member 'ULCharacterMovementComponent::SprintRetainingTimeWhenFalling' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_AccumulatedMovement) == 0x000B4C, "Member 'ULCharacterMovementComponent::Cached_AccumulatedMovement' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_AccumulatedMovement_ForAll) == 0x000B58, "Member 'ULCharacterMovementComponent::Cached_AccumulatedMovement_ForAll' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_PerchHelper_MovementMode) == 0x000B64, "Member 'ULCharacterMovementComponent::Cached_PerchHelper_MovementMode' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_PerchHelper_PreLocation) == 0x000B68, "Member 'ULCharacterMovementComponent::Cached_PerchHelper_PreLocation' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_PerchHelper_OriginalPerchRadiusThreshold) == 0x000B74, "Member 'ULCharacterMovementComponent::Cached_PerchHelper_OriginalPerchRadiusThreshold' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_PerchHelper_SaveTime) == 0x000B78, "Member 'ULCharacterMovementComponent::Cached_PerchHelper_SaveTime' has a wrong offset!");
static_assert(offsetof(ULCharacterMovementComponent, Cached_InputAxisSpeed) == 0x000B7C, "Member 'ULCharacterMovementComponent::Cached_InputAxisSpeed' has a wrong offset!");

// Class ProjectP.LLevelPreloadBoxComponent
// 0x0050 (0x04C0 - 0x0470)
class ULLevelPreloadBoxComponent final : public UBoxComponent
{
public:
	TArray<class FName>                           ProjectileCodeNames;                               // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x48];                                     // 0x0478(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapProjectile(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlapProjectlie(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelPreloadBoxComponent">();
	}
	static class ULLevelPreloadBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLevelPreloadBoxComponent>();
	}
};
static_assert(alignof(ULLevelPreloadBoxComponent) == 0x000010, "Wrong alignment on ULLevelPreloadBoxComponent");
static_assert(sizeof(ULLevelPreloadBoxComponent) == 0x0004C0, "Wrong size on ULLevelPreloadBoxComponent");
static_assert(offsetof(ULLevelPreloadBoxComponent, ProjectileCodeNames) == 0x000468, "Member 'ULLevelPreloadBoxComponent::ProjectileCodeNames' has a wrong offset!");

// Class ProjectP.LCheatManager
// 0x0000 (0x0088 - 0x0088)
class ULCheatManager final : public UCheatManager
{
public:
	void BullsOne();
	void CheckDist();
	void CheckDistReset();
	void DebugHit();
	void Die();
	void DisableNotify(const class FString& NotifyType);
	void EnableNotify(const class FString& NotifyType);
	class APlayerController* GetActivePlayerController();
	bool IsActiveDebugCamera();
	void OnePunchMan();
	void RedBull();
	void SetDebugCameraSpeedScale(float InSpeedScale);
	void ToggleDebugCameraHUD();
	void ToggleDebugHitCollision();
	void ToggleGameCommandBook();
	void Zombie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCheatManager">();
	}
	static class ULCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCheatManager>();
	}
};
static_assert(alignof(ULCheatManager) == 0x000008, "Wrong alignment on ULCheatManager");
static_assert(sizeof(ULCheatManager) == 0x000088, "Wrong size on ULCheatManager");

// Class ProjectP.LAnimNotifyState_NPCPartsDestroySelf
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_NPCPartsDestroySelf final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_NPCPartsDestroySelf">();
	}
	static class ULAnimNotifyState_NPCPartsDestroySelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_NPCPartsDestroySelf>();
	}
};
static_assert(alignof(ULAnimNotifyState_NPCPartsDestroySelf) == 0x000008, "Wrong alignment on ULAnimNotifyState_NPCPartsDestroySelf");
static_assert(sizeof(ULAnimNotifyState_NPCPartsDestroySelf) == 0x000048, "Wrong size on ULAnimNotifyState_NPCPartsDestroySelf");
static_assert(offsetof(ULAnimNotifyState_NPCPartsDestroySelf, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_NPCPartsDestroySelf::PartsCodeName' has a wrong offset!");

// Class ProjectP.LComboTableBase
// 0x00C0 (0x00E8 - 0x0028)
class ULComboTableBase : public UObject
{
public:
	class ULActPayloadBase*                       Cached_Payload;                                    // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Cached_SelectedSkillCodeName;                      // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 Cached_CurrActor;                                  // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Cached_Command;                                    // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Cached_Lever;                                      // 0x0048(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActBase*                              Cached_CurrAction;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLActionInfo                           Cached_ActionInfo;                                 // 0x0060(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLAction_StartRotationInfo             Cached_StartRotationInfo;                          // 0x00C0(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckCurrAction_ActionState(const class FName State);
	bool CheckCurrAction_Category(const ELActionCategory Category);
	bool CheckCurrAction_Class(const TSoftClassPtr<class UClass> Type);
	bool CheckCurrAction_SkillID(class FName ID);
	bool CheckCurrAction_Valid();
	bool CheckCurrActor_Moving();
	bool CheckLever_Neutral(bool CheckInputted);
	bool QueryNextAction(class AActor* TargetActor, class FName Command, const struct FVector& Lever, class ULActBase* CurrAction, class FName* OutActionClass, struct FLActionInfo* ActionInfo, class ULActPayloadBase** OutPayload);
	void Select_Skill(class FName SkillCodeName);
	void SelectDir_CurrentLever(float RotationTime);
	void SelectDir_InputttedLever(float RotationTime);
	void SelectDir_LockOnDir(float RotationTime);
	void Traverse(class AActor* TargetActor, class FName Command, const struct FVector& Lever, class ULActBase* CurrAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LComboTableBase">();
	}
	static class ULComboTableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULComboTableBase>();
	}
};
static_assert(alignof(ULComboTableBase) == 0x000008, "Wrong alignment on ULComboTableBase");
static_assert(sizeof(ULComboTableBase) == 0x0000E8, "Wrong size on ULComboTableBase");
static_assert(offsetof(ULComboTableBase, Cached_Payload) == 0x000028, "Member 'ULComboTableBase::Cached_Payload' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_SelectedSkillCodeName) == 0x000030, "Member 'ULComboTableBase::Cached_SelectedSkillCodeName' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_CurrActor) == 0x000038, "Member 'ULComboTableBase::Cached_CurrActor' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_Command) == 0x000040, "Member 'ULComboTableBase::Cached_Command' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_Lever) == 0x000048, "Member 'ULComboTableBase::Cached_Lever' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_CurrAction) == 0x000058, "Member 'ULComboTableBase::Cached_CurrAction' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_ActionInfo) == 0x000060, "Member 'ULComboTableBase::Cached_ActionInfo' has a wrong offset!");
static_assert(offsetof(ULComboTableBase, Cached_StartRotationInfo) == 0x0000C0, "Member 'ULComboTableBase::Cached_StartRotationInfo' has a wrong offset!");

// Class ProjectP.LCommandHotKeySettings
// 0x0010 (0x0038 - 0x0028)
class ULCommandHotKeySettings final : public UObject
{
public:
	TArray<struct FCommandHotKeyMapping>          CommandHotKeyMappings;                             // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCommandHotKeySettings">();
	}
	static class ULCommandHotKeySettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCommandHotKeySettings>();
	}
};
static_assert(alignof(ULCommandHotKeySettings) == 0x000008, "Wrong alignment on ULCommandHotKeySettings");
static_assert(sizeof(ULCommandHotKeySettings) == 0x000038, "Wrong size on ULCommandHotKeySettings");
static_assert(offsetof(ULCommandHotKeySettings, CommandHotKeyMappings) == 0x000028, "Member 'ULCommandHotKeySettings::CommandHotKeyMappings' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyInput_GetUpDash
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_GetUpDash final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_GetUpDash">();
	}
	static class ULAnimNotifyState_ApplyInput_GetUpDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_GetUpDash>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_GetUpDash) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_GetUpDash");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_GetUpDash) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_GetUpDash");

// Class ProjectP.LSequenceActorData
// 0x0078 (0x00A0 - 0x0028)
class ULSequenceActorData final : public UObject
{
public:
	TWeakObjectPtr<class ALevelSequenceActor>     SequenceActorPtr;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALSequenceRuntimeSetting> RuntimeSettingPtr;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLSequenceBindActor>            SequenceBindActorList;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  InstigatorActorPtr;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPlaySequenceActor;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFinishedSequenceActor;                           // 0x0060(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALPropLevelSequenceSpot> OwnerSpot;                                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableSkipSequence;                                // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelSequenceInfoPtr                  InfoPtr;                                           // 0x0080(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CommandCodeName;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SeqnenceTableCodeName;                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayReverse;                                       // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecutePlay();
	void ExecuteSkipUIControl(bool Visible);
	void OnFinishedSequencePlayer();
	void OnFinishedSkipSequenceActor();
	void OnPlaySequencePlayer();
	void OnStopSequencePlayer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSequenceActorData">();
	}
	static class ULSequenceActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSequenceActorData>();
	}
};
static_assert(alignof(ULSequenceActorData) == 0x000008, "Wrong alignment on ULSequenceActorData");
static_assert(sizeof(ULSequenceActorData) == 0x0000A0, "Wrong size on ULSequenceActorData");
static_assert(offsetof(ULSequenceActorData, SequenceActorPtr) == 0x000028, "Member 'ULSequenceActorData::SequenceActorPtr' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, RuntimeSettingPtr) == 0x000030, "Member 'ULSequenceActorData::RuntimeSettingPtr' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, SequenceBindActorList) == 0x000038, "Member 'ULSequenceActorData::SequenceBindActorList' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, InstigatorActorPtr) == 0x000048, "Member 'ULSequenceActorData::InstigatorActorPtr' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, OnPlaySequenceActor) == 0x000050, "Member 'ULSequenceActorData::OnPlaySequenceActor' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, OnFinishedSequenceActor) == 0x000060, "Member 'ULSequenceActorData::OnFinishedSequenceActor' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, OwnerSpot) == 0x000070, "Member 'ULSequenceActorData::OwnerSpot' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, EnableSkipSequence) == 0x000078, "Member 'ULSequenceActorData::EnableSkipSequence' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, InfoPtr) == 0x000080, "Member 'ULSequenceActorData::InfoPtr' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, CommandCodeName) == 0x000088, "Member 'ULSequenceActorData::CommandCodeName' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, SeqnenceTableCodeName) == 0x000090, "Member 'ULSequenceActorData::SeqnenceTableCodeName' has a wrong offset!");
static_assert(offsetof(ULSequenceActorData, PlayReverse) == 0x000098, "Member 'ULSequenceActorData::PlayReverse' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlaySequence
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_PlaySequence final : public ULAnimNotifyBase
{
public:
	class FName                                   SequenceCodeName;                                  // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlaySequence">();
	}
	static class ULAnimNotify_PlaySequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlaySequence>();
	}
};
static_assert(alignof(ULAnimNotify_PlaySequence) == 0x000008, "Wrong alignment on ULAnimNotify_PlaySequence");
static_assert(sizeof(ULAnimNotify_PlaySequence) == 0x000050, "Wrong size on ULAnimNotify_PlaySequence");
static_assert(offsetof(ULAnimNotify_PlaySequence, SequenceCodeName) == 0x000048, "Member 'ULAnimNotify_PlaySequence::SequenceCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyStateBase_HitCheck
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyStateBase_HitCheck : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyStateBase_HitCheck">();
	}
	static class ULAnimNotifyStateBase_HitCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyStateBase_HitCheck>();
	}
};
static_assert(alignof(ULAnimNotifyStateBase_HitCheck) == 0x000008, "Wrong alignment on ULAnimNotifyStateBase_HitCheck");
static_assert(sizeof(ULAnimNotifyStateBase_HitCheck) == 0x000040, "Wrong size on ULAnimNotifyStateBase_HitCheck");

// Class ProjectP.LAnimNotifyState_Debug
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_Debug final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Debug">();
	}
	static class ULAnimNotifyState_Debug* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Debug>();
	}
};
static_assert(alignof(ULAnimNotifyState_Debug) == 0x000008, "Wrong alignment on ULAnimNotifyState_Debug");
static_assert(sizeof(ULAnimNotifyState_Debug) == 0x000040, "Wrong size on ULAnimNotifyState_Debug");

// Class ProjectP.LAnimNotifyState_ChangePartsAnimState
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_ChangePartsAnimState final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLPartsAnimStateType                   AnimStateName;                                     // 0x0048(0x0008)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangePartsAnimState">();
	}
	static class ULAnimNotifyState_ChangePartsAnimState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangePartsAnimState>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangePartsAnimState) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangePartsAnimState");
static_assert(sizeof(ULAnimNotifyState_ChangePartsAnimState) == 0x000050, "Wrong size on ULAnimNotifyState_ChangePartsAnimState");
static_assert(offsetof(ULAnimNotifyState_ChangePartsAnimState, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_ChangePartsAnimState::PartsCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangePartsAnimState, AnimStateName) == 0x000048, "Member 'ULAnimNotifyState_ChangePartsAnimState::AnimStateName' has a wrong offset!");

// Class ProjectP.LLiftObject
// 0x0018 (0x0278 - 0x0260)
class ALLiftObject final : public ALLevelObject
{
public:
	class USceneComponent*                        InteractPositionComp;                              // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELiftObjectType                               LiftObjectType;                                    // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELDoorState                                   LiftDoorState;                                     // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELLiftObjectState                             LiftObjectState;                                   // 0x026A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B[0x1];                                      // 0x026B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AAudioVolume>            AudioVolume;                                       // 0x026C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapToAudioVolume(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapToAudioVolume(class AActor* OverlappedActor, class AActor* OtherActor);
	float PlayInteractMotion();
	void SetDoorState(ELDoorState StateData);
	void SetLiftObjectState(ELLiftObjectState StateData);
	void SetPropLiftState(ELPropLiftStateType StateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLiftObject">();
	}
	static class ALLiftObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLiftObject>();
	}
};
static_assert(alignof(ALLiftObject) == 0x000008, "Wrong alignment on ALLiftObject");
static_assert(sizeof(ALLiftObject) == 0x000278, "Wrong size on ALLiftObject");
static_assert(offsetof(ALLiftObject, InteractPositionComp) == 0x000260, "Member 'ALLiftObject::InteractPositionComp' has a wrong offset!");
static_assert(offsetof(ALLiftObject, LiftObjectType) == 0x000268, "Member 'ALLiftObject::LiftObjectType' has a wrong offset!");
static_assert(offsetof(ALLiftObject, LiftDoorState) == 0x000269, "Member 'ALLiftObject::LiftDoorState' has a wrong offset!");
static_assert(offsetof(ALLiftObject, LiftObjectState) == 0x00026A, "Member 'ALLiftObject::LiftObjectState' has a wrong offset!");
static_assert(offsetof(ALLiftObject, AudioVolume) == 0x00026C, "Member 'ALLiftObject::AudioVolume' has a wrong offset!");

// Class ProjectP.LAnimNotify_HitGrab
// 0x00F0 (0x0130 - 0x0040)
class ULAnimNotify_HitGrab final : public ULAnimNotifyStateBase_HitCheck
{
public:
	struct FLHitCollisionInfo                     Info;                                              // 0x0040(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLGrabInfo                             GrabInfo;                                          // 0x00C8(0x0068)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_HitGrab">();
	}
	static class ULAnimNotify_HitGrab* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_HitGrab>();
	}
};
static_assert(alignof(ULAnimNotify_HitGrab) == 0x000008, "Wrong alignment on ULAnimNotify_HitGrab");
static_assert(sizeof(ULAnimNotify_HitGrab) == 0x000130, "Wrong size on ULAnimNotify_HitGrab");
static_assert(offsetof(ULAnimNotify_HitGrab, Info) == 0x000040, "Member 'ULAnimNotify_HitGrab::Info' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HitGrab, GrabInfo) == 0x0000C8, "Member 'ULAnimNotify_HitGrab::GrabInfo' has a wrong offset!");

// Class ProjectP.LAnimNotify_HitGrabRelease
// 0x00A8 (0x00E8 - 0x0040)
class ULAnimNotify_HitGrabRelease final : public ULAnimNotifyStateBase_HitCheck
{
public:
	struct FLHitCollisionInfo                     Info;                                              // 0x0040(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLGrabReleaseInfo                      GrabReleaseInfo;                                   // 0x00C8(0x0020)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_HitGrabRelease">();
	}
	static class ULAnimNotify_HitGrabRelease* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_HitGrabRelease>();
	}
};
static_assert(alignof(ULAnimNotify_HitGrabRelease) == 0x000008, "Wrong alignment on ULAnimNotify_HitGrabRelease");
static_assert(sizeof(ULAnimNotify_HitGrabRelease) == 0x0000E8, "Wrong size on ULAnimNotify_HitGrabRelease");
static_assert(offsetof(ULAnimNotify_HitGrabRelease, Info) == 0x000040, "Member 'ULAnimNotify_HitGrabRelease::Info' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HitGrabRelease, GrabReleaseInfo) == 0x0000C8, "Member 'ULAnimNotify_HitGrabRelease::GrabReleaseInfo' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyPreInput
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyPreInput final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyPreInput">();
	}
	static class ULAnimNotifyState_ApplyPreInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyPreInput>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyPreInput) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyPreInput");
static_assert(sizeof(ULAnimNotifyState_ApplyPreInput) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyPreInput");

// Class ProjectP.LAnimNotify_PartsHitCheck
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotify_PartsHitCheck final : public ULAnimNotifyStateBase_HitCheck
{
public:
	int32                                         HitIndex;                                          // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartsIndex;                                        // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PartsHitCheck">();
	}
	static class ULAnimNotify_PartsHitCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PartsHitCheck>();
	}
};
static_assert(alignof(ULAnimNotify_PartsHitCheck) == 0x000008, "Wrong alignment on ULAnimNotify_PartsHitCheck");
static_assert(sizeof(ULAnimNotify_PartsHitCheck) == 0x000048, "Wrong size on ULAnimNotify_PartsHitCheck");
static_assert(offsetof(ULAnimNotify_PartsHitCheck, HitIndex) == 0x000040, "Member 'ULAnimNotify_PartsHitCheck::HitIndex' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PartsHitCheck, PartsIndex) == 0x000044, "Member 'ULAnimNotify_PartsHitCheck::PartsIndex' has a wrong offset!");

// Class ProjectP.LAnimNotify_HitCheck
// 0x0120 (0x0160 - 0x0040)
class ULAnimNotify_HitCheck : public ULAnimNotifyStateBase_HitCheck
{
public:
	struct FLHitCollisionInfo                     Info;                                              // 0x0040(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELPartsAttachPointType                        BodyWeaponAttachPointType;                         // 0x00C8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInfoOnBodyWeaponDestoryed;                     // 0x00C9(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLHitCollisionInfo                     InfoOnBodyWeaponDestoryed;                         // 0x00D0(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELHitFxLocationType                           HitFxLocationType;                                 // 0x0158(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_HitCheck">();
	}
	static class ULAnimNotify_HitCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_HitCheck>();
	}
};
static_assert(alignof(ULAnimNotify_HitCheck) == 0x000008, "Wrong alignment on ULAnimNotify_HitCheck");
static_assert(sizeof(ULAnimNotify_HitCheck) == 0x000160, "Wrong size on ULAnimNotify_HitCheck");
static_assert(offsetof(ULAnimNotify_HitCheck, Info) == 0x000040, "Member 'ULAnimNotify_HitCheck::Info' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HitCheck, BodyWeaponAttachPointType) == 0x0000C8, "Member 'ULAnimNotify_HitCheck::BodyWeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HitCheck, bUseInfoOnBodyWeaponDestoryed) == 0x0000C9, "Member 'ULAnimNotify_HitCheck::bUseInfoOnBodyWeaponDestoryed' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HitCheck, InfoOnBodyWeaponDestoryed) == 0x0000D0, "Member 'ULAnimNotify_HitCheck::InfoOnBodyWeaponDestoryed' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HitCheck, HitFxLocationType) == 0x000158, "Member 'ULAnimNotify_HitCheck::HitFxLocationType' has a wrong offset!");

// Class ProjectP.LAnimNotify_DespawnNPC
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_DespawnNPC final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_DespawnNPC">();
	}
	static class ULAnimNotify_DespawnNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_DespawnNPC>();
	}
};
static_assert(alignof(ULAnimNotify_DespawnNPC) == 0x000008, "Wrong alignment on ULAnimNotify_DespawnNPC");
static_assert(sizeof(ULAnimNotify_DespawnNPC) == 0x000048, "Wrong size on ULAnimNotify_DespawnNPC");

// Class ProjectP.LAnimNotifyState_Object_Destruct
// 0x0000 (0x0160 - 0x0160)
class ULAnimNotifyState_Object_Destruct final : public ULAnimNotify_HitCheck
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Object_Destruct">();
	}
	static class ULAnimNotifyState_Object_Destruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Object_Destruct>();
	}
};
static_assert(alignof(ULAnimNotifyState_Object_Destruct) == 0x000008, "Wrong alignment on ULAnimNotifyState_Object_Destruct");
static_assert(sizeof(ULAnimNotifyState_Object_Destruct) == 0x000160, "Wrong size on ULAnimNotifyState_Object_Destruct");

// Class ProjectP.LAnimNotifyState_WeaponHitCheck
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_WeaponHitCheck final : public ULAnimNotifyStateBase_HitCheck
{
public:
	class FName                                   SkillCodeNameOverride;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitIndex;                                          // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickInterval_MaxCount;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSpark;                                      // 0x0055(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRepulse;                                    // 0x0056(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_WeaponHitCheck">();
	}
	static class ULAnimNotifyState_WeaponHitCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_WeaponHitCheck>();
	}
};
static_assert(alignof(ULAnimNotifyState_WeaponHitCheck) == 0x000008, "Wrong alignment on ULAnimNotifyState_WeaponHitCheck");
static_assert(sizeof(ULAnimNotifyState_WeaponHitCheck) == 0x000058, "Wrong size on ULAnimNotifyState_WeaponHitCheck");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, SkillCodeNameOverride) == 0x000040, "Member 'ULAnimNotifyState_WeaponHitCheck::SkillCodeNameOverride' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, HitIndex) == 0x000048, "Member 'ULAnimNotifyState_WeaponHitCheck::HitIndex' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, TickInterval) == 0x00004C, "Member 'ULAnimNotifyState_WeaponHitCheck::TickInterval' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, TickInterval_MaxCount) == 0x000050, "Member 'ULAnimNotifyState_WeaponHitCheck::TickInterval_MaxCount' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, WeaponAttachPointType) == 0x000054, "Member 'ULAnimNotifyState_WeaponHitCheck::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, bEnableSpark) == 0x000055, "Member 'ULAnimNotifyState_WeaponHitCheck::bEnableSpark' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHitCheck, bEnableRepulse) == 0x000056, "Member 'ULAnimNotifyState_WeaponHitCheck::bEnableRepulse' has a wrong offset!");

// Class ProjectP.LAnimNotify_FootStep
// 0x0030 (0x0078 - 0x0048)
class ULAnimNotify_FootStep final : public ULAnimNotifyBase
{
public:
	class FName                                   BoneName;                                          // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName_Sound;                                   // 0x0058(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDuringFullbodyAttackAction;                 // 0x0064(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TestMoveSpeed;                                     // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestMaterialType;                                  // 0x006C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCharacterSoundType                   TestCharacterSoundType;                            // 0x0070(0x0008)(Edit, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_FootStep">();
	}
	static class ULAnimNotify_FootStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_FootStep>();
	}
};
static_assert(alignof(ULAnimNotify_FootStep) == 0x000008, "Wrong alignment on ULAnimNotify_FootStep");
static_assert(sizeof(ULAnimNotify_FootStep) == 0x000078, "Wrong size on ULAnimNotify_FootStep");
static_assert(offsetof(ULAnimNotify_FootStep, BoneName) == 0x000048, "Member 'ULAnimNotify_FootStep::BoneName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, EventName) == 0x000050, "Member 'ULAnimNotify_FootStep::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, EventName_Sound) == 0x000058, "Member 'ULAnimNotify_FootStep::EventName_Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, VolumeModifier) == 0x000060, "Member 'ULAnimNotify_FootStep::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, bIgnoreDuringFullbodyAttackAction) == 0x000064, "Member 'ULAnimNotify_FootStep::bIgnoreDuringFullbodyAttackAction' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, TestMoveSpeed) == 0x000068, "Member 'ULAnimNotify_FootStep::TestMoveSpeed' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, TestMaterialType) == 0x00006C, "Member 'ULAnimNotify_FootStep::TestMaterialType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_FootStep, TestCharacterSoundType) == 0x000070, "Member 'ULAnimNotify_FootStep::TestCharacterSoundType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_WeaponHide
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_WeaponHide final : public ULAnimNotifyStateBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_WeaponHide">();
	}
	static class ULAnimNotifyState_WeaponHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_WeaponHide>();
	}
};
static_assert(alignof(ULAnimNotifyState_WeaponHide) == 0x000008, "Wrong alignment on ULAnimNotifyState_WeaponHide");
static_assert(sizeof(ULAnimNotifyState_WeaponHide) == 0x000048, "Wrong size on ULAnimNotifyState_WeaponHide");
static_assert(offsetof(ULAnimNotifyState_WeaponHide, WeaponAttachPointType) == 0x000040, "Member 'ULAnimNotifyState_WeaponHide::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_WeaponHide, bInvert) == 0x000041, "Member 'ULAnimNotifyState_WeaponHide::bInvert' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_HideManagedEffects
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_HideManagedEffects final : public ULAnimNotifyStateBase
{
public:
	bool                                          bHide;                                             // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_HideManagedEffects">();
	}
	static class ULAnimNotifyState_HideManagedEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_HideManagedEffects>();
	}
};
static_assert(alignof(ULAnimNotifyState_HideManagedEffects) == 0x000008, "Wrong alignment on ULAnimNotifyState_HideManagedEffects");
static_assert(sizeof(ULAnimNotifyState_HideManagedEffects) == 0x000048, "Wrong size on ULAnimNotifyState_HideManagedEffects");
static_assert(offsetof(ULAnimNotifyState_HideManagedEffects, bHide) == 0x000040, "Member 'ULAnimNotifyState_HideManagedEffects::bHide' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_NPCSpawnIdleBranch
// 0x0030 (0x0070 - 0x0040)
class ULAnimNotifyState_NPCSpawnIdleBranch final : public ULAnimNotifyStateBase
{
public:
	class FName                                   UseSkillCodeName;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionPercent : 1;                              // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PercentValue;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionRange : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELAIRangeCheckType                            SkillrangeChecktype;                               // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillDistMin;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDistMax;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillRangeAngleStart;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillRangeAngleEnd;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDistHeight;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_NPCSpawnIdleBranch">();
	}
	static class ULAnimNotifyState_NPCSpawnIdleBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_NPCSpawnIdleBranch>();
	}
};
static_assert(alignof(ULAnimNotifyState_NPCSpawnIdleBranch) == 0x000008, "Wrong alignment on ULAnimNotifyState_NPCSpawnIdleBranch");
static_assert(sizeof(ULAnimNotifyState_NPCSpawnIdleBranch) == 0x000070, "Wrong size on ULAnimNotifyState_NPCSpawnIdleBranch");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, UseSkillCodeName) == 0x000040, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::UseSkillCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, PercentValue) == 0x00004C, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::PercentValue' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, SkillrangeChecktype) == 0x000051, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::SkillrangeChecktype' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, SkillDistMin) == 0x000054, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::SkillDistMin' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, SkillDistMax) == 0x000058, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::SkillDistMax' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, SkillRangeAngleStart) == 0x00005C, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::SkillRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, SkillRangeAngleEnd) == 0x000060, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::SkillRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, SkillDistHeight) == 0x000064, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::SkillDistHeight' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSpawnIdleBranch, Priority) == 0x000068, "Member 'ULAnimNotifyState_NPCSpawnIdleBranch::Priority' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_RootMotionScaling
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_RootMotionScaling final : public ULAnimNotifyStateBase
{
public:
	ELAnimRootMotionScaleOperationType            OperationType;                                     // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslationScale;                                  // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_RootMotionScaling">();
	}
	static class ULAnimNotifyState_RootMotionScaling* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_RootMotionScaling>();
	}
};
static_assert(alignof(ULAnimNotifyState_RootMotionScaling) == 0x000008, "Wrong alignment on ULAnimNotifyState_RootMotionScaling");
static_assert(sizeof(ULAnimNotifyState_RootMotionScaling) == 0x000048, "Wrong size on ULAnimNotifyState_RootMotionScaling");
static_assert(offsetof(ULAnimNotifyState_RootMotionScaling, OperationType) == 0x000040, "Member 'ULAnimNotifyState_RootMotionScaling::OperationType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_RootMotionScaling, TranslationScale) == 0x000044, "Member 'ULAnimNotifyState_RootMotionScaling::TranslationScale' has a wrong offset!");

// Class ProjectP.LAnimNotify_WeaponOn
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_WeaponOn final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_WeaponOn">();
	}
	static class ULAnimNotify_WeaponOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_WeaponOn>();
	}
};
static_assert(alignof(ULAnimNotify_WeaponOn) == 0x000008, "Wrong alignment on ULAnimNotify_WeaponOn");
static_assert(sizeof(ULAnimNotify_WeaponOn) == 0x000048, "Wrong size on ULAnimNotify_WeaponOn");

// Class ProjectP.LAnimNotify_PlayTimedGroundSkillFx
// 0x00A0 (0x00E0 - 0x0040)
class ULAnimNotify_PlayTimedGroundSkillFx final : public ULAnimNotifyStateBase
{
public:
	TArray<struct FLNiagaraWithParametersWithPS_for_Notify> FXList;                                            // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSoundWithPS>                  SoundList;                                         // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0060(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0070(0x0030)(BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x00A0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x00A1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x00A2(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeModifier;                                    // 0x00A4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeIn;                                            // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeOut;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x00C8(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestSurface;                                       // 0x00D8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayTimedGroundSkillFx">();
	}
	static class ULAnimNotify_PlayTimedGroundSkillFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayTimedGroundSkillFx>();
	}
};
static_assert(alignof(ULAnimNotify_PlayTimedGroundSkillFx) == 0x000010, "Wrong alignment on ULAnimNotify_PlayTimedGroundSkillFx");
static_assert(sizeof(ULAnimNotify_PlayTimedGroundSkillFx) == 0x0000E0, "Wrong size on ULAnimNotify_PlayTimedGroundSkillFx");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, FXList) == 0x000040, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::FXList' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, SoundList) == 0x000050, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::SoundList' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, SocketName) == 0x000060, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, Offset) == 0x000070, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::Offset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, UseSocketOrientedOffset) == 0x0000A0, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, UseAbsoluteRotation) == 0x0000A1, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, bAttached) == 0x0000A2, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, VolumeModifier) == 0x0000A4, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, FadeIn) == 0x0000A8, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::FadeIn' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, FadeOut) == 0x0000B8, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::FadeOut' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, DisableWhenWeaponInListBroken) == 0x0000C8, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundSkillFx, TestSurface) == 0x0000D8, "Member 'ULAnimNotify_PlayTimedGroundSkillFx::TestSurface' has a wrong offset!");

// Class ProjectP.LAnimNotify_WeaponOff
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_WeaponOff final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_WeaponOff">();
	}
	static class ULAnimNotify_WeaponOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_WeaponOff>();
	}
};
static_assert(alignof(ULAnimNotify_WeaponOff) == 0x000008, "Wrong alignment on ULAnimNotify_WeaponOff");
static_assert(sizeof(ULAnimNotify_WeaponOff) == 0x000048, "Wrong size on ULAnimNotify_WeaponOff");

// Class ProjectP.LAnimNotify_WeaponSelectOn
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_WeaponSelectOn final : public ULAnimNotifyBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_WeaponSelectOn">();
	}
	static class ULAnimNotify_WeaponSelectOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_WeaponSelectOn>();
	}
};
static_assert(alignof(ULAnimNotify_WeaponSelectOn) == 0x000008, "Wrong alignment on ULAnimNotify_WeaponSelectOn");
static_assert(sizeof(ULAnimNotify_WeaponSelectOn) == 0x000050, "Wrong size on ULAnimNotify_WeaponSelectOn");
static_assert(offsetof(ULAnimNotify_WeaponSelectOn, WeaponAttachPointType) == 0x000048, "Member 'ULAnimNotify_WeaponSelectOn::WeaponAttachPointType' has a wrong offset!");

// Class ProjectP.LAnimNotify_NPCSuicide
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_NPCSuicide final : public ULAnimNotifyBase
{
public:
	ELNPCSuicideType                              SuicideType;                                       // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DeadCodeName;                                      // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemGet;                                          // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExpGet;                                           // 0x0055(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideRespawnState;                          // 0x0056(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespawnEnable;                                    // 0x0057(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDeadSound;                                    // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_NPCSuicide">();
	}
	static class ULAnimNotify_NPCSuicide* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_NPCSuicide>();
	}
};
static_assert(alignof(ULAnimNotify_NPCSuicide) == 0x000008, "Wrong alignment on ULAnimNotify_NPCSuicide");
static_assert(sizeof(ULAnimNotify_NPCSuicide) == 0x000060, "Wrong size on ULAnimNotify_NPCSuicide");
static_assert(offsetof(ULAnimNotify_NPCSuicide, SuicideType) == 0x000048, "Member 'ULAnimNotify_NPCSuicide::SuicideType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPCSuicide, DeadCodeName) == 0x00004C, "Member 'ULAnimNotify_NPCSuicide::DeadCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPCSuicide, bItemGet) == 0x000054, "Member 'ULAnimNotify_NPCSuicide::bItemGet' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPCSuicide, bExpGet) == 0x000055, "Member 'ULAnimNotify_NPCSuicide::bExpGet' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPCSuicide, bUseOverrideRespawnState) == 0x000056, "Member 'ULAnimNotify_NPCSuicide::bUseOverrideRespawnState' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPCSuicide, bRespawnEnable) == 0x000057, "Member 'ULAnimNotify_NPCSuicide::bRespawnEnable' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPCSuicide, bPlayDeadSound) == 0x000058, "Member 'ULAnimNotify_NPCSuicide::bPlayDeadSound' has a wrong offset!");

// Class ProjectP.LAnimNotify_WeaponSelectOff
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_WeaponSelectOff final : public ULAnimNotifyBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_WeaponSelectOff">();
	}
	static class ULAnimNotify_WeaponSelectOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_WeaponSelectOff>();
	}
};
static_assert(alignof(ULAnimNotify_WeaponSelectOff) == 0x000008, "Wrong alignment on ULAnimNotify_WeaponSelectOff");
static_assert(sizeof(ULAnimNotify_WeaponSelectOff) == 0x000050, "Wrong size on ULAnimNotify_WeaponSelectOff");
static_assert(offsetof(ULAnimNotify_WeaponSelectOff, WeaponAttachPointType) == 0x000048, "Member 'ULAnimNotify_WeaponSelectOff::WeaponAttachPointType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ChangeRateScale
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_ChangeRateScale final : public ULAnimNotifyStateBase
{
public:
	float                                         PrevPlayRate;                                      // 0x0040(0x0004)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELAnimRateScaleOperationType                  OperationType;                                     // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimRateScale;                                     // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreezeTime;                                        // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangeRateScale">();
	}
	static class ULAnimNotifyState_ChangeRateScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangeRateScale>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangeRateScale) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangeRateScale");
static_assert(sizeof(ULAnimNotifyState_ChangeRateScale) == 0x000050, "Wrong size on ULAnimNotifyState_ChangeRateScale");
static_assert(offsetof(ULAnimNotifyState_ChangeRateScale, PrevPlayRate) == 0x000040, "Member 'ULAnimNotifyState_ChangeRateScale::PrevPlayRate' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangeRateScale, OperationType) == 0x000044, "Member 'ULAnimNotifyState_ChangeRateScale::OperationType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangeRateScale, AnimRateScale) == 0x000048, "Member 'ULAnimNotifyState_ChangeRateScale::AnimRateScale' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangeRateScale, FreezeTime) == 0x00004C, "Member 'ULAnimNotifyState_ChangeRateScale::FreezeTime' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_MoveBlockStartDisableOff
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_MoveBlockStartDisableOff final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_MoveBlockStartDisableOff">();
	}
	static class ULAnimNotifyState_MoveBlockStartDisableOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_MoveBlockStartDisableOff>();
	}
};
static_assert(alignof(ULAnimNotifyState_MoveBlockStartDisableOff) == 0x000008, "Wrong alignment on ULAnimNotifyState_MoveBlockStartDisableOff");
static_assert(sizeof(ULAnimNotifyState_MoveBlockStartDisableOff) == 0x000040, "Wrong size on ULAnimNotifyState_MoveBlockStartDisableOff");

// Class ProjectP.LAnimNotifyState_AnimPlayRate
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_AnimPlayRate final : public ULAnimNotifyStateBase
{
public:
	ELAnimRateScaleOperationType                  OperationType;                                     // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimRateScale;                                     // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreezeTime;                                        // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AnimPlayRate">();
	}
	static class ULAnimNotifyState_AnimPlayRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AnimPlayRate>();
	}
};
static_assert(alignof(ULAnimNotifyState_AnimPlayRate) == 0x000008, "Wrong alignment on ULAnimNotifyState_AnimPlayRate");
static_assert(sizeof(ULAnimNotifyState_AnimPlayRate) == 0x000050, "Wrong size on ULAnimNotifyState_AnimPlayRate");
static_assert(offsetof(ULAnimNotifyState_AnimPlayRate, OperationType) == 0x000040, "Member 'ULAnimNotifyState_AnimPlayRate::OperationType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_AnimPlayRate, AnimRateScale) == 0x000044, "Member 'ULAnimNotifyState_AnimPlayRate::AnimRateScale' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_AnimPlayRate, FreezeTime) == 0x000048, "Member 'ULAnimNotifyState_AnimPlayRate::FreezeTime' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_AllowInput_Rotation
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_AllowInput_Rotation final : public ULAnimNotifyStateBase
{
public:
	float                                         RotationSpeed;                                     // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_Rotation">();
	}
	static class ULAnimNotifyState_AllowInput_Rotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_Rotation>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_Rotation) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_Rotation");
static_assert(sizeof(ULAnimNotifyState_AllowInput_Rotation) == 0x000048, "Wrong size on ULAnimNotifyState_AllowInput_Rotation");
static_assert(offsetof(ULAnimNotifyState_AllowInput_Rotation, RotationSpeed) == 0x000040, "Member 'ULAnimNotifyState_AllowInput_Rotation::RotationSpeed' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayTimedGroundFx
// 0x0190 (0x01D0 - 0x0040)
class ULAnimNotify_PlayTimedGroundFx final : public ULAnimNotifyStateBase
{
public:
	class FName                                   EventName;                                         // 0x0040(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName_Sound;                                   // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0060(0x0030)(BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x0091(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0092(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x0098(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x00E8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0138(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0188(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeIn;                                            // 0x018C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeOut;                                           // 0x019C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x01B0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestSurface;                                       // 0x01C0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayTimedGroundFx">();
	}
	static class ULAnimNotify_PlayTimedGroundFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayTimedGroundFx>();
	}
};
static_assert(alignof(ULAnimNotify_PlayTimedGroundFx) == 0x000010, "Wrong alignment on ULAnimNotify_PlayTimedGroundFx");
static_assert(sizeof(ULAnimNotify_PlayTimedGroundFx) == 0x0001D0, "Wrong size on ULAnimNotify_PlayTimedGroundFx");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, EventName) == 0x000040, "Member 'ULAnimNotify_PlayTimedGroundFx::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, EventName_Sound) == 0x000048, "Member 'ULAnimNotify_PlayTimedGroundFx::EventName_Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, SocketName) == 0x000050, "Member 'ULAnimNotify_PlayTimedGroundFx::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, Offset) == 0x000060, "Member 'ULAnimNotify_PlayTimedGroundFx::Offset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, UseSocketOrientedOffset) == 0x000090, "Member 'ULAnimNotify_PlayTimedGroundFx::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, UseAbsoluteRotation) == 0x000091, "Member 'ULAnimNotify_PlayTimedGroundFx::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, bAttached) == 0x000092, "Member 'ULAnimNotify_PlayTimedGroundFx::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, ApplyVariableFloat) == 0x000098, "Member 'ULAnimNotify_PlayTimedGroundFx::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, ApplyVariableVector2) == 0x0000E8, "Member 'ULAnimNotify_PlayTimedGroundFx::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, ApplyVariableVector3) == 0x000138, "Member 'ULAnimNotify_PlayTimedGroundFx::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, VolumeModifier) == 0x000188, "Member 'ULAnimNotify_PlayTimedGroundFx::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, FadeIn) == 0x00018C, "Member 'ULAnimNotify_PlayTimedGroundFx::FadeIn' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, FadeOut) == 0x00019C, "Member 'ULAnimNotify_PlayTimedGroundFx::FadeOut' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, DisableWhenWeaponInListBroken) == 0x0001B0, "Member 'ULAnimNotify_PlayTimedGroundFx::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedGroundFx, TestSurface) == 0x0001C0, "Member 'ULAnimNotify_PlayTimedGroundFx::TestSurface' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_DisableLockOnRotation
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_DisableLockOnRotation final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DisableLockOnRotation">();
	}
	static class ULAnimNotifyState_DisableLockOnRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DisableLockOnRotation>();
	}
};
static_assert(alignof(ULAnimNotifyState_DisableLockOnRotation) == 0x000008, "Wrong alignment on ULAnimNotifyState_DisableLockOnRotation");
static_assert(sizeof(ULAnimNotifyState_DisableLockOnRotation) == 0x000040, "Wrong size on ULAnimNotifyState_DisableLockOnRotation");

// Class ProjectP.LAnimNotifyState_CurrentLeverForcedMove
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_CurrentLeverForcedMove final : public ULAnimNotifyStateBase
{
public:
	float                                         MoveSpeed;                                         // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseRotation : 1;                                   // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         UseLeverTracking : 1;                              // 0x0044(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_CurrentLeverForcedMove">();
	}
	static class ULAnimNotifyState_CurrentLeverForcedMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_CurrentLeverForcedMove>();
	}
};
static_assert(alignof(ULAnimNotifyState_CurrentLeverForcedMove) == 0x000008, "Wrong alignment on ULAnimNotifyState_CurrentLeverForcedMove");
static_assert(sizeof(ULAnimNotifyState_CurrentLeverForcedMove) == 0x000048, "Wrong size on ULAnimNotifyState_CurrentLeverForcedMove");
static_assert(offsetof(ULAnimNotifyState_CurrentLeverForcedMove, MoveSpeed) == 0x000040, "Member 'ULAnimNotifyState_CurrentLeverForcedMove::MoveSpeed' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_NPCExtraBT
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_NPCExtraBT final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_NPCExtraBT">();
	}
	static class ULAnimNotifyState_NPCExtraBT* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_NPCExtraBT>();
	}
};
static_assert(alignof(ULAnimNotifyState_NPCExtraBT) == 0x000008, "Wrong alignment on ULAnimNotifyState_NPCExtraBT");
static_assert(sizeof(ULAnimNotifyState_NPCExtraBT) == 0x000040, "Wrong size on ULAnimNotifyState_NPCExtraBT");

// Class ProjectP.LAnimNotifyState_AllowInput_Move
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_AllowInput_Move final : public ULAnimNotifyStateBase
{
public:
	uint8                                         CancelAction : 1;                                  // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_Move">();
	}
	static class ULAnimNotifyState_AllowInput_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_Move>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_Move) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_Move");
static_assert(sizeof(ULAnimNotifyState_AllowInput_Move) == 0x000048, "Wrong size on ULAnimNotifyState_AllowInput_Move");

// Class ProjectP.LAnimNotifyState_ApplyInput
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput">();
	}
	static class ULAnimNotifyState_ApplyInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput");
static_assert(sizeof(ULAnimNotifyState_ApplyInput) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput");

// Class ProjectP.LAnimNotify_NpcStandGuardEnable
// 0x00B0 (0x00F8 - 0x0048)
class ULAnimNotify_NpcStandGuardEnable final : public ULAnimNotifyBase
{
public:
	class FName                                   ActionGroupCodeName;                               // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaRecoveryRatio;                              // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleStart;                              // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLHitCollisionInfo                     HitInfo;                                           // 0x0060(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartAngle;                                        // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAngle;                                          // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_NpcStandGuardEnable">();
	}
	static class ULAnimNotify_NpcStandGuardEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_NpcStandGuardEnable>();
	}
};
static_assert(alignof(ULAnimNotify_NpcStandGuardEnable) == 0x000008, "Wrong alignment on ULAnimNotify_NpcStandGuardEnable");
static_assert(sizeof(ULAnimNotify_NpcStandGuardEnable) == 0x0000F8, "Wrong size on ULAnimNotify_NpcStandGuardEnable");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, ActionGroupCodeName) == 0x000048, "Member 'ULAnimNotify_NpcStandGuardEnable::ActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, StaminaRecoveryRatio) == 0x000050, "Member 'ULAnimNotify_NpcStandGuardEnable::StaminaRecoveryRatio' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, GuardRangeAngleStart) == 0x000054, "Member 'ULAnimNotify_NpcStandGuardEnable::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, GuardRangeAngleEnd) == 0x000058, "Member 'ULAnimNotify_NpcStandGuardEnable::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, HitInfo) == 0x000060, "Member 'ULAnimNotify_NpcStandGuardEnable::HitInfo' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, WeaponAttachPointType) == 0x0000E8, "Member 'ULAnimNotify_NpcStandGuardEnable::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, StartAngle) == 0x0000EC, "Member 'ULAnimNotify_NpcStandGuardEnable::StartAngle' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, EndAngle) == 0x0000F0, "Member 'ULAnimNotify_NpcStandGuardEnable::EndAngle' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NpcStandGuardEnable, Distance) == 0x0000F4, "Member 'ULAnimNotify_NpcStandGuardEnable::Distance' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyInput_ChargeCancel
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_ChargeCancel final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_ChargeCancel">();
	}
	static class ULAnimNotifyState_ApplyInput_ChargeCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_ChargeCancel>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_ChargeCancel) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_ChargeCancel");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_ChargeCancel) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_ChargeCancel");

// Class ProjectP.LAnimNotifyState_AllowInput_Charge_Cancel
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_AllowInput_Charge_Cancel final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_Charge_Cancel">();
	}
	static class ULAnimNotifyState_AllowInput_Charge_Cancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_Charge_Cancel>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_Charge_Cancel) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_Charge_Cancel");
static_assert(sizeof(ULAnimNotifyState_AllowInput_Charge_Cancel) == 0x000040, "Wrong size on ULAnimNotifyState_AllowInput_Charge_Cancel");

// Class ProjectP.LAnimNotifyState_AnimSwitchOnOff
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_AnimSwitchOnOff final : public ULAnimNotifyStateBase
{
public:
	class FName                                   AnimSwitchName;                                    // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AnimSwitchOnOff">();
	}
	static class ULAnimNotifyState_AnimSwitchOnOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AnimSwitchOnOff>();
	}
};
static_assert(alignof(ULAnimNotifyState_AnimSwitchOnOff) == 0x000008, "Wrong alignment on ULAnimNotifyState_AnimSwitchOnOff");
static_assert(sizeof(ULAnimNotifyState_AnimSwitchOnOff) == 0x000048, "Wrong size on ULAnimNotifyState_AnimSwitchOnOff");
static_assert(offsetof(ULAnimNotifyState_AnimSwitchOnOff, AnimSwitchName) == 0x000040, "Member 'ULAnimNotifyState_AnimSwitchOnOff::AnimSwitchName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Allow_FableCancel
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_Allow_FableCancel final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Allow_FableCancel">();
	}
	static class ULAnimNotifyState_Allow_FableCancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Allow_FableCancel>();
	}
};
static_assert(alignof(ULAnimNotifyState_Allow_FableCancel) == 0x000008, "Wrong alignment on ULAnimNotifyState_Allow_FableCancel");
static_assert(sizeof(ULAnimNotifyState_Allow_FableCancel) == 0x000040, "Wrong size on ULAnimNotifyState_Allow_FableCancel");

// Class ProjectP.LAnimNotifyState_AllowInput_SlaveArm
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_AllowInput_SlaveArm final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_SlaveArm">();
	}
	static class ULAnimNotifyState_AllowInput_SlaveArm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_SlaveArm>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_SlaveArm) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_SlaveArm");
static_assert(sizeof(ULAnimNotifyState_AllowInput_SlaveArm) == 0x000040, "Wrong size on ULAnimNotifyState_AllowInput_SlaveArm");

// Class ProjectP.LAnimNotify_PlayLadderFx
// 0x0138 (0x0180 - 0x0048)
class ULAnimNotify_PlayLadderFx final : public ULAnimNotifyBase
{
public:
	class FName                                   EventName;                                         // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName_Sound;                                   // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0058(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0060(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x006C(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleOffset;                                       // 0x0078(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x0084(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x0085(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0086(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0087(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x0088(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x00D8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0128(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0178(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestSurface;                                       // 0x017C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayLadderFx">();
	}
	static class ULAnimNotify_PlayLadderFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayLadderFx>();
	}
};
static_assert(alignof(ULAnimNotify_PlayLadderFx) == 0x000008, "Wrong alignment on ULAnimNotify_PlayLadderFx");
static_assert(sizeof(ULAnimNotify_PlayLadderFx) == 0x000180, "Wrong size on ULAnimNotify_PlayLadderFx");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, EventName) == 0x000048, "Member 'ULAnimNotify_PlayLadderFx::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, EventName_Sound) == 0x000050, "Member 'ULAnimNotify_PlayLadderFx::EventName_Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, SocketName) == 0x000058, "Member 'ULAnimNotify_PlayLadderFx::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, LocationOffset) == 0x000060, "Member 'ULAnimNotify_PlayLadderFx::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, RotationOffset) == 0x00006C, "Member 'ULAnimNotify_PlayLadderFx::RotationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, ScaleOffset) == 0x000078, "Member 'ULAnimNotify_PlayLadderFx::ScaleOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, UseSocketOrientedOffset) == 0x000084, "Member 'ULAnimNotify_PlayLadderFx::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, UseAbsoluteRotation) == 0x000085, "Member 'ULAnimNotify_PlayLadderFx::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, bAttached) == 0x000086, "Member 'ULAnimNotify_PlayLadderFx::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, MeshSelectionType) == 0x000087, "Member 'ULAnimNotify_PlayLadderFx::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, ApplyVariableFloat) == 0x000088, "Member 'ULAnimNotify_PlayLadderFx::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, ApplyVariableVector2) == 0x0000D8, "Member 'ULAnimNotify_PlayLadderFx::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, ApplyVariableVector3) == 0x000128, "Member 'ULAnimNotify_PlayLadderFx::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, VolumeModifier) == 0x000178, "Member 'ULAnimNotify_PlayLadderFx::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayLadderFx, TestSurface) == 0x00017C, "Member 'ULAnimNotify_PlayLadderFx::TestSurface' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyInput_Guard
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_Guard final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_Guard">();
	}
	static class ULAnimNotifyState_ApplyInput_Guard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_Guard>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_Guard) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_Guard");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_Guard) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_Guard");

// Class ProjectP.LAnimNotifyState_AllowInput_Guard
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_AllowInput_Guard final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_Guard">();
	}
	static class ULAnimNotifyState_AllowInput_Guard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_Guard>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_Guard) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_Guard");
static_assert(sizeof(ULAnimNotifyState_AllowInput_Guard) == 0x000040, "Wrong size on ULAnimNotifyState_AllowInput_Guard");

// Class ProjectP.LAnimNotifyStateBase_EnableFloatingHit
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyStateBase_EnableFloatingHit final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyStateBase_EnableFloatingHit">();
	}
	static class ULAnimNotifyStateBase_EnableFloatingHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyStateBase_EnableFloatingHit>();
	}
};
static_assert(alignof(ULAnimNotifyStateBase_EnableFloatingHit) == 0x000008, "Wrong alignment on ULAnimNotifyStateBase_EnableFloatingHit");
static_assert(sizeof(ULAnimNotifyStateBase_EnableFloatingHit) == 0x000040, "Wrong size on ULAnimNotifyStateBase_EnableFloatingHit");

// Class ProjectP.LAnimNotifyState_ApplyInput_LightAttack
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_LightAttack final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_LightAttack">();
	}
	static class ULAnimNotifyState_ApplyInput_LightAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_LightAttack>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_LightAttack) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_LightAttack");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_LightAttack) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_LightAttack");

// Class ProjectP.LAnimNotifyState_ApplyInput_StrongAttack
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_StrongAttack final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_StrongAttack">();
	}
	static class ULAnimNotifyState_ApplyInput_StrongAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_StrongAttack>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_StrongAttack) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_StrongAttack");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_StrongAttack) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_StrongAttack");

// Class ProjectP.LAnimNotifyState_GuardCheck_Arm
// 0x00B8 (0x00F8 - 0x0040)
class ULAnimNotifyState_GuardCheck_Arm final : public ULAnimNotifyStateBase
{
public:
	struct FLGuardStatOverride                    GuardStatOverride;                                 // 0x0040(0x0024)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleStart;                              // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLHitCollisionInfo                     HitInfo;                                           // 0x0070(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GuardCheck_Arm">();
	}
	static class ULAnimNotifyState_GuardCheck_Arm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GuardCheck_Arm>();
	}
};
static_assert(alignof(ULAnimNotifyState_GuardCheck_Arm) == 0x000008, "Wrong alignment on ULAnimNotifyState_GuardCheck_Arm");
static_assert(sizeof(ULAnimNotifyState_GuardCheck_Arm) == 0x0000F8, "Wrong size on ULAnimNotifyState_GuardCheck_Arm");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm, GuardStatOverride) == 0x000040, "Member 'ULAnimNotifyState_GuardCheck_Arm::GuardStatOverride' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm, GuardRangeAngleStart) == 0x000064, "Member 'ULAnimNotifyState_GuardCheck_Arm::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm, GuardRangeAngleEnd) == 0x000068, "Member 'ULAnimNotifyState_GuardCheck_Arm::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm, HitInfo) == 0x000070, "Member 'ULAnimNotifyState_GuardCheck_Arm::HitInfo' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyInput_Dash
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_Dash final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_Dash">();
	}
	static class ULAnimNotifyState_ApplyInput_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_Dash>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_Dash) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_Dash");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_Dash) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_Dash");

// Class ProjectP.LAnimNotifyState_AllowInput_Repair_Cancel
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_AllowInput_Repair_Cancel final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_Repair_Cancel">();
	}
	static class ULAnimNotifyState_AllowInput_Repair_Cancel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_Repair_Cancel>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_Repair_Cancel) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_Repair_Cancel");
static_assert(sizeof(ULAnimNotifyState_AllowInput_Repair_Cancel) == 0x000040, "Wrong size on ULAnimNotifyState_AllowInput_Repair_Cancel");

// Class ProjectP.LAnimNotify_ChangeNpcWeapon
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_ChangeNpcWeapon final : public ULAnimNotifyBase
{
public:
	class FName                                   MonsterWeaponCodeName;                             // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionGroupTableCodeName;                          // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_ChangeNpcWeapon">();
	}
	static class ULAnimNotify_ChangeNpcWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_ChangeNpcWeapon>();
	}
};
static_assert(alignof(ULAnimNotify_ChangeNpcWeapon) == 0x000008, "Wrong alignment on ULAnimNotify_ChangeNpcWeapon");
static_assert(sizeof(ULAnimNotify_ChangeNpcWeapon) == 0x000060, "Wrong size on ULAnimNotify_ChangeNpcWeapon");
static_assert(offsetof(ULAnimNotify_ChangeNpcWeapon, MonsterWeaponCodeName) == 0x000048, "Member 'ULAnimNotify_ChangeNpcWeapon::MonsterWeaponCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_ChangeNpcWeapon, WeaponAttachPointType) == 0x000050, "Member 'ULAnimNotify_ChangeNpcWeapon::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_ChangeNpcWeapon, ActionGroupTableCodeName) == 0x000054, "Member 'ULAnimNotify_ChangeNpcWeapon::ActionGroupTableCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Victim_CounterCheck
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_Victim_CounterCheck final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Victim_CounterCheck">();
	}
	static class ULAnimNotifyState_Victim_CounterCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Victim_CounterCheck>();
	}
};
static_assert(alignof(ULAnimNotifyState_Victim_CounterCheck) == 0x000008, "Wrong alignment on ULAnimNotifyState_Victim_CounterCheck");
static_assert(sizeof(ULAnimNotifyState_Victim_CounterCheck) == 0x000040, "Wrong size on ULAnimNotifyState_Victim_CounterCheck");

// Class ProjectP.LAnimNotifyState_ToughDefense
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_ToughDefense final : public ULAnimNotifyStateBase
{
public:
	int32                                         ToughDefenseValue;                                 // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ToughDefense">();
	}
	static class ULAnimNotifyState_ToughDefense* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ToughDefense>();
	}
};
static_assert(alignof(ULAnimNotifyState_ToughDefense) == 0x000008, "Wrong alignment on ULAnimNotifyState_ToughDefense");
static_assert(sizeof(ULAnimNotifyState_ToughDefense) == 0x000048, "Wrong size on ULAnimNotifyState_ToughDefense");
static_assert(offsetof(ULAnimNotifyState_ToughDefense, ToughDefenseValue) == 0x000040, "Member 'ULAnimNotifyState_ToughDefense::ToughDefenseValue' has a wrong offset!");

// Class ProjectP.LAnimNotify_ApplySingleActionState
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotify_ApplySingleActionState final : public ULAnimNotifyStateBase
{
public:
	class FName                                   ActionState;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_ApplySingleActionState">();
	}
	static class ULAnimNotify_ApplySingleActionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_ApplySingleActionState>();
	}
};
static_assert(alignof(ULAnimNotify_ApplySingleActionState) == 0x000008, "Wrong alignment on ULAnimNotify_ApplySingleActionState");
static_assert(sizeof(ULAnimNotify_ApplySingleActionState) == 0x000048, "Wrong size on ULAnimNotify_ApplySingleActionState");
static_assert(offsetof(ULAnimNotify_ApplySingleActionState, ActionState) == 0x000040, "Member 'ULAnimNotify_ApplySingleActionState::ActionState' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_MoveActor
// 0x0020 (0x0060 - 0x0040)
class ULAnimNotifyState_MoveActor final : public ULAnimNotifyStateBase
{
public:
	class UCurveVector*                           MoveCurve;                                         // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0048(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFixedDir;                                       // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStepUp;                                         // 0x0055(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckNavPath;                                      // 0x0056(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x9];                                       // 0x0057(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_MoveActor">();
	}
	static class ULAnimNotifyState_MoveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_MoveActor>();
	}
};
static_assert(alignof(ULAnimNotifyState_MoveActor) == 0x000008, "Wrong alignment on ULAnimNotifyState_MoveActor");
static_assert(sizeof(ULAnimNotifyState_MoveActor) == 0x000060, "Wrong size on ULAnimNotifyState_MoveActor");
static_assert(offsetof(ULAnimNotifyState_MoveActor, MoveCurve) == 0x000040, "Member 'ULAnimNotifyState_MoveActor::MoveCurve' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MoveActor, Movement) == 0x000048, "Member 'ULAnimNotifyState_MoveActor::Movement' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MoveActor, UseFixedDir) == 0x000054, "Member 'ULAnimNotifyState_MoveActor::UseFixedDir' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MoveActor, UseStepUp) == 0x000055, "Member 'ULAnimNotifyState_MoveActor::UseStepUp' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MoveActor, CheckNavPath) == 0x000056, "Member 'ULAnimNotifyState_MoveActor::CheckNavPath' has a wrong offset!");

// Class ProjectP.LPropInteractStartComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULPropInteractStartComponent final : public USceneComponent
{
public:
	ELPropInteractState                           InteractStateType;                                 // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropInteractStartComponent">();
	}
	static class ULPropInteractStartComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropInteractStartComponent>();
	}
};
static_assert(alignof(ULPropInteractStartComponent) == 0x000010, "Wrong alignment on ULPropInteractStartComponent");
static_assert(sizeof(ULPropInteractStartComponent) == 0x0001F0, "Wrong size on ULPropInteractStartComponent");
static_assert(offsetof(ULPropInteractStartComponent, InteractStateType) == 0x0001E8, "Member 'ULPropInteractStartComponent::InteractStateType' has a wrong offset!");

// Class ProjectP.LAnimNotify_ApplyCommmand
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_ApplyCommmand final : public ULAnimNotifyBase
{
public:
	class FName                                   Command;                                           // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0050(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipCommandPrerequisitiesCheck;                    // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_ApplyCommmand">();
	}
	static class ULAnimNotify_ApplyCommmand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_ApplyCommmand>();
	}
};
static_assert(alignof(ULAnimNotify_ApplyCommmand) == 0x000008, "Wrong alignment on ULAnimNotify_ApplyCommmand");
static_assert(sizeof(ULAnimNotify_ApplyCommmand) == 0x000060, "Wrong size on ULAnimNotify_ApplyCommmand");
static_assert(offsetof(ULAnimNotify_ApplyCommmand, Command) == 0x000048, "Member 'ULAnimNotify_ApplyCommmand::Command' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_ApplyCommmand, Lever) == 0x000050, "Member 'ULAnimNotify_ApplyCommmand::Lever' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_ApplyCommmand, SkipCommandPrerequisitiesCheck) == 0x00005C, "Member 'ULAnimNotify_ApplyCommmand::SkipCommandPrerequisitiesCheck' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_UseBodyLookat
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_UseBodyLookat final : public ULAnimNotifyStateBase
{
public:
	ELLookAtUpperBodyType                         LookAtType;                                        // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookatScale;                                       // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_UseBodyLookat">();
	}
	static class ULAnimNotifyState_UseBodyLookat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_UseBodyLookat>();
	}
};
static_assert(alignof(ULAnimNotifyState_UseBodyLookat) == 0x000008, "Wrong alignment on ULAnimNotifyState_UseBodyLookat");
static_assert(sizeof(ULAnimNotifyState_UseBodyLookat) == 0x000048, "Wrong size on ULAnimNotifyState_UseBodyLookat");
static_assert(offsetof(ULAnimNotifyState_UseBodyLookat, LookAtType) == 0x000040, "Member 'ULAnimNotifyState_UseBodyLookat::LookAtType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseBodyLookat, LookatScale) == 0x000044, "Member 'ULAnimNotifyState_UseBodyLookat::LookatScale' has a wrong offset!");

// Class ProjectP.LPropHUDEventComponent
// 0x0010 (0x00C0 - 0x00B0)
class ULPropHUDEventComponent final : public UActorComponent
{
public:
	class FName                                   HUDEvent;                                          // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForTrainingArea;                                 // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropHUDEventComponent">();
	}
	static class ULPropHUDEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropHUDEventComponent>();
	}
};
static_assert(alignof(ULPropHUDEventComponent) == 0x000008, "Wrong alignment on ULPropHUDEventComponent");
static_assert(sizeof(ULPropHUDEventComponent) == 0x0000C0, "Wrong size on ULPropHUDEventComponent");
static_assert(offsetof(ULPropHUDEventComponent, HUDEvent) == 0x0000B0, "Member 'ULPropHUDEventComponent::HUDEvent' has a wrong offset!");
static_assert(offsetof(ULPropHUDEventComponent, IsForTrainingArea) == 0x0000B8, "Member 'ULPropHUDEventComponent::IsForTrainingArea' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_UseHeadLookat_Disable
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_UseHeadLookat_Disable final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_UseHeadLookat_Disable">();
	}
	static class ULAnimNotifyState_UseHeadLookat_Disable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_UseHeadLookat_Disable>();
	}
};
static_assert(alignof(ULAnimNotifyState_UseHeadLookat_Disable) == 0x000008, "Wrong alignment on ULAnimNotifyState_UseHeadLookat_Disable");
static_assert(sizeof(ULAnimNotifyState_UseHeadLookat_Disable) == 0x000040, "Wrong size on ULAnimNotifyState_UseHeadLookat_Disable");

// Class ProjectP.LPreloadTargetComponent
// 0x0030 (0x00E0 - 0x00B0)
class ULPreloadTargetComponent final : public UActorComponent
{
public:
	TArray<TSoftObjectPtr<class UParticleSystem>> ParticleArray;                                     // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  NiagaraArray;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USoundBase>>      SoundArray;                                        // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPreloadTargetComponent">();
	}
	static class ULPreloadTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPreloadTargetComponent>();
	}
};
static_assert(alignof(ULPreloadTargetComponent) == 0x000008, "Wrong alignment on ULPreloadTargetComponent");
static_assert(sizeof(ULPreloadTargetComponent) == 0x0000E0, "Wrong size on ULPreloadTargetComponent");
static_assert(offsetof(ULPreloadTargetComponent, ParticleArray) == 0x0000B0, "Member 'ULPreloadTargetComponent::ParticleArray' has a wrong offset!");
static_assert(offsetof(ULPreloadTargetComponent, NiagaraArray) == 0x0000C0, "Member 'ULPreloadTargetComponent::NiagaraArray' has a wrong offset!");
static_assert(offsetof(ULPreloadTargetComponent, SoundArray) == 0x0000D0, "Member 'ULPreloadTargetComponent::SoundArray' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_SkillMove
// 0x00B0 (0x00F0 - 0x0040)
class ULAnimNotifyState_SkillMove final : public ULAnimNotifyStateBase
{
public:
	class FName                                   SkillMoveID;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseOverride : 1;                                   // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSkillMoveInfoOverride                SkillMoveOverride;                                 // 0x0050(0x00A0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_SkillMove">();
	}
	static class ULAnimNotifyState_SkillMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_SkillMove>();
	}
};
static_assert(alignof(ULAnimNotifyState_SkillMove) == 0x000008, "Wrong alignment on ULAnimNotifyState_SkillMove");
static_assert(sizeof(ULAnimNotifyState_SkillMove) == 0x0000F0, "Wrong size on ULAnimNotifyState_SkillMove");
static_assert(offsetof(ULAnimNotifyState_SkillMove, SkillMoveID) == 0x000040, "Member 'ULAnimNotifyState_SkillMove::SkillMoveID' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_SkillMove, SkillMoveOverride) == 0x000050, "Member 'ULAnimNotifyState_SkillMove::SkillMoveOverride' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_SkillMove_New
// 0x00B0 (0x00F0 - 0x0040)
class ULAnimNotifyState_SkillMove_New final : public ULAnimNotifyStateBase
{
public:
	class FName                                   SkillMoveID;                                       // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseOverride : 1;                                   // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSkillMoveInfoOverride                SkillMoveOverride;                                 // 0x0050(0x00A0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_SkillMove_New">();
	}
	static class ULAnimNotifyState_SkillMove_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_SkillMove_New>();
	}
};
static_assert(alignof(ULAnimNotifyState_SkillMove_New) == 0x000008, "Wrong alignment on ULAnimNotifyState_SkillMove_New");
static_assert(sizeof(ULAnimNotifyState_SkillMove_New) == 0x0000F0, "Wrong size on ULAnimNotifyState_SkillMove_New");
static_assert(offsetof(ULAnimNotifyState_SkillMove_New, SkillMoveID) == 0x000040, "Member 'ULAnimNotifyState_SkillMove_New::SkillMoveID' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_SkillMove_New, SkillMoveOverride) == 0x000050, "Member 'ULAnimNotifyState_SkillMove_New::SkillMoveOverride' has a wrong offset!");

// Class ProjectP.LQuartzPocket
// 0x0028 (0x0050 - 0x0028)
class ULQuartzPocket final : public UObject
{
public:
	struct FQuartzPocketInfoPtr                   PocketInfo;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLQuartzSlot>                   QuartzSlotList;                                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLQuartzPocketSynergy                  Synergy;                                           // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool InstallSlotFromUI(int32 InSlotIndex, class FName QuartzEffectCodeName);

	int32 GetPocketLevel() const;
	bool IsPocketUnlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LQuartzPocket">();
	}
	static class ULQuartzPocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULQuartzPocket>();
	}
};
static_assert(alignof(ULQuartzPocket) == 0x000008, "Wrong alignment on ULQuartzPocket");
static_assert(sizeof(ULQuartzPocket) == 0x000050, "Wrong size on ULQuartzPocket");
static_assert(offsetof(ULQuartzPocket, PocketInfo) == 0x000028, "Member 'ULQuartzPocket::PocketInfo' has a wrong offset!");
static_assert(offsetof(ULQuartzPocket, QuartzSlotList) == 0x000030, "Member 'ULQuartzPocket::QuartzSlotList' has a wrong offset!");
static_assert(offsetof(ULQuartzPocket, Synergy) == 0x000040, "Member 'ULQuartzPocket::Synergy' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Projectile
// 0x0050 (0x0090 - 0x0040)
class ULAnimNotifyState_Projectile final : public ULAnimNotifyStateBase
{
public:
	class FName                                   ProjectileID;                                      // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnOffset;                                       // 0x0050(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALProjectile>            TestProjectile;                                    // 0x0080(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Projectile">();
	}
	static class ULAnimNotifyState_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Projectile>();
	}
};
static_assert(alignof(ULAnimNotifyState_Projectile) == 0x000010, "Wrong alignment on ULAnimNotifyState_Projectile");
static_assert(sizeof(ULAnimNotifyState_Projectile) == 0x000090, "Wrong size on ULAnimNotifyState_Projectile");
static_assert(offsetof(ULAnimNotifyState_Projectile, ProjectileID) == 0x000040, "Member 'ULAnimNotifyState_Projectile::ProjectileID' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Projectile, SpawnOffset) == 0x000050, "Member 'ULAnimNotifyState_Projectile::SpawnOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Projectile, TestProjectile) == 0x000080, "Member 'ULAnimNotifyState_Projectile::TestProjectile' has a wrong offset!");

// Class ProjectP.LProjectile
// 0x01F0 (0x03D0 - 0x01E0)
class ALProjectile : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ProjectileHandleId;                                // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProjectileInfoPtr                     Info;                                              // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          StopByNotify;                                      // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALProjectileDesign*                     ProjectileDesign;                                  // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RootParentActor;                                   // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  AttachedActor;                                     // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInPool;                                          // 0x0220(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnderDestroying;                                 // 0x0221(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPaused;                                          // 0x0222(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollisionCheck;                             // 0x0223(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           Timer_StartCollisionCheck;                         // 0x0228(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfile;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Cached_StartTransform;                             // 0x0240(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           Timer_LifeTime;                                    // 0x0270(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULProjectileHit_PeriodicHandler*> PeriodicHitHandlerList;                            // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ULProjectileHit_PeriodicHandler_V2*> PeriodicHitHandler_V2_List;                        // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ULProjectileSpawn_PeriodicHandler*> PeriodicChildSpawnHandlerList;                     // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ULProjectile_AbnormalApplyInRange*      AbnormalApplyInRangeInfo;                          // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         VictimCheckerList;                                 // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0xF8];                                     // 0x02D0(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldCheckCollisionHitAfterOverlapCheck;         // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckTargetHittable(class AActor* Victim, class FName SkillHitCodeName);
	bool CheckValidFaction(class AActor* Victim);
	bool CheckValidOverlapTarget(class AActor* Victim);
	bool CheckValidTargetType(class AActor* Victim);
	void ClearOverlappedActorList();
	void GenerateHit(const struct FLProjectileHitInfo& HitInfo, const struct FVector& Location);
	void GenerateHit_TargetOnly(const struct FLProjectileHitInfo& ProjectileHitInfo, const struct FHitResult& HitResult);
	void GenerateHit_TargetOnly_V2(const struct FLProjectileHitInfo_V2& ProjectileHitInfo, const struct FHitResult& HitResult);
	void GenerateHit_V2(const struct FLProjectileHitInfo_V2& HitInfo, const struct FVector& Location);
	void GetOverlappedActorList(TArray<class AActor*>* OutList);
	void InitializeFromProjectileDesign();
	bool InitProjectile(const struct FProjectileInfoPtr& InInfo, const struct FLProjectileSpawnParameter& SpawnParameters);
	bool IsStopByNotify();
	bool IsStopByRootOwnerDie();
	void OnAttachedActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void OnAttackedByOther(class AActor* Other, class FName SkillHitCodeName);
	void OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& SweepResult);
	void OnCollisionHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FHitResult& HitResult);
	void OnDeadParentCharacter(class ALCharacter* DeadCharacter);
	void OnDisappear(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult);
	void OnExplode(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult);
	void OnLifeTimeOver();
	void ProcessHit(const struct FLProjectileHitInfo& HitInfo, const struct FHitResult& HitResult);
	void ProcessHitProp(const struct FLProjectileHitInfo& ProjectileHitInfo, const struct FHitResult& HitResult);
	void Reset();
	void SenseTarget();
	void SpawnChildren(const struct FLChildProjectileSpawnInfo& ChildSpawnInfo);
	bool SpawnProjectileDesignActor();
	void Start();
	void StartCollisionCheck();
	void Stop();
	void StopApplyAbnormal();
	void StopGeneratePeriodicHit();
	void StopSpawnChildren();
	void UpdateOverlapEvents(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile">();
	}
	static class ALProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile>();
	}
};
static_assert(alignof(ALProjectile) == 0x000010, "Wrong alignment on ALProjectile");
static_assert(sizeof(ALProjectile) == 0x0003D0, "Wrong size on ALProjectile");
static_assert(offsetof(ALProjectile, ProjectileHandleId) == 0x0001E8, "Member 'ALProjectile::ProjectileHandleId' has a wrong offset!");
static_assert(offsetof(ALProjectile, Info) == 0x0001F0, "Member 'ALProjectile::Info' has a wrong offset!");
static_assert(offsetof(ALProjectile, StopByNotify) == 0x0001F8, "Member 'ALProjectile::StopByNotify' has a wrong offset!");
static_assert(offsetof(ALProjectile, ProjectileDesign) == 0x000200, "Member 'ALProjectile::ProjectileDesign' has a wrong offset!");
static_assert(offsetof(ALProjectile, RootParentActor) == 0x000208, "Member 'ALProjectile::RootParentActor' has a wrong offset!");
static_assert(offsetof(ALProjectile, TargetActor) == 0x000210, "Member 'ALProjectile::TargetActor' has a wrong offset!");
static_assert(offsetof(ALProjectile, AttachedActor) == 0x000218, "Member 'ALProjectile::AttachedActor' has a wrong offset!");
static_assert(offsetof(ALProjectile, IsInPool) == 0x000220, "Member 'ALProjectile::IsInPool' has a wrong offset!");
static_assert(offsetof(ALProjectile, IsUnderDestroying) == 0x000221, "Member 'ALProjectile::IsUnderDestroying' has a wrong offset!");
static_assert(offsetof(ALProjectile, IsPaused) == 0x000222, "Member 'ALProjectile::IsPaused' has a wrong offset!");
static_assert(offsetof(ALProjectile, bEnableCollisionCheck) == 0x000223, "Member 'ALProjectile::bEnableCollisionCheck' has a wrong offset!");
static_assert(offsetof(ALProjectile, Timer_StartCollisionCheck) == 0x000228, "Member 'ALProjectile::Timer_StartCollisionCheck' has a wrong offset!");
static_assert(offsetof(ALProjectile, CollisionProfile) == 0x000230, "Member 'ALProjectile::CollisionProfile' has a wrong offset!");
static_assert(offsetof(ALProjectile, CollisionRadius) == 0x000238, "Member 'ALProjectile::CollisionRadius' has a wrong offset!");
static_assert(offsetof(ALProjectile, Cached_StartTransform) == 0x000240, "Member 'ALProjectile::Cached_StartTransform' has a wrong offset!");
static_assert(offsetof(ALProjectile, Timer_LifeTime) == 0x000270, "Member 'ALProjectile::Timer_LifeTime' has a wrong offset!");
static_assert(offsetof(ALProjectile, PeriodicHitHandlerList) == 0x000278, "Member 'ALProjectile::PeriodicHitHandlerList' has a wrong offset!");
static_assert(offsetof(ALProjectile, PeriodicHitHandler_V2_List) == 0x000288, "Member 'ALProjectile::PeriodicHitHandler_V2_List' has a wrong offset!");
static_assert(offsetof(ALProjectile, PeriodicChildSpawnHandlerList) == 0x000298, "Member 'ALProjectile::PeriodicChildSpawnHandlerList' has a wrong offset!");
static_assert(offsetof(ALProjectile, AbnormalApplyInRangeInfo) == 0x0002A8, "Member 'ALProjectile::AbnormalApplyInRangeInfo' has a wrong offset!");
static_assert(offsetof(ALProjectile, VictimCheckerList) == 0x0002C0, "Member 'ALProjectile::VictimCheckerList' has a wrong offset!");
static_assert(offsetof(ALProjectile, bShouldCheckCollisionHitAfterOverlapCheck) == 0x0003C8, "Member 'ALProjectile::bShouldCheckCollisionHitAfterOverlapCheck' has a wrong offset!");

// Class ProjectP.LProjectile_Typical
// 0x0030 (0x0400 - 0x03D0)
#pragma pack(push, 0x1)
class alignas(0x10) ALProjectile_Typical : public ALProjectile
{
public:
	struct FTimerHandle                           Timer_Activate;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x1B];                                     // 0x03DD(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_Typical">();
	}
	static class ALProjectile_Typical* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_Typical>();
	}
};
#pragma pack(pop)
static_assert(alignof(ALProjectile_Typical) == 0x000010, "Wrong alignment on ALProjectile_Typical");
static_assert(sizeof(ALProjectile_Typical) == 0x000400, "Wrong size on ALProjectile_Typical");
static_assert(offsetof(ALProjectile_Typical, Timer_Activate) == 0x0003D0, "Member 'ALProjectile_Typical::Timer_Activate' has a wrong offset!");
static_assert(offsetof(ALProjectile_Typical, MaxDistance) == 0x0003D8, "Member 'ALProjectile_Typical::MaxDistance' has a wrong offset!");
static_assert(offsetof(ALProjectile_Typical, bActivated) == 0x0003DC, "Member 'ALProjectile_Typical::bActivated' has a wrong offset!");

// Class ProjectP.LProjectile_Fixed
// 0x0000 (0x0400 - 0x0400)
class ALProjectile_Fixed : public ALProjectile_Typical
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_Fixed">();
	}
	static class ALProjectile_Fixed* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_Fixed>();
	}
};
static_assert(alignof(ALProjectile_Fixed) == 0x000010, "Wrong alignment on ALProjectile_Fixed");
static_assert(sizeof(ALProjectile_Fixed) == 0x000400, "Wrong size on ALProjectile_Fixed");

// Class ProjectP.LAnimNotify_HpRestore
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_HpRestore final : public ULAnimNotifyBase
{
public:
	float                                         HPRestoreRatio;                                    // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HPRestoreValue;                                    // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_HpRestore">();
	}
	static class ULAnimNotify_HpRestore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_HpRestore>();
	}
};
static_assert(alignof(ULAnimNotify_HpRestore) == 0x000008, "Wrong alignment on ULAnimNotify_HpRestore");
static_assert(sizeof(ULAnimNotify_HpRestore) == 0x000050, "Wrong size on ULAnimNotify_HpRestore");
static_assert(offsetof(ULAnimNotify_HpRestore, HPRestoreRatio) == 0x000048, "Member 'ULAnimNotify_HpRestore::HPRestoreRatio' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_HpRestore, HPRestoreValue) == 0x00004C, "Member 'ULAnimNotify_HpRestore::HPRestoreValue' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayParticleEffect
// 0x0010 (0x00A0 - 0x0090)
class ULAnimNotify_PlayParticleEffect final : public UAnimNotify_PlayParticleEffect
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseAbsoluteRotation;                               // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0099(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayParticleEffect">();
	}
	static class ULAnimNotify_PlayParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayParticleEffect>();
	}
};
static_assert(alignof(ULAnimNotify_PlayParticleEffect) == 0x000010, "Wrong alignment on ULAnimNotify_PlayParticleEffect");
static_assert(sizeof(ULAnimNotify_PlayParticleEffect) == 0x0000A0, "Wrong size on ULAnimNotify_PlayParticleEffect");
static_assert(offsetof(ULAnimNotify_PlayParticleEffect, UseAbsoluteRotation) == 0x000098, "Member 'ULAnimNotify_PlayParticleEffect::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayParticleEffect, Enabled) == 0x000099, "Member 'ULAnimNotify_PlayParticleEffect::Enabled' has a wrong offset!");

// Class ProjectP.LProjectileHit_PeriodicHandler_V2
// 0x0048 (0x0070 - 0x0028)
class ULProjectileHit_PeriodicHandler_V2 final : public UObject
{
public:
	class ALProjectile*                           Owner;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectileHitInfo_V2                 HitInfo;                                           // 0x0030(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Initialize(class ALProjectile* InOwner, const struct FLProjectileHitInfo_V2& InHitInfo);
	void OnGenerateHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectileHit_PeriodicHandler_V2">();
	}
	static class ULProjectileHit_PeriodicHandler_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjectileHit_PeriodicHandler_V2>();
	}
};
static_assert(alignof(ULProjectileHit_PeriodicHandler_V2) == 0x000008, "Wrong alignment on ULProjectileHit_PeriodicHandler_V2");
static_assert(sizeof(ULProjectileHit_PeriodicHandler_V2) == 0x000070, "Wrong size on ULProjectileHit_PeriodicHandler_V2");
static_assert(offsetof(ULProjectileHit_PeriodicHandler_V2, Owner) == 0x000028, "Member 'ULProjectileHit_PeriodicHandler_V2::Owner' has a wrong offset!");
static_assert(offsetof(ULProjectileHit_PeriodicHandler_V2, HitInfo) == 0x000030, "Member 'ULProjectileHit_PeriodicHandler_V2::HitInfo' has a wrong offset!");
static_assert(offsetof(ULProjectileHit_PeriodicHandler_V2, TimerHandle) == 0x000060, "Member 'ULProjectileHit_PeriodicHandler_V2::TimerHandle' has a wrong offset!");
static_assert(offsetof(ULProjectileHit_PeriodicHandler_V2, Count) == 0x000068, "Member 'ULProjectileHit_PeriodicHandler_V2::Count' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayNiagaraEffect
// 0x0120 (0x01B0 - 0x0090)
class ULAnimNotify_PlayNiagaraEffect final : public UAnimNotify_PlayNiagaraEffect
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseAbsoluteRotation;                               // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0099(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x00A0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x00B0(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x0100(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0150(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x01A0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0xF];                                      // 0x01A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayNiagaraEffect">();
	}
	static class ULAnimNotify_PlayNiagaraEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayNiagaraEffect>();
	}
};
static_assert(alignof(ULAnimNotify_PlayNiagaraEffect) == 0x000010, "Wrong alignment on ULAnimNotify_PlayNiagaraEffect");
static_assert(sizeof(ULAnimNotify_PlayNiagaraEffect) == 0x0001B0, "Wrong size on ULAnimNotify_PlayNiagaraEffect");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, UseAbsoluteRotation) == 0x000098, "Member 'ULAnimNotify_PlayNiagaraEffect::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, Enabled) == 0x000099, "Member 'ULAnimNotify_PlayNiagaraEffect::Enabled' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, DisableWhenWeaponInListBroken) == 0x0000A0, "Member 'ULAnimNotify_PlayNiagaraEffect::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, ApplyVariableFloat) == 0x0000B0, "Member 'ULAnimNotify_PlayNiagaraEffect::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, ApplyVariableVector2) == 0x000100, "Member 'ULAnimNotify_PlayNiagaraEffect::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, ApplyVariableVector3) == 0x000150, "Member 'ULAnimNotify_PlayNiagaraEffect::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayNiagaraEffect, MeshSelectionType) == 0x0001A0, "Member 'ULAnimNotify_PlayNiagaraEffect::MeshSelectionType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_TimedParticleEffect
// 0x0038 (0x0098 - 0x0060)
class ULAnimNotifyState_TimedParticleEffect final : public UAnimNotifyState_TimedParticleEffect
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseAbsoluteRotation;                               // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x006C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AttachedComponent;                                 // 0x0078(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0088(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_TimedParticleEffect">();
	}
	static class ULAnimNotifyState_TimedParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_TimedParticleEffect>();
	}
};
static_assert(alignof(ULAnimNotifyState_TimedParticleEffect) == 0x000008, "Wrong alignment on ULAnimNotifyState_TimedParticleEffect");
static_assert(sizeof(ULAnimNotifyState_TimedParticleEffect) == 0x000098, "Wrong size on ULAnimNotifyState_TimedParticleEffect");
static_assert(offsetof(ULAnimNotifyState_TimedParticleEffect, UseAbsoluteRotation) == 0x000068, "Member 'ULAnimNotifyState_TimedParticleEffect::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedParticleEffect, bAttached) == 0x000069, "Member 'ULAnimNotifyState_TimedParticleEffect::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedParticleEffect, Scale) == 0x00006C, "Member 'ULAnimNotifyState_TimedParticleEffect::Scale' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedParticleEffect, AttachedComponent) == 0x000078, "Member 'ULAnimNotifyState_TimedParticleEffect::AttachedComponent' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedParticleEffect, Enabled) == 0x000080, "Member 'ULAnimNotifyState_TimedParticleEffect::Enabled' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_TimedParticleEffect, DisableWhenWeaponInListBroken) == 0x000088, "Member 'ULAnimNotifyState_TimedParticleEffect::DisableWhenWeaponInListBroken' has a wrong offset!");

// Class ProjectP.LPlayerItemLocker
// 0x0118 (0x0140 - 0x0028)
class ULPlayerItemLocker final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAddItem;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddItemFail;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveItem;                                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateItem;                                      // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetItemEventWithCount;                           // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetItemSpecialWithCount;                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefillItem;                                      // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> ItemCategoryMap;                                   // 0x00A0(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULWeaponItem*>                   WeaponItemList;                                    // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         AllItemList;                                       // 0x0100(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         CommonItemList;                                    // 0x0110(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         RequirementItemList;                               // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AbandonItem(class ULItem* Item, int32 RemoveCount);
	bool AddItem(class ULItem* Item);
	void EmptyItems();
	TArray<class ULItem*> FindCategoryItems(ELItemSecondCategory Category);
	class ULItem* FindItemByCodeName(class FName CodeName);
	TArray<class ULItem*> FindItemsByCodeName(class FName CodeName);
	TArray<class ULItem*> FindUICategoryItems(ELItemFirstCategory Category);
	const TArray<class ULItem*> GetAllItems();
	const TArray<class ULItem*> GetCommonItems();
	const TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> GetItemCategoryMap();
	int32 GetItemTotalCountByCodeName(class FName CodeName);
	int32 GetMaxItemCountMovableToInventory(class ULItem* Item);
	const TArray<class ULItem*> GetRequirementItems();
	const TArray<class ULWeaponItem*> GetWeaponItems();
	int32 GetWeaponTotalCountByCodeName(class FName HandleCodeName, class FName BladeCodeName);
	bool HasItem(class ULItem* Item);
	bool MoveItemToInventory(class ULItem* Item, int32 ItemCount, bool bManualMove);
	void RefillMonadUnitItem();
	bool RemoveItem(class ULItem* Item);

	bool HasSameItem(class FName ItemCodeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayerItemLocker">();
	}
	static class ULPlayerItemLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayerItemLocker>();
	}
};
static_assert(alignof(ULPlayerItemLocker) == 0x000008, "Wrong alignment on ULPlayerItemLocker");
static_assert(sizeof(ULPlayerItemLocker) == 0x000140, "Wrong size on ULPlayerItemLocker");
static_assert(offsetof(ULPlayerItemLocker, OnAddItem) == 0x000030, "Member 'ULPlayerItemLocker::OnAddItem' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, OnAddItemFail) == 0x000040, "Member 'ULPlayerItemLocker::OnAddItemFail' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, OnRemoveItem) == 0x000050, "Member 'ULPlayerItemLocker::OnRemoveItem' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, OnUpdateItem) == 0x000060, "Member 'ULPlayerItemLocker::OnUpdateItem' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, OnGetItemEventWithCount) == 0x000070, "Member 'ULPlayerItemLocker::OnGetItemEventWithCount' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, OnGetItemSpecialWithCount) == 0x000080, "Member 'ULPlayerItemLocker::OnGetItemSpecialWithCount' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, OnRefillItem) == 0x000090, "Member 'ULPlayerItemLocker::OnRefillItem' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, ItemCategoryMap) == 0x0000A0, "Member 'ULPlayerItemLocker::ItemCategoryMap' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, WeaponItemList) == 0x0000F0, "Member 'ULPlayerItemLocker::WeaponItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, AllItemList) == 0x000100, "Member 'ULPlayerItemLocker::AllItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, CommonItemList) == 0x000110, "Member 'ULPlayerItemLocker::CommonItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerItemLocker, RequirementItemList) == 0x000120, "Member 'ULPlayerItemLocker::RequirementItemList' has a wrong offset!");

// Class ProjectP.LPropDestructMarkerComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULPropDestructMarkerComponent final : public USceneComponent
{
public:
	float                                         Strength;                                          // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropDestructMarkerComponent">();
	}
	static class ULPropDestructMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropDestructMarkerComponent>();
	}
};
static_assert(alignof(ULPropDestructMarkerComponent) == 0x000010, "Wrong alignment on ULPropDestructMarkerComponent");
static_assert(sizeof(ULPropDestructMarkerComponent) == 0x0001F0, "Wrong size on ULPropDestructMarkerComponent");
static_assert(offsetof(ULPropDestructMarkerComponent, Strength) == 0x0001E8, "Member 'ULPropDestructMarkerComponent::Strength' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_NiagaraTrailEffect
// 0x0130 (0x0190 - 0x0060)
class ULAnimNotifyState_NiagaraTrailEffect final : public UAnimNotifyState_TimedNiagaraEffect
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseAbsoluteRotation;                               // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x006C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AttachedComponent;                                 // 0x0078(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0088(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x0098(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x00E8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0138(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0188(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           CheckElementDamageType;                            // 0x0189(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x6];                                      // 0x018A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_NiagaraTrailEffect">();
	}
	static class ULAnimNotifyState_NiagaraTrailEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_NiagaraTrailEffect>();
	}
};
static_assert(alignof(ULAnimNotifyState_NiagaraTrailEffect) == 0x000008, "Wrong alignment on ULAnimNotifyState_NiagaraTrailEffect");
static_assert(sizeof(ULAnimNotifyState_NiagaraTrailEffect) == 0x000190, "Wrong size on ULAnimNotifyState_NiagaraTrailEffect");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, UseAbsoluteRotation) == 0x000068, "Member 'ULAnimNotifyState_NiagaraTrailEffect::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, Scale) == 0x00006C, "Member 'ULAnimNotifyState_NiagaraTrailEffect::Scale' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, AttachedComponent) == 0x000078, "Member 'ULAnimNotifyState_NiagaraTrailEffect::AttachedComponent' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, Enabled) == 0x000080, "Member 'ULAnimNotifyState_NiagaraTrailEffect::Enabled' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, DisableWhenWeaponInListBroken) == 0x000088, "Member 'ULAnimNotifyState_NiagaraTrailEffect::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, ApplyVariableFloat) == 0x000098, "Member 'ULAnimNotifyState_NiagaraTrailEffect::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, ApplyVariableVector2) == 0x0000E8, "Member 'ULAnimNotifyState_NiagaraTrailEffect::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, ApplyVariableVector3) == 0x000138, "Member 'ULAnimNotifyState_NiagaraTrailEffect::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, MeshSelectionType) == 0x000188, "Member 'ULAnimNotifyState_NiagaraTrailEffect::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NiagaraTrailEffect, CheckElementDamageType) == 0x000189, "Member 'ULAnimNotifyState_NiagaraTrailEffect::CheckElementDamageType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_PlayDecal
// 0x0048 (0x0088 - 0x0040)
class ULAnimNotifyState_PlayDecal final : public ULAnimNotifyStateBase
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0054(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x0060(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRandomRotate;                                   // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0078(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_PlayDecal">();
	}
	static class ULAnimNotifyState_PlayDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_PlayDecal>();
	}
};
static_assert(alignof(ULAnimNotifyState_PlayDecal) == 0x000008, "Wrong alignment on ULAnimNotifyState_PlayDecal");
static_assert(sizeof(ULAnimNotifyState_PlayDecal) == 0x000088, "Wrong size on ULAnimNotifyState_PlayDecal");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, Material) == 0x000040, "Member 'ULAnimNotifyState_PlayDecal::Material' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, LocationOffset) == 0x000048, "Member 'ULAnimNotifyState_PlayDecal::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, RotationOffset) == 0x000054, "Member 'ULAnimNotifyState_PlayDecal::RotationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, DecalSize) == 0x000060, "Member 'ULAnimNotifyState_PlayDecal::DecalSize' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, LifeSpan) == 0x00006C, "Member 'ULAnimNotifyState_PlayDecal::LifeSpan' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, UseRandomRotate) == 0x000070, "Member 'ULAnimNotifyState_PlayDecal::UseRandomRotate' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayDecal, DisableWhenWeaponInListBroken) == 0x000078, "Member 'ULAnimNotifyState_PlayDecal::DisableWhenWeaponInListBroken' has a wrong offset!");

// Class ProjectP.LProduct
// 0x0028 (0x0050 - 0x0028)
class ULProduct final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GoodsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ConnectedItem;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanStackCount();
	class ULItem* GetItem();
	int32 Price();
	int32 StockCount();

	int32 BuyNumMax() const;
	bool CanBuyInfinity() const;
	bool CanDisplayOn() const;
	ELShopProductType GetProductType() const;
	bool IsWeapon() const;
	struct FLSpecialShopExchangeNeeds Needs() const;
	int32 OriginStockCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProduct">();
	}
	static class ULProduct* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProduct>();
	}
};
static_assert(alignof(ULProduct) == 0x000008, "Wrong alignment on ULProduct");
static_assert(sizeof(ULProduct) == 0x000050, "Wrong size on ULProduct");
static_assert(offsetof(ULProduct, GoodsCodeName) == 0x000040, "Member 'ULProduct::GoodsCodeName' has a wrong offset!");
static_assert(offsetof(ULProduct, ConnectedItem) == 0x000048, "Member 'ULProduct::ConnectedItem' has a wrong offset!");

// Class ProjectP.LProjectile_NonTypical
// 0x0000 (0x03D0 - 0x03D0)
class ALProjectile_NonTypical : public ALProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_NonTypical">();
	}
	static class ALProjectile_NonTypical* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_NonTypical>();
	}
};
static_assert(alignof(ALProjectile_NonTypical) == 0x000010, "Wrong alignment on ALProjectile_NonTypical");
static_assert(sizeof(ALProjectile_NonTypical) == 0x0003D0, "Wrong size on ALProjectile_NonTypical");

// Class ProjectP.LAnimNotifyState_NPCSkillLink
// 0x0070 (0x00B0 - 0x0040)
class ULAnimNotifyState_NPCSkillLink final : public ULAnimNotifyStateBase
{
public:
	class FName                                   SkillLinkCodeName;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseOverride : 1;                                   // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSkillLinkInfoOverride                SkillLinkOverride;                                 // 0x0050(0x0060)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_NPCSkillLink">();
	}
	static class ULAnimNotifyState_NPCSkillLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_NPCSkillLink>();
	}
};
static_assert(alignof(ULAnimNotifyState_NPCSkillLink) == 0x000008, "Wrong alignment on ULAnimNotifyState_NPCSkillLink");
static_assert(sizeof(ULAnimNotifyState_NPCSkillLink) == 0x0000B0, "Wrong size on ULAnimNotifyState_NPCSkillLink");
static_assert(offsetof(ULAnimNotifyState_NPCSkillLink, SkillLinkCodeName) == 0x000040, "Member 'ULAnimNotifyState_NPCSkillLink::SkillLinkCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_NPCSkillLink, SkillLinkOverride) == 0x000050, "Member 'ULAnimNotifyState_NPCSkillLink::SkillLinkOverride' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ReservePreInput
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ReservePreInput final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ReservePreInput">();
	}
	static class ULAnimNotifyState_ReservePreInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ReservePreInput>();
	}
};
static_assert(alignof(ULAnimNotifyState_ReservePreInput) == 0x000008, "Wrong alignment on ULAnimNotifyState_ReservePreInput");
static_assert(sizeof(ULAnimNotifyState_ReservePreInput) == 0x000040, "Wrong size on ULAnimNotifyState_ReservePreInput");

// Class ProjectP.LProductShop
// 0x0000 (0x0028 - 0x0028)
class ULProductShop : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProductShop">();
	}
	static class ULProductShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProductShop>();
	}
};
static_assert(alignof(ULProductShop) == 0x000008, "Wrong alignment on ULProductShop");
static_assert(sizeof(ULProductShop) == 0x000028, "Wrong size on ULProductShop");

// Class ProjectP.LProductSpecialShop
// 0x0028 (0x0050 - 0x0028)
class ULProductSpecialShop final : public ULProductShop
{
public:
	class FName                                   ShopCodeName;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLProductShopItemData>          DealProducts;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class ULProduct*>                      Products;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	bool Buy(class ULProduct* InProduct, int32 InCount);
	TSet<ELItemFirstCategory> GetBuyCategorys();
	TArray<class ULProduct*> GetBuyList(ELItemFirstCategory Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProductSpecialShop">();
	}
	static class ULProductSpecialShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProductSpecialShop>();
	}
};
static_assert(alignof(ULProductSpecialShop) == 0x000008, "Wrong alignment on ULProductSpecialShop");
static_assert(sizeof(ULProductSpecialShop) == 0x000050, "Wrong size on ULProductSpecialShop");
static_assert(offsetof(ULProductSpecialShop, ShopCodeName) == 0x000028, "Member 'ULProductSpecialShop::ShopCodeName' has a wrong offset!");
static_assert(offsetof(ULProductSpecialShop, DealProducts) == 0x000030, "Member 'ULProductSpecialShop::DealProducts' has a wrong offset!");
static_assert(offsetof(ULProductSpecialShop, Products) == 0x000040, "Member 'ULProductSpecialShop::Products' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_StaminaRestore
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_StaminaRestore final : public ULAnimNotifyStateBase
{
public:
	float                                         StaminaRestoreRatio;                               // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_StaminaRestore">();
	}
	static class ULAnimNotifyState_StaminaRestore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_StaminaRestore>();
	}
};
static_assert(alignof(ULAnimNotifyState_StaminaRestore) == 0x000008, "Wrong alignment on ULAnimNotifyState_StaminaRestore");
static_assert(sizeof(ULAnimNotifyState_StaminaRestore) == 0x000048, "Wrong size on ULAnimNotifyState_StaminaRestore");
static_assert(offsetof(ULAnimNotifyState_StaminaRestore, StaminaRestoreRatio) == 0x000040, "Member 'ULAnimNotifyState_StaminaRestore::StaminaRestoreRatio' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Item_On
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_Item_On final : public ULAnimNotifyStateBase
{
public:
	TWeakObjectPtr<class UMeshComponent>          ItemMeshComp;                                      // 0x0040(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ItemMeshActor;                                     // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Item_On">();
	}
	static class ULAnimNotifyState_Item_On* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Item_On>();
	}
};
static_assert(alignof(ULAnimNotifyState_Item_On) == 0x000008, "Wrong alignment on ULAnimNotifyState_Item_On");
static_assert(sizeof(ULAnimNotifyState_Item_On) == 0x000050, "Wrong size on ULAnimNotifyState_Item_On");
static_assert(offsetof(ULAnimNotifyState_Item_On, ItemMeshComp) == 0x000040, "Member 'ULAnimNotifyState_Item_On::ItemMeshComp' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Item_On, ItemMeshActor) == 0x000048, "Member 'ULAnimNotifyState_Item_On::ItemMeshActor' has a wrong offset!");

// Class ProjectP.LProjetileAbnormalApplyTargetInfo
// 0x0030 (0x0058 - 0x0028)
class ULProjetileAbnormalApplyTargetInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjetileAbnormalApplyTargetInfo">();
	}
	static class ULProjetileAbnormalApplyTargetInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjetileAbnormalApplyTargetInfo>();
	}
};
static_assert(alignof(ULProjetileAbnormalApplyTargetInfo) == 0x000008, "Wrong alignment on ULProjetileAbnormalApplyTargetInfo");
static_assert(sizeof(ULProjetileAbnormalApplyTargetInfo) == 0x000058, "Wrong size on ULProjetileAbnormalApplyTargetInfo");

// Class ProjectP.LPropActor
// 0x0010 (0x0220 - 0x0210)
class ALPropActor : public ALInteractActor
{
public:
	TWeakObjectPtr<class ULPropComponent>         PropComponent;                                     // 0x0210(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0218(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropActor">();
	}
	static class ALPropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropActor>();
	}
};
static_assert(alignof(ALPropActor) == 0x000008, "Wrong alignment on ALPropActor");
static_assert(sizeof(ALPropActor) == 0x000220, "Wrong size on ALPropActor");
static_assert(offsetof(ALPropActor, PropComponent) == 0x000210, "Member 'ALPropActor::PropComponent' has a wrong offset!");
static_assert(offsetof(ALPropActor, SkeletalMeshComponent) == 0x000218, "Member 'ALPropActor::SkeletalMeshComponent' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_SetGroggyRecoveryRatio
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_SetGroggyRecoveryRatio final : public ULAnimNotifyStateBase
{
public:
	float                                         GroggyRecoveryRatio;                               // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_SetGroggyRecoveryRatio">();
	}
	static class ULAnimNotifyState_SetGroggyRecoveryRatio* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_SetGroggyRecoveryRatio>();
	}
};
static_assert(alignof(ULAnimNotifyState_SetGroggyRecoveryRatio) == 0x000008, "Wrong alignment on ULAnimNotifyState_SetGroggyRecoveryRatio");
static_assert(sizeof(ULAnimNotifyState_SetGroggyRecoveryRatio) == 0x000048, "Wrong size on ULAnimNotifyState_SetGroggyRecoveryRatio");
static_assert(offsetof(ULAnimNotifyState_SetGroggyRecoveryRatio, GroggyRecoveryRatio) == 0x000040, "Member 'ULAnimNotifyState_SetGroggyRecoveryRatio::GroggyRecoveryRatio' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ChangeState_Dead
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ChangeState_Dead final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangeState_Dead">();
	}
	static class ULAnimNotifyState_ChangeState_Dead* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangeState_Dead>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangeState_Dead) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangeState_Dead");
static_assert(sizeof(ULAnimNotifyState_ChangeState_Dead) == 0x000040, "Wrong size on ULAnimNotifyState_ChangeState_Dead");

// Class ProjectP.LNPCSpecConditionBase
// 0x0008 (0x0030 - 0x0028)
class ULNPCSpecConditionBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecConditionBase">();
	}
	static class ULNPCSpecConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecConditionBase>();
	}
};
static_assert(alignof(ULNPCSpecConditionBase) == 0x000008, "Wrong alignment on ULNPCSpecConditionBase");
static_assert(sizeof(ULNPCSpecConditionBase) == 0x000030, "Wrong size on ULNPCSpecConditionBase");

// Class ProjectP.LNPCSpecConditionSignal
// 0x0010 (0x0040 - 0x0030)
class ULNPCSpecConditionSignal final : public ULNPCSpecConditionBase
{
public:
	class FString                                 SignalString;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecConditionSignal">();
	}
	static class ULNPCSpecConditionSignal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecConditionSignal>();
	}
};
static_assert(alignof(ULNPCSpecConditionSignal) == 0x000008, "Wrong alignment on ULNPCSpecConditionSignal");
static_assert(sizeof(ULNPCSpecConditionSignal) == 0x000040, "Wrong size on ULNPCSpecConditionSignal");
static_assert(offsetof(ULNPCSpecConditionSignal, SignalString) == 0x000030, "Member 'ULNPCSpecConditionSignal::SignalString' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_UseNavi
// 0x0030 (0x0070 - 0x0040)
class ULAnimNotifyState_UseNavi final : public ULAnimNotifyStateBase
{
public:
	float                                         MoveSpeedRate;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetOffset;                                      // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusRange;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MovableTargetCheck;                                // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ArriveSkillCodeName;                               // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_UseNavi">();
	}
	static class ULAnimNotifyState_UseNavi* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_UseNavi>();
	}
};
static_assert(alignof(ULAnimNotifyState_UseNavi) == 0x000008, "Wrong alignment on ULAnimNotifyState_UseNavi");
static_assert(sizeof(ULAnimNotifyState_UseNavi) == 0x000070, "Wrong size on ULAnimNotifyState_UseNavi");
static_assert(offsetof(ULAnimNotifyState_UseNavi, MoveSpeedRate) == 0x000040, "Member 'ULAnimNotifyState_UseNavi::MoveSpeedRate' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, MoveSpeed) == 0x000044, "Member 'ULAnimNotifyState_UseNavi::MoveSpeed' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, TurnSpeed) == 0x000048, "Member 'ULAnimNotifyState_UseNavi::TurnSpeed' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, TargetType) == 0x00004C, "Member 'ULAnimNotifyState_UseNavi::TargetType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, TargetOffset) == 0x000050, "Member 'ULAnimNotifyState_UseNavi::TargetOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, RadiusRange) == 0x00005C, "Member 'ULAnimNotifyState_UseNavi::RadiusRange' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, MovableTargetCheck) == 0x000060, "Member 'ULAnimNotifyState_UseNavi::MovableTargetCheck' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, DirectionType) == 0x000061, "Member 'ULAnimNotifyState_UseNavi::DirectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_UseNavi, ArriveSkillCodeName) == 0x000064, "Member 'ULAnimNotifyState_UseNavi::ArriveSkillCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_UseNaviSpeedrateChange
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_UseNaviSpeedrateChange final : public ULAnimNotifyStateBase
{
public:
	float                                         MoveSpeedRate;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_UseNaviSpeedrateChange">();
	}
	static class ULAnimNotifyState_UseNaviSpeedrateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_UseNaviSpeedrateChange>();
	}
};
static_assert(alignof(ULAnimNotifyState_UseNaviSpeedrateChange) == 0x000008, "Wrong alignment on ULAnimNotifyState_UseNaviSpeedrateChange");
static_assert(sizeof(ULAnimNotifyState_UseNaviSpeedrateChange) == 0x000048, "Wrong size on ULAnimNotifyState_UseNaviSpeedrateChange");
static_assert(offsetof(ULAnimNotifyState_UseNaviSpeedrateChange, MoveSpeedRate) == 0x000040, "Member 'ULAnimNotifyState_UseNaviSpeedrateChange::MoveSpeedRate' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_AimToTarget
// 0x0028 (0x0068 - 0x0040)
class ULAnimNotifyState_AimToTarget final : public ULAnimNotifyStateBase
{
public:
	class FName                                   FireBoneName;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FireLocationOffset;                                // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBoneName;                                    // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocationOffset;                              // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AimToTarget">();
	}
	static class ULAnimNotifyState_AimToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AimToTarget>();
	}
};
static_assert(alignof(ULAnimNotifyState_AimToTarget) == 0x000008, "Wrong alignment on ULAnimNotifyState_AimToTarget");
static_assert(sizeof(ULAnimNotifyState_AimToTarget) == 0x000068, "Wrong size on ULAnimNotifyState_AimToTarget");
static_assert(offsetof(ULAnimNotifyState_AimToTarget, FireBoneName) == 0x000040, "Member 'ULAnimNotifyState_AimToTarget::FireBoneName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_AimToTarget, FireLocationOffset) == 0x000048, "Member 'ULAnimNotifyState_AimToTarget::FireLocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_AimToTarget, TargetBoneName) == 0x000054, "Member 'ULAnimNotifyState_AimToTarget::TargetBoneName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_AimToTarget, TargetLocationOffset) == 0x00005C, "Member 'ULAnimNotifyState_AimToTarget::TargetLocationOffset' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_FixAimToTarget
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_FixAimToTarget final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_FixAimToTarget">();
	}
	static class ULAnimNotifyState_FixAimToTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_FixAimToTarget>();
	}
};
static_assert(alignof(ULAnimNotifyState_FixAimToTarget) == 0x000008, "Wrong alignment on ULAnimNotifyState_FixAimToTarget");
static_assert(sizeof(ULAnimNotifyState_FixAimToTarget) == 0x000040, "Wrong size on ULAnimNotifyState_FixAimToTarget");

// Class ProjectP.LNPCSpecActionBase
// 0x0000 (0x0028 - 0x0028)
class ULNPCSpecActionBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecActionBase">();
	}
	static class ULNPCSpecActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecActionBase>();
	}
};
static_assert(alignof(ULNPCSpecActionBase) == 0x000008, "Wrong alignment on ULNPCSpecActionBase");
static_assert(sizeof(ULNPCSpecActionBase) == 0x000028, "Wrong size on ULNPCSpecActionBase");

// Class ProjectP.LNPCSpecActionBTreeSM
// 0x0010 (0x0038 - 0x0028)
class ULNPCSpecActionBTreeSM final : public ULNPCSpecActionBase
{
public:
	class FName                                   BTreeStateName;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelCurrentSkillAction;                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestartAILogic;                                   // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecActionBTreeSM">();
	}
	static class ULNPCSpecActionBTreeSM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecActionBTreeSM>();
	}
};
static_assert(alignof(ULNPCSpecActionBTreeSM) == 0x000008, "Wrong alignment on ULNPCSpecActionBTreeSM");
static_assert(sizeof(ULNPCSpecActionBTreeSM) == 0x000038, "Wrong size on ULNPCSpecActionBTreeSM");
static_assert(offsetof(ULNPCSpecActionBTreeSM, BTreeStateName) == 0x000028, "Member 'ULNPCSpecActionBTreeSM::BTreeStateName' has a wrong offset!");
static_assert(offsetof(ULNPCSpecActionBTreeSM, bCancelCurrentSkillAction) == 0x000030, "Member 'ULNPCSpecActionBTreeSM::bCancelCurrentSkillAction' has a wrong offset!");
static_assert(offsetof(ULNPCSpecActionBTreeSM, bRestartAILogic) == 0x000031, "Member 'ULNPCSpecActionBTreeSM::bRestartAILogic' has a wrong offset!");

// Class ProjectP.LPropShapeObjectSpot
// 0x0000 (0x0350 - 0x0350)
class ALPropShapeObjectSpot : public ALPropSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropShapeObjectSpot">();
	}
	static class ALPropShapeObjectSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropShapeObjectSpot>();
	}
};
static_assert(alignof(ALPropShapeObjectSpot) == 0x000008, "Wrong alignment on ALPropShapeObjectSpot");
static_assert(sizeof(ALPropShapeObjectSpot) == 0x000350, "Wrong size on ALPropShapeObjectSpot");

// Class ProjectP.LAnimNotifyState_CamShake
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_CamShake final : public ULAnimNotifyStateBase
{
public:
	TSubclassOf<class UMatineeCameraShake>        CameraShake;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_CamShake">();
	}
	static class ULAnimNotifyState_CamShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_CamShake>();
	}
};
static_assert(alignof(ULAnimNotifyState_CamShake) == 0x000008, "Wrong alignment on ULAnimNotifyState_CamShake");
static_assert(sizeof(ULAnimNotifyState_CamShake) == 0x000058, "Wrong size on ULAnimNotifyState_CamShake");
static_assert(offsetof(ULAnimNotifyState_CamShake, CameraShake) == 0x000040, "Member 'ULAnimNotifyState_CamShake::CameraShake' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CamShake, InnerRadius) == 0x000048, "Member 'ULAnimNotifyState_CamShake::InnerRadius' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CamShake, OuterRadius) == 0x00004C, "Member 'ULAnimNotifyState_CamShake::OuterRadius' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_CamShake, Falloff) == 0x000050, "Member 'ULAnimNotifyState_CamShake::Falloff' has a wrong offset!");

// Class ProjectP.LAnimNotify_BGM
// 0x0010 (0x0058 - 0x0048)
class ULAnimNotify_BGM final : public ULAnimNotifyBase
{
public:
	class FName                                   SoundName;                                         // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSoundNameUI;                                  // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_BGM">();
	}
	static class ULAnimNotify_BGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_BGM>();
	}
};
static_assert(alignof(ULAnimNotify_BGM) == 0x000008, "Wrong alignment on ULAnimNotify_BGM");
static_assert(sizeof(ULAnimNotify_BGM) == 0x000058, "Wrong size on ULAnimNotify_BGM");
static_assert(offsetof(ULAnimNotify_BGM, SoundName) == 0x000048, "Member 'ULAnimNotify_BGM::SoundName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_BGM, bShowSoundNameUI) == 0x000050, "Member 'ULAnimNotify_BGM::bShowSoundNameUI' has a wrong offset!");

// Class ProjectP.LPathwayCollisionComponent
// 0x0000 (0x0470 - 0x0470)
class ULPathwayCollisionComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPathwayCollisionComponent">();
	}
	static class ULPathwayCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPathwayCollisionComponent>();
	}
};
static_assert(alignof(ULPathwayCollisionComponent) == 0x000010, "Wrong alignment on ULPathwayCollisionComponent");
static_assert(sizeof(ULPathwayCollisionComponent) == 0x000470, "Wrong size on ULPathwayCollisionComponent");

// Class ProjectP.LAnimNotifyState_DropMesh
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_DropMesh final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DropMesh">();
	}
	static class ULAnimNotifyState_DropMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DropMesh>();
	}
};
static_assert(alignof(ULAnimNotifyState_DropMesh) == 0x000008, "Wrong alignment on ULAnimNotifyState_DropMesh");
static_assert(sizeof(ULAnimNotifyState_DropMesh) == 0x000040, "Wrong size on ULAnimNotifyState_DropMesh");

// Class ProjectP.LAnimNotify_BodyStain
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_BodyStain final : public ULAnimNotifyBase
{
public:
	int32                                         StainLevel;                                        // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amount;                                            // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_BodyStain">();
	}
	static class ULAnimNotify_BodyStain* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_BodyStain>();
	}
};
static_assert(alignof(ULAnimNotify_BodyStain) == 0x000008, "Wrong alignment on ULAnimNotify_BodyStain");
static_assert(sizeof(ULAnimNotify_BodyStain) == 0x000050, "Wrong size on ULAnimNotify_BodyStain");
static_assert(offsetof(ULAnimNotify_BodyStain, StainLevel) == 0x000048, "Member 'ULAnimNotify_BodyStain::StainLevel' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_BodyStain, Amount) == 0x00004C, "Member 'ULAnimNotify_BodyStain::Amount' has a wrong offset!");

// Class ProjectP.LGoldenTree
// 0x0028 (0x0050 - 0x0028)
class ULGoldenTree final : public UObject
{
public:
	uint8                                         Pad_28[0x1C];                                      // 0x0028(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALPropSpot>              TreeSpot;                                          // 0x0044(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHarvestRemainSec();
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);

	float GetBoostExcelGoalSec() const;
	float GetBoostExcelSec() const;
	int32 GetGoldStackLimit() const;
	int32 GetHarvestableCount() const;
	ELGoldenTreeState GetState() const;
	bool IsBoostNow() const;
	bool IsPlayerReached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGoldenTree">();
	}
	static class ULGoldenTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGoldenTree>();
	}
};
static_assert(alignof(ULGoldenTree) == 0x000008, "Wrong alignment on ULGoldenTree");
static_assert(sizeof(ULGoldenTree) == 0x000050, "Wrong size on ULGoldenTree");
static_assert(offsetof(ULGoldenTree, TreeSpot) == 0x000044, "Member 'ULGoldenTree::TreeSpot' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlaySound
// 0x0038 (0x0080 - 0x0048)
class ULAnimNotify_PlaySound final : public ULAnimNotifyBase
{
public:
	class USoundBase*                             Sound;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachName;                                        // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveDelay;                                        // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0070(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlaySound">();
	}
	static class ULAnimNotify_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlaySound>();
	}
};
static_assert(alignof(ULAnimNotify_PlaySound) == 0x000008, "Wrong alignment on ULAnimNotify_PlaySound");
static_assert(sizeof(ULAnimNotify_PlaySound) == 0x000080, "Wrong size on ULAnimNotify_PlaySound");
static_assert(offsetof(ULAnimNotify_PlaySound, Sound) == 0x000048, "Member 'ULAnimNotify_PlaySound::Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlaySound, VolumeMultiplier) == 0x000050, "Member 'ULAnimNotify_PlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlaySound, PitchMultiplier) == 0x000054, "Member 'ULAnimNotify_PlaySound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlaySound, AttachName) == 0x00005C, "Member 'ULAnimNotify_PlaySound::AttachName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlaySound, EventName) == 0x000064, "Member 'ULAnimNotify_PlaySound::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlaySound, LeaveDelay) == 0x00006C, "Member 'ULAnimNotify_PlaySound::LeaveDelay' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlaySound, DisableWhenWeaponInListBroken) == 0x000070, "Member 'ULAnimNotify_PlaySound::DisableWhenWeaponInListBroken' has a wrong offset!");

// Class ProjectP.LPropLiftOverlapPawnComponent
// 0x0000 (0x0470 - 0x0470)
class ULPropLiftOverlapPawnComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropLiftOverlapPawnComponent">();
	}
	static class ULPropLiftOverlapPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropLiftOverlapPawnComponent>();
	}
};
static_assert(alignof(ULPropLiftOverlapPawnComponent) == 0x000010, "Wrong alignment on ULPropLiftOverlapPawnComponent");
static_assert(sizeof(ULPropLiftOverlapPawnComponent) == 0x000470, "Wrong size on ULPropLiftOverlapPawnComponent");

// Class ProjectP.LAnimNotifyState_PlayLoopSound
// 0x0050 (0x0090 - 0x0040)
class ULAnimNotifyState_PlayLoopSound final : public ULAnimNotifyStateBase
{
public:
	class USoundBase*                             Sound;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollow : 1;                                       // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSoundFadeData                        FadeIn;                                            // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeOut;                                           // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_PlayLoopSound">();
	}
	static class ULAnimNotifyState_PlayLoopSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_PlayLoopSound>();
	}
};
static_assert(alignof(ULAnimNotifyState_PlayLoopSound) == 0x000008, "Wrong alignment on ULAnimNotifyState_PlayLoopSound");
static_assert(sizeof(ULAnimNotifyState_PlayLoopSound) == 0x000090, "Wrong size on ULAnimNotifyState_PlayLoopSound");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, Sound) == 0x000040, "Member 'ULAnimNotifyState_PlayLoopSound::Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, VolumeMultiplier) == 0x000048, "Member 'ULAnimNotifyState_PlayLoopSound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, PitchMultiplier) == 0x00004C, "Member 'ULAnimNotifyState_PlayLoopSound::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, FadeIn) == 0x000054, "Member 'ULAnimNotifyState_PlayLoopSound::FadeIn' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, FadeOut) == 0x000064, "Member 'ULAnimNotifyState_PlayLoopSound::FadeOut' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, AttachName) == 0x000074, "Member 'ULAnimNotifyState_PlayLoopSound::AttachName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PlayLoopSound, DisableWhenWeaponInListBroken) == 0x000080, "Member 'ULAnimNotifyState_PlayLoopSound::DisableWhenWeaponInListBroken' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ReplaceFatalHitMotion
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_ReplaceFatalHitMotion final : public ULAnimNotifyStateBase
{
public:
	class FName                                   FatalAttack_ReplacedAnim_BeforeHit;                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim;                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim_End;                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ReplaceFatalHitMotion">();
	}
	static class ULAnimNotifyState_ReplaceFatalHitMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ReplaceFatalHitMotion>();
	}
};
static_assert(alignof(ULAnimNotifyState_ReplaceFatalHitMotion) == 0x000008, "Wrong alignment on ULAnimNotifyState_ReplaceFatalHitMotion");
static_assert(sizeof(ULAnimNotifyState_ReplaceFatalHitMotion) == 0x000058, "Wrong size on ULAnimNotifyState_ReplaceFatalHitMotion");
static_assert(offsetof(ULAnimNotifyState_ReplaceFatalHitMotion, FatalAttack_ReplacedAnim_BeforeHit) == 0x000040, "Member 'ULAnimNotifyState_ReplaceFatalHitMotion::FatalAttack_ReplacedAnim_BeforeHit' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ReplaceFatalHitMotion, FatalAttack_ReplacedAnim) == 0x000048, "Member 'ULAnimNotifyState_ReplaceFatalHitMotion::FatalAttack_ReplacedAnim' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ReplaceFatalHitMotion, FatalAttack_ReplacedAnim_End) == 0x000050, "Member 'ULAnimNotifyState_ReplaceFatalHitMotion::FatalAttack_ReplacedAnim_End' has a wrong offset!");

// Class ProjectP.LPropBlockingVolumeComponent
// 0x0000 (0x0470 - 0x0470)
class ULPropBlockingVolumeComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropBlockingVolumeComponent">();
	}
	static class ULPropBlockingVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropBlockingVolumeComponent>();
	}
};
static_assert(alignof(ULPropBlockingVolumeComponent) == 0x000010, "Wrong alignment on ULPropBlockingVolumeComponent");
static_assert(sizeof(ULPropBlockingVolumeComponent) == 0x000470, "Wrong size on ULPropBlockingVolumeComponent");

// Class ProjectP.LAnimNotify_MaterialParam
// 0x0038 (0x0080 - 0x0048)
class ULAnimNotify_MaterialParam final : public ULAnimNotifyBase
{
public:
	ELMeshSelectionType                           SelectionType;                                     // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLMaterialParamScalar>          ScalarParams;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLMaterialParamVector>          VectorParams;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         OverrideAllDurationTime;                           // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideMaterialSlotName;                          // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_MaterialParam">();
	}
	static class ULAnimNotify_MaterialParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_MaterialParam>();
	}
};
static_assert(alignof(ULAnimNotify_MaterialParam) == 0x000008, "Wrong alignment on ULAnimNotify_MaterialParam");
static_assert(sizeof(ULAnimNotify_MaterialParam) == 0x000080, "Wrong size on ULAnimNotify_MaterialParam");
static_assert(offsetof(ULAnimNotify_MaterialParam, SelectionType) == 0x000048, "Member 'ULAnimNotify_MaterialParam::SelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialParam, ScalarParams) == 0x000050, "Member 'ULAnimNotify_MaterialParam::ScalarParams' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialParam, VectorParams) == 0x000060, "Member 'ULAnimNotify_MaterialParam::VectorParams' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialParam, OverrideAllDurationTime) == 0x000070, "Member 'ULAnimNotify_MaterialParam::OverrideAllDurationTime' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_MaterialParam, OverrideMaterialSlotName) == 0x000074, "Member 'ULAnimNotify_MaterialParam::OverrideMaterialSlotName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_MaterialVarying
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_MaterialVarying final : public ULAnimNotifyStateBase
{
public:
	ELMeshSelectionType                           SelectionType;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_MaterialVarying">();
	}
	static class ULAnimNotifyState_MaterialVarying* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_MaterialVarying>();
	}
};
static_assert(alignof(ULAnimNotifyState_MaterialVarying) == 0x000008, "Wrong alignment on ULAnimNotifyState_MaterialVarying");
static_assert(sizeof(ULAnimNotifyState_MaterialVarying) == 0x000058, "Wrong size on ULAnimNotifyState_MaterialVarying");
static_assert(offsetof(ULAnimNotifyState_MaterialVarying, SelectionType) == 0x000040, "Member 'ULAnimNotifyState_MaterialVarying::SelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MaterialVarying, MaterialVarying) == 0x000048, "Member 'ULAnimNotifyState_MaterialVarying::MaterialVarying' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MaterialVarying, PlayType) == 0x000050, "Member 'ULAnimNotifyState_MaterialVarying::PlayType' has a wrong offset!");

// Class ProjectP.LAnimNotify_NPC_Change_Phase
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_NPC_Change_Phase final : public ULAnimNotifyBase
{
public:
	class FName                                   CommonActionPathCodeName;                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LocomotionActionPathCodeName;                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionGroupTableCodeName;                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_NPC_Change_Phase">();
	}
	static class ULAnimNotify_NPC_Change_Phase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_NPC_Change_Phase>();
	}
};
static_assert(alignof(ULAnimNotify_NPC_Change_Phase) == 0x000008, "Wrong alignment on ULAnimNotify_NPC_Change_Phase");
static_assert(sizeof(ULAnimNotify_NPC_Change_Phase) == 0x000060, "Wrong size on ULAnimNotify_NPC_Change_Phase");
static_assert(offsetof(ULAnimNotify_NPC_Change_Phase, CommonActionPathCodeName) == 0x000048, "Member 'ULAnimNotify_NPC_Change_Phase::CommonActionPathCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPC_Change_Phase, LocomotionActionPathCodeName) == 0x000050, "Member 'ULAnimNotify_NPC_Change_Phase::LocomotionActionPathCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_NPC_Change_Phase, ActionGroupTableCodeName) == 0x000058, "Member 'ULAnimNotify_NPC_Change_Phase::ActionGroupTableCodeName' has a wrong offset!");

// Class ProjectP.LPropHelpMateSpot
// 0x0008 (0x0358 - 0x0350)
class ALPropHelpMateSpot : public ALPropShapeObjectSpot
{
public:
	bool                                          HelpMatePopupConfirm;                              // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionRetry();
	void OnOpenPopupHelpMate();
	void OnUIHelpMatePopupResult(bool PopupResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropHelpMateSpot">();
	}
	static class ALPropHelpMateSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropHelpMateSpot>();
	}
};
static_assert(alignof(ALPropHelpMateSpot) == 0x000008, "Wrong alignment on ALPropHelpMateSpot");
static_assert(sizeof(ALPropHelpMateSpot) == 0x000358, "Wrong size on ALPropHelpMateSpot");
static_assert(offsetof(ALPropHelpMateSpot, HelpMatePopupConfirm) == 0x000350, "Member 'ALPropHelpMateSpot::HelpMatePopupConfirm' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_RunNotiEnd_Buff
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_RunNotiEnd_Buff final : public ULAnimNotifyStateBase
{
public:
	class FName                                   BuffCodeName;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_RunNotiEnd_Buff">();
	}
	static class ULAnimNotifyState_RunNotiEnd_Buff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_RunNotiEnd_Buff>();
	}
};
static_assert(alignof(ULAnimNotifyState_RunNotiEnd_Buff) == 0x000008, "Wrong alignment on ULAnimNotifyState_RunNotiEnd_Buff");
static_assert(sizeof(ULAnimNotifyState_RunNotiEnd_Buff) == 0x000048, "Wrong size on ULAnimNotifyState_RunNotiEnd_Buff");
static_assert(offsetof(ULAnimNotifyState_RunNotiEnd_Buff, BuffCodeName) == 0x000040, "Member 'ULAnimNotifyState_RunNotiEnd_Buff::BuffCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotify_Buff
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_Buff final : public ULAnimNotifyBase
{
public:
	class FName                                   BuffCodeName;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_Buff">();
	}
	static class ULAnimNotify_Buff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_Buff>();
	}
};
static_assert(alignof(ULAnimNotify_Buff) == 0x000008, "Wrong alignment on ULAnimNotify_Buff");
static_assert(sizeof(ULAnimNotify_Buff) == 0x000050, "Wrong size on ULAnimNotify_Buff");
static_assert(offsetof(ULAnimNotify_Buff, BuffCodeName) == 0x000048, "Member 'ULAnimNotify_Buff::BuffCodeName' has a wrong offset!");

// Class ProjectP.LPropLevelSequenceSpot
// 0x0078 (0x03C8 - 0x0350)
class ALPropLevelSequenceSpot : public ALPropSpot
{
public:
	class FName                                   SequenceCodeName;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToggleSequenceCodeName;                            // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayed;                                          // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayReverse;                                     // 0x0361(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTogglePlay;                                      // 0x0362(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VolumeInSequencePlay;                              // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VolumeOutSequenceStop;                             // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VolumeEnterOnce;                                   // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DieToReset;                                        // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableDestroySequence;                            // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLSequenceBindActor>            BindSpotList;                                      // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class ALPropLevelSequenceSpot*>        StopSequenceSpotList;                              // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     CurrentSequenceActorData;                          // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     DefaultSequenceActorData;                          // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     ToggleSequenceActorData;                           // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     BeforePlayedSequenceActorData;                     // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     AfterPlayedSequenceActorData;                      // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SequencePlayAgainFlag;                             // 0x03B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFinishedLevelSequenceSpot;                       // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void OnFinishedCurrentSequenceActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropLevelSequenceSpot">();
	}
	static class ALPropLevelSequenceSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropLevelSequenceSpot>();
	}
};
static_assert(alignof(ALPropLevelSequenceSpot) == 0x000008, "Wrong alignment on ALPropLevelSequenceSpot");
static_assert(sizeof(ALPropLevelSequenceSpot) == 0x0003C8, "Wrong size on ALPropLevelSequenceSpot");
static_assert(offsetof(ALPropLevelSequenceSpot, SequenceCodeName) == 0x000350, "Member 'ALPropLevelSequenceSpot::SequenceCodeName' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, ToggleSequenceCodeName) == 0x000358, "Member 'ALPropLevelSequenceSpot::ToggleSequenceCodeName' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, IsPlayed) == 0x000360, "Member 'ALPropLevelSequenceSpot::IsPlayed' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, IsPlayReverse) == 0x000361, "Member 'ALPropLevelSequenceSpot::IsPlayReverse' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, IsTogglePlay) == 0x000362, "Member 'ALPropLevelSequenceSpot::IsTogglePlay' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, VolumeInSequencePlay) == 0x000363, "Member 'ALPropLevelSequenceSpot::VolumeInSequencePlay' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, VolumeOutSequenceStop) == 0x000364, "Member 'ALPropLevelSequenceSpot::VolumeOutSequenceStop' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, VolumeEnterOnce) == 0x000365, "Member 'ALPropLevelSequenceSpot::VolumeEnterOnce' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, DieToReset) == 0x000366, "Member 'ALPropLevelSequenceSpot::DieToReset' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, DisableDestroySequence) == 0x000367, "Member 'ALPropLevelSequenceSpot::DisableDestroySequence' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, BindSpotList) == 0x000368, "Member 'ALPropLevelSequenceSpot::BindSpotList' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, StopSequenceSpotList) == 0x000378, "Member 'ALPropLevelSequenceSpot::StopSequenceSpotList' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, CurrentSequenceActorData) == 0x000388, "Member 'ALPropLevelSequenceSpot::CurrentSequenceActorData' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, DefaultSequenceActorData) == 0x000390, "Member 'ALPropLevelSequenceSpot::DefaultSequenceActorData' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, ToggleSequenceActorData) == 0x000398, "Member 'ALPropLevelSequenceSpot::ToggleSequenceActorData' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, BeforePlayedSequenceActorData) == 0x0003A0, "Member 'ALPropLevelSequenceSpot::BeforePlayedSequenceActorData' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, AfterPlayedSequenceActorData) == 0x0003A8, "Member 'ALPropLevelSequenceSpot::AfterPlayedSequenceActorData' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, SequencePlayAgainFlag) == 0x0003B0, "Member 'ALPropLevelSequenceSpot::SequencePlayAgainFlag' has a wrong offset!");
static_assert(offsetof(ALPropLevelSequenceSpot, OnFinishedLevelSequenceSpot) == 0x0003B8, "Member 'ALPropLevelSequenceSpot::OnFinishedLevelSequenceSpot' has a wrong offset!");

// Class ProjectP.LProductBuyShop
// 0x0028 (0x0050 - 0x0028)
class ULProductBuyShop final : public ULProductShop
{
public:
	class FName                                   ShopCodeName;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLProductShopItemData>          DealProducts;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class ULProduct*>                      Products;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	bool Buy(class ULProduct* InProduct, int32 InCount);
	TSet<ELItemFirstCategory> GetBuyCategorys();
	TArray<class ULProduct*> GetBuyList(ELItemFirstCategory Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProductBuyShop">();
	}
	static class ULProductBuyShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProductBuyShop>();
	}
};
static_assert(alignof(ULProductBuyShop) == 0x000008, "Wrong alignment on ULProductBuyShop");
static_assert(sizeof(ULProductBuyShop) == 0x000050, "Wrong size on ULProductBuyShop");
static_assert(offsetof(ULProductBuyShop, ShopCodeName) == 0x000028, "Member 'ULProductBuyShop::ShopCodeName' has a wrong offset!");
static_assert(offsetof(ULProductBuyShop, DealProducts) == 0x000030, "Member 'ULProductBuyShop::DealProducts' has a wrong offset!");
static_assert(offsetof(ULProductBuyShop, Products) == 0x000040, "Member 'ULProductBuyShop::Products' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_AbnormalOn
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_AbnormalOn final : public ULAnimNotifyStateBase
{
public:
	class FName                                   AbnormalCodeName;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AbnormalOn">();
	}
	static class ULAnimNotifyState_AbnormalOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AbnormalOn>();
	}
};
static_assert(alignof(ULAnimNotifyState_AbnormalOn) == 0x000008, "Wrong alignment on ULAnimNotifyState_AbnormalOn");
static_assert(sizeof(ULAnimNotifyState_AbnormalOn) == 0x000048, "Wrong size on ULAnimNotifyState_AbnormalOn");
static_assert(offsetof(ULAnimNotifyState_AbnormalOn, AbnormalCodeName) == 0x000040, "Member 'ULAnimNotifyState_AbnormalOn::AbnormalCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotify_WindVolume
// 0x0030 (0x0078 - 0x0048)
class ULAnimNotify_WindVolume final : public ULAnimNotifyBase
{
public:
	float                                         WindSpeed;                                         // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPointWind;                                        // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VolumeSize;                                        // 0x0050(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x005C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0068(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_WindVolume">();
	}
	static class ULAnimNotify_WindVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_WindVolume>();
	}
};
static_assert(alignof(ULAnimNotify_WindVolume) == 0x000008, "Wrong alignment on ULAnimNotify_WindVolume");
static_assert(sizeof(ULAnimNotify_WindVolume) == 0x000078, "Wrong size on ULAnimNotify_WindVolume");
static_assert(offsetof(ULAnimNotify_WindVolume, WindSpeed) == 0x000048, "Member 'ULAnimNotify_WindVolume::WindSpeed' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_WindVolume, bPointWind) == 0x00004C, "Member 'ULAnimNotify_WindVolume::bPointWind' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_WindVolume, VolumeSize) == 0x000050, "Member 'ULAnimNotify_WindVolume::VolumeSize' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_WindVolume, LocationOffset) == 0x00005C, "Member 'ULAnimNotify_WindVolume::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_WindVolume, RotationOffset) == 0x000068, "Member 'ULAnimNotify_WindVolume::RotationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_WindVolume, LifeSpan) == 0x000074, "Member 'ULAnimNotify_WindVolume::LifeSpan' has a wrong offset!");

// Class ProjectP.LProjectilePropSpot
// 0x0020 (0x0370 - 0x0350)
class ALProjectilePropSpot final : public ALPropSpot
{
public:
	class ULPropVolumeComponent*                  ProjectileTriggerVolumeComponent;                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          OverlappedActorList;                               // 0x0358(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectilePropSpot">();
	}
	static class ALProjectilePropSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectilePropSpot>();
	}
};
static_assert(alignof(ALProjectilePropSpot) == 0x000008, "Wrong alignment on ALProjectilePropSpot");
static_assert(sizeof(ALProjectilePropSpot) == 0x000370, "Wrong size on ALProjectilePropSpot");
static_assert(offsetof(ALProjectilePropSpot, ProjectileTriggerVolumeComponent) == 0x000350, "Member 'ALProjectilePropSpot::ProjectileTriggerVolumeComponent' has a wrong offset!");
static_assert(offsetof(ALProjectilePropSpot, OverlappedActorList) == 0x000358, "Member 'ALProjectilePropSpot::OverlappedActorList' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_StopCameraWork
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_StopCameraWork final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_StopCameraWork">();
	}
	static class ULAnimNotifyState_StopCameraWork* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_StopCameraWork>();
	}
};
static_assert(alignof(ULAnimNotifyState_StopCameraWork) == 0x000008, "Wrong alignment on ULAnimNotifyState_StopCameraWork");
static_assert(sizeof(ULAnimNotifyState_StopCameraWork) == 0x000040, "Wrong size on ULAnimNotifyState_StopCameraWork");

// Class ProjectP.LAnimNotifyState_ApplyInput_Frenzy
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_Frenzy final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_Frenzy">();
	}
	static class ULAnimNotifyState_ApplyInput_Frenzy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_Frenzy>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_Frenzy) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_Frenzy");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_Frenzy) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_Frenzy");

// Class ProjectP.LTalker
// 0x0010 (0x0038 - 0x0028)
class ULTalker final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetCodeName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTalker">();
	}
	static class ULTalker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTalker>();
	}
};
static_assert(alignof(ULTalker) == 0x000008, "Wrong alignment on ULTalker");
static_assert(sizeof(ULTalker) == 0x000038, "Wrong size on ULTalker");

// Class ProjectP.LAnimNotifyState_AllowInput_FableHandle
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_AllowInput_FableHandle final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowInput_FableHandle">();
	}
	static class ULAnimNotifyState_AllowInput_FableHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowInput_FableHandle>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowInput_FableHandle) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowInput_FableHandle");
static_assert(sizeof(ULAnimNotifyState_AllowInput_FableHandle) == 0x000040, "Wrong size on ULAnimNotifyState_AllowInput_FableHandle");

// Class ProjectP.LAnimNotifyState_ApplyInput_UseItem
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_UseItem final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_UseItem">();
	}
	static class ULAnimNotifyState_ApplyInput_UseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_UseItem>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_UseItem) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_UseItem");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_UseItem) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_UseItem");

// Class ProjectP.LAnimNotifyState_ApplyInput_WeaponChange
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_WeaponChange final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_WeaponChange">();
	}
	static class ULAnimNotifyState_ApplyInput_WeaponChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_WeaponChange>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_WeaponChange) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_WeaponChange");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_WeaponChange) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_WeaponChange");

// Class ProjectP.LAnimNotifyState_ReserveInput_Attack
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ReserveInput_Attack final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ReserveInput_Attack">();
	}
	static class ULAnimNotifyState_ReserveInput_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ReserveInput_Attack>();
	}
};
static_assert(alignof(ULAnimNotifyState_ReserveInput_Attack) == 0x000008, "Wrong alignment on ULAnimNotifyState_ReserveInput_Attack");
static_assert(sizeof(ULAnimNotifyState_ReserveInput_Attack) == 0x000040, "Wrong size on ULAnimNotifyState_ReserveInput_Attack");

// Class ProjectP.LAnimNotifyState_ReserveInput_Special
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ReserveInput_Special final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ReserveInput_Special">();
	}
	static class ULAnimNotifyState_ReserveInput_Special* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ReserveInput_Special>();
	}
};
static_assert(alignof(ULAnimNotifyState_ReserveInput_Special) == 0x000008, "Wrong alignment on ULAnimNotifyState_ReserveInput_Special");
static_assert(sizeof(ULAnimNotifyState_ReserveInput_Special) == 0x000040, "Wrong size on ULAnimNotifyState_ReserveInput_Special");

// Class ProjectP.LAnimNotifyState_Reset_PralyzeGroggy
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_Reset_PralyzeGroggy final : public ULAnimNotifyStateBase
{
public:
	bool                                          Groggy;                                            // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bResetGroggyEnable;                                // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Reset_PralyzeGroggy">();
	}
	static class ULAnimNotifyState_Reset_PralyzeGroggy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Reset_PralyzeGroggy>();
	}
};
static_assert(alignof(ULAnimNotifyState_Reset_PralyzeGroggy) == 0x000008, "Wrong alignment on ULAnimNotifyState_Reset_PralyzeGroggy");
static_assert(sizeof(ULAnimNotifyState_Reset_PralyzeGroggy) == 0x000048, "Wrong size on ULAnimNotifyState_Reset_PralyzeGroggy");
static_assert(offsetof(ULAnimNotifyState_Reset_PralyzeGroggy, Groggy) == 0x000040, "Member 'ULAnimNotifyState_Reset_PralyzeGroggy::Groggy' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Reset_PralyzeGroggy, bResetGroggyEnable) == 0x000041, "Member 'ULAnimNotifyState_Reset_PralyzeGroggy::bResetGroggyEnable' has a wrong offset!");

// Class ProjectP.LTileView
// 0x04E0 (0x0870 - 0x0390)
class ULTileView final : public UTileView
{
public:
	struct FScrollBarStyle                        WidgetStyle;                                       // 0x0390(0x04D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_860[0x10];                                     // 0x0860(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetScrollOffset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTileView">();
	}
	static class ULTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTileView>();
	}
};
static_assert(alignof(ULTileView) == 0x000008, "Wrong alignment on ULTileView");
static_assert(sizeof(ULTileView) == 0x000870, "Wrong size on ULTileView");
static_assert(offsetof(ULTileView, WidgetStyle) == 0x000390, "Member 'ULTileView::WidgetStyle' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ParryCheck
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ParryCheck final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ParryCheck">();
	}
	static class ULAnimNotifyState_ParryCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ParryCheck>();
	}
};
static_assert(alignof(ULAnimNotifyState_ParryCheck) == 0x000008, "Wrong alignment on ULAnimNotifyState_ParryCheck");
static_assert(sizeof(ULAnimNotifyState_ParryCheck) == 0x000040, "Wrong size on ULAnimNotifyState_ParryCheck");

// Class ProjectP.LAnimNotifyState_GlobalTimeDilation
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_GlobalTimeDilation final : public ULAnimNotifyStateBase
{
public:
	float                                         TimeDilation;                                      // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GlobalTimeDilation">();
	}
	static class ULAnimNotifyState_GlobalTimeDilation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GlobalTimeDilation>();
	}
};
static_assert(alignof(ULAnimNotifyState_GlobalTimeDilation) == 0x000008, "Wrong alignment on ULAnimNotifyState_GlobalTimeDilation");
static_assert(sizeof(ULAnimNotifyState_GlobalTimeDilation) == 0x000048, "Wrong size on ULAnimNotifyState_GlobalTimeDilation");
static_assert(offsetof(ULAnimNotifyState_GlobalTimeDilation, TimeDilation) == 0x000040, "Member 'ULAnimNotifyState_GlobalTimeDilation::TimeDilation' has a wrong offset!");

// Class ProjectP.LTutorialSystem
// 0x01F0 (0x0268 - 0x0078)
class ULTutorialSystem final : public ULGameSubSystem
{
public:
	bool                                          TutorialPauseState;                                // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameInitDelayTime;                                 // 0x007C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   GameInitTutorial;                                  // 0x0080(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_GameInit;                              // 0x0088(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ActivateTutorialSystem;                            // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FLTutorialHierarchyInfo> TutorialDB;                                        // 0x00A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<ELCallBackEventType, struct FLAutoTutorialInfoList> AutoStartTutorialDB;                               // 0x00F0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<ELCallBackEventType, struct FLAutoTutorialInfoList> AutoEndTutorialDB;                                 // 0x0140(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<ELCallBackEventType, struct FLAutoTutorialInfoList> AutoPlayCountAssignDB;                             // 0x0190(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           TutorialList;                                      // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   VisibleTutorial;                                   // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TutorialDuringTick;                                // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TickDefaultCoolTime;                               // 0x0200(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLTutorialCoolTime>             TutorialCoolTimeList;                              // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           PlayerBlockPendingList;                            // 0x0218(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_PlayerBlockPending;                    // 0x0228(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           PriorityPendingList;                               // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           BattlePendingList;                                 // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         BattlePendingCount;                                // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BattlePendingLimit;                                // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BattlePendingTime;                                 // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle_BattlePending;                         // 0x0260(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckBattlePendingList();
	void ClearTutorialState();
	void EndTutorialUI(const class FName& TutorialCodeName);
	void ExecuteTutorial(class FName TutorialCodeName, bool PriorityPendingData);
	void GetCurrentTutorialList(TArray<class FName>* OutTutorialList);
	class FText GetDescriptionText(const class FName& TutorialCodeName, int32 StepNum);
	class FText GetTitleText(const class FName& TutorialCodeName, int32 StepNum);
	int32 GetTutorialMaxStep(const class FName& TutorialCodeName);
	class FName GetWindowTutorialCodeName();
	void OnGameInitTutorial();

	struct FTutorialInfoPtr GetTutorialDB_TutorialInfo(const class FName& TutorialCodeName, int32 TutorialStep) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTutorialSystem">();
	}
	static class ULTutorialSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTutorialSystem>();
	}
};
static_assert(alignof(ULTutorialSystem) == 0x000008, "Wrong alignment on ULTutorialSystem");
static_assert(sizeof(ULTutorialSystem) == 0x000268, "Wrong size on ULTutorialSystem");
static_assert(offsetof(ULTutorialSystem, TutorialPauseState) == 0x000078, "Member 'ULTutorialSystem::TutorialPauseState' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, GameInitDelayTime) == 0x00007C, "Member 'ULTutorialSystem::GameInitDelayTime' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, GameInitTutorial) == 0x000080, "Member 'ULTutorialSystem::GameInitTutorial' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TimerHandle_GameInit) == 0x000088, "Member 'ULTutorialSystem::TimerHandle_GameInit' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, ActivateTutorialSystem) == 0x000090, "Member 'ULTutorialSystem::ActivateTutorialSystem' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TutorialDB) == 0x0000A0, "Member 'ULTutorialSystem::TutorialDB' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, AutoStartTutorialDB) == 0x0000F0, "Member 'ULTutorialSystem::AutoStartTutorialDB' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, AutoEndTutorialDB) == 0x000140, "Member 'ULTutorialSystem::AutoEndTutorialDB' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, AutoPlayCountAssignDB) == 0x000190, "Member 'ULTutorialSystem::AutoPlayCountAssignDB' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TutorialList) == 0x0001E0, "Member 'ULTutorialSystem::TutorialList' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, VisibleTutorial) == 0x0001F0, "Member 'ULTutorialSystem::VisibleTutorial' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TutorialDuringTick) == 0x0001F8, "Member 'ULTutorialSystem::TutorialDuringTick' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TickDefaultCoolTime) == 0x000200, "Member 'ULTutorialSystem::TickDefaultCoolTime' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TutorialCoolTimeList) == 0x000208, "Member 'ULTutorialSystem::TutorialCoolTimeList' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, PlayerBlockPendingList) == 0x000218, "Member 'ULTutorialSystem::PlayerBlockPendingList' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TimerHandle_PlayerBlockPending) == 0x000228, "Member 'ULTutorialSystem::TimerHandle_PlayerBlockPending' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, PriorityPendingList) == 0x000230, "Member 'ULTutorialSystem::PriorityPendingList' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, BattlePendingList) == 0x000240, "Member 'ULTutorialSystem::BattlePendingList' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, BattlePendingCount) == 0x000250, "Member 'ULTutorialSystem::BattlePendingCount' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, BattlePendingLimit) == 0x000254, "Member 'ULTutorialSystem::BattlePendingLimit' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, BattlePendingTime) == 0x000258, "Member 'ULTutorialSystem::BattlePendingTime' has a wrong offset!");
static_assert(offsetof(ULTutorialSystem, TimerHandle_BattlePending) == 0x000260, "Member 'ULTutorialSystem::TimerHandle_BattlePending' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_EnableParts
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_EnableParts final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartsEnabled;                                     // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestoreEnableOnNotifyEnd;                         // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_EnableParts">();
	}
	static class ULAnimNotifyState_EnableParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_EnableParts>();
	}
};
static_assert(alignof(ULAnimNotifyState_EnableParts) == 0x000008, "Wrong alignment on ULAnimNotifyState_EnableParts");
static_assert(sizeof(ULAnimNotifyState_EnableParts) == 0x000050, "Wrong size on ULAnimNotifyState_EnableParts");
static_assert(offsetof(ULAnimNotifyState_EnableParts, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_EnableParts::PartsCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableParts, bPartsEnabled) == 0x000048, "Member 'ULAnimNotifyState_EnableParts::bPartsEnabled' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableParts, bRestoreEnableOnNotifyEnd) == 0x000049, "Member 'ULAnimNotifyState_EnableParts::bRestoreEnableOnNotifyEnd' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_PartsDestroy
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_PartsDestroy final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DamageRatio;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleteDestruct;                                 // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_PartsDestroy">();
	}
	static class ULAnimNotifyState_PartsDestroy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_PartsDestroy>();
	}
};
static_assert(alignof(ULAnimNotifyState_PartsDestroy) == 0x000008, "Wrong alignment on ULAnimNotifyState_PartsDestroy");
static_assert(sizeof(ULAnimNotifyState_PartsDestroy) == 0x000050, "Wrong size on ULAnimNotifyState_PartsDestroy");
static_assert(offsetof(ULAnimNotifyState_PartsDestroy, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_PartsDestroy::PartsCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PartsDestroy, DamageRatio) == 0x000048, "Member 'ULAnimNotifyState_PartsDestroy::DamageRatio' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_PartsDestroy, bCompleteDestruct) == 0x00004C, "Member 'ULAnimNotifyState_PartsDestroy::bCompleteDestruct' has a wrong offset!");

// Class ProjectP.LRichTextBlock
// 0x0000 (0x0680 - 0x0680)
class ULRichTextBlock : public URichTextBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LRichTextBlock">();
	}
	static class ULRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULRichTextBlock>();
	}
};
static_assert(alignof(ULRichTextBlock) == 0x000008, "Wrong alignment on ULRichTextBlock");
static_assert(sizeof(ULRichTextBlock) == 0x000680, "Wrong size on ULRichTextBlock");

// Class ProjectP.LAnimNotifyState_EnableNPCParts
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_EnableNPCParts final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartsEnable;                                      // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestoreEnableOnNotifyEnd;                         // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_EnableNPCParts">();
	}
	static class ULAnimNotifyState_EnableNPCParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_EnableNPCParts>();
	}
};
static_assert(alignof(ULAnimNotifyState_EnableNPCParts) == 0x000008, "Wrong alignment on ULAnimNotifyState_EnableNPCParts");
static_assert(sizeof(ULAnimNotifyState_EnableNPCParts) == 0x000050, "Wrong size on ULAnimNotifyState_EnableNPCParts");
static_assert(offsetof(ULAnimNotifyState_EnableNPCParts, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_EnableNPCParts::PartsCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableNPCParts, bPartsEnable) == 0x000048, "Member 'ULAnimNotifyState_EnableNPCParts::bPartsEnable' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableNPCParts, bRestoreEnableOnNotifyEnd) == 0x000049, "Member 'ULAnimNotifyState_EnableNPCParts::bRestoreEnableOnNotifyEnd' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_NPCPartsRestore
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_NPCPartsRestore final : public ULAnimNotifyStateBase
{
public:
	class FName                                   PartsCodeName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_NPCPartsRestore">();
	}
	static class ULAnimNotifyState_NPCPartsRestore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_NPCPartsRestore>();
	}
};
static_assert(alignof(ULAnimNotifyState_NPCPartsRestore) == 0x000008, "Wrong alignment on ULAnimNotifyState_NPCPartsRestore");
static_assert(sizeof(ULAnimNotifyState_NPCPartsRestore) == 0x000048, "Wrong size on ULAnimNotifyState_NPCPartsRestore");
static_assert(offsetof(ULAnimNotifyState_NPCPartsRestore, PartsCodeName) == 0x000040, "Member 'ULAnimNotifyState_NPCPartsRestore::PartsCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_WarningEvent
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_WarningEvent final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_WarningEvent">();
	}
	static class ULAnimNotifyState_WarningEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_WarningEvent>();
	}
};
static_assert(alignof(ULAnimNotifyState_WarningEvent) == 0x000008, "Wrong alignment on ULAnimNotifyState_WarningEvent");
static_assert(sizeof(ULAnimNotifyState_WarningEvent) == 0x000040, "Wrong size on ULAnimNotifyState_WarningEvent");

// Class ProjectP.LSequenceRuntimeSetting
// 0x0020 (0x0200 - 0x01E0)
class ALSequenceRuntimeSetting final : public AActor
{
public:
	struct FLSequenceRuntimeSettings              RuntimeSetting;                                    // 0x01E0(0x0005)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(bool Visible)>                 OnSkipUIControl;                                   // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Cached_PlayerWeaponControl;                        // 0x01F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Cached_PlayerWeaponOn;                             // 0x01F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Cached_SkipUIControl;                              // 0x01FA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Cached_SkipUIOn;                                   // 0x01FB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Cached_EnableSkipSequence;                         // 0x01FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSequenceRuntimeSetting">();
	}
	static class ALSequenceRuntimeSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSequenceRuntimeSetting>();
	}
};
static_assert(alignof(ALSequenceRuntimeSetting) == 0x000008, "Wrong alignment on ALSequenceRuntimeSetting");
static_assert(sizeof(ALSequenceRuntimeSetting) == 0x000200, "Wrong size on ALSequenceRuntimeSetting");
static_assert(offsetof(ALSequenceRuntimeSetting, RuntimeSetting) == 0x0001E0, "Member 'ALSequenceRuntimeSetting::RuntimeSetting' has a wrong offset!");
static_assert(offsetof(ALSequenceRuntimeSetting, OnSkipUIControl) == 0x0001E8, "Member 'ALSequenceRuntimeSetting::OnSkipUIControl' has a wrong offset!");
static_assert(offsetof(ALSequenceRuntimeSetting, Cached_PlayerWeaponControl) == 0x0001F8, "Member 'ALSequenceRuntimeSetting::Cached_PlayerWeaponControl' has a wrong offset!");
static_assert(offsetof(ALSequenceRuntimeSetting, Cached_PlayerWeaponOn) == 0x0001F9, "Member 'ALSequenceRuntimeSetting::Cached_PlayerWeaponOn' has a wrong offset!");
static_assert(offsetof(ALSequenceRuntimeSetting, Cached_SkipUIControl) == 0x0001FA, "Member 'ALSequenceRuntimeSetting::Cached_SkipUIControl' has a wrong offset!");
static_assert(offsetof(ALSequenceRuntimeSetting, Cached_SkipUIOn) == 0x0001FB, "Member 'ALSequenceRuntimeSetting::Cached_SkipUIOn' has a wrong offset!");
static_assert(offsetof(ALSequenceRuntimeSetting, Cached_EnableSkipSequence) == 0x0001FC, "Member 'ALSequenceRuntimeSetting::Cached_EnableSkipSequence' has a wrong offset!");

// Class ProjectP.LSaveGame
// 0x0030 (0x0058 - 0x0028)
class ULSaveGame : public USaveGame
{
public:
	class FString                                 SlotName;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGameDataType                                GameDataType;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UtcDateTime;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Saved;                                             // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Loaded;                                            // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Savedata_Version;                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CRCHash;                                           // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSaveGame">();
	}
	static class ULSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSaveGame>();
	}
};
static_assert(alignof(ULSaveGame) == 0x000008, "Wrong alignment on ULSaveGame");
static_assert(sizeof(ULSaveGame) == 0x000058, "Wrong size on ULSaveGame");
static_assert(offsetof(ULSaveGame, SlotName) == 0x000028, "Member 'ULSaveGame::SlotName' has a wrong offset!");
static_assert(offsetof(ULSaveGame, UserIndex) == 0x000038, "Member 'ULSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(ULSaveGame, GameDataType) == 0x00003C, "Member 'ULSaveGame::GameDataType' has a wrong offset!");
static_assert(offsetof(ULSaveGame, UtcDateTime) == 0x000040, "Member 'ULSaveGame::UtcDateTime' has a wrong offset!");
static_assert(offsetof(ULSaveGame, Saved) == 0x000048, "Member 'ULSaveGame::Saved' has a wrong offset!");
static_assert(offsetof(ULSaveGame, Loaded) == 0x000049, "Member 'ULSaveGame::Loaded' has a wrong offset!");
static_assert(offsetof(ULSaveGame, Savedata_Version) == 0x00004C, "Member 'ULSaveGame::Savedata_Version' has a wrong offset!");
static_assert(offsetof(ULSaveGame, CRCHash) == 0x000050, "Member 'ULSaveGame::CRCHash' has a wrong offset!");

// Class ProjectP.LCharacterSaveGame
// 0x0698 (0x06F0 - 0x0058)
class ULCharacterSaveGame final : public ULSaveGame
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCharacterSaveData                    CharacterSaveData;                                 // 0x0060(0x0360)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLSpotSaveData                         SpotSaveData;                                      // 0x03C0(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLExiledNpcData                        ExiledNpcData;                                     // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLVariableSaveData                     VariableSaveData;                                  // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLWorldEventSaveData                   WorldEventSaveData;                                // 0x04C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLTalkerSaveData                       TalkerSaveData;                                    // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLQuestSaveData                        QuestSaveData;                                     // 0x04E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLTutorialSaveData                     TutorialSaveData;                                  // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLDropItemSaveData                     DropItemSaveData;                                  // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLLoadingScreenData                    LoadingScreenSaveData;                             // 0x0510(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLCinematicData                        CinematicSaveData;                                 // 0x05B0(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLDLCSaveData_Character                DLCSaveData_Character;                             // 0x0650(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLPatchRewardSaveData_Character        PatchRewardSaveData_Character;                     // 0x06A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCharacterSaveGame">();
	}
	static class ULCharacterSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCharacterSaveGame>();
	}
};
static_assert(alignof(ULCharacterSaveGame) == 0x000010, "Wrong alignment on ULCharacterSaveGame");
static_assert(sizeof(ULCharacterSaveGame) == 0x0006F0, "Wrong size on ULCharacterSaveGame");
static_assert(offsetof(ULCharacterSaveGame, CharacterSaveData) == 0x000060, "Member 'ULCharacterSaveGame::CharacterSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, SpotSaveData) == 0x0003C0, "Member 'ULCharacterSaveGame::SpotSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, ExiledNpcData) == 0x0004A0, "Member 'ULCharacterSaveGame::ExiledNpcData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, VariableSaveData) == 0x0004B0, "Member 'ULCharacterSaveGame::VariableSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, WorldEventSaveData) == 0x0004C0, "Member 'ULCharacterSaveGame::WorldEventSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, TalkerSaveData) == 0x0004D0, "Member 'ULCharacterSaveGame::TalkerSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, QuestSaveData) == 0x0004E0, "Member 'ULCharacterSaveGame::QuestSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, TutorialSaveData) == 0x0004F0, "Member 'ULCharacterSaveGame::TutorialSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, DropItemSaveData) == 0x000500, "Member 'ULCharacterSaveGame::DropItemSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, LoadingScreenSaveData) == 0x000510, "Member 'ULCharacterSaveGame::LoadingScreenSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, CinematicSaveData) == 0x0005B0, "Member 'ULCharacterSaveGame::CinematicSaveData' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, DLCSaveData_Character) == 0x000650, "Member 'ULCharacterSaveGame::DLCSaveData_Character' has a wrong offset!");
static_assert(offsetof(ULCharacterSaveGame, PatchRewardSaveData_Character) == 0x0006A0, "Member 'ULCharacterSaveGame::PatchRewardSaveData_Character' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_HelpSignal
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_HelpSignal final : public ULAnimNotifyStateBase
{
public:
	float                                         OverrideRange;                                     // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_HelpSignal">();
	}
	static class ULAnimNotifyState_HelpSignal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_HelpSignal>();
	}
};
static_assert(alignof(ULAnimNotifyState_HelpSignal) == 0x000008, "Wrong alignment on ULAnimNotifyState_HelpSignal");
static_assert(sizeof(ULAnimNotifyState_HelpSignal) == 0x000048, "Wrong size on ULAnimNotifyState_HelpSignal");
static_assert(offsetof(ULAnimNotifyState_HelpSignal, OverrideRange) == 0x000040, "Member 'ULAnimNotifyState_HelpSignal::OverrideRange' has a wrong offset!");

// Class ProjectP.LAnimNotify_ContentCommand
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_ContentCommand final : public ULAnimNotifyBase
{
public:
	class FName                                   CommandCodeName;                                   // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_ContentCommand">();
	}
	static class ULAnimNotify_ContentCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_ContentCommand>();
	}
};
static_assert(alignof(ULAnimNotify_ContentCommand) == 0x000008, "Wrong alignment on ULAnimNotify_ContentCommand");
static_assert(sizeof(ULAnimNotify_ContentCommand) == 0x000050, "Wrong size on ULAnimNotify_ContentCommand");
static_assert(offsetof(ULAnimNotify_ContentCommand, CommandCodeName) == 0x000048, "Member 'ULAnimNotify_ContentCommand::CommandCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayMonologue
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_PlayMonologue final : public ULAnimNotifyBase
{
public:
	class FName                                   DialogCodeName;                                    // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayableNpc_CodeNameList;                          // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayMonologue">();
	}
	static class ULAnimNotify_PlayMonologue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayMonologue>();
	}
};
static_assert(alignof(ULAnimNotify_PlayMonologue) == 0x000008, "Wrong alignment on ULAnimNotify_PlayMonologue");
static_assert(sizeof(ULAnimNotify_PlayMonologue) == 0x000060, "Wrong size on ULAnimNotify_PlayMonologue");
static_assert(offsetof(ULAnimNotify_PlayMonologue, DialogCodeName) == 0x000048, "Member 'ULAnimNotify_PlayMonologue::DialogCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayMonologue, PlayableNpc_CodeNameList) == 0x000050, "Member 'ULAnimNotify_PlayMonologue::PlayableNpc_CodeNameList' has a wrong offset!");

// Class ProjectP.LCineCameraComponent
// 0x0050 (0x0960 - 0x0910)
class ULCineCameraComponent final : public UCineCameraComponent
{
public:
	struct FLSequenceTarget                       TraceTarget;                                       // 0x0908(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TraceBlendSpeed;                                   // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94C[0x14];                                     // 0x094C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCineCameraComponent">();
	}
	static class ULCineCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCineCameraComponent>();
	}
};
static_assert(alignof(ULCineCameraComponent) == 0x000010, "Wrong alignment on ULCineCameraComponent");
static_assert(sizeof(ULCineCameraComponent) == 0x000960, "Wrong size on ULCineCameraComponent");
static_assert(offsetof(ULCineCameraComponent, TraceTarget) == 0x000908, "Member 'ULCineCameraComponent::TraceTarget' has a wrong offset!");
static_assert(offsetof(ULCineCameraComponent, TraceBlendSpeed) == 0x000948, "Member 'ULCineCameraComponent::TraceBlendSpeed' has a wrong offset!");

// Class ProjectP.LSlaveArmTree
// 0x0010 (0x0038 - 0x0028)
class ULSlaveArmTree final : public UObject
{
public:
	struct FSlaveArmTreeInfoPtr                   Info;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActivateTreeFromUI();
	void SetActivate(bool bNewActivate, bool bNeedCalcPlayerStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSlaveArmTree">();
	}
	static class ULSlaveArmTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSlaveArmTree>();
	}
};
static_assert(alignof(ULSlaveArmTree) == 0x000008, "Wrong alignment on ULSlaveArmTree");
static_assert(sizeof(ULSlaveArmTree) == 0x000038, "Wrong size on ULSlaveArmTree");
static_assert(offsetof(ULSlaveArmTree, Info) == 0x000028, "Member 'ULSlaveArmTree::Info' has a wrong offset!");
static_assert(offsetof(ULSlaveArmTree, bUnlock) == 0x000030, "Member 'ULSlaveArmTree::bUnlock' has a wrong offset!");
static_assert(offsetof(ULSlaveArmTree, bActivated) == 0x000031, "Member 'ULSlaveArmTree::bActivated' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_LockPerfectGuard
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_LockPerfectGuard final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_LockPerfectGuard">();
	}
	static class ULAnimNotifyState_LockPerfectGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_LockPerfectGuard>();
	}
};
static_assert(alignof(ULAnimNotifyState_LockPerfectGuard) == 0x000008, "Wrong alignment on ULAnimNotifyState_LockPerfectGuard");
static_assert(sizeof(ULAnimNotifyState_LockPerfectGuard) == 0x000040, "Wrong size on ULAnimNotifyState_LockPerfectGuard");

// Class ProjectP.LAnimNotifyState_HUDEvent
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_HUDEvent final : public ULAnimNotifyStateBase
{
public:
	class FName                                   EventName;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHUDEventNotifyType                          HUDEventNotifyType;                                // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0xF];                                       // 0x0049(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_HUDEvent">();
	}
	static class ULAnimNotifyState_HUDEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_HUDEvent>();
	}
};
static_assert(alignof(ULAnimNotifyState_HUDEvent) == 0x000008, "Wrong alignment on ULAnimNotifyState_HUDEvent");
static_assert(sizeof(ULAnimNotifyState_HUDEvent) == 0x000058, "Wrong size on ULAnimNotifyState_HUDEvent");
static_assert(offsetof(ULAnimNotifyState_HUDEvent, EventName) == 0x000040, "Member 'ULAnimNotifyState_HUDEvent::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_HUDEvent, HUDEventNotifyType) == 0x000048, "Member 'ULAnimNotifyState_HUDEvent::HUDEventNotifyType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ApplyInput_DoubleDash
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_ApplyInput_DoubleDash final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ApplyInput_DoubleDash">();
	}
	static class ULAnimNotifyState_ApplyInput_DoubleDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ApplyInput_DoubleDash>();
	}
};
static_assert(alignof(ULAnimNotifyState_ApplyInput_DoubleDash) == 0x000008, "Wrong alignment on ULAnimNotifyState_ApplyInput_DoubleDash");
static_assert(sizeof(ULAnimNotifyState_ApplyInput_DoubleDash) == 0x000040, "Wrong size on ULAnimNotifyState_ApplyInput_DoubleDash");

// Class ProjectP.LSoundControlComponent
// 0x00A0 (0x0150 - 0x00B0)
class ULSoundControlComponent final : public UActorComponent
{
public:
	class FName                                   SoundActivateFlag;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundDeactivateFlag;                               // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundActivate_if_NpcSpot_Spawnable;                // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundActivate_if_NpcSpot_Not_Spawnable;            // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundDeactivate_if_NpcSpot_Spawnable;              // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundDeactivate_if_NpcSpot_Not_Spawnable;          // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoundDeactivate_if_BossRoom_Destroyed;             // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSoundPlayWeatherCondition                   SoundActivate_if_Weather_is;                       // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSoundPlayWeatherCondition                   SoundDeactivate_if_Weather_is;                     // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayToPlay;                                       // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToStop;                                       // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeIn;                                            // 0x011C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeOut;                                           // 0x012C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x14];                                     // 0x013C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceStop();
	void OnBossRoomDestroyed(const class FString& BossRoomUniqueId);
	void OnGlobalVariableChanged(class FName InGlobalVariable, int32 InValue);
	void OnNpcDead(const class FString& NpcSpotUniqueID);
	void OnPlayStateChanged(EAudioComponentPlayState PlayState);
	void OnWeatherChanged(class FName InWeatherCodeName);
	void Play();
	void PlayInstant();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSoundControlComponent">();
	}
	static class ULSoundControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSoundControlComponent>();
	}
};
static_assert(alignof(ULSoundControlComponent) == 0x000008, "Wrong alignment on ULSoundControlComponent");
static_assert(sizeof(ULSoundControlComponent) == 0x000150, "Wrong size on ULSoundControlComponent");
static_assert(offsetof(ULSoundControlComponent, SoundActivateFlag) == 0x0000B0, "Member 'ULSoundControlComponent::SoundActivateFlag' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundDeactivateFlag) == 0x0000B8, "Member 'ULSoundControlComponent::SoundDeactivateFlag' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundActivate_if_NpcSpot_Spawnable) == 0x0000C0, "Member 'ULSoundControlComponent::SoundActivate_if_NpcSpot_Spawnable' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundActivate_if_NpcSpot_Not_Spawnable) == 0x0000D0, "Member 'ULSoundControlComponent::SoundActivate_if_NpcSpot_Not_Spawnable' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundDeactivate_if_NpcSpot_Spawnable) == 0x0000E0, "Member 'ULSoundControlComponent::SoundDeactivate_if_NpcSpot_Spawnable' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundDeactivate_if_NpcSpot_Not_Spawnable) == 0x0000F0, "Member 'ULSoundControlComponent::SoundDeactivate_if_NpcSpot_Not_Spawnable' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundDeactivate_if_BossRoom_Destroyed) == 0x000100, "Member 'ULSoundControlComponent::SoundDeactivate_if_BossRoom_Destroyed' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundActivate_if_Weather_is) == 0x000110, "Member 'ULSoundControlComponent::SoundActivate_if_Weather_is' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, SoundDeactivate_if_Weather_is) == 0x000111, "Member 'ULSoundControlComponent::SoundDeactivate_if_Weather_is' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, DelayToPlay) == 0x000114, "Member 'ULSoundControlComponent::DelayToPlay' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, DelayToStop) == 0x000118, "Member 'ULSoundControlComponent::DelayToStop' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, FadeIn) == 0x00011C, "Member 'ULSoundControlComponent::FadeIn' has a wrong offset!");
static_assert(offsetof(ULSoundControlComponent, FadeOut) == 0x00012C, "Member 'ULSoundControlComponent::FadeOut' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_MeshRotatingOnFloor
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_MeshRotatingOnFloor final : public ULAnimNotifyStateBase
{
public:
	float                                         RotSpeed_In;                                       // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotSpeed_Out;                                      // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_MeshRotatingOnFloor">();
	}
	static class ULAnimNotifyState_MeshRotatingOnFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_MeshRotatingOnFloor>();
	}
};
static_assert(alignof(ULAnimNotifyState_MeshRotatingOnFloor) == 0x000008, "Wrong alignment on ULAnimNotifyState_MeshRotatingOnFloor");
static_assert(sizeof(ULAnimNotifyState_MeshRotatingOnFloor) == 0x000048, "Wrong size on ULAnimNotifyState_MeshRotatingOnFloor");
static_assert(offsetof(ULAnimNotifyState_MeshRotatingOnFloor, RotSpeed_In) == 0x000040, "Member 'ULAnimNotifyState_MeshRotatingOnFloor::RotSpeed_In' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_MeshRotatingOnFloor, RotSpeed_Out) == 0x000044, "Member 'ULAnimNotifyState_MeshRotatingOnFloor::RotSpeed_Out' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_DisableFatalAttack
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_DisableFatalAttack final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DisableFatalAttack">();
	}
	static class ULAnimNotifyState_DisableFatalAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DisableFatalAttack>();
	}
};
static_assert(alignof(ULAnimNotifyState_DisableFatalAttack) == 0x000008, "Wrong alignment on ULAnimNotifyState_DisableFatalAttack");
static_assert(sizeof(ULAnimNotifyState_DisableFatalAttack) == 0x000040, "Wrong size on ULAnimNotifyState_DisableFatalAttack");

// Class ProjectP.LAnimNotify_PlayGroundFx
// 0x0168 (0x01B0 - 0x0048)
class ULAnimNotify_PlayGroundFx final : public ULAnimNotifyBase
{
public:
	class FName                                   EventName;                                         // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName_Sound;                                   // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0058(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0060(0x0030)(BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x0091(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0092(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x0098(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x00E8(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0138(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0188(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayBodyStain;                                    // 0x018C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyStainAmount;                                   // 0x0190(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0198(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestSurface;                                       // 0x01A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayGroundFx">();
	}
	static class ULAnimNotify_PlayGroundFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayGroundFx>();
	}
};
static_assert(alignof(ULAnimNotify_PlayGroundFx) == 0x000010, "Wrong alignment on ULAnimNotify_PlayGroundFx");
static_assert(sizeof(ULAnimNotify_PlayGroundFx) == 0x0001B0, "Wrong size on ULAnimNotify_PlayGroundFx");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, EventName) == 0x000048, "Member 'ULAnimNotify_PlayGroundFx::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, EventName_Sound) == 0x000050, "Member 'ULAnimNotify_PlayGroundFx::EventName_Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, SocketName) == 0x000058, "Member 'ULAnimNotify_PlayGroundFx::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, Offset) == 0x000060, "Member 'ULAnimNotify_PlayGroundFx::Offset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, UseSocketOrientedOffset) == 0x000090, "Member 'ULAnimNotify_PlayGroundFx::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, UseAbsoluteRotation) == 0x000091, "Member 'ULAnimNotify_PlayGroundFx::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, bAttached) == 0x000092, "Member 'ULAnimNotify_PlayGroundFx::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, ApplyVariableFloat) == 0x000098, "Member 'ULAnimNotify_PlayGroundFx::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, ApplyVariableVector2) == 0x0000E8, "Member 'ULAnimNotify_PlayGroundFx::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, ApplyVariableVector3) == 0x000138, "Member 'ULAnimNotify_PlayGroundFx::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, VolumeModifier) == 0x000188, "Member 'ULAnimNotify_PlayGroundFx::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, bPlayBodyStain) == 0x00018C, "Member 'ULAnimNotify_PlayGroundFx::bPlayBodyStain' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, BodyStainAmount) == 0x000190, "Member 'ULAnimNotify_PlayGroundFx::BodyStainAmount' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, DisableWhenWeaponInListBroken) == 0x000198, "Member 'ULAnimNotify_PlayGroundFx::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundFx, TestSurface) == 0x0001A8, "Member 'ULAnimNotify_PlayGroundFx::TestSurface' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayGroundSkillFx
// 0x0078 (0x00C0 - 0x0048)
class ULAnimNotify_PlayGroundSkillFx final : public ULAnimNotifyBase
{
public:
	TArray<struct FLNiagaraWithParametersWithPS_for_Notify> FXList;                                            // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLSoundWithPS>                  SoundList;                                         // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0068(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0070(0x0030)(BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x00A0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x00A1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x00A2(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeModifier;                                    // 0x00A4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x00A8(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestSurface;                                       // 0x00B8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayGroundSkillFx">();
	}
	static class ULAnimNotify_PlayGroundSkillFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayGroundSkillFx>();
	}
};
static_assert(alignof(ULAnimNotify_PlayGroundSkillFx) == 0x000010, "Wrong alignment on ULAnimNotify_PlayGroundSkillFx");
static_assert(sizeof(ULAnimNotify_PlayGroundSkillFx) == 0x0000C0, "Wrong size on ULAnimNotify_PlayGroundSkillFx");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, FXList) == 0x000048, "Member 'ULAnimNotify_PlayGroundSkillFx::FXList' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, SoundList) == 0x000058, "Member 'ULAnimNotify_PlayGroundSkillFx::SoundList' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, SocketName) == 0x000068, "Member 'ULAnimNotify_PlayGroundSkillFx::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, Offset) == 0x000070, "Member 'ULAnimNotify_PlayGroundSkillFx::Offset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, UseSocketOrientedOffset) == 0x0000A0, "Member 'ULAnimNotify_PlayGroundSkillFx::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, UseAbsoluteRotation) == 0x0000A1, "Member 'ULAnimNotify_PlayGroundSkillFx::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, bAttached) == 0x0000A2, "Member 'ULAnimNotify_PlayGroundSkillFx::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, VolumeModifier) == 0x0000A4, "Member 'ULAnimNotify_PlayGroundSkillFx::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, DisableWhenWeaponInListBroken) == 0x0000A8, "Member 'ULAnimNotify_PlayGroundSkillFx::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayGroundSkillFx, TestSurface) == 0x0000B8, "Member 'ULAnimNotify_PlayGroundSkillFx::TestSurface' has a wrong offset!");

// Class ProjectP.LAnimNotify_SpawnNPC
// 0x0020 (0x0068 - 0x0048)
class ULAnimNotify_SpawnNPC final : public ULAnimNotifyBase
{
public:
	class FName                                   NPCCodeName;                                       // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0050(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnIdleCodeName;                                 // 0x005C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_SpawnNPC">();
	}
	static class ULAnimNotify_SpawnNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_SpawnNPC>();
	}
};
static_assert(alignof(ULAnimNotify_SpawnNPC) == 0x000008, "Wrong alignment on ULAnimNotify_SpawnNPC");
static_assert(sizeof(ULAnimNotify_SpawnNPC) == 0x000068, "Wrong size on ULAnimNotify_SpawnNPC");
static_assert(offsetof(ULAnimNotify_SpawnNPC, NPCCodeName) == 0x000048, "Member 'ULAnimNotify_SpawnNPC::NPCCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SpawnNPC, LocationOffset) == 0x000050, "Member 'ULAnimNotify_SpawnNPC::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SpawnNPC, SpawnIdleCodeName) == 0x00005C, "Member 'ULAnimNotify_SpawnNPC::SpawnIdleCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_MoveCollisionDisable
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_MoveCollisionDisable final : public ULAnimNotifyStateBase
{
public:
	uint8                                         MainCapsuleMoveOnly : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MainCapsuleDisable : 1;                            // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DisableSubCapsuleName;                             // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_MoveCollisionDisable">();
	}
	static class ULAnimNotifyState_MoveCollisionDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_MoveCollisionDisable>();
	}
};
static_assert(alignof(ULAnimNotifyState_MoveCollisionDisable) == 0x000008, "Wrong alignment on ULAnimNotifyState_MoveCollisionDisable");
static_assert(sizeof(ULAnimNotifyState_MoveCollisionDisable) == 0x000058, "Wrong size on ULAnimNotifyState_MoveCollisionDisable");
static_assert(offsetof(ULAnimNotifyState_MoveCollisionDisable, DisableSubCapsuleName) == 0x000048, "Member 'ULAnimNotifyState_MoveCollisionDisable::DisableSubCapsuleName' has a wrong offset!");

// Class ProjectP.LProjectile_Angular
// 0x0010 (0x0410 - 0x0400)
class ALProjectile_Angular : public ALProjectile_Typical
{
public:
	uint8                                         Pad_3F8[0x14];                                     // 0x03F8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBounceCount;                                // 0x040C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_Angular">();
	}
	static class ALProjectile_Angular* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_Angular>();
	}
};
static_assert(alignof(ALProjectile_Angular) == 0x000010, "Wrong alignment on ALProjectile_Angular");
static_assert(sizeof(ALProjectile_Angular) == 0x000410, "Wrong size on ALProjectile_Angular");
static_assert(offsetof(ALProjectile_Angular, CurrentBounceCount) == 0x00040C, "Member 'ALProjectile_Angular::CurrentBounceCount' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ChangeCharBlockType
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_ChangeCharBlockType final : public ULAnimNotifyStateBase
{
public:
	ELCharacterCollisionType                      CharacterCollisionType;                            // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangeCharBlockType">();
	}
	static class ULAnimNotifyState_ChangeCharBlockType* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangeCharBlockType>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangeCharBlockType) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangeCharBlockType");
static_assert(sizeof(ULAnimNotifyState_ChangeCharBlockType) == 0x000048, "Wrong size on ULAnimNotifyState_ChangeCharBlockType");
static_assert(offsetof(ULAnimNotifyState_ChangeCharBlockType, CharacterCollisionType) == 0x000040, "Member 'ULAnimNotifyState_ChangeCharBlockType::CharacterCollisionType' has a wrong offset!");

// Class ProjectP.LAnimNotify_PlayTimedLadderFx
// 0x0158 (0x0198 - 0x0040)
class ULAnimNotify_PlayTimedLadderFx final : public ULAnimNotifyStateBase
{
public:
	class FName                                   EventName;                                         // 0x0040(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName_Sound;                                   // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0058(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0064(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleOffset;                                       // 0x0070(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x007D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x007E(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x007F(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ApplyVariableFloat;                                // 0x0080(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           ApplyVariableVector2;                              // 0x00D0(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             ApplyVariableVector3;                              // 0x0120(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         VolumeModifier;                                    // 0x0170(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeIn;                                            // 0x0174(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeOut;                                           // 0x0184(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestSurface;                                       // 0x0194(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayTimedLadderFx">();
	}
	static class ULAnimNotify_PlayTimedLadderFx* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayTimedLadderFx>();
	}
};
static_assert(alignof(ULAnimNotify_PlayTimedLadderFx) == 0x000008, "Wrong alignment on ULAnimNotify_PlayTimedLadderFx");
static_assert(sizeof(ULAnimNotify_PlayTimedLadderFx) == 0x000198, "Wrong size on ULAnimNotify_PlayTimedLadderFx");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, EventName) == 0x000040, "Member 'ULAnimNotify_PlayTimedLadderFx::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, EventName_Sound) == 0x000048, "Member 'ULAnimNotify_PlayTimedLadderFx::EventName_Sound' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, SocketName) == 0x000050, "Member 'ULAnimNotify_PlayTimedLadderFx::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, LocationOffset) == 0x000058, "Member 'ULAnimNotify_PlayTimedLadderFx::LocationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, RotationOffset) == 0x000064, "Member 'ULAnimNotify_PlayTimedLadderFx::RotationOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, ScaleOffset) == 0x000070, "Member 'ULAnimNotify_PlayTimedLadderFx::ScaleOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, UseSocketOrientedOffset) == 0x00007C, "Member 'ULAnimNotify_PlayTimedLadderFx::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, UseAbsoluteRotation) == 0x00007D, "Member 'ULAnimNotify_PlayTimedLadderFx::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, bAttached) == 0x00007E, "Member 'ULAnimNotify_PlayTimedLadderFx::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, MeshSelectionType) == 0x00007F, "Member 'ULAnimNotify_PlayTimedLadderFx::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, ApplyVariableFloat) == 0x000080, "Member 'ULAnimNotify_PlayTimedLadderFx::ApplyVariableFloat' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, ApplyVariableVector2) == 0x0000D0, "Member 'ULAnimNotify_PlayTimedLadderFx::ApplyVariableVector2' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, ApplyVariableVector3) == 0x000120, "Member 'ULAnimNotify_PlayTimedLadderFx::ApplyVariableVector3' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, VolumeModifier) == 0x000170, "Member 'ULAnimNotify_PlayTimedLadderFx::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, FadeIn) == 0x000174, "Member 'ULAnimNotify_PlayTimedLadderFx::FadeIn' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, FadeOut) == 0x000184, "Member 'ULAnimNotify_PlayTimedLadderFx::FadeOut' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedLadderFx, TestSurface) == 0x000194, "Member 'ULAnimNotify_PlayTimedLadderFx::TestSurface' has a wrong offset!");

// Class ProjectP.LProjectileDesign
// 0x0098 (0x0278 - 0x01E0)
class ALProjectileDesign : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileInfoPtr                     Info;                                              // 0x01E8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALProjectile>            Projectile;                                        // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionInfo            DestructionInfo;                                   // 0x01F8(0x000E)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_206[0x2];                                      // 0x0206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLProjectileHitInfo>            HitInfoList;                                       // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLProjectileHitInfo_V2>         HitInfoList_V2;                                    // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLChildProjectileSpawnInfo>     ChildSpawnInfoList;                                // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLProjectileAbnormalApplyInRangeInfo   AbnormalApplyInfo;                                 // 0x0238(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInvincibleWhenOverlapCharacter;             // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CustomChildProjectileCodeNameList;                 // 0x0260(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsUnderDestroying;                                 // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInPool;                                          // 0x0271(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272[0x6];                                      // 0x0272(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCustomOverlapDestroyCondition(class AActor* OverlappedActor);
	class FName CheckUseSubstituteSkillHit(const struct FLProjectileHitInfo& ProjectileHitInfo, const struct FHitResult& HitResult);
	void EndProjectileDesign();
	class ALProjectile* GetProjectile();
	void InitProjectile();
	void OnAttakedByOther(class AActor* Other, class FName SkillHitCodeName);
	void OnBounce();
	void OnDisappear(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult);
	void OnExplode(ELProjectileDestroyReason Reason, const struct FHitResult& HitResult);
	void OnSpawnChildren(class ALProjectile* ChildProjectile);
	void Pause(bool bPauseFlag);
	TArray<struct FHitResult> RefineHitTarget(const TArray<struct FHitResult>& InHitResults);
	void ReserveDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectileDesign">();
	}
	static class ALProjectileDesign* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectileDesign>();
	}
};
static_assert(alignof(ALProjectileDesign) == 0x000008, "Wrong alignment on ALProjectileDesign");
static_assert(sizeof(ALProjectileDesign) == 0x000278, "Wrong size on ALProjectileDesign");
static_assert(offsetof(ALProjectileDesign, Info) == 0x0001E8, "Member 'ALProjectileDesign::Info' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, Projectile) == 0x0001F0, "Member 'ALProjectileDesign::Projectile' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, DestructionInfo) == 0x0001F8, "Member 'ALProjectileDesign::DestructionInfo' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, HitInfoList) == 0x000208, "Member 'ALProjectileDesign::HitInfoList' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, HitInfoList_V2) == 0x000218, "Member 'ALProjectileDesign::HitInfoList_V2' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, ChildSpawnInfoList) == 0x000228, "Member 'ALProjectileDesign::ChildSpawnInfoList' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, AbnormalApplyInfo) == 0x000238, "Member 'ALProjectileDesign::AbnormalApplyInfo' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, TargetOffset) == 0x000250, "Member 'ALProjectileDesign::TargetOffset' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, bIgnoreInvincibleWhenOverlapCharacter) == 0x00025C, "Member 'ALProjectileDesign::bIgnoreInvincibleWhenOverlapCharacter' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, CustomChildProjectileCodeNameList) == 0x000260, "Member 'ALProjectileDesign::CustomChildProjectileCodeNameList' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, IsUnderDestroying) == 0x000270, "Member 'ALProjectileDesign::IsUnderDestroying' has a wrong offset!");
static_assert(offsetof(ALProjectileDesign, IsInPool) == 0x000271, "Member 'ALProjectileDesign::IsInPool' has a wrong offset!");

// Class ProjectP.LAnimNotify_SendNPCWorldTrigger
// 0x0028 (0x0070 - 0x0048)
class ULAnimNotify_SendNPCWorldTrigger final : public ULAnimNotifyBase
{
public:
	ELAISendWorldTriggerType                      TriggerType;                                       // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TriggerString;                                     // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendRadius;                                        // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCCodeName;                                       // 0x0064(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_SendNPCWorldTrigger">();
	}
	static class ULAnimNotify_SendNPCWorldTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_SendNPCWorldTrigger>();
	}
};
static_assert(alignof(ULAnimNotify_SendNPCWorldTrigger) == 0x000008, "Wrong alignment on ULAnimNotify_SendNPCWorldTrigger");
static_assert(sizeof(ULAnimNotify_SendNPCWorldTrigger) == 0x000070, "Wrong size on ULAnimNotify_SendNPCWorldTrigger");
static_assert(offsetof(ULAnimNotify_SendNPCWorldTrigger, TriggerType) == 0x000048, "Member 'ULAnimNotify_SendNPCWorldTrigger::TriggerType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SendNPCWorldTrigger, TriggerString) == 0x000050, "Member 'ULAnimNotify_SendNPCWorldTrigger::TriggerString' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SendNPCWorldTrigger, SendRadius) == 0x000060, "Member 'ULAnimNotify_SendNPCWorldTrigger::SendRadius' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SendNPCWorldTrigger, NPCCodeName) == 0x000064, "Member 'ULAnimNotify_SendNPCWorldTrigger::NPCCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_IncreaseStretchBone
// 0x0030 (0x0070 - 0x0040)
class ULAnimNotifyState_IncreaseStretchBone final : public ULAnimNotifyStateBase
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         StretchDistance;                                   // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLEasingData                           StretchEasingData;                                 // 0x0054(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExceptionDurationTime;                             // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLEasingData                           ExceptionEasingData;                               // 0x0064(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_IncreaseStretchBone">();
	}
	static class ULAnimNotifyState_IncreaseStretchBone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_IncreaseStretchBone>();
	}
};
static_assert(alignof(ULAnimNotifyState_IncreaseStretchBone) == 0x000008, "Wrong alignment on ULAnimNotifyState_IncreaseStretchBone");
static_assert(sizeof(ULAnimNotifyState_IncreaseStretchBone) == 0x000070, "Wrong size on ULAnimNotifyState_IncreaseStretchBone");
static_assert(offsetof(ULAnimNotifyState_IncreaseStretchBone, BoneNames) == 0x000040, "Member 'ULAnimNotifyState_IncreaseStretchBone::BoneNames' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_IncreaseStretchBone, StretchDistance) == 0x000050, "Member 'ULAnimNotifyState_IncreaseStretchBone::StretchDistance' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_IncreaseStretchBone, StretchEasingData) == 0x000054, "Member 'ULAnimNotifyState_IncreaseStretchBone::StretchEasingData' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_IncreaseStretchBone, ExceptionDurationTime) == 0x000060, "Member 'ULAnimNotifyState_IncreaseStretchBone::ExceptionDurationTime' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_IncreaseStretchBone, ExceptionEasingData) == 0x000064, "Member 'ULAnimNotifyState_IncreaseStretchBone::ExceptionEasingData' has a wrong offset!");

// Class ProjectP.LProjectilePropActor
// 0x0020 (0x0240 - 0x0220)
class ALProjectilePropActor final : public ALPropActor
{
public:
	TArray<struct FLProjectilePropSpawnParameter> ProjectileList;                                    // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULSpotProjectileSpawn_PeriodicHandler*> SpawnHandlerList;                                  // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectilePropActor">();
	}
	static class ALProjectilePropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectilePropActor>();
	}
};
static_assert(alignof(ALProjectilePropActor) == 0x000008, "Wrong alignment on ALProjectilePropActor");
static_assert(sizeof(ALProjectilePropActor) == 0x000240, "Wrong size on ALProjectilePropActor");
static_assert(offsetof(ALProjectilePropActor, ProjectileList) == 0x000220, "Member 'ALProjectilePropActor::ProjectileList' has a wrong offset!");
static_assert(offsetof(ALProjectilePropActor, SpawnHandlerList) == 0x000230, "Member 'ALProjectilePropActor::SpawnHandlerList' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_DecreaseStretchBone
// 0x0020 (0x0060 - 0x0040)
class ULAnimNotifyState_DecreaseStretchBone final : public ULAnimNotifyStateBase
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLEasingData                           EasingData;                                        // 0x0050(0x000C)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DecreaseStretchBone">();
	}
	static class ULAnimNotifyState_DecreaseStretchBone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DecreaseStretchBone>();
	}
};
static_assert(alignof(ULAnimNotifyState_DecreaseStretchBone) == 0x000008, "Wrong alignment on ULAnimNotifyState_DecreaseStretchBone");
static_assert(sizeof(ULAnimNotifyState_DecreaseStretchBone) == 0x000060, "Wrong size on ULAnimNotifyState_DecreaseStretchBone");
static_assert(offsetof(ULAnimNotifyState_DecreaseStretchBone, BoneNames) == 0x000040, "Member 'ULAnimNotifyState_DecreaseStretchBone::BoneNames' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_DecreaseStretchBone, EasingData) == 0x000050, "Member 'ULAnimNotifyState_DecreaseStretchBone::EasingData' has a wrong offset!");

// Class ProjectP.LSpecialBuff
// 0x0020 (0x0048 - 0x0028)
class ULSpecialBuff : public UObject
{
public:
	struct FSpecialBuffInfoPtr                    Info;                                              // 0x0028(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ALCharacter* GetOwner();
	void OnAttached();
	void OnDetached();
	void Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff">();
	}
	static class ULSpecialBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff>();
	}
};
static_assert(alignof(ULSpecialBuff) == 0x000008, "Wrong alignment on ULSpecialBuff");
static_assert(sizeof(ULSpecialBuff) == 0x000048, "Wrong size on ULSpecialBuff");
static_assert(offsetof(ULSpecialBuff, Info) == 0x000028, "Member 'ULSpecialBuff::Info' has a wrong offset!");

// Class ProjectP.LSpecialBuff_Item_Category_Max_Stack_Add
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_Item_Category_Max_Stack_Add final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Item_Category_Max_Stack_Add">();
	}
	static class ULSpecialBuff_Item_Category_Max_Stack_Add* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Item_Category_Max_Stack_Add>();
	}
};
static_assert(alignof(ULSpecialBuff_Item_Category_Max_Stack_Add) == 0x000008, "Wrong alignment on ULSpecialBuff_Item_Category_Max_Stack_Add");
static_assert(sizeof(ULSpecialBuff_Item_Category_Max_Stack_Add) == 0x000048, "Wrong size on ULSpecialBuff_Item_Category_Max_Stack_Add");

// Class ProjectP.LAnimNotifyStateBase_ForceOverrideDieMotion
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyStateBase_ForceOverrideDieMotion final : public ULAnimNotifyStateBase
{
public:
	class FName                                   DieMotionCodeName;                                 // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyStateBase_ForceOverrideDieMotion">();
	}
	static class ULAnimNotifyStateBase_ForceOverrideDieMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyStateBase_ForceOverrideDieMotion>();
	}
};
static_assert(alignof(ULAnimNotifyStateBase_ForceOverrideDieMotion) == 0x000008, "Wrong alignment on ULAnimNotifyStateBase_ForceOverrideDieMotion");
static_assert(sizeof(ULAnimNotifyStateBase_ForceOverrideDieMotion) == 0x000048, "Wrong size on ULAnimNotifyStateBase_ForceOverrideDieMotion");
static_assert(offsetof(ULAnimNotifyStateBase_ForceOverrideDieMotion, DieMotionCodeName) == 0x000040, "Member 'ULAnimNotifyStateBase_ForceOverrideDieMotion::DieMotionCodeName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_DisableLockOn
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_DisableLockOn final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DisableLockOn">();
	}
	static class ULAnimNotifyState_DisableLockOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DisableLockOn>();
	}
};
static_assert(alignof(ULAnimNotifyState_DisableLockOn) == 0x000008, "Wrong alignment on ULAnimNotifyState_DisableLockOn");
static_assert(sizeof(ULAnimNotifyState_DisableLockOn) == 0x000040, "Wrong size on ULAnimNotifyState_DisableLockOn");

// Class ProjectP.BoxComponentForGuide
// 0x0000 (0x0470 - 0x0470)
class UBoxComponentForGuide final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxComponentForGuide">();
	}
	static class UBoxComponentForGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxComponentForGuide>();
	}
};
static_assert(alignof(UBoxComponentForGuide) == 0x000010, "Wrong alignment on UBoxComponentForGuide");
static_assert(sizeof(UBoxComponentForGuide) == 0x000470, "Wrong size on UBoxComponentForGuide");

// Class ProjectP.LAnimNotify_NpcStandGuardDisable
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_NpcStandGuardDisable final : public ULAnimNotifyBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_NpcStandGuardDisable">();
	}
	static class ULAnimNotify_NpcStandGuardDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_NpcStandGuardDisable>();
	}
};
static_assert(alignof(ULAnimNotify_NpcStandGuardDisable) == 0x000008, "Wrong alignment on ULAnimNotify_NpcStandGuardDisable");
static_assert(sizeof(ULAnimNotify_NpcStandGuardDisable) == 0x000050, "Wrong size on ULAnimNotify_NpcStandGuardDisable");
static_assert(offsetof(ULAnimNotify_NpcStandGuardDisable, WeaponAttachPointType) == 0x000048, "Member 'ULAnimNotify_NpcStandGuardDisable::WeaponAttachPointType' has a wrong offset!");

// Class ProjectP.LAnimNotify_GuardStatOverride
// 0x0028 (0x0070 - 0x0048)
class ULAnimNotify_GuardStatOverride final : public ULAnimNotifyBase
{
public:
	bool                                          UseGuardStatOverride;                              // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGuardStatOverride                    GuardStatOverride;                                 // 0x004C(0x0024)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_GuardStatOverride">();
	}
	static class ULAnimNotify_GuardStatOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_GuardStatOverride>();
	}
};
static_assert(alignof(ULAnimNotify_GuardStatOverride) == 0x000008, "Wrong alignment on ULAnimNotify_GuardStatOverride");
static_assert(sizeof(ULAnimNotify_GuardStatOverride) == 0x000070, "Wrong size on ULAnimNotify_GuardStatOverride");
static_assert(offsetof(ULAnimNotify_GuardStatOverride, UseGuardStatOverride) == 0x000048, "Member 'ULAnimNotify_GuardStatOverride::UseGuardStatOverride' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_GuardStatOverride, GuardStatOverride) == 0x00004C, "Member 'ULAnimNotify_GuardStatOverride::GuardStatOverride' has a wrong offset!");

// Class ProjectP.LLevelInactiveInterface
// 0x0000 (0x0028 - 0x0028)
class ILLevelInactiveInterface final : public IInterface
{
public:
	void ActivateLevelActor();
	void DeactivateLevelActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelInactiveInterface">();
	}
	static class ILLevelInactiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILLevelInactiveInterface>();
	}
};
static_assert(alignof(ILLevelInactiveInterface) == 0x000008, "Wrong alignment on ILLevelInactiveInterface");
static_assert(sizeof(ILLevelInactiveInterface) == 0x000028, "Wrong size on ILLevelInactiveInterface");

// Class ProjectP.LAnimNotify_PlayTimedCharacterSD
// 0x0090 (0x00D0 - 0x0040)
class ULAnimNotify_PlayTimedCharacterSD final : public ULAnimNotifyStateBase
{
public:
	class FName                                   EventName;                                         // 0x0040(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0048(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0050(0x0030)(BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0080(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeModifier;                                    // 0x0084(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSoundFadeData                        FadeIn;                                            // 0x008C(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSoundFadeData                        FadeOut;                                           // 0x009C(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x00B0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLCharacterSoundType                   TestCharacterSoundType;                            // 0x00C0(0x0008)(Edit, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_PlayTimedCharacterSD">();
	}
	static class ULAnimNotify_PlayTimedCharacterSD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_PlayTimedCharacterSD>();
	}
};
static_assert(alignof(ULAnimNotify_PlayTimedCharacterSD) == 0x000010, "Wrong alignment on ULAnimNotify_PlayTimedCharacterSD");
static_assert(sizeof(ULAnimNotify_PlayTimedCharacterSD) == 0x0000D0, "Wrong size on ULAnimNotify_PlayTimedCharacterSD");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, EventName) == 0x000040, "Member 'ULAnimNotify_PlayTimedCharacterSD::EventName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, SocketName) == 0x000048, "Member 'ULAnimNotify_PlayTimedCharacterSD::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, Offset) == 0x000050, "Member 'ULAnimNotify_PlayTimedCharacterSD::Offset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, bAttached) == 0x000080, "Member 'ULAnimNotify_PlayTimedCharacterSD::bAttached' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, VolumeModifier) == 0x000084, "Member 'ULAnimNotify_PlayTimedCharacterSD::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, MeshSelectionType) == 0x000088, "Member 'ULAnimNotify_PlayTimedCharacterSD::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, FadeIn) == 0x00008C, "Member 'ULAnimNotify_PlayTimedCharacterSD::FadeIn' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, FadeOut) == 0x00009C, "Member 'ULAnimNotify_PlayTimedCharacterSD::FadeOut' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, DisableWhenWeaponInListBroken) == 0x0000B0, "Member 'ULAnimNotify_PlayTimedCharacterSD::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_PlayTimedCharacterSD, TestCharacterSoundType) == 0x0000C0, "Member 'ULAnimNotify_PlayTimedCharacterSD::TestCharacterSoundType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ChangeFSMState
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_ChangeFSMState final : public ULAnimNotifyStateBase
{
public:
	ELAnimFSMState                                AnimFSMState;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LockRotation : 1;                                  // 0x0041(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangeFSMState">();
	}
	static class ULAnimNotifyState_ChangeFSMState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangeFSMState>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangeFSMState) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangeFSMState");
static_assert(sizeof(ULAnimNotifyState_ChangeFSMState) == 0x000048, "Wrong size on ULAnimNotifyState_ChangeFSMState");
static_assert(offsetof(ULAnimNotifyState_ChangeFSMState, AnimFSMState) == 0x000040, "Member 'ULAnimNotifyState_ChangeFSMState::AnimFSMState' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_GuardCheck_NoStiffen
// 0x0090 (0x00D0 - 0x0040)
class ULAnimNotifyState_GuardCheck_NoStiffen final : public ULAnimNotifyStateBase
{
public:
	int32                                         GuardRangeAngleStart;                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitCollisionInfo                     HitInfo;                                           // 0x0048(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GuardCheck_NoStiffen">();
	}
	static class ULAnimNotifyState_GuardCheck_NoStiffen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GuardCheck_NoStiffen>();
	}
};
static_assert(alignof(ULAnimNotifyState_GuardCheck_NoStiffen) == 0x000008, "Wrong alignment on ULAnimNotifyState_GuardCheck_NoStiffen");
static_assert(sizeof(ULAnimNotifyState_GuardCheck_NoStiffen) == 0x0000D0, "Wrong size on ULAnimNotifyState_GuardCheck_NoStiffen");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_NoStiffen, GuardRangeAngleStart) == 0x000040, "Member 'ULAnimNotifyState_GuardCheck_NoStiffen::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_NoStiffen, GuardRangeAngleEnd) == 0x000044, "Member 'ULAnimNotifyState_GuardCheck_NoStiffen::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_NoStiffen, HitInfo) == 0x000048, "Member 'ULAnimNotifyState_GuardCheck_NoStiffen::HitInfo' has a wrong offset!");

// Class ProjectP.LStargazerObject
// 0x0000 (0x0260 - 0x0260)
class ALStargazerObject : public ALLevelObject
{
public:
	void ResetDilationTime();
	void SetStargazerType(ELStargazerType StateData);
	void SetStargazerUnstable(bool Unstable);
	void UpdateDilationTime(float DeltaTime, float DilationScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LStargazerObject">();
	}
	static class ALStargazerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALStargazerObject>();
	}
};
static_assert(alignof(ALStargazerObject) == 0x000008, "Wrong alignment on ALStargazerObject");
static_assert(sizeof(ALStargazerObject) == 0x000260, "Wrong size on ALStargazerObject");

// Class ProjectP.LAnimNotifyState_GuardCheck_Arm_NoStiffen
// 0x00B8 (0x00F8 - 0x0040)
class ULAnimNotifyState_GuardCheck_Arm_NoStiffen final : public ULAnimNotifyStateBase
{
public:
	int32                                         GuardRangeAngleStart;                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRangeAngleEnd;                                // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGuardStatOverride                    GuardStatOverride;                                 // 0x0048(0x0024)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLHitCollisionInfo                     HitInfo;                                           // 0x0070(0x0088)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GuardCheck_Arm_NoStiffen">();
	}
	static class ULAnimNotifyState_GuardCheck_Arm_NoStiffen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GuardCheck_Arm_NoStiffen>();
	}
};
static_assert(alignof(ULAnimNotifyState_GuardCheck_Arm_NoStiffen) == 0x000008, "Wrong alignment on ULAnimNotifyState_GuardCheck_Arm_NoStiffen");
static_assert(sizeof(ULAnimNotifyState_GuardCheck_Arm_NoStiffen) == 0x0000F8, "Wrong size on ULAnimNotifyState_GuardCheck_Arm_NoStiffen");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm_NoStiffen, GuardRangeAngleStart) == 0x000040, "Member 'ULAnimNotifyState_GuardCheck_Arm_NoStiffen::GuardRangeAngleStart' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm_NoStiffen, GuardRangeAngleEnd) == 0x000044, "Member 'ULAnimNotifyState_GuardCheck_Arm_NoStiffen::GuardRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm_NoStiffen, GuardStatOverride) == 0x000048, "Member 'ULAnimNotifyState_GuardCheck_Arm_NoStiffen::GuardStatOverride' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_GuardCheck_Arm_NoStiffen, HitInfo) == 0x000070, "Member 'ULAnimNotifyState_GuardCheck_Arm_NoStiffen::HitInfo' has a wrong offset!");

// Class ProjectP.LAnimNotify_LAnimBranch
// 0x0030 (0x0070 - 0x0040)
class ULAnimNotify_LAnimBranch final : public ULAnimNotifyStateBase
{
public:
	bool                                          _condition_percent;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _percent_value;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _condition_hit_target;                             // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _hit_target_action_event_alias;                    // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _condition_defence_skill;                          // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _condition_part_needed;                            // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_LAnimBranch">();
	}
	static class ULAnimNotify_LAnimBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_LAnimBranch>();
	}
};
static_assert(alignof(ULAnimNotify_LAnimBranch) == 0x000008, "Wrong alignment on ULAnimNotify_LAnimBranch");
static_assert(sizeof(ULAnimNotify_LAnimBranch) == 0x000070, "Wrong size on ULAnimNotify_LAnimBranch");
static_assert(offsetof(ULAnimNotify_LAnimBranch, _condition_percent) == 0x000040, "Member 'ULAnimNotify_LAnimBranch::_condition_percent' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_LAnimBranch, _percent_value) == 0x000044, "Member 'ULAnimNotify_LAnimBranch::_percent_value' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_LAnimBranch, _condition_hit_target) == 0x000048, "Member 'ULAnimNotify_LAnimBranch::_condition_hit_target' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_LAnimBranch, _hit_target_action_event_alias) == 0x000050, "Member 'ULAnimNotify_LAnimBranch::_hit_target_action_event_alias' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_LAnimBranch, _condition_defence_skill) == 0x000060, "Member 'ULAnimNotify_LAnimBranch::_condition_defence_skill' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_LAnimBranch, _condition_part_needed) == 0x000064, "Member 'ULAnimNotify_LAnimBranch::_condition_part_needed' has a wrong offset!");

// Class ProjectP.LAnimNotify_SwapNpc
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_SwapNpc final : public ULAnimNotifyBase
{
public:
	class FName                                   SwapNpcCodeName;                                   // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnOffset;                                       // 0x0050(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInheritHP;                                        // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetSwapAtRespawn;                               // 0x005D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnOnSpot;                                      // 0x005E(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_SwapNpc">();
	}
	static class ULAnimNotify_SwapNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_SwapNpc>();
	}
};
static_assert(alignof(ULAnimNotify_SwapNpc) == 0x000008, "Wrong alignment on ULAnimNotify_SwapNpc");
static_assert(sizeof(ULAnimNotify_SwapNpc) == 0x000060, "Wrong size on ULAnimNotify_SwapNpc");
static_assert(offsetof(ULAnimNotify_SwapNpc, SwapNpcCodeName) == 0x000048, "Member 'ULAnimNotify_SwapNpc::SwapNpcCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SwapNpc, SpawnOffset) == 0x000050, "Member 'ULAnimNotify_SwapNpc::SpawnOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SwapNpc, bInheritHP) == 0x00005C, "Member 'ULAnimNotify_SwapNpc::bInheritHP' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SwapNpc, bResetSwapAtRespawn) == 0x00005D, "Member 'ULAnimNotify_SwapNpc::bResetSwapAtRespawn' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_SwapNpc, bSpawnOnSpot) == 0x00005E, "Member 'ULAnimNotify_SwapNpc::bSpawnOnSpot' has a wrong offset!");

// Class ProjectP.LMonologControl
// 0x0028 (0x0050 - 0x0028)
class ULMonologControl final : public UObject
{
public:
	bool                                          PlayingFromInteractCollision;                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogInfoPtr                         Monolog;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RepeatCount;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatTimer;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PendingStop;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetScriptText();
	void OnCompleteSingleMonologPlay();
	void PlayRepeat();

	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMonologControl">();
	}
	static class ULMonologControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULMonologControl>();
	}
};
static_assert(alignof(ULMonologControl) == 0x000008, "Wrong alignment on ULMonologControl");
static_assert(sizeof(ULMonologControl) == 0x000050, "Wrong size on ULMonologControl");
static_assert(offsetof(ULMonologControl, PlayingFromInteractCollision) == 0x000028, "Member 'ULMonologControl::PlayingFromInteractCollision' has a wrong offset!");
static_assert(offsetof(ULMonologControl, Monolog) == 0x000030, "Member 'ULMonologControl::Monolog' has a wrong offset!");
static_assert(offsetof(ULMonologControl, RepeatCount) == 0x000038, "Member 'ULMonologControl::RepeatCount' has a wrong offset!");
static_assert(offsetof(ULMonologControl, RepeatTimer) == 0x00003C, "Member 'ULMonologControl::RepeatTimer' has a wrong offset!");
static_assert(offsetof(ULMonologControl, PendingStop) == 0x000040, "Member 'ULMonologControl::PendingStop' has a wrong offset!");

// Class ProjectP.LAnimNotify_Smash
// 0x0050 (0x0098 - 0x0048)
class ULAnimNotify_Smash final : public ULAnimNotifyBase
{
public:
	ELMeshSelectionType                           MeshSelectionType;                                 // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x004C(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _OffsetLocation;                                   // 0x0054(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetRotation;                                    // 0x0060(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetScale;                                       // 0x006C(0x000C)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSocketOrientedOffset;                           // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAbsoluteRotation;                               // 0x0079(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeModifier;                                    // 0x007C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ELWeaponAttachPointType>               DisableWhenWeaponInListBroken;                     // 0x0080(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestAttackerSurface;                               // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         TestGroundSurface;                                 // 0x0091(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_Smash">();
	}
	static class ULAnimNotify_Smash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_Smash>();
	}
};
static_assert(alignof(ULAnimNotify_Smash) == 0x000008, "Wrong alignment on ULAnimNotify_Smash");
static_assert(sizeof(ULAnimNotify_Smash) == 0x000098, "Wrong size on ULAnimNotify_Smash");
static_assert(offsetof(ULAnimNotify_Smash, MeshSelectionType) == 0x000048, "Member 'ULAnimNotify_Smash::MeshSelectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, SocketName) == 0x00004C, "Member 'ULAnimNotify_Smash::SocketName' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, _OffsetLocation) == 0x000054, "Member 'ULAnimNotify_Smash::_OffsetLocation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, OffsetRotation) == 0x000060, "Member 'ULAnimNotify_Smash::OffsetRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, OffsetScale) == 0x00006C, "Member 'ULAnimNotify_Smash::OffsetScale' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, UseSocketOrientedOffset) == 0x000078, "Member 'ULAnimNotify_Smash::UseSocketOrientedOffset' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, UseAbsoluteRotation) == 0x000079, "Member 'ULAnimNotify_Smash::UseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, VolumeModifier) == 0x00007C, "Member 'ULAnimNotify_Smash::VolumeModifier' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, DisableWhenWeaponInListBroken) == 0x000080, "Member 'ULAnimNotify_Smash::DisableWhenWeaponInListBroken' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, TestAttackerSurface) == 0x000090, "Member 'ULAnimNotify_Smash::TestAttackerSurface' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Smash, TestGroundSurface) == 0x000091, "Member 'ULAnimNotify_Smash::TestGroundSurface' has a wrong offset!");

// Class ProjectP.LDebugCameraHUD
// 0x0038 (0x0308 - 0x02D0)
class ALDebugCameraHUD final : public ADebugCameraHUD
{
public:
	uint8                                         Pad_2D0[0x38];                                     // 0x02D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDebugCameraHUD">();
	}
	static class ALDebugCameraHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDebugCameraHUD>();
	}
};
static_assert(alignof(ALDebugCameraHUD) == 0x000008, "Wrong alignment on ALDebugCameraHUD");
static_assert(sizeof(ALDebugCameraHUD) == 0x000308, "Wrong size on ALDebugCameraHUD");

// Class ProjectP.LAnimNotifyState_ChangePCWeapon
// 0x0028 (0x0068 - 0x0040)
class ULAnimNotifyState_ChangePCWeapon final : public ULAnimNotifyStateBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType1;                            // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHandleCodeName1;                             // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBladeCodeName1;                              // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPointType2;                            // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponHandleCodeName2;                             // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponBladeCodeName2;                              // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangePCWeapon">();
	}
	static class ULAnimNotifyState_ChangePCWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangePCWeapon>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangePCWeapon) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangePCWeapon");
static_assert(sizeof(ULAnimNotifyState_ChangePCWeapon) == 0x000068, "Wrong size on ULAnimNotifyState_ChangePCWeapon");
static_assert(offsetof(ULAnimNotifyState_ChangePCWeapon, WeaponAttachPointType1) == 0x000040, "Member 'ULAnimNotifyState_ChangePCWeapon::WeaponAttachPointType1' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangePCWeapon, WeaponHandleCodeName1) == 0x000044, "Member 'ULAnimNotifyState_ChangePCWeapon::WeaponHandleCodeName1' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangePCWeapon, WeaponBladeCodeName1) == 0x00004C, "Member 'ULAnimNotifyState_ChangePCWeapon::WeaponBladeCodeName1' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangePCWeapon, WeaponAttachPointType2) == 0x000054, "Member 'ULAnimNotifyState_ChangePCWeapon::WeaponAttachPointType2' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangePCWeapon, WeaponHandleCodeName2) == 0x000058, "Member 'ULAnimNotifyState_ChangePCWeapon::WeaponHandleCodeName2' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangePCWeapon, WeaponBladeCodeName2) == 0x000060, "Member 'ULAnimNotifyState_ChangePCWeapon::WeaponBladeCodeName2' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_ChangeWeaponAnimState
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_ChangeWeaponAnimState final : public ULAnimNotifyStateBase
{
public:
	ELWeaponPartType                              WeaponPartType;                                    // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLWeaponAnimStateType                  AnimStateName;                                     // 0x0044(0x0008)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_ChangeWeaponAnimState">();
	}
	static class ULAnimNotifyState_ChangeWeaponAnimState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_ChangeWeaponAnimState>();
	}
};
static_assert(alignof(ULAnimNotifyState_ChangeWeaponAnimState) == 0x000008, "Wrong alignment on ULAnimNotifyState_ChangeWeaponAnimState");
static_assert(sizeof(ULAnimNotifyState_ChangeWeaponAnimState) == 0x000050, "Wrong size on ULAnimNotifyState_ChangeWeaponAnimState");
static_assert(offsetof(ULAnimNotifyState_ChangeWeaponAnimState, WeaponPartType) == 0x000040, "Member 'ULAnimNotifyState_ChangeWeaponAnimState::WeaponPartType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangeWeaponAnimState, WeaponAttachPointType) == 0x000041, "Member 'ULAnimNotifyState_ChangeWeaponAnimState::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_ChangeWeaponAnimState, AnimStateName) == 0x000044, "Member 'ULAnimNotifyState_ChangeWeaponAnimState::AnimStateName' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_InterectStateChange
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_InterectStateChange final : public ULAnimNotifyStateBase
{
public:
	bool                                          Input_Key_Check;                                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Input_Cam_Check;                                   // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_InterectStateChange">();
	}
	static class ULAnimNotifyState_InterectStateChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_InterectStateChange>();
	}
};
static_assert(alignof(ULAnimNotifyState_InterectStateChange) == 0x000008, "Wrong alignment on ULAnimNotifyState_InterectStateChange");
static_assert(sizeof(ULAnimNotifyState_InterectStateChange) == 0x000048, "Wrong size on ULAnimNotifyState_InterectStateChange");
static_assert(offsetof(ULAnimNotifyState_InterectStateChange, Input_Key_Check) == 0x000040, "Member 'ULAnimNotifyState_InterectStateChange::Input_Key_Check' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_InterectStateChange, Input_Cam_Check) == 0x000041, "Member 'ULAnimNotifyState_InterectStateChange::Input_Cam_Check' has a wrong offset!");

// Class ProjectP.LItem
// 0x0080 (0x00A8 - 0x0028)
class ULItem : public UObject
{
public:
	bool                                          VirtualBasedUpgrade;                               // 0x0028(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0xF];                                       // 0x0029(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemCommonInfoPtr                     CommonInfo;                                        // 0x0038(0x0008)(Edit, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ItemCount;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DurabilityAmount;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int64                                         UniqueId;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULItem>                  ComplexItem_Unit;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULItem>                  ComplexItem_Main;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ComplexItem_UseMainInstead : 1;                    // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLWeaponPart                           WeaponPart;                                        // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          OnToggled;                                         // 0x0098(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0xF];                                       // 0x0099(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanKeep();
	bool ChangeCorrection(ELStatCorrectChangeType Type);
	ELAssistUseItemSlotType GetAssistUseSlotType();
	ELEquipSlotType GetEquipSlotType();
	int32 GetMaxStackCount();
	int32 GetRawSlaveArmStat(ELSecondStat InStat);
	class ULItem* GetSlavearmAlteredItem();
	int32 GetSlaveArmStat(class AActor* InOwner, ELSecondStat InStat, bool IsVirtual);
	int32 GetSlaveArmStatBonus(class AActor* InOwner, ELSecondStat InStat, bool IsVirtual);
	int32 GetUseSlotIndex(bool FirstLine);
	bool IsEquipped();
	bool IsEquippedAssistUseItem();
	bool IsEquippedUseItem(bool* OutIsFirstLine);
	bool Reinforce();
	void SetComplexItem_UseMainInstead(bool UseMainInstead);
	void SetCount(int32 Count);
	void SetSlavearmAlteredItem(class ULItem* InAlteredItem);

	bool CanChangeCorrection(ELStatCorrectChangeType Type) const;
	bool CanCombineBlade(ELBladeShapeType BladeShapeType) const;
	bool CanReinforce() const;
	bool CanStackCount() const;
	struct FHandleStatCorrectionChangeInfoPtr GetChangeCorrectionInfo(ELStatCorrectChangeType Type) const;
	ELStatCorrectChangeType GetChangedCorrectionType() const;
	class FName GetCodeName() const;
	struct FItemCollectionInfoPtr GetCollectionInfo() const;
	struct FItemCommonInfoPtr GetCommonInfo() const;
	class ULItem* GetComplexItem_Main() const;
	class ULItem* GetComplexItem_Unit() const;
	struct FItemConsumeInfoPtr GetConsumeInfo() const;
	ELHandleCorrectResultGrade GetCorrectionGrade(ELFirstStat Type, ELStatCorrectChangeType WillBeChangeCorrection, int32* OutStackLevel) const;
	int32 GetCount() const;
	int32 GetDurabilityAmount() const;
	ELItemFirstCategory GetFirstCategory() const;
	TSoftObjectPtr<class UObject> GetImageResource() const;
	int64 GetItemId() const;
	int32 GetMaxSharpnessPoint(bool bIncludeSharpnessStatBonus, bool WillReinforceDiffStat, bool bIncludeGrindingReducement) const;
	int32 GetMaxSharpnessPointByType(ELBladeSharpnessType Type, bool bIncludeSharpnessStatBonus, bool WillReinforceDiffStat) const;
	struct FItemWeaponReinforceInfoPtr GetNextReinforceInfo() const;
	struct FItemPartsInfoPtr GetPartsInfo() const;
	int32 GetRawWeaponStat(ELSecondStat InStat, bool WillReinforceDiffStat, ELStatCorrectChangeType WillHandleDiffStat) const;
	struct FItemWeaponReinforceInfoPtr GetReinforceInfo() const;
	int32 GetReinforceLevel() const;
	ELItemSecondCategory GetSecondCategory() const;
	struct FItemSlaveArmInfoPtr GetSlaveArmInfo() const;
	struct FItemBladeInfoPtr GetWeaponBladeInfo() const;
	struct FItemHandleInfoPtr GetWeaponHandleInfo() const;
	int32 GetWeaponStat(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat, ELStatCorrectChangeType WillHandleDiffStat) const;
	int32 GetWeaponStatBonus(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat, ELStatCorrectChangeType WillHandleDiffStat) const;
	int32 GetWeight() const;
	bool IsBladeItem() const;
	bool IsChangedCorrection() const;
	bool IsComplexItem() const;
	bool IsHandleItem() const;
	bool IsOnToggled() const;
	bool IsReinforced() const;
	bool IsSameGroup(class ULItem* In) const;
	bool IsSameItem(class ULItem* In) const;
	bool IsToggleItem() const;
	bool IsWeapon() const;
	bool IsWeaponBlade() const;
	bool IsWeaponHandle() const;
	bool IsWeaponSlaveArm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LItem">();
	}
	static class ULItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULItem>();
	}
};
static_assert(alignof(ULItem) == 0x000008, "Wrong alignment on ULItem");
static_assert(sizeof(ULItem) == 0x0000A8, "Wrong size on ULItem");
static_assert(offsetof(ULItem, VirtualBasedUpgrade) == 0x000028, "Member 'ULItem::VirtualBasedUpgrade' has a wrong offset!");
static_assert(offsetof(ULItem, CommonInfo) == 0x000038, "Member 'ULItem::CommonInfo' has a wrong offset!");
static_assert(offsetof(ULItem, ItemCount) == 0x000040, "Member 'ULItem::ItemCount' has a wrong offset!");
static_assert(offsetof(ULItem, DurabilityAmount) == 0x000044, "Member 'ULItem::DurabilityAmount' has a wrong offset!");
static_assert(offsetof(ULItem, UniqueId) == 0x000048, "Member 'ULItem::UniqueId' has a wrong offset!");
static_assert(offsetof(ULItem, ComplexItem_Unit) == 0x000050, "Member 'ULItem::ComplexItem_Unit' has a wrong offset!");
static_assert(offsetof(ULItem, ComplexItem_Main) == 0x000058, "Member 'ULItem::ComplexItem_Main' has a wrong offset!");
static_assert(offsetof(ULItem, WeaponPart) == 0x000068, "Member 'ULItem::WeaponPart' has a wrong offset!");
static_assert(offsetof(ULItem, OnToggled) == 0x000098, "Member 'ULItem::OnToggled' has a wrong offset!");

// Class ProjectP.LAnimNotify_DecreaseWeaponDurability
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_DecreaseWeaponDurability final : public ULAnimNotifyBase
{
public:
	int32                                         DecreaseAmount;                                    // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_DecreaseWeaponDurability">();
	}
	static class ULAnimNotify_DecreaseWeaponDurability* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_DecreaseWeaponDurability>();
	}
};
static_assert(alignof(ULAnimNotify_DecreaseWeaponDurability) == 0x000008, "Wrong alignment on ULAnimNotify_DecreaseWeaponDurability");
static_assert(sizeof(ULAnimNotify_DecreaseWeaponDurability) == 0x000050, "Wrong size on ULAnimNotify_DecreaseWeaponDurability");
static_assert(offsetof(ULAnimNotify_DecreaseWeaponDurability, DecreaseAmount) == 0x000048, "Member 'ULAnimNotify_DecreaseWeaponDurability::DecreaseAmount' has a wrong offset!");

// Class ProjectP.LListView
// 0x04E0 (0x0850 - 0x0370)
class ULListView final : public UListView
{
public:
	struct FScrollBarStyle                        WidgetStyle;                                       // 0x0370(0x04D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_840[0x10];                                     // 0x0840(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetScrollOffset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LListView">();
	}
	static class ULListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULListView>();
	}
};
static_assert(alignof(ULListView) == 0x000008, "Wrong alignment on ULListView");
static_assert(sizeof(ULListView) == 0x000850, "Wrong size on ULListView");
static_assert(offsetof(ULListView, WidgetStyle) == 0x000370, "Member 'ULListView::WidgetStyle' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_EnableSkillHitDecreaseWeaponDurability
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability final : public ULAnimNotifyStateBase
{
public:
	int32                                         StartAngle;                                        // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAngle;                                          // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_EnableSkillHitDecreaseWeaponDurability">();
	}
	static class ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability>();
	}
};
static_assert(alignof(ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability) == 0x000008, "Wrong alignment on ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability");
static_assert(sizeof(ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability) == 0x000050, "Wrong size on ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability");
static_assert(offsetof(ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability, StartAngle) == 0x000040, "Member 'ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability::StartAngle' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability, EndAngle) == 0x000044, "Member 'ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability::EndAngle' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability, Distance) == 0x000048, "Member 'ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability::Distance' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability, WeaponAttachPointType) == 0x00004C, "Member 'ULAnimNotifyState_EnableSkillHitDecreaseWeaponDurability::WeaponAttachPointType' has a wrong offset!");

// Class ProjectP.LAnimNotify_ConsumeFrenzyUnit
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_ConsumeFrenzyUnit final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_ConsumeFrenzyUnit">();
	}
	static class ULAnimNotify_ConsumeFrenzyUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_ConsumeFrenzyUnit>();
	}
};
static_assert(alignof(ULAnimNotify_ConsumeFrenzyUnit) == 0x000008, "Wrong alignment on ULAnimNotify_ConsumeFrenzyUnit");
static_assert(sizeof(ULAnimNotify_ConsumeFrenzyUnit) == 0x000048, "Wrong size on ULAnimNotify_ConsumeFrenzyUnit");

// Class ProjectP.LAnimNotifyState_AllowRootmotionHeight
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_AllowRootmotionHeight final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_AllowRootmotionHeight">();
	}
	static class ULAnimNotifyState_AllowRootmotionHeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_AllowRootmotionHeight>();
	}
};
static_assert(alignof(ULAnimNotifyState_AllowRootmotionHeight) == 0x000008, "Wrong alignment on ULAnimNotifyState_AllowRootmotionHeight");
static_assert(sizeof(ULAnimNotifyState_AllowRootmotionHeight) == 0x000040, "Wrong size on ULAnimNotifyState_AllowRootmotionHeight");

// Class ProjectP.LSlaveArmItem
// 0x0020 (0x00C8 - 0x00A8)
class ULSlaveArmItem final : public ULItem
{
public:
	int32                                         Ammo_Max;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ammo_Max_Additional;                               // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ammo_Current;                                      // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ammo_Reload_Cooltime;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ammo_Reload_RemainTime;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ammo_Reload_Amount;                                // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELShotGunAmmoType                             CurrentShotGunAmmoType;                            // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAcidSpreadingModeType                       AcidSpreadingMode;                                 // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeShotGunAmmo(ELShotGunAmmoType InType);
	void ChangeSpreadingMode(ELAcidSpreadingModeType InMode);
	void ConsumeAmmo(int32 ConsumeAmmoCount);
	void RefreshUIState();
	void UpdateAmmoUI();

	bool CanCombinedKeyActionEnable() const;
	bool IsAcidSpreaderSlavearm() const;
	bool IsAegisInCooltime() const;
	bool IsAegisSlaveArm() const;
	bool IsFlameThrowerSlavearm() const;
	bool IsFulminisSlaveArm() const;
	bool IsNormalSlaveArm() const;
	bool IsPileBunkerSlaveArm() const;
	bool IsPuppetStringSlaveArm() const;
	bool IsShotGunSlavearm() const;
	bool IsSniperCannonSlaveArm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSlaveArmItem">();
	}
	static class ULSlaveArmItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSlaveArmItem>();
	}
};
static_assert(alignof(ULSlaveArmItem) == 0x000008, "Wrong alignment on ULSlaveArmItem");
static_assert(sizeof(ULSlaveArmItem) == 0x0000C8, "Wrong size on ULSlaveArmItem");
static_assert(offsetof(ULSlaveArmItem, Ammo_Max) == 0x0000A8, "Member 'ULSlaveArmItem::Ammo_Max' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, Ammo_Max_Additional) == 0x0000AC, "Member 'ULSlaveArmItem::Ammo_Max_Additional' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, Ammo_Current) == 0x0000B0, "Member 'ULSlaveArmItem::Ammo_Current' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, Ammo_Reload_Cooltime) == 0x0000B4, "Member 'ULSlaveArmItem::Ammo_Reload_Cooltime' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, Ammo_Reload_RemainTime) == 0x0000B8, "Member 'ULSlaveArmItem::Ammo_Reload_RemainTime' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, Ammo_Reload_Amount) == 0x0000BC, "Member 'ULSlaveArmItem::Ammo_Reload_Amount' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, CurrentShotGunAmmoType) == 0x0000C0, "Member 'ULSlaveArmItem::CurrentShotGunAmmoType' has a wrong offset!");
static_assert(offsetof(ULSlaveArmItem, AcidSpreadingMode) == 0x0000C1, "Member 'ULSlaveArmItem::AcidSpreadingMode' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_FloatingState
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_FloatingState final : public ULAnimNotifyStateBase
{
public:
	class FName                                   EndSkillCodeName;                                  // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCeiling;                                     // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_FloatingState">();
	}
	static class ULAnimNotifyState_FloatingState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_FloatingState>();
	}
};
static_assert(alignof(ULAnimNotifyState_FloatingState) == 0x000008, "Wrong alignment on ULAnimNotifyState_FloatingState");
static_assert(sizeof(ULAnimNotifyState_FloatingState) == 0x000050, "Wrong size on ULAnimNotifyState_FloatingState");
static_assert(offsetof(ULAnimNotifyState_FloatingState, EndSkillCodeName) == 0x000040, "Member 'ULAnimNotifyState_FloatingState::EndSkillCodeName' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_FloatingState, bApplyCeiling) == 0x000048, "Member 'ULAnimNotifyState_FloatingState::bApplyCeiling' has a wrong offset!");

// Class ProjectP.LDialogDebugInfo
// 0x0060 (0x0088 - 0x0028)
class ULDialogDebugInfo final : public UObject
{
public:
	class FName                                   NPCCodeName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TalkerCodeName;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLSingleDialogDebugInfo                Main;                                              // 0x0038(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLSingleDialogDebugInfo>        Menu;                                              // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDialogDebugInfo">();
	}
	static class ULDialogDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDialogDebugInfo>();
	}
};
static_assert(alignof(ULDialogDebugInfo) == 0x000008, "Wrong alignment on ULDialogDebugInfo");
static_assert(sizeof(ULDialogDebugInfo) == 0x000088, "Wrong size on ULDialogDebugInfo");
static_assert(offsetof(ULDialogDebugInfo, NPCCodeName) == 0x000028, "Member 'ULDialogDebugInfo::NPCCodeName' has a wrong offset!");
static_assert(offsetof(ULDialogDebugInfo, TalkerCodeName) == 0x000030, "Member 'ULDialogDebugInfo::TalkerCodeName' has a wrong offset!");
static_assert(offsetof(ULDialogDebugInfo, Main) == 0x000038, "Member 'ULDialogDebugInfo::Main' has a wrong offset!");
static_assert(offsetof(ULDialogDebugInfo, Menu) == 0x000078, "Member 'ULDialogDebugInfo::Menu' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_FloatingStateOff
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_FloatingStateOff final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_FloatingStateOff">();
	}
	static class ULAnimNotifyState_FloatingStateOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_FloatingStateOff>();
	}
};
static_assert(alignof(ULAnimNotifyState_FloatingStateOff) == 0x000008, "Wrong alignment on ULAnimNotifyState_FloatingStateOff");
static_assert(sizeof(ULAnimNotifyState_FloatingStateOff) == 0x000040, "Wrong size on ULAnimNotifyState_FloatingStateOff");

// Class ProjectP.LAnimNotifyState_FloatingCollisionEnable
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_FloatingCollisionEnable final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_FloatingCollisionEnable">();
	}
	static class ULAnimNotifyState_FloatingCollisionEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_FloatingCollisionEnable>();
	}
};
static_assert(alignof(ULAnimNotifyState_FloatingCollisionEnable) == 0x000008, "Wrong alignment on ULAnimNotifyState_FloatingCollisionEnable");
static_assert(sizeof(ULAnimNotifyState_FloatingCollisionEnable) == 0x000040, "Wrong size on ULAnimNotifyState_FloatingCollisionEnable");

// Class ProjectP.LAnimNotifyState_CheckCommandHold
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_CheckCommandHold final : public ULAnimNotifyStateBase
{
public:
	class FName                                   Command;                                           // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_CheckCommandHold">();
	}
	static class ULAnimNotifyState_CheckCommandHold* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_CheckCommandHold>();
	}
};
static_assert(alignof(ULAnimNotifyState_CheckCommandHold) == 0x000008, "Wrong alignment on ULAnimNotifyState_CheckCommandHold");
static_assert(sizeof(ULAnimNotifyState_CheckCommandHold) == 0x000048, "Wrong size on ULAnimNotifyState_CheckCommandHold");
static_assert(offsetof(ULAnimNotifyState_CheckCommandHold, Command) == 0x000040, "Member 'ULAnimNotifyState_CheckCommandHold::Command' has a wrong offset!");

// Class ProjectP.LItemDropSystem
// 0x0068 (0x00E0 - 0x0078)
class ULItemDropSystem final : public ULGameSubSystem
{
public:
	class ALItemDropSystemData*                   SystemData;                                        // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ItemDropEnable;                                    // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ItemDefaultExtent;                                 // 0x0094(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ItemLargeExtent;                                   // 0x00A0(0x000C)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemTraceHeight;                                   // 0x00AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemTraceSize;                                     // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDropErgoData>                 DropErgoDataList;                                  // 0x00C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ActiveNpcSpotDie;                                  // 0x00D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULNpcSpotDieData*                       NpcSpotDieData;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GainDropErgoData(const class FString& SpotUniqueID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LItemDropSystem">();
	}
	static class ULItemDropSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULItemDropSystem>();
	}
};
static_assert(alignof(ULItemDropSystem) == 0x000008, "Wrong alignment on ULItemDropSystem");
static_assert(sizeof(ULItemDropSystem) == 0x0000E0, "Wrong size on ULItemDropSystem");
static_assert(offsetof(ULItemDropSystem, SystemData) == 0x000078, "Member 'ULItemDropSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, ItemDropEnable) == 0x000090, "Member 'ULItemDropSystem::ItemDropEnable' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, ItemDefaultExtent) == 0x000094, "Member 'ULItemDropSystem::ItemDefaultExtent' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, ItemLargeExtent) == 0x0000A0, "Member 'ULItemDropSystem::ItemLargeExtent' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, ItemTraceHeight) == 0x0000AC, "Member 'ULItemDropSystem::ItemTraceHeight' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, ItemTraceSize) == 0x0000B0, "Member 'ULItemDropSystem::ItemTraceSize' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, DropErgoDataList) == 0x0000C0, "Member 'ULItemDropSystem::DropErgoDataList' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, ActiveNpcSpotDie) == 0x0000D0, "Member 'ULItemDropSystem::ActiveNpcSpotDie' has a wrong offset!");
static_assert(offsetof(ULItemDropSystem, NpcSpotDieData) == 0x0000D8, "Member 'ULItemDropSystem::NpcSpotDieData' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Show_Weapon_Forced
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_Show_Weapon_Forced final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Show_Weapon_Forced">();
	}
	static class ULAnimNotifyState_Show_Weapon_Forced* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Show_Weapon_Forced>();
	}
};
static_assert(alignof(ULAnimNotifyState_Show_Weapon_Forced) == 0x000008, "Wrong alignment on ULAnimNotifyState_Show_Weapon_Forced");
static_assert(sizeof(ULAnimNotifyState_Show_Weapon_Forced) == 0x000040, "Wrong size on ULAnimNotifyState_Show_Weapon_Forced");

// Class ProjectP.LHitProcContext
// 0x0B38 (0x0B60 - 0x0028)
class ULHitProcContext : public UObject
{
public:
	class AActor*                                 Attacker;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Original_HitResult;                                // 0x0038(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              Original_HitInfo;                                  // 0x00C0(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x50];                                     // 0x0210(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Original_SkillHitCodeName;                         // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkillHitInfoPtr                       Original_SkillHitInfo;                             // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSkillHitInfoPtr                       SkillHitInfo;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class ULHitProcComponent*                     Attacker_HitProcComp;                              // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActMgrComponent*                      Attacker_ActMgrComp;                               // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULStatComponent*                        Attacker_StatComp;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              Attacker_ActionAtHitStarted;                       // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               Attacker_Weapon;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULHitProcComponent*                     Victim_HitProcComp;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActMgrComponent*                      Victim_ActMgrComp;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULStatComponent*                        Victim_StatComp;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULActBase*                              Victim_ActionAtHitStarted;                         // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeapon*                               Victim_Weapon;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPartsActor*                           Victim_PartsActor;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       Victim_PartsComp;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       Attacker_BodyWeapon;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPartsComponent*                       Attacker_TestBodyWeapon;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Processed_Attacker_HitActionClassName;             // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Processed_Attacker_SkillCodeName;                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Processed_Attacker_HitResult;                      // 0x0300(0x0088)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              Processed_Attacker_HitInfo;                        // 0x0388(0x0150)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Processed_Victim_HitActionClassName;               // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Processed_Victim_SkillCodeName;                    // 0x04E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Processed_Victim_CommonMontageCodeName;            // 0x04E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Processed_Victim_HitResult;                        // 0x04F0(0x0088)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              Processed_Victim_HitInfo;                          // 0x0578(0x0150)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Processed_Victim_DiedByCurrentHit : 1;             // 0x06C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_PlayDieAction : 1;                // 0x06C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_Endured : 1;                      // 0x06C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_GuardSucceed : 1;                 // 0x06C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_PerfectGuardSucceed : 1;          // 0x06C8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_GuardBreak : 1;                   // 0x06C8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_GuardReflect : 1;                 // 0x06C8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_Dodge : 1;                        // 0x06C8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Processed_Victim_PartsDestoryed : 1;               // 0x06C9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6CA[0x2];                                      // 0x06CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Processed_SkillHitCodeName_To_Attacker;            // 0x06CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Processed_IsMultipleHit : 1;                       // 0x06D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6D5[0x3];                                      // 0x06D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLReceiveDamageParams                  Processed_ReceiveDamageParams;                     // 0x06D8(0x00D0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLReceiveDamageResults                 Processed_ReceiveDamageResults;                    // 0x07A8(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLCalcDamageData                       Processed_CalcDamageData;                          // 0x07C0(0x0110)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLReservedHitContext                   Processed_ReservedHitContext;                      // 0x08D0(0x01E8)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB8[0x8];                                      // 0x0AB8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLHitFXPlayData                        Processed_HitFXPlayData;                           // 0x0AC0(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<ELMomentType>                          Processed_ReachMomentTypeArray;                    // 0x0B40(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Processed_DebugString;                             // 0x0B50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AttackerActionAtHitStarted(EExecutePin* Branches, class ULActBase** OutActionAtHitStarted);
	void AttackerActMgrComp(EExecutePin* Branches, class ULActMgrComponent** OutActMgrComponent);
	void AttackerAs(ELHitProcObjectType* Branches, class ALCharacter** OutCharacter, class ALPCCharacter** OutPC, class ALNPCCharacter** OutNPC, class ALDynamicDamageVolumeActor** OutDamageVolume, class ALProjectile** OutProjectile);
	void AttackerHitProcComp(EExecutePin* Branches, class ULHitProcComponent** OutHitProcComponent);
	void AttackerStatComp(EExecutePin* Branches, class ULStatComponent** OutStatComponent);
	void AttackerWeapon(EExecutePin* Branches, class ALWeapon** OutWeapon);
	bool ChangeSkillHitBP(class FName InSkillHitCodeName, EExecutePin* Branches);
	bool OnPrepareBP();
	void OnResetBP();
	bool PrepareBP(class AActor* InAttacker, class AActor* InVictim, const struct FHitResult& InHitResult, const struct FLHitInfo& InHitInfo, EExecutePin* Branches);
	void Reset();
	void VictimActionAtHitStarted(EExecutePin* Branches, class ULActBase** OutActionAtHitStarted);
	void VictimActMgrComp(EExecutePin* Branches, class ULActMgrComponent** OutActMgrComponent);
	void VictimAs(ELHitProcObjectType* Branches, class ALCharacter** OutCharacter, class ALPCCharacter** OutPC, class ALNPCCharacter** OutNPC, class ALDynamicDamageVolumeActor** OutDamageVolume, class ALProjectile** OutProjectile);
	void VictimHitProcComp(EExecutePin* Branches, class ULHitProcComponent** OutHitProcComponent);
	void VictimStatComp(EExecutePin* Branches, class ULStatComponent** OutStatComponent);
	void VictimWeapon(EExecutePin* Branches, class ALWeapon** OutWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitProcContext">();
	}
	static class ULHitProcContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHitProcContext>();
	}
};
static_assert(alignof(ULHitProcContext) == 0x000010, "Wrong alignment on ULHitProcContext");
static_assert(sizeof(ULHitProcContext) == 0x000B60, "Wrong size on ULHitProcContext");
static_assert(offsetof(ULHitProcContext, Attacker) == 0x000028, "Member 'ULHitProcContext::Attacker' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim) == 0x000030, "Member 'ULHitProcContext::Victim' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Original_HitResult) == 0x000038, "Member 'ULHitProcContext::Original_HitResult' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Original_HitInfo) == 0x0000C0, "Member 'ULHitProcContext::Original_HitInfo' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Original_SkillHitCodeName) == 0x000260, "Member 'ULHitProcContext::Original_SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Original_SkillHitInfo) == 0x000268, "Member 'ULHitProcContext::Original_SkillHitInfo' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, SkillHitCodeName) == 0x000270, "Member 'ULHitProcContext::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, SkillHitInfo) == 0x000278, "Member 'ULHitProcContext::SkillHitInfo' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_HitProcComp) == 0x000280, "Member 'ULHitProcContext::Attacker_HitProcComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_ActMgrComp) == 0x000288, "Member 'ULHitProcContext::Attacker_ActMgrComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_StatComp) == 0x000290, "Member 'ULHitProcContext::Attacker_StatComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_ActionAtHitStarted) == 0x000298, "Member 'ULHitProcContext::Attacker_ActionAtHitStarted' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_Weapon) == 0x0002A0, "Member 'ULHitProcContext::Attacker_Weapon' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_HitProcComp) == 0x0002A8, "Member 'ULHitProcContext::Victim_HitProcComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_ActMgrComp) == 0x0002B0, "Member 'ULHitProcContext::Victim_ActMgrComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_StatComp) == 0x0002B8, "Member 'ULHitProcContext::Victim_StatComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_ActionAtHitStarted) == 0x0002C0, "Member 'ULHitProcContext::Victim_ActionAtHitStarted' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_Weapon) == 0x0002C8, "Member 'ULHitProcContext::Victim_Weapon' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_PartsActor) == 0x0002D0, "Member 'ULHitProcContext::Victim_PartsActor' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Victim_PartsComp) == 0x0002D8, "Member 'ULHitProcContext::Victim_PartsComp' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_BodyWeapon) == 0x0002E0, "Member 'ULHitProcContext::Attacker_BodyWeapon' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Attacker_TestBodyWeapon) == 0x0002E8, "Member 'ULHitProcContext::Attacker_TestBodyWeapon' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Attacker_HitActionClassName) == 0x0002F0, "Member 'ULHitProcContext::Processed_Attacker_HitActionClassName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Attacker_SkillCodeName) == 0x0002F8, "Member 'ULHitProcContext::Processed_Attacker_SkillCodeName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Attacker_HitResult) == 0x000300, "Member 'ULHitProcContext::Processed_Attacker_HitResult' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Attacker_HitInfo) == 0x000388, "Member 'ULHitProcContext::Processed_Attacker_HitInfo' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Victim_HitActionClassName) == 0x0004D8, "Member 'ULHitProcContext::Processed_Victim_HitActionClassName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Victim_SkillCodeName) == 0x0004E0, "Member 'ULHitProcContext::Processed_Victim_SkillCodeName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Victim_CommonMontageCodeName) == 0x0004E8, "Member 'ULHitProcContext::Processed_Victim_CommonMontageCodeName' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Victim_HitResult) == 0x0004F0, "Member 'ULHitProcContext::Processed_Victim_HitResult' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_Victim_HitInfo) == 0x000578, "Member 'ULHitProcContext::Processed_Victim_HitInfo' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_SkillHitCodeName_To_Attacker) == 0x0006CC, "Member 'ULHitProcContext::Processed_SkillHitCodeName_To_Attacker' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_ReceiveDamageParams) == 0x0006D8, "Member 'ULHitProcContext::Processed_ReceiveDamageParams' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_ReceiveDamageResults) == 0x0007A8, "Member 'ULHitProcContext::Processed_ReceiveDamageResults' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_CalcDamageData) == 0x0007C0, "Member 'ULHitProcContext::Processed_CalcDamageData' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_ReservedHitContext) == 0x0008D0, "Member 'ULHitProcContext::Processed_ReservedHitContext' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_HitFXPlayData) == 0x000AC0, "Member 'ULHitProcContext::Processed_HitFXPlayData' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_ReachMomentTypeArray) == 0x000B40, "Member 'ULHitProcContext::Processed_ReachMomentTypeArray' has a wrong offset!");
static_assert(offsetof(ULHitProcContext, Processed_DebugString) == 0x000B50, "Member 'ULHitProcContext::Processed_DebugString' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_BareHand_On
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_BareHand_On final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_BareHand_On">();
	}
	static class ULAnimNotifyState_BareHand_On* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_BareHand_On>();
	}
};
static_assert(alignof(ULAnimNotifyState_BareHand_On) == 0x000008, "Wrong alignment on ULAnimNotifyState_BareHand_On");
static_assert(sizeof(ULAnimNotifyState_BareHand_On) == 0x000040, "Wrong size on ULAnimNotifyState_BareHand_On");

// Class ProjectP.LAnimNotifyState_BareHand_Off
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_BareHand_Off final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_BareHand_Off">();
	}
	static class ULAnimNotifyState_BareHand_Off* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_BareHand_Off>();
	}
};
static_assert(alignof(ULAnimNotifyState_BareHand_Off) == 0x000008, "Wrong alignment on ULAnimNotifyState_BareHand_Off");
static_assert(sizeof(ULAnimNotifyState_BareHand_Off) == 0x000040, "Wrong size on ULAnimNotifyState_BareHand_Off");

// Class ProjectP.LAnimNotify_SetMovementMode
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_SetMovementMode final : public ULAnimNotifyBase
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_SetMovementMode">();
	}
	static class ULAnimNotify_SetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_SetMovementMode>();
	}
};
static_assert(alignof(ULAnimNotify_SetMovementMode) == 0x000008, "Wrong alignment on ULAnimNotify_SetMovementMode");
static_assert(sizeof(ULAnimNotify_SetMovementMode) == 0x000050, "Wrong size on ULAnimNotify_SetMovementMode");
static_assert(offsetof(ULAnimNotify_SetMovementMode, MovementMode) == 0x000048, "Member 'ULAnimNotify_SetMovementMode::MovementMode' has a wrong offset!");

// Class ProjectP.LOptionSystemData
// 0x02D0 (0x04B0 - 0x01E0)
class ALOptionSystemData : public AActor
{
public:
	int32                                         Visual_RenderScale;                                // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Viewdistance;                               // 0x01E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Antialiasing;                               // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Postprocess;                                // 0x01EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Shadow;                                     // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Texture;                                    // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Effects;                                    // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Foliage;                                    // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Shading;                                    // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Anisotropy;                                 // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Atmosphere;                                 // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_AmbientOcclusion;                           // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Reflection;                                 // 0x0210(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_FSR;                                        // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_RayTracing;                                 // 0x0218(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_FrameRate;                                  // 0x021C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_Resolution;                                 // 0x0220(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_DynamicResMode;                             // 0x0224(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_DynamicResMin;                              // 0x0228(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_DynamicResMax;                              // 0x022C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_DynamicResTimeUS;                           // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_RenderScale;                                   // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Viewdistance;                                  // 0x0238(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Antialiasing;                                  // 0x023C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Postprocess;                                   // 0x0240(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Shadow;                                        // 0x0244(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Texture;                                       // 0x0248(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Effects;                                       // 0x024C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Foliage;                                       // 0x0250(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Shading;                                       // 0x0254(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Anisotropy;                                    // 0x0258(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Atmosphere;                                    // 0x025C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_AmbientOcclusion;                              // 0x0260(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Reflection;                                    // 0x0264(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_FSR;                                           // 0x0268(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_RayTracing;                                    // 0x026C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_FrameRate;                                     // 0x0270(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_Resolution;                                    // 0x0274(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_DynamicResMode;                                // 0x0278(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_DynamicResMin;                                 // 0x027C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_DynamicResMax;                                 // 0x0280(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_DynamicResTimeUS;                              // 0x0284(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_RenderScale;                                // 0x0288(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Viewdistance;                               // 0x028C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Antialiasing;                               // 0x0290(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Postprocess;                                // 0x0294(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Shadow;                                     // 0x0298(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Texture;                                    // 0x029C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Effects;                                    // 0x02A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Foliage;                                    // 0x02A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Shading;                                    // 0x02A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Anisotropy;                                 // 0x02AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Atmosphere;                                 // 0x02B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_AmbientOcclusion;                           // 0x02B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Reflection;                                 // 0x02B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_FSR;                                        // 0x02BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_RayTracing;                                 // 0x02C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_FrameRate;                                  // 0x02C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_Resolution;                                 // 0x02C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_DynamicResMode;                             // 0x02CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_DynamicResMin;                              // 0x02D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_DynamicResMax;                              // 0x02D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_DynamicResTimeUS;                           // 0x02D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_RenderScale;                            // 0x02DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Viewdistance;                           // 0x02E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Antialiasing;                           // 0x02E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Postprocess;                            // 0x02E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Shadow;                                 // 0x02EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Texture;                                // 0x02F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Effects;                                // 0x02F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Foliage;                                // 0x02F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Shading;                                // 0x02FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Anisotropy;                             // 0x0300(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Atmosphere;                             // 0x0304(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_AmbientOcclusion;                       // 0x0308(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Reflection;                             // 0x030C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_FSR;                                    // 0x0310(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_RayTracing;                             // 0x0314(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_FrameRate;                              // 0x0318(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_Resolution;                             // 0x031C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_DynamicResMode;                         // 0x0320(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_DynamicResMin;                          // 0x0324(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_DynamicResMax;                          // 0x0328(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Visual_2nd_DynamicResTimeUS;                       // 0x032C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_RenderScale;                               // 0x0330(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Viewdistance;                              // 0x0334(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Antialiasing;                              // 0x0338(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Postprocess;                               // 0x033C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Shadow;                                    // 0x0340(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Texture;                                   // 0x0344(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Effects;                                   // 0x0348(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Foliage;                                   // 0x034C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Shading;                                   // 0x0350(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Anisotropy;                                // 0x0354(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Atmosphere;                                // 0x0358(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_AmbientOcclusion;                          // 0x035C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Reflection;                                // 0x0360(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_FSR;                                       // 0x0364(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_RayTracing;                                // 0x0368(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_FrameRate;                                 // 0x036C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_Resolution;                                // 0x0370(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_DynamicResMode;                            // 0x0374(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_DynamicResMin;                             // 0x0378(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_DynamicResMax;                             // 0x037C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HFR_2nd_DynamicResTimeUS;                          // 0x0380(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_RenderScale;                            // 0x0384(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Viewdistance;                           // 0x0388(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Antialiasing;                           // 0x038C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Postprocess;                            // 0x0390(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Shadow;                                 // 0x0394(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Texture;                                // 0x0398(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Effects;                                // 0x039C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Foliage;                                // 0x03A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Shading;                                // 0x03A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Anisotropy;                             // 0x03A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Atmosphere;                             // 0x03AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_AmbientOcclusion;                       // 0x03B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Reflection;                             // 0x03B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_FSR;                                    // 0x03B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_RayTracing;                             // 0x03BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_FrameRate;                              // 0x03C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_Resolution;                             // 0x03C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_DynamicResMode;                         // 0x03C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_DynamicResMin;                          // 0x03CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_DynamicResMax;                          // 0x03D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action_2nd_DynamicResTimeUS;                       // 0x03D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_RenderScaleStep;                               // 0x03D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_ViewdistanceStep;                              // 0x03DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_AntialiasingStep;                              // 0x03E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_PostprocessStep;                               // 0x03E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_ShadowStep;                                    // 0x03E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_TextureStep;                                   // 0x03EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_EffectsStep;                                   // 0x03F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_FoliageStep;                                   // 0x03F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_ShadingStep;                                   // 0x03F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_AnisotropyStep;                                // 0x03FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_AtmosphereStep;                                // 0x0400(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_AmbientOcclusionStep;                          // 0x0404(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Low_ReflectionStep;                                // 0x0408(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_RenderScaleStep;                            // 0x040C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_ViewdistanceStep;                           // 0x0410(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_AntialiasingStep;                           // 0x0414(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_PostprocessStep;                            // 0x0418(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_ShadowStep;                                 // 0x041C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_TextureStep;                                // 0x0420(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_EffectsStep;                                // 0x0424(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_FoliageStep;                                // 0x0428(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_ShadingStep;                                // 0x042C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_AnisotropyStep;                             // 0x0430(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_AtmosphereStep;                             // 0x0434(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_AmbientOcclusionStep;                       // 0x0438(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Medium_ReflectionStep;                             // 0x043C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_RenderScaleStep;                              // 0x0440(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_ViewdistanceStep;                             // 0x0444(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_AntialiasingStep;                             // 0x0448(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_PostprocessStep;                              // 0x044C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_ShadowStep;                                   // 0x0450(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_TextureStep;                                  // 0x0454(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_EffectsStep;                                  // 0x0458(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_FoliageStep;                                  // 0x045C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_ShadingStep;                                  // 0x0460(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_AnisotropyStep;                               // 0x0464(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_AtmosphereStep;                               // 0x0468(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_AmbientOcclusionStep;                         // 0x046C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         High_ReflectionStep;                               // 0x0470(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_RenderScaleStep;                              // 0x0474(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_ViewdistanceStep;                             // 0x0478(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_AntialiasingStep;                             // 0x047C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_PostprocessStep;                              // 0x0480(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_ShadowStep;                                   // 0x0484(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_TextureStep;                                  // 0x0488(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_EffectsStep;                                  // 0x048C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_FoliageStep;                                  // 0x0490(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_ShadingStep;                                  // 0x0494(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_AnisotropyStep;                               // 0x0498(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_AtmosphereStep;                               // 0x049C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_AmbientOcclusionStep;                         // 0x04A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Epic_ReflectionStep;                               // 0x04A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumAspectRatio;                                // 0x04A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetDefault_EnableAlignmentToCamera();
	bool GetDefault_EnableCameraShake();
	bool GetDefault_EnableMoveCameraUpDown();
	bool GetDefaultCameraInvert(ECameraDirectOption InRotator);
	int32 GetDefaultCameraSpeedIdx(ECameraDirectOption InRotator);
	int32 GetDefaultDeadZoneIdx(bool LeftStick);
	bool GetDefaultEnableBloodExpression();
	bool GetDefaultEnableMotionBlur();
	bool GetDefaultEnableTutorialPopup();
	bool GetDefaultEnableVideoSubtitle();
	int32 GetDefaultForceFeedbackIdx();
	ELFramerateLimit GetDefaultFramerateLimit();
	EWindowMode GetDefaultFullscreenMode();
	ELHUDVisible GetDefaultHUDVisibility();
	class FName GetDefaultInputPresetName(bool IsGamePad);
	class FString GetDefaultLanguage();
	int32 GetDefaultLockOnImportanceWeightMultiply();
	EPlayStyleOption GetDefaultPlayStyleOption();
	ELScalabilityLevel GetDefaultScalabilityLevel();
	struct FIntPoint GetDefaultScreenResolution();
	int32 GetDefaultSelectableMouseSensitivityMultiplyIdx();
	int32 GetDefaultSubtitleSize();
	bool GetDefaultUseAutoNewTargetLockOn();
	bool GetDefaultUseAutoTargeting();
	bool GetDefaultUseHDR();
	int32 GetDefaultVolumeIdx(ELVolumeType InType);
	bool GetDefaultVSyncEnabled();
	TArray<float> GetSelectableCameraSpeeds(ECameraDirectOption InRotator, bool IsPad);
	TArray<float> GetSelectableDeadZone(bool LeftStick);
	TArray<float> GetSelectableForceFeedback();
	TArray<float> GetSelectableFramerateLimits();
	TArray<class FString> GetSelectableLanguages();
	TArray<struct FLLockOnImportanceWeight> GetSelectableLockOnImportanceWeightMultiply();
	TArray<float> GetSelectableMouseSensitivityMultiply();
	TArray<float> GetSelectableVolumes(ELVolumeType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LOptionSystemData">();
	}
	static class ALOptionSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALOptionSystemData>();
	}
};
static_assert(alignof(ALOptionSystemData) == 0x000008, "Wrong alignment on ALOptionSystemData");
static_assert(sizeof(ALOptionSystemData) == 0x0004B0, "Wrong size on ALOptionSystemData");
static_assert(offsetof(ALOptionSystemData, Visual_RenderScale) == 0x0001E0, "Member 'ALOptionSystemData::Visual_RenderScale' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Viewdistance) == 0x0001E4, "Member 'ALOptionSystemData::Visual_Viewdistance' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Antialiasing) == 0x0001E8, "Member 'ALOptionSystemData::Visual_Antialiasing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Postprocess) == 0x0001EC, "Member 'ALOptionSystemData::Visual_Postprocess' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Shadow) == 0x0001F0, "Member 'ALOptionSystemData::Visual_Shadow' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Texture) == 0x0001F4, "Member 'ALOptionSystemData::Visual_Texture' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Effects) == 0x0001F8, "Member 'ALOptionSystemData::Visual_Effects' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Foliage) == 0x0001FC, "Member 'ALOptionSystemData::Visual_Foliage' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Shading) == 0x000200, "Member 'ALOptionSystemData::Visual_Shading' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Anisotropy) == 0x000204, "Member 'ALOptionSystemData::Visual_Anisotropy' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Atmosphere) == 0x000208, "Member 'ALOptionSystemData::Visual_Atmosphere' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_AmbientOcclusion) == 0x00020C, "Member 'ALOptionSystemData::Visual_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Reflection) == 0x000210, "Member 'ALOptionSystemData::Visual_Reflection' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_FSR) == 0x000214, "Member 'ALOptionSystemData::Visual_FSR' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_RayTracing) == 0x000218, "Member 'ALOptionSystemData::Visual_RayTracing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_FrameRate) == 0x00021C, "Member 'ALOptionSystemData::Visual_FrameRate' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_Resolution) == 0x000220, "Member 'ALOptionSystemData::Visual_Resolution' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_DynamicResMode) == 0x000224, "Member 'ALOptionSystemData::Visual_DynamicResMode' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_DynamicResMin) == 0x000228, "Member 'ALOptionSystemData::Visual_DynamicResMin' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_DynamicResMax) == 0x00022C, "Member 'ALOptionSystemData::Visual_DynamicResMax' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_DynamicResTimeUS) == 0x000230, "Member 'ALOptionSystemData::Visual_DynamicResTimeUS' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_RenderScale) == 0x000234, "Member 'ALOptionSystemData::HFR_RenderScale' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Viewdistance) == 0x000238, "Member 'ALOptionSystemData::HFR_Viewdistance' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Antialiasing) == 0x00023C, "Member 'ALOptionSystemData::HFR_Antialiasing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Postprocess) == 0x000240, "Member 'ALOptionSystemData::HFR_Postprocess' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Shadow) == 0x000244, "Member 'ALOptionSystemData::HFR_Shadow' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Texture) == 0x000248, "Member 'ALOptionSystemData::HFR_Texture' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Effects) == 0x00024C, "Member 'ALOptionSystemData::HFR_Effects' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Foliage) == 0x000250, "Member 'ALOptionSystemData::HFR_Foliage' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Shading) == 0x000254, "Member 'ALOptionSystemData::HFR_Shading' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Anisotropy) == 0x000258, "Member 'ALOptionSystemData::HFR_Anisotropy' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Atmosphere) == 0x00025C, "Member 'ALOptionSystemData::HFR_Atmosphere' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_AmbientOcclusion) == 0x000260, "Member 'ALOptionSystemData::HFR_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Reflection) == 0x000264, "Member 'ALOptionSystemData::HFR_Reflection' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_FSR) == 0x000268, "Member 'ALOptionSystemData::HFR_FSR' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_RayTracing) == 0x00026C, "Member 'ALOptionSystemData::HFR_RayTracing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_FrameRate) == 0x000270, "Member 'ALOptionSystemData::HFR_FrameRate' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_Resolution) == 0x000274, "Member 'ALOptionSystemData::HFR_Resolution' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_DynamicResMode) == 0x000278, "Member 'ALOptionSystemData::HFR_DynamicResMode' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_DynamicResMin) == 0x00027C, "Member 'ALOptionSystemData::HFR_DynamicResMin' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_DynamicResMax) == 0x000280, "Member 'ALOptionSystemData::HFR_DynamicResMax' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_DynamicResTimeUS) == 0x000284, "Member 'ALOptionSystemData::HFR_DynamicResTimeUS' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_RenderScale) == 0x000288, "Member 'ALOptionSystemData::Action_RenderScale' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Viewdistance) == 0x00028C, "Member 'ALOptionSystemData::Action_Viewdistance' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Antialiasing) == 0x000290, "Member 'ALOptionSystemData::Action_Antialiasing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Postprocess) == 0x000294, "Member 'ALOptionSystemData::Action_Postprocess' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Shadow) == 0x000298, "Member 'ALOptionSystemData::Action_Shadow' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Texture) == 0x00029C, "Member 'ALOptionSystemData::Action_Texture' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Effects) == 0x0002A0, "Member 'ALOptionSystemData::Action_Effects' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Foliage) == 0x0002A4, "Member 'ALOptionSystemData::Action_Foliage' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Shading) == 0x0002A8, "Member 'ALOptionSystemData::Action_Shading' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Anisotropy) == 0x0002AC, "Member 'ALOptionSystemData::Action_Anisotropy' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Atmosphere) == 0x0002B0, "Member 'ALOptionSystemData::Action_Atmosphere' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_AmbientOcclusion) == 0x0002B4, "Member 'ALOptionSystemData::Action_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Reflection) == 0x0002B8, "Member 'ALOptionSystemData::Action_Reflection' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_FSR) == 0x0002BC, "Member 'ALOptionSystemData::Action_FSR' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_RayTracing) == 0x0002C0, "Member 'ALOptionSystemData::Action_RayTracing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_FrameRate) == 0x0002C4, "Member 'ALOptionSystemData::Action_FrameRate' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_Resolution) == 0x0002C8, "Member 'ALOptionSystemData::Action_Resolution' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_DynamicResMode) == 0x0002CC, "Member 'ALOptionSystemData::Action_DynamicResMode' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_DynamicResMin) == 0x0002D0, "Member 'ALOptionSystemData::Action_DynamicResMin' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_DynamicResMax) == 0x0002D4, "Member 'ALOptionSystemData::Action_DynamicResMax' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_DynamicResTimeUS) == 0x0002D8, "Member 'ALOptionSystemData::Action_DynamicResTimeUS' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_RenderScale) == 0x0002DC, "Member 'ALOptionSystemData::Visual_2nd_RenderScale' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Viewdistance) == 0x0002E0, "Member 'ALOptionSystemData::Visual_2nd_Viewdistance' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Antialiasing) == 0x0002E4, "Member 'ALOptionSystemData::Visual_2nd_Antialiasing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Postprocess) == 0x0002E8, "Member 'ALOptionSystemData::Visual_2nd_Postprocess' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Shadow) == 0x0002EC, "Member 'ALOptionSystemData::Visual_2nd_Shadow' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Texture) == 0x0002F0, "Member 'ALOptionSystemData::Visual_2nd_Texture' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Effects) == 0x0002F4, "Member 'ALOptionSystemData::Visual_2nd_Effects' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Foliage) == 0x0002F8, "Member 'ALOptionSystemData::Visual_2nd_Foliage' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Shading) == 0x0002FC, "Member 'ALOptionSystemData::Visual_2nd_Shading' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Anisotropy) == 0x000300, "Member 'ALOptionSystemData::Visual_2nd_Anisotropy' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Atmosphere) == 0x000304, "Member 'ALOptionSystemData::Visual_2nd_Atmosphere' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_AmbientOcclusion) == 0x000308, "Member 'ALOptionSystemData::Visual_2nd_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Reflection) == 0x00030C, "Member 'ALOptionSystemData::Visual_2nd_Reflection' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_FSR) == 0x000310, "Member 'ALOptionSystemData::Visual_2nd_FSR' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_RayTracing) == 0x000314, "Member 'ALOptionSystemData::Visual_2nd_RayTracing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_FrameRate) == 0x000318, "Member 'ALOptionSystemData::Visual_2nd_FrameRate' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_Resolution) == 0x00031C, "Member 'ALOptionSystemData::Visual_2nd_Resolution' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_DynamicResMode) == 0x000320, "Member 'ALOptionSystemData::Visual_2nd_DynamicResMode' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_DynamicResMin) == 0x000324, "Member 'ALOptionSystemData::Visual_2nd_DynamicResMin' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_DynamicResMax) == 0x000328, "Member 'ALOptionSystemData::Visual_2nd_DynamicResMax' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Visual_2nd_DynamicResTimeUS) == 0x00032C, "Member 'ALOptionSystemData::Visual_2nd_DynamicResTimeUS' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_RenderScale) == 0x000330, "Member 'ALOptionSystemData::HFR_2nd_RenderScale' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Viewdistance) == 0x000334, "Member 'ALOptionSystemData::HFR_2nd_Viewdistance' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Antialiasing) == 0x000338, "Member 'ALOptionSystemData::HFR_2nd_Antialiasing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Postprocess) == 0x00033C, "Member 'ALOptionSystemData::HFR_2nd_Postprocess' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Shadow) == 0x000340, "Member 'ALOptionSystemData::HFR_2nd_Shadow' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Texture) == 0x000344, "Member 'ALOptionSystemData::HFR_2nd_Texture' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Effects) == 0x000348, "Member 'ALOptionSystemData::HFR_2nd_Effects' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Foliage) == 0x00034C, "Member 'ALOptionSystemData::HFR_2nd_Foliage' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Shading) == 0x000350, "Member 'ALOptionSystemData::HFR_2nd_Shading' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Anisotropy) == 0x000354, "Member 'ALOptionSystemData::HFR_2nd_Anisotropy' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Atmosphere) == 0x000358, "Member 'ALOptionSystemData::HFR_2nd_Atmosphere' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_AmbientOcclusion) == 0x00035C, "Member 'ALOptionSystemData::HFR_2nd_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Reflection) == 0x000360, "Member 'ALOptionSystemData::HFR_2nd_Reflection' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_FSR) == 0x000364, "Member 'ALOptionSystemData::HFR_2nd_FSR' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_RayTracing) == 0x000368, "Member 'ALOptionSystemData::HFR_2nd_RayTracing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_FrameRate) == 0x00036C, "Member 'ALOptionSystemData::HFR_2nd_FrameRate' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_Resolution) == 0x000370, "Member 'ALOptionSystemData::HFR_2nd_Resolution' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_DynamicResMode) == 0x000374, "Member 'ALOptionSystemData::HFR_2nd_DynamicResMode' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_DynamicResMin) == 0x000378, "Member 'ALOptionSystemData::HFR_2nd_DynamicResMin' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_DynamicResMax) == 0x00037C, "Member 'ALOptionSystemData::HFR_2nd_DynamicResMax' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, HFR_2nd_DynamicResTimeUS) == 0x000380, "Member 'ALOptionSystemData::HFR_2nd_DynamicResTimeUS' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_RenderScale) == 0x000384, "Member 'ALOptionSystemData::Action_2nd_RenderScale' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Viewdistance) == 0x000388, "Member 'ALOptionSystemData::Action_2nd_Viewdistance' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Antialiasing) == 0x00038C, "Member 'ALOptionSystemData::Action_2nd_Antialiasing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Postprocess) == 0x000390, "Member 'ALOptionSystemData::Action_2nd_Postprocess' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Shadow) == 0x000394, "Member 'ALOptionSystemData::Action_2nd_Shadow' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Texture) == 0x000398, "Member 'ALOptionSystemData::Action_2nd_Texture' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Effects) == 0x00039C, "Member 'ALOptionSystemData::Action_2nd_Effects' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Foliage) == 0x0003A0, "Member 'ALOptionSystemData::Action_2nd_Foliage' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Shading) == 0x0003A4, "Member 'ALOptionSystemData::Action_2nd_Shading' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Anisotropy) == 0x0003A8, "Member 'ALOptionSystemData::Action_2nd_Anisotropy' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Atmosphere) == 0x0003AC, "Member 'ALOptionSystemData::Action_2nd_Atmosphere' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_AmbientOcclusion) == 0x0003B0, "Member 'ALOptionSystemData::Action_2nd_AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Reflection) == 0x0003B4, "Member 'ALOptionSystemData::Action_2nd_Reflection' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_FSR) == 0x0003B8, "Member 'ALOptionSystemData::Action_2nd_FSR' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_RayTracing) == 0x0003BC, "Member 'ALOptionSystemData::Action_2nd_RayTracing' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_FrameRate) == 0x0003C0, "Member 'ALOptionSystemData::Action_2nd_FrameRate' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_Resolution) == 0x0003C4, "Member 'ALOptionSystemData::Action_2nd_Resolution' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_DynamicResMode) == 0x0003C8, "Member 'ALOptionSystemData::Action_2nd_DynamicResMode' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_DynamicResMin) == 0x0003CC, "Member 'ALOptionSystemData::Action_2nd_DynamicResMin' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_DynamicResMax) == 0x0003D0, "Member 'ALOptionSystemData::Action_2nd_DynamicResMax' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Action_2nd_DynamicResTimeUS) == 0x0003D4, "Member 'ALOptionSystemData::Action_2nd_DynamicResTimeUS' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_RenderScaleStep) == 0x0003D8, "Member 'ALOptionSystemData::Low_RenderScaleStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_ViewdistanceStep) == 0x0003DC, "Member 'ALOptionSystemData::Low_ViewdistanceStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_AntialiasingStep) == 0x0003E0, "Member 'ALOptionSystemData::Low_AntialiasingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_PostprocessStep) == 0x0003E4, "Member 'ALOptionSystemData::Low_PostprocessStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_ShadowStep) == 0x0003E8, "Member 'ALOptionSystemData::Low_ShadowStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_TextureStep) == 0x0003EC, "Member 'ALOptionSystemData::Low_TextureStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_EffectsStep) == 0x0003F0, "Member 'ALOptionSystemData::Low_EffectsStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_FoliageStep) == 0x0003F4, "Member 'ALOptionSystemData::Low_FoliageStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_ShadingStep) == 0x0003F8, "Member 'ALOptionSystemData::Low_ShadingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_AnisotropyStep) == 0x0003FC, "Member 'ALOptionSystemData::Low_AnisotropyStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_AtmosphereStep) == 0x000400, "Member 'ALOptionSystemData::Low_AtmosphereStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_AmbientOcclusionStep) == 0x000404, "Member 'ALOptionSystemData::Low_AmbientOcclusionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Low_ReflectionStep) == 0x000408, "Member 'ALOptionSystemData::Low_ReflectionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_RenderScaleStep) == 0x00040C, "Member 'ALOptionSystemData::Medium_RenderScaleStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_ViewdistanceStep) == 0x000410, "Member 'ALOptionSystemData::Medium_ViewdistanceStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_AntialiasingStep) == 0x000414, "Member 'ALOptionSystemData::Medium_AntialiasingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_PostprocessStep) == 0x000418, "Member 'ALOptionSystemData::Medium_PostprocessStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_ShadowStep) == 0x00041C, "Member 'ALOptionSystemData::Medium_ShadowStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_TextureStep) == 0x000420, "Member 'ALOptionSystemData::Medium_TextureStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_EffectsStep) == 0x000424, "Member 'ALOptionSystemData::Medium_EffectsStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_FoliageStep) == 0x000428, "Member 'ALOptionSystemData::Medium_FoliageStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_ShadingStep) == 0x00042C, "Member 'ALOptionSystemData::Medium_ShadingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_AnisotropyStep) == 0x000430, "Member 'ALOptionSystemData::Medium_AnisotropyStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_AtmosphereStep) == 0x000434, "Member 'ALOptionSystemData::Medium_AtmosphereStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_AmbientOcclusionStep) == 0x000438, "Member 'ALOptionSystemData::Medium_AmbientOcclusionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Medium_ReflectionStep) == 0x00043C, "Member 'ALOptionSystemData::Medium_ReflectionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_RenderScaleStep) == 0x000440, "Member 'ALOptionSystemData::High_RenderScaleStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_ViewdistanceStep) == 0x000444, "Member 'ALOptionSystemData::High_ViewdistanceStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_AntialiasingStep) == 0x000448, "Member 'ALOptionSystemData::High_AntialiasingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_PostprocessStep) == 0x00044C, "Member 'ALOptionSystemData::High_PostprocessStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_ShadowStep) == 0x000450, "Member 'ALOptionSystemData::High_ShadowStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_TextureStep) == 0x000454, "Member 'ALOptionSystemData::High_TextureStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_EffectsStep) == 0x000458, "Member 'ALOptionSystemData::High_EffectsStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_FoliageStep) == 0x00045C, "Member 'ALOptionSystemData::High_FoliageStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_ShadingStep) == 0x000460, "Member 'ALOptionSystemData::High_ShadingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_AnisotropyStep) == 0x000464, "Member 'ALOptionSystemData::High_AnisotropyStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_AtmosphereStep) == 0x000468, "Member 'ALOptionSystemData::High_AtmosphereStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_AmbientOcclusionStep) == 0x00046C, "Member 'ALOptionSystemData::High_AmbientOcclusionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, High_ReflectionStep) == 0x000470, "Member 'ALOptionSystemData::High_ReflectionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_RenderScaleStep) == 0x000474, "Member 'ALOptionSystemData::Epic_RenderScaleStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_ViewdistanceStep) == 0x000478, "Member 'ALOptionSystemData::Epic_ViewdistanceStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_AntialiasingStep) == 0x00047C, "Member 'ALOptionSystemData::Epic_AntialiasingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_PostprocessStep) == 0x000480, "Member 'ALOptionSystemData::Epic_PostprocessStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_ShadowStep) == 0x000484, "Member 'ALOptionSystemData::Epic_ShadowStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_TextureStep) == 0x000488, "Member 'ALOptionSystemData::Epic_TextureStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_EffectsStep) == 0x00048C, "Member 'ALOptionSystemData::Epic_EffectsStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_FoliageStep) == 0x000490, "Member 'ALOptionSystemData::Epic_FoliageStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_ShadingStep) == 0x000494, "Member 'ALOptionSystemData::Epic_ShadingStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_AnisotropyStep) == 0x000498, "Member 'ALOptionSystemData::Epic_AnisotropyStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_AtmosphereStep) == 0x00049C, "Member 'ALOptionSystemData::Epic_AtmosphereStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_AmbientOcclusionStep) == 0x0004A0, "Member 'ALOptionSystemData::Epic_AmbientOcclusionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, Epic_ReflectionStep) == 0x0004A4, "Member 'ALOptionSystemData::Epic_ReflectionStep' has a wrong offset!");
static_assert(offsetof(ALOptionSystemData, MinimumAspectRatio) == 0x0004A8, "Member 'ALOptionSystemData::MinimumAspectRatio' has a wrong offset!");

// Class ProjectP.LAnimNotify_Teleport
// 0x0018 (0x0060 - 0x0048)
class ULAnimNotify_Teleport final : public ULAnimNotifyBase
{
public:
	ELAITargetType                                LocationTargetType;                                // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x004A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         Distance;                                          // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Angle;                                             // 0x0054(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDissolveEffectEnabled;                            // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_Teleport">();
	}
	static class ULAnimNotify_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_Teleport>();
	}
};
static_assert(alignof(ULAnimNotify_Teleport) == 0x000008, "Wrong alignment on ULAnimNotify_Teleport");
static_assert(sizeof(ULAnimNotify_Teleport) == 0x000060, "Wrong size on ULAnimNotify_Teleport");
static_assert(offsetof(ULAnimNotify_Teleport, LocationTargetType) == 0x000048, "Member 'ULAnimNotify_Teleport::LocationTargetType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Teleport, TargetType) == 0x000049, "Member 'ULAnimNotify_Teleport::TargetType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Teleport, DirectionType) == 0x00004A, "Member 'ULAnimNotify_Teleport::DirectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Teleport, Distance) == 0x00004C, "Member 'ULAnimNotify_Teleport::Distance' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Teleport, Angle) == 0x000054, "Member 'ULAnimNotify_Teleport::Angle' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_Teleport, bDissolveEffectEnabled) == 0x00005C, "Member 'ULAnimNotify_Teleport::bDissolveEffectEnabled' has a wrong offset!");

// Class ProjectP.LWeaponItem
// 0x0048 (0x00F0 - 0x00A8)
class ULWeaponItem : public ULItem
{
public:
	struct FLWeaponPart                           BladePart;                                         // 0x00A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHeroicWeapon;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SharpnessPoint;                                    // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELBladeSharpnessType                          SharpnessType;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GrindCount;                                        // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SharpnessRecoverRatio;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeCorrectionHandle(ELStatCorrectChangeType Type);
	void ConsumeSharpness(int32 InConsumePoint, bool CanBreakWeapon, bool* bIsConsumed, class ALWeapon* TargetWeaponActor);
	class FName GetSharpnessAbnormalStateCodeName(ELBladeSharpnessType Type);
	float GetSharpnessDamageRatio(ELBladeSharpnessType Type);
	float GetSharpnessDestructionRatio(ELBladeSharpnessType Type);
	int32 GetSharpnessRepulseLevel();
	bool IsOnHand();
	bool ReinforceBlade();
	void RestoreSharpness(int32 InPoint, bool IsGrinding);
	void SetHeroicWeapon(bool bHeroic);
	void SetSharpnessPoint(int32 InSharpnessPoint, bool IsGrinding);

	bool CanChangeCorrectionHandle(ELStatCorrectChangeType Type) const;
	bool CanReinforceBlade() const;
	class FName GetBladeCodeName() const;
	struct FItemCommonInfoPtr GetBladeCommonInfo() const;
	TSoftObjectPtr<class UObject> GetBladeImageResource() const;
	struct FItemBladeInfoPtr GetBladeInfo() const;
	struct FItemWeaponReinforceInfoPtr GetBladeReinforceInfo() const;
	int32 GetBladeStat(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat) const;
	int32 GetBladeStatBonus(class AActor* InOwner, ELSecondStat InStat, bool WillReinforceDiffStat) const;
	int32 GetCurrentSharpnessPoint() const;
	ELBladeSharpnessType GetCurrentSharpnessType() const;
	struct FHandleStatCorrectionChangeInfoPtr GetHandleChangeCorrectionInfo(ELStatCorrectChangeType Type) const;
	ELStatCorrectChangeType GetHandleChangedCorrectionType() const;
	class FName GetHandleCodeName() const;
	struct FItemCommonInfoPtr GetHandleCommonInfo() const;
	ELHandleCorrectResultGrade GetHandleCorrectionGrade(ELFirstStat Type, ELStatCorrectChangeType WillBeChangeCorrection, int32* OutStackLevel) const;
	TSoftObjectPtr<class UObject> GetHandleImageResource() const;
	struct FItemHandleInfoPtr GetHandleInfo() const;
	int32 GetHandleStat(class AActor* InOwner, ELSecondStat InStat) const;
	int32 GetHandleStatBonus(class AActor* InOwner, ELSecondStat InStat) const;
	TSoftObjectPtr<class UObject> GetHeroicImageResource() const;
	int32 GetNecessityFirstStat(ELFirstStat InStat) const;
	struct FItemWeaponReinforceInfoPtr GetNextBladeReinforceInfo() const;
	int32 GetRawBladeStat(ELSecondStat InStat, bool WillReinforceDiffStat) const;
	int32 GetRawHandleStat(ELSecondStat InStat) const;
	void GetSeparatedWeaponParts(class ULItem** OutHandleItem, class ULItem** OutBladeItem) const;
	float GetSharpnessRecoverRatio() const;
	ELElementDamageType GetWeaponElementalType() const;
	class FText GetWeaponName() const;
	bool HasBlade() const;
	bool IsChangedCorrectionHandle() const;
	bool IsHeroicWeapon() const;
	bool IsOriginalWeapon() const;
	bool IsReinforcedBlade() const;
	bool IsSharpnessMax() const;
	TArray<class ULItem*> SeparateWeaponPart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponItem">();
	}
	static class ULWeaponItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWeaponItem>();
	}
};
static_assert(alignof(ULWeaponItem) == 0x000008, "Wrong alignment on ULWeaponItem");
static_assert(sizeof(ULWeaponItem) == 0x0000F0, "Wrong size on ULWeaponItem");
static_assert(offsetof(ULWeaponItem, BladePart) == 0x0000A8, "Member 'ULWeaponItem::BladePart' has a wrong offset!");
static_assert(offsetof(ULWeaponItem, bHeroicWeapon) == 0x0000D8, "Member 'ULWeaponItem::bHeroicWeapon' has a wrong offset!");
static_assert(offsetof(ULWeaponItem, SharpnessPoint) == 0x0000DC, "Member 'ULWeaponItem::SharpnessPoint' has a wrong offset!");
static_assert(offsetof(ULWeaponItem, SharpnessType) == 0x0000E0, "Member 'ULWeaponItem::SharpnessType' has a wrong offset!");
static_assert(offsetof(ULWeaponItem, GrindCount) == 0x0000E4, "Member 'ULWeaponItem::GrindCount' has a wrong offset!");
static_assert(offsetof(ULWeaponItem, SharpnessRecoverRatio) == 0x0000E8, "Member 'ULWeaponItem::SharpnessRecoverRatio' has a wrong offset!");

// Class ProjectP.LHeroicTransformWeaponItem
// 0x0000 (0x00F0 - 0x00F0)
class ULHeroicTransformWeaponItem final : public ULWeaponItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHeroicTransformWeaponItem">();
	}
	static class ULHeroicTransformWeaponItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHeroicTransformWeaponItem>();
	}
};
static_assert(alignof(ULHeroicTransformWeaponItem) == 0x000008, "Wrong alignment on ULHeroicTransformWeaponItem");
static_assert(sizeof(ULHeroicTransformWeaponItem) == 0x0000F0, "Wrong size on ULHeroicTransformWeaponItem");

// Class ProjectP.LAnimNotify_TeleportTimed
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotify_TeleportTimed final : public ULAnimNotifyStateBase
{
public:
	ELAITargetType                                LocationTargetType;                                // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAITargetType                                TargetType;                                        // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDirectionType                             DirectionType;                                     // 0x0042(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         Distance;                                          // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         Angle;                                             // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDissolveEffectEnabled;                            // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_TeleportTimed">();
	}
	static class ULAnimNotify_TeleportTimed* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_TeleportTimed>();
	}
};
static_assert(alignof(ULAnimNotify_TeleportTimed) == 0x000008, "Wrong alignment on ULAnimNotify_TeleportTimed");
static_assert(sizeof(ULAnimNotify_TeleportTimed) == 0x000058, "Wrong size on ULAnimNotify_TeleportTimed");
static_assert(offsetof(ULAnimNotify_TeleportTimed, LocationTargetType) == 0x000040, "Member 'ULAnimNotify_TeleportTimed::LocationTargetType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_TeleportTimed, TargetType) == 0x000041, "Member 'ULAnimNotify_TeleportTimed::TargetType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_TeleportTimed, DirectionType) == 0x000042, "Member 'ULAnimNotify_TeleportTimed::DirectionType' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_TeleportTimed, Distance) == 0x000044, "Member 'ULAnimNotify_TeleportTimed::Distance' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_TeleportTimed, Angle) == 0x00004C, "Member 'ULAnimNotify_TeleportTimed::Angle' has a wrong offset!");
static_assert(offsetof(ULAnimNotify_TeleportTimed, bDissolveEffectEnabled) == 0x000054, "Member 'ULAnimNotify_TeleportTimed::bDissolveEffectEnabled' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_RecieveToughGroggyRate
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_RecieveToughGroggyRate final : public ULAnimNotifyStateBase
{
public:
	uint8                                         Tough : 1;                                         // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ToughRate;                                         // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Groggy : 1;                                        // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroggyRate;                                        // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_RecieveToughGroggyRate">();
	}
	static class ULAnimNotifyState_RecieveToughGroggyRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_RecieveToughGroggyRate>();
	}
};
static_assert(alignof(ULAnimNotifyState_RecieveToughGroggyRate) == 0x000008, "Wrong alignment on ULAnimNotifyState_RecieveToughGroggyRate");
static_assert(sizeof(ULAnimNotifyState_RecieveToughGroggyRate) == 0x000050, "Wrong size on ULAnimNotifyState_RecieveToughGroggyRate");
static_assert(offsetof(ULAnimNotifyState_RecieveToughGroggyRate, ToughRate) == 0x000044, "Member 'ULAnimNotifyState_RecieveToughGroggyRate::ToughRate' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_RecieveToughGroggyRate, GroggyRate) == 0x00004C, "Member 'ULAnimNotifyState_RecieveToughGroggyRate::GroggyRate' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_GrappleGun_Reflect
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_GrappleGun_Reflect final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_GrappleGun_Reflect">();
	}
	static class ULAnimNotifyState_GrappleGun_Reflect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_GrappleGun_Reflect>();
	}
};
static_assert(alignof(ULAnimNotifyState_GrappleGun_Reflect) == 0x000008, "Wrong alignment on ULAnimNotifyState_GrappleGun_Reflect");
static_assert(sizeof(ULAnimNotifyState_GrappleGun_Reflect) == 0x000040, "Wrong size on ULAnimNotifyState_GrappleGun_Reflect");

// Class ProjectP.LSubOption
// 0x0020 (0x0048 - 0x0028)
class ULSubOption : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALOptionSystemData*                     SystemData;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULOptionSaveGame*                       SaveGame;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ResetToDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSubOption">();
	}
	static class ULSubOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSubOption>();
	}
};
static_assert(alignof(ULSubOption) == 0x000008, "Wrong alignment on ULSubOption");
static_assert(sizeof(ULSubOption) == 0x000048, "Wrong size on ULSubOption");
static_assert(offsetof(ULSubOption, SystemData) == 0x000030, "Member 'ULSubOption::SystemData' has a wrong offset!");
static_assert(offsetof(ULSubOption, SaveGame) == 0x000038, "Member 'ULSubOption::SaveGame' has a wrong offset!");

// Class ProjectP.LDispalySoundOption
// 0x0050 (0x0098 - 0x0048)
class ULDispalySoundOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplySoundOptionMultiply(ELVolumeType InType, float InValue);
	int32 GetVolumeStep(ELVolumeType InType);
	bool SetVolumeStep(ELVolumeType InType, int32 InStep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDispalySoundOption">();
	}
	static class ULDispalySoundOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDispalySoundOption>();
	}
};
static_assert(alignof(ULDispalySoundOption) == 0x000008, "Wrong alignment on ULDispalySoundOption");
static_assert(sizeof(ULDispalySoundOption) == 0x000098, "Wrong size on ULDispalySoundOption");

// Class ProjectP.LAnimNotifyState_DistanceRootMotionScaling
// 0x0018 (0x0058 - 0x0040)
class ULAnimNotifyState_DistanceRootMotionScaling final : public ULAnimNotifyStateBase
{
public:
	ELAnimRootMotionScaleOperationType            OperationType;                                     // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scaling_Min;                                       // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scaling_Max;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootMotion_Distance;                               // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset_Distance_From_Taget;                        // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DistanceRootMotionScaling">();
	}
	static class ULAnimNotifyState_DistanceRootMotionScaling* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DistanceRootMotionScaling>();
	}
};
static_assert(alignof(ULAnimNotifyState_DistanceRootMotionScaling) == 0x000008, "Wrong alignment on ULAnimNotifyState_DistanceRootMotionScaling");
static_assert(sizeof(ULAnimNotifyState_DistanceRootMotionScaling) == 0x000058, "Wrong size on ULAnimNotifyState_DistanceRootMotionScaling");
static_assert(offsetof(ULAnimNotifyState_DistanceRootMotionScaling, OperationType) == 0x000040, "Member 'ULAnimNotifyState_DistanceRootMotionScaling::OperationType' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_DistanceRootMotionScaling, Scaling_Min) == 0x000044, "Member 'ULAnimNotifyState_DistanceRootMotionScaling::Scaling_Min' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_DistanceRootMotionScaling, Scaling_Max) == 0x000048, "Member 'ULAnimNotifyState_DistanceRootMotionScaling::Scaling_Max' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_DistanceRootMotionScaling, RootMotion_Distance) == 0x00004C, "Member 'ULAnimNotifyState_DistanceRootMotionScaling::RootMotion_Distance' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_DistanceRootMotionScaling, Offset_Distance_From_Taget) == 0x000050, "Member 'ULAnimNotifyState_DistanceRootMotionScaling::Offset_Distance_From_Taget' has a wrong offset!");

// Class ProjectP.LInteractComponent
// 0x0050 (0x0240 - 0x01F0)
class ULInteractComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLInteractionInfo>              InteractionInfoList;                               // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPrimitiveComponent>     UserInteractedComp;                                // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELInteractResult                              DialogInteractResult;                              // 0x0208(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x17];                                     // 0x0209(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULInteractSphereComponent> InteractComp_ByVolume;                             // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTriggerInteract;                                 // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void OnCloseDialog();
	void OnComponentBeginOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentBeginOverlapped_InteractVolume(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentBeginOverlapped_LookAt(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentBeginOverlapped_Radius(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentEndOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnComponentEndOverlapped_InteractVolume(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnComponentEndOverlapped_LookAt(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnComponentEndOverlapped_Radius(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnOpenDialog();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractComponent">();
	}
	static class ULInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInteractComponent>();
	}
};
static_assert(alignof(ULInteractComponent) == 0x000010, "Wrong alignment on ULInteractComponent");
static_assert(sizeof(ULInteractComponent) == 0x000240, "Wrong size on ULInteractComponent");
static_assert(offsetof(ULInteractComponent, InteractionInfoList) == 0x0001F0, "Member 'ULInteractComponent::InteractionInfoList' has a wrong offset!");
static_assert(offsetof(ULInteractComponent, UserInteractedComp) == 0x000200, "Member 'ULInteractComponent::UserInteractedComp' has a wrong offset!");
static_assert(offsetof(ULInteractComponent, DialogInteractResult) == 0x000208, "Member 'ULInteractComponent::DialogInteractResult' has a wrong offset!");
static_assert(offsetof(ULInteractComponent, InteractComp_ByVolume) == 0x000220, "Member 'ULInteractComponent::InteractComp_ByVolume' has a wrong offset!");
static_assert(offsetof(ULInteractComponent, OnTriggerInteract) == 0x000230, "Member 'ULInteractComponent::OnTriggerInteract' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_DropWeapon
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_DropWeapon final : public ULAnimNotifyStateBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_DropWeapon">();
	}
	static class ULAnimNotifyState_DropWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_DropWeapon>();
	}
};
static_assert(alignof(ULAnimNotifyState_DropWeapon) == 0x000008, "Wrong alignment on ULAnimNotifyState_DropWeapon");
static_assert(sizeof(ULAnimNotifyState_DropWeapon) == 0x000048, "Wrong size on ULAnimNotifyState_DropWeapon");
static_assert(offsetof(ULAnimNotifyState_DropWeapon, WeaponAttachPointType) == 0x000040, "Member 'ULAnimNotifyState_DropWeapon::WeaponAttachPointType' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Repulse
// 0x0020 (0x0060 - 0x0040)
class ULAnimNotifyState_Repulse final : public ULAnimNotifyStateBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPoint;                                 // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocket;                                  // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocket;                                    // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSphereRadius;                                 // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Material;                                          // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Repulse">();
	}
	static class ULAnimNotifyState_Repulse* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Repulse>();
	}
};
static_assert(alignof(ULAnimNotifyState_Repulse) == 0x000008, "Wrong alignment on ULAnimNotifyState_Repulse");
static_assert(sizeof(ULAnimNotifyState_Repulse) == 0x000060, "Wrong size on ULAnimNotifyState_Repulse");
static_assert(offsetof(ULAnimNotifyState_Repulse, WeaponAttachPoint) == 0x000040, "Member 'ULAnimNotifyState_Repulse::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Repulse, TraceStartSocket) == 0x000044, "Member 'ULAnimNotifyState_Repulse::TraceStartSocket' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Repulse, TraceEndSocket) == 0x00004C, "Member 'ULAnimNotifyState_Repulse::TraceEndSocket' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Repulse, TraceSphereRadius) == 0x000054, "Member 'ULAnimNotifyState_Repulse::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Repulse, LifeSpan) == 0x000058, "Member 'ULAnimNotifyState_Repulse::LifeSpan' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Repulse, Material) == 0x00005C, "Member 'ULAnimNotifyState_Repulse::Material' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Spark
// 0x0020 (0x0060 - 0x0040)
class ULAnimNotifyState_Spark final : public ULAnimNotifyStateBase
{
public:
	ELWeaponAttachPointType                       WeaponAttachPoint;                                 // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocket;                                  // 0x0044(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocket;                                    // 0x004C(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSphereRadius;                                 // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Material;                                          // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Spark">();
	}
	static class ULAnimNotifyState_Spark* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Spark>();
	}
};
static_assert(alignof(ULAnimNotifyState_Spark) == 0x000008, "Wrong alignment on ULAnimNotifyState_Spark");
static_assert(sizeof(ULAnimNotifyState_Spark) == 0x000060, "Wrong size on ULAnimNotifyState_Spark");
static_assert(offsetof(ULAnimNotifyState_Spark, WeaponAttachPoint) == 0x000040, "Member 'ULAnimNotifyState_Spark::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Spark, TraceStartSocket) == 0x000044, "Member 'ULAnimNotifyState_Spark::TraceStartSocket' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Spark, TraceEndSocket) == 0x00004C, "Member 'ULAnimNotifyState_Spark::TraceEndSocket' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Spark, TraceSphereRadius) == 0x000054, "Member 'ULAnimNotifyState_Spark::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Spark, LifeSpan) == 0x000058, "Member 'ULAnimNotifyState_Spark::LifeSpan' has a wrong offset!");
static_assert(offsetof(ULAnimNotifyState_Spark, Material) == 0x00005C, "Member 'ULAnimNotifyState_Spark::Material' has a wrong offset!");

// Class ProjectP.LKeySettingOption
// 0x0070 (0x00B8 - 0x0048)
class ULKeySettingOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x70];                                      // 0x0048(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBackupCustomizedInputInfo(ELInputOptionType InControllerType);
	bool ApplyCustomizedInput(ELInputOptionType InControllerType);
	bool ChangeInputKey(class FName InputAction, const struct FKey& Key);
	ELPCActionKeyType FindPresetInputAction(class FName InPresetName, const struct FKey& Key);
	struct FKey FindPresetInputActionKey(class FName InPresetName, ELPCActionKeyType KeyType);
	class FName GetCurrentPresetName(bool IsGamePad);
	TArray<class FName> GetSelectablePresetNames(bool IsGamePad);
	void OnClosedWindow(class FName WidgetTableName);
	void SetBackupCustomizedInputInfo();
	bool SetChangePreset(class FName InPresetName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LKeySettingOption">();
	}
	static class ULKeySettingOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULKeySettingOption>();
	}
};
static_assert(alignof(ULKeySettingOption) == 0x000008, "Wrong alignment on ULKeySettingOption");
static_assert(sizeof(ULKeySettingOption) == 0x0000B8, "Wrong size on ULKeySettingOption");

// Class ProjectP.LAnimNotifyState_RepairWeapon
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_RepairWeapon final : public ULAnimNotifyStateBase
{
public:
	float                                         SharpnessRecoverRatio;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_RepairWeapon">();
	}
	static class ULAnimNotifyState_RepairWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_RepairWeapon>();
	}
};
static_assert(alignof(ULAnimNotifyState_RepairWeapon) == 0x000008, "Wrong alignment on ULAnimNotifyState_RepairWeapon");
static_assert(sizeof(ULAnimNotifyState_RepairWeapon) == 0x000048, "Wrong size on ULAnimNotifyState_RepairWeapon");
static_assert(offsetof(ULAnimNotifyState_RepairWeapon, SharpnessRecoverRatio) == 0x000040, "Member 'ULAnimNotifyState_RepairWeapon::SharpnessRecoverRatio' has a wrong offset!");

// Class ProjectP.LKillZoneVolume
// 0x0028 (0x0260 - 0x0238)
class ALKillZoneVolume final : public ALVolume
{
public:
	ELKillZoneType                                KillZoneType;                                      // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraSequenceStartDelay;                          // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraUpperPosition;                              // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CameraSequencePlayTimer;                           // 0x0248(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomDieUIShowTime;                           // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DieUI_StartDelay;                                  // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALLocationActor*                        ErgoDropLocation;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LKillZoneVolume">();
	}
	static class ALKillZoneVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALKillZoneVolume>();
	}
};
static_assert(alignof(ALKillZoneVolume) == 0x000008, "Wrong alignment on ALKillZoneVolume");
static_assert(sizeof(ALKillZoneVolume) == 0x000260, "Wrong size on ALKillZoneVolume");
static_assert(offsetof(ALKillZoneVolume, KillZoneType) == 0x000238, "Member 'ALKillZoneVolume::KillZoneType' has a wrong offset!");
static_assert(offsetof(ALKillZoneVolume, CameraSequenceStartDelay) == 0x00023C, "Member 'ALKillZoneVolume::CameraSequenceStartDelay' has a wrong offset!");
static_assert(offsetof(ALKillZoneVolume, bCameraUpperPosition) == 0x000240, "Member 'ALKillZoneVolume::bCameraUpperPosition' has a wrong offset!");
static_assert(offsetof(ALKillZoneVolume, CameraSequencePlayTimer) == 0x000248, "Member 'ALKillZoneVolume::CameraSequencePlayTimer' has a wrong offset!");
static_assert(offsetof(ALKillZoneVolume, bUseCustomDieUIShowTime) == 0x000250, "Member 'ALKillZoneVolume::bUseCustomDieUIShowTime' has a wrong offset!");
static_assert(offsetof(ALKillZoneVolume, DieUI_StartDelay) == 0x000254, "Member 'ALKillZoneVolume::DieUI_StartDelay' has a wrong offset!");
static_assert(offsetof(ALKillZoneVolume, ErgoDropLocation) == 0x000258, "Member 'ALKillZoneVolume::ErgoDropLocation' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_FallingSpeedRate
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_FallingSpeedRate final : public ULAnimNotifyStateBase
{
public:
	float                                         FallingSpeedRate;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_FallingSpeedRate">();
	}
	static class ULAnimNotifyState_FallingSpeedRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_FallingSpeedRate>();
	}
};
static_assert(alignof(ULAnimNotifyState_FallingSpeedRate) == 0x000008, "Wrong alignment on ULAnimNotifyState_FallingSpeedRate");
static_assert(sizeof(ULAnimNotifyState_FallingSpeedRate) == 0x000048, "Wrong size on ULAnimNotifyState_FallingSpeedRate");
static_assert(offsetof(ULAnimNotifyState_FallingSpeedRate, FallingSpeedRate) == 0x000040, "Member 'ULAnimNotifyState_FallingSpeedRate::FallingSpeedRate' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_Fatal_Counter_Signal
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_Fatal_Counter_Signal final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Fatal_Counter_Signal">();
	}
	static class ULAnimNotifyState_Fatal_Counter_Signal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Fatal_Counter_Signal>();
	}
};
static_assert(alignof(ULAnimNotifyState_Fatal_Counter_Signal) == 0x000008, "Wrong alignment on ULAnimNotifyState_Fatal_Counter_Signal");
static_assert(sizeof(ULAnimNotifyState_Fatal_Counter_Signal) == 0x000040, "Wrong size on ULAnimNotifyState_Fatal_Counter_Signal");

// Class ProjectP.LAnimNotifyState_Fatal_Counter_Enable
// 0x0008 (0x0048 - 0x0040)
class ULAnimNotifyState_Fatal_Counter_Enable final : public ULAnimNotifyStateBase
{
public:
	uint8                                         Tough : 1;                                         // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_Fatal_Counter_Enable">();
	}
	static class ULAnimNotifyState_Fatal_Counter_Enable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_Fatal_Counter_Enable>();
	}
};
static_assert(alignof(ULAnimNotifyState_Fatal_Counter_Enable) == 0x000008, "Wrong alignment on ULAnimNotifyState_Fatal_Counter_Enable");
static_assert(sizeof(ULAnimNotifyState_Fatal_Counter_Enable) == 0x000048, "Wrong size on ULAnimNotifyState_Fatal_Counter_Enable");

// Class ProjectP.LPartsActor
// 0x0068 (0x0248 - 0x01E0)
class ALPartsActor final : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDropPrimitive>                DropPrimitives;                                    // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLHiddenComplex                        HiddenComplex;                                     // 0x01F8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void BoneMerging();
	void BoneMergingSkeletalMesh(class USkeletalMeshComponent* Component);
	void DropParts(const struct FVector& LastImpulseDirection);
	TArray<class UMeshComponent*> FindDropMeshes();
	class ALCharacter* GetOwnerCharacter();
	class USkeletalMeshComponent* GetPartsAttachParent();
	class ULPartsComponent* GetPartsComponent();
	void OnChangeNextDestructState();
	void OnPartsDestroyed();
	void OnRespawn();
	void PartsActivate();
	void PartsDeactivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPartsActor">();
	}
	static class ALPartsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPartsActor>();
	}
};
static_assert(alignof(ALPartsActor) == 0x000008, "Wrong alignment on ALPartsActor");
static_assert(sizeof(ALPartsActor) == 0x000248, "Wrong size on ALPartsActor");
static_assert(offsetof(ALPartsActor, DropPrimitives) == 0x0001E8, "Member 'ALPartsActor::DropPrimitives' has a wrong offset!");
static_assert(offsetof(ALPartsActor, HiddenComplex) == 0x0001F8, "Member 'ALPartsActor::HiddenComplex' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_JumpTargetSet
// 0x0000 (0x0040 - 0x0040)
class ULAnimNotifyState_JumpTargetSet final : public ULAnimNotifyStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_JumpTargetSet">();
	}
	static class ULAnimNotifyState_JumpTargetSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_JumpTargetSet>();
	}
};
static_assert(alignof(ULAnimNotifyState_JumpTargetSet) == 0x000008, "Wrong alignment on ULAnimNotifyState_JumpTargetSet");
static_assert(sizeof(ULAnimNotifyState_JumpTargetSet) == 0x000040, "Wrong size on ULAnimNotifyState_JumpTargetSet");

// Class ProjectP.LInteractSystem
// 0x00D0 (0x0148 - 0x0078)
class ULInteractSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRefreshDialogForDebug;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishDialog;                                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDialogExit;                                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class ULDialogControl*                        ActiveDialog;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULMonologControl*                       ActiveMonolog;                                     // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULDialogDB*                             DialogDB;                                          // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OpenedUIByDialog;                                  // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULDialogDebugInfo*                      DebugResult;                                       // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInInteractVolume;                                // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer_NeedWaitBeforeUI;                            // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsBlockedDialog;                                   // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0xB];                                      // 0x0131(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Selected_SophiaLevelUpMotion;                      // 0x013C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Dev_InteractStartTransform();
	class ULDialogDebugInfo* GetDialogDebugInfo();
	class AActor* GetLastDialogingActor();
	void OnBlockDialog(bool InBlock);
	void OnClosedDialog(class FName WidgetTableName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractSystem">();
	}
	static class ULInteractSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInteractSystem>();
	}
};
static_assert(alignof(ULInteractSystem) == 0x000008, "Wrong alignment on ULInteractSystem");
static_assert(sizeof(ULInteractSystem) == 0x000148, "Wrong size on ULInteractSystem");
static_assert(offsetof(ULInteractSystem, OnRefreshDialogForDebug) == 0x0000A8, "Member 'ULInteractSystem::OnRefreshDialogForDebug' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, OnFinishDialog) == 0x0000B8, "Member 'ULInteractSystem::OnFinishDialog' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, OnDialogExit) == 0x0000C8, "Member 'ULInteractSystem::OnDialogExit' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, ActiveDialog) == 0x0000D8, "Member 'ULInteractSystem::ActiveDialog' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, ActiveMonolog) == 0x0000E0, "Member 'ULInteractSystem::ActiveMonolog' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, DialogDB) == 0x0000E8, "Member 'ULInteractSystem::DialogDB' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, OpenedUIByDialog) == 0x0000F8, "Member 'ULInteractSystem::OpenedUIByDialog' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, DebugResult) == 0x000100, "Member 'ULInteractSystem::DebugResult' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, IsInInteractVolume) == 0x000108, "Member 'ULInteractSystem::IsInInteractVolume' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, Timer_NeedWaitBeforeUI) == 0x00010C, "Member 'ULInteractSystem::Timer_NeedWaitBeforeUI' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, IsBlockedDialog) == 0x000130, "Member 'ULInteractSystem::IsBlockedDialog' has a wrong offset!");
static_assert(offsetof(ULInteractSystem, Selected_SophiaLevelUpMotion) == 0x00013C, "Member 'ULInteractSystem::Selected_SophiaLevelUpMotion' has a wrong offset!");

// Class ProjectP.LAnimNotifyState_QstReceiveCallback
// 0x0010 (0x0050 - 0x0040)
class ULAnimNotifyState_QstReceiveCallback final : public ULAnimNotifyStateBase
{
public:
	TArray<class FString>                         NotifyCodeNameList;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyState_QstReceiveCallback">();
	}
	static class ULAnimNotifyState_QstReceiveCallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotifyState_QstReceiveCallback>();
	}
};
static_assert(alignof(ULAnimNotifyState_QstReceiveCallback) == 0x000008, "Wrong alignment on ULAnimNotifyState_QstReceiveCallback");
static_assert(sizeof(ULAnimNotifyState_QstReceiveCallback) == 0x000050, "Wrong size on ULAnimNotifyState_QstReceiveCallback");
static_assert(offsetof(ULAnimNotifyState_QstReceiveCallback, NotifyCodeNameList) == 0x000040, "Member 'ULAnimNotifyState_QstReceiveCallback::NotifyCodeNameList' has a wrong offset!");

// Class ProjectP.LAnimNotify_InvincibleForDirecting
// 0x0008 (0x0050 - 0x0048)
class ULAnimNotify_InvincibleForDirecting final : public ULAnimNotifyBase
{
public:
	bool                                          ActiveFlag;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_InvincibleForDirecting">();
	}
	static class ULAnimNotify_InvincibleForDirecting* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_InvincibleForDirecting>();
	}
};
static_assert(alignof(ULAnimNotify_InvincibleForDirecting) == 0x000008, "Wrong alignment on ULAnimNotify_InvincibleForDirecting");
static_assert(sizeof(ULAnimNotify_InvincibleForDirecting) == 0x000050, "Wrong size on ULAnimNotify_InvincibleForDirecting");
static_assert(offsetof(ULAnimNotify_InvincibleForDirecting, ActiveFlag) == 0x000048, "Member 'ULAnimNotify_InvincibleForDirecting::ActiveFlag' has a wrong offset!");

// Class ProjectP.LAnimNotify_RemoveAllAbnormal
// 0x0000 (0x0048 - 0x0048)
class ULAnimNotify_RemoveAllAbnormal final : public ULAnimNotifyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotify_RemoveAllAbnormal">();
	}
	static class ULAnimNotify_RemoveAllAbnormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAnimNotify_RemoveAllAbnormal>();
	}
};
static_assert(alignof(ULAnimNotify_RemoveAllAbnormal) == 0x000008, "Wrong alignment on ULAnimNotify_RemoveAllAbnormal");
static_assert(sizeof(ULAnimNotify_RemoveAllAbnormal) == 0x000048, "Wrong size on ULAnimNotify_RemoveAllAbnormal");

// Class ProjectP.LLevelSkeletalMeshActor
// 0x0088 (0x0268 - 0x01E0)
class ALLevelSkeletalMeshActor final : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bShouldDoAnimNotifies : 1;                         // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWakeOnLevelStart : 1;                             // 0x01E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULLevelSkeletalMeshComponent*           SkeletalMeshComponent;                             // 0x01F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMesh*                          ReplicatedMesh;                                    // 0x01F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          ReplicatedPhysAsset;                               // 0x0200(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReplicatedMaterial0;                               // 0x0208(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReplicatedMaterial1;                               // 0x0210(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x50];                                     // 0x0218(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ReplicatedMaterial0();
	void OnRep_ReplicatedMaterial1();
	void OnRep_ReplicatedMesh();
	void OnRep_ReplicatedPhysAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelSkeletalMeshActor">();
	}
	static class ALLevelSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLevelSkeletalMeshActor>();
	}
};
static_assert(alignof(ALLevelSkeletalMeshActor) == 0x000008, "Wrong alignment on ALLevelSkeletalMeshActor");
static_assert(sizeof(ALLevelSkeletalMeshActor) == 0x000268, "Wrong size on ALLevelSkeletalMeshActor");
static_assert(offsetof(ALLevelSkeletalMeshActor, SkeletalMeshComponent) == 0x0001F0, "Member 'ALLevelSkeletalMeshActor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ALLevelSkeletalMeshActor, ReplicatedMesh) == 0x0001F8, "Member 'ALLevelSkeletalMeshActor::ReplicatedMesh' has a wrong offset!");
static_assert(offsetof(ALLevelSkeletalMeshActor, ReplicatedPhysAsset) == 0x000200, "Member 'ALLevelSkeletalMeshActor::ReplicatedPhysAsset' has a wrong offset!");
static_assert(offsetof(ALLevelSkeletalMeshActor, ReplicatedMaterial0) == 0x000208, "Member 'ALLevelSkeletalMeshActor::ReplicatedMaterial0' has a wrong offset!");
static_assert(offsetof(ALLevelSkeletalMeshActor, ReplicatedMaterial1) == 0x000210, "Member 'ALLevelSkeletalMeshActor::ReplicatedMaterial1' has a wrong offset!");

// Class ProjectP.DitherAssetUserData
// 0x0010 (0x0038 - 0x0028)
class UDitherAssetUserData final : public UAssetUserData
{
public:
	class FName                                   CodeName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DitherAssetUserData">();
	}
	static class UDitherAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDitherAssetUserData>();
	}
};
static_assert(alignof(UDitherAssetUserData) == 0x000008, "Wrong alignment on UDitherAssetUserData");
static_assert(sizeof(UDitherAssetUserData) == 0x000038, "Wrong size on UDitherAssetUserData");
static_assert(offsetof(UDitherAssetUserData, CodeName) == 0x000028, "Member 'UDitherAssetUserData::CodeName' has a wrong offset!");
static_assert(offsetof(UDitherAssetUserData, DistanceScale) == 0x000030, "Member 'UDitherAssetUserData::DistanceScale' has a wrong offset!");

// Class ProjectP.LDamageVolume
// 0x0020 (0x0258 - 0x0238)
class ALDamageVolume final : public ALVolume
{
public:
	ELDamageVolumeType                            DamageVolumeType;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Damage;                                            // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDamagePerTime>                TargetList;                                        // 0x0248(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDamageVolume">();
	}
	static class ALDamageVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDamageVolume>();
	}
};
static_assert(alignof(ALDamageVolume) == 0x000008, "Wrong alignment on ALDamageVolume");
static_assert(sizeof(ALDamageVolume) == 0x000258, "Wrong size on ALDamageVolume");
static_assert(offsetof(ALDamageVolume, DamageVolumeType) == 0x000238, "Member 'ALDamageVolume::DamageVolumeType' has a wrong offset!");
static_assert(offsetof(ALDamageVolume, Damage) == 0x00023C, "Member 'ALDamageVolume::Damage' has a wrong offset!");
static_assert(offsetof(ALDamageVolume, DurationTime) == 0x000240, "Member 'ALDamageVolume::DurationTime' has a wrong offset!");
static_assert(offsetof(ALDamageVolume, TargetList) == 0x000248, "Member 'ALDamageVolume::TargetList' has a wrong offset!");

// Class ProjectP.LDamageCollisionComponent
// 0x0020 (0x0490 - 0x0470)
class ULDamageCollisionComponent final : public UBoxComponent
{
public:
	ELDamageVolumeType                            DamageVolumeType;                                  // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Damage;                                            // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDamagePerTime>                TargetList;                                        // 0x0478(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginOverlapDamageCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void EndOverlapDamageCollision(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDamageCollisionComponent">();
	}
	static class ULDamageCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDamageCollisionComponent>();
	}
};
static_assert(alignof(ULDamageCollisionComponent) == 0x000010, "Wrong alignment on ULDamageCollisionComponent");
static_assert(sizeof(ULDamageCollisionComponent) == 0x000490, "Wrong size on ULDamageCollisionComponent");
static_assert(offsetof(ULDamageCollisionComponent, DamageVolumeType) == 0x000468, "Member 'ULDamageCollisionComponent::DamageVolumeType' has a wrong offset!");
static_assert(offsetof(ULDamageCollisionComponent, Damage) == 0x00046C, "Member 'ULDamageCollisionComponent::Damage' has a wrong offset!");
static_assert(offsetof(ULDamageCollisionComponent, DurationTime) == 0x000470, "Member 'ULDamageCollisionComponent::DurationTime' has a wrong offset!");
static_assert(offsetof(ULDamageCollisionComponent, TargetList) == 0x000478, "Member 'ULDamageCollisionComponent::TargetList' has a wrong offset!");

// Class ProjectP.LManualLevelStreamingVolume
// 0x0008 (0x0238 - 0x0230)
class ALManualLevelStreamingVolume final : public ALevelStreamingVolume
{
public:
	uint8                                         bHighPriority : 1;                                 // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LManualLevelStreamingVolume">();
	}
	static class ALManualLevelStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALManualLevelStreamingVolume>();
	}
};
static_assert(alignof(ALManualLevelStreamingVolume) == 0x000008, "Wrong alignment on ALManualLevelStreamingVolume");
static_assert(sizeof(ALManualLevelStreamingVolume) == 0x000238, "Wrong size on ALManualLevelStreamingVolume");

// Class ProjectP.LTransformDataAsset
// 0x0050 (0x0080 - 0x0030)
class ULTransformDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<class FName, struct FTransform>          DataMap;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void AddObjectTransform(class FName TargetObjectName, const struct FTransform& LocationTransform);
	void ClearAllData();
	void PrintData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTransformDataAsset">();
	}
	static class ULTransformDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTransformDataAsset>();
	}
};
static_assert(alignof(ULTransformDataAsset) == 0x000008, "Wrong alignment on ULTransformDataAsset");
static_assert(sizeof(ULTransformDataAsset) == 0x000080, "Wrong size on ULTransformDataAsset");
static_assert(offsetof(ULTransformDataAsset, DataMap) == 0x000030, "Member 'ULTransformDataAsset::DataMap' has a wrong offset!");

// Class ProjectP.LSpotDataAsset
// 0x0088 (0x00B8 - 0x0030)
class ULSpotDataAsset final : public UPrimaryDataAsset
{
public:
	class FString                                 DataStr;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTransform>          DataMap;                                           // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ALCharacter>             CharacterPtr;                                      // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearAllData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpotDataAsset">();
	}
	static class ULSpotDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpotDataAsset>();
	}
};
static_assert(alignof(ULSpotDataAsset) == 0x000008, "Wrong alignment on ULSpotDataAsset");
static_assert(sizeof(ULSpotDataAsset) == 0x0000B8, "Wrong size on ULSpotDataAsset");
static_assert(offsetof(ULSpotDataAsset, DataStr) == 0x000030, "Member 'ULSpotDataAsset::DataStr' has a wrong offset!");
static_assert(offsetof(ULSpotDataAsset, DataMap) == 0x000040, "Member 'ULSpotDataAsset::DataMap' has a wrong offset!");
static_assert(offsetof(ULSpotDataAsset, CharacterPtr) == 0x000090, "Member 'ULSpotDataAsset::CharacterPtr' has a wrong offset!");

// Class ProjectP.LPreloadDataAsset
// 0x00F0 (0x0120 - 0x0030)
class ULPreloadDataAsset final : public UPrimaryDataAsset
{
public:
	struct FLPreloadProjectileChildSpawnCodeNameData ProjectileChildSpawnCodeNames;                     // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLPreloadActionGroupData> ActionGroupDatas;                                  // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLPreloadNPCData>    NPCDatas;                                          // 0x00D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void ClearAllData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPreloadDataAsset">();
	}
	static class ULPreloadDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPreloadDataAsset>();
	}
};
static_assert(alignof(ULPreloadDataAsset) == 0x000008, "Wrong alignment on ULPreloadDataAsset");
static_assert(sizeof(ULPreloadDataAsset) == 0x000120, "Wrong size on ULPreloadDataAsset");
static_assert(offsetof(ULPreloadDataAsset, ProjectileChildSpawnCodeNames) == 0x000030, "Member 'ULPreloadDataAsset::ProjectileChildSpawnCodeNames' has a wrong offset!");
static_assert(offsetof(ULPreloadDataAsset, ActionGroupDatas) == 0x000080, "Member 'ULPreloadDataAsset::ActionGroupDatas' has a wrong offset!");
static_assert(offsetof(ULPreloadDataAsset, NPCDatas) == 0x0000D0, "Member 'ULPreloadDataAsset::NPCDatas' has a wrong offset!");

// Class ProjectP.LSpecialBuff_Abnormal_On_FrenzyAction
// 0x0008 (0x0050 - 0x0048)
class ULSpecialBuff_Abnormal_On_FrenzyAction final : public ULSpecialBuff
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnterActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair);
	void OnLeaveActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_On_FrenzyAction">();
	}
	static class ULSpecialBuff_Abnormal_On_FrenzyAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_On_FrenzyAction>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_On_FrenzyAction) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_On_FrenzyAction");
static_assert(sizeof(ULSpecialBuff_Abnormal_On_FrenzyAction) == 0x000050, "Wrong size on ULSpecialBuff_Abnormal_On_FrenzyAction");

// Class ProjectP.LDataTableSystem
// 0x0050 (0x00C8 - 0x0078)
class ULDataTableSystem final : public ULGameSubSystem
{
public:
	TMap<EDataTableType, class UDataTable*>       LoadedDataTableMap;                                // 0x0078(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDataTableSystem">();
	}
	static class ULDataTableSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDataTableSystem>();
	}
};
static_assert(alignof(ULDataTableSystem) == 0x000008, "Wrong alignment on ULDataTableSystem");
static_assert(sizeof(ULDataTableSystem) == 0x0000C8, "Wrong size on ULDataTableSystem");
static_assert(offsetof(ULDataTableSystem, LoadedDataTableMap) == 0x000078, "Member 'ULDataTableSystem::LoadedDataTableMap' has a wrong offset!");

// Class ProjectP.LDebugCameraController
// 0x0000 (0x0648 - 0x0648)
class ALDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDebugCameraController">();
	}
	static class ALDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDebugCameraController>();
	}
};
static_assert(alignof(ALDebugCameraController) == 0x000008, "Wrong alignment on ALDebugCameraController");
static_assert(sizeof(ALDebugCameraController) == 0x000648, "Wrong size on ALDebugCameraController");

// Class ProjectP.LSpecialBuff_EquipSlotUnlock
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_EquipSlotUnlock final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_EquipSlotUnlock">();
	}
	static class ULSpecialBuff_EquipSlotUnlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_EquipSlotUnlock>();
	}
};
static_assert(alignof(ULSpecialBuff_EquipSlotUnlock) == 0x000008, "Wrong alignment on ULSpecialBuff_EquipSlotUnlock");
static_assert(sizeof(ULSpecialBuff_EquipSlotUnlock) == 0x000048, "Wrong size on ULSpecialBuff_EquipSlotUnlock");

// Class ProjectP.LDecalComponent
// 0x0030 (0x0260 - 0x0230)
class ULDecalComponent final : public UDecalComponent
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELMaterialVaryingPlayType                     PlayType;                                          // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMaterialVaryingPlayer                MaterialVaryingPlayer;                             // 0x0238(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDecalComponent">();
	}
	static class ULDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDecalComponent>();
	}
};
static_assert(alignof(ULDecalComponent) == 0x000010, "Wrong alignment on ULDecalComponent");
static_assert(sizeof(ULDecalComponent) == 0x000260, "Wrong size on ULDecalComponent");
static_assert(offsetof(ULDecalComponent, MaterialVarying) == 0x000228, "Member 'ULDecalComponent::MaterialVarying' has a wrong offset!");
static_assert(offsetof(ULDecalComponent, PlayType) == 0x000230, "Member 'ULDecalComponent::PlayType' has a wrong offset!");
static_assert(offsetof(ULDecalComponent, MaterialVaryingPlayer) == 0x000238, "Member 'ULDecalComponent::MaterialVaryingPlayer' has a wrong offset!");

// Class ProjectP.LSequenceBindingActor
// 0x0000 (0x01E0 - 0x01E0)
class ALSequenceBindingActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSequenceBindingActor">();
	}
	static class ALSequenceBindingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSequenceBindingActor>();
	}
};
static_assert(alignof(ALSequenceBindingActor) == 0x000008, "Wrong alignment on ALSequenceBindingActor");
static_assert(sizeof(ALSequenceBindingActor) == 0x0001E0, "Wrong size on ALSequenceBindingActor");

// Class ProjectP.LAnimNotifyInterface
// 0x0000 (0x0028 - 0x0028)
class ILAnimNotifyInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAnimNotifyInterface">();
	}
	static class ILAnimNotifyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILAnimNotifyInterface>();
	}
};
static_assert(alignof(ILAnimNotifyInterface) == 0x000008, "Wrong alignment on ILAnimNotifyInterface");
static_assert(sizeof(ILAnimNotifyInterface) == 0x000028, "Wrong size on ILAnimNotifyInterface");

// Class ProjectP.LGeneralName
// 0x0000 (0x0028 - 0x0028)
class ULGeneralName final : public UObject
{
public:
	static class FName LName_Action_SpawnIdle();
	static class FName LName_Action_TurnAround();
	static class FName LName_CommonAnim_Run_F();
	static class FName LName_CommonAnim_Walk_B();
	static class FName LName_CommonAnim_Walk_F();
	static class FName LName_CommonAnim_Walk_L();
	static class FName LName_CommonAnim_Walk_R();
	static class FName LName_Hair();
	static class FName LName_Head();
	static class FName LName_MontageSection_End();
	static class FName LName_None();
	static class FName LName_NPCPause_SpotTrigger();
	static class FName LName_NPCPauseMeta_Action();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGeneralName">();
	}
	static class ULGeneralName* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGeneralName>();
	}
};
static_assert(alignof(ULGeneralName) == 0x000008, "Wrong alignment on ULGeneralName");
static_assert(sizeof(ULGeneralName) == 0x000028, "Wrong size on ULGeneralName");

// Class ProjectP.LCollisionMaskFilter
// 0x0000 (0x0028 - 0x0028)
class ULCollisionMaskFilter final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCollisionMaskFilter">();
	}
	static class ULCollisionMaskFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCollisionMaskFilter>();
	}
};
static_assert(alignof(ULCollisionMaskFilter) == 0x000008, "Wrong alignment on ULCollisionMaskFilter");
static_assert(sizeof(ULCollisionMaskFilter) == 0x000028, "Wrong size on ULCollisionMaskFilter");

// Class ProjectP.LHitColMgrComponent
// 0x00F8 (0x01A8 - 0x00B0)
class ULHitColMgrComponent final : public UActorComponent
{
public:
	class AActor*                                 HitColOwner;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitContext                           Cached_HitContext;                                 // 0x00B8(0x0074)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGrabInfo                             Cached_GrabInfo;                                   // 0x0130(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapped(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentEndOverlapped(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitColMgrComponent">();
	}
	static class ULHitColMgrComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHitColMgrComponent>();
	}
};
static_assert(alignof(ULHitColMgrComponent) == 0x000008, "Wrong alignment on ULHitColMgrComponent");
static_assert(sizeof(ULHitColMgrComponent) == 0x0001A8, "Wrong size on ULHitColMgrComponent");
static_assert(offsetof(ULHitColMgrComponent, HitColOwner) == 0x0000B0, "Member 'ULHitColMgrComponent::HitColOwner' has a wrong offset!");
static_assert(offsetof(ULHitColMgrComponent, Cached_HitContext) == 0x0000B8, "Member 'ULHitColMgrComponent::Cached_HitContext' has a wrong offset!");
static_assert(offsetof(ULHitColMgrComponent, Cached_GrabInfo) == 0x000130, "Member 'ULHitColMgrComponent::Cached_GrabInfo' has a wrong offset!");

// Class ProjectP.LCollisionChannel
// 0x0000 (0x0028 - 0x0028)
class ULCollisionChannel final : public UObject
{
public:
	static ECollisionChannel CollisionChannel_LAttack();
	static ECollisionChannel CollisionChannel_LAudio();
	static ECollisionChannel CollisionChannel_LCapsuleBig();
	static ECollisionChannel CollisionChannel_LCapsuleNormal();
	static ECollisionChannel CollisionChannel_LCapsulePC();
	static ECollisionChannel CollisionChannel_LCloud();
	static ECollisionChannel CollisionChannel_LIK();
	static ECollisionChannel CollisionChannel_LPhysicsBodyBig();
	static ECollisionChannel CollisionChannel_LPhysicsBodyNormal();
	static ECollisionChannel CollisionChannel_LPhysicsBodyVisual();
	static ECollisionChannel CollisionChannel_LProjectile();
	static ECollisionChannel CollisionChannel_LRepulse();
	static ECollisionChannel CollisionChannel_LSpark();
	static ECollisionChannel CollisionChannel_LWaterVolume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCollisionChannel">();
	}
	static class ULCollisionChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCollisionChannel>();
	}
};
static_assert(alignof(ULCollisionChannel) == 0x000008, "Wrong alignment on ULCollisionChannel");
static_assert(sizeof(ULCollisionChannel) == 0x000028, "Wrong size on ULCollisionChannel");

// Class ProjectP.LLevelUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULLevelUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangePropStateBP(class AActor* TargetActor, int32 TargetState, EExecutePin* Branches);
	static void CheckNextPropStateBP(class AActor* TargetActor);
	static class ULPropComponent* GetPropComponentBP(class AActor* TargetActor, EExecutePin* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelUtilFuncLibrary">();
	}
	static class ULLevelUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLevelUtilFuncLibrary>();
	}
};
static_assert(alignof(ULLevelUtilFuncLibrary) == 0x000008, "Wrong alignment on ULLevelUtilFuncLibrary");
static_assert(sizeof(ULLevelUtilFuncLibrary) == 0x000028, "Wrong size on ULLevelUtilFuncLibrary");

// Class ProjectP.LCollisionProfile
// 0x0000 (0x0028 - 0x0028)
class ULCollisionProfile final : public UObject
{
public:
	static class FName CollisionProfile_BlockAll();
	static class FName CollisionProfile_BlockAllDynamic();
	static class FName CollisionProfile_CharacterMesh();
	static class FName CollisionProfile_Destructible();
	static class FName CollisionProfile_IgnoreOnlyPawn();
	static class FName CollisionProfile_InvisibleWall();
	static class FName CollisionProfile_InvisibleWallDynamic();
	static class FName CollisionProfile_LAttack_Base();
	static class FName CollisionProfile_LAttack_Range();
	static class FName CollisionProfile_LBlock_Obstacle();
	static class FName CollisionProfile_LBlock_Obstacle_Projectile();
	static class FName CollisionProfile_LBlockAll_MovingEnvironment();
	static class FName CollisionProfile_LBlockAll_ThruCamera();
	static class FName CollisionProfile_LBlockingVolume();
	static class FName CollisionProfile_LCamera_Block();
	static class FName CollisionProfile_LCapsuleAll_BlockAll();
	static class FName CollisionProfile_LCapsuleAll_Penetrate();
	static class FName CollisionProfile_LCapsuleAll_Penetrate_Fly();
	static class FName CollisionProfile_LCapsuleAll_TestOverlap();
	static class FName CollisionProfile_LCapsuleBig_Base();
	static class FName CollisionProfile_LCapsuleBig_Dead();
	static class FName CollisionProfile_LCapsuleBig_Ghost();
	static class FName CollisionProfile_LCapsuleNormal_Base();
	static class FName CollisionProfile_LCapsuleNormal_Dead();
	static class FName CollisionProfile_LCapsuleNormal_Ghost();
	static class FName CollisionProfile_LCapsuleNormal_Ghost_Hittable();
	static class FName CollisionProfile_LCapsuleNormal_Hittable();
	static class FName CollisionProfile_LCapsuleNormal_Penetrate_Hittable();
	static class FName CollisionProfile_LCapsuleNPC_TestOverlap();
	static class FName CollisionProfile_LCapsulePC_Base();
	static class FName CollisionProfile_LCapsulePC_Dead();
	static class FName CollisionProfile_LCapsulePC_Ghost();
	static class FName CollisionProfile_LCapsulePC_TestOverlap();
	static class FName CollisionProfile_LDecoMesh_Attack();
	static class FName CollisionProfile_LDecoMesh_DropEnd();
	static class FName CollisionProfile_LDecoMesh_DropStart();
	static class FName CollisionProfile_LDestructible_Chunk();
	static class FName CollisionProfile_LEnvironmentVolume();
	static class FName CollisionProfile_LFloorPC();
	static class FName CollisionProfile_LInteract_Base();
	static class FName CollisionProfile_LInteract_CapsuleBase();
	static class FName CollisionProfile_LPhysicsBody_Explosion_Cut();
	static class FName CollisionProfile_LPhysicsBodyBig_Base();
	static class FName CollisionProfile_LPhysicsBodyBig_Dead();
	static class FName CollisionProfile_LPhysicsBodyBig_Dying();
	static class FName CollisionProfile_LPhysicsBodyBig_Ghost();
	static class FName CollisionProfile_LPhysicsBodyBig_Penetrate();
	static class FName CollisionProfile_LPhysicsBodyNormal_Base();
	static class FName CollisionProfile_LPhysicsBodyNormal_Dead();
	static class FName CollisionProfile_LPhysicsBodyNormal_Dying();
	static class FName CollisionProfile_LPhysicsBodyNormal_Ghost();
	static class FName CollisionProfile_LPhysicsBodyNormal_Penetrate();
	static class FName CollisionProfile_LPhysicsBodyNormal_SimulateOnly();
	static class FName CollisionProfile_LPhysicsBodyPC_Base();
	static class FName CollisionProfile_LPhysicsBodyPC_Dead();
	static class FName CollisionProfile_LPhysicsBodyPC_Dying();
	static class FName CollisionProfile_LPhysicsBodyPC_Ghost();
	static class FName CollisionProfile_LPhysicsBodyPC_Penetrate();
	static class FName CollisionProfile_LPhysicsBodyPC_SimulateOnly();
	static class FName CollisionProfile_LPhysicsBodyVisual_Base();
	static class FName CollisionProfile_LProjectile_Base();
	static class FName CollisionProfile_NoCollision();
	static class FName CollisionProfile_None();
	static class FName CollisionProfile_OverlapAll();
	static class FName CollisionProfile_OverlapAllDynamic();
	static class FName CollisionProfile_OverlapOnlyPawn();
	static class FName CollisionProfile_Pawn();
	static class FName CollisionProfile_PhysicsActor();
	static class FName CollisionProfile_Ragdoll();
	static class FName CollisionProfile_Spectator();
	static class FName CollisionProfile_Trigger();
	static class FName CollisionProfile_UI();
	static class FName CollisionProfile_Vehicle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCollisionProfile">();
	}
	static class ULCollisionProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCollisionProfile>();
	}
};
static_assert(alignof(ULCollisionProfile) == 0x000008, "Wrong alignment on ULCollisionProfile");
static_assert(sizeof(ULCollisionProfile) == 0x000028, "Wrong size on ULCollisionProfile");

// Class ProjectP.LComponentTag
// 0x0000 (0x0028 - 0x0028)
class ULComponentTag final : public UObject
{
public:
	static class FName CollisionProfile_LFootCollision();
	static class FName CollisionProfile_None();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LComponentTag">();
	}
	static class ULComponentTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULComponentTag>();
	}
};
static_assert(alignof(ULComponentTag) == 0x000008, "Wrong alignment on ULComponentTag");
static_assert(sizeof(ULComponentTag) == 0x000028, "Wrong size on ULComponentTag");

// Class ProjectP.Interface_DestructEntity
// 0x0000 (0x0028 - 0x0028)
class IInterface_DestructEntity final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interface_DestructEntity">();
	}
	static class IInterface_DestructEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterface_DestructEntity>();
	}
};
static_assert(alignof(IInterface_DestructEntity) == 0x000008, "Wrong alignment on IInterface_DestructEntity");
static_assert(sizeof(IInterface_DestructEntity) == 0x000028, "Wrong size on IInterface_DestructEntity");

// Class ProjectP.LHUD
// 0x0060 (0x0330 - 0x02D0)
class ALHUD final : public AHUD
{
public:
	uint8                                         Pad_2D0[0x60];                                     // 0x02D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHUD">();
	}
	static class ALHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALHUD>();
	}
};
static_assert(alignof(ALHUD) == 0x000008, "Wrong alignment on ALHUD");
static_assert(sizeof(ALHUD) == 0x000330, "Wrong size on ALHUD");

// Class ProjectP.LDestructStaticMeshComponent
// 0x0020 (0x0500 - 0x04E0)
class ULDestructStaticMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllMassScale;                                      // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveChunksPushStrengthRate;                        // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugDraw : 1;                                    // 0x04F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCollideCamera : 1;                                // 0x04F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanPushChunks : 1;                                // 0x04F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bArtificialImpulse : 1;                            // 0x04F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4F1[0xF];                                      // 0x04F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDestructOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDestructStaticMeshComponent">();
	}
	static class ULDestructStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDestructStaticMeshComponent>();
	}
};
static_assert(alignof(ULDestructStaticMeshComponent) == 0x000010, "Wrong alignment on ULDestructStaticMeshComponent");
static_assert(sizeof(ULDestructStaticMeshComponent) == 0x000500, "Wrong size on ULDestructStaticMeshComponent");
static_assert(offsetof(ULDestructStaticMeshComponent, AllMassScale) == 0x0004E8, "Member 'ULDestructStaticMeshComponent::AllMassScale' has a wrong offset!");
static_assert(offsetof(ULDestructStaticMeshComponent, MoveChunksPushStrengthRate) == 0x0004EC, "Member 'ULDestructStaticMeshComponent::MoveChunksPushStrengthRate' has a wrong offset!");

// Class ProjectP.LDestructSkeletalMeshComponent
// 0x0020 (0x0EE0 - 0x0EC0)
class ULDestructSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_EB8[0x8];                                      // 0x0EB8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllMassScale;                                      // 0x0EC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveChunksPushStrengthRate;                        // 0x0EC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugDraw : 1;                                    // 0x0EC8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCollideCamera : 1;                                // 0x0EC8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_EC9[0x17];                                     // 0x0EC9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDestructOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDestructSkeletalMeshComponent">();
	}
	static class ULDestructSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDestructSkeletalMeshComponent>();
	}
};
static_assert(alignof(ULDestructSkeletalMeshComponent) == 0x000010, "Wrong alignment on ULDestructSkeletalMeshComponent");
static_assert(sizeof(ULDestructSkeletalMeshComponent) == 0x000EE0, "Wrong size on ULDestructSkeletalMeshComponent");
static_assert(offsetof(ULDestructSkeletalMeshComponent, AllMassScale) == 0x000EC0, "Member 'ULDestructSkeletalMeshComponent::AllMassScale' has a wrong offset!");
static_assert(offsetof(ULDestructSkeletalMeshComponent, MoveChunksPushStrengthRate) == 0x000EC4, "Member 'ULDestructSkeletalMeshComponent::MoveChunksPushStrengthRate' has a wrong offset!");

// Class ProjectP.LDestructibleComponent
// 0x0030 (0x0780 - 0x0750)
class ULDestructibleComponent final : public UDestructibleComponent
{
public:
	uint8                                         Pad_750[0x8];                                      // 0x0750(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllMassScale;                                      // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveChunksPushStrengthRate;                        // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugDraw : 1;                                    // 0x0760(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCollideCamera : 1;                                // 0x0760(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanPushChunks : 1;                                // 0x0760(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bArtificialImpulse : 1;                            // 0x0760(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_761[0x17];                                     // 0x0761(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0778(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideStaticMeshProcess();
	void OnDestructFracture(const struct FVector& HitPoint, const struct FVector& HitDirection);
	void OnDestructOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDestructibleComponent">();
	}
	static class ULDestructibleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDestructibleComponent>();
	}
};
static_assert(alignof(ULDestructibleComponent) == 0x000010, "Wrong alignment on ULDestructibleComponent");
static_assert(sizeof(ULDestructibleComponent) == 0x000780, "Wrong size on ULDestructibleComponent");
static_assert(offsetof(ULDestructibleComponent, AllMassScale) == 0x000758, "Member 'ULDestructibleComponent::AllMassScale' has a wrong offset!");
static_assert(offsetof(ULDestructibleComponent, MoveChunksPushStrengthRate) == 0x00075C, "Member 'ULDestructibleComponent::MoveChunksPushStrengthRate' has a wrong offset!");
static_assert(offsetof(ULDestructibleComponent, StaticMeshComponent) == 0x000778, "Member 'ULDestructibleComponent::StaticMeshComponent' has a wrong offset!");

// Class ProjectP.LHumanitySystem
// 0x0048 (0x00C0 - 0x0078)
class ULHumanitySystem final : public ULGameSubSystem
{
public:
	class ULHumanityDB*                           HumanityDB;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSatisfiedBuffAlter;                              // 0x0080(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHumanizationBuffAddInfoPtr>    Applied_BuffAdd;                                   // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHumanityAcquisitionPopupEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHumanitySystem">();
	}
	static class ULHumanitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHumanitySystem>();
	}
};
static_assert(alignof(ULHumanitySystem) == 0x000008, "Wrong alignment on ULHumanitySystem");
static_assert(sizeof(ULHumanitySystem) == 0x0000C0, "Wrong size on ULHumanitySystem");
static_assert(offsetof(ULHumanitySystem, HumanityDB) == 0x000078, "Member 'ULHumanitySystem::HumanityDB' has a wrong offset!");
static_assert(offsetof(ULHumanitySystem, OnSatisfiedBuffAlter) == 0x000080, "Member 'ULHumanitySystem::OnSatisfiedBuffAlter' has a wrong offset!");
static_assert(offsetof(ULHumanitySystem, Applied_BuffAdd) == 0x000090, "Member 'ULHumanitySystem::Applied_BuffAdd' has a wrong offset!");

// Class ProjectP.LDestructionObject
// 0x0120 (0x0330 - 0x0210)
class ALDestructionObject : public ALInteractActor
{
public:
	uint8                                         bIsPossiblePhysicalReactionRemains : 1;            // 0x0210(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_211[0x1F];                                     // 0x0211(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisappearRange;                                    // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugDraw : 1;                                    // 0x0234(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCrashedAll : 1;                                   // 0x0234(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStableAll : 1;                                    // 0x0234(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanDisappearByCameraView : 1;                     // 0x0234(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanDissolveEffect : 1;                            // 0x0234(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTakeWarningEvent : 1;                             // 0x0234(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIndestructibleButOccurEvent : 1;                  // 0x0234(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DissolveEffectDelayTime;                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DissolveEffectActorDestoryDelayTime;               // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavModifierComponent*                  NavModifierComponent;                              // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           HideByCameraViewTimerHandle;                       // 0x0260(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DissolveTimerHandle;                               // 0x0268(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0xB4];                                     // 0x0270(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALPropDestructionSpot>   OwnerSpot;                                         // 0x0324(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELPhysicalSurfaceType                         Override_PhysicalSurface;                          // 0x032C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanRepulse(class AActor* Attacker);
	void DoHitDirection(const struct FVector& HitLocation, const struct FVector& HitDirection, float Strength);
	void DoHitFully(const struct FVector& HitLocation, float Strength);
	void DoHitRadius(const struct FVector& HitLocation, float Radius, float Strength);
	void DoHitSelf(float Strength);
	int32 GetCurrectHPDestructionProp();
	void OnDestructCrashed();
	void ProcessHit();
	void PushCrashedChunks(const struct FVector& PushLocation);
	void ResetCrashed();

	class AActor* GetControlShapeObjectSpot(int32 Index_0) const;
	int32 GetControlShapeObjectSpotLastIndex() const;
	class AActor* GetControlVolumeSpot() const;
	ELPhysicalSurfaceType GetOverridePhysicalSurface() const;
	ELPhysicalSurfaceType GetPhysicalSurfaceType() const;
	bool IsCrashedAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDestructionObject">();
	}
	static class ALDestructionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDestructionObject>();
	}
};
static_assert(alignof(ALDestructionObject) == 0x000008, "Wrong alignment on ALDestructionObject");
static_assert(sizeof(ALDestructionObject) == 0x000330, "Wrong size on ALDestructionObject");
static_assert(offsetof(ALDestructionObject, DisappearRange) == 0x000230, "Member 'ALDestructionObject::DisappearRange' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, DissolveEffectDelayTime) == 0x000238, "Member 'ALDestructionObject::DissolveEffectDelayTime' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, DissolveEffectActorDestoryDelayTime) == 0x00023C, "Member 'ALDestructionObject::DissolveEffectActorDestoryDelayTime' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, CapsuleComponent) == 0x000240, "Member 'ALDestructionObject::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, NavModifierComponent) == 0x000248, "Member 'ALDestructionObject::NavModifierComponent' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, HideByCameraViewTimerHandle) == 0x000260, "Member 'ALDestructionObject::HideByCameraViewTimerHandle' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, DissolveTimerHandle) == 0x000268, "Member 'ALDestructionObject::DissolveTimerHandle' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, OwnerSpot) == 0x000324, "Member 'ALDestructionObject::OwnerSpot' has a wrong offset!");
static_assert(offsetof(ALDestructionObject, Override_PhysicalSurface) == 0x00032C, "Member 'ALDestructionObject::Override_PhysicalSurface' has a wrong offset!");

// Class ProjectP.LLocationVolume
// 0x0008 (0x0240 - 0x0238)
class ALLocationVolume final : public ALVolume
{
public:
	class FName                                   LocationCodeName;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLocationVolume">();
	}
	static class ALLocationVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLocationVolume>();
	}
};
static_assert(alignof(ALLocationVolume) == 0x000008, "Wrong alignment on ALLocationVolume");
static_assert(sizeof(ALLocationVolume) == 0x000240, "Wrong size on ALLocationVolume");
static_assert(offsetof(ALLocationVolume, LocationCodeName) == 0x000238, "Member 'ALLocationVolume::LocationCodeName' has a wrong offset!");

// Class ProjectP.LDevSystem
// 0x0038 (0x00B0 - 0x0078)
class ULDevSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnToggleCommandBook;                               // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULRecordCameraData*                     LastRecordCameraData;                              // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableRecordCamera;                               // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecordLookatZOffset;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUserGameCommand(const struct FLGameCommandBookEntity& Command);
	void BindGameCommandBookHotKey(const struct FLGameCommandBookEntity& Command);
	void EmptyUserCommands();
	void ExecuteGameCommand(const struct FLGameCommandBookEntity& Command);
	class AActor* GetDebugTargetActor();
	class ALNPCCharacter* GetNpcActorOnlyOne();
	void LoadGameCommands(TArray<struct FLGameCommandBookEntity>* DefaultCommands, TArray<struct FLGameCommandBookEntity>* UserCommands, TArray<struct FLGameCommandBookEntity>* DefaultChapterCommands, TArray<struct FLGameCommandBookEntity>* DefaultMoneyCommands);
	void SaveUserGameCommands(const TArray<struct FLGameCommandBookEntity>& UserCommands);
	void StartRecordCamera(float FrameRate, int32 LookatZOffset);
	void StopRecordCamera();
	void TogglePrintLocation();
	void UnbindGameCommandBookHotKey(const struct FLGameCommandBookEntity& Command);
	void UnbindGameCommandBookHotKeyAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDevSystem">();
	}
	static class ULDevSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDevSystem>();
	}
};
static_assert(alignof(ULDevSystem) == 0x000008, "Wrong alignment on ULDevSystem");
static_assert(sizeof(ULDevSystem) == 0x0000B0, "Wrong size on ULDevSystem");
static_assert(offsetof(ULDevSystem, OnToggleCommandBook) == 0x000078, "Member 'ULDevSystem::OnToggleCommandBook' has a wrong offset!");
static_assert(offsetof(ULDevSystem, LastRecordCameraData) == 0x000098, "Member 'ULDevSystem::LastRecordCameraData' has a wrong offset!");
static_assert(offsetof(ULDevSystem, bEnableRecordCamera) == 0x0000A0, "Member 'ULDevSystem::bEnableRecordCamera' has a wrong offset!");
static_assert(offsetof(ULDevSystem, RecordLookatZOffset) == 0x0000A4, "Member 'ULDevSystem::RecordLookatZOffset' has a wrong offset!");

// Class ProjectP.LDLCSystem
// 0x0100 (0x0178 - 0x0078)
class ULDLCSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0xC0];                                      // 0x0078(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             UIPreviewDLC;                                      // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIDLCItemReceiveResult_Account;                    // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIDLCItemReceiveResult;                            // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckAvailableDLC();
	void OnCloseItemReceiveUI();
	void OnConnectionCanceled();
	void OnConnectionFailed();
	bool PopOutPendingDLC_Account(ELRewardType InType);
	bool PopOutPendingDLC_Character(ELRewardType InType);
	void PrintPreview();

	TArray<class FName> GetPendingDLCList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDLCSystem">();
	}
	static class ULDLCSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDLCSystem>();
	}
};
static_assert(alignof(ULDLCSystem) == 0x000008, "Wrong alignment on ULDLCSystem");
static_assert(sizeof(ULDLCSystem) == 0x000178, "Wrong size on ULDLCSystem");
static_assert(offsetof(ULDLCSystem, UIPreviewDLC) == 0x000138, "Member 'ULDLCSystem::UIPreviewDLC' has a wrong offset!");
static_assert(offsetof(ULDLCSystem, UIDLCItemReceiveResult_Account) == 0x000148, "Member 'ULDLCSystem::UIDLCItemReceiveResult_Account' has a wrong offset!");
static_assert(offsetof(ULDLCSystem, UIDLCItemReceiveResult) == 0x000158, "Member 'ULDLCSystem::UIDLCItemReceiveResult' has a wrong offset!");

// Class ProjectP.LDropFixVolume
// 0x0008 (0x0240 - 0x0238)
class ALDropFixVolume final : public ALVolume
{
public:
	class ALLocationActor*                        ErgoDropLocation;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDropFixVolume">();
	}
	static class ALDropFixVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDropFixVolume>();
	}
};
static_assert(alignof(ALDropFixVolume) == 0x000008, "Wrong alignment on ALDropFixVolume");
static_assert(sizeof(ALDropFixVolume) == 0x000240, "Wrong size on ALDropFixVolume");
static_assert(offsetof(ALDropFixVolume, ErgoDropLocation) == 0x000238, "Member 'ALDropFixVolume::ErgoDropLocation' has a wrong offset!");

// Class ProjectP.LInteractSphereComponent
// 0x0010 (0x0470 - 0x0460)
class ULInteractSphereComponent final : public USphereComponent
{
public:
	int32                                         ConfrontAngle;                                     // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfrontAngleProp;                                 // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageCodeName;                                   // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractSphereComponent">();
	}
	static class ULInteractSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInteractSphereComponent>();
	}
};
static_assert(alignof(ULInteractSphereComponent) == 0x000010, "Wrong alignment on ULInteractSphereComponent");
static_assert(sizeof(ULInteractSphereComponent) == 0x000470, "Wrong size on ULInteractSphereComponent");
static_assert(offsetof(ULInteractSphereComponent, ConfrontAngle) == 0x000460, "Member 'ULInteractSphereComponent::ConfrontAngle' has a wrong offset!");
static_assert(offsetof(ULInteractSphereComponent, ConfrontAngleProp) == 0x000464, "Member 'ULInteractSphereComponent::ConfrontAngleProp' has a wrong offset!");
static_assert(offsetof(ULInteractSphereComponent, MessageCodeName) == 0x000468, "Member 'ULInteractSphereComponent::MessageCodeName' has a wrong offset!");

// Class ProjectP.LDummySpot
// 0x0000 (0x02C8 - 0x02C8)
class ALDummySpot final : public ALSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDummySpot">();
	}
	static class ALDummySpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDummySpot>();
	}
};
static_assert(alignof(ALDummySpot) == 0x000008, "Wrong alignment on ALDummySpot");
static_assert(sizeof(ALDummySpot) == 0x0002C8, "Wrong size on ALDummySpot");

// Class ProjectP.LNPCSpot
// 0x0150 (0x0418 - 0x02C8)
class ALNPCSpot : public ALSpot
{
public:
	class FName                                   SpawnIdleActionGroup;                              // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableSenseOnSpawnIdle : 1;                      // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNPCSpawnIdleOverride                 SpawnIdleOverride;                                 // 0x02D4(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLNPCInfoOverride                      NPCInfoOverride;                                   // 0x02EC(0x003C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PathWayCodeName;                                   // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveByPathWayOnSpawn;                             // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFloatingStateOnSpawn : 1;                         // 0x0331(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFloatingStateCeiling : 1;                         // 0x0331(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAIPauseOnSpawn : 1;                               // 0x0331(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSleepOnSpawn : 1;                                 // 0x0331(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetSwapOnRespawn : 1;                           // 0x0331(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseModifySpawnIdle : 1;                           // 0x0331(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bImportantNPC;                                     // 0x0332(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_333[0x1];                                      // 0x0333(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameObject_InactiveDistanceFromPlayer_Override;    // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFactionType                                  Faction;                                           // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDeadState;                                       // 0x0339(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsHideDespawn : 1;                                // 0x033A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_33B[0x1];                                      // 0x033B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StolenDropErgo;                                    // 0x033C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsRespawnEnable : 1;                              // 0x0340(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SwapNpcCodeName;                                   // 0x0344(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bExecuteWakeUp : 1;                                // 0x034C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExecuteFloatingStop : 1;                          // 0x034C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            PartsItemDropCount;                                // 0x0350(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<class ULAITargetPointComponent*>       AITargetPointComponents;                           // 0x03A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ModifySpawnIdleCodeName;                           // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeBossRoomSpot : 1;                          // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNPCSpotDieInfoPtr>             NPCSpotDieInfoList;                                // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FNPCSpotDieInfoPtr                     NPCSpotDieInfoPtr;                                 // 0x03D0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           WakeUpTimerHandle;                                 // 0x03D8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDeadSpawnNpc;                                    // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FLButterflyNPCGroupMember>      ButterFlyNPCSpotList;                              // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALNPCSpot>               GroupMaster_RedButterfly;                          // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALNPCCharacter>          SpawnedNpc;                                        // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapPathway(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnWakeUpSpawnedNpc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpot">();
	}
	static class ALNPCSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALNPCSpot>();
	}
};
static_assert(alignof(ALNPCSpot) == 0x000008, "Wrong alignment on ALNPCSpot");
static_assert(sizeof(ALNPCSpot) == 0x000418, "Wrong size on ALNPCSpot");
static_assert(offsetof(ALNPCSpot, SpawnIdleActionGroup) == 0x0002C8, "Member 'ALNPCSpot::SpawnIdleActionGroup' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, SpawnIdleOverride) == 0x0002D4, "Member 'ALNPCSpot::SpawnIdleOverride' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, NPCInfoOverride) == 0x0002EC, "Member 'ALNPCSpot::NPCInfoOverride' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, PathWayCodeName) == 0x000328, "Member 'ALNPCSpot::PathWayCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, bMoveByPathWayOnSpawn) == 0x000330, "Member 'ALNPCSpot::bMoveByPathWayOnSpawn' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, bImportantNPC) == 0x000332, "Member 'ALNPCSpot::bImportantNPC' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, GameObject_InactiveDistanceFromPlayer_Override) == 0x000334, "Member 'ALNPCSpot::GameObject_InactiveDistanceFromPlayer_Override' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, Faction) == 0x000338, "Member 'ALNPCSpot::Faction' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, IsDeadState) == 0x000339, "Member 'ALNPCSpot::IsDeadState' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, StolenDropErgo) == 0x00033C, "Member 'ALNPCSpot::StolenDropErgo' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, SwapNpcCodeName) == 0x000344, "Member 'ALNPCSpot::SwapNpcCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, PartsItemDropCount) == 0x000350, "Member 'ALNPCSpot::PartsItemDropCount' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, AITargetPointComponents) == 0x0003A0, "Member 'ALNPCSpot::AITargetPointComponents' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, ModifySpawnIdleCodeName) == 0x0003B0, "Member 'ALNPCSpot::ModifySpawnIdleCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, NPCSpotDieInfoList) == 0x0003C0, "Member 'ALNPCSpot::NPCSpotDieInfoList' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, NPCSpotDieInfoPtr) == 0x0003D0, "Member 'ALNPCSpot::NPCSpotDieInfoPtr' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, WakeUpTimerHandle) == 0x0003D8, "Member 'ALNPCSpot::WakeUpTimerHandle' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, OnDeadSpawnNpc) == 0x0003E0, "Member 'ALNPCSpot::OnDeadSpawnNpc' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, ButterFlyNPCSpotList) == 0x0003F0, "Member 'ALNPCSpot::ButterFlyNPCSpotList' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, GroupMaster_RedButterfly) == 0x000400, "Member 'ALNPCSpot::GroupMaster_RedButterfly' has a wrong offset!");
static_assert(offsetof(ALNPCSpot, SpawnedNpc) == 0x000408, "Member 'ALNPCSpot::SpawnedNpc' has a wrong offset!");

// Class ProjectP.LDummyNPCSpot
// 0x0000 (0x0418 - 0x0418)
class ALDummyNPCSpot final : public ALNPCSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDummyNPCSpot">();
	}
	static class ALDummyNPCSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDummyNPCSpot>();
	}
};
static_assert(alignof(ALDummyNPCSpot) == 0x000008, "Wrong alignment on ALDummyNPCSpot");
static_assert(sizeof(ALDummyNPCSpot) == 0x000418, "Wrong size on ALDummyNPCSpot");

// Class ProjectP.LDummyPropSpot
// 0x0000 (0x0350 - 0x0350)
class ALDummyPropSpot final : public ALPropSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDummyPropSpot">();
	}
	static class ALDummyPropSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDummyPropSpot>();
	}
};
static_assert(alignof(ALDummyPropSpot) == 0x000008, "Wrong alignment on ALDummyPropSpot");
static_assert(sizeof(ALDummyPropSpot) == 0x000350, "Wrong size on ALDummyPropSpot");

// Class ProjectP.LNPCSpecConditionAbnormal
// 0x0008 (0x0038 - 0x0030)
class ULNPCSpecConditionAbnormal final : public ULNPCSpecConditionBase
{
public:
	class FName                                   AbnormalCodeName;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecConditionAbnormal">();
	}
	static class ULNPCSpecConditionAbnormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecConditionAbnormal>();
	}
};
static_assert(alignof(ULNPCSpecConditionAbnormal) == 0x000008, "Wrong alignment on ULNPCSpecConditionAbnormal");
static_assert(sizeof(ULNPCSpecConditionAbnormal) == 0x000038, "Wrong size on ULNPCSpecConditionAbnormal");
static_assert(offsetof(ULNPCSpecConditionAbnormal, AbnormalCodeName) == 0x000030, "Member 'ULNPCSpecConditionAbnormal::AbnormalCodeName' has a wrong offset!");

// Class ProjectP.LEnvRootComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULEnvRootComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LEnvRootComponent">();
	}
	static class ULEnvRootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULEnvRootComponent>();
	}
};
static_assert(alignof(ULEnvRootComponent) == 0x000010, "Wrong alignment on ULEnvRootComponent");
static_assert(sizeof(ULEnvRootComponent) == 0x0001F0, "Wrong size on ULEnvRootComponent");

// Class ProjectP.LPostProcessComponent
// 0x0020 (0x07E0 - 0x07C0)
class ULPostProcessComponent final : public UPostProcessComponent
{
public:
	uint8                                         Pad_7C0[0x20];                                     // 0x07C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPostProcessComponent">();
	}
	static class ULPostProcessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPostProcessComponent>();
	}
};
static_assert(alignof(ULPostProcessComponent) == 0x000010, "Wrong alignment on ULPostProcessComponent");
static_assert(sizeof(ULPostProcessComponent) == 0x0007E0, "Wrong size on ULPostProcessComponent");

// Class ProjectP.SphereComponentForGuide
// 0x0000 (0x0460 - 0x0460)
class USphereComponentForGuide : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereComponentForGuide">();
	}
	static class USphereComponentForGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<USphereComponentForGuide>();
	}
};
static_assert(alignof(USphereComponentForGuide) == 0x000010, "Wrong alignment on USphereComponentForGuide");
static_assert(sizeof(USphereComponentForGuide) == 0x000460, "Wrong size on USphereComponentForGuide");

// Class ProjectP.LPlatformSystem
// 0x0140 (0x01B8 - 0x0078)
class ULPlatformSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnNeowizAuth;                                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bCompleteNeowizAuth;                               // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NWZ_Auth_ID;                                       // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NWZ_Auth_PW;                                       // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 NWZ_Auth_Token;                                    // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          NWZ_Auth_ExternalAccount;                          // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NWZ_LogKey;                                        // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NeowizAuthInterval;                                // 0x00D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           NeowizAuthTimerHandle;                             // 0x00E0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ActivityObjectID;                                  // 0x00E8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         ActivityTaskIDs;                                   // 0x00F8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class FString                                 StoreCategory;                                     // 0x0108(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 StoreProductId;                                    // 0x0118(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Cache_RefreshPlatformAchievements;                 // 0x0130(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RequestAchievementArray;                           // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x68];                                     // 0x0148(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShutdown;                                         // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLaunchActivity;                                   // 0x01B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELLaunchActivityErrorType                     LaunchActivityErrorType;                           // 0x01B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B3[0x5];                                      // 0x01B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConfirmNeowizAuth(const class FString& ID, const class FString& PW, bool ExternalAccount);
	void ExecuteNeowizAuthRefresh();
	float GetChunkInstallProgress();
	class FString GetGameVersionString();
	ELLaunchActivityErrorType GetLaunchActivityErrortype();
	class FString GetPlatformName();
	class FString GetPlayerNickName();
	bool IsChunkInstallComplete();
	bool IsLaunchActivity();
	bool IsNeowizAuthExternalAccount();
	bool IsValidNeowizAuth();
	void PrintLoginStatusTest();
	bool ResetActivity();
	void ResetLaunchActivity();
	bool ResumeActivity(int32 InProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlatformSystem">();
	}
	static class ULPlatformSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlatformSystem>();
	}
};
static_assert(alignof(ULPlatformSystem) == 0x000008, "Wrong alignment on ULPlatformSystem");
static_assert(sizeof(ULPlatformSystem) == 0x0001B8, "Wrong size on ULPlatformSystem");
static_assert(offsetof(ULPlatformSystem, OnNeowizAuth) == 0x000078, "Member 'ULPlatformSystem::OnNeowizAuth' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, bCompleteNeowizAuth) == 0x000088, "Member 'ULPlatformSystem::bCompleteNeowizAuth' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NWZ_Auth_ID) == 0x000090, "Member 'ULPlatformSystem::NWZ_Auth_ID' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NWZ_Auth_PW) == 0x0000A0, "Member 'ULPlatformSystem::NWZ_Auth_PW' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NWZ_Auth_Token) == 0x0000B0, "Member 'ULPlatformSystem::NWZ_Auth_Token' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NWZ_Auth_ExternalAccount) == 0x0000C0, "Member 'ULPlatformSystem::NWZ_Auth_ExternalAccount' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NWZ_LogKey) == 0x0000C8, "Member 'ULPlatformSystem::NWZ_LogKey' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NeowizAuthInterval) == 0x0000D8, "Member 'ULPlatformSystem::NeowizAuthInterval' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, NeowizAuthTimerHandle) == 0x0000E0, "Member 'ULPlatformSystem::NeowizAuthTimerHandle' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, ActivityObjectID) == 0x0000E8, "Member 'ULPlatformSystem::ActivityObjectID' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, ActivityTaskIDs) == 0x0000F8, "Member 'ULPlatformSystem::ActivityTaskIDs' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, StoreCategory) == 0x000108, "Member 'ULPlatformSystem::StoreCategory' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, StoreProductId) == 0x000118, "Member 'ULPlatformSystem::StoreProductId' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, Cache_RefreshPlatformAchievements) == 0x000130, "Member 'ULPlatformSystem::Cache_RefreshPlatformAchievements' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, RequestAchievementArray) == 0x000138, "Member 'ULPlatformSystem::RequestAchievementArray' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, bShutdown) == 0x0001B0, "Member 'ULPlatformSystem::bShutdown' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, bLaunchActivity) == 0x0001B1, "Member 'ULPlatformSystem::bLaunchActivity' has a wrong offset!");
static_assert(offsetof(ULPlatformSystem, LaunchActivityErrorType) == 0x0001B2, "Member 'ULPlatformSystem::LaunchActivityErrorType' has a wrong offset!");

// Class ProjectP.LEnvVolumeActor
// 0x0078 (0x02B0 - 0x0238)
class ALEnvVolumeActor : public ALVolume
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPostProcessComponent*                 PostProcessSource;                                 // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPostProcessComponent*                 PostProcessTarget;                                 // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class ULEnvSettings*>       EnvSettings;                                       // 0x0260(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LEnvVolumeActor">();
	}
	static class ALEnvVolumeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALEnvVolumeActor>();
	}
};
static_assert(alignof(ALEnvVolumeActor) == 0x000008, "Wrong alignment on ALEnvVolumeActor");
static_assert(sizeof(ALEnvVolumeActor) == 0x0002B0, "Wrong size on ALEnvVolumeActor");
static_assert(offsetof(ALEnvVolumeActor, PostProcessSource) == 0x000240, "Member 'ALEnvVolumeActor::PostProcessSource' has a wrong offset!");
static_assert(offsetof(ALEnvVolumeActor, PostProcessTarget) == 0x000248, "Member 'ALEnvVolumeActor::PostProcessTarget' has a wrong offset!");
static_assert(offsetof(ALEnvVolumeActor, Priority) == 0x000250, "Member 'ALEnvVolumeActor::Priority' has a wrong offset!");
static_assert(offsetof(ALEnvVolumeActor, BlendRadius) == 0x000254, "Member 'ALEnvVolumeActor::BlendRadius' has a wrong offset!");
static_assert(offsetof(ALEnvVolumeActor, BlendWeight) == 0x000258, "Member 'ALEnvVolumeActor::BlendWeight' has a wrong offset!");
static_assert(offsetof(ALEnvVolumeActor, EnvSettings) == 0x000260, "Member 'ALEnvVolumeActor::EnvSettings' has a wrong offset!");

// Class ProjectP.LGlobalEnvActor
// 0x0440 (0x0620 - 0x01E0)
class ALGlobalEnvActor : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULEnvRootComponent*                     DummyRoot;                                         // 0x01E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        StaticScene;                                       // 0x01F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MovableScene;                                      // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPostProcessComponent*                 PostProcessSource;                                 // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPostProcessComponent*                 PostProcessTarget;                                 // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             DirectionalLight;                                  // 0x0210(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             DirectionalLightNoShadow;                          // 0x0218(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             DirectionalLightCharacter;                         // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkyLightComponent*                     SkyLight;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   SkySphere;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExponentialHeightFogComponent*         HeightFog;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SkyMI;                                             // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MPC;                                               // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDayTimeType                                  DayTime;                                           // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LowerHemisphereColor;                              // 0x0254(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               SkyMID;                                            // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollectionInstance*   MPCInst;                                           // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlayerCameraLocation;                              // 0x0278(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayerCamera;                                  // 0x0284(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveEnvironment;                                // 0x0285(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286[0x2];                                      // 0x0286(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class ULEnvSettings*>       EnvSettings;                                       // 0x0288(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   CurrentSetting;                                    // 0x02D8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrevSetting;                                       // 0x02E0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendAlpha;                                        // 0x02E8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendDuration;                                     // 0x02EC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QueuedSetting;                                     // 0x02F0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueuedBlendDuration;                               // 0x02F8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLDirectionalLightSettings             Blended_DirectionalLight;                          // 0x02FC(0x005C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLDirectionalLightNoShadowSettings     Blended_DirectionalLightNoShadow;                  // 0x0358(0x002C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLDirectionalLightNoShadowSettings     Blended_DirectionalLightCharacter;                 // 0x0384(0x002C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSkyLightSettings                     Blended_SkyLight;                                  // 0x03B0(0x001C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLHeightFogSettings                    Blended_HeightFog;                                 // 0x03CC(0x006C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSkySphereSettings                    Blended_SkySphere;                                 // 0x0438(0x0094)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLCloudSettings                        Blended_Cloud;                                     // 0x04CC(0x008C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLWeatherSettings                      Blended_Weather;                                   // 0x0558(0x0040)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FLLightningSettings                    Blended_Lightning;                                 // 0x0598(0x0074)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendWeightAccumed;                                // 0x060C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableShadowDistanceFading(bool Enable);
	bool GetEditorCameraPosition(struct FVector* OutCameraPostion);
	bool IsBlending();
	void OnSetActiveEnvironment(bool Active);
	void OnStartPostProcessing_BP();
	void SetPreviewTarget(int32 Index_0);
	void SpawnCustomLightning(float Delay, float Direction, float Intensity, float Distance, float Height);
	void StartBlend(class FName TargetName, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGlobalEnvActor">();
	}
	static class ALGlobalEnvActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGlobalEnvActor>();
	}
};
static_assert(alignof(ALGlobalEnvActor) == 0x000008, "Wrong alignment on ALGlobalEnvActor");
static_assert(sizeof(ALGlobalEnvActor) == 0x000620, "Wrong size on ALGlobalEnvActor");
static_assert(offsetof(ALGlobalEnvActor, DummyRoot) == 0x0001E8, "Member 'ALGlobalEnvActor::DummyRoot' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, StaticScene) == 0x0001F0, "Member 'ALGlobalEnvActor::StaticScene' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, MovableScene) == 0x0001F8, "Member 'ALGlobalEnvActor::MovableScene' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, PostProcessSource) == 0x000200, "Member 'ALGlobalEnvActor::PostProcessSource' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, PostProcessTarget) == 0x000208, "Member 'ALGlobalEnvActor::PostProcessTarget' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, DirectionalLight) == 0x000210, "Member 'ALGlobalEnvActor::DirectionalLight' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, DirectionalLightNoShadow) == 0x000218, "Member 'ALGlobalEnvActor::DirectionalLightNoShadow' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, DirectionalLightCharacter) == 0x000220, "Member 'ALGlobalEnvActor::DirectionalLightCharacter' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, SkyLight) == 0x000228, "Member 'ALGlobalEnvActor::SkyLight' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, SkySphere) == 0x000230, "Member 'ALGlobalEnvActor::SkySphere' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, HeightFog) == 0x000238, "Member 'ALGlobalEnvActor::HeightFog' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, SkyMI) == 0x000240, "Member 'ALGlobalEnvActor::SkyMI' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, MPC) == 0x000248, "Member 'ALGlobalEnvActor::MPC' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, DayTime) == 0x000250, "Member 'ALGlobalEnvActor::DayTime' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, LowerHemisphereColor) == 0x000254, "Member 'ALGlobalEnvActor::LowerHemisphereColor' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, SkyMID) == 0x000268, "Member 'ALGlobalEnvActor::SkyMID' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, MPCInst) == 0x000270, "Member 'ALGlobalEnvActor::MPCInst' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, PlayerCameraLocation) == 0x000278, "Member 'ALGlobalEnvActor::PlayerCameraLocation' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, bHasPlayerCamera) == 0x000284, "Member 'ALGlobalEnvActor::bHasPlayerCamera' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, bActiveEnvironment) == 0x000285, "Member 'ALGlobalEnvActor::bActiveEnvironment' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, EnvSettings) == 0x000288, "Member 'ALGlobalEnvActor::EnvSettings' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, CurrentSetting) == 0x0002D8, "Member 'ALGlobalEnvActor::CurrentSetting' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, PrevSetting) == 0x0002E0, "Member 'ALGlobalEnvActor::PrevSetting' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, BlendAlpha) == 0x0002E8, "Member 'ALGlobalEnvActor::BlendAlpha' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, BlendDuration) == 0x0002EC, "Member 'ALGlobalEnvActor::BlendDuration' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, QueuedSetting) == 0x0002F0, "Member 'ALGlobalEnvActor::QueuedSetting' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, QueuedBlendDuration) == 0x0002F8, "Member 'ALGlobalEnvActor::QueuedBlendDuration' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_DirectionalLight) == 0x0002FC, "Member 'ALGlobalEnvActor::Blended_DirectionalLight' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_DirectionalLightNoShadow) == 0x000358, "Member 'ALGlobalEnvActor::Blended_DirectionalLightNoShadow' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_DirectionalLightCharacter) == 0x000384, "Member 'ALGlobalEnvActor::Blended_DirectionalLightCharacter' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_SkyLight) == 0x0003B0, "Member 'ALGlobalEnvActor::Blended_SkyLight' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_HeightFog) == 0x0003CC, "Member 'ALGlobalEnvActor::Blended_HeightFog' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_SkySphere) == 0x000438, "Member 'ALGlobalEnvActor::Blended_SkySphere' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_Cloud) == 0x0004CC, "Member 'ALGlobalEnvActor::Blended_Cloud' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_Weather) == 0x000558, "Member 'ALGlobalEnvActor::Blended_Weather' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, Blended_Lightning) == 0x000598, "Member 'ALGlobalEnvActor::Blended_Lightning' has a wrong offset!");
static_assert(offsetof(ALGlobalEnvActor, BlendWeightAccumed) == 0x00060C, "Member 'ALGlobalEnvActor::BlendWeightAccumed' has a wrong offset!");

// Class ProjectP.LSlaveArmInfo
// 0x0038 (0x0060 - 0x0028)
class ULSlaveArmInfo final : public UObject
{
public:
	uint8                                         Pad_28[0xC];                                       // 0x0028(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CodeName;                                          // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent;                             // 0x003C(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULPartsAttachInfo*>              AttachInfoList;                                    // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         bEnableWeaponItemPreload : 1;                      // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSlaveArmInfo">();
	}
	static class ULSlaveArmInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSlaveArmInfo>();
	}
};
static_assert(alignof(ULSlaveArmInfo) == 0x000008, "Wrong alignment on ULSlaveArmInfo");
static_assert(sizeof(ULSlaveArmInfo) == 0x000060, "Wrong size on ULSlaveArmInfo");
static_assert(offsetof(ULSlaveArmInfo, CodeName) == 0x000034, "Member 'ULSlaveArmInfo::CodeName' has a wrong offset!");
static_assert(offsetof(ULSlaveArmInfo, SkeletalMeshComponent) == 0x00003C, "Member 'ULSlaveArmInfo::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ULSlaveArmInfo, AttachInfoList) == 0x000048, "Member 'ULSlaveArmInfo::AttachInfoList' has a wrong offset!");

// Class ProjectP.LAITargetPointComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULAITargetPointComponent final : public USceneComponent
{
public:
	ELAITargetPointType                           TargetPointType;                                   // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAITargetPointComponent">();
	}
	static class ULAITargetPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAITargetPointComponent>();
	}
};
static_assert(alignof(ULAITargetPointComponent) == 0x000010, "Wrong alignment on ULAITargetPointComponent");
static_assert(sizeof(ULAITargetPointComponent) == 0x0001F0, "Wrong size on ULAITargetPointComponent");
static_assert(offsetof(ULAITargetPointComponent, TargetPointType) == 0x0001E8, "Member 'ULAITargetPointComponent::TargetPointType' has a wrong offset!");

// Class ProjectP.LPartsAttachInfo
// 0x0008 (0x0030 - 0x0028)
class ULPartsAttachInfo final : public UObject
{
public:
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent;                             // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPartsAttachInfo">();
	}
	static class ULPartsAttachInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPartsAttachInfo>();
	}
};
static_assert(alignof(ULPartsAttachInfo) == 0x000008, "Wrong alignment on ULPartsAttachInfo");
static_assert(sizeof(ULPartsAttachInfo) == 0x000030, "Wrong size on ULPartsAttachInfo");
static_assert(offsetof(ULPartsAttachInfo, SkeletalMeshComponent) == 0x000028, "Member 'ULPartsAttachInfo::SkeletalMeshComponent' has a wrong offset!");

// Class ProjectP.LNPCSpecConditionHP
// 0x0008 (0x0038 - 0x0030)
class ULNPCSpecConditionHP final : public ULNPCSpecConditionBase
{
public:
	int32                                         PercentHP;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckOnce;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecConditionHP">();
	}
	static class ULNPCSpecConditionHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecConditionHP>();
	}
};
static_assert(alignof(ULNPCSpecConditionHP) == 0x000008, "Wrong alignment on ULNPCSpecConditionHP");
static_assert(sizeof(ULNPCSpecConditionHP) == 0x000038, "Wrong size on ULNPCSpecConditionHP");
static_assert(offsetof(ULNPCSpecConditionHP, PercentHP) == 0x000030, "Member 'ULNPCSpecConditionHP::PercentHP' has a wrong offset!");
static_assert(offsetof(ULNPCSpecConditionHP, bCheckOnce) == 0x000034, "Member 'ULNPCSpecConditionHP::bCheckOnce' has a wrong offset!");

// Class ProjectP.LEquipmentComponent
// 0x01C0 (0x0270 - 0x00B0)
class ULEquipmentComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnWeaponStateChanged;                              // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartsMeshChanged;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         bEnableWeaponItemPreload : 1;                      // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdateWeaponOnOff : 1;                            // 0x00D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Current_Mesh_Body;                                 // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Current_Mesh_Mask;                                 // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          Current_Mesh_Eyewear;                              // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FLWeaponBuildData>         WeaponBuildDatas;                                  // 0x00F8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         ExtraWeaponSetupIndex;                             // 0x0148(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C[0x14];                                     // 0x014C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedWeaponIndex;                               // 0x0160(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FLSlaveArmBuildData>       SlaveArmBuildDatas;                                // 0x0168(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectedSlaveArmIndex;                             // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLWeaponTransformData>          WeaponTransformDatas;                              // 0x01C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLDecoMeshData>      DecoMeshDatas;                                     // 0x01D0(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLHitMeshParts>      HitMeshPartsList;                                  // 0x0220(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddNpcHitParts(class FName NpcPartsCodeName, class FName SkillCodeNameOnDestroy, class UPrimitiveComponent* Primitive, bool bPartsEnableWhenSpawn);
	void ChangeTransformWeapon(ELWeaponAttachPointType MasterWeaponAttachPoint, ELWeaponAttachPointType WeaponAttachPoint1, class FName WeaponHandleCodeName1, class FName WeaponBladeCodeName1, ELWeaponAttachPointType WeaponAttachPoint2, class FName WeaponHandleCodeName2, class FName WeaponBladeCodeName2);
	bool CheckHitPartsWeakElement(class FName HitPartsName, const struct FLCalcDamageData& CalcDamageData);
	class UShapeComponent* CreateDecoShape(class FName MeshName, const struct FVector& Size, class FName AttachSocketName, const struct FRotator& Rotation, bool bResponseCollision, bool bDebugDraw);
	class UStaticMeshComponent* CreateDecoStaticMesh(class FName MeshName, class UStaticMesh* StaticMesh, class FName AttachSocketName, bool bResponseCollision, bool bDisappear);
	void DeactivatePartsAll();
	void DestroyDecoMesh(class FName MeshName);
	void DoHeadCostumeOff(bool DoOff);
	void DropDecoMeshes();
	class UStaticMeshComponent* DropPhysicsDecoStaticMesh(class FName MeshName, bool IgnorePawn);
	void DropPickedWeapon(ELWeaponAttachPointType AttachPointType);
	void DropPickedWeaponAll();
	class UStaticMeshComponent* FindDecoStaticMesh(class FName MeshName);
	class ALPartsActor* FindPartsActor(int32 PartsIndex);
	class ULPartsComponent* FindPartsCompByAttachPoint(ELPartsAttachPointType AttachPointType);
	class ULPartsComponent* FindPartsCompByLinkBodyBone(class FName BoneName);
	class ULPartsComponent* FindPartsCompByNPCPartsCodeName(class FName NpcPartsCodeName);
	class FName GetHitPartsNameByPrimitive(class UPrimitiveComponent* Primitive);
	class ULPartsComponent* GetPartsComp(int32 PartsIndex);
	class ALWeapon* GetPickedWeaponActor(ELWeaponAttachPointType AttachPointType);
	class ALWeapon* GetSelectedWeaponActor();
	int32 GetSelectedWeaponIndex();
	class ULSlaveArmInfo* GetSlaveArmInfo();
	class ALWeapon* GetWeaponActor(int32 Index_0);
	class ALWeapon* GetWeaponByComponent(class UPrimitiveComponent* Component);
	class ALWeapon* GetWeaponByULItem(class ULItem* Item);
	class ULWeaponItem* GetWeaponItem(int32 Index_0);
	bool HasDecoMeshResponseCollision(class UPrimitiveComponent* PrimitiveComponent);
	bool IsDecoMesh(class UPrimitiveComponent* MeshComponent);
	bool IsHitPartsByPrimitive(class UPrimitiveComponent* Primitive);
	class ALWeapon* PickWeapon(ELWeaponAttachPointType AttachPointType, int32 Index_0, ELPickWeaponChangeMotionType ChangeMotionType);
	void ResetDeco(class FName MeshName);
	class UStaticMeshComponent* ResetDecoStaticMesh(class FName MeshName);
	void ResetWeapon(int32 Index_0);
	void ResetWeaponAll();
	void RespawnWeaponByItem(class ULItem* Item);
	void SelectSlaveArm(int32 Index_0);
	void SelectWeapon(int32 Index_0);
	void SetDecoHidden(class FName MeshName, bool bHidden);
	void SetDecoNoCollsion(class FName MeshName);
	void SetParts(class ULItem* Item);
	void SetSlaveArmByItem(int32 Index_0, class ULItem* Item);
	void SetWeaponByItem(int32 Index_0, class ULItem* Item);
	void SetWeaponByItemWeaponMonster(int32 Index_0, class FName ItemWeaponMonsterCodeName);
	class ALWeapon* SpawnWeapon();
	class ALWeapon* SpawnWeaponWithClass(TSubclassOf<class ALWeapon> HandleWeaponClass, TSubclassOf<class ALWeapon> BladeWeaponClass);
	void UnChangeTransformWeapon(ELWeaponAttachPointType OriginalWeaponAttachPoint);
	void UnPickWeapon(ELWeaponAttachPointType AttachPointType, ELPickWeaponChangeMotionType ChangeMotionType);
	void WeaponOff(ELWeaponAttachPointType AttachPointType);
	void WeaponOn(ELWeaponAttachPointType AttachPointType);
	void WeaponOnOffOwnerHidden(bool bOnOff);

	bool CheckHitPartsRepulseHitRangeAngle(class FName HitPartsName, class AActor* Attacker, class AActor* Victim) const;
	bool CheckHitPartsRepulseLevel(class FName HitPartsName, ELPhysicalDamageType InPhysicalDamageType, int32 InAttackRepulseLevel) const;
	class USkeletalMesh* GetCurrentMeshBody() const;
	class FName GetHitPartsSkillCodeNameOnDestory(class FName HitPartsName) const;
	TArray<class ULPartsComponent*> GetPartsComponents() const;
	class FName GetWeakElementSkillCodeName(class FName HitPartsName) const;
	bool IsBodyNeedShrink() const;
	bool IsHitPartsDestoryed(class FName HitPartsName) const;
	bool IsHitPartsEnabled(class FName HitPartsName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LEquipmentComponent">();
	}
	static class ULEquipmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULEquipmentComponent>();
	}
};
static_assert(alignof(ULEquipmentComponent) == 0x000008, "Wrong alignment on ULEquipmentComponent");
static_assert(sizeof(ULEquipmentComponent) == 0x000270, "Wrong size on ULEquipmentComponent");
static_assert(offsetof(ULEquipmentComponent, OnWeaponStateChanged) == 0x0000B0, "Member 'ULEquipmentComponent::OnWeaponStateChanged' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, OnPartsMeshChanged) == 0x0000C0, "Member 'ULEquipmentComponent::OnPartsMeshChanged' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, Current_Mesh_Body) == 0x0000D8, "Member 'ULEquipmentComponent::Current_Mesh_Body' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, Current_Mesh_Mask) == 0x0000E0, "Member 'ULEquipmentComponent::Current_Mesh_Mask' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, Current_Mesh_Eyewear) == 0x0000E8, "Member 'ULEquipmentComponent::Current_Mesh_Eyewear' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, WeaponBuildDatas) == 0x0000F8, "Member 'ULEquipmentComponent::WeaponBuildDatas' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, ExtraWeaponSetupIndex) == 0x000148, "Member 'ULEquipmentComponent::ExtraWeaponSetupIndex' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, SelectedWeaponIndex) == 0x000160, "Member 'ULEquipmentComponent::SelectedWeaponIndex' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, SlaveArmBuildDatas) == 0x000168, "Member 'ULEquipmentComponent::SlaveArmBuildDatas' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, SelectedSlaveArmIndex) == 0x0001B8, "Member 'ULEquipmentComponent::SelectedSlaveArmIndex' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, WeaponTransformDatas) == 0x0001C0, "Member 'ULEquipmentComponent::WeaponTransformDatas' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, DecoMeshDatas) == 0x0001D0, "Member 'ULEquipmentComponent::DecoMeshDatas' has a wrong offset!");
static_assert(offsetof(ULEquipmentComponent, HitMeshPartsList) == 0x000220, "Member 'ULEquipmentComponent::HitMeshPartsList' has a wrong offset!");

// Class ProjectP.LEventDispatcherSystem
// 0x0730 (0x07A8 - 0x0078)
class ULEventDispatcherSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnSpawnActor;                                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeGameState;                                 // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             YouDieToReStart;                                   // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnYouDie;                                          // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ApplyLoadedGameDataAccount;                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ApplyLoadedGameDataCharacter;                      // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetActiveEnvironment;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeLevelPuppetKing;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeLevelRaxasia;                              // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeLevelSimon;                                // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleteAsyncPreLoad;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndAsyncPreLoadScene;                            // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGainExp;                                         // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGainFrenzyPoint;                                 // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStaminaConsume;                                  // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedSlaveMagazine;                            // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlaveArmUsableStateChange;                       // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeWeapon;                                    // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGainItem;                                        // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGainWeapon;                                      // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMaxOrb;                                          // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshOrb;                                      // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateWeaponSharpness;                           // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateFrenzyPoint;                               // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeFrenzyMode;                                // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuartzSlotInstalled;                             // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuartzSynergyActivated;                          // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleAbnormalPassiveUI;                        // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleSpecialBuffUI;                            // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFableBuffEnable;                                 // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeadBoss;                                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeadBossUIEnd;                                   // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeOutSequence;                                 // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeOutSequence_Finished;                        // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReadyHUD;                                        // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshHealthPower;                              // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshDeathCount;                               // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshReceiveDamage;                            // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshPlayTime;                                 // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleInteractionUI;                            // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnableInteractionUI;                             // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleGuideUI;                                  // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimerGuideUI;                                    // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTutorialMessageUI;                               // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnErgoDropAcquisition;                             // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnErgoDropChange;                                  // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleHudBossHPBar;                             // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddFatalIndicator;                               // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveFatalIndicator;                            // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIHUDUpdateWeapon;                                 // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIMsgYouDie;                                       // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIMsgYouDieEnd;                                    // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeBlackOn;                                     // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeBlackOff;                                    // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeOutHUD;                                      // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeOutHUD_Finished;                             // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeInHUD;                                       // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIFadeInHUD_Finished;                              // 0x0408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIMsgCurrentLocation;                              // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIUpdateCurrentSoul;                               // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIUpdateCharacterStat;                             // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIConfirmCharacterStat;                            // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIChangeFirstStat;                                 // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIUpdateSecondStat;                                // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIActiveLevelUpWidget;                             // 0x0478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIGuardExCoolTimeStarted;                          // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UISettingInputBlock;                               // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UILobbyProcessEnd;                                 // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIConfirmTeleport;                                 // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBackToLatestTorsionCoil;                         // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBackToHotelTorsionCoil;                          // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIActivateTorsionCoil;                             // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UICompleteTorsionCoilActiveAlert;                  // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIHelpMatePopupResult;                             // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIUpdateCurrentHumanity;                           // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIHumanityAcquisitionPopup;                        // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIHumanityAcquisitionPopupEnded;                   // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIRecordHumanityAcquisition;                       // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIBuildupPCAbnormal;                               // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIVisibleAbnormalDuration;                         // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIHUDEvent;                                        // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIReadLetterEvent;                                 // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIPressAssistUseItemTriggerKey;                    // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIOnPlayMonolog;                                   // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIOnStopMonolog;                                   // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UICrossHairVisibleChanged;                         // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIShowNewGamePlus;                                 // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIConfirmNewGamePlus;                              // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIPlayerSpawnFailedMessage;                        // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIChangedScreenResolution;                         // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIApplyGoldenTreeBoost;                            // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UISlaveArmAmmoChanged;                             // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIPressShotgunAmmoPouch;                           // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShotGunAmmoChanged;                              // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAcidSpreadingModeChanged;                        // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFlameThrowerExplosionEnableStateChanged;         // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLieDialogStart;                                  // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLieDialogEnd;                                    // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOverlapTrainingArea;                             // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleHelpmateHPBar;                            // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProtectErgoDropChanged;                          // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowSubtitle;                                    // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLoadedCharacterSaveData;                         // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowControlGuide;                                // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayingSlavearmAction;                           // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExecuteTeleport;                                 // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecollectionEnterPressed;                        // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecollectionClosePressed;                        // 0x0728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UIDialogInputBlock;                                // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeatherChanged;                                  // 0x0748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeWeaponFableSkill;                          // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCaptureMomentCondition;                          // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_780[0x28];                                     // 0x0780(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureMomentCondition(const struct FMomentConditionCaptureInfo& CapturedInfo, class AActor* Owner);
	void OnUIConfirmNewGamePlus(bool IsConfirm);
	void OnUIMsgYouDieEnd();
	void RaiseSenseToActor(class AActor* Reciever, const struct FLAISenseTakeLocation& TakeLocation);
	void RaiseSenseToActors(const struct FLAISenseTakeLocation& TakeLocation);
	void SendHelpSignal(class AActor* Target, float OverrideRange);
	void SenseTargetToActor(class AActor* Reciever, ELAISense Sense, class AActor* Target);
	void SenseTargetToCharacters(ELAISense Sense, class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LEventDispatcherSystem">();
	}
	static class ULEventDispatcherSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULEventDispatcherSystem>();
	}
};
static_assert(alignof(ULEventDispatcherSystem) == 0x000008, "Wrong alignment on ULEventDispatcherSystem");
static_assert(sizeof(ULEventDispatcherSystem) == 0x0007A8, "Wrong size on ULEventDispatcherSystem");
static_assert(offsetof(ULEventDispatcherSystem, OnSpawnActor) == 0x000078, "Member 'ULEventDispatcherSystem::OnSpawnActor' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeGameState) == 0x000088, "Member 'ULEventDispatcherSystem::OnChangeGameState' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, YouDieToReStart) == 0x000098, "Member 'ULEventDispatcherSystem::YouDieToReStart' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnYouDie) == 0x0000A8, "Member 'ULEventDispatcherSystem::OnYouDie' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, ApplyLoadedGameDataAccount) == 0x0000B8, "Member 'ULEventDispatcherSystem::ApplyLoadedGameDataAccount' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, ApplyLoadedGameDataCharacter) == 0x0000C8, "Member 'ULEventDispatcherSystem::ApplyLoadedGameDataCharacter' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnSetActiveEnvironment) == 0x0000D8, "Member 'ULEventDispatcherSystem::OnSetActiveEnvironment' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeLevelPuppetKing) == 0x0000E8, "Member 'ULEventDispatcherSystem::OnChangeLevelPuppetKing' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeLevelRaxasia) == 0x0000F8, "Member 'ULEventDispatcherSystem::OnChangeLevelRaxasia' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeLevelSimon) == 0x000108, "Member 'ULEventDispatcherSystem::OnChangeLevelSimon' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnCompleteAsyncPreLoad) == 0x000118, "Member 'ULEventDispatcherSystem::OnCompleteAsyncPreLoad' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnEndAsyncPreLoadScene) == 0x000128, "Member 'ULEventDispatcherSystem::OnEndAsyncPreLoadScene' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnGainExp) == 0x000138, "Member 'ULEventDispatcherSystem::OnGainExp' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnGainFrenzyPoint) == 0x000148, "Member 'ULEventDispatcherSystem::OnGainFrenzyPoint' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnStaminaConsume) == 0x000158, "Member 'ULEventDispatcherSystem::OnStaminaConsume' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangedSlaveMagazine) == 0x000168, "Member 'ULEventDispatcherSystem::OnChangedSlaveMagazine' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnSlaveArmUsableStateChange) == 0x000178, "Member 'ULEventDispatcherSystem::OnSlaveArmUsableStateChange' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeWeapon) == 0x000188, "Member 'ULEventDispatcherSystem::OnChangeWeapon' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnGainItem) == 0x000198, "Member 'ULEventDispatcherSystem::OnGainItem' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnGainWeapon) == 0x0001A8, "Member 'ULEventDispatcherSystem::OnGainWeapon' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnMaxOrb) == 0x0001B8, "Member 'ULEventDispatcherSystem::OnMaxOrb' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRefreshOrb) == 0x0001C8, "Member 'ULEventDispatcherSystem::OnRefreshOrb' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnUpdateWeaponSharpness) == 0x0001D8, "Member 'ULEventDispatcherSystem::OnUpdateWeaponSharpness' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnUpdateFrenzyPoint) == 0x0001E8, "Member 'ULEventDispatcherSystem::OnUpdateFrenzyPoint' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeFrenzyMode) == 0x0001F8, "Member 'ULEventDispatcherSystem::OnChangeFrenzyMode' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnQuartzSlotInstalled) == 0x000208, "Member 'ULEventDispatcherSystem::OnQuartzSlotInstalled' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnQuartzSynergyActivated) == 0x000218, "Member 'ULEventDispatcherSystem::OnQuartzSynergyActivated' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnVisibleAbnormalPassiveUI) == 0x000228, "Member 'ULEventDispatcherSystem::OnVisibleAbnormalPassiveUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnVisibleSpecialBuffUI) == 0x000238, "Member 'ULEventDispatcherSystem::OnVisibleSpecialBuffUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnFableBuffEnable) == 0x000248, "Member 'ULEventDispatcherSystem::OnFableBuffEnable' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnDeadBoss) == 0x000258, "Member 'ULEventDispatcherSystem::OnDeadBoss' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnDeadBossUIEnd) == 0x000268, "Member 'ULEventDispatcherSystem::OnDeadBossUIEnd' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeOutSequence) == 0x000278, "Member 'ULEventDispatcherSystem::UIFadeOutSequence' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeOutSequence_Finished) == 0x000288, "Member 'ULEventDispatcherSystem::UIFadeOutSequence_Finished' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnReadyHUD) == 0x000298, "Member 'ULEventDispatcherSystem::OnReadyHUD' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRefreshHealthPower) == 0x0002A8, "Member 'ULEventDispatcherSystem::OnRefreshHealthPower' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRefreshDeathCount) == 0x0002B8, "Member 'ULEventDispatcherSystem::OnRefreshDeathCount' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRefreshReceiveDamage) == 0x0002C8, "Member 'ULEventDispatcherSystem::OnRefreshReceiveDamage' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRefreshPlayTime) == 0x0002D8, "Member 'ULEventDispatcherSystem::OnRefreshPlayTime' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnVisibleInteractionUI) == 0x0002E8, "Member 'ULEventDispatcherSystem::OnVisibleInteractionUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnEnableInteractionUI) == 0x0002F8, "Member 'ULEventDispatcherSystem::OnEnableInteractionUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnVisibleGuideUI) == 0x000308, "Member 'ULEventDispatcherSystem::OnVisibleGuideUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnTimerGuideUI) == 0x000318, "Member 'ULEventDispatcherSystem::OnTimerGuideUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnTutorialMessageUI) == 0x000328, "Member 'ULEventDispatcherSystem::OnTutorialMessageUI' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnErgoDropAcquisition) == 0x000338, "Member 'ULEventDispatcherSystem::OnErgoDropAcquisition' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnErgoDropChange) == 0x000348, "Member 'ULEventDispatcherSystem::OnErgoDropChange' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnVisibleHudBossHPBar) == 0x000358, "Member 'ULEventDispatcherSystem::OnVisibleHudBossHPBar' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnAddFatalIndicator) == 0x000368, "Member 'ULEventDispatcherSystem::OnAddFatalIndicator' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRemoveFatalIndicator) == 0x000378, "Member 'ULEventDispatcherSystem::OnRemoveFatalIndicator' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIHUDUpdateWeapon) == 0x000388, "Member 'ULEventDispatcherSystem::UIHUDUpdateWeapon' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIMsgYouDie) == 0x000398, "Member 'ULEventDispatcherSystem::UIMsgYouDie' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIMsgYouDieEnd) == 0x0003A8, "Member 'ULEventDispatcherSystem::UIMsgYouDieEnd' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeBlackOn) == 0x0003B8, "Member 'ULEventDispatcherSystem::UIFadeBlackOn' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeBlackOff) == 0x0003C8, "Member 'ULEventDispatcherSystem::UIFadeBlackOff' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeOutHUD) == 0x0003D8, "Member 'ULEventDispatcherSystem::UIFadeOutHUD' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeOutHUD_Finished) == 0x0003E8, "Member 'ULEventDispatcherSystem::UIFadeOutHUD_Finished' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeInHUD) == 0x0003F8, "Member 'ULEventDispatcherSystem::UIFadeInHUD' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIFadeInHUD_Finished) == 0x000408, "Member 'ULEventDispatcherSystem::UIFadeInHUD_Finished' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIMsgCurrentLocation) == 0x000418, "Member 'ULEventDispatcherSystem::UIMsgCurrentLocation' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIUpdateCurrentSoul) == 0x000428, "Member 'ULEventDispatcherSystem::UIUpdateCurrentSoul' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIUpdateCharacterStat) == 0x000438, "Member 'ULEventDispatcherSystem::UIUpdateCharacterStat' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIConfirmCharacterStat) == 0x000448, "Member 'ULEventDispatcherSystem::UIConfirmCharacterStat' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIChangeFirstStat) == 0x000458, "Member 'ULEventDispatcherSystem::UIChangeFirstStat' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIUpdateSecondStat) == 0x000468, "Member 'ULEventDispatcherSystem::UIUpdateSecondStat' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIActiveLevelUpWidget) == 0x000478, "Member 'ULEventDispatcherSystem::UIActiveLevelUpWidget' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIGuardExCoolTimeStarted) == 0x000488, "Member 'ULEventDispatcherSystem::UIGuardExCoolTimeStarted' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UISettingInputBlock) == 0x000498, "Member 'ULEventDispatcherSystem::UISettingInputBlock' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UILobbyProcessEnd) == 0x0004A8, "Member 'ULEventDispatcherSystem::UILobbyProcessEnd' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIConfirmTeleport) == 0x0004B8, "Member 'ULEventDispatcherSystem::UIConfirmTeleport' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnBackToLatestTorsionCoil) == 0x0004C8, "Member 'ULEventDispatcherSystem::OnBackToLatestTorsionCoil' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnBackToHotelTorsionCoil) == 0x0004D8, "Member 'ULEventDispatcherSystem::OnBackToHotelTorsionCoil' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIActivateTorsionCoil) == 0x0004E8, "Member 'ULEventDispatcherSystem::UIActivateTorsionCoil' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UICompleteTorsionCoilActiveAlert) == 0x0004F8, "Member 'ULEventDispatcherSystem::UICompleteTorsionCoilActiveAlert' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIHelpMatePopupResult) == 0x000508, "Member 'ULEventDispatcherSystem::UIHelpMatePopupResult' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIUpdateCurrentHumanity) == 0x000518, "Member 'ULEventDispatcherSystem::UIUpdateCurrentHumanity' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIHumanityAcquisitionPopup) == 0x000528, "Member 'ULEventDispatcherSystem::UIHumanityAcquisitionPopup' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIHumanityAcquisitionPopupEnded) == 0x000538, "Member 'ULEventDispatcherSystem::UIHumanityAcquisitionPopupEnded' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIRecordHumanityAcquisition) == 0x000548, "Member 'ULEventDispatcherSystem::UIRecordHumanityAcquisition' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIBuildupPCAbnormal) == 0x000558, "Member 'ULEventDispatcherSystem::UIBuildupPCAbnormal' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIVisibleAbnormalDuration) == 0x000568, "Member 'ULEventDispatcherSystem::UIVisibleAbnormalDuration' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIHUDEvent) == 0x000578, "Member 'ULEventDispatcherSystem::UIHUDEvent' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIReadLetterEvent) == 0x000588, "Member 'ULEventDispatcherSystem::UIReadLetterEvent' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIPressAssistUseItemTriggerKey) == 0x000598, "Member 'ULEventDispatcherSystem::UIPressAssistUseItemTriggerKey' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIOnPlayMonolog) == 0x0005A8, "Member 'ULEventDispatcherSystem::UIOnPlayMonolog' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIOnStopMonolog) == 0x0005B8, "Member 'ULEventDispatcherSystem::UIOnStopMonolog' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UICrossHairVisibleChanged) == 0x0005C8, "Member 'ULEventDispatcherSystem::UICrossHairVisibleChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIShowNewGamePlus) == 0x0005D8, "Member 'ULEventDispatcherSystem::UIShowNewGamePlus' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIConfirmNewGamePlus) == 0x0005E8, "Member 'ULEventDispatcherSystem::UIConfirmNewGamePlus' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIPlayerSpawnFailedMessage) == 0x0005F8, "Member 'ULEventDispatcherSystem::UIPlayerSpawnFailedMessage' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIChangedScreenResolution) == 0x000608, "Member 'ULEventDispatcherSystem::UIChangedScreenResolution' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIApplyGoldenTreeBoost) == 0x000618, "Member 'ULEventDispatcherSystem::UIApplyGoldenTreeBoost' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UISlaveArmAmmoChanged) == 0x000628, "Member 'ULEventDispatcherSystem::UISlaveArmAmmoChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIPressShotgunAmmoPouch) == 0x000638, "Member 'ULEventDispatcherSystem::UIPressShotgunAmmoPouch' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnShotGunAmmoChanged) == 0x000648, "Member 'ULEventDispatcherSystem::OnShotGunAmmoChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnAcidSpreadingModeChanged) == 0x000658, "Member 'ULEventDispatcherSystem::OnAcidSpreadingModeChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnFlameThrowerExplosionEnableStateChanged) == 0x000668, "Member 'ULEventDispatcherSystem::OnFlameThrowerExplosionEnableStateChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnLieDialogStart) == 0x000678, "Member 'ULEventDispatcherSystem::OnLieDialogStart' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnLieDialogEnd) == 0x000688, "Member 'ULEventDispatcherSystem::OnLieDialogEnd' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnOverlapTrainingArea) == 0x000698, "Member 'ULEventDispatcherSystem::OnOverlapTrainingArea' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnVisibleHelpmateHPBar) == 0x0006A8, "Member 'ULEventDispatcherSystem::OnVisibleHelpmateHPBar' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnProtectErgoDropChanged) == 0x0006B8, "Member 'ULEventDispatcherSystem::OnProtectErgoDropChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnShowSubtitle) == 0x0006C8, "Member 'ULEventDispatcherSystem::OnShowSubtitle' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnLoadedCharacterSaveData) == 0x0006D8, "Member 'ULEventDispatcherSystem::OnLoadedCharacterSaveData' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnShowControlGuide) == 0x0006E8, "Member 'ULEventDispatcherSystem::OnShowControlGuide' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnPlayingSlavearmAction) == 0x0006F8, "Member 'ULEventDispatcherSystem::OnPlayingSlavearmAction' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnExecuteTeleport) == 0x000708, "Member 'ULEventDispatcherSystem::OnExecuteTeleport' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRecollectionEnterPressed) == 0x000718, "Member 'ULEventDispatcherSystem::OnRecollectionEnterPressed' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnRecollectionClosePressed) == 0x000728, "Member 'ULEventDispatcherSystem::OnRecollectionClosePressed' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, UIDialogInputBlock) == 0x000738, "Member 'ULEventDispatcherSystem::UIDialogInputBlock' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnWeatherChanged) == 0x000748, "Member 'ULEventDispatcherSystem::OnWeatherChanged' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnChangeWeaponFableSkill) == 0x000758, "Member 'ULEventDispatcherSystem::OnChangeWeaponFableSkill' has a wrong offset!");
static_assert(offsetof(ULEventDispatcherSystem, OnCaptureMomentCondition) == 0x000770, "Member 'ULEventDispatcherSystem::OnCaptureMomentCondition' has a wrong offset!");

// Class ProjectP.LExiledNpcArea
// 0x00A8 (0x0308 - 0x0260)
class ALExiledNpcArea final : public ALLevelObject
{
public:
	class ALExiledNPCSpot*                        OwnerExiledNPCSpot;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_Warning_Inner;                                // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_Warning_Outer;                                // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_IsolateBarrier;                               // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_IsolateBarrierEffect;                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root_IsolateBarrierForCamera;                      // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x78];                                     // 0x0290(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapped_Warning_Inner(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentBeginOverlapped_Warning_Outer(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentEndOverlapped_Warning_Inner(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnComponentEndOverlapped_Warning_Outer(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LExiledNpcArea">();
	}
	static class ALExiledNpcArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALExiledNpcArea>();
	}
};
static_assert(alignof(ALExiledNpcArea) == 0x000008, "Wrong alignment on ALExiledNpcArea");
static_assert(sizeof(ALExiledNpcArea) == 0x000308, "Wrong size on ALExiledNpcArea");
static_assert(offsetof(ALExiledNpcArea, OwnerExiledNPCSpot) == 0x000260, "Member 'ALExiledNpcArea::OwnerExiledNPCSpot' has a wrong offset!");
static_assert(offsetof(ALExiledNpcArea, Root_Warning_Inner) == 0x000268, "Member 'ALExiledNpcArea::Root_Warning_Inner' has a wrong offset!");
static_assert(offsetof(ALExiledNpcArea, Root_Warning_Outer) == 0x000270, "Member 'ALExiledNpcArea::Root_Warning_Outer' has a wrong offset!");
static_assert(offsetof(ALExiledNpcArea, Root_IsolateBarrier) == 0x000278, "Member 'ALExiledNpcArea::Root_IsolateBarrier' has a wrong offset!");
static_assert(offsetof(ALExiledNpcArea, Root_IsolateBarrierEffect) == 0x000280, "Member 'ALExiledNpcArea::Root_IsolateBarrierEffect' has a wrong offset!");
static_assert(offsetof(ALExiledNpcArea, Root_IsolateBarrierForCamera) == 0x000288, "Member 'ALExiledNpcArea::Root_IsolateBarrierForCamera' has a wrong offset!");

// Class ProjectP.LObjectPoolInterface
// 0x0000 (0x0028 - 0x0028)
class ILObjectPoolInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LObjectPoolInterface">();
	}
	static class ILObjectPoolInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILObjectPoolInterface>();
	}
};
static_assert(alignof(ILObjectPoolInterface) == 0x000008, "Wrong alignment on ILObjectPoolInterface");
static_assert(sizeof(ILObjectPoolInterface) == 0x000028, "Wrong size on ILObjectPoolInterface");

// Class ProjectP.LExiledNPCSpot
// 0x0008 (0x0420 - 0x0418)
class ALExiledNPCSpot final : public ALNPCSpot
{
public:
	class FName                                   ExiledNpcSpot_CodeName;                            // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LExiledNPCSpot">();
	}
	static class ALExiledNPCSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALExiledNPCSpot>();
	}
};
static_assert(alignof(ALExiledNPCSpot) == 0x000008, "Wrong alignment on ALExiledNPCSpot");
static_assert(sizeof(ALExiledNPCSpot) == 0x000420, "Wrong size on ALExiledNPCSpot");
static_assert(offsetof(ALExiledNPCSpot, ExiledNpcSpot_CodeName) == 0x000418, "Member 'ALExiledNPCSpot::ExiledNpcSpot_CodeName' has a wrong offset!");

// Class ProjectP.LLogObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ILLogObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLogObjectInterface">();
	}
	static class ILLogObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILLogObjectInterface>();
	}
};
static_assert(alignof(ILLogObjectInterface) == 0x000008, "Wrong alignment on ILLogObjectInterface");
static_assert(sizeof(ILLogObjectInterface) == 0x000028, "Wrong size on ILLogObjectInterface");

// Class ProjectP.LExiledNpcSystemData
// 0x00E8 (0x02C8 - 0x01E0)
class ALExiledNpcSystemData : public AActor
{
public:
	struct FExiledNpcContextInfo                  ContextInfo;                                       // 0x01E0(0x00E0)(Edit, EditConst, NativeAccessSpecifierPublic)
	float                                         NextMsgBlockingTime;                               // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LExiledNpcSystemData">();
	}
	static class ALExiledNpcSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALExiledNpcSystemData>();
	}
};
static_assert(alignof(ALExiledNpcSystemData) == 0x000008, "Wrong alignment on ALExiledNpcSystemData");
static_assert(sizeof(ALExiledNpcSystemData) == 0x0002C8, "Wrong size on ALExiledNpcSystemData");
static_assert(offsetof(ALExiledNpcSystemData, ContextInfo) == 0x0001E0, "Member 'ALExiledNpcSystemData::ContextInfo' has a wrong offset!");
static_assert(offsetof(ALExiledNpcSystemData, NextMsgBlockingTime) == 0x0002C0, "Member 'ALExiledNpcSystemData::NextMsgBlockingTime' has a wrong offset!");

// Class ProjectP.LExiledNpcSystem
// 0x0120 (0x0198 - 0x0078)
class ULExiledNpcSystem final : public ULGameSubSystem
{
public:
	int32                                         NumberOfExiledNpc;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExiledNpcContextInfo                  ContextInfo;                                       // 0x0080(0x00E0)(Edit, EditConst, NativeAccessSpecifierPrivate)
	class ALExiledNpcSystemData*                  ExiledNpcSystemData;                               // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLPreloadBox                           PreloadInstance;                                   // 0x0168(0x0030)(Transient, NativeAccessSpecifierPrivate)

public:
	bool MakeNewContextBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LExiledNpcSystem">();
	}
	static class ULExiledNpcSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULExiledNpcSystem>();
	}
};
static_assert(alignof(ULExiledNpcSystem) == 0x000008, "Wrong alignment on ULExiledNpcSystem");
static_assert(sizeof(ULExiledNpcSystem) == 0x000198, "Wrong size on ULExiledNpcSystem");
static_assert(offsetof(ULExiledNpcSystem, NumberOfExiledNpc) == 0x000078, "Member 'ULExiledNpcSystem::NumberOfExiledNpc' has a wrong offset!");
static_assert(offsetof(ULExiledNpcSystem, ContextInfo) == 0x000080, "Member 'ULExiledNpcSystem::ContextInfo' has a wrong offset!");
static_assert(offsetof(ULExiledNpcSystem, ExiledNpcSystemData) == 0x000160, "Member 'ULExiledNpcSystem::ExiledNpcSystemData' has a wrong offset!");
static_assert(offsetof(ULExiledNpcSystem, PreloadInstance) == 0x000168, "Member 'ULExiledNpcSystem::PreloadInstance' has a wrong offset!");

// Class ProjectP.LExplodeSkeletalMeshComponent
// 0x0010 (0x0ED0 - 0x0EC0)
class ULExplodeSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	ELExplosionMeshType                           ExplosionMeshType;                                 // 0x0EB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB9[0x17];                                     // 0x0EB9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LExplodeSkeletalMeshComponent">();
	}
	static class ULExplodeSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULExplodeSkeletalMeshComponent>();
	}
};
static_assert(alignof(ULExplodeSkeletalMeshComponent) == 0x000010, "Wrong alignment on ULExplodeSkeletalMeshComponent");
static_assert(sizeof(ULExplodeSkeletalMeshComponent) == 0x000ED0, "Wrong size on ULExplodeSkeletalMeshComponent");
static_assert(offsetof(ULExplodeSkeletalMeshComponent, ExplosionMeshType) == 0x000EB8, "Member 'ULExplodeSkeletalMeshComponent::ExplosionMeshType' has a wrong offset!");

// Class ProjectP.LPropDoorSpot
// 0x0010 (0x0360 - 0x0350)
class ALPropDoorSpot : public ALPropSpot
{
public:
	class ULPropBlockingVolumeComponent*          BlockingVolumeComp;                                // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropDoorSpot">();
	}
	static class ALPropDoorSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropDoorSpot>();
	}
};
static_assert(alignof(ALPropDoorSpot) == 0x000008, "Wrong alignment on ALPropDoorSpot");
static_assert(sizeof(ALPropDoorSpot) == 0x000360, "Wrong size on ALPropDoorSpot");
static_assert(offsetof(ALPropDoorSpot, BlockingVolumeComp) == 0x000350, "Member 'ALPropDoorSpot::BlockingVolumeComp' has a wrong offset!");

// Class ProjectP.LFrenzyComponent
// 0x0028 (0x00D8 - 0x00B0)
class ULFrenzyComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFrenzyEffectData>             RemainEffectList;                                  // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateFrenzy();
	void DeactivateFrenzy(bool bExhaustAllFrenzyPoint);
	void OnFrenzySkillEnded();
	void OnFrenzySkillUsed();

	bool IsActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFrenzyComponent">();
	}
	static class ULFrenzyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULFrenzyComponent>();
	}
};
static_assert(alignof(ULFrenzyComponent) == 0x000008, "Wrong alignment on ULFrenzyComponent");
static_assert(sizeof(ULFrenzyComponent) == 0x0000D8, "Wrong size on ULFrenzyComponent");
static_assert(offsetof(ULFrenzyComponent, RemainEffectList) == 0x0000B8, "Member 'ULFrenzyComponent::RemainEffectList' has a wrong offset!");

// Class ProjectP.LNPCSpotTriggerComponent
// 0x0020 (0x0490 - 0x0470)
class ULNPCSpotTriggerComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_468[0x9];                                      // 0x0468(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	ELNPCSpotTriggerType                          TriggerType;                                       // 0x0471(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_472[0x2];                                      // 0x0472(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerDelay;                                      // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   NpcSkillCodeName;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLNpcSpotWakeUpData                    WakeUpData;                                        // 0x0480(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapSpotTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRemovePauseAI();
	void OnSpotTriggerRetry();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpotTriggerComponent">();
	}
	static class ULNPCSpotTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpotTriggerComponent>();
	}
};
static_assert(alignof(ULNPCSpotTriggerComponent) == 0x000010, "Wrong alignment on ULNPCSpotTriggerComponent");
static_assert(sizeof(ULNPCSpotTriggerComponent) == 0x000490, "Wrong size on ULNPCSpotTriggerComponent");
static_assert(offsetof(ULNPCSpotTriggerComponent, TriggerType) == 0x000471, "Member 'ULNPCSpotTriggerComponent::TriggerType' has a wrong offset!");
static_assert(offsetof(ULNPCSpotTriggerComponent, TriggerDelay) == 0x000474, "Member 'ULNPCSpotTriggerComponent::TriggerDelay' has a wrong offset!");
static_assert(offsetof(ULNPCSpotTriggerComponent, NpcSkillCodeName) == 0x000478, "Member 'ULNPCSpotTriggerComponent::NpcSkillCodeName' has a wrong offset!");
static_assert(offsetof(ULNPCSpotTriggerComponent, WakeUpData) == 0x000480, "Member 'ULNPCSpotTriggerComponent::WakeUpData' has a wrong offset!");

// Class ProjectP.LMaterialVarying
// 0x0048 (0x0070 - 0x0028)
class ULMaterialVarying final : public UObject
{
public:
	TArray<class UMaterialInterface*>             BaseMaterials;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, AssetRegistrySearchable, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           MaterialSlotNames;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TimeScale;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLMaterialVaryingScalar>        ScalarValues;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLMaterialVaryingColor>         ColorValues;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMaterialVarying">();
	}
	static class ULMaterialVarying* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULMaterialVarying>();
	}
};
static_assert(alignof(ULMaterialVarying) == 0x000008, "Wrong alignment on ULMaterialVarying");
static_assert(sizeof(ULMaterialVarying) == 0x000070, "Wrong size on ULMaterialVarying");
static_assert(offsetof(ULMaterialVarying, BaseMaterials) == 0x000028, "Member 'ULMaterialVarying::BaseMaterials' has a wrong offset!");
static_assert(offsetof(ULMaterialVarying, MaterialSlotNames) == 0x000038, "Member 'ULMaterialVarying::MaterialSlotNames' has a wrong offset!");
static_assert(offsetof(ULMaterialVarying, TimeScale) == 0x000048, "Member 'ULMaterialVarying::TimeScale' has a wrong offset!");
static_assert(offsetof(ULMaterialVarying, ScalarValues) == 0x000050, "Member 'ULMaterialVarying::ScalarValues' has a wrong offset!");
static_assert(offsetof(ULMaterialVarying, ColorValues) == 0x000060, "Member 'ULMaterialVarying::ColorValues' has a wrong offset!");

// Class ProjectP.LFXVaryingComponent
// 0x0070 (0x0120 - 0x00B0)
class ULFXVaryingComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCompletePlayMaterialVarying;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLMaterialVaryingPlayer>        MaterialVaryings;                                  // 0x0110(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool IsPlayingVaryingName(class FName PlayName);
	void PlayVaryingWithMesh(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, class UMeshComponent* MeshComp, bool bResetToDefault, class FName PlayName);
	void PlayVaryingWithMeshes(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, const TArray<class UMeshComponent*>& MeshComps, bool bResetToDefault, class FName PlayName);
	void StopVaryingAll(bool bResetToDefault);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFXVaryingComponent">();
	}
	static class ULFXVaryingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULFXVaryingComponent>();
	}
};
static_assert(alignof(ULFXVaryingComponent) == 0x000008, "Wrong alignment on ULFXVaryingComponent");
static_assert(sizeof(ULFXVaryingComponent) == 0x000120, "Wrong size on ULFXVaryingComponent");
static_assert(offsetof(ULFXVaryingComponent, OnCompletePlayMaterialVarying) == 0x0000B0, "Member 'ULFXVaryingComponent::OnCompletePlayMaterialVarying' has a wrong offset!");
static_assert(offsetof(ULFXVaryingComponent, MaterialVaryings) == 0x000110, "Member 'ULFXVaryingComponent::MaterialVaryings' has a wrong offset!");

// Class ProjectP.LWeaponFXVaryingComponent
// 0x0010 (0x0130 - 0x0120)
class ULWeaponFXVaryingComponent final : public ULFXVaryingComponent
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMaterialFx(class FName InMaterialFxCodename, class UMeshComponent* MeshComp);
	void RemoveMaterialFx(class FName InMaterialFxCodename, class UMeshComponent* MeshComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponFXVaryingComponent">();
	}
	static class ULWeaponFXVaryingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWeaponFXVaryingComponent>();
	}
};
static_assert(alignof(ULWeaponFXVaryingComponent) == 0x000008, "Wrong alignment on ULWeaponFXVaryingComponent");
static_assert(sizeof(ULWeaponFXVaryingComponent) == 0x000130, "Wrong size on ULWeaponFXVaryingComponent");

// Class ProjectP.LPropItemSpot
// 0x0028 (0x0378 - 0x0350)
class ALPropItemSpot : public ALPropShapeObjectSpot
{
public:
	class FName                                   ItemPackageCodeName;                               // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentItemPackageCodeName;                        // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemExist;                                         // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x17];                                     // 0x0361(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropItemSpot">();
	}
	static class ALPropItemSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropItemSpot>();
	}
};
static_assert(alignof(ALPropItemSpot) == 0x000008, "Wrong alignment on ALPropItemSpot");
static_assert(sizeof(ALPropItemSpot) == 0x000378, "Wrong size on ALPropItemSpot");
static_assert(offsetof(ALPropItemSpot, ItemPackageCodeName) == 0x000350, "Member 'ALPropItemSpot::ItemPackageCodeName' has a wrong offset!");
static_assert(offsetof(ALPropItemSpot, CurrentItemPackageCodeName) == 0x000358, "Member 'ALPropItemSpot::CurrentItemPackageCodeName' has a wrong offset!");
static_assert(offsetof(ALPropItemSpot, ItemExist) == 0x000360, "Member 'ALPropItemSpot::ItemExist' has a wrong offset!");

// Class ProjectP.LManagedNiagaraComponent
// 0x0000 (0x0610 - 0x0610)
class ULManagedNiagaraComponent final : public UNiagaraComponent
{
public:
	ELManagedNiagaraUsage                         Usage;                                             // 0x0608(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x7];                                      // 0x0609(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LManagedNiagaraComponent">();
	}
	static class ULManagedNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULManagedNiagaraComponent>();
	}
};
static_assert(alignof(ULManagedNiagaraComponent) == 0x000010, "Wrong alignment on ULManagedNiagaraComponent");
static_assert(sizeof(ULManagedNiagaraComponent) == 0x000610, "Wrong size on ULManagedNiagaraComponent");
static_assert(offsetof(ULManagedNiagaraComponent, Usage) == 0x000608, "Member 'ULManagedNiagaraComponent::Usage' has a wrong offset!");

// Class ProjectP.LNPCCharacter
// 0x0790 (0x1430 - 0x0CA0)
class ALNPCCharacter : public ALCharacter
{
public:
	class FName                                   SpawnIdleActionGroup;                              // 0x0CA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PathWayCodeName;                                   // 0x0CA8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveByPathWayOnSpawn;                             // 0x0CB0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerPathWay;                                   // 0x0CB1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFloatingStateOnSpawn : 1;                         // 0x0CB2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFloatingStateCeiling : 1;                         // 0x0CB2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFloatingStateLanding : 1;                         // 0x0CB2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAIPauseOnSpawn : 1;                               // 0x0CB2(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSleepOnSpawn : 1;                                 // 0x0CB2(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableSenseOnSpawnIdle : 1;                      // 0x0CB2(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSeeThroughPC : 1;                                 // 0x0CB2(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bImportantNPC : 1;                                 // 0x0CB2(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableCantMove : 1;                              // 0x0CB3(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideBossHPIfSpawnDistanceFar : 1;                 // 0x0CB3(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FLAbnormalCodeNameType                 ImmuneAbnormalCodename;                            // 0x0CB4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CBC[0x4];                                      // 0x0CBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLAbnormalCodeNameType>         ImmuneAbnormalCodenames;                           // 0x0CC0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class ALNPCController*                        NPCController;                                     // 0x0CD0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULHeadTagComponent*                     HeadTagComponent;                                  // 0x0CD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshOffset;                                        // 0x0CE0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcTableID;                                        // 0x0CEC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF4[0x4];                                      // 0x0CF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNPCInfoPtr                            NPCInfo;                                           // 0x0CF8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FNPCStatInfoPtr                        NPCStatInfo;                                       // 0x0D00(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   HitMotionReplaceGroupCodeName;                     // 0x0D08(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLMonsterCameraModifier                MonsterCameraModifier;                             // 0x0D10(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLMonsterLockOnCameraModifiers> MonsterLockOnCameraModifiers;                      // 0x0D30(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FLNPCAimToTarget                       AimToTarget;                                       // 0x0D80(0x0028)(Edit, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA8[0x4];                                      // 0x0DA8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatingStateCeilingCapsuleHalfHeight;             // 0x0DAC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB0[0x8];                                      // 0x0DB0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseMovementDesiredRotation;                       // 0x0DB8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB9[0x3];                                      // 0x0DB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveToActorAcceptanceRadius;                       // 0x0DBC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathDirect_OverrideRadius;                         // 0x0DC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathDirect_TraceOffsetZ;                           // 0x0DC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerceptionSight_TraceOffsetZ;                      // 0x0DC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerceptionSight_AngleOffset;                       // 0x0DCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_RF_Start;                                   // 0x0DD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_RB_Start;                                   // 0x0DD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_BR_Start;                                   // 0x0DD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_BL_Start;                                   // 0x0DDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_LB_Start;                                   // 0x0DE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_LF_Start;                                   // 0x0DE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDIR_FL_Start;                                   // 0x0DE8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AlwaysExplosiveKill : 1;                           // 0x0DEC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         AlwaysExplosiveKill_ExceptNonePhysicalDamage : 1;  // 0x0DEC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ModifyCustomCameraShake : 1;                       // 0x0DEC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_DED[0x3];                                      // 0x0DED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExplosiveCameraShakeCustom;                        // 0x0DF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AlwaysExplosiveKill_SkillHit;                      // 0x0DF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explosive_Kill_Power_Light;                        // 0x0E00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explosive_Kill_Power_Medium;                       // 0x0E04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explosive_Kill_Power_Heavy;                        // 0x0E08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0C[0x4];                                      // 0x0E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Explosive_FxSocketNameArray;                       // 0x0E10(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLFatalAttackCounterEnableInfo         FatalAttackCounterEnableInfo;                      // 0x0E20(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_IndicatorUISocketName;                 // 0x0E38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LocationPivot_Override;                // 0x0E40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LookAtTriangle_Bottom_Override;        // 0x0E48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LookAtTriangle_Top_R_Override;         // 0x0E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalSocket_LookAtTriangle_Top_L_Override;         // 0x0E58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatalAttack_EnableHeight_Up;                       // 0x0E60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatalAttack_EnableHeight_Down;                     // 0x0E64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatalAttack_CapsuleBackAngle_Start;                // 0x0E68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatalAttack_CapsuleBackAngle_End;                  // 0x0E6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo;                                   // 0x0E70(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFatalAttackInfo                      FatalAttackInfo_Add;                               // 0x0EC4(0x0054)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim_BeforeHit;                // 0x0F18(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim;                          // 0x0F20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim_End;                      // 0x0F28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F30[0x4];                                      // 0x0F30(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Replace_GroggyLoopCodeName;                        // 0x0F34(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3C[0x4];                                      // 0x0F3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnParalyzeEnable;                                  // 0x0F40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGroggy;                                          // 0x0F50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         Current_GroggyEnable_Duration;                     // 0x0F60(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Current_GroggyEnable_ElapsedTime;                  // 0x0F64(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cached_GroggyEnableRetainTime;                     // 0x0F68(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdjustGauge_Count_Groggy;                          // 0x0F6C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLGroggyPointAdjustRatio>       Cached_GroggyPointAdjustRatioArray;                // 0x0F70(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         Cached_GroggyPointAdjustRatioIndex;                // 0x0F80(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F84[0x4];                                      // 0x0F84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      AdjustDuration_Count_Debuff;                       // 0x0F88(0x0050)(Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSleepState;                                      // 0x0FD8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndSpawnIdle;                                    // 0x0FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleElementalDuration;                        // 0x0FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibleHelpmateAbnormal;                         // 0x1008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         DeadBossAlertTime;                                 // 0x1018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InactiveDistanceFromPlayer_Override;               // 0x101C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Default_ActionGroupCodeName;                       // 0x1020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Phase_ActionGroupCodeName;                         // 0x1028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Floating_ActionGroupCodeName;                      // 0x1030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALNPCSpot>               OwnerNpcSpot;                                      // 0x1038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatStateTime;                                   // 0x1040(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLCharacterExitFunction                ExitFunction;                                      // 0x1044(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1058[0x8];                                     // 0x1058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSectionRotationSpeed                 SectionRotationSpeed;                              // 0x1060(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_106C[0x318];                                   // 0x106C(0x0318)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ExecuteDieEvent;                                   // 0x1384(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExecuteErgoDrop;                                   // 0x1385(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1386[0x1];                                     // 0x1386(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ELHPUIType                                    HPUIType;                                          // 0x1387(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegainHP;                                          // 0x1388(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegainHPRecoveryTime;                              // 0x138C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1390[0x8];                                     // 0x1390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DelegateUI_OnChangedCombatState;                   // 0x1398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DelegateUI_OnVisibleHeadTag;                       // 0x13A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLNPCShareData                         NPCShareData;                                      // 0x13B8(0x0050)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLRootMotionJumpContext>        RootMotionJumpContextList;                         // 0x1408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1418[0x18];                                    // 0x1418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeCurrentLocationToHomeLocation();
	void ChangePhase(class FName ActionGroupTableCodeName);
	void DeadCharacterBP();
	void DoExitFunctionTimeDespawn(float Time);
	void DoExitFunctionTimeInvisible(float Time);
	void DoExitFunctionTimeLookHide(float Time, class ULMaterialVarying* HideVarying);
	void DoPlay_RedButterfly(float StartDelay);
	bool FindRootMotionJumpContext(class FName SkillCodeName, struct FLRootMotionJumpContext* OutContext);
	bool HasShareData_Event(class FName EventName);
	void HeadTagBindingBP();
	void HeadTagSettingBP();
	void HeadTagVisibility(bool InVisibility);
	void InitPhase();
	bool IsPlaying_RedButterfly();
	void OnActiveGroupping_RedButterfly(class ALNPCSpot* InGrouppingPropVolume);
	void OnChangePhase(class FName ActionGroupTableCodeName, class FName CommonActionPath, class FName LocomotoinActionPath);
	void OnExitCharacter();
	void OnGroggyOccurred(bool IsStarted);
	void OnRespawnBP();
	void OnSleepStateChanged(bool bSleepState);
	void OnStartAI();
	void OnSwapNPC(class ALNPCCharacter* BeforeNPC, class ALNPCCharacter* AfterNPC);
	void OnWatchActionStateAfterRemove(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair);
	void OnWatchActionStateBeforeAdd(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair);
	class ULActBase* PlayAction_CommonMontage(class FName CommonMontageCodeName);
	class ULActBase* PlayAction_RotationToAngle(float YawAngle);
	class ULActBase* PlayAction_RotationToHome();
	class ULActBase* PlayAction_RotationToTarget(float CoolTime, float PlaySpeed);
	class ULActBase* PlayAction_SpawnIdle();
	class ULActBase* PlayAction_TalkerIdle();
	class ULActBase* PlaySkill(class FName SkillCodeName);
	void SetCombatStateBP(bool bCombatState);
	void SetGroggyPointAdjustRatio(const TArray<struct FLGroggyPointAdjustRatio>& Override);
	void SetScarecrow(const class FString& Command);
	void SetShareData_Event(class FName EventName);
	void SetVisibleHPBar(bool IsVisible, bool IsCombatState);
	void StartExitNPCFunctions();
	void StopAction_SpawnIdle();
	void SwapNpc(const class FName& NPCCodeName, const struct FVector& SpawnOffset, bool bInheritHP, bool bForceSpawn, bool bResetSwapAtRespawn, bool bSpawnOnSpot);
	bool TryGroggy(int32 ConsumePoint, bool CheckOnly);
	bool TryGroggyEnableTimeAdd(float Time);
	bool TrySuppressGroggy();

	bool CheckHitRepulse(ELPhysicalDamageType InPhyscialDamageType, int32 InAttackRepulseLevel) const;
	bool CheckPartsHitRepulse(ELPhysicalDamageType InPhyscialDamageType, int32 InAttackRepulseLevel, class FName HitPartsName) const;
	float GetMoveSpeed() const;
	class FName GetNPCInfoActionGroupCodeName() const;
	float GetScaledFloatingStateCeilingCapsuleHalfHeight() const;
	float GetSightDistance() const;
	float GetTargetDetectRange() const;
	bool IsCombatState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCCharacter">();
	}
	static class ALNPCCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALNPCCharacter>();
	}
};
static_assert(alignof(ALNPCCharacter) == 0x000010, "Wrong alignment on ALNPCCharacter");
static_assert(sizeof(ALNPCCharacter) == 0x001430, "Wrong size on ALNPCCharacter");
static_assert(offsetof(ALNPCCharacter, SpawnIdleActionGroup) == 0x000CA0, "Member 'ALNPCCharacter::SpawnIdleActionGroup' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, PathWayCodeName) == 0x000CA8, "Member 'ALNPCCharacter::PathWayCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, bMoveByPathWayOnSpawn) == 0x000CB0, "Member 'ALNPCCharacter::bMoveByPathWayOnSpawn' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, bTriggerPathWay) == 0x000CB1, "Member 'ALNPCCharacter::bTriggerPathWay' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, ImmuneAbnormalCodename) == 0x000CB4, "Member 'ALNPCCharacter::ImmuneAbnormalCodename' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, ImmuneAbnormalCodenames) == 0x000CC0, "Member 'ALNPCCharacter::ImmuneAbnormalCodenames' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCController) == 0x000CD0, "Member 'ALNPCCharacter::NPCController' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, HeadTagComponent) == 0x000CD8, "Member 'ALNPCCharacter::HeadTagComponent' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, MeshOffset) == 0x000CE0, "Member 'ALNPCCharacter::MeshOffset' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NpcTableID) == 0x000CEC, "Member 'ALNPCCharacter::NpcTableID' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCInfo) == 0x000CF8, "Member 'ALNPCCharacter::NPCInfo' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCStatInfo) == 0x000D00, "Member 'ALNPCCharacter::NPCStatInfo' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, HitMotionReplaceGroupCodeName) == 0x000D08, "Member 'ALNPCCharacter::HitMotionReplaceGroupCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, MonsterCameraModifier) == 0x000D10, "Member 'ALNPCCharacter::MonsterCameraModifier' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, MonsterLockOnCameraModifiers) == 0x000D30, "Member 'ALNPCCharacter::MonsterLockOnCameraModifiers' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, AimToTarget) == 0x000D80, "Member 'ALNPCCharacter::AimToTarget' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FloatingStateCeilingCapsuleHalfHeight) == 0x000DAC, "Member 'ALNPCCharacter::FloatingStateCeilingCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, bUseMovementDesiredRotation) == 0x000DB8, "Member 'ALNPCCharacter::bUseMovementDesiredRotation' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, MoveToActorAcceptanceRadius) == 0x000DBC, "Member 'ALNPCCharacter::MoveToActorAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, PathDirect_OverrideRadius) == 0x000DC0, "Member 'ALNPCCharacter::PathDirect_OverrideRadius' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, PathDirect_TraceOffsetZ) == 0x000DC4, "Member 'ALNPCCharacter::PathDirect_TraceOffsetZ' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, PerceptionSight_TraceOffsetZ) == 0x000DC8, "Member 'ALNPCCharacter::PerceptionSight_TraceOffsetZ' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, PerceptionSight_AngleOffset) == 0x000DCC, "Member 'ALNPCCharacter::PerceptionSight_AngleOffset' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_RF_Start) == 0x000DD0, "Member 'ALNPCCharacter::NPCDIR_RF_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_RB_Start) == 0x000DD4, "Member 'ALNPCCharacter::NPCDIR_RB_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_BR_Start) == 0x000DD8, "Member 'ALNPCCharacter::NPCDIR_BR_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_BL_Start) == 0x000DDC, "Member 'ALNPCCharacter::NPCDIR_BL_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_LB_Start) == 0x000DE0, "Member 'ALNPCCharacter::NPCDIR_LB_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_LF_Start) == 0x000DE4, "Member 'ALNPCCharacter::NPCDIR_LF_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCDIR_FL_Start) == 0x000DE8, "Member 'ALNPCCharacter::NPCDIR_FL_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, ExplosiveCameraShakeCustom) == 0x000DF0, "Member 'ALNPCCharacter::ExplosiveCameraShakeCustom' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, AlwaysExplosiveKill_SkillHit) == 0x000DF8, "Member 'ALNPCCharacter::AlwaysExplosiveKill_SkillHit' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Explosive_Kill_Power_Light) == 0x000E00, "Member 'ALNPCCharacter::Explosive_Kill_Power_Light' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Explosive_Kill_Power_Medium) == 0x000E04, "Member 'ALNPCCharacter::Explosive_Kill_Power_Medium' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Explosive_Kill_Power_Heavy) == 0x000E08, "Member 'ALNPCCharacter::Explosive_Kill_Power_Heavy' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Explosive_FxSocketNameArray) == 0x000E10, "Member 'ALNPCCharacter::Explosive_FxSocketNameArray' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttackCounterEnableInfo) == 0x000E20, "Member 'ALNPCCharacter::FatalAttackCounterEnableInfo' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_IndicatorUISocketName) == 0x000E38, "Member 'ALNPCCharacter::FatalAttack_IndicatorUISocketName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalSocket_LocationPivot_Override) == 0x000E40, "Member 'ALNPCCharacter::FatalSocket_LocationPivot_Override' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalSocket_LookAtTriangle_Bottom_Override) == 0x000E48, "Member 'ALNPCCharacter::FatalSocket_LookAtTriangle_Bottom_Override' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalSocket_LookAtTriangle_Top_R_Override) == 0x000E50, "Member 'ALNPCCharacter::FatalSocket_LookAtTriangle_Top_R_Override' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalSocket_LookAtTriangle_Top_L_Override) == 0x000E58, "Member 'ALNPCCharacter::FatalSocket_LookAtTriangle_Top_L_Override' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_EnableHeight_Up) == 0x000E60, "Member 'ALNPCCharacter::FatalAttack_EnableHeight_Up' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_EnableHeight_Down) == 0x000E64, "Member 'ALNPCCharacter::FatalAttack_EnableHeight_Down' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_CapsuleBackAngle_Start) == 0x000E68, "Member 'ALNPCCharacter::FatalAttack_CapsuleBackAngle_Start' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_CapsuleBackAngle_End) == 0x000E6C, "Member 'ALNPCCharacter::FatalAttack_CapsuleBackAngle_End' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttackInfo) == 0x000E70, "Member 'ALNPCCharacter::FatalAttackInfo' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttackInfo_Add) == 0x000EC4, "Member 'ALNPCCharacter::FatalAttackInfo_Add' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_ReplacedAnim_BeforeHit) == 0x000F18, "Member 'ALNPCCharacter::FatalAttack_ReplacedAnim_BeforeHit' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_ReplacedAnim) == 0x000F20, "Member 'ALNPCCharacter::FatalAttack_ReplacedAnim' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, FatalAttack_ReplacedAnim_End) == 0x000F28, "Member 'ALNPCCharacter::FatalAttack_ReplacedAnim_End' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Replace_GroggyLoopCodeName) == 0x000F34, "Member 'ALNPCCharacter::Replace_GroggyLoopCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OnParalyzeEnable) == 0x000F40, "Member 'ALNPCCharacter::OnParalyzeEnable' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OnGroggy) == 0x000F50, "Member 'ALNPCCharacter::OnGroggy' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Current_GroggyEnable_Duration) == 0x000F60, "Member 'ALNPCCharacter::Current_GroggyEnable_Duration' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Current_GroggyEnable_ElapsedTime) == 0x000F64, "Member 'ALNPCCharacter::Current_GroggyEnable_ElapsedTime' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Cached_GroggyEnableRetainTime) == 0x000F68, "Member 'ALNPCCharacter::Cached_GroggyEnableRetainTime' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, AdjustGauge_Count_Groggy) == 0x000F6C, "Member 'ALNPCCharacter::AdjustGauge_Count_Groggy' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Cached_GroggyPointAdjustRatioArray) == 0x000F70, "Member 'ALNPCCharacter::Cached_GroggyPointAdjustRatioArray' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Cached_GroggyPointAdjustRatioIndex) == 0x000F80, "Member 'ALNPCCharacter::Cached_GroggyPointAdjustRatioIndex' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, AdjustDuration_Count_Debuff) == 0x000F88, "Member 'ALNPCCharacter::AdjustDuration_Count_Debuff' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OnSleepState) == 0x000FD8, "Member 'ALNPCCharacter::OnSleepState' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OnEndSpawnIdle) == 0x000FE8, "Member 'ALNPCCharacter::OnEndSpawnIdle' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OnVisibleElementalDuration) == 0x000FF8, "Member 'ALNPCCharacter::OnVisibleElementalDuration' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OnVisibleHelpmateAbnormal) == 0x001008, "Member 'ALNPCCharacter::OnVisibleHelpmateAbnormal' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, DeadBossAlertTime) == 0x001018, "Member 'ALNPCCharacter::DeadBossAlertTime' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, InactiveDistanceFromPlayer_Override) == 0x00101C, "Member 'ALNPCCharacter::InactiveDistanceFromPlayer_Override' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Default_ActionGroupCodeName) == 0x001020, "Member 'ALNPCCharacter::Default_ActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Phase_ActionGroupCodeName) == 0x001028, "Member 'ALNPCCharacter::Phase_ActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, Floating_ActionGroupCodeName) == 0x001030, "Member 'ALNPCCharacter::Floating_ActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, OwnerNpcSpot) == 0x001038, "Member 'ALNPCCharacter::OwnerNpcSpot' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, CombatStateTime) == 0x001040, "Member 'ALNPCCharacter::CombatStateTime' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, ExitFunction) == 0x001044, "Member 'ALNPCCharacter::ExitFunction' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, SectionRotationSpeed) == 0x001060, "Member 'ALNPCCharacter::SectionRotationSpeed' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, ExecuteDieEvent) == 0x001384, "Member 'ALNPCCharacter::ExecuteDieEvent' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, ExecuteErgoDrop) == 0x001385, "Member 'ALNPCCharacter::ExecuteErgoDrop' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, HPUIType) == 0x001387, "Member 'ALNPCCharacter::HPUIType' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, RegainHP) == 0x001388, "Member 'ALNPCCharacter::RegainHP' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, RegainHPRecoveryTime) == 0x00138C, "Member 'ALNPCCharacter::RegainHPRecoveryTime' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, DelegateUI_OnChangedCombatState) == 0x001398, "Member 'ALNPCCharacter::DelegateUI_OnChangedCombatState' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, DelegateUI_OnVisibleHeadTag) == 0x0013A8, "Member 'ALNPCCharacter::DelegateUI_OnVisibleHeadTag' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, NPCShareData) == 0x0013B8, "Member 'ALNPCCharacter::NPCShareData' has a wrong offset!");
static_assert(offsetof(ALNPCCharacter, RootMotionJumpContextList) == 0x001408, "Member 'ALNPCCharacter::RootMotionJumpContextList' has a wrong offset!");

// Class ProjectP.LFXComponent
// 0x0160 (0x0210 - 0x00B0)
class ULFXComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCompletePlayMaterialVarying;                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompletePlayMaterialParam;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bUseResetToDefaultMaterial;                        // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x57];                                      // 0x00D1(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLMaterialVaryingPlayer>        MaterialVaryings;                                  // 0x0128(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFXTrailEmitter>               TrailList;                                         // 0x0148(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class UNiagaraComponent>, float> DelayDeactiveSystemList;                           // 0x0158(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULMaterialVarying*                      DissolveVarying;                                   // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x58];                                     // 0x01B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayDeactiveSystem(class UNiagaraComponent* NiagaraComponent, float DelayTime);
	void FXCommand_DeactiveTime(const TArray<class UFXSystemComponent*>& FXs, float DeactiveTime);
	void FXCommand_DoEvent(ELFXCommandEventType Type);
	void FXCommands_DeactiveEvent(const TArray<class UFXSystemComponent*>& FXs, ELFXCommandEventType Type);
	void HideManagedNiagaraComponents(bool bHide);
	bool IsPlayingVaryingName(class FName PlayName);
	void PlayBodyDurabilityConsumeFX(ELPartsAttachPointType AttachPointType);
	void PlayDeadHide(bool bDissolveEffect);
	void PlayElementPartsHitFX(class UNiagaraSystem* System, const struct FVector& HitLocation);
	void PlayHide(bool bDissolveEffect, class ULMaterialVarying* HideVarying, const class FName VaryingName);
	void PlayHitRegionFX(const struct FLHitFXPlayData& HitFXPlayData);
	void PlayMaterialParamScalar(class FName PlayerName, const TArray<class UMaterialInterface*>& Materials, const TArray<struct FLMaterialParamScalar>& Scalar);
	void PlayMaterialParamScalarSingle(class FName PlayerName, const TArray<class UMaterialInterface*>& Materials, const struct FLMaterialParamScalar& Scalar);
	void PlayMaterialVaryingValues(const TArray<struct FLMaterialVaryingScalar>& ScalarValues, const TArray<struct FLMaterialVaryingColor>& ColorValues, ELMaterialVaryingPlayType PlayType, const TArray<class UMeshComponent*>& MeshComponents, class FName PlayName);
	void PlayMaterialVaryingWithMesh(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, class UMeshComponent* MeshComp, class FName PlayName);
	void PlayMaterialVaryingWithMeshes(class ULMaterialVarying* MaterialVarying, ELMaterialVaryingPlayType PlayType, const TArray<class UMeshComponent*>& MeshComps, class FName PlayName);
	void PlayTrail(class UObject* Instigator, class UParticleSystem* PSTemplate, class FName FirstSocketName, class FName SecondSocketName);
	void RefreshHide();
	void RefreshHideWeapon();
	void ResetToDefaultMaterial();
	void SetUseResetToDefaultMaterial(bool bEnable);
	void StartSplashBloodFX(class ALCharacter* Attacker, class ALWeapon* AttackerWeapon, ELBloodEffectType BloodType, float AttackerStiffenDurationTime);
	void StopHide(bool bDissolveEffect);
	void StopMaterialParam(class FName PlayerName);
	void StopMaterialVarying(class ULMaterialVarying* MaterialVarying);
	void StopMaterialVaryingAll(bool ResetToDefault);
	void StopSplashBloodFX();
	void StopTrail(class UObject* Instigator, float ReserveStopTime);

	bool IsHide() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFXComponent">();
	}
	static class ULFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULFXComponent>();
	}
};
static_assert(alignof(ULFXComponent) == 0x000008, "Wrong alignment on ULFXComponent");
static_assert(sizeof(ULFXComponent) == 0x000210, "Wrong size on ULFXComponent");
static_assert(offsetof(ULFXComponent, OnCompletePlayMaterialVarying) == 0x0000B0, "Member 'ULFXComponent::OnCompletePlayMaterialVarying' has a wrong offset!");
static_assert(offsetof(ULFXComponent, OnCompletePlayMaterialParam) == 0x0000C0, "Member 'ULFXComponent::OnCompletePlayMaterialParam' has a wrong offset!");
static_assert(offsetof(ULFXComponent, bUseResetToDefaultMaterial) == 0x0000D0, "Member 'ULFXComponent::bUseResetToDefaultMaterial' has a wrong offset!");
static_assert(offsetof(ULFXComponent, MaterialVaryings) == 0x000128, "Member 'ULFXComponent::MaterialVaryings' has a wrong offset!");
static_assert(offsetof(ULFXComponent, TrailList) == 0x000148, "Member 'ULFXComponent::TrailList' has a wrong offset!");
static_assert(offsetof(ULFXComponent, DelayDeactiveSystemList) == 0x000158, "Member 'ULFXComponent::DelayDeactiveSystemList' has a wrong offset!");
static_assert(offsetof(ULFXComponent, DissolveVarying) == 0x0001B0, "Member 'ULFXComponent::DissolveVarying' has a wrong offset!");

// Class ProjectP.LFXSystemData
// 0x0018 (0x01F8 - 0x01E0)
class ALFXSystemData : public AActor
{
public:
	bool                                          Enable_FootStepFX;                                 // 0x01E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundFX_RayStartHeight;                           // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFX_RayEndHeight;                             // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalSurfaceFxChangeSpeed;                      // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadHitSoundPlayLimitDuration;                     // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLAttachedEffectSet ActiveFuryAttack(class ALNPCCharacter* InTarget, bool bActive, float InVolumeModifier);
	TSoftObjectPtr<class ULMaterialVarying> GetWeaponMaterialVarying(class FName MaterialFxCodename);
	class UNiagaraSystem* GetWeaponTrailElementFX(class FName ElementFXCodename);
	void OnBeginTalk();
	struct FLAttachedEffectSet OnBuffEffect(class AActor* Actor, class FName EventName, ELPhysicalSurfaceType PhysicalSurface, class FName AttachedSocketName);
	void OnDisappear(class ALCharacter* Character);
	void OnEndTalk();
	void OnFrenzyModeMV(class ALCharacter* InTarget, bool bFrenzyMode);
	void OnParalyzationOcurred(class AActor* Victim);
	void OnPulseRecharged();
	void OnTorsionCoilPostProcess();
	void OnWeaponBladeDestroyEffect(const struct FVector& Location);
	void PlayHitEffect(const struct FLHitFXPlayData& HitFXPlayData);
	void PlaySocketTracerHitEffect_FX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface);
	void PlaySocketTracerHitEffect_SFX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface);
	void SetBloodOnOff(bool bOnOff);
	void SetFatalIndicatorState(class FName IndicatorKey, class ALCharacter* TargetActor, ELFatalIndicatorState PrevState, ELFatalIndicatorState CurrentState, const struct FTransform& FxTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFXSystemData">();
	}
	static class ALFXSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALFXSystemData>();
	}
};
static_assert(alignof(ALFXSystemData) == 0x000008, "Wrong alignment on ALFXSystemData");
static_assert(sizeof(ALFXSystemData) == 0x0001F8, "Wrong size on ALFXSystemData");
static_assert(offsetof(ALFXSystemData, Enable_FootStepFX) == 0x0001E0, "Member 'ALFXSystemData::Enable_FootStepFX' has a wrong offset!");
static_assert(offsetof(ALFXSystemData, GroundFX_RayStartHeight) == 0x0001E4, "Member 'ALFXSystemData::GroundFX_RayStartHeight' has a wrong offset!");
static_assert(offsetof(ALFXSystemData, GroundFX_RayEndHeight) == 0x0001E8, "Member 'ALFXSystemData::GroundFX_RayEndHeight' has a wrong offset!");
static_assert(offsetof(ALFXSystemData, PhysicalSurfaceFxChangeSpeed) == 0x0001EC, "Member 'ALFXSystemData::PhysicalSurfaceFxChangeSpeed' has a wrong offset!");
static_assert(offsetof(ALFXSystemData, DeadHitSoundPlayLimitDuration) == 0x0001F0, "Member 'ALFXSystemData::DeadHitSoundPlayLimitDuration' has a wrong offset!");

// Class ProjectP.LFXSystem
// 0x04C0 (0x0538 - 0x0078)
class ULFXSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALFXSystemData*                         SystemData;                                        // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x20];                                      // 0x0088(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLSwingSFX_PC_Table                    SwingSFX_PC_Table;                                 // 0x00A8(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSwingSFX_NPC_Table                   SwingSFX_NPC_Table;                                // 0x0108(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLHitFxTable                           HitFxTable;                                        // 0x0168(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLHitSFXTable                          HitSFXTable;                                       // 0x0170(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSplashBloodFxTable                   SplashBloodFxTable;                                // 0x0178(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLCameraShakeTable                     CameraShakeTable;                                  // 0x0180(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSmashFxTable                         SmashFxTable;                                      // 0x0188(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLPhysicalSurfaceFxTable               PhysicalSurfaceFxTable;                            // 0x0190(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLPhysicalSurfaceSoundTable            PhysicalSurfaceSoundTable;                         // 0x01E8(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLCharacterSoundTable                  CharacereSDTable;                                  // 0x0240(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLFxAttachCommonTable                  FxAttachCommonTable;                               // 0x0298(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLWeatherFxTable                       WeatherFxTable;                                    // 0x02A0(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLWeatherSoundTable                    WeatherSoundTable;                                 // 0x02A8(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLEnvSoundTable                        EnvSoundTable;                                     // 0x02B0(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLBladeTrailTable                      BladeTrailTable;                                   // 0x02B8(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSparkFxTable                         SparkFxTable;                                      // 0x02C0(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSparkSoundTable                      SparkSoundTable;                                   // 0x0318(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLRepulseFxTable                       RepulseFxTable;                                    // 0x0370(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLRepulseSoundTable                    RepulseSoundTable;                                 // 0x03C8(0x0058)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSoundCueTable                        SoundCueTable;                                     // 0x0420(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLHitLevelTable                        HitLevelTable;                                     // 0x0428(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLPlaySoundNotify_TimeChecker          PlaySoundNotify_TimeChecker;                       // 0x0438(0x0058)(NativeAccessSpecifierPublic)
	TMap<class FString, class UFXSystemComponent*> SpawnedFxSystemComponentHolder;                    // 0x0490(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FString, class UAudioComponent*>   SpawnedAudioComponentHolder;                       // 0x04E0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetachEffectHardly(struct FLAttachedEffectSet* Attached);
	void DoFrenzyModeMV(class ALCharacter* InTarget, bool bFrenzyMode);
	void DoHitEffect(const struct FLHitFXPlayData& HitFXPlayData);
	void DoSmashEffect(const struct FLSmashFXPlayData& SmashFxPlayData);
	void DoSocketTracerHitEffect_FX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface);
	void DoSocketTracerHitEffect_SFX(class FName EventName, const struct FTransform& HitTransform, ELPhysicalSurfaceType AttackerPhysicalSurface, ELPhysicalSurfaceType GroundPhysicalSurface);
	void DoWeaponBladeDestroyEffect(const struct FVector& Location);
	TSoftObjectPtr<class ULMaterialVarying> GetWeaponMaterialVarying(class FName MaterialFxCodename);
	class UNiagaraSystem* GetWeaponTrailElementFX(class FName ElementFXCodename);
	void OnBeginTalk();
	void OnDetachNiagaraDelegate(class UNiagaraComponent* InNiagaraComp);
	void OnDetachParticleDelegate(class UParticleSystemComponent* InParticleComp);
	void OnEndTalk();
	void OnFuryAttack(class ALNPCCharacter* InTarget, float InVolumeModifier);
	void OnParalyzationOcurred(class AActor* Victim);
	void OnPulseRecharged();
	void OnTorsionCoilPostProcess();
	void PlayDeadSound(class AActor* DeadActor);
	void SetFatalIndicatorState(class FName IndicatorKey, class ALCharacter* TargetActor, ELFatalIndicatorState PrevState, ELFatalIndicatorState CurrentState, const struct FTransform& FxTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFXSystem">();
	}
	static class ULFXSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULFXSystem>();
	}
};
static_assert(alignof(ULFXSystem) == 0x000008, "Wrong alignment on ULFXSystem");
static_assert(sizeof(ULFXSystem) == 0x000538, "Wrong size on ULFXSystem");
static_assert(offsetof(ULFXSystem, SystemData) == 0x000080, "Member 'ULFXSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SwingSFX_PC_Table) == 0x0000A8, "Member 'ULFXSystem::SwingSFX_PC_Table' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SwingSFX_NPC_Table) == 0x000108, "Member 'ULFXSystem::SwingSFX_NPC_Table' has a wrong offset!");
static_assert(offsetof(ULFXSystem, HitFxTable) == 0x000168, "Member 'ULFXSystem::HitFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, HitSFXTable) == 0x000170, "Member 'ULFXSystem::HitSFXTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SplashBloodFxTable) == 0x000178, "Member 'ULFXSystem::SplashBloodFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, CameraShakeTable) == 0x000180, "Member 'ULFXSystem::CameraShakeTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SmashFxTable) == 0x000188, "Member 'ULFXSystem::SmashFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, PhysicalSurfaceFxTable) == 0x000190, "Member 'ULFXSystem::PhysicalSurfaceFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, PhysicalSurfaceSoundTable) == 0x0001E8, "Member 'ULFXSystem::PhysicalSurfaceSoundTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, CharacereSDTable) == 0x000240, "Member 'ULFXSystem::CharacereSDTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, FxAttachCommonTable) == 0x000298, "Member 'ULFXSystem::FxAttachCommonTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, WeatherFxTable) == 0x0002A0, "Member 'ULFXSystem::WeatherFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, WeatherSoundTable) == 0x0002A8, "Member 'ULFXSystem::WeatherSoundTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, EnvSoundTable) == 0x0002B0, "Member 'ULFXSystem::EnvSoundTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, BladeTrailTable) == 0x0002B8, "Member 'ULFXSystem::BladeTrailTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SparkFxTable) == 0x0002C0, "Member 'ULFXSystem::SparkFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SparkSoundTable) == 0x000318, "Member 'ULFXSystem::SparkSoundTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, RepulseFxTable) == 0x000370, "Member 'ULFXSystem::RepulseFxTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, RepulseSoundTable) == 0x0003C8, "Member 'ULFXSystem::RepulseSoundTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SoundCueTable) == 0x000420, "Member 'ULFXSystem::SoundCueTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, HitLevelTable) == 0x000428, "Member 'ULFXSystem::HitLevelTable' has a wrong offset!");
static_assert(offsetof(ULFXSystem, PlaySoundNotify_TimeChecker) == 0x000438, "Member 'ULFXSystem::PlaySoundNotify_TimeChecker' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SpawnedFxSystemComponentHolder) == 0x000490, "Member 'ULFXSystem::SpawnedFxSystemComponentHolder' has a wrong offset!");
static_assert(offsetof(ULFXSystem, SpawnedAudioComponentHolder) == 0x0004E0, "Member 'ULFXSystem::SpawnedAudioComponentHolder' has a wrong offset!");

// Class ProjectP.LPropLiftStartPointComponent
// 0x0000 (0x0470 - 0x0470)
class ULPropLiftStartPointComponent final : public UBoxComponent
{
public:
	ELPropLiftStateType                           ForceDefaultState;                                 // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropLiftStartPointComponent">();
	}
	static class ULPropLiftStartPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropLiftStartPointComponent>();
	}
};
static_assert(alignof(ULPropLiftStartPointComponent) == 0x000010, "Wrong alignment on ULPropLiftStartPointComponent");
static_assert(sizeof(ULPropLiftStartPointComponent) == 0x000470, "Wrong size on ULPropLiftStartPointComponent");
static_assert(offsetof(ULPropLiftStartPointComponent, ForceDefaultState) == 0x000468, "Member 'ULPropLiftStartPointComponent::ForceDefaultState' has a wrong offset!");

// Class ProjectP.LGallerySystemData
// 0x0000 (0x01E0 - 0x01E0)
class ALGallerySystemData : public AActor
{
public:
	class AActor* GetSpawned();
	void Spawn(const class FName& CodeName, const struct FVector& InLocation, class ACineCameraActor* InPreviewCam, float InPreviewCam_OriginZ);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGallerySystemData">();
	}
	static class ALGallerySystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGallerySystemData>();
	}
};
static_assert(alignof(ALGallerySystemData) == 0x000008, "Wrong alignment on ALGallerySystemData");
static_assert(sizeof(ALGallerySystemData) == 0x0001E0, "Wrong size on ALGallerySystemData");

// Class ProjectP.LObjectPoolSystemData
// 0x0000 (0x01E0 - 0x01E0)
class ALObjectPoolSystemData : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LObjectPoolSystemData">();
	}
	static class ALObjectPoolSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALObjectPoolSystemData>();
	}
};
static_assert(alignof(ALObjectPoolSystemData) == 0x000008, "Wrong alignment on ALObjectPoolSystemData");
static_assert(sizeof(ALObjectPoolSystemData) == 0x0001E0, "Wrong size on ALObjectPoolSystemData");

// Class ProjectP.LGallerySystem
// 0x0040 (0x00B8 - 0x0078)
class ULGallerySystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ALGallerySystemData*                    SystemData;                                        // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLGalleryAssetTable                    GalleryAssetTable;                                 // 0x0090(0x0008)(Transient, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAcquireRecollection;                             // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSuccessSpawnModel;                               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	struct FLGalleryAssetTableRowType GetRecollectionAssetInfo(const class FName& CodeName);
	TArray<struct FLDiplayableGallery> GetRecollections();
	class AActor* GetSpawnedModel();
	void SpawnModel(const class FName& CodeName, const struct FVector& InLocation, class ACineCameraActor* InPreviewCam, float InPreviewCam_OriginZ);
	void SuccessSpawnModel(class AActor* InSpawnModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGallerySystem">();
	}
	static class ULGallerySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGallerySystem>();
	}
};
static_assert(alignof(ULGallerySystem) == 0x000008, "Wrong alignment on ULGallerySystem");
static_assert(sizeof(ULGallerySystem) == 0x0000B8, "Wrong size on ULGallerySystem");
static_assert(offsetof(ULGallerySystem, SystemData) == 0x000088, "Member 'ULGallerySystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULGallerySystem, GalleryAssetTable) == 0x000090, "Member 'ULGallerySystem::GalleryAssetTable' has a wrong offset!");
static_assert(offsetof(ULGallerySystem, OnAcquireRecollection) == 0x000098, "Member 'ULGallerySystem::OnAcquireRecollection' has a wrong offset!");
static_assert(offsetof(ULGallerySystem, OnSuccessSpawnModel) == 0x0000A8, "Member 'ULGallerySystem::OnSuccessSpawnModel' has a wrong offset!");

// Class ProjectP.LRecordCameraData
// 0x0020 (0x0048 - 0x0028)
class ULRecordCameraData final : public UObject
{
public:
	float                                         FrameRate;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleElapsedTime;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLRecordCameraFrame>            Frames;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void GetSampleFrame(float FlowTime, struct FVector* Location, struct FRotator* Rotation);
	void SampleFrame(float DeltaTime, const struct FVector& Location, const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LRecordCameraData">();
	}
	static class ULRecordCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULRecordCameraData>();
	}
};
static_assert(alignof(ULRecordCameraData) == 0x000008, "Wrong alignment on ULRecordCameraData");
static_assert(sizeof(ULRecordCameraData) == 0x000048, "Wrong size on ULRecordCameraData");
static_assert(offsetof(ULRecordCameraData, FrameRate) == 0x000028, "Member 'ULRecordCameraData::FrameRate' has a wrong offset!");
static_assert(offsetof(ULRecordCameraData, MaxTime) == 0x00002C, "Member 'ULRecordCameraData::MaxTime' has a wrong offset!");
static_assert(offsetof(ULRecordCameraData, SampleElapsedTime) == 0x000030, "Member 'ULRecordCameraData::SampleElapsedTime' has a wrong offset!");
static_assert(offsetof(ULRecordCameraData, Frames) == 0x000038, "Member 'ULRecordCameraData::Frames' has a wrong offset!");

// Class ProjectP.LDynamicPropShapeObjectSpot
// 0x0000 (0x0350 - 0x0350)
class ALDynamicPropShapeObjectSpot final : public ALPropShapeObjectSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDynamicPropShapeObjectSpot">();
	}
	static class ALDynamicPropShapeObjectSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDynamicPropShapeObjectSpot>();
	}
};
static_assert(alignof(ALDynamicPropShapeObjectSpot) == 0x000008, "Wrong alignment on ALDynamicPropShapeObjectSpot");
static_assert(sizeof(ALDynamicPropShapeObjectSpot) == 0x000350, "Wrong size on ALDynamicPropShapeObjectSpot");

// Class ProjectP.LReasonForDeathInfo
// 0x01F0 (0x0218 - 0x0028)
class ULReasonForDeathInfo final : public UObject
{
public:
	TWeakObjectPtr<class AActor>                  DeadBody;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deadtime;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLHitInfo                              DieCauseHitInfo;                                   // 0x0038(0x0150)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Murderer;                                          // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BodyExplode;                                       // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Temp_ForcedDieActionByFalling;                     // 0x0194(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELDieCauseType                                DieCauseType;                                      // 0x019C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAllowLieDying;                                   // 0x019D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19E[0x2];                                      // 0x019E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentActionClassCodeName;                        // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentCommonActionMontage;                        // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSkillHitType                                LastSkillHitType;                                  // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NpcAssetTableCodeName;                             // 0x01B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionGroupTableCodeName;                          // 0x01BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCCodeName;                                       // 0x01C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideDieMontageCodeName;                        // 0x01CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionType                               DieCauseHitAction;                                 // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELActionCategory                              DieCauseActionCategory;                            // 0x01D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalDamageType                          DieCausePhysicalDamageType;                        // 0x01D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7[0x1];                                      // 0x01D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELDieCauseHitDirection>                DieCauseHitDirection;                              // 0x01D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ELDieCauseElement                             DieCauseElement;                                   // 0x01E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELDieCauseFall                                DieCauseFall;                                      // 0x01E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitMotionType                               DieCauseHitActionOverride;                         // 0x01EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuiside;                                          // 0x01EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           OverrideDieAnim;                                   // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDyingAnim;                                    // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGenerateExp;                                // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGenerateItem;                               // 0x01FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideNPCRespawnState;                       // 0x01FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideNPCRespawn;                               // 0x01FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideCharacterTime;                                 // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DespawnCharacterTime;                              // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDieFromFatalAttack;                               // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiedByKillZone;                                   // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomDieUIShowTime;                           // 0x020A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B[0x1];                                      // 0x020B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DieUI_StartDelay;                                  // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayDeadSound;                                    // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDead();
	bool MakeNewRecord(class AActor* TargetActor, ELDieCauseType InDieCauseType);
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LReasonForDeathInfo">();
	}
	static class ULReasonForDeathInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULReasonForDeathInfo>();
	}
};
static_assert(alignof(ULReasonForDeathInfo) == 0x000008, "Wrong alignment on ULReasonForDeathInfo");
static_assert(sizeof(ULReasonForDeathInfo) == 0x000218, "Wrong size on ULReasonForDeathInfo");
static_assert(offsetof(ULReasonForDeathInfo, DeadBody) == 0x000028, "Member 'ULReasonForDeathInfo::DeadBody' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, Deadtime) == 0x000030, "Member 'ULReasonForDeathInfo::Deadtime' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseHitInfo) == 0x000038, "Member 'ULReasonForDeathInfo::DieCauseHitInfo' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, Murderer) == 0x000188, "Member 'ULReasonForDeathInfo::Murderer' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, BodyExplode) == 0x000190, "Member 'ULReasonForDeathInfo::BodyExplode' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, Temp_ForcedDieActionByFalling) == 0x000194, "Member 'ULReasonForDeathInfo::Temp_ForcedDieActionByFalling' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseType) == 0x00019C, "Member 'ULReasonForDeathInfo::DieCauseType' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, IsAllowLieDying) == 0x00019D, "Member 'ULReasonForDeathInfo::IsAllowLieDying' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, CurrentActionClassCodeName) == 0x0001A0, "Member 'ULReasonForDeathInfo::CurrentActionClassCodeName' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, CurrentCommonActionMontage) == 0x0001A8, "Member 'ULReasonForDeathInfo::CurrentCommonActionMontage' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, LastSkillHitType) == 0x0001B0, "Member 'ULReasonForDeathInfo::LastSkillHitType' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, NpcAssetTableCodeName) == 0x0001B4, "Member 'ULReasonForDeathInfo::NpcAssetTableCodeName' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, ActionGroupTableCodeName) == 0x0001BC, "Member 'ULReasonForDeathInfo::ActionGroupTableCodeName' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, NPCCodeName) == 0x0001C4, "Member 'ULReasonForDeathInfo::NPCCodeName' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, OverrideDieMontageCodeName) == 0x0001CC, "Member 'ULReasonForDeathInfo::OverrideDieMontageCodeName' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseHitAction) == 0x0001D4, "Member 'ULReasonForDeathInfo::DieCauseHitAction' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseActionCategory) == 0x0001D5, "Member 'ULReasonForDeathInfo::DieCauseActionCategory' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCausePhysicalDamageType) == 0x0001D6, "Member 'ULReasonForDeathInfo::DieCausePhysicalDamageType' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseHitDirection) == 0x0001D8, "Member 'ULReasonForDeathInfo::DieCauseHitDirection' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseElement) == 0x0001E8, "Member 'ULReasonForDeathInfo::DieCauseElement' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseFall) == 0x0001E9, "Member 'ULReasonForDeathInfo::DieCauseFall' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieCauseHitActionOverride) == 0x0001EA, "Member 'ULReasonForDeathInfo::DieCauseHitActionOverride' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bSuiside) == 0x0001EB, "Member 'ULReasonForDeathInfo::bSuiside' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, OverrideDieAnim) == 0x0001F0, "Member 'ULReasonForDeathInfo::OverrideDieAnim' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bPlayDyingAnim) == 0x0001F8, "Member 'ULReasonForDeathInfo::bPlayDyingAnim' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bEnableGenerateExp) == 0x0001F9, "Member 'ULReasonForDeathInfo::bEnableGenerateExp' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bEnableGenerateItem) == 0x0001FA, "Member 'ULReasonForDeathInfo::bEnableGenerateItem' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bUseOverrideNPCRespawnState) == 0x0001FB, "Member 'ULReasonForDeathInfo::bUseOverrideNPCRespawnState' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bOverrideNPCRespawn) == 0x0001FC, "Member 'ULReasonForDeathInfo::bOverrideNPCRespawn' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, HideCharacterTime) == 0x000200, "Member 'ULReasonForDeathInfo::HideCharacterTime' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DespawnCharacterTime) == 0x000204, "Member 'ULReasonForDeathInfo::DespawnCharacterTime' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bDieFromFatalAttack) == 0x000208, "Member 'ULReasonForDeathInfo::bDieFromFatalAttack' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bDiedByKillZone) == 0x000209, "Member 'ULReasonForDeathInfo::bDiedByKillZone' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bUseCustomDieUIShowTime) == 0x00020A, "Member 'ULReasonForDeathInfo::bUseCustomDieUIShowTime' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, DieUI_StartDelay) == 0x00020C, "Member 'ULReasonForDeathInfo::DieUI_StartDelay' has a wrong offset!");
static_assert(offsetof(ULReasonForDeathInfo, bPlayDeadSound) == 0x000210, "Member 'ULReasonForDeathInfo::bPlayDeadSound' has a wrong offset!");

// Class ProjectP.LCommonConstantValues
// 0x00F0 (0x0118 - 0x0028)
class ULCommonConstantValues final : public UObject
{
public:
	TMap<class FName, int32>                      IntValues;                                         // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      FloatValues;                                       // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                NameVlaues;                                        // 0x00C8(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	float GetAbnormalStateBuildUpRecover();
	int32 GetAbnormalStateBuildUpRecoverDelay();
	int32 GetAbnormalStateBuildupRecoverRate();
	int32 GetAbnormalStateBuildupRecoverWait();
	int32 GetAbnormalStatePenaltyBase();
	float GetAbnormalStatePenaltyExponent();
	class FName GetAfterEndingCookieMovie();
	float GetAggro_Target_Range();
	int32 GetASZombieHPSet();
	float GetAttackDefenceAdd();
	float GetAttackDefenceExponent();
	float GetAttackDefenceScale();
	float GetAttackScale();
	int32 GetAttackSpeedRatioMax();
	int32 GetAttackSpeedRatioMin();
	class FName GetBladeElementAttackBuff_Acid();
	class FName GetBladeElementAttackBuff_Electric();
	class FName GetBladeElementAttackBuff_Fire();
	int32 GetBladeNeedStatLackAtkRatio();
	int32 GetBladeNeedStatLackDestructionRatio();
	int32 GetBladeNeedStatLackStaminaRatio();
	class FName GetBossRaxasiaShieldBrokenName();
	class FName GetBossRaxasiaShieldName();
	class FName GetBossRoom_Ergodrop_relocation_check_state();
	int32 GetBuildUpRecoverIncBase();
	float GetBuildUpRecoverIncExponent();
	int32 GetCatDustEffectRange();
	int32 GetCatDustRangeDecreaseRatio();
	int32 GetCatDustSensitiveDecreaseTime();
	class FName GetCH06BossKill();
	class FName GetCH13BossKill();
	class FName GetConsumeReturnClockBlockCondition();
	class FName GetConsumeReturnClockBlockMsg();
	class FName GetCopper2setAbnormalState();
	class FName GetCopper3setAbnormalState();
	int32 GetDashParryCooltime();
	class FName GetDefaultCostumeCodeName();
	float GetDefenceFactor();
	float GetDefenceScale();
	int32 GetDialogInputTerm();
	float GetDialogNextSpeed();
	float GetDialogVoiceFadeoutSec();
	int32 GetDialogVoiceTermTime();
	class FName GetDoorKeyFail();
	class FName GetDoorKeySuccess();
	int32 GetDropErgoExchangeRate();
	float GetElementalAbStateBuildUpRecover();
	int32 GetElementalAbStateBuildUpRecoverDelay();
	int32 GetExiledNpcWarningMsgDelay();
	class FName GetFrenzyAbnormalCodeName();
	int32 GetFrenzyPointMax();
	int32 GetGoldenTreeAccelTimes();
	int32 GetGoldenTreeHarvestFirst();
	class FName GetGoldenTreeHarvestItem();
	int32 GetGoldenTreeHarvestItemNum();
	TArray<class FString> GetGoldenTreePropUniqueId();
	int32 GetGoldenTreeTimeToHarvesting();
	int32 GetGoldStackLimit();
	TSoftObjectPtr<class USoundAttenuation> GetGramophoneAttenuationAsset();
	int32 GetGuardParryCooltime();
	class FName GetHandleCorrectChangeCodeName_Advance();
	class FName GetHandleCorrectChangeCodeName_Clear();
	class FName GetHandleCorrectChangeCodeName_Motifvity();
	class FName GetHandleCorrectChangeCodeName_Technique();
	int32 GetHandleCorrectionChange_UnderLimit();
	int32 GetHandleCorrectionChange_UpperStackLimit();
	int32 GetHandleNeedStatLackAtkRatio();
	int32 GetHandleNeedStatLackGuardSaveStaminaRatio();
	class FName GetHelpMateAwakeItem();
	class FName GetHelpMateDespawnWorldTrigger();
	class FName GetHelpMateFailMsg();
	class FName GetHelpMateSuccessMsg();
	class FName GetHitBoom_Projectile_Code_Name();
	class FName GetHotelTeleportActivateCondition1();
	class FName GetHotelTeleportActivateCondition2();
	class FName GetHotelTosionCoilCodeName();
	class FName GetHotelTosionCoilCodeName2();
	int32 GetHumanityGain_HighStart();
	class FName GetHumanityGainSkill_High();
	class FName GetHumanityGainSkill_Low();
	int32 GetHumanityMax();
	class FName GetInitWeatherCodeName();
	class FName GetIntroSequenceCodeName();
	int32 GetInventoryMaxBladeSlot();
	int32 GetInventoryMaxGearSlot();
	int32 GetInventoryMaxHandleSlot();
	int32 GetInventoryMaxPartsSlot();
	int32 GetInventoryMaxWeaponSlot();
	int32 GetItemValueGradeCheck();
	class FName GetLevelResetNeedItem();
	int32 GetLevelResetNeedItemNum();
	class FName GetLieEffectSequenceCodeName();
	class FName GetLiftInteractionFailMessage();
	bool GetLockerRefillMsgOn();
	int32 GetMaxLevelStationStargazer();
	class FName GetMaxLevelStationStargazerCondition();
	class FName GetMonadBuffMainItem();
	class FName GetMonasterySimonDieCheck();
	int32 GetMonologueRepeatTime();
	class FName GetMoviePOrganOpen();
	class FName GetNGP_belt_slot_clear();
	class FName GetNoseStaffLargeBLD();
	class FName GetNoseStaffLargeHND();
	class FName GetNoseStaffMediumBLD();
	class FName GetNoseStaffMediumHND();
	class FName GetNoseStaffSmallHND();
	int32 GetNpcMenuOpenDelay();
	class FName GetOpeningMovieCodeName();
	class FName GetPCActionTypeBld1();
	class FName GetPCActionTypeBld2();
	class FName GetPCActionTypeBld3();
	class FName GetPCActionTypeHnd1();
	class FName GetPCActionTypeHnd2();
	class FName GetPCActionTypeHnd3();
	class FName GetPCActionTypeStat1();
	class FName GetPCActionTypeStat2();
	class FName GetPCActionTypeStat3();
	int32 GetPCDialogMinTurnAngle();
	int32 GetPCDialogRotateTime();
	class FName GetPCInitializeSet1();
	class FName GetPCInitializeSet2();
	class FName GetPCInitializeSet3();
	class FName GetPCInitializeSet_Factory1();
	class FName GetPCInitializeSet_Factory2();
	class FName GetPCInitializeSet_Factory3();
	float GetPlayRateExponentOver();
	float GetPlayRateExponentUnder();
	int32 GetPlayRecordCheckTime();
	int32 GetPSystemLevel2RequiredSynergyCount();
	int32 GetPSystemLevel3RequiredSynergyCount();
	int32 GetPSystemLevel4RequiredSynergyCount();
	int32 GetPSystemLevel5RequiredSynergyCount();
	int32 GetPSystemLevel6RequiredSynergyCount();
	int32 GetPSystemLevel7RequiredSynergyCount();
	int32 GetPSystemLevelLimitNewGamePlus0();
	int32 GetPSystemLevelLimitNewGamePlus1();
	int32 GetPSystemLevelLimitNewGamePlus2();
	int32 GetPSystemMaxLevel();
	class FName GetPulseItemBuffCodenameOnBreaked();
	class FName GetPulseItemCodeName();
	class FName GetQuartzItemCodeName();
	class FName GetQuartzSystemLevelUpItemCodeName();
	class FName GetQuartzSystemResetItemCodeName();
	int32 GetQuartzSystemResetItemNum();
	class FName GetRaxasiaShieldPartsName();
	int32 GetReduceFPOnFrenzy();
	int32 GetReduceFPOnFrenzyInterval();
	int32 GetRegainhpMakeRatio();
	bool GetResetItemSlotPosition();
	class FName GetResurrection_Abnormal_Code_Name();
	int32 GetSellingPriceRatio();
	class FName GetSequenceHotelBICodeName();
	int32 GetSharpnessBadAttackMod();
	int32 GetSharpnessBadDestructionMod();
	int32 GetSharpnessBrokenAttackMod();
	int32 GetSharpnessBrokenDestructionMod();
	int32 GetSharpnessFineAttackMod();
	int32 GetSharpnessFineDestructionMod();
	int32 GetSharpnessNormalAttackMod();
	int32 GetSharpnessNormalDestructionMod();
	int32 GetSharpnessReduceValue();
	int32 GetShopPurchaseLimit();
	float GetSkillHitDefenceExponent();
	class FName GetSlavearmItemAlterUseType();
	class FName GetSlaveArmReinforcementResetItemCodeName();
	int32 GetSlaveArmReinforcementResetItemNum();
	int32 GetSprintExhaustTime();
	int32 GetSprintSpeedRatioMax();
	int32 GetSprintSpeedRatioMin();
	float GetStaminaConsumeRatioExponentOver();
	float GetStaminaConsumeRatioExponentUnder();
	class FName GetStealthAbnormalCodeName();
	class FName GetStealthImmediatelyAbnormalCodeName();
	class FName GetStealthTotallyImmediatelyAbnormalCodeName();
	int32 GetStorageMaxSlot();
	int32 GetStorageRequirementsSlot();
	int32 GetSwapNPCDefaultHPRate();
	int32 GetTalkerDialogRotateTime();
	class FName GetTalkerTurnLAnim();
	class FName GetTalkerTurnRAnim();
	class FName GetTeleporStartSequenceCodeName();
	class FName GetTeleportEndSequenceCodeName();
	class FName GetTeleportObjectForNGPDelay();
	class FName GetTeleportObjectForNGPStart();
	bool GetTorsionCoilSetFullSlaveMagazine();
	class FName GetTungsten2setAbnormalState();
	class FName GetTungsten3setAbnormalState();
	int32 GetTutorialPendingLimit();
	float GetTutorialPendingTime();
	int32 GetTutorialPriorityPendingMaxCount();
	class FName GetUniqueGrinderMainItem();
	class FName GetUranium2setAbnormalState();
	class FName GetUranium3setAbnormalState();
	class FName GetVibranium2setAbnormalState();
	class FName GetVibranium3setAbnormalState();
	int32 GetWalkRunSpeedRatioMax();
	int32 GetWalkRunSpeedRatioMin();
	int32 GetWeaponPhysicalAttackpowerFatalWeight();
	float GetWeightLimitOverAllowRatio();
	class FName GetWood2setAbnormalState();
	class FName GetWood3setAbnormalState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCommonConstantValues">();
	}
	static class ULCommonConstantValues* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCommonConstantValues>();
	}
};
static_assert(alignof(ULCommonConstantValues) == 0x000008, "Wrong alignment on ULCommonConstantValues");
static_assert(sizeof(ULCommonConstantValues) == 0x000118, "Wrong size on ULCommonConstantValues");
static_assert(offsetof(ULCommonConstantValues, IntValues) == 0x000028, "Member 'ULCommonConstantValues::IntValues' has a wrong offset!");
static_assert(offsetof(ULCommonConstantValues, FloatValues) == 0x000078, "Member 'ULCommonConstantValues::FloatValues' has a wrong offset!");
static_assert(offsetof(ULCommonConstantValues, NameVlaues) == 0x0000C8, "Member 'ULCommonConstantValues::NameVlaues' has a wrong offset!");

// Class ProjectP.LNPCSpecActionSignal
// 0x0020 (0x0048 - 0x0028)
class ULNPCSpecActionSignal final : public ULNPCSpecActionBase
{
public:
	class FName                                   NPCCodeName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendDistance;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SignalString;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecActionSignal">();
	}
	static class ULNPCSpecActionSignal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecActionSignal>();
	}
};
static_assert(alignof(ULNPCSpecActionSignal) == 0x000008, "Wrong alignment on ULNPCSpecActionSignal");
static_assert(sizeof(ULNPCSpecActionSignal) == 0x000048, "Wrong size on ULNPCSpecActionSignal");
static_assert(offsetof(ULNPCSpecActionSignal, NPCCodeName) == 0x000028, "Member 'ULNPCSpecActionSignal::NPCCodeName' has a wrong offset!");
static_assert(offsetof(ULNPCSpecActionSignal, SendDistance) == 0x000030, "Member 'ULNPCSpecActionSignal::SendDistance' has a wrong offset!");
static_assert(offsetof(ULNPCSpecActionSignal, SignalString) == 0x000038, "Member 'ULNPCSpecActionSignal::SignalString' has a wrong offset!");

// Class ProjectP.LObjectDataDB
// 0x0020 (0x0048 - 0x0028)
class ULObjectDataDB final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LObjectDataDB">();
	}
	static class ULObjectDataDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULObjectDataDB>();
	}
};
static_assert(alignof(ULObjectDataDB) == 0x000008, "Wrong alignment on ULObjectDataDB");
static_assert(sizeof(ULObjectDataDB) == 0x000048, "Wrong size on ULObjectDataDB");

// Class ProjectP.LGameDataSystem
// 0x01D8 (0x0250 - 0x0078)
class ULGameDataSystem final : public ULGameSubSystem
{
public:
	bool                                          RaxasiaShieldBroken;                               // 0x0078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0xF];                                       // 0x0079(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AutoSaveTimerHandle;                               // 0x0088(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoSaveDelayTime;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULAccountSaveGame*                      AccountSaveGame;                                   // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULCharacterSaveGame*                    CharacterSaveGame;                                 // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLGameDataExecute>              GameDataExecuteList;                               // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ELGameDataType>                        AsyncSaveExecutionList;                            // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<ELGameDataType>                        AsyncLoadExecutionList;                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FLTeleportLocationChapter> TeleportLocationMap;                               // 0x0100(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          DebugLog;                                          // 0x0150(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitAcquisitionSoul;                               // 0x0154(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 EULA_Version;                                      // 0x0158(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULCommonConstantValues*                 CommonConstantValues;                              // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULObjectDataDB*                         ObjectDataDB;                                      // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x38];                                     // 0x0178(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGlobalVariableChanged;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         LoadCharacterCount;                                // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         LoadAccountCount;                                  // 0x01C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C2[0x2];                                      // 0x01C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActivityIndex;                                     // 0x01C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SaveInPlayTimerHandle;                             // 0x01C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Account_Savedata_Version_Major;                    // 0x01D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Account_Savedata_Version_Minor;                    // 0x01D1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Account_Savedata_Version_Bugfix;                   // 0x01D2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Character_Savedata_Version_Major;                  // 0x01D3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Character_Savedata_Version_Minor;                  // 0x01D4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Character_Savedata_Version_Bugfix;                 // 0x01D5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D6[0x2];                                      // 0x01D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Account_Savedata_Version;                          // 0x01D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        Character_Savedata_Version;                        // 0x01DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveAccountAndCharacterCount;                // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveAccountCount;                            // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveCharacterCount;                          // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveOptionCount;                             // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveAccountAndCharacterCountPerMin;          // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveAccountCountPerMin;                      // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InGameSaveCharacterCountPerMin;                    // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int64>                                 ArrInGameSaveAccountAndCharacterCountPerMin;       // 0x0218(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int64>                                 ArrInGameSaveAccountCountPerMin;                   // 0x0228(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int64>                                 ArrInGameSaveCharacterCountPerMin;                 // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         PrintLogCurrentTime;                               // 0x0248(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Min;                                               // 0x024C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddPlayedRecord(const class FName& RecordName);
	void ApplyActivity();
	void CalcTeleportList();
	void CheckAutoSave();
	void ContinueCharacterStorageData();
	void DeleteCharacterStorageData(const class FString& DeleteName);
	class FString GetAccountEULAVersion();
	int32 GetActivityIndex();
	TArray<int32> GetCategoryList();
	int32 GetCharacterLevel();
	class FString GetCharacterName();
	class FString GetCharacterStoragePlayTime(const class FString& FindName);
	class FString GetCharacterStorageSaveDateTime(const struct FDateTime& InDateTime);
	class ULCommonConstantValues* GetConstantValues();
	int32 GetCurrentErgo();
	class FName GetCurrentHotelTosionCoil();
	int32 GetCurrentHumanity();
	int32 GetCurrentNewGamePlus();
	class FName GetDepartureTeleportObject();
	int32 GetDropErgo();
	class FString GetEULAVersion();
	int32 GetForceStartChapter();
	int32 GetGlobalVariableData(const class FName& InCodeName);
	ELHairCategoryType GetHairCategoryType();
	int32 GetHumanityLevel();
	float GetHumanityRatio();
	class FName GetLatestTorsionCoil();
	int32 GetLevelUpRequireErgo(int32 CheckLevel);
	int32 GetMaxLevelUpCount(int32 PlayerLevel, int32 RemainSoul);
	bool GetNewGamePlusProcess();
	int32 GetNextLevelUpRequireSoul();
	struct FTransform GetPlayerTeleportTransform(ELSpawnTransformType* OutSpawnTransformType);
	bool GetRaxasiaShieldBroken();
	int32 GetRemainSoul(int32 CurLevel, int32 CurSoul, int32 LevelUpCount);
	bool GetSaveData(TArray<struct FLCharacterStorageData>* OutCharacterList);
	bool GetTeleportList(int32 CategoryIndex, TArray<struct FLTeleportLocation>* OutTeleportLocationList);
	class FName GetWeatherCodeName();
	bool IsHiddenConditionTeleportToHotel();
	bool IsLastPlayCharacter(const class FString& FindName);
	bool IsNormalShutDown();
	bool IsPlayingNewGamePlusProcess();
	bool IsPossibleTeleportToHotel();
	bool IsValidLastPlayCharacter();
	bool IsValidStarterPackContinueCharacter();
	bool IsValidStarterPackSelectCharacter(const class FString& SelectName);
	bool IsValidTeleportTransformByType(ELSpawnTransformType FindType, struct FTransform* OutTransform);
	void LoadContinueCharacterStorageData();
	void LoadSelectCharacterStorageData(const class FString& SelectName);
	void NewCharacterStorageData(int32 StartChapter);
	void NewGamePlusToPlayStart();
	class ULObjectDataDB* ObjDataDB();
	void OnClosedStargazerDialog(class FName WidgetTableName);
	void OnLoadGameDataInGame(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame);
	void OnLoadGameDataLobby(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame);
	void OnResultEULA(bool InAgree);
	void OnSaveGameDataInGame(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType);
	void OnSaveGameDataLobby(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType);
	void ResetActivityIndex();
	void RestoreCharacterStorageData(int32 StartChapter);
	void SaveGameDataFromUI(bool IsAsyncSave, bool NormalShutDown);
	void SelectCharacterStorageData(const class FString& SelectName);
	void SetActivityIndex(int32 InActivityIndex);
	void SetPlayerSpawnFailedMessage(const class FString& InMessage);

	bool GetAccountOpenedRecollection() const;
	class FString GetAccountPlayTime() const;
	bool GetAccountShowEndingCredit() const;
	int32 GetDeathCount() const;
	class FString GetPlayTime() const;
	int32 GetReceiveDamage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameDataSystem">();
	}
	static class ULGameDataSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameDataSystem>();
	}
};
static_assert(alignof(ULGameDataSystem) == 0x000008, "Wrong alignment on ULGameDataSystem");
static_assert(sizeof(ULGameDataSystem) == 0x000250, "Wrong size on ULGameDataSystem");
static_assert(offsetof(ULGameDataSystem, RaxasiaShieldBroken) == 0x000078, "Member 'ULGameDataSystem::RaxasiaShieldBroken' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, AutoSaveTimerHandle) == 0x000088, "Member 'ULGameDataSystem::AutoSaveTimerHandle' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, AutoSaveDelayTime) == 0x000090, "Member 'ULGameDataSystem::AutoSaveDelayTime' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, AccountSaveGame) == 0x000098, "Member 'ULGameDataSystem::AccountSaveGame' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, CharacterSaveGame) == 0x0000A0, "Member 'ULGameDataSystem::CharacterSaveGame' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, GameDataExecuteList) == 0x0000D0, "Member 'ULGameDataSystem::GameDataExecuteList' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, AsyncSaveExecutionList) == 0x0000E0, "Member 'ULGameDataSystem::AsyncSaveExecutionList' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, AsyncLoadExecutionList) == 0x0000F0, "Member 'ULGameDataSystem::AsyncLoadExecutionList' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, TeleportLocationMap) == 0x000100, "Member 'ULGameDataSystem::TeleportLocationMap' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, DebugLog) == 0x000150, "Member 'ULGameDataSystem::DebugLog' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InitAcquisitionSoul) == 0x000154, "Member 'ULGameDataSystem::InitAcquisitionSoul' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, EULA_Version) == 0x000158, "Member 'ULGameDataSystem::EULA_Version' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, CommonConstantValues) == 0x000168, "Member 'ULGameDataSystem::CommonConstantValues' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, ObjectDataDB) == 0x000170, "Member 'ULGameDataSystem::ObjectDataDB' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, OnGlobalVariableChanged) == 0x0001B0, "Member 'ULGameDataSystem::OnGlobalVariableChanged' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, LoadCharacterCount) == 0x0001C0, "Member 'ULGameDataSystem::LoadCharacterCount' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, LoadAccountCount) == 0x0001C1, "Member 'ULGameDataSystem::LoadAccountCount' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, ActivityIndex) == 0x0001C4, "Member 'ULGameDataSystem::ActivityIndex' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, SaveInPlayTimerHandle) == 0x0001C8, "Member 'ULGameDataSystem::SaveInPlayTimerHandle' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Account_Savedata_Version_Major) == 0x0001D0, "Member 'ULGameDataSystem::Account_Savedata_Version_Major' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Account_Savedata_Version_Minor) == 0x0001D1, "Member 'ULGameDataSystem::Account_Savedata_Version_Minor' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Account_Savedata_Version_Bugfix) == 0x0001D2, "Member 'ULGameDataSystem::Account_Savedata_Version_Bugfix' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Character_Savedata_Version_Major) == 0x0001D3, "Member 'ULGameDataSystem::Character_Savedata_Version_Major' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Character_Savedata_Version_Minor) == 0x0001D4, "Member 'ULGameDataSystem::Character_Savedata_Version_Minor' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Character_Savedata_Version_Bugfix) == 0x0001D5, "Member 'ULGameDataSystem::Character_Savedata_Version_Bugfix' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Account_Savedata_Version) == 0x0001D8, "Member 'ULGameDataSystem::Account_Savedata_Version' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Character_Savedata_Version) == 0x0001DC, "Member 'ULGameDataSystem::Character_Savedata_Version' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveAccountAndCharacterCount) == 0x0001E0, "Member 'ULGameDataSystem::InGameSaveAccountAndCharacterCount' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveAccountCount) == 0x0001E8, "Member 'ULGameDataSystem::InGameSaveAccountCount' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveCharacterCount) == 0x0001F0, "Member 'ULGameDataSystem::InGameSaveCharacterCount' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveOptionCount) == 0x0001F8, "Member 'ULGameDataSystem::InGameSaveOptionCount' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveAccountAndCharacterCountPerMin) == 0x000200, "Member 'ULGameDataSystem::InGameSaveAccountAndCharacterCountPerMin' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveAccountCountPerMin) == 0x000208, "Member 'ULGameDataSystem::InGameSaveAccountCountPerMin' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, InGameSaveCharacterCountPerMin) == 0x000210, "Member 'ULGameDataSystem::InGameSaveCharacterCountPerMin' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, ArrInGameSaveAccountAndCharacterCountPerMin) == 0x000218, "Member 'ULGameDataSystem::ArrInGameSaveAccountAndCharacterCountPerMin' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, ArrInGameSaveAccountCountPerMin) == 0x000228, "Member 'ULGameDataSystem::ArrInGameSaveAccountCountPerMin' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, ArrInGameSaveCharacterCountPerMin) == 0x000238, "Member 'ULGameDataSystem::ArrInGameSaveCharacterCountPerMin' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, PrintLogCurrentTime) == 0x000248, "Member 'ULGameDataSystem::PrintLogCurrentTime' has a wrong offset!");
static_assert(offsetof(ULGameDataSystem, Min) == 0x00024C, "Member 'ULGameDataSystem::Min' has a wrong offset!");

// Class ProjectP.LGamePadOption
// 0x0018 (0x0060 - 0x0048)
class ULGamePadOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyControllerDeadZoneMultiply(bool InLeftStick, float InValue);
	void ApplyControllerForceFeedbackMultiply(float InValue);
	int32 GetDeadZoneStep(bool LeftStick);
	int32 GetForceFeedbackStep();
	int32 GetMoveSpeedStep(ECameraDirectOption InRotator);
	bool IsInvertMove(ECameraDirectOption InRotator);
	void ResetEditedInputAction();
	bool SetDeadZoneStep(bool LeftStick, int32 InStep);
	bool SetForceFeedbackStep(int32 InStep);
	bool SetInvertMove(ECameraDirectOption InRotator, bool InInvert);
	bool SetMoveSpeedStep(ECameraDirectOption InRotator, int32 InStep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGamePadOption">();
	}
	static class ULGamePadOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGamePadOption>();
	}
};
static_assert(alignof(ULGamePadOption) == 0x000008, "Wrong alignment on ULGamePadOption");
static_assert(sizeof(ULGamePadOption) == 0x000060, "Wrong size on ULGamePadOption");

// Class ProjectP.PNGameEngine
// 0x0038 (0x0DB8 - 0x0D80)
class UPNGameEngine final : public UGameEngine
{
public:
	TArray<class FString>                         ForceLoadSoundPathList;                            // 0x0D80(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class USoundClass*                            BaseSoundClass_LBGM;                               // 0x0D90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            BaseSoundClass_LEffect;                            // 0x0D98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            BaseSoundClass_LMaster;                            // 0x0DA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            BaseSoundClass_LVoice;                             // 0x0DA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB0[0x8];                                      // 0x0DB0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PNGameEngine">();
	}
	static class UPNGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPNGameEngine>();
	}
};
static_assert(alignof(UPNGameEngine) == 0x000008, "Wrong alignment on UPNGameEngine");
static_assert(sizeof(UPNGameEngine) == 0x000DB8, "Wrong size on UPNGameEngine");
static_assert(offsetof(UPNGameEngine, ForceLoadSoundPathList) == 0x000D80, "Member 'UPNGameEngine::ForceLoadSoundPathList' has a wrong offset!");
static_assert(offsetof(UPNGameEngine, BaseSoundClass_LBGM) == 0x000D90, "Member 'UPNGameEngine::BaseSoundClass_LBGM' has a wrong offset!");
static_assert(offsetof(UPNGameEngine, BaseSoundClass_LEffect) == 0x000D98, "Member 'UPNGameEngine::BaseSoundClass_LEffect' has a wrong offset!");
static_assert(offsetof(UPNGameEngine, BaseSoundClass_LMaster) == 0x000DA0, "Member 'UPNGameEngine::BaseSoundClass_LMaster' has a wrong offset!");
static_assert(offsetof(UPNGameEngine, BaseSoundClass_LVoice) == 0x000DA8, "Member 'UPNGameEngine::BaseSoundClass_LVoice' has a wrong offset!");

// Class ProjectP.LGameInstance
// 0x0120 (0x02C8 - 0x01A8)
class ULGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULTransformDataAsset*                   TeleportTransformDataAsset;                        // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPreloadDataAsset*                     PreloadDataAsset;                                  // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULGameState*>                    GameStateList;                                     // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ULGameState>             CurrentGameStatePtr;                               // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x3];                                      // 0x01D8(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReloadContentInfoXml;                             // 0x01DB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCreateGameModeForPIE;                             // 0x01DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DD[0x2B];                                     // 0x01DD(0x002B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ActionGroupTableCodeNameArray_PreloadForPC;        // 0x0208(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActionGroupTableCodeNameArray_PreloadForPCSkill;   // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh_Hair_Basic;                                   // 0x0228(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh_Hair_WBasic;                                  // 0x0250(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh_Hair_Long;                                    // 0x0278(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh_Hair_WLong;                                   // 0x02A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void ActiveGameSystemForTest(ELGameSubSystemActiveType ActiveType);

	bool ExecBP(class UWorld* InWorld, const class FString& Cmd);
	void GetEmptyPulseGauge(int32* EmptyPulseCount, int32* EmptyPulseGauge_Current, int32* EmptyPulseGauge_Max, int32* EmptyPulseGauge_DefatltMax);
	EPNGameState GetGameState();
	bool IsPlayState();
	void MainProcess_PlayExit();
	void MainProcess_PlayStart();
	void MainProcess_StartInstance();
	void MakeNewCharacterBP(bool bInEditor);
	void OnChangeGameState(EPNGameState InGameState, bool ExecuteInGameMode);
	void OnEndAsyncPreLoadScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameInstance">();
	}
	static class ULGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameInstance>();
	}
};
static_assert(alignof(ULGameInstance) == 0x000008, "Wrong alignment on ULGameInstance");
static_assert(sizeof(ULGameInstance) == 0x0002C8, "Wrong size on ULGameInstance");
static_assert(offsetof(ULGameInstance, TeleportTransformDataAsset) == 0x0001B0, "Member 'ULGameInstance::TeleportTransformDataAsset' has a wrong offset!");
static_assert(offsetof(ULGameInstance, PreloadDataAsset) == 0x0001B8, "Member 'ULGameInstance::PreloadDataAsset' has a wrong offset!");
static_assert(offsetof(ULGameInstance, GameStateList) == 0x0001C0, "Member 'ULGameInstance::GameStateList' has a wrong offset!");
static_assert(offsetof(ULGameInstance, CurrentGameStatePtr) == 0x0001D0, "Member 'ULGameInstance::CurrentGameStatePtr' has a wrong offset!");
static_assert(offsetof(ULGameInstance, bReloadContentInfoXml) == 0x0001DB, "Member 'ULGameInstance::bReloadContentInfoXml' has a wrong offset!");
static_assert(offsetof(ULGameInstance, bCreateGameModeForPIE) == 0x0001DC, "Member 'ULGameInstance::bCreateGameModeForPIE' has a wrong offset!");
static_assert(offsetof(ULGameInstance, ActionGroupTableCodeNameArray_PreloadForPC) == 0x000208, "Member 'ULGameInstance::ActionGroupTableCodeNameArray_PreloadForPC' has a wrong offset!");
static_assert(offsetof(ULGameInstance, ActionGroupTableCodeNameArray_PreloadForPCSkill) == 0x000218, "Member 'ULGameInstance::ActionGroupTableCodeNameArray_PreloadForPCSkill' has a wrong offset!");
static_assert(offsetof(ULGameInstance, Mesh_Hair_Basic) == 0x000228, "Member 'ULGameInstance::Mesh_Hair_Basic' has a wrong offset!");
static_assert(offsetof(ULGameInstance, Mesh_Hair_WBasic) == 0x000250, "Member 'ULGameInstance::Mesh_Hair_WBasic' has a wrong offset!");
static_assert(offsetof(ULGameInstance, Mesh_Hair_Long) == 0x000278, "Member 'ULGameInstance::Mesh_Hair_Long' has a wrong offset!");
static_assert(offsetof(ULGameInstance, Mesh_Hair_WLong) == 0x0002A0, "Member 'ULGameInstance::Mesh_Hair_WLong' has a wrong offset!");

// Class ProjectP.LGameModeBase
// 0x0008 (0x0288 - 0x0280)
class ALGameModeBase : public AGameModeBase
{
public:
	bool                                          bPlayGameMode;                                     // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustPlayerLocationAndRotation;                  // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportWorldAsyncLoad;                            // 0x0282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadingLevel;                                     // 0x0283(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateForPIE;                                     // 0x0284(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGameState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameModeBase">();
	}
	static class ALGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGameModeBase>();
	}
};
static_assert(alignof(ALGameModeBase) == 0x000008, "Wrong alignment on ALGameModeBase");
static_assert(sizeof(ALGameModeBase) == 0x000288, "Wrong size on ALGameModeBase");
static_assert(offsetof(ALGameModeBase, bPlayGameMode) == 0x000280, "Member 'ALGameModeBase::bPlayGameMode' has a wrong offset!");
static_assert(offsetof(ALGameModeBase, bAdjustPlayerLocationAndRotation) == 0x000281, "Member 'ALGameModeBase::bAdjustPlayerLocationAndRotation' has a wrong offset!");
static_assert(offsetof(ALGameModeBase, bSupportWorldAsyncLoad) == 0x000282, "Member 'ALGameModeBase::bSupportWorldAsyncLoad' has a wrong offset!");
static_assert(offsetof(ALGameModeBase, bLoadingLevel) == 0x000283, "Member 'ALGameModeBase::bLoadingLevel' has a wrong offset!");
static_assert(offsetof(ALGameModeBase, bCreateForPIE) == 0x000284, "Member 'ALGameModeBase::bCreateForPIE' has a wrong offset!");

// Class ProjectP.LPCAnimInstance
// 0x0000 (0x06F0 - 0x06F0)
class ULPCAnimInstance : public ULAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPCAnimInstance">();
	}
	static class ULPCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPCAnimInstance>();
	}
};
static_assert(alignof(ULPCAnimInstance) == 0x000010, "Wrong alignment on ULPCAnimInstance");
static_assert(sizeof(ULPCAnimInstance) == 0x0006F0, "Wrong size on ULPCAnimInstance");

// Class ProjectP.LGameObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ILGameObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameObjectInterface">();
	}
	static class ILGameObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGameObjectInterface>();
	}
};
static_assert(alignof(ILGameObjectInterface) == 0x000008, "Wrong alignment on ILGameObjectInterface");
static_assert(sizeof(ILGameObjectInterface) == 0x000028, "Wrong size on ILGameObjectInterface");

// Class ProjectP.LItemDropSystemData
// 0x0000 (0x01E0 - 0x01E0)
class ALItemDropSystemData : public AActor
{
public:
	void SpawnDropErgoData(const struct FLDropErgoData& DropErgoData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LItemDropSystemData">();
	}
	static class ALItemDropSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALItemDropSystemData>();
	}
};
static_assert(alignof(ALItemDropSystemData) == 0x000008, "Wrong alignment on ALItemDropSystemData");
static_assert(sizeof(ALItemDropSystemData) == 0x0001E0, "Wrong size on ALItemDropSystemData");

// Class ProjectP.LGameSettings
// 0x0008 (0x0040 - 0x0038)
class ULGameSettings final : public UDeveloperSettings
{
public:
	bool                                          bGameDay;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEasyMode;                                         // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLevelStreaming;                                // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeowizAuth;                                       // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCanHotKeyInShipping;                       // 0x003C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableActivationSystemV2;                         // 0x003D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBoostAI;                                    // 0x003E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanHotKey();
	static bool CanPreload(ELPreloadUsage Usage);
	static bool CheckGameCommand(ELGameCommandCategory CommandCategory);
	static bool IsBoostAI();
	static bool IsEasyMode();
	static bool IsEnableActivationSystemV2();
	static bool IsGameDayBuild();
	static bool IsNeowizAuth();
	static bool IsUseActionGroupBuildData();
	static bool IsUseLevelStreaming();
	static void SetEasyModeEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameSettings">();
	}
	static class ULGameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameSettings>();
	}
};
static_assert(alignof(ULGameSettings) == 0x000008, "Wrong alignment on ULGameSettings");
static_assert(sizeof(ULGameSettings) == 0x000040, "Wrong size on ULGameSettings");
static_assert(offsetof(ULGameSettings, bGameDay) == 0x000038, "Member 'ULGameSettings::bGameDay' has a wrong offset!");
static_assert(offsetof(ULGameSettings, bEasyMode) == 0x000039, "Member 'ULGameSettings::bEasyMode' has a wrong offset!");
static_assert(offsetof(ULGameSettings, bUseLevelStreaming) == 0x00003A, "Member 'ULGameSettings::bUseLevelStreaming' has a wrong offset!");
static_assert(offsetof(ULGameSettings, bNeowizAuth) == 0x00003B, "Member 'ULGameSettings::bNeowizAuth' has a wrong offset!");
static_assert(offsetof(ULGameSettings, bDisableCanHotKeyInShipping) == 0x00003C, "Member 'ULGameSettings::bDisableCanHotKeyInShipping' has a wrong offset!");
static_assert(offsetof(ULGameSettings, bEnableActivationSystemV2) == 0x00003D, "Member 'ULGameSettings::bEnableActivationSystemV2' has a wrong offset!");
static_assert(offsetof(ULGameSettings, bEnableBoostAI) == 0x00003E, "Member 'ULGameSettings::bEnableBoostAI' has a wrong offset!");

// Class ProjectP.LEditorSettings
// 0x0008 (0x0040 - 0x0038)
class ULEditorSettings final : public UDeveloperSettings
{
public:
	bool                                          bUseActionGroupBuildData;                          // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreload_System;                                   // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreload_PC;                                       // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreload_NPC;                                      // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreload_PROP;                                     // 0x003C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreload_UI;                                       // 0x003D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAI;                                          // 0x003E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LEditorSettings">();
	}
	static class ULEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULEditorSettings>();
	}
};
static_assert(alignof(ULEditorSettings) == 0x000008, "Wrong alignment on ULEditorSettings");
static_assert(sizeof(ULEditorSettings) == 0x000040, "Wrong size on ULEditorSettings");
static_assert(offsetof(ULEditorSettings, bUseActionGroupBuildData) == 0x000038, "Member 'ULEditorSettings::bUseActionGroupBuildData' has a wrong offset!");
static_assert(offsetof(ULEditorSettings, bPreload_System) == 0x000039, "Member 'ULEditorSettings::bPreload_System' has a wrong offset!");
static_assert(offsetof(ULEditorSettings, bPreload_PC) == 0x00003A, "Member 'ULEditorSettings::bPreload_PC' has a wrong offset!");
static_assert(offsetof(ULEditorSettings, bPreload_NPC) == 0x00003B, "Member 'ULEditorSettings::bPreload_NPC' has a wrong offset!");
static_assert(offsetof(ULEditorSettings, bPreload_PROP) == 0x00003C, "Member 'ULEditorSettings::bPreload_PROP' has a wrong offset!");
static_assert(offsetof(ULEditorSettings, bPreload_UI) == 0x00003D, "Member 'ULEditorSettings::bPreload_UI' has a wrong offset!");
static_assert(offsetof(ULEditorSettings, bDebugAI) == 0x00003E, "Member 'ULEditorSettings::bDebugAI' has a wrong offset!");

// Class ProjectP.LGameEditableSettings
// 0x0018 (0x0040 - 0x0028)
class ULGameEditableSettings final : public UObject
{
public:
	class FString                                 CustomXmlDataPath;                                 // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceLoadXmlLocalization;                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMonsterAlwaysDissolveEffect;                      // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameEditableSettings">();
	}
	static class ULGameEditableSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameEditableSettings>();
	}
};
static_assert(alignof(ULGameEditableSettings) == 0x000008, "Wrong alignment on ULGameEditableSettings");
static_assert(sizeof(ULGameEditableSettings) == 0x000040, "Wrong size on ULGameEditableSettings");
static_assert(offsetof(ULGameEditableSettings, CustomXmlDataPath) == 0x000028, "Member 'ULGameEditableSettings::CustomXmlDataPath' has a wrong offset!");
static_assert(offsetof(ULGameEditableSettings, ForceLoadXmlLocalization) == 0x000038, "Member 'ULGameEditableSettings::ForceLoadXmlLocalization' has a wrong offset!");
static_assert(offsetof(ULGameEditableSettings, bMonsterAlwaysDissolveEffect) == 0x000039, "Member 'ULGameEditableSettings::bMonsterAlwaysDissolveEffect' has a wrong offset!");

// Class ProjectP.LPersonaHelperComponent
// 0x00C8 (0x0178 - 0x00B0)
class ULPersonaHelperComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULActMgrComponent*                      ActMgrComponent;                                   // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   RefLWeaponClass;                                   // 0x00C0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SkeletalMeshComponent_SlaveArm;                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALWeapon*                               Weapon_R;                                          // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALWeapon*                               Weapon_L;                                          // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x78];                                     // 0x0100(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPersonaHelperComponent">();
	}
	static class ULPersonaHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPersonaHelperComponent>();
	}
};
static_assert(alignof(ULPersonaHelperComponent) == 0x000008, "Wrong alignment on ULPersonaHelperComponent");
static_assert(sizeof(ULPersonaHelperComponent) == 0x000178, "Wrong size on ULPersonaHelperComponent");
static_assert(offsetof(ULPersonaHelperComponent, ActMgrComponent) == 0x0000B8, "Member 'ULPersonaHelperComponent::ActMgrComponent' has a wrong offset!");
static_assert(offsetof(ULPersonaHelperComponent, RefLWeaponClass) == 0x0000C0, "Member 'ULPersonaHelperComponent::RefLWeaponClass' has a wrong offset!");
static_assert(offsetof(ULPersonaHelperComponent, SkeletalMeshComponent_SlaveArm) == 0x0000E8, "Member 'ULPersonaHelperComponent::SkeletalMeshComponent_SlaveArm' has a wrong offset!");
static_assert(offsetof(ULPersonaHelperComponent, Weapon_R) == 0x0000F0, "Member 'ULPersonaHelperComponent::Weapon_R' has a wrong offset!");
static_assert(offsetof(ULPersonaHelperComponent, Weapon_L) == 0x0000F8, "Member 'ULPersonaHelperComponent::Weapon_L' has a wrong offset!");

// Class ProjectP.LGameState
// 0x0010 (0x0038 - 0x0028)
class ULGameState : public UObject
{
public:
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULGameInstance>          LGameInstancePtr;                                  // 0x002C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameState">();
	}
	static class ULGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameState>();
	}
};
static_assert(alignof(ULGameState) == 0x000008, "Wrong alignment on ULGameState");
static_assert(sizeof(ULGameState) == 0x000038, "Wrong size on ULGameState");
static_assert(offsetof(ULGameState, LGameInstancePtr) == 0x00002C, "Member 'ULGameState::LGameInstancePtr' has a wrong offset!");

// Class ProjectP.LChildActorEditorComponent
// 0x0000 (0x0220 - 0x0220)
class ULChildActorEditorComponent final : public UChildActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LChildActorEditorComponent">();
	}
	static class ULChildActorEditorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULChildActorEditorComponent>();
	}
};
static_assert(alignof(ULChildActorEditorComponent) == 0x000010, "Wrong alignment on ULChildActorEditorComponent");
static_assert(sizeof(ULChildActorEditorComponent) == 0x000220, "Wrong size on ULChildActorEditorComponent");

// Class ProjectP.LPSOGameState
// 0x0000 (0x0038 - 0x0038)
class ULPSOGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPSOGameState">();
	}
	static class ULPSOGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPSOGameState>();
	}
};
static_assert(alignof(ULPSOGameState) == 0x000008, "Wrong alignment on ULPSOGameState");
static_assert(sizeof(ULPSOGameState) == 0x000038, "Wrong size on ULPSOGameState");

// Class ProjectP.LInitGameState
// 0x0000 (0x0038 - 0x0038)
class ULInitGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInitGameState">();
	}
	static class ULInitGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInitGameState>();
	}
};
static_assert(alignof(ULInitGameState) == 0x000008, "Wrong alignment on ULInitGameState");
static_assert(sizeof(ULInitGameState) == 0x000038, "Wrong size on ULInitGameState");

// Class ProjectP.LIntroGameState
// 0x0000 (0x0038 - 0x0038)
class ULIntroGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LIntroGameState">();
	}
	static class ULIntroGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULIntroGameState>();
	}
};
static_assert(alignof(ULIntroGameState) == 0x000008, "Wrong alignment on ULIntroGameState");
static_assert(sizeof(ULIntroGameState) == 0x000038, "Wrong size on ULIntroGameState");

// Class ProjectP.LInputCommand
// 0x0000 (0x0028 - 0x0028)
class ULInputCommand final : public UObject
{
public:
	static class FName InputCommand_AssistUseItemDown();
	static class FName InputCommand_AssistUseItemLeft();
	static class FName InputCommand_AssistUseItemRight();
	static class FName InputCommand_AssistUseItemUp();
	static class FName InputCommand_ChargeCancel();
	static class FName InputCommand_Dash();
	static class FName InputCommand_DirectLockOnDash();
	static class FName InputCommand_DisableSprint();
	static class FName InputCommand_EnableSprint();
	static class FName InputCommand_FableHandle();
	static class FName InputCommand_FableHandle_OnGuardHit();
	static class FName InputCommand_Frenzy();
	static class FName InputCommand_FrenzyRelease();
	static class FName InputCommand_Guard();
	static class FName InputCommand_GuardEnd();
	static class FName InputCommand_LightAttack();
	static class FName InputCommand_None();
	static class FName InputCommand_ObjectInteraction();
	static class FName InputCommand_ParryDash();
	static class FName InputCommand_ParryGuard();
	static class FName InputCommand_Parrying();
	static class FName InputCommand_SlaveArmPress();
	static class FName InputCommand_SlaveArmRelease();
	static class FName InputCommand_StartSprint();
	static class FName InputCommand_StartTurning();
	static class FName InputCommand_StopRunning();
	static class FName InputCommand_StopSprint();
	static class FName InputCommand_StopTurning();
	static class FName InputCommand_StrongAttack();
	static class FName InputCommand_ToggleWalkMode();
	static class FName InputCommand_TurnSprint();
	static class FName InputCommand_UseItem();
	static class FName InputCommand_WeaponChange();
	static class FName InputCommand_WeaponChangePrevious();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInputCommand">();
	}
	static class ULInputCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInputCommand>();
	}
};
static_assert(alignof(ULInputCommand) == 0x000008, "Wrong alignment on ULInputCommand");
static_assert(sizeof(ULInputCommand) == 0x000028, "Wrong size on ULInputCommand");

// Class ProjectP.LLoginGameState
// 0x0000 (0x0038 - 0x0038)
class ULLoginGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLoginGameState">();
	}
	static class ULLoginGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLoginGameState>();
	}
};
static_assert(alignof(ULLoginGameState) == 0x000008, "Wrong alignment on ULLoginGameState");
static_assert(sizeof(ULLoginGameState) == 0x000038, "Wrong size on ULLoginGameState");

// Class ProjectP.LPlayOption
// 0x0020 (0x0068 - 0x0048)
class ULPlayOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetCurrentLanguage();
	bool GetEnableTutorialPopup();
	ELHUDVisible GetHUDVisibility();
	int32 GetLanguageStep();
	int32 GetLockOnImportanceWeightMultiply();
	TArray<class FString> GetSelectableLanguages();
	int32 GetSubtitleSize();
	bool GetUseAutoNewTargetLockOn();
	bool GetUseAutoTargeting();
	bool IsBloodExpressionEnabled();
	bool IsDirectLockOnDash();
	bool IsMotionBlurEnabled();
	bool IsVideoSubtitleEnabled();
	bool SetDirectLockOnDash(bool TurnOn);
	bool SetEnableBloodExpression(bool InEnable);
	bool SetEnableTutorialPopup(bool Enable);
	bool SetEnableVideoSubtitle(bool InEnable);
	bool SetHUDVisibility(ELHUDVisible InVisible);
	bool SetLanguageStep(int32 InStep);
	bool SetLockOnImportanceWeightMultiply(int32 InStep);
	bool SetMotionBlurEnabled(bool InEnable);
	bool SetSubtitleSize(int32 InSubtitleSize);
	bool SetUseAutoNewTargetLockOn(bool InAuto);
	bool SetUseAutoTargeting(bool Enable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayOption">();
	}
	static class ULPlayOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayOption>();
	}
};
static_assert(alignof(ULPlayOption) == 0x000008, "Wrong alignment on ULPlayOption");
static_assert(sizeof(ULPlayOption) == 0x000068, "Wrong size on ULPlayOption");

// Class ProjectP.LLobbyGameState
// 0x0000 (0x0038 - 0x0038)
class ULLobbyGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLobbyGameState">();
	}
	static class ULLobbyGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLobbyGameState>();
	}
};
static_assert(alignof(ULLobbyGameState) == 0x000008, "Wrong alignment on ULLobbyGameState");
static_assert(sizeof(ULLobbyGameState) == 0x000038, "Wrong size on ULLobbyGameState");

// Class ProjectP.LPlayGameState
// 0x0000 (0x0038 - 0x0038)
class ULPlayGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayGameState">();
	}
	static class ULPlayGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayGameState>();
	}
};
static_assert(alignof(ULPlayGameState) == 0x000008, "Wrong alignment on ULPlayGameState");
static_assert(sizeof(ULPlayGameState) == 0x000038, "Wrong size on ULPlayGameState");

// Class ProjectP.LNewGamePlusState
// 0x0000 (0x0038 - 0x0038)
class ULNewGamePlusState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNewGamePlusState">();
	}
	static class ULNewGamePlusState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNewGamePlusState>();
	}
};
static_assert(alignof(ULNewGamePlusState) == 0x000008, "Wrong alignment on ULNewGamePlusState");
static_assert(sizeof(ULNewGamePlusState) == 0x000038, "Wrong size on ULNewGamePlusState");

// Class ProjectP.LLockOnTargetComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULLockOnTargetComponent final : public USceneComponent
{
public:
	void DisableLockOn();
	void EnableLockOn();

	bool IsLockOnEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLockOnTargetComponent">();
	}
	static class ULLockOnTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLockOnTargetComponent>();
	}
};
static_assert(alignof(ULLockOnTargetComponent) == 0x000010, "Wrong alignment on ULLockOnTargetComponent");
static_assert(sizeof(ULLockOnTargetComponent) == 0x0001F0, "Wrong size on ULLockOnTargetComponent");

// Class ProjectP.LGalleryGameState
// 0x0000 (0x0038 - 0x0038)
class ULGalleryGameState final : public ULGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGalleryGameState">();
	}
	static class ULGalleryGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGalleryGameState>();
	}
};
static_assert(alignof(ULGalleryGameState) == 0x000008, "Wrong alignment on ULGalleryGameState");
static_assert(sizeof(ULGalleryGameState) == 0x000038, "Wrong size on ULGalleryGameState");

// Class ProjectP.LPCController
// 0x00A0 (0x05E8 - 0x0548)
class ALPCController : public APlayerController
{
public:
	uint8                                         Pad_548[0x10];                                     // 0x0548(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultCameraRotationInputSpeed;                   // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateToLockOnPoint;                              // 0x055C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55D[0xF];                                      // 0x055D(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULActBase>               ActionAtStartLockOn;                               // 0x056C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LSBForwardAxisValue;                               // 0x0574(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LSBRightAxisValue;                                 // 0x0578(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAxisValue;                                     // 0x057C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAxisValue;                                   // 0x0580(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InteractionStatus;                                 // 0x0584(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InteractionMotion;                                 // 0x0585(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InteractionLadder;                                 // 0x0586(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_587[0x11];                                     // 0x0587(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAudioListenerPosition                AudioListenerPosition;                             // 0x0598(0x0050)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	bool CanUseItem(class ULItem* Item);
	void ChangeLockOnTargetOnKeyboard();
	void DoLookUp(float InAxisValue);
	void DoMoveForward(float InAxisValue);
	void DoMoveRight(float InAxisValue);
	void DoTargetLockOn();
	void DoTurn(float InAxisValue);
	void DoUseItem(class ULItem* Item, int32 UseCount);
	void ExecuteInteractionEvent();
	bool IsInteractionLadder();
	bool IsInteractionMotion();
	bool IsInteractionStatus();
	void OnControllerCommand(const class FString& Command, const TArray<class FString>& Args);
	void OnRecvRespawnFromCharacterBP();
	void ReceiveOnActionStarted(class ULActMgrComponent* InActMgrComponent, class ULActBase* StartedAction);
	void ReceiveOnActionStopCalled(class ULActMgrComponent* InActMgrComponent, class ULActBase* StoppingAction, class ULActBase* ReasonAction);
	void SetAudioListenerPosition_AudioListenerPositionComponent(const struct FVector& Offset, float LerpDuration);
	void SetAudioListenerPosition_Camera(const struct FVector& Offset, float LerpDuration);
	void SetAudioListenerPosition_Character(float LerpDuration);
	void SetAudioListenerPosition_CustomLocation(const struct FVector& Location, float LerpDuration);
	void SetAudioListenerPosition_StatRoom();
	void SetInteractionLadder(bool Motion);

	ELAudioListenerPositionType GetAudioListenerPositionType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPCController">();
	}
	static class ALPCController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPCController>();
	}
};
static_assert(alignof(ALPCController) == 0x000008, "Wrong alignment on ALPCController");
static_assert(sizeof(ALPCController) == 0x0005E8, "Wrong size on ALPCController");
static_assert(offsetof(ALPCController, DefaultCameraRotationInputSpeed) == 0x000558, "Member 'ALPCController::DefaultCameraRotationInputSpeed' has a wrong offset!");
static_assert(offsetof(ALPCController, bRotateToLockOnPoint) == 0x00055C, "Member 'ALPCController::bRotateToLockOnPoint' has a wrong offset!");
static_assert(offsetof(ALPCController, ActionAtStartLockOn) == 0x00056C, "Member 'ALPCController::ActionAtStartLockOn' has a wrong offset!");
static_assert(offsetof(ALPCController, LSBForwardAxisValue) == 0x000574, "Member 'ALPCController::LSBForwardAxisValue' has a wrong offset!");
static_assert(offsetof(ALPCController, LSBRightAxisValue) == 0x000578, "Member 'ALPCController::LSBRightAxisValue' has a wrong offset!");
static_assert(offsetof(ALPCController, TurnAxisValue) == 0x00057C, "Member 'ALPCController::TurnAxisValue' has a wrong offset!");
static_assert(offsetof(ALPCController, LookUpAxisValue) == 0x000580, "Member 'ALPCController::LookUpAxisValue' has a wrong offset!");
static_assert(offsetof(ALPCController, InteractionStatus) == 0x000584, "Member 'ALPCController::InteractionStatus' has a wrong offset!");
static_assert(offsetof(ALPCController, InteractionMotion) == 0x000585, "Member 'ALPCController::InteractionMotion' has a wrong offset!");
static_assert(offsetof(ALPCController, InteractionLadder) == 0x000586, "Member 'ALPCController::InteractionLadder' has a wrong offset!");
static_assert(offsetof(ALPCController, AudioListenerPosition) == 0x000598, "Member 'ALPCController::AudioListenerPosition' has a wrong offset!");

// Class ProjectP.LGameTagVolume
// 0x0020 (0x0258 - 0x0238)
class ALGameTagVolume final : public ALVolume
{
public:
	struct FGameplayTagContainer                  ExecuteTags;                                       // 0x0238(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameTagVolume">();
	}
	static class ALGameTagVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGameTagVolume>();
	}
};
static_assert(alignof(ALGameTagVolume) == 0x000008, "Wrong alignment on ALGameTagVolume");
static_assert(sizeof(ALGameTagVolume) == 0x000258, "Wrong size on ALGameTagVolume");
static_assert(offsetof(ALGameTagVolume, ExecuteTags) == 0x000238, "Member 'ALGameTagVolume::ExecuteTags' has a wrong offset!");

// Class ProjectP.LGameUserSettings
// 0x0040 (0x01D0 - 0x0190)
class ULGameUserSettings final : public UGameUserSettings
{
public:
	bool                                          IsInitedGraphic;                                   // 0x0190(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              LastResolution;                                    // 0x0194(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayTracingShadows;                                 // 0x019C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayTracingAmbientOcclusion;                        // 0x019D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayTracingSkyLight;                                // 0x019E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayTracingGlobalIllumination;                      // 0x019F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayTracingTranslucency;                            // 0x01A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayTracingReflections;                             // 0x01A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VRSEnabled;                                        // 0x01A2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CACAOEnabled;                                      // 0x01A3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDLSSMode                                     DLSSMode;                                          // 0x01A4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DLSSSharpness;                                     // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DLSSFrameGeneration;                               // 0x01AC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFSR1Mode                                     FSR1Mode;                                          // 0x01AD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFSR2Mode                                     FSR2Mode;                                          // 0x01AE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF[0x1];                                      // 0x01AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FSR2Sharpness;                                     // 0x01B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EXeSSMode                                     XeSSMode;                                          // 0x01B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReflexMode                                   ReflexMode;                                        // 0x01B5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HDROutputEnabled;                                  // 0x01B6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B7[0x1];                                      // 0x01B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ColorBrightness;                                   // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HDRBrightness;                                     // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HDRContrast;                                       // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstBrightnessSetting;                            // 0x01C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayStyle;                                         // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHFREnabled;                                       // 0x01CC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameUserSettings">();
	}
	static class ULGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameUserSettings>();
	}
};
static_assert(alignof(ULGameUserSettings) == 0x000008, "Wrong alignment on ULGameUserSettings");
static_assert(sizeof(ULGameUserSettings) == 0x0001D0, "Wrong size on ULGameUserSettings");
static_assert(offsetof(ULGameUserSettings, IsInitedGraphic) == 0x000190, "Member 'ULGameUserSettings::IsInitedGraphic' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, LastResolution) == 0x000194, "Member 'ULGameUserSettings::LastResolution' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, RayTracingShadows) == 0x00019C, "Member 'ULGameUserSettings::RayTracingShadows' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, RayTracingAmbientOcclusion) == 0x00019D, "Member 'ULGameUserSettings::RayTracingAmbientOcclusion' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, RayTracingSkyLight) == 0x00019E, "Member 'ULGameUserSettings::RayTracingSkyLight' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, RayTracingGlobalIllumination) == 0x00019F, "Member 'ULGameUserSettings::RayTracingGlobalIllumination' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, RayTracingTranslucency) == 0x0001A0, "Member 'ULGameUserSettings::RayTracingTranslucency' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, RayTracingReflections) == 0x0001A1, "Member 'ULGameUserSettings::RayTracingReflections' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, VRSEnabled) == 0x0001A2, "Member 'ULGameUserSettings::VRSEnabled' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, CACAOEnabled) == 0x0001A3, "Member 'ULGameUserSettings::CACAOEnabled' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, DLSSMode) == 0x0001A4, "Member 'ULGameUserSettings::DLSSMode' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, DLSSSharpness) == 0x0001A8, "Member 'ULGameUserSettings::DLSSSharpness' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, DLSSFrameGeneration) == 0x0001AC, "Member 'ULGameUserSettings::DLSSFrameGeneration' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, FSR1Mode) == 0x0001AD, "Member 'ULGameUserSettings::FSR1Mode' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, FSR2Mode) == 0x0001AE, "Member 'ULGameUserSettings::FSR2Mode' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, FSR2Sharpness) == 0x0001B0, "Member 'ULGameUserSettings::FSR2Sharpness' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, XeSSMode) == 0x0001B4, "Member 'ULGameUserSettings::XeSSMode' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, ReflexMode) == 0x0001B5, "Member 'ULGameUserSettings::ReflexMode' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, HDROutputEnabled) == 0x0001B6, "Member 'ULGameUserSettings::HDROutputEnabled' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, ColorBrightness) == 0x0001B8, "Member 'ULGameUserSettings::ColorBrightness' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, HDRBrightness) == 0x0001BC, "Member 'ULGameUserSettings::HDRBrightness' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, HDRContrast) == 0x0001C0, "Member 'ULGameUserSettings::HDRContrast' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, FirstBrightnessSetting) == 0x0001C4, "Member 'ULGameUserSettings::FirstBrightnessSetting' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, PlayStyle) == 0x0001C8, "Member 'ULGameUserSettings::PlayStyle' has a wrong offset!");
static_assert(offsetof(ULGameUserSettings, bHFREnabled) == 0x0001CC, "Member 'ULGameUserSettings::bHFREnabled' has a wrong offset!");

// Class ProjectP.LMovieSystemData
// 0x0010 (0x01F0 - 0x01E0)
class ALMovieSystemData : public AActor
{
public:
	class FName                                   OpenMovieCodeName;                                 // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayingMovieCodeName;                              // 0x01E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearMovieData();
	void DeactivatePauseOnReachedEnd();
	bool IsPauseOnReachedEnd();
	bool IsPlayingBinkMovie();
	void MovieSeekToLast();
	bool PlayBinkMovie(class FName MovieCodeName, const class FString& MovieUrl, bool bPauseOnReachedEnd);
	void StopBinkMovie(class FName MovieCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMovieSystemData">();
	}
	static class ALMovieSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALMovieSystemData>();
	}
};
static_assert(alignof(ALMovieSystemData) == 0x000008, "Wrong alignment on ALMovieSystemData");
static_assert(sizeof(ALMovieSystemData) == 0x0001F0, "Wrong size on ALMovieSystemData");
static_assert(offsetof(ALMovieSystemData, OpenMovieCodeName) == 0x0001E0, "Member 'ALMovieSystemData::OpenMovieCodeName' has a wrong offset!");
static_assert(offsetof(ALMovieSystemData, PlayingMovieCodeName) == 0x0001E8, "Member 'ALMovieSystemData::PlayingMovieCodeName' has a wrong offset!");

// Class ProjectP.LGameVariables
// 0x0008 (0x0030 - 0x0028)
class ULGameVariables final : public UObject
{
public:
	class UCurveFloat*                            WirePullingCurve;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameVariables">();
	}
	static class ULGameVariables* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameVariables>();
	}
};
static_assert(alignof(ULGameVariables) == 0x000008, "Wrong alignment on ULGameVariables");
static_assert(sizeof(ULGameVariables) == 0x000030, "Wrong size on ULGameVariables");
static_assert(offsetof(ULGameVariables, WirePullingCurve) == 0x000028, "Member 'ULGameVariables::WirePullingCurve' has a wrong offset!");

// Class ProjectP.LGameViewportClient
// 0x0000 (0x0370 - 0x0370)
class ULGameViewportClient final : public UGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGameViewportClient">();
	}
	static class ULGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGameViewportClient>();
	}
};
static_assert(alignof(ULGameViewportClient) == 0x000008, "Wrong alignment on ULGameViewportClient");
static_assert(sizeof(ULGameViewportClient) == 0x000370, "Wrong size on ULGameViewportClient");

// Class ProjectP.LNiagaraDataInterfaceWind
// 0x0000 (0x0038 - 0x0038)
class ULNiagaraDataInterfaceWind final : public UNiagaraDataInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNiagaraDataInterfaceWind">();
	}
	static class ULNiagaraDataInterfaceWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNiagaraDataInterfaceWind>();
	}
};
static_assert(alignof(ULNiagaraDataInterfaceWind) == 0x000008, "Wrong alignment on ULNiagaraDataInterfaceWind");
static_assert(sizeof(ULNiagaraDataInterfaceWind) == 0x000038, "Wrong size on ULNiagaraDataInterfaceWind");

// Class ProjectP.LGarbageCollectionVolume
// 0x0008 (0x0240 - 0x0238)
class ALGarbageCollectionVolume final : public ALVolume
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGarbageCollectionVolume">();
	}
	static class ALGarbageCollectionVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGarbageCollectionVolume>();
	}
};
static_assert(alignof(ALGarbageCollectionVolume) == 0x000008, "Wrong alignment on ALGarbageCollectionVolume");
static_assert(sizeof(ALGarbageCollectionVolume) == 0x000240, "Wrong size on ALGarbageCollectionVolume");

// Class ProjectP.LPlayerInput
// 0x01E0 (0x0588 - 0x03A8)
class ULPlayerInput final : public UPlayerInput
{
public:
	uint8                                         Pad_3A8[0x1E0];                                    // 0x03A8(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayerInput">();
	}
	static class ULPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayerInput>();
	}
};
static_assert(alignof(ULPlayerInput) == 0x000008, "Wrong alignment on ULPlayerInput");
static_assert(sizeof(ULPlayerInput) == 0x000588, "Wrong size on ULPlayerInput");

// Class ProjectP.LGuideObject
// 0x0008 (0x0268 - 0x0260)
class ALGuideObject : public ALLevelObject
{
public:
	float                                         EffectDisappearTime;                               // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGuideObject">();
	}
	static class ALGuideObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGuideObject>();
	}
};
static_assert(alignof(ALGuideObject) == 0x000008, "Wrong alignment on ALGuideObject");
static_assert(sizeof(ALGuideObject) == 0x000268, "Wrong size on ALGuideObject");
static_assert(offsetof(ALGuideObject, EffectDisappearTime) == 0x000260, "Member 'ALGuideObject::EffectDisappearTime' has a wrong offset!");

// Class ProjectP.LHeadTagComponent
// 0x0010 (0x05A0 - 0x0590)
class ULHeadTagComponent final : public UWidgetComponent
{
public:
	uint8                                         Pad_590[0x10];                                     // 0x0590(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanHeadTagVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHeadTagComponent">();
	}
	static class ULHeadTagComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHeadTagComponent>();
	}
};
static_assert(alignof(ULHeadTagComponent) == 0x000010, "Wrong alignment on ULHeadTagComponent");
static_assert(sizeof(ULHeadTagComponent) == 0x0005A0, "Wrong size on ULHeadTagComponent");

// Class ProjectP.LPathWaySplineComponent
// 0x0000 (0x0540 - 0x0540)
class ULPathWaySplineComponent final : public USplineComponent
{
public:
	class UFont*                                  WayPointFont;                                      // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPathWaySplineComponent">();
	}
	static class ULPathWaySplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPathWaySplineComponent>();
	}
};
static_assert(alignof(ULPathWaySplineComponent) == 0x000010, "Wrong alignment on ULPathWaySplineComponent");
static_assert(sizeof(ULPathWaySplineComponent) == 0x000540, "Wrong size on ULPathWaySplineComponent");
static_assert(offsetof(ULPathWaySplineComponent, WayPointFont) == 0x000538, "Member 'ULPathWaySplineComponent::WayPointFont' has a wrong offset!");

// Class ProjectP.LHitCollisionCapsuleComponent
// 0x0000 (0x0460 - 0x0460)
class ULHitCollisionCapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitCollisionCapsuleComponent">();
	}
	static class ULHitCollisionCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHitCollisionCapsuleComponent>();
	}
};
static_assert(alignof(ULHitCollisionCapsuleComponent) == 0x000010, "Wrong alignment on ULHitCollisionCapsuleComponent");
static_assert(sizeof(ULHitCollisionCapsuleComponent) == 0x000460, "Wrong size on ULHitCollisionCapsuleComponent");

// Class ProjectP.LHitCollisionSphereComponent
// 0x0000 (0x0460 - 0x0460)
class ULHitCollisionSphereComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitCollisionSphereComponent">();
	}
	static class ULHitCollisionSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHitCollisionSphereComponent>();
	}
};
static_assert(alignof(ULHitCollisionSphereComponent) == 0x000010, "Wrong alignment on ULHitCollisionSphereComponent");
static_assert(sizeof(ULHitCollisionSphereComponent) == 0x000460, "Wrong size on ULHitCollisionSphereComponent");

// Class ProjectP.LHitCollisionDynamic
// 0x00E0 (0x02C0 - 0x01E0)
class alignas(0x10) ALHitCollisionDynamic final : public AActor
{
public:
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UShapeComponent*                        ShapeComponent;                                    // 0x01E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCollisionOwnerType                          CollisionOwnerType;                                // 0x01F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitColMgrComponent*                   HitColMgrComponent;                                // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0xC0];                                     // 0x0200(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetCollisionOwner();
	ELPhysicalSurfaceType GetPhysicalSurface();

	class FName GetPartsCodeName() const;
	bool IsAttackCollision() const;
	bool IsGuardCollision() const;
	bool IsPartsGuardCollision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitCollisionDynamic">();
	}
	static class ALHitCollisionDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALHitCollisionDynamic>();
	}
};
static_assert(alignof(ALHitCollisionDynamic) == 0x000010, "Wrong alignment on ALHitCollisionDynamic");
static_assert(sizeof(ALHitCollisionDynamic) == 0x0002C0, "Wrong size on ALHitCollisionDynamic");
static_assert(offsetof(ALHitCollisionDynamic, ShapeComponent) == 0x0001E8, "Member 'ALHitCollisionDynamic::ShapeComponent' has a wrong offset!");
static_assert(offsetof(ALHitCollisionDynamic, CollisionOwnerType) == 0x0001F0, "Member 'ALHitCollisionDynamic::CollisionOwnerType' has a wrong offset!");
static_assert(offsetof(ALHitCollisionDynamic, HitColMgrComponent) == 0x0001F8, "Member 'ALHitCollisionDynamic::HitColMgrComponent' has a wrong offset!");

// Class ProjectP.LHitProcComponent
// 0x0208 (0x02B8 - 0x00B0)
class ULHitProcComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HitProcContextClass;                               // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULHitProcContext*                       Cached_HitProcContext;                             // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitInfo                              Cached_LastHitInfo;                                // 0x0130(0x0150)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   RedirectToSkill_Paralyzation;                      // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RedirectToSkill_Groggy;                            // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Cached_LastRegisteredSocketTracer_Fx;              // 0x0290(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Cached_LastRegisteredSocketTracer_Repulse;         // 0x0294(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Cached_LastRegisteredSocketTracer_RepulseForWeaponOnly; // 0x0298(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLTest_HitProcOptions                  TestOption;                                        // 0x02A0(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LastHitTime;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetDebugShowRepulseSparkInfo();
	void OnActionStarted(class ULActMgrComponent* ActMgrComponent, class ULActBase* StartedAction);
	void OnActionStopCalled(class ULActMgrComponent* ActMgrComponent, class ULActBase* StoppingAction, class ULActBase* ReasonAction);
	void OnDebugHitOcurred(const struct FHitResult& Info);
	void OnFxSocketHitOccurred(class ULActMgrComponent* ActMgrComponent, const struct FLFxSocketTracerInfo& SocketTracerInfo, const struct FHitResult& HitResult);
	void OnRepulseSocketHitOccurred(class ULActMgrComponent* ActMgrComponent, const struct FLFxSocketTracerInfo& SocketTracerInfo, const struct FHitResult& HitResult);
	void ProcessHit(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult, const struct FLHitInfo& HitInfo);
	void ProcessHitDecoMesh(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult);
	void ProcessHitProp(class AActor* Attacker, class AActor* Victim, const struct FHitResult& HitResult, const struct FLHitInfo& HitInfo);
	void RegisterNewHit(class AActor* Victim, const struct FLHitContext& HitContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHitProcComponent">();
	}
	static class ULHitProcComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHitProcComponent>();
	}
};
static_assert(alignof(ULHitProcComponent) == 0x000008, "Wrong alignment on ULHitProcComponent");
static_assert(sizeof(ULHitProcComponent) == 0x0002B8, "Wrong size on ULHitProcComponent");
static_assert(offsetof(ULHitProcComponent, HitProcContextClass) == 0x000100, "Member 'ULHitProcComponent::HitProcContextClass' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, Cached_HitProcContext) == 0x000128, "Member 'ULHitProcComponent::Cached_HitProcContext' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, Cached_LastHitInfo) == 0x000130, "Member 'ULHitProcComponent::Cached_LastHitInfo' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, RedirectToSkill_Paralyzation) == 0x000280, "Member 'ULHitProcComponent::RedirectToSkill_Paralyzation' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, RedirectToSkill_Groggy) == 0x000288, "Member 'ULHitProcComponent::RedirectToSkill_Groggy' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, Cached_LastRegisteredSocketTracer_Fx) == 0x000290, "Member 'ULHitProcComponent::Cached_LastRegisteredSocketTracer_Fx' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, Cached_LastRegisteredSocketTracer_Repulse) == 0x000294, "Member 'ULHitProcComponent::Cached_LastRegisteredSocketTracer_Repulse' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, Cached_LastRegisteredSocketTracer_RepulseForWeaponOnly) == 0x000298, "Member 'ULHitProcComponent::Cached_LastRegisteredSocketTracer_RepulseForWeaponOnly' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, TestOption) == 0x0002A0, "Member 'ULHitProcComponent::TestOption' has a wrong offset!");
static_assert(offsetof(ULHitProcComponent, LastHitTime) == 0x0002B0, "Member 'ULHitProcComponent::LastHitTime' has a wrong offset!");

// Class ProjectP.LHumanityDB
// 0x00B0 (0x00D8 - 0x0028)
class ULHumanityDB final : public UObject
{
public:
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHumanityDB">();
	}
	static class ULHumanityDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHumanityDB>();
	}
};
static_assert(alignof(ULHumanityDB) == 0x000008, "Wrong alignment on ULHumanityDB");
static_assert(sizeof(ULHumanityDB) == 0x0000D8, "Wrong size on ULHumanityDB");

// Class ProjectP.LInteractVolumeComponent
// 0x0010 (0x0480 - 0x0470)
class ULInteractVolumeComponent final : public UBoxComponent
{
public:
	bool                                          UseConfrontAngle_Override;                         // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConfrontAngle_Override;                            // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseConfrontAngleProp_Override;                     // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConfrontAngleProp_Override;                        // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractVolumeComponent">();
	}
	static class ULInteractVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInteractVolumeComponent>();
	}
};
static_assert(alignof(ULInteractVolumeComponent) == 0x000010, "Wrong alignment on ULInteractVolumeComponent");
static_assert(sizeof(ULInteractVolumeComponent) == 0x000480, "Wrong size on ULInteractVolumeComponent");
static_assert(offsetof(ULInteractVolumeComponent, UseConfrontAngle_Override) == 0x000468, "Member 'ULInteractVolumeComponent::UseConfrontAngle_Override' has a wrong offset!");
static_assert(offsetof(ULInteractVolumeComponent, ConfrontAngle_Override) == 0x00046C, "Member 'ULInteractVolumeComponent::ConfrontAngle_Override' has a wrong offset!");
static_assert(offsetof(ULInteractVolumeComponent, UseConfrontAngleProp_Override) == 0x000470, "Member 'ULInteractVolumeComponent::UseConfrontAngleProp_Override' has a wrong offset!");
static_assert(offsetof(ULInteractVolumeComponent, ConfrontAngleProp_Override) == 0x000474, "Member 'ULInteractVolumeComponent::ConfrontAngleProp_Override' has a wrong offset!");

// Class ProjectP.LInteractInterface
// 0x0000 (0x0028 - 0x0028)
class ILInteractInterface final : public IInterface
{
public:
	void CalcInteractionResult();
	struct FTransform GetInteractionStartTransform(bool* IsValid);
	class UAnimSequenceBase* GetInteractionUserAnimMontage();
	void HideInteractMessage();
	void InteractionEnd();
	bool IsValidUserInteractedComp();
	void RefreshPlayerInteraction();
	void StopPlayerInteraction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractInterface">();
	}
	static class ILInteractInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILInteractInterface>();
	}
};
static_assert(alignof(ILInteractInterface) == 0x000008, "Wrong alignment on ILInteractInterface");
static_assert(sizeof(ILInteractInterface) == 0x000028, "Wrong size on ILInteractInterface");

// Class ProjectP.LInteractionCapsuleComponent
// 0x0000 (0x0460 - 0x0460)
class ULInteractionCapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LInteractionCapsuleComponent">();
	}
	static class ULInteractionCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULInteractionCapsuleComponent>();
	}
};
static_assert(alignof(ULInteractionCapsuleComponent) == 0x000010, "Wrong alignment on ULInteractionCapsuleComponent");
static_assert(sizeof(ULInteractionCapsuleComponent) == 0x000460, "Wrong size on ULInteractionCapsuleComponent");

// Class ProjectP.LDialogControl
// 0x0040 (0x0068 - 0x0028)
class ULDialogControl final : public UObject
{
public:
	struct FLDisplayableDialog                    Dialogs;                                           // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FDialogInfoPtr                         ScriptInfo;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDialogInfoPtr>                 MenuItemInfos;                                     // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         SelectedMenuIndex;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEssensialNow;                                    // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLDialogExecute Execute();
	struct FLDialogExecute ExecuteSelect(int32 InMenuIdx);
	TArray<int32> GetMenuItemNotifies();
	TArray<class FText> GetMenuItemTexts();
	class FText GetNameText();
	class FText GetScriptText();
	void OnCloseUIByExecute(class FName WidgetTableName);
	int32 StartExecute();

	struct FDialogInfoPtr GetSelectedMenuInfoPtr() const;
	const struct FTalkerInfoPtr GetTalkerInfo() const;
	bool IsHoldSelectDialog() const;
	bool IsValid() const;
	bool WillExit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDialogControl">();
	}
	static class ULDialogControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDialogControl>();
	}
};
static_assert(alignof(ULDialogControl) == 0x000008, "Wrong alignment on ULDialogControl");
static_assert(sizeof(ULDialogControl) == 0x000068, "Wrong size on ULDialogControl");
static_assert(offsetof(ULDialogControl, Dialogs) == 0x000028, "Member 'ULDialogControl::Dialogs' has a wrong offset!");
static_assert(offsetof(ULDialogControl, ScriptInfo) == 0x000048, "Member 'ULDialogControl::ScriptInfo' has a wrong offset!");
static_assert(offsetof(ULDialogControl, MenuItemInfos) == 0x000050, "Member 'ULDialogControl::MenuItemInfos' has a wrong offset!");
static_assert(offsetof(ULDialogControl, SelectedMenuIndex) == 0x000060, "Member 'ULDialogControl::SelectedMenuIndex' has a wrong offset!");
static_assert(offsetof(ULDialogControl, IsEssensialNow) == 0x000064, "Member 'ULDialogControl::IsEssensialNow' has a wrong offset!");

// Class ProjectP.LDialogDB
// 0x00F0 (0x0118 - 0x0028)
class ULDialogDB final : public UObject
{
public:
	uint8                                         Pad_28[0xF0];                                      // 0x0028(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLDisplayableDialog GetDialog(class FName DialogCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDialogDB">();
	}
	static class ULDialogDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULDialogDB>();
	}
};
static_assert(alignof(ULDialogDB) == 0x000008, "Wrong alignment on ULDialogDB");
static_assert(sizeof(ULDialogDB) == 0x000118, "Wrong size on ULDialogDB");

// Class ProjectP.LPlayerInventory
// 0x01F0 (0x0218 - 0x0028)
class ULPlayerInventory final : public UObject
{
public:
	uint8                                         Pad_28[0xC8];                                      // 0x0028(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAddItem;                                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveItem;                                      // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateItem;                                      // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetItemEventWithCount;                           // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGetItemSpecialWithCount;                         // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> ItemCategoryMap;                                   // 0x0140(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULWeaponItem*>                   WeaponItemList;                                    // 0x0190(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         AllItemList;                                       // 0x01A0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         BladeItemList;                                     // 0x01B0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         HandleItemList;                                    // 0x01C0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         GearItemList;                                      // 0x01D0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULItem*>                         PartsItemList;                                     // 0x01E0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ULSlaveArmItem*>                 SlaveArmItemList;                                  // 0x01F0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x18];                                     // 0x0200(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AbandonItem(class ULItem* Item, int32 RemoveCount);
	bool AddItem(class ULItem* Item);
	void BlockNewNotification(bool InBlocked);
	void ClearAllNotification();
	void ClearAllNotification_Inven();
	void ClearCategoryNotification(ELItemFirstCategory Category);
	bool ConsumeItem(class ULItem* Item, int32 ConsumeCount);
	bool ConsumeItemByCodeName(class FName CodeName, int32 ConsumeCount);
	void EmptyItems();
	TArray<class ULItem*> FindBladeItems();
	TArray<class ULItem*> FindCategoryItems(ELItemSecondCategory Category);
	TArray<class ULItem*> FindHandleItems();
	class ULItem* FindItemByCodeName(class FName CodeName);
	TArray<class ULItem*> FindItemsByCodeName(class FName CodeName);
	TArray<class ULItem*> FindUICategoryItems(ELItemFirstCategory Category);
	const TArray<class ULItem*> GetAllItems();
	const TArray<class ULItem*> GetBladeItems();
	const TArray<class ULItem*> GetGearItems();
	const TArray<class ULItem*> GetHandleItems();
	const TMap<ELItemSecondCategory, struct FLInvenCategoryItemList> GetItemCategoryMap();
	int32 GetItemTotalCountByCodeName(class FName CodeName);
	const TArray<class ULItem*> GetPartsItems();
	const TArray<class ULSlaveArmItem*> GetSlaveArmItems();
	const TArray<class ULWeaponItem*> GetWeaponItems();
	TArray<class ULWeaponItem*> GetWeaponItems_SortedByEquipSlot();
	int32 GetWeaponTotalCountByCodeName(class FName HandleCodeName, class FName BladeCodeName);
	bool HasItem(class ULItem* Item);
	bool IsNotiCategory(ELItemFirstCategory Category);
	bool IsNotiItem(class ULItem* InItem);
	ELItemGainResult MoveItemToLocker(class ULItem* Item, int32 ItemCount);
	void RechargeConsumeItems();
	bool RemoveItem(class ULItem* Item);

	bool HasSameItem(class FName ItemCodeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayerInventory">();
	}
	static class ULPlayerInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayerInventory>();
	}
};
static_assert(alignof(ULPlayerInventory) == 0x000008, "Wrong alignment on ULPlayerInventory");
static_assert(sizeof(ULPlayerInventory) == 0x000218, "Wrong size on ULPlayerInventory");
static_assert(offsetof(ULPlayerInventory, OnAddItem) == 0x0000F0, "Member 'ULPlayerInventory::OnAddItem' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, OnRemoveItem) == 0x000100, "Member 'ULPlayerInventory::OnRemoveItem' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, OnUpdateItem) == 0x000110, "Member 'ULPlayerInventory::OnUpdateItem' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, OnGetItemEventWithCount) == 0x000120, "Member 'ULPlayerInventory::OnGetItemEventWithCount' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, OnGetItemSpecialWithCount) == 0x000130, "Member 'ULPlayerInventory::OnGetItemSpecialWithCount' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, ItemCategoryMap) == 0x000140, "Member 'ULPlayerInventory::ItemCategoryMap' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, WeaponItemList) == 0x000190, "Member 'ULPlayerInventory::WeaponItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, AllItemList) == 0x0001A0, "Member 'ULPlayerInventory::AllItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, BladeItemList) == 0x0001B0, "Member 'ULPlayerInventory::BladeItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, HandleItemList) == 0x0001C0, "Member 'ULPlayerInventory::HandleItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, GearItemList) == 0x0001D0, "Member 'ULPlayerInventory::GearItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, PartsItemList) == 0x0001E0, "Member 'ULPlayerInventory::PartsItemList' has a wrong offset!");
static_assert(offsetof(ULPlayerInventory, SlaveArmItemList) == 0x0001F0, "Member 'ULPlayerInventory::SlaveArmItemList' has a wrong offset!");

// Class ProjectP.LPulseItem
// 0x0010 (0x00B8 - 0x00A8)
class ULPulseItem final : public ULItem
{
public:
	uint8                                         bPulseGaugeRechargeable : 1;                       // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRecharged : 1;                                    // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PulseItemExhaustedCount;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PulseGaugeRechargedCount;                          // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPulseItem">();
	}
	static class ULPulseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPulseItem>();
	}
};
static_assert(alignof(ULPulseItem) == 0x000008, "Wrong alignment on ULPulseItem");
static_assert(sizeof(ULPulseItem) == 0x0000B8, "Wrong size on ULPulseItem");
static_assert(offsetof(ULPulseItem, PulseItemExhaustedCount) == 0x0000AC, "Member 'ULPulseItem::PulseItemExhaustedCount' has a wrong offset!");
static_assert(offsetof(ULPulseItem, PulseGaugeRechargedCount) == 0x0000B0, "Member 'ULPulseItem::PulseGaugeRechargedCount' has a wrong offset!");

// Class ProjectP.LMonadUnitItem
// 0x0000 (0x00A8 - 0x00A8)
class ULMonadUnitItem final : public ULItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMonadUnitItem">();
	}
	static class ULMonadUnitItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULMonadUnitItem>();
	}
};
static_assert(alignof(ULMonadUnitItem) == 0x000008, "Wrong alignment on ULMonadUnitItem");
static_assert(sizeof(ULMonadUnitItem) == 0x0000A8, "Wrong size on ULMonadUnitItem");

// Class ProjectP.LNpcSpotDieData
// 0x0090 (0x00B8 - 0x0028)
class ULNpcSpotDieData final : public UObject
{
public:
	TWeakObjectPtr<class ALNPCSpot>               NpcSpot;                                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNPCSpotDieInfoPtr                     InfoPtr;                                           // 0x0030(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<ELNpcSpotDieType>                      ProcessTypeList;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ELNpcSpotDieType>                      EtcTypeList;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ELNpcSpotDieType                              CurrentType;                                       // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALPropLevelSequenceSpot> LevelSequenceSpot;                                 // 0x005C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReserveNextProcess;                                // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      AcquiredItemMap;                                   // 0x0068(0x0050)(NativeAccessSpecifierPublic)

public:
	void ExecuteChangeWeather();
	void ExecuteDeadBossAlert();
	void ExecuteDeadBossAlertAfterCommand();
	void ExecuteDialog();
	void ExecuteItemAlert();
	void ExecuteLevelSequence();
	void ExecuteMonologue();
	void ExecuteMovie();
	void ExecuteUiFadeOut();
	void NextNpcSpotDieProcess();
	void ResponseDialogExit();
	void ResponseLevelSequenceEnd(const class FString& SpotUniqueID);
	void ResponseMonologueExit();
	void ResponseMovieEnd(const class FName& MovieCodeName);
	void ResponseUiFadeOutEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNpcSpotDieData">();
	}
	static class ULNpcSpotDieData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNpcSpotDieData>();
	}
};
static_assert(alignof(ULNpcSpotDieData) == 0x000008, "Wrong alignment on ULNpcSpotDieData");
static_assert(sizeof(ULNpcSpotDieData) == 0x0000B8, "Wrong size on ULNpcSpotDieData");
static_assert(offsetof(ULNpcSpotDieData, NpcSpot) == 0x000028, "Member 'ULNpcSpotDieData::NpcSpot' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, InfoPtr) == 0x000030, "Member 'ULNpcSpotDieData::InfoPtr' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, ProcessTypeList) == 0x000038, "Member 'ULNpcSpotDieData::ProcessTypeList' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, EtcTypeList) == 0x000048, "Member 'ULNpcSpotDieData::EtcTypeList' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, CurrentType) == 0x000058, "Member 'ULNpcSpotDieData::CurrentType' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, LevelSequenceSpot) == 0x00005C, "Member 'ULNpcSpotDieData::LevelSequenceSpot' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, ReserveNextProcess) == 0x000064, "Member 'ULNpcSpotDieData::ReserveNextProcess' has a wrong offset!");
static_assert(offsetof(ULNpcSpotDieData, AcquiredItemMap) == 0x000068, "Member 'ULNpcSpotDieData::AcquiredItemMap' has a wrong offset!");

// Class ProjectP.LItemSystem
// 0x0180 (0x01F8 - 0x0078)
class ULItemSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateItem;                                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0xF8];                                      // 0x0088(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPlayerInventory*                      PlayerInventory;                                   // 0x0180(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULPlayerEquipment*                      PlayerEquipment;                                   // 0x0188(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULPlayerItemLocker*                     PlayerItemLocker;                                  // 0x0190(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULProductBuyShop*>               BuyShops;                                          // 0x0198(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class ULProductSellShop*                      SellShop;                                          // 0x01A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULProductSpecialShop*>           SpecialShops;                                      // 0x01B0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class ULItem*                                 UsedItem;                                          // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 TorsionCoilReservedItem;                           // 0x01C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULItem*                                 ForceUseReservedItem;                              // 0x01D0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveShopCodeName;                                // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           CheckedLettersPage;                                // 0x01E0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FLItemCostumeTable                     ItemCostumeTable;                                  // 0x01F0(0x0008)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool AbandonItem(class ULItem* Item, int32 InCount);
	bool ChangeCorrectionHandle(ELStatCorrectChangeType Type, class ULItem* HandleOrWeapon);
	bool CheckItemCanUsed(class ULItem* Item, int32 UseCount);
	bool CombineWeapon(class ULWeaponItem* WeaponToChange, const struct FLWeaponPartInfoForCombine& HandlePart, const struct FLWeaponPartInfoForCombine& BladePart, class ULWeaponItem** OutResultWeaponItem);
	bool CombineWeaponWithoutRestrictions(class ULItem* HandleItem, class ULItem* BladeItem, class ULWeaponItem** OutResultWeaponItem);
	class ULItem* CreateItem(class FName CodeName);
	class ULWeaponItem* CreateWeaponItem(class FName HandleCodeName, class FName BladeCodeName);
	void DecideForceUseItem(bool Result, class FName ItemCodeName);
	bool DestoryItem(class ULItem* Item);
	bool DivideWeapon(class ULWeaponItem* WeaponItem, class ULItem** ResultHandleItem, class ULItem** ResultBladeItem);
	struct FSlavearmAlterItemMatchInfoPtr FindSlavearmAlteredConsumeItemInfo(class FName ConsumeItemCodename, class FName SlaveArmItemCodename);
	void GetBladeListForCombine(class ULWeaponItem* WeaponToChange, TArray<struct FLWeaponPartInfoForCombine>* OutBladeInfoList);
	class ULProductBuyShop* GetBuyShop(class FName ShopCodeName);
	void GetChangeCorrectionHandleNeeds(ELStatCorrectChangeType InType, class ULItem* InHandleOrWeapon, class FName* OutItemCodeName, int32* OutItemCount, int32* OutErgoCount);
	class ULWeaponItem* GetCombineResultWeapon(class ULItem* HandleItem, class ULItem* BladeItem);
	ELConsumeItemSlavearmAtlerableState GetConsumeItemAlterableState(class FName ConsumeItemCodename);
	void GetHandleListForCombine(class ULWeaponItem* WeaponToChange, TArray<struct FLWeaponPartInfoForCombine>* OutHandleInfoList);
	TSoftObjectPtr<class UObject> GetItemToggleImageResource(class ULItem* Item);
	void GetNecessaryMaterialForCombineWeapon(class ULItem* HandleItem, class ULItem* BladeItem, int32* CurrentCost, int32* RequireCost, TArray<struct FLItemRequireCount>* RequireItems);
	void GetNecessaryMaterialForDivideWeapon(class ULWeaponItem* WeaponItem, int32* CurrentCost, int32* RequireCost, struct FLItemRequireCount* Item1, struct FLItemRequireCount* Item2);
	class ULPlayerEquipment* GetPlayerEquipment();
	class ULPlayerInventory* GetPlayerInventory();
	class ULPlayerItemLocker* GetPlayerItemLocker();
	bool GetPulseGaugeRechargeSystemEnable();
	int32 GetPulseItemExhaustedCount();
	int32 GetPulseItemRechargeableCount();
	int32 GetPulseItemRechargedCount();
	bool GetPulseRechargeable();
	class ULItem* GetReadyToUseItem(class ULActBase* Action, int32* OutUseCount);
	TArray<ELItemSecondCategory> GetSecondCategory_Blade();
	TArray<ELItemSecondCategory> GetSecondCategory_FromFirst(ELItemFirstCategory InCategory);
	TArray<ELItemSecondCategory> GetSecondCategory_Handle();
	class ULProductSellShop* GetSellShop();
	class ULProductSpecialShop* GetSpecialShop(class FName ShopCodeName);
	bool GetUnusableNow(class FName ItemCodeName);
	bool MakeComplexItem(class ULItem* ComplexItem_Main, class ULItem* ComplexItem_Unit);
	void OnClosedWindow(class FName WidgetTableName);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);
	void OnReadLetter(class FName InLetterName, int32 InPageNum);
	void OnUpdateItemInventory(class ULItem* Item);
	void RechargeConsumeItems();
	bool ReinforceBlade(class ULItem* BladeOrWeapon);
	void RestoreWeaponSharpnessMax();
	void SetPulseGaugeRechargeSystemEnable(bool bEnable);
	bool UseItem(class ULItem* Item, int32 UseCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LItemSystem">();
	}
	static class ULItemSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULItemSystem>();
	}
};
static_assert(alignof(ULItemSystem) == 0x000008, "Wrong alignment on ULItemSystem");
static_assert(sizeof(ULItemSystem) == 0x0001F8, "Wrong size on ULItemSystem");
static_assert(offsetof(ULItemSystem, OnUpdateItem) == 0x000078, "Member 'ULItemSystem::OnUpdateItem' has a wrong offset!");
static_assert(offsetof(ULItemSystem, PlayerInventory) == 0x000180, "Member 'ULItemSystem::PlayerInventory' has a wrong offset!");
static_assert(offsetof(ULItemSystem, PlayerEquipment) == 0x000188, "Member 'ULItemSystem::PlayerEquipment' has a wrong offset!");
static_assert(offsetof(ULItemSystem, PlayerItemLocker) == 0x000190, "Member 'ULItemSystem::PlayerItemLocker' has a wrong offset!");
static_assert(offsetof(ULItemSystem, BuyShops) == 0x000198, "Member 'ULItemSystem::BuyShops' has a wrong offset!");
static_assert(offsetof(ULItemSystem, SellShop) == 0x0001A8, "Member 'ULItemSystem::SellShop' has a wrong offset!");
static_assert(offsetof(ULItemSystem, SpecialShops) == 0x0001B0, "Member 'ULItemSystem::SpecialShops' has a wrong offset!");
static_assert(offsetof(ULItemSystem, UsedItem) == 0x0001C0, "Member 'ULItemSystem::UsedItem' has a wrong offset!");
static_assert(offsetof(ULItemSystem, TorsionCoilReservedItem) == 0x0001C8, "Member 'ULItemSystem::TorsionCoilReservedItem' has a wrong offset!");
static_assert(offsetof(ULItemSystem, ForceUseReservedItem) == 0x0001D0, "Member 'ULItemSystem::ForceUseReservedItem' has a wrong offset!");
static_assert(offsetof(ULItemSystem, ActiveShopCodeName) == 0x0001D8, "Member 'ULItemSystem::ActiveShopCodeName' has a wrong offset!");
static_assert(offsetof(ULItemSystem, CheckedLettersPage) == 0x0001E0, "Member 'ULItemSystem::CheckedLettersPage' has a wrong offset!");
static_assert(offsetof(ULItemSystem, ItemCostumeTable) == 0x0001F0, "Member 'ULItemSystem::ItemCostumeTable' has a wrong offset!");

// Class ProjectP.LFogGateObject
// 0x0000 (0x0260 - 0x0260)
class ALFogGateObject : public ALLevelObject
{
public:
	void SetFogGateState(ELFogGateState StateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFogGateObject">();
	}
	static class ALFogGateObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALFogGateObject>();
	}
};
static_assert(alignof(ALFogGateObject) == 0x000008, "Wrong alignment on ALFogGateObject");
static_assert(sizeof(ALFogGateObject) == 0x000260, "Wrong size on ALFogGateObject");

// Class ProjectP.LSequenceTransformTracker
// 0x0090 (0x0270 - 0x01E0)
class ALSequenceTransformTracker final : public AActor
{
public:
	struct FLSequenceTarget                       TrackingTargetFirst;                               // 0x01E0(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLSequenceTarget                       TrackingTargetSecond;                              // 0x0220(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BlendAlpha;                                        // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0xC];                                      // 0x0264(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSequenceTransformTracker">();
	}
	static class ALSequenceTransformTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSequenceTransformTracker>();
	}
};
static_assert(alignof(ALSequenceTransformTracker) == 0x000008, "Wrong alignment on ALSequenceTransformTracker");
static_assert(sizeof(ALSequenceTransformTracker) == 0x000270, "Wrong size on ALSequenceTransformTracker");
static_assert(offsetof(ALSequenceTransformTracker, TrackingTargetFirst) == 0x0001E0, "Member 'ALSequenceTransformTracker::TrackingTargetFirst' has a wrong offset!");
static_assert(offsetof(ALSequenceTransformTracker, TrackingTargetSecond) == 0x000220, "Member 'ALSequenceTransformTracker::TrackingTargetSecond' has a wrong offset!");
static_assert(offsetof(ALSequenceTransformTracker, BlendAlpha) == 0x000260, "Member 'ALSequenceTransformTracker::BlendAlpha' has a wrong offset!");

// Class ProjectP.LCineCameraActor
// 0x0000 (0x0820 - 0x0820)
class ALCineCameraActor final : public ACineCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCineCameraActor">();
	}
	static class ALCineCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALCineCameraActor>();
	}
};
static_assert(alignof(ALCineCameraActor) == 0x000010, "Wrong alignment on ALCineCameraActor");
static_assert(sizeof(ALCineCameraActor) == 0x000820, "Wrong size on ALCineCameraActor");

// Class ProjectP.LLevelSequenceSystemData
// 0x0010 (0x01F0 - 0x01E0)
class ALLevelSequenceSystemData : public AActor
{
public:
	TArray<struct FLSequenceMixer>                SequenceSoundMixes;                                // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelSequenceSystemData">();
	}
	static class ALLevelSequenceSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLevelSequenceSystemData>();
	}
};
static_assert(alignof(ALLevelSequenceSystemData) == 0x000008, "Wrong alignment on ALLevelSequenceSystemData");
static_assert(sizeof(ALLevelSequenceSystemData) == 0x0001F0, "Wrong size on ALLevelSequenceSystemData");
static_assert(offsetof(ALLevelSequenceSystemData, SequenceSoundMixes) == 0x0001E0, "Member 'ALLevelSequenceSystemData::SequenceSoundMixes' has a wrong offset!");

// Class ProjectP.LLevelSequenceSystem
// 0x0188 (0x0200 - 0x0078)
class ULLevelSequenceSystem final : public ULGameSubSystem
{
public:
	class ALLevelSequenceSystemData*              SystemData;                                        // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnStopSkipProcessUI;                               // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x50];                                      // 0x0090(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULSequenceActorData*>            SequenceActorDataList;                             // 0x00E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          TickReserveEnable;                                 // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReserveSpotUniqueID;                               // 0x00F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ReserveExecuteCommand;                             // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReservePlayReverse;                                // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0xF];                                      // 0x0111(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULSequenceActorData>     Cached_SkipSequenceActorData;                      // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     Cached_CanSkipSequenceActorData;                   // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULSequenceActorData>     Cached_LieEffectSequenceActorData;                 // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x50];                                     // 0x0138(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FLSubtitleHierarchyInfo> SubtitleDB;                                        // 0x0188(0x0050)(Protected, NativeAccessSpecifierProtected)
	bool                                          TickSubtitleEnable;                                // 0x01D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickSubtitleTime;                                  // 0x01DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TickSubtitleCodeName;                              // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubtitleStartTimeIndex;                            // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TickSubtitleStartTimeList;                         // 0x01F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void ForceUnLockPlayerAction();
	class ULSequenceActorData* GetLastPlayingSequenceActorData();
	class ULSequenceActorData* GetSequenceActorData(const class FName& SequenceCodeName);
	void OnLieDialogEnd();
	void OnLieDialogStart();
	void SkipPlayingSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelSequenceSystem">();
	}
	static class ULLevelSequenceSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLevelSequenceSystem>();
	}
};
static_assert(alignof(ULLevelSequenceSystem) == 0x000008, "Wrong alignment on ULLevelSequenceSystem");
static_assert(sizeof(ULLevelSequenceSystem) == 0x000200, "Wrong size on ULLevelSequenceSystem");
static_assert(offsetof(ULLevelSequenceSystem, SystemData) == 0x000078, "Member 'ULLevelSequenceSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, OnStopSkipProcessUI) == 0x000080, "Member 'ULLevelSequenceSystem::OnStopSkipProcessUI' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, SequenceActorDataList) == 0x0000E0, "Member 'ULLevelSequenceSystem::SequenceActorDataList' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, TickReserveEnable) == 0x0000F0, "Member 'ULLevelSequenceSystem::TickReserveEnable' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, ReserveSpotUniqueID) == 0x0000F8, "Member 'ULLevelSequenceSystem::ReserveSpotUniqueID' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, ReserveExecuteCommand) == 0x000108, "Member 'ULLevelSequenceSystem::ReserveExecuteCommand' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, ReservePlayReverse) == 0x000110, "Member 'ULLevelSequenceSystem::ReservePlayReverse' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, Cached_SkipSequenceActorData) == 0x000120, "Member 'ULLevelSequenceSystem::Cached_SkipSequenceActorData' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, Cached_CanSkipSequenceActorData) == 0x000128, "Member 'ULLevelSequenceSystem::Cached_CanSkipSequenceActorData' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, Cached_LieEffectSequenceActorData) == 0x000130, "Member 'ULLevelSequenceSystem::Cached_LieEffectSequenceActorData' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, SubtitleDB) == 0x000188, "Member 'ULLevelSequenceSystem::SubtitleDB' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, TickSubtitleEnable) == 0x0001D8, "Member 'ULLevelSequenceSystem::TickSubtitleEnable' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, TickSubtitleTime) == 0x0001DC, "Member 'ULLevelSequenceSystem::TickSubtitleTime' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, TickSubtitleCodeName) == 0x0001E0, "Member 'ULLevelSequenceSystem::TickSubtitleCodeName' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, SubtitleStartTimeIndex) == 0x0001E8, "Member 'ULLevelSequenceSystem::SubtitleStartTimeIndex' has a wrong offset!");
static_assert(offsetof(ULLevelSequenceSystem, TickSubtitleStartTimeList) == 0x0001F0, "Member 'ULLevelSequenceSystem::TickSubtitleStartTimeList' has a wrong offset!");

// Class ProjectP.LLevelSequenceUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULLevelSequenceUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ActiveFixCameraSpeed();
	static void ApplyPCCommand(class FName Command);
	static void DeactiveFixCameraSpeed();
	static void HidePC();
	static void LockPlayerAction(class ULevelSequencePlayer* NeedUnLockPlayerAction);
	static void ResetHeadLookatHolding();
	static void ShowPC();
	static void UnLockPlayerAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelSequenceUtilFuncLibrary">();
	}
	static class ULLevelSequenceUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLevelSequenceUtilFuncLibrary>();
	}
};
static_assert(alignof(ULLevelSequenceUtilFuncLibrary) == 0x000008, "Wrong alignment on ULLevelSequenceUtilFuncLibrary");
static_assert(sizeof(ULLevelSequenceUtilFuncLibrary) == 0x000028, "Wrong size on ULLevelSequenceUtilFuncLibrary");

// Class ProjectP.LLevelSkeletalMeshComponent
// 0x0010 (0x0ED0 - 0x0EC0)
class ULLevelSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_EB8[0x18];                                     // 0x0EB8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelSkeletalMeshComponent">();
	}
	static class ULLevelSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLevelSkeletalMeshComponent>();
	}
};
static_assert(alignof(ULLevelSkeletalMeshComponent) == 0x000010, "Wrong alignment on ULLevelSkeletalMeshComponent");
static_assert(sizeof(ULLevelSkeletalMeshComponent) == 0x000ED0, "Wrong size on ULLevelSkeletalMeshComponent");

// Class ProjectP.LLevelStreamingVolume
// 0x0008 (0x0238 - 0x0230)
class ALLevelStreamingVolume final : public ALevelStreamingVolume
{
public:
	EStreamingLayer                               StreamingLayer;                                    // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysLoadStreaming;                              // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelStreamingVolume">();
	}
	static class ALLevelStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLevelStreamingVolume>();
	}
};
static_assert(alignof(ALLevelStreamingVolume) == 0x000008, "Wrong alignment on ALLevelStreamingVolume");
static_assert(sizeof(ALLevelStreamingVolume) == 0x000238, "Wrong size on ALLevelStreamingVolume");
static_assert(offsetof(ALLevelStreamingVolume, StreamingLayer) == 0x000230, "Member 'ALLevelStreamingVolume::StreamingLayer' has a wrong offset!");
static_assert(offsetof(ALLevelStreamingVolume, bAlwaysLoadStreaming) == 0x000231, "Member 'ALLevelStreamingVolume::bAlwaysLoadStreaming' has a wrong offset!");

// Class ProjectP.LManualLevelStreamingTirgger
// 0x0008 (0x01E8 - 0x01E0)
class ALManualLevelStreamingTirgger final : public AActor
{
public:
	class UBoxComponent*                          CollisionComponent;                                // 0x01E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LManualLevelStreamingTirgger">();
	}
	static class ALManualLevelStreamingTirgger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALManualLevelStreamingTirgger>();
	}
};
static_assert(alignof(ALManualLevelStreamingTirgger) == 0x000008, "Wrong alignment on ALManualLevelStreamingTirgger");
static_assert(sizeof(ALManualLevelStreamingTirgger) == 0x0001E8, "Wrong size on ALManualLevelStreamingTirgger");
static_assert(offsetof(ALManualLevelStreamingTirgger, CollisionComponent) == 0x0001E0, "Member 'ALManualLevelStreamingTirgger::CollisionComponent' has a wrong offset!");

// Class ProjectP.LLight
// 0x0000 (0x01E0 - 0x01E0)
class ALLight final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLight">();
	}
	static class ALLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLight>();
	}
};
static_assert(alignof(ALLight) == 0x000008, "Wrong alignment on ALLight");
static_assert(sizeof(ALLight) == 0x0001E0, "Wrong size on ALLight");

// Class ProjectP.LLocalPlayer
// 0x0000 (0x0258 - 0x0258)
class ULLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLocalPlayer">();
	}
	static class ULLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLocalPlayer>();
	}
};
static_assert(alignof(ULLocalPlayer) == 0x000008, "Wrong alignment on ULLocalPlayer");
static_assert(sizeof(ULLocalPlayer) == 0x000258, "Wrong size on ULLocalPlayer");

// Class ProjectP.LLocationActor
// 0x0000 (0x01E0 - 0x01E0)
class ALLocationActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLocationActor">();
	}
	static class ALLocationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLocationActor>();
	}
};
static_assert(alignof(ALLocationActor) == 0x000008, "Wrong alignment on ALLocationActor");
static_assert(sizeof(ALLocationActor) == 0x0001E0, "Wrong size on ALLocationActor");

// Class ProjectP.LLockOnSystemData
// 0x0108 (0x02E8 - 0x01E0)
class ALLockOnSystemData : public AActor
{
public:
	struct FNoneLockOnAutoGuideData               NoneLockOnAutoGuideData;                           // 0x01E0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsLockOn;                                         // 0x01F8(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LockOnTarget;                                      // 0x0200(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrnetCameraRotationLagSpeed;                     // 0x0208(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMode;                                        // 0x020C(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSeeTargetsHiddenInEnvionment;                // 0x020D(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTarget;                                      // 0x020E(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugScreenPos;                                   // 0x020F(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSensitiveRotation;                           // 0x0210(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestFunction;                                     // 0x0211(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSensitiveRotationYaw;                          // 0x0212(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotationYawSectionData;                        // 0x0213(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLRotationYawSectionData>       RotationYawSectionDatas;                           // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLFloatInterval                        LimitPitchMinMax;                                  // 0x0228(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFloatInterval                        HoldPitchStopMove;                                 // 0x0230(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLockOnSensitiveRotation               SensitiveRotation;                                 // 0x0238(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FLockOnFocusedTargetOffsetMove         FocusedTargetOffsetMove;                           // 0x024C(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TryingLockOnRotationSpeed;                         // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBlockInverse;                                  // 0x027C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraLag;                                  // 0x027D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraRotationLag;                          // 0x027E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F[0x1];                                      // 0x027F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagSpeed;                                    // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistance;                              // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLimitPitchAngle;                                // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLimitPitchAngle;                                // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLockOnImportanceFactor                ImportanceFactor;                                  // 0x0294(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ScreenHorizontalRate;                              // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenVerticalRate;                                // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeNearbyDistanceCheckFromTarget;              // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeNearbyDistance;                              // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FowardCollectDistance;                             // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InheritCollectDistance;                            // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CollectFOVScaling;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperBodyLookAtBoneName;                           // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnPostponeTime;                                // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeNearbyDelayTime;                             // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamePadPressValue;                                 // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MousePressValue;                                   // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLockOnSystemData">();
	}
	static class ALLockOnSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLockOnSystemData>();
	}
};
static_assert(alignof(ALLockOnSystemData) == 0x000008, "Wrong alignment on ALLockOnSystemData");
static_assert(sizeof(ALLockOnSystemData) == 0x0002E8, "Wrong size on ALLockOnSystemData");
static_assert(offsetof(ALLockOnSystemData, NoneLockOnAutoGuideData) == 0x0001E0, "Member 'ALLockOnSystemData::NoneLockOnAutoGuideData' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bIsLockOn) == 0x0001F8, "Member 'ALLockOnSystemData::bIsLockOn' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, LockOnTarget) == 0x000200, "Member 'ALLockOnSystemData::LockOnTarget' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, CurrnetCameraRotationLagSpeed) == 0x000208, "Member 'ALLockOnSystemData::CurrnetCameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bDebugMode) == 0x00020C, "Member 'ALLockOnSystemData::bDebugMode' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bDebugSeeTargetsHiddenInEnvionment) == 0x00020D, "Member 'ALLockOnSystemData::bDebugSeeTargetsHiddenInEnvionment' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bDebugTarget) == 0x00020E, "Member 'ALLockOnSystemData::bDebugTarget' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bDebugScreenPos) == 0x00020F, "Member 'ALLockOnSystemData::bDebugScreenPos' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bDebugSensitiveRotation) == 0x000210, "Member 'ALLockOnSystemData::bDebugSensitiveRotation' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bTestFunction) == 0x000211, "Member 'ALLockOnSystemData::bTestFunction' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bUseSensitiveRotationYaw) == 0x000212, "Member 'ALLockOnSystemData::bUseSensitiveRotationYaw' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bUseRotationYawSectionData) == 0x000213, "Member 'ALLockOnSystemData::bUseRotationYawSectionData' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, RotationYawSectionDatas) == 0x000218, "Member 'ALLockOnSystemData::RotationYawSectionDatas' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, LimitPitchMinMax) == 0x000228, "Member 'ALLockOnSystemData::LimitPitchMinMax' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, HoldPitchStopMove) == 0x000230, "Member 'ALLockOnSystemData::HoldPitchStopMove' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, SensitiveRotation) == 0x000238, "Member 'ALLockOnSystemData::SensitiveRotation' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, FocusedTargetOffsetMove) == 0x00024C, "Member 'ALLockOnSystemData::FocusedTargetOffsetMove' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, TryingLockOnRotationSpeed) == 0x000278, "Member 'ALLockOnSystemData::TryingLockOnRotationSpeed' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bUseBlockInverse) == 0x00027C, "Member 'ALLockOnSystemData::bUseBlockInverse' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bEnableCameraLag) == 0x00027D, "Member 'ALLockOnSystemData::bEnableCameraLag' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bEnableCameraRotationLag) == 0x00027E, "Member 'ALLockOnSystemData::bEnableCameraRotationLag' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, CameraLagSpeed) == 0x000280, "Member 'ALLockOnSystemData::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, CameraRotationLagSpeed) == 0x000284, "Member 'ALLockOnSystemData::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, CameraLagMaxDistance) == 0x000288, "Member 'ALLockOnSystemData::CameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, MinLimitPitchAngle) == 0x00028C, "Member 'ALLockOnSystemData::MinLimitPitchAngle' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, MaxLimitPitchAngle) == 0x000290, "Member 'ALLockOnSystemData::MaxLimitPitchAngle' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, ImportanceFactor) == 0x000294, "Member 'ALLockOnSystemData::ImportanceFactor' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, ScreenHorizontalRate) == 0x0002B0, "Member 'ALLockOnSystemData::ScreenHorizontalRate' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, ScreenVerticalRate) == 0x0002B4, "Member 'ALLockOnSystemData::ScreenVerticalRate' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, bChangeNearbyDistanceCheckFromTarget) == 0x0002B8, "Member 'ALLockOnSystemData::bChangeNearbyDistanceCheckFromTarget' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, ChangeNearbyDistance) == 0x0002BC, "Member 'ALLockOnSystemData::ChangeNearbyDistance' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, FowardCollectDistance) == 0x0002C0, "Member 'ALLockOnSystemData::FowardCollectDistance' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, InheritCollectDistance) == 0x0002C4, "Member 'ALLockOnSystemData::InheritCollectDistance' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, CollectFOVScaling) == 0x0002C8, "Member 'ALLockOnSystemData::CollectFOVScaling' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, UpperBodyLookAtBoneName) == 0x0002D0, "Member 'ALLockOnSystemData::UpperBodyLookAtBoneName' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, LockOnPostponeTime) == 0x0002D8, "Member 'ALLockOnSystemData::LockOnPostponeTime' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, ChangeNearbyDelayTime) == 0x0002DC, "Member 'ALLockOnSystemData::ChangeNearbyDelayTime' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, GamePadPressValue) == 0x0002E0, "Member 'ALLockOnSystemData::GamePadPressValue' has a wrong offset!");
static_assert(offsetof(ALLockOnSystemData, MousePressValue) == 0x0002E4, "Member 'ALLockOnSystemData::MousePressValue' has a wrong offset!");

// Class ProjectP.LLockOnSystem
// 0x07C8 (0x0840 - 0x0078)
class alignas(0x10) ULLockOnSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnStartLockOnMode;                                 // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFinishLockOnMode;                                // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class ALLockOnSystemData*                     LockOnData;                                        // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x7A0];                                     // 0x00A0(0x07A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsFocusTarget(class AActor* CheckActor);

	class AActor* GetLockOnTargetActor() const;
	struct FVector GetLockOnTargetPointLocation() const;
	struct FVector GetLockOnTargetPointLookAtUpperLocation() const;
	bool IsLockOnMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLockOnSystem">();
	}
	static class ULLockOnSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLockOnSystem>();
	}
};
static_assert(alignof(ULLockOnSystem) == 0x000010, "Wrong alignment on ULLockOnSystem");
static_assert(sizeof(ULLockOnSystem) == 0x000840, "Wrong size on ULLockOnSystem");
static_assert(offsetof(ULLockOnSystem, OnStartLockOnMode) == 0x000078, "Member 'ULLockOnSystem::OnStartLockOnMode' has a wrong offset!");
static_assert(offsetof(ULLockOnSystem, OnFinishLockOnMode) == 0x000088, "Member 'ULLockOnSystem::OnFinishLockOnMode' has a wrong offset!");
static_assert(offsetof(ULLockOnSystem, LockOnData) == 0x000098, "Member 'ULLockOnSystem::LockOnData' has a wrong offset!");

// Class ProjectP.LMiscUtilFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class ULMiscUtilFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UMaterialInstanceDynamic* AddPostProcessMaterial(class UPostProcessComponent* PostProcessComponent, class UMaterialInterface* Material, float InWeight);
	static class UAudioComponent* AttachFollowingEnvSound(class FName InCodeName, ELPhysicalSurfaceType InPhysicalSurface, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed);
	static void ChangeMaterialColor(const TArray<class UMeshComponent*>& MeshComponents, class FName ParameterName, const struct FLinearColor& Value);
	static void ChangeMaterialScalar(const TArray<class UMeshComponent*>& MeshComponents, class FName ParameterName, float Value);
	static void ClearAndInvalidateTimerHandle(class UObject* WorldContextObject, struct FTimerHandle& Handle);
	static ELPhysicalSurfaceType ConvertPhysicalSurfaceNameToEnum(class FName InPhysicalSurfaceName);
	static ELPhysicalSurfaceType ConvertPhysicalSurfaceToEnum(EPhysicalSurface InPhysicalSurface);
	static bool ExecuteContentCommand(class FName CommandCodeName);
	static bool ExecuteWorldEvent(ELCallBackEventType CallBackEventType, const class FString& Param1, const class FString& Param2);
	static bool FindClosestBoneOnPhysicsAsset(class USkeletalMeshComponent* MeshComponent, const struct FVector& WorldPosition, const struct FVector& WorldImpulse, bool bApproximate, const TArray<class FName>& SearchBoneNames, class FName* ClosestBoneName);
	static class UPrimitiveComponent* FindComponentForEffect(class USkeletalMeshComponent* SkeletalMeshComponent, class AActor* Actor, const class FName& FXSocket, ELMeshSelectionType MeshSelectionType);
	static bool FindLowerBoneList(class USkeletalMeshComponent* MeshComponent, class FName BoneName, TArray<class FName>* BoneList);
	static bool FindNearbyBoneList(class USkeletalMeshComponent* MeshComponent, class FName BoneName, TArray<class FName>* BoneList);
	static float FindNearestFloatInArray(const TArray<float>& FloatArray, float InputFloat);
	static bool FindSplashBloodFx(ELBloodEffectType InBloodType, class UNiagaraSystem** OutParticle, class UParticleSystem** OutTrail);
	static bool FindWeatherFx(class FName InCodeName, class UNiagaraSystem** OutNiagara, struct FVector* OutOffset, TMap<class FName, float>* OutDefaultScalarVariables, TMap<class FName, struct FColor>* OutDefautlColorVariables);
	static bool FindWeatherSound(class FName InCodeName, class USoundBase** OutSound, TMap<class FName, float>* OutDefaultScalarVariables, TMap<class FName, struct FColor>* OutDefautlColorVariables);
	static bool FlushAudioCache();
	static bool GameObject_Activate(class AActor* TargetActor, bool ForceReset);
	static bool GameObject_Deactivate(class AActor* TargetActor);
	static ELGameObjectState GameObject_GetState(class AActor* TargetActor);
	static void GetBuildConfiguration(class FString* Configuration);
	static class ULCommonConstantValues* GetConstantValues();
	static struct FVector GetCurrentLever(class APawn* TargetActor);
	static class ULEquipmentComponent* GetEquipmentComponentBP(class AActor* TargetActor);
	static class ULFXComponent* GetFXComponent(class AActor* TargetActor);
	static struct FVector GetHitSweepLocation(const struct FHitResult& HitResult);
	static class ULBodyStainComponent* GetLBodyStainComponentBP(class AActor* TargetActor, EExecutePin* Branches);
	static void GetMeshComponentsBySelectionType(class AActor* Actor, TArray<class UMeshComponent*>* OutComponents, ELMeshSelectionType SelectType);
	static class ALNPCSpot* GetNPCSpot(const class FString& InUniqueSpotId);
	static class FName GetObjectFName(class UObject* Object);
	static class FString GetObjectName(class UObject* Object);
	static ELWeaponCorrectionPhysicalGrade GetProjectileCorrectionGrade(ELFirstStat Stat, const class ULItem* ConsumeItem);
	static bool GetRigidBodyBoneList(class USkeletalMeshComponent* MeshComponent, TArray<class FName>* BoneList);
	static bool GetRigidBodyBox(class USkeletalMeshComponent* MeshComponent, class FName BoneName, struct FVector* Location, struct FRotator* Rotation, struct FVector* BoundExtent);
	static bool GetRigidBodyBoxNearby(class USkeletalMeshComponent* MeshComponent, class FName BoneName, struct FVector* Location, struct FRotator* Rotation, struct FVector* BoundExtent);
	static int32 GetShaderPrecompileRemainingCount();
	static ELWeaponCorrectionPhysicalGrade GetSlaveArmCorrectionGrade(ELFirstStat Stat, const class ULItem* SlaveArmItem);
	static void GetSpecialBuffLocalText(class FName CodeName, class FText* OutName, class FText* OutTooltip);
	static class ALStatRoomPCCharacter* GetStatRoomPC(class UObject* WorldContextObject);
	static void GetWeaponMeshComponentsBySelectionType(class ALWeapon* WeaponActor, TArray<class UMeshComponent*>* OutComponents, ELMeshSelectionType SelectType);
	static void HideManagedNiagaraComponentsBP(class AActor* TargetActor, bool Hide, EExecutePin* Branches);
	static bool IsLiquidSurface(ELPhysicalSurfaceType PhysicalSurfaceType);
	static bool IsNearPC(class UObject* WorldContextObject, const struct FVector& Location);
	static bool IsPCInBox(const class UObject* WorldContextObject, class UBoxComponent* Box);
	static bool IsRightAcceptButton();
	static bool IsValidEventCondition(class FName ConditionName);
	static class UActorComponent* LoadAndAddComponent(class AActor* TargetActor, TSoftClassPtr<class UClass> TargetComponentClass);
	static class USceneComponent* LoadAndAttachToComponent(class USceneComponent* AttachTargetComponent, TSoftClassPtr<class UClass> TargetComponentClass, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	static void LogBP(class UObject* WorldContextObject, const class FString& Msg, class UObject* LogInstigator, bool ShowScreen, float ShowScreenDuration);
	static void LogForWarningBP(class UObject* WorldContextObject, const class FString& Msg, class UObject* LogInstigator, bool ShowScreen, float ShowScreenDuration);
	static void MessagePump();
	static bool PlayCameraShake(class UObject* WorldContextObject, class FName TableCodeName, const struct FVector& Epicenter);
	static class UAudioComponent* PlayCharacterSoundAtLocation(const class UObject* WorldContextObject, class FName EventName, class FName CharacterSoundTypeCodeName, const struct FTransform& SpawnTransform, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static class UAudioComponent* PlayCharacterSoundAttached(class FName EventName, class FName CharacterSoundTypeCodeName, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static bool PlayExplosiveKillFx(class AActor* TargetActor, class FName EventName, class FName Attribute, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, const TArray<class FName>& TargetFxSocketArray);
	static struct FLAttachedEffectSet PlayFxCommon_Attach(class AActor* TargetActor, class FName EventName, class FName SocketName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy, bool bPlayFx, bool bPlaySound);
	static void PlayFxCommon_Location(class AActor* TargetActor, class FName EventName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, float VolumeMultiplier, bool bPlayFx, bool bPlaySound);
	static bool PlayHitFx(class UObject* WorldContextObject, class AActor* Victim, ELHitFXType InHitFxType, ELHitFX_SecondaryType InSecondType, ELPhysicalSurfaceType InAttackerMaterial, class FName Attribute, ELSwingPowerType InPower, ELFxVictimType VictimType, const struct FTransform& SpawnTransform);
	static bool PlayHitFxAttached(class AActor* ActorToAttach, ELHitFXType InHitFxType, ELHitFX_SecondaryType InSecondType, ELPhysicalSurfaceType InAttackerMaterial, class FName Attribute, ELSwingPowerType InPower, ELFxVictimType VictimType);
	static bool PlayHitSFX(class UObject* WorldContextObject, ELHitSoundType InHitSoundType, ELHitSound_SecondaryType InSecondType, class FName Attribute, ELPhysicalSurfaceType InAttackerMaterial, ELPhysicalSurfaceType InPhysicalSurface, ELSwingPowerType InPower, ELFxVictimType VictimType, const struct FTransform& SpawnTransform, float VolumeMultiplier, float PitchMultiplier, class AActor* OwningActor, bool bPlay2DSound);
	static class UNiagaraComponent* PlayPhysicalSurfaceFxAtLocation(const class UObject* WorldContextObject, class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, const struct FTransform& SpawnTransform, bool bAutoDestroy, class AActor* Instigator);
	static class UNiagaraComponent* PlayPhysicalSurfaceFxAttached(class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy);
	static class UAudioComponent* PlayPhysicalSurfaceSoundAtLocation(const class UObject* WorldContextObject, class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, const struct FTransform& SpawnTransform, float CurveValue, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static class UAudioComponent* PlayPhysicalSurfaceSoundAttached(class FName EventName, ELPhysicalSurfaceType PhysicalSurface, ELPhysicalSurfaceFXConditionType InCondition, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float CurveValue, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	static void PlayRepulseFx(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform);
	static void PlayRepulseSound(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform, float VolumeModifier, float PitchModifier);
	static bool PlaySmashFX(class UObject* WorldContextObject, ELPhysicalSurfaceType InAttackMaterial, ELPhysicalSurfaceType InGroundMaterial, ELSwingPowerType InPower, const struct FTransform& SpawnTransform);
	static void PlaySparkFx(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform);
	static void PlaySparkSound(const class UObject* WorldContextObject, ELPhysicalSurfaceType AttackerMaterial, ELPhysicalSurfaceType GroundMaterial, const struct FTransform& SpawnTransform, float VolumeModifier, float PitchModifier);
	static void PlaySwingSFX(class UAudioComponent** OutSwingSfxComponent, class UAudioComponent** OutEnchantSfxComponent, class USceneComponent* TargetComponent, class FName InCodeName, ELSkillMotionType InMotionType, ELSwingPowerType InPower, ELAbnormalEnchantType InEnchantType, class FName TargetSocketName, const struct FVector& OffsetLocation, float VolumeMultiplier, float PitchMultiplier, bool IsPcSound);
	static void PrintActionGroupPathAssets(class FName ActionGroupCodeName);
	static void PrintNPCLoadAssets(class FName NPCCodeName);
	static struct FVector2D ProjectWorldToScreenNormalized(const struct FVector& WorldPosition);
	static class ALWeapon* Proto_EquipSubWeapon(class FName HandleCodeName, class FName BladeCodeName);
	static class ALWeapon* Proto_GetSubWeapon(class AActor* TargetActor);
	static int32 Proto_GetSubWeaponIndex();
	static void Proto_ResetSubWeapon();
	static void RemovePostProcessMaterial(class UPostProcessComponent* PostProcessComponent, class UMaterialInstanceDynamic* MaterialInstnaceDynamic);
	static void SetAudioListenerPosition_AudioListenerPositionComponent(const struct FVector& Offset, float LerpDuration);
	static void SetAudioListenerPosition_Camera(const struct FVector& Offset, float LerpDuration);
	static void SetAudioListenerPosition_Character(float LerpDuration);
	static void SetAudioListenerPosition_CustomLocation(const struct FVector& Location, float LerpDuration);
	static void SetAudioListenerPosition_StatRoom();
	static bool SetupMainCamera(class ACharacter* TargetActor);
	static class UForceFeedbackComponent* SpawnForceFeedbackAtLocation(const class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class UForceFeedbackComponent* SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
	static class ULDecalComponent* SpawnMaterialVaryingDecalAtLocation(const class UObject* WorldContextObject, class ULMaterialVarying* InMaterialVarying, ELMaterialVaryingPlayType InPlayType, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation);
	static class UNiagaraComponent* SpawnSystemAttachedWithParameters(class AActor* ActorToAttach, const struct FLNiagaraWithParameters& NiagaraWithParameters);
	static class ULWindSourceComponent* SpawnWindSourceAtLocation(const class UObject* WorldContextObject, float WindSpeed, bool bPointWind, const struct FVector& VolumeSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan);
	static bool TraceForLandingOnFloor(class UObject* WorldContext, const struct FVector& TraceLocation, float TraceHalfHeight, struct FVector* ResultLocation);
	static bool WasRenderedActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMiscUtilFuncLibrary">();
	}
	static class ULMiscUtilFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULMiscUtilFuncLibrary>();
	}
};
static_assert(alignof(ULMiscUtilFuncLibrary) == 0x000008, "Wrong alignment on ULMiscUtilFuncLibrary");
static_assert(sizeof(ULMiscUtilFuncLibrary) == 0x000028, "Wrong size on ULMiscUtilFuncLibrary");

// Class ProjectP.LMovieSystem
// 0x0028 (0x00A0 - 0x0078)
class ULMovieSystem final : public ULGameSubSystem
{
public:
	class ALMovieSystemData*                      SystemData;                                        // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnFinishedMovie;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class FName                                   WaitForExecuteMovie;                               // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ReserveMovieCodeName;                              // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DeactivatePauseOnReachedEnd();
	void ExecutePlayBinkMovie();
	void OnMediaClosed(class FName MovieCodeName);
	void OnMediaOpened(class FName MovieCodeName);
	void OnMediaPauseOnReachedEnd(class FName MovieCodeName);
	void OnMediaReachedEnd(class FName MovieCodeName);
	bool PlayBinkMovie(class FName MovieCodeName);
	void SkipBinkMovie();
	void StopBinkMovie(class FName MovieCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMovieSystem">();
	}
	static class ULMovieSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULMovieSystem>();
	}
};
static_assert(alignof(ULMovieSystem) == 0x000008, "Wrong alignment on ULMovieSystem");
static_assert(sizeof(ULMovieSystem) == 0x0000A0, "Wrong size on ULMovieSystem");
static_assert(offsetof(ULMovieSystem, SystemData) == 0x000078, "Member 'ULMovieSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULMovieSystem, OnFinishedMovie) == 0x000080, "Member 'ULMovieSystem::OnFinishedMovie' has a wrong offset!");
static_assert(offsetof(ULMovieSystem, WaitForExecuteMovie) == 0x000090, "Member 'ULMovieSystem::WaitForExecuteMovie' has a wrong offset!");
static_assert(offsetof(ULMovieSystem, ReserveMovieCodeName) == 0x000098, "Member 'ULMovieSystem::ReserveMovieCodeName' has a wrong offset!");

// Class ProjectP.LNavLinkProxy
// 0x0000 (0x0230 - 0x0230)
class ALNavLinkProxy : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNavLinkProxy">();
	}
	static class ALNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALNavLinkProxy>();
	}
};
static_assert(alignof(ALNavLinkProxy) == 0x000008, "Wrong alignment on ALNavLinkProxy");
static_assert(sizeof(ALNavLinkProxy) == 0x000230, "Wrong size on ALNavLinkProxy");

// Class ProjectP.LNPCAnimInstance
// 0x0000 (0x06F0 - 0x06F0)
class ULNPCAnimInstance final : public ULAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCAnimInstance">();
	}
	static class ULNPCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCAnimInstance>();
	}
};
static_assert(alignof(ULNPCAnimInstance) == 0x000010, "Wrong alignment on ULNPCAnimInstance");
static_assert(sizeof(ULNPCAnimInstance) == 0x0006F0, "Wrong size on ULNPCAnimInstance");

// Class ProjectP.LNPCController
// 0x0000 (0x0DB8 - 0x0DB8)
class ALNPCController : public ALAIController
{
public:
	static class ALNPCController* Get(class AActor* Actor);

	void DeadCharacterBP();
	void EndCombatState();
	int32 GetCheckSkillUseCount();
	bool IsCombatState();
	void OnRespawnBP();
	void ResetBBKeys();
	void RunInitBehaviorTree(class UBehaviorTree* CustomBehaviroTree);
	void SelectCommonActionBP(const class FName& CommonActionMontageName, class FName* OutActionClassName, class ULActPayloadBase** OutPayload);
	void SetActivate(bool bInActivate);
	void StartCombatState();

	bool IsActivate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCController">();
	}
	static class ALNPCController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALNPCController>();
	}
};
static_assert(alignof(ALNPCController) == 0x000008, "Wrong alignment on ALNPCController");
static_assert(sizeof(ALNPCController) == 0x000DB8, "Wrong size on ALNPCController");

// Class ProjectP.LNPCSpecActionSkill
// 0x0008 (0x0030 - 0x0028)
class ULNPCSpecActionSkill final : public ULNPCSpecActionBase
{
public:
	class FName                                   SkillCodeName;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpecActionSkill">();
	}
	static class ULNPCSpecActionSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpecActionSkill>();
	}
};
static_assert(alignof(ULNPCSpecActionSkill) == 0x000008, "Wrong alignment on ULNPCSpecActionSkill");
static_assert(sizeof(ULNPCSpecActionSkill) == 0x000030, "Wrong size on ULNPCSpecActionSkill");
static_assert(offsetof(ULNPCSpecActionSkill, SkillCodeName) == 0x000028, "Member 'ULNPCSpecActionSkill::SkillCodeName' has a wrong offset!");

// Class ProjectP.LNPCSpotComponentForGuide
// 0x0000 (0x0460 - 0x0460)
class ULNPCSpotComponentForGuide final : public USphereComponentForGuide
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LNPCSpotComponentForGuide">();
	}
	static class ULNPCSpotComponentForGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULNPCSpotComponentForGuide>();
	}
};
static_assert(alignof(ULNPCSpotComponentForGuide) == 0x000010, "Wrong alignment on ULNPCSpotComponentForGuide");
static_assert(sizeof(ULNPCSpotComponentForGuide) == 0x000460, "Wrong size on ULNPCSpotComponentForGuide");

// Class ProjectP.LObjectManagementSystemData
// 0x0010 (0x01F0 - 0x01E0)
class ALObjectManagementSystemData : public AActor
{
public:
	TArray<class FName>                           AlwayLoadPCActionGroups;                           // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LObjectManagementSystemData">();
	}
	static class ALObjectManagementSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALObjectManagementSystemData>();
	}
};
static_assert(alignof(ALObjectManagementSystemData) == 0x000008, "Wrong alignment on ALObjectManagementSystemData");
static_assert(sizeof(ALObjectManagementSystemData) == 0x0001F0, "Wrong size on ALObjectManagementSystemData");
static_assert(offsetof(ALObjectManagementSystemData, AlwayLoadPCActionGroups) == 0x0001E0, "Member 'ALObjectManagementSystemData::AlwayLoadPCActionGroups' has a wrong offset!");

// Class ProjectP.LObjectManagementSystem
// 0x0740 (0x07B8 - 0x0078)
class ULObjectManagementSystem final : public ULGameSubSystem
{
public:
	float                                         GameObject_PlayerMovementForUpdateTriggering;      // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameObject_InactiveDistanceFromPlayer;             // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePreload;                                        // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AnimAssets;                                        // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x100];                                     // 0x0098(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLPreloadBox                           PCPreloadInstance_Always;                          // 0x0198(0x0030)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FLPreloadBox>              PCPreloadInstance_Weapon;                          // 0x01C8(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FLPreloadBox>              PCPreloadInstance_SlaveArm;                        // 0x0218(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FLPreloadBox>              PCPreloadInstance_Item;                            // 0x0268(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x28];                                     // 0x02B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UObject>>         LevelGameObjects;                                  // 0x02E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          ObjectList;                                        // 0x02F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FString, TWeakObjectPtr<class AActor>> ObjectMap;                                         // 0x0300(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ALPCCharacter>           PlayerCharacter;                                   // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ALStatRoomPCCharacter>   StatRoomCharacter;                                 // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALCharacter>>     CharacterList;                                     // 0x0360(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALDestructionObject>> DestructObjectList;                                // 0x0370(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALNPCCharacter>>  InstantSpawnNPCList;                               // 0x0380(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALDestructionObject>> InstantSpawnDestructionObjectList;                 // 0x0390(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALSpot>>          SpotList;                                          // 0x03A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALNPCSpot>>       NpcSpotList;                                       // 0x03B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALExiledNPCSpot>> ExiledNPCSpotSpotList;                             // 0x03C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropSpot>>      PropSpotList;                                      // 0x03D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropItemSpot>>  PropItemSpotList;                                  // 0x03E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropHelpMateSpot>> PropHelpMateSpotList;                              // 0x03F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALTeleportObjectSpot>> TeleportObjectSpotList;                            // 0x0400(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropShapeObjectSpot>> PropShapeObjectSpotList;                           // 0x0410(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropLadderSpot>> PropLadderSpotList;                                // 0x0420(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropLiftSpot>>  PropLiftSpotList;                                  // 0x0430(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropDestructionSpot>> PropDestructionSpotList;                           // 0x0440(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropVolumeSpot>> PropVolumeSpotList;                                // 0x0450(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropLevelSequenceSpot>> PropLevelSequenceSpotList;                         // 0x0460(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALBossRoomSpot>>  BossRoomSpotList;                                  // 0x0470(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPropDoorSpot>>  PropDoorSpotList;                                  // 0x0480(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALProjectilePropSpot>> ProjectileSpotList;                                // 0x0490(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ALDummySpot*                            DummySpot;                                         // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALDummyNPCSpot*                         DummyNPCSpot;                                      // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALDummyPropSpot*                        DummyPropSpot;                                     // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ALSoulDropObject>        SoulDropObject;                                    // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALExiledNpcArea>> ExiledNpcAreaList;                                 // 0x04C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALPathWayObject>> PathWayObjectList;                                 // 0x04D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  FluidControllerPtr;                                // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALNPCCharacter>>  FocusToPCList;                                     // 0x04E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALNPCCharacter>>  CombatNPCList;                                     // 0x04F8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALNPCCharacter>>  HideBossHPIfReturnDistanceFarList;                 // 0x0508(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          RemoveFlagList;                                    // 0x0518(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ALObjectManagementSystemData*           SystemData;                                        // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x50];                                     // 0x0530(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNpcDeadbodySettings                  NpcDeadbodySettings;                               // 0x0580(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSpotManagementSettings               NpcSpotSettings;                                   // 0x058C(0x001C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSpotManagementSettings               DestructionSpotSettings;                           // 0x05A8(0x001C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSpotManagementSettings               ImportantPropSpotSettings;                         // 0x05C4(0x001C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSpotManagementSettings               DynamicPropSpotSettings;                           // 0x05E0(0x001C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSpotManagementSettings               NormalPropSpotSettings;                            // 0x05FC(0x001C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FLSpotManagementSettings               Hotel_NormalPropSpotSettings;                      // 0x0618(0x001C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ALPropSpot>>         ImportantPropSpotClasses;                          // 0x0638(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ALPropSpot>>         DynamicPropSpotClasses;                            // 0x0648(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ALNPCCharacter>>  NpcDeadbodyList;                                   // 0x0658(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FLSpotListManagement                   NpcSpotManager;                                    // 0x0668(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSpotListManagement                   DestructionSpotManager;                            // 0x0690(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSpotListManagement                   ImportantPropSpotManager;                          // 0x06B8(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSpotListManagement                   DynamicPropSpotManager;                            // 0x06E0(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLSpotListManagement                   NormalPropSpotManager;                             // 0x0708(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ALSpot>>          TempAsyncLoadList;                                 // 0x0730(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ALSpot>>          TempSpawnList;                                     // 0x0740(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALSpot>                  TempSpotToSpawn;                                   // 0x0750(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGoldenTree*                           GoldenTree;                                        // 0x0758(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         UniqueId_Tail;                                     // 0x0760(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<int64>                                   UniqueIdSet;                                       // 0x0768(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddRemoveFlag(class AActor* InActor);
	void FindFiles(TArray<struct FSoftObjectPath>* OutObjectPaths, const class FString& Directory);
	class AActor* GetFluidController(EExecutePin* Branches);
	class ULGoldenTree* GetGoldenTree();
	class ALPCCharacter* GetPlayerCharacter();
	void OnSetActiveEnvironment(bool bWorldActive);
	void SetFluidController(class AActor* TargetActor);
	class ALDestructionObject* SpawnDestructionObject(class FName DestructionObjectCodeName, const struct FTransform& SpawnTransform, bool bTraceAndLandingOnFloor);
	class ALNPCCharacter* SpawnNPC(class FName NPCCodeName, const struct FTransform& SpawnTransform, bool bTraceAndLandingOnFloor, class FName SpawnIdleActionGroupCodeName);

	TArray<class ALNPCCharacter*> FindNPCCharactersAround(class FName NPCCodeName, float AroundDistance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LObjectManagementSystem">();
	}
	static class ULObjectManagementSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULObjectManagementSystem>();
	}
};
static_assert(alignof(ULObjectManagementSystem) == 0x000008, "Wrong alignment on ULObjectManagementSystem");
static_assert(sizeof(ULObjectManagementSystem) == 0x0007B8, "Wrong size on ULObjectManagementSystem");
static_assert(offsetof(ULObjectManagementSystem, GameObject_PlayerMovementForUpdateTriggering) == 0x000078, "Member 'ULObjectManagementSystem::GameObject_PlayerMovementForUpdateTriggering' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, GameObject_InactiveDistanceFromPlayer) == 0x00007C, "Member 'ULObjectManagementSystem::GameObject_InactiveDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, UsePreload) == 0x000080, "Member 'ULObjectManagementSystem::UsePreload' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, AnimAssets) == 0x000088, "Member 'ULObjectManagementSystem::AnimAssets' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PCPreloadInstance_Always) == 0x000198, "Member 'ULObjectManagementSystem::PCPreloadInstance_Always' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PCPreloadInstance_Weapon) == 0x0001C8, "Member 'ULObjectManagementSystem::PCPreloadInstance_Weapon' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PCPreloadInstance_SlaveArm) == 0x000218, "Member 'ULObjectManagementSystem::PCPreloadInstance_SlaveArm' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PCPreloadInstance_Item) == 0x000268, "Member 'ULObjectManagementSystem::PCPreloadInstance_Item' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, LevelGameObjects) == 0x0002E0, "Member 'ULObjectManagementSystem::LevelGameObjects' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ObjectList) == 0x0002F0, "Member 'ULObjectManagementSystem::ObjectList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ObjectMap) == 0x000300, "Member 'ULObjectManagementSystem::ObjectMap' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PlayerCharacter) == 0x000350, "Member 'ULObjectManagementSystem::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, StatRoomCharacter) == 0x000358, "Member 'ULObjectManagementSystem::StatRoomCharacter' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, CharacterList) == 0x000360, "Member 'ULObjectManagementSystem::CharacterList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DestructObjectList) == 0x000370, "Member 'ULObjectManagementSystem::DestructObjectList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, InstantSpawnNPCList) == 0x000380, "Member 'ULObjectManagementSystem::InstantSpawnNPCList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, InstantSpawnDestructionObjectList) == 0x000390, "Member 'ULObjectManagementSystem::InstantSpawnDestructionObjectList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, SpotList) == 0x0003A0, "Member 'ULObjectManagementSystem::SpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NpcSpotList) == 0x0003B0, "Member 'ULObjectManagementSystem::NpcSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ExiledNPCSpotSpotList) == 0x0003C0, "Member 'ULObjectManagementSystem::ExiledNPCSpotSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropSpotList) == 0x0003D0, "Member 'ULObjectManagementSystem::PropSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropItemSpotList) == 0x0003E0, "Member 'ULObjectManagementSystem::PropItemSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropHelpMateSpotList) == 0x0003F0, "Member 'ULObjectManagementSystem::PropHelpMateSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, TeleportObjectSpotList) == 0x000400, "Member 'ULObjectManagementSystem::TeleportObjectSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropShapeObjectSpotList) == 0x000410, "Member 'ULObjectManagementSystem::PropShapeObjectSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropLadderSpotList) == 0x000420, "Member 'ULObjectManagementSystem::PropLadderSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropLiftSpotList) == 0x000430, "Member 'ULObjectManagementSystem::PropLiftSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropDestructionSpotList) == 0x000440, "Member 'ULObjectManagementSystem::PropDestructionSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropVolumeSpotList) == 0x000450, "Member 'ULObjectManagementSystem::PropVolumeSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropLevelSequenceSpotList) == 0x000460, "Member 'ULObjectManagementSystem::PropLevelSequenceSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, BossRoomSpotList) == 0x000470, "Member 'ULObjectManagementSystem::BossRoomSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PropDoorSpotList) == 0x000480, "Member 'ULObjectManagementSystem::PropDoorSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ProjectileSpotList) == 0x000490, "Member 'ULObjectManagementSystem::ProjectileSpotList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DummySpot) == 0x0004A0, "Member 'ULObjectManagementSystem::DummySpot' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DummyNPCSpot) == 0x0004A8, "Member 'ULObjectManagementSystem::DummyNPCSpot' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DummyPropSpot) == 0x0004B0, "Member 'ULObjectManagementSystem::DummyPropSpot' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, SoulDropObject) == 0x0004B8, "Member 'ULObjectManagementSystem::SoulDropObject' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ExiledNpcAreaList) == 0x0004C0, "Member 'ULObjectManagementSystem::ExiledNpcAreaList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, PathWayObjectList) == 0x0004D0, "Member 'ULObjectManagementSystem::PathWayObjectList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, FluidControllerPtr) == 0x0004E0, "Member 'ULObjectManagementSystem::FluidControllerPtr' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, FocusToPCList) == 0x0004E8, "Member 'ULObjectManagementSystem::FocusToPCList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, CombatNPCList) == 0x0004F8, "Member 'ULObjectManagementSystem::CombatNPCList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, HideBossHPIfReturnDistanceFarList) == 0x000508, "Member 'ULObjectManagementSystem::HideBossHPIfReturnDistanceFarList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, RemoveFlagList) == 0x000518, "Member 'ULObjectManagementSystem::RemoveFlagList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, SystemData) == 0x000528, "Member 'ULObjectManagementSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NpcDeadbodySettings) == 0x000580, "Member 'ULObjectManagementSystem::NpcDeadbodySettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NpcSpotSettings) == 0x00058C, "Member 'ULObjectManagementSystem::NpcSpotSettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DestructionSpotSettings) == 0x0005A8, "Member 'ULObjectManagementSystem::DestructionSpotSettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ImportantPropSpotSettings) == 0x0005C4, "Member 'ULObjectManagementSystem::ImportantPropSpotSettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DynamicPropSpotSettings) == 0x0005E0, "Member 'ULObjectManagementSystem::DynamicPropSpotSettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NormalPropSpotSettings) == 0x0005FC, "Member 'ULObjectManagementSystem::NormalPropSpotSettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, Hotel_NormalPropSpotSettings) == 0x000618, "Member 'ULObjectManagementSystem::Hotel_NormalPropSpotSettings' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ImportantPropSpotClasses) == 0x000638, "Member 'ULObjectManagementSystem::ImportantPropSpotClasses' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DynamicPropSpotClasses) == 0x000648, "Member 'ULObjectManagementSystem::DynamicPropSpotClasses' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NpcDeadbodyList) == 0x000658, "Member 'ULObjectManagementSystem::NpcDeadbodyList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NpcSpotManager) == 0x000668, "Member 'ULObjectManagementSystem::NpcSpotManager' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DestructionSpotManager) == 0x000690, "Member 'ULObjectManagementSystem::DestructionSpotManager' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, ImportantPropSpotManager) == 0x0006B8, "Member 'ULObjectManagementSystem::ImportantPropSpotManager' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, DynamicPropSpotManager) == 0x0006E0, "Member 'ULObjectManagementSystem::DynamicPropSpotManager' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, NormalPropSpotManager) == 0x000708, "Member 'ULObjectManagementSystem::NormalPropSpotManager' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, TempAsyncLoadList) == 0x000730, "Member 'ULObjectManagementSystem::TempAsyncLoadList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, TempSpawnList) == 0x000740, "Member 'ULObjectManagementSystem::TempSpawnList' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, TempSpotToSpawn) == 0x000750, "Member 'ULObjectManagementSystem::TempSpotToSpawn' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, GoldenTree) == 0x000758, "Member 'ULObjectManagementSystem::GoldenTree' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, UniqueId_Tail) == 0x000760, "Member 'ULObjectManagementSystem::UniqueId_Tail' has a wrong offset!");
static_assert(offsetof(ULObjectManagementSystem, UniqueIdSet) == 0x000768, "Member 'ULObjectManagementSystem::UniqueIdSet' has a wrong offset!");

// Class ProjectP.LPoolingObjectManager
// 0x0050 (0x0078 - 0x0028)
class ULPoolingObjectManager final : public UObject
{
public:
	TMap<class UClass*, struct FLPoolingObjectHolder> PoolingObjectMap;                                  // 0x0028(0x0050)(NativeAccessSpecifierPrivate)

public:
	void Clear();
	void CreateObjects(class UObject* WorldContext, TSoftClassPtr<class UClass> ObjectClassPtr, int32 Count, bool bCreateOnlySurplusAmount);
	void CreateWidgets(class UObject* WorldContext, TSoftClassPtr<class UClass> WidgetClassPtr, int32 Count, bool bCreateOnlySurplusAmount);
	class UObject* GetRecyclableObject(class UObject* WorldContext, TSoftClassPtr<class UClass> ObjectClassPtr);
	bool ReturnToRecyclingBin(class UObject* WorldContext, class UObject* TargetObject);
	void ShrinkRecyclingBin(class UObject* WorldContext, TSoftClassPtr<class UClass> ObjectClassPtr, int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPoolingObjectManager">();
	}
	static class ULPoolingObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPoolingObjectManager>();
	}
};
static_assert(alignof(ULPoolingObjectManager) == 0x000008, "Wrong alignment on ULPoolingObjectManager");
static_assert(sizeof(ULPoolingObjectManager) == 0x000078, "Wrong size on ULPoolingObjectManager");
static_assert(offsetof(ULPoolingObjectManager, PoolingObjectMap) == 0x000028, "Member 'ULPoolingObjectManager::PoolingObjectMap' has a wrong offset!");

// Class ProjectP.LObjectPoolSystem
// 0x0028 (0x00A0 - 0x0078)
class ULObjectPoolSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULPoolingObjectManager*                 PoolingObjectManager;                              // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALObjectPoolSystemData*                 SystemData;                                        // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 CreateNewRecyclables(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass, int32 Count);
	class AActor* GetRecyclables(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass);
	const class ALObjectPoolSystemData* GetSystemData();
	int32 ResizeRecyclingBin(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass, int32 DesiredSize);
	bool ReturnToRecyclingBin(class AActor* TargetActor);
	int32 ShrinkRecyclingBin(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass, int32 DesiredSize);

	int32 GetSizeOfRecyclingBin(class UObject* WorldContext, const TSoftClassPtr<class UClass> RecyclablesClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LObjectPoolSystem">();
	}
	static class ULObjectPoolSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULObjectPoolSystem>();
	}
};
static_assert(alignof(ULObjectPoolSystem) == 0x000008, "Wrong alignment on ULObjectPoolSystem");
static_assert(sizeof(ULObjectPoolSystem) == 0x0000A0, "Wrong size on ULObjectPoolSystem");
static_assert(offsetof(ULObjectPoolSystem, PoolingObjectManager) == 0x000090, "Member 'ULObjectPoolSystem::PoolingObjectManager' has a wrong offset!");
static_assert(offsetof(ULObjectPoolSystem, SystemData) == 0x000098, "Member 'ULObjectPoolSystem::SystemData' has a wrong offset!");

// Class ProjectP.LCameraOption
// 0x0018 (0x0060 - 0x0048)
class ULCameraOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCameraOptionMultiply(ECameraDirectOption InOptionType, bool InIsPad, float InValue);
	int32 GetMoveSpeedStep(ECameraDirectOption InRotator, ELInputOptionType InType);
	bool IsEnableAlignmentToCamera();
	bool IsEnableCameraShake();
	bool IsEnableMoveCameraUpDown();
	bool IsInvertMove(ECameraDirectOption InRotator, ELInputOptionType InType);
	void OnChangedInputMode(bool bGamePad);
	bool SetEnableAlignmentToCamera(bool Enable);
	bool SetEnableCameraShake(bool Enable);
	bool SetEnableMoveCameraUpDown(bool Enable);
	bool SetInvertMove(ECameraDirectOption InRotator, bool InInvert, ELInputOptionType InType);
	bool SetMoveSpeedStep(ECameraDirectOption InRotator, int32 InStep, ELInputOptionType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LCameraOption">();
	}
	static class ULCameraOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULCameraOption>();
	}
};
static_assert(alignof(ULCameraOption) == 0x000008, "Wrong alignment on ULCameraOption");
static_assert(sizeof(ULCameraOption) == 0x000060, "Wrong size on ULCameraOption");

// Class ProjectP.LGraphicOption
// 0x0030 (0x0078 - 0x0048)
class ULGraphicOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AutoScalabilityLevel();
	bool GetCACAOEnabled();
	int32 GetCurrentBrightness();
	EDLSSMode GetCurrentDLSSMode();
	float GetCurrentDLSSSharpness();
	EFSR1Mode GetCurrentFSR1Mode();
	EFSR2Mode GetCurrentFSR2Mode();
	float GetCurrentFSR2Sharpness();
	int32 GetCurrentHDRBrightness();
	int32 GetCurrentHDRContrast();
	EPlayStyleOption GetCurrentPlayStyleOption();
	EReflexMode GetCurrentReflexMode();
	struct FIntPoint GetCurrentScreenResolution();
	EXeSSMode GetCurrentXeSSMode();
	ELScalabilityDefaultLevel GetDetailScalability(EScalabilityType InType);
	bool GetDLSSGEnabled();
	float GetFrameRateLimit();
	EWindowMode GetFullscreenMode();
	class FString GetGraphicCardName();
	int32 GetScreenResolutionStep();
	TArray<struct FIntPoint> GetSelectableScreenResolutions();
	TArray<EDLSSMode> GetSupportedDLSSModes();
	bool Is120HzModeEnabled();
	bool Is120HzModeSupported();
	bool IsCACAOSupported();
	bool IsDLSSGAvailable();
	bool IsDLSSGSupported();
	bool IsDLSSModeSupported(EDLSSMode InMode);
	bool IsDLSSSharpnessAvailable();
	bool IsDLSSSupported();
	bool IsFSR1Supported();
	bool IsFSR2SharpnessAvailable();
	bool IsFSR2Supported();
	bool IsHDROutputEnabled();
	bool IsHDROutputSupported();
	bool IsPlayStyleOptionEnabled();
	bool IsRayTracingAmbientOcclusionEnabled();
	bool IsRayTracingGlobalIlluminationEnabled();
	bool IsRayTracingReflectionsEnabled();
	bool IsRayTracingShadowsEnabled();
	bool IsRayTracingSkyLightEnabled();
	bool IsRayTracingSupported();
	bool IsRayTracingTranslucencyEnabled();
	bool IsReflexModeAvailable();
	bool IsReflexSupported();
	bool IsVRSEnabled();
	bool IsVRSSupported();
	bool IsVSyncEnabled();
	bool IsXeSSSupported();
	bool Set120HzModeEnabled(bool bEnabled);
	bool SetCACAOEnabled(bool InEnable);
	bool SetCurrentBrightness(int32 InBrightness);
	bool SetCurrentHDRBrightness(int32 InBrightness);
	bool SetCurrentHDRContrast(int32 InContrast);
	bool SetDetailScalability(const EScalabilityType InType, ELScalabilityDefaultLevel InValue);
	bool SetDLSSGEnabled(bool InEnabled);
	bool SetDLSSMode(EDLSSMode InMode);
	bool SetDLSSSharpness(float InSharpness);
	bool SetFrameRateLimit(float InFrameratelimit);
	bool SetFSR1Mode(EFSR1Mode InMode);
	bool SetFSR2Mode(EFSR2Mode InMode);
	bool SetFSR2Sharpness(float InSharpness);
	bool SetFullscreenMode(EWindowMode InType);
	bool SetHDROutputEnabled(bool InEnable);
	bool SetPlayStyleOption(const EPlayStyleOption InPlayStyle);
	bool SetRayTracingAmbientOcclusionEnabled(bool bEnabled);
	bool SetRayTracingGlobalIlluminationEnabled(bool bEnabled);
	bool SetRayTracingReflectionsEnabled(bool bEnabled);
	bool SetRayTracingShadowsEnabled(bool bEnabled);
	bool SetRayTracingSkyLightEnabled(bool bEnabled);
	bool SetRayTracingTranslucencyEnabled(bool bEnabled);
	bool SetReflexMode(EReflexMode InMode);
	bool SetScalabilityLevel(ELScalabilityLevel InType);
	bool SetScreenResolutionStep(int32 InStep);
	bool SetVRSEnabled(bool InEnable);
	bool SetVSyncEnabled(bool InEnable);
	bool SetXeSSMode(EXeSSMode InMode);

	ELScalabilityLevel GetCurrentScalabilityLevel() const;
	struct FIntPoint GetDesktopResolution() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGraphicOption">();
	}
	static class ULGraphicOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGraphicOption>();
	}
};
static_assert(alignof(ULGraphicOption) == 0x000008, "Wrong alignment on ULGraphicOption");
static_assert(sizeof(ULGraphicOption) == 0x000078, "Wrong size on ULGraphicOption");

// Class ProjectP.LKeyboardMouseOption
// 0x0008 (0x0050 - 0x0048)
class ULKeyboardMouseOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMouseSensitivityStep();
	float GetMouseSensitivityValue();
	int32 GetMoveSpeedStep(ECameraDirectOption InRotator);
	bool IsInvertMove(ECameraDirectOption InRotator);
	void ResetEditedInputAction();
	bool SetInvertMove(ECameraDirectOption InRotator, bool InInvert);
	bool SetMouseSensitivityStep(int32 InStep);
	bool SetMoveSpeedStep(ECameraDirectOption InRotator, int32 InStep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LKeyboardMouseOption">();
	}
	static class ULKeyboardMouseOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULKeyboardMouseOption>();
	}
};
static_assert(alignof(ULKeyboardMouseOption) == 0x000008, "Wrong alignment on ULKeyboardMouseOption");
static_assert(sizeof(ULKeyboardMouseOption) == 0x000050, "Wrong size on ULKeyboardMouseOption");

// Class ProjectP.LFirstGameStartOption
// 0x0008 (0x0050 - 0x0048)
class ULFirstGameStartOption final : public ULSubOption
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetAutoSaveAlert();
	bool GetFirstBrightness();
	bool GetFirstLanguage();
	void OnClosedWindow(class FName WidgetTableName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LFirstGameStartOption">();
	}
	static class ULFirstGameStartOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULFirstGameStartOption>();
	}
};
static_assert(alignof(ULFirstGameStartOption) == 0x000008, "Wrong alignment on ULFirstGameStartOption");
static_assert(sizeof(ULFirstGameStartOption) == 0x000050, "Wrong size on ULFirstGameStartOption");

// Class ProjectP.LOptionSystem
// 0x00B0 (0x0128 - 0x0078)
class ULOptionSystem final : public ULGameSubSystem
{
public:
	class ULPlayOption*                           PlayOption;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULCameraOption*                         CameraOption;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULDispalySoundOption*                   DisplaySoundOption;                                // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGraphicOption*                        GraphicOption;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGamePadOption*                        GamePadOption;                                     // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULKeyboardMouseOption*                  KeyboardMouseOption;                               // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULKeySettingOption*                     KeySettingOption;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULFirstGameStartOption*                 FirstGameStartOption;                              // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALOptionSystemData*                     SystemData;                                        // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULOptionSaveGame*                       OptionSaveGame;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnOptionSyncSave;                                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x2];                                       // 0x00D8(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          CheckCustomizedInput;                              // 0x00DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DB[0x1];                                       // 0x00DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraOption_VerticalMoveSpeed_GamePad_Multiply;   // 0x00DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraOption_VerticalMoveSpeed_Keyboard_Multiply;  // 0x00E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraOption_HorizontalMoveSpeed_GamePad_Multiply; // 0x00E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CameraOption_HorizontalMoveSpeed_Keyboard_Multiply; // 0x00E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_MasterVolume_Multiply;                 // 0x00EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_BGMVolume_Multiply;                    // 0x00F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_AmbienceVolume_Multiply;               // 0x00F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_CinematicsVolume_Multiply;             // 0x00F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_EffectVolume_Multiply;                 // 0x00FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_VoiceVolume_Multiply;                  // 0x0100(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundOption_SystemVolume_Multiply;                 // 0x0104(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ControllerOption_ForceFeedback_Multiply;           // 0x0108(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ControllerOption_DeadZone_L_Multiply;              // 0x010C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ControllerOption_DeadZone_R_Multiply;              // 0x0110(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ControllerOption_ForceFeedback_Left_Large;         // 0x0114(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ControllerOption_ForceFeedback_Right_Large;        // 0x0118(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ControllerOption_ForceFeedback_Left_Small;         // 0x011C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ControllerOption_ForceFeedback_Right_Small;        // 0x0120(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetLocationCodeName();
	class FString GetNewGamePlusRound();
	int32 GetPlayerLevel();
	class FString GetPlayTime();
	bool Load();
	void OnInitLoadOptionGameData(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame);
	void OnLoadOptionGameData(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType, class ULSaveGame* SaveGame);
	void OnResetSystemData();
	void OnSaveOptionGameData(const class FString& SlotName, bool bSuccess, ELGameDataType GameDataType);
	bool Save();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LOptionSystem">();
	}
	static class ULOptionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULOptionSystem>();
	}
};
static_assert(alignof(ULOptionSystem) == 0x000008, "Wrong alignment on ULOptionSystem");
static_assert(sizeof(ULOptionSystem) == 0x000128, "Wrong size on ULOptionSystem");
static_assert(offsetof(ULOptionSystem, PlayOption) == 0x000078, "Member 'ULOptionSystem::PlayOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, CameraOption) == 0x000080, "Member 'ULOptionSystem::CameraOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, DisplaySoundOption) == 0x000088, "Member 'ULOptionSystem::DisplaySoundOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, GraphicOption) == 0x000090, "Member 'ULOptionSystem::GraphicOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, GamePadOption) == 0x000098, "Member 'ULOptionSystem::GamePadOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, KeyboardMouseOption) == 0x0000A0, "Member 'ULOptionSystem::KeyboardMouseOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, KeySettingOption) == 0x0000A8, "Member 'ULOptionSystem::KeySettingOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, FirstGameStartOption) == 0x0000B0, "Member 'ULOptionSystem::FirstGameStartOption' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SystemData) == 0x0000B8, "Member 'ULOptionSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, OptionSaveGame) == 0x0000C0, "Member 'ULOptionSystem::OptionSaveGame' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, OnOptionSyncSave) == 0x0000C8, "Member 'ULOptionSystem::OnOptionSyncSave' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, CheckCustomizedInput) == 0x0000DA, "Member 'ULOptionSystem::CheckCustomizedInput' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, CameraOption_VerticalMoveSpeed_GamePad_Multiply) == 0x0000DC, "Member 'ULOptionSystem::CameraOption_VerticalMoveSpeed_GamePad_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, CameraOption_VerticalMoveSpeed_Keyboard_Multiply) == 0x0000E0, "Member 'ULOptionSystem::CameraOption_VerticalMoveSpeed_Keyboard_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, CameraOption_HorizontalMoveSpeed_GamePad_Multiply) == 0x0000E4, "Member 'ULOptionSystem::CameraOption_HorizontalMoveSpeed_GamePad_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, CameraOption_HorizontalMoveSpeed_Keyboard_Multiply) == 0x0000E8, "Member 'ULOptionSystem::CameraOption_HorizontalMoveSpeed_Keyboard_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_MasterVolume_Multiply) == 0x0000EC, "Member 'ULOptionSystem::SoundOption_MasterVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_BGMVolume_Multiply) == 0x0000F0, "Member 'ULOptionSystem::SoundOption_BGMVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_AmbienceVolume_Multiply) == 0x0000F4, "Member 'ULOptionSystem::SoundOption_AmbienceVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_CinematicsVolume_Multiply) == 0x0000F8, "Member 'ULOptionSystem::SoundOption_CinematicsVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_EffectVolume_Multiply) == 0x0000FC, "Member 'ULOptionSystem::SoundOption_EffectVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_VoiceVolume_Multiply) == 0x000100, "Member 'ULOptionSystem::SoundOption_VoiceVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, SoundOption_SystemVolume_Multiply) == 0x000104, "Member 'ULOptionSystem::SoundOption_SystemVolume_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_ForceFeedback_Multiply) == 0x000108, "Member 'ULOptionSystem::ControllerOption_ForceFeedback_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_DeadZone_L_Multiply) == 0x00010C, "Member 'ULOptionSystem::ControllerOption_DeadZone_L_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_DeadZone_R_Multiply) == 0x000110, "Member 'ULOptionSystem::ControllerOption_DeadZone_R_Multiply' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_ForceFeedback_Left_Large) == 0x000114, "Member 'ULOptionSystem::ControllerOption_ForceFeedback_Left_Large' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_ForceFeedback_Right_Large) == 0x000118, "Member 'ULOptionSystem::ControllerOption_ForceFeedback_Right_Large' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_ForceFeedback_Left_Small) == 0x00011C, "Member 'ULOptionSystem::ControllerOption_ForceFeedback_Left_Small' has a wrong offset!");
static_assert(offsetof(ULOptionSystem, ControllerOption_ForceFeedback_Right_Small) == 0x000120, "Member 'ULOptionSystem::ControllerOption_ForceFeedback_Right_Small' has a wrong offset!");

// Class ProjectP.LPartsAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class ULPartsAnimInstance final : public UAnimInstance
{
public:
	class FName                                   AnimState;                                         // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeAnimState(class FName AnimState_0);
	void ClearAnimState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPartsAnimInstance">();
	}
	static class ULPartsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPartsAnimInstance>();
	}
};
static_assert(alignof(ULPartsAnimInstance) == 0x000010, "Wrong alignment on ULPartsAnimInstance");
static_assert(sizeof(ULPartsAnimInstance) == 0x0002C0, "Wrong size on ULPartsAnimInstance");
static_assert(offsetof(ULPartsAnimInstance, AnimState) == 0x0002B8, "Member 'ULPartsAnimInstance::AnimState' has a wrong offset!");

// Class ProjectP.LPartsComponent
// 0x00D0 (0x02C0 - 0x01F0)
class ULPartsComponent final : public USceneComponent
{
public:
	uint8                                         bBoneMerging : 1;                                  // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreHitJudgmentAngle : 1;                       // 0x01E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDropOnCompleteDestruct : 1;                       // 0x01E8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideAttachedBoneOnCompleteDestruct : 1;           // 0x01E8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableSplashBloodFX : 1;                         // 0x01E8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCompleteDestruct : 1;                             // 0x01E8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDestoryedOnSpawn : 1;                             // 0x01E8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableOnSpawn : 1;                                // 0x01E8(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHitEnabled : 1;                                   // 0x01E9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EA[0x2];                                      // 0x01EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PartsIndex;                                        // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LinkBodyBones;                                     // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ForceCompleteDestructionIndex;                     // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCPartsInfoCodeName;                              // 0x0204(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NPCBodyWeaponInfoCodeName;                         // 0x020C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPartsAttachPointType                        AttachPointType;                                   // 0x0214(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FLPartsBuildData>          PartsBuildDatas;                                   // 0x0218(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALCharacter>             OwnerCharacter;                                    // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALPartsActor*                           PartsActor;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DestructionIndex;                                  // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrHealthPoint;                                   // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxHealthPoint;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x3C];                                     // 0x0284(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakParts();
	void ChangeNextCompeleteDestructState();
	void ChangeNextDestructState();
	bool CheckHitJudgmentAngle(class AActor* Attacker);
	bool CheckRepulseHitLevel(ELPhysicalDamageType InPhysicalDamageType, int32 InAttackRepulseLevel);
	struct FNPCPartsInfoPtr GetNPCPartsInfoByDestruction();
	class ALCharacter* GetOwnerCharacter();
	void ReceiveDamage(int32 Damage, bool* bDamaged, bool* bDestructionIndexDestoryed, class ULHitProcContext* HitProcContext);
	void SetLastImpulseDirection(const struct FVector& ImpulseDirection);
	void SetPartsEnabled(bool bEnable);

	class ALPartsActor* GetPartsActor() const;
	int32 GetPartsIndex() const;
	class FName GetPartsSkillCodeNameOnDestory() const;
	bool IsCompleteDestruct() const;
	bool IsHitEnabled() const;
	bool IsPartsDamageToOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPartsComponent">();
	}
	static class ULPartsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPartsComponent>();
	}
};
static_assert(alignof(ULPartsComponent) == 0x000010, "Wrong alignment on ULPartsComponent");
static_assert(sizeof(ULPartsComponent) == 0x0002C0, "Wrong size on ULPartsComponent");
static_assert(offsetof(ULPartsComponent, PartsIndex) == 0x0001EC, "Member 'ULPartsComponent::PartsIndex' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, LinkBodyBones) == 0x0001F0, "Member 'ULPartsComponent::LinkBodyBones' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, ForceCompleteDestructionIndex) == 0x000200, "Member 'ULPartsComponent::ForceCompleteDestructionIndex' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, NPCPartsInfoCodeName) == 0x000204, "Member 'ULPartsComponent::NPCPartsInfoCodeName' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, NPCBodyWeaponInfoCodeName) == 0x00020C, "Member 'ULPartsComponent::NPCBodyWeaponInfoCodeName' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, AttachPointType) == 0x000214, "Member 'ULPartsComponent::AttachPointType' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, PartsBuildDatas) == 0x000218, "Member 'ULPartsComponent::PartsBuildDatas' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, OwnerCharacter) == 0x000268, "Member 'ULPartsComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, PartsActor) == 0x000270, "Member 'ULPartsComponent::PartsActor' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, DestructionIndex) == 0x000278, "Member 'ULPartsComponent::DestructionIndex' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, CurrHealthPoint) == 0x00027C, "Member 'ULPartsComponent::CurrHealthPoint' has a wrong offset!");
static_assert(offsetof(ULPartsComponent, MaxHealthPoint) == 0x000280, "Member 'ULPartsComponent::MaxHealthPoint' has a wrong offset!");

// Class ProjectP.LPatchRewardSystem
// 0x00A0 (0x0118 - 0x0078)
class ULPatchRewardSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0xA0];                                      // 0x0078(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPatchRewardSystem">();
	}
	static class ULPatchRewardSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPatchRewardSystem>();
	}
};
static_assert(alignof(ULPatchRewardSystem) == 0x000008, "Wrong alignment on ULPatchRewardSystem");
static_assert(sizeof(ULPatchRewardSystem) == 0x000118, "Wrong size on ULPatchRewardSystem");

// Class ProjectP.LPathWayObject
// 0x0038 (0x0218 - 0x01E0)
class ALPathWayObject final : public AActor
{
public:
	class FName                                   PathWayCodeName;                                   // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPathWayType                                 PathWayType;                                       // 0x01E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLPathWayPointData>             WayPoints;                                         // 0x01F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class ULPathWaySplineComponent*               SplineComponent;                                   // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x10];                                     // 0x0208(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPathWayObject">();
	}
	static class ALPathWayObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPathWayObject>();
	}
};
static_assert(alignof(ALPathWayObject) == 0x000008, "Wrong alignment on ALPathWayObject");
static_assert(sizeof(ALPathWayObject) == 0x000218, "Wrong size on ALPathWayObject");
static_assert(offsetof(ALPathWayObject, PathWayCodeName) == 0x0001E0, "Member 'ALPathWayObject::PathWayCodeName' has a wrong offset!");
static_assert(offsetof(ALPathWayObject, PathWayType) == 0x0001E8, "Member 'ALPathWayObject::PathWayType' has a wrong offset!");
static_assert(offsetof(ALPathWayObject, WayPoints) == 0x0001F0, "Member 'ALPathWayObject::WayPoints' has a wrong offset!");
static_assert(offsetof(ALPathWayObject, SplineComponent) == 0x000200, "Member 'ALPathWayObject::SplineComponent' has a wrong offset!");

// Class ProjectP.LPCCharacter
// 0x0210 (0x0EB0 - 0x0CA0)
class ALPCCharacter : public ALCharacter
{
public:
	struct FDefaultStatInfoPtr                    DefaultStatInfo;                                   // 0x0CA0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA8[0x8];                                      // 0x0CA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPNPlayerData                          PlayerData;                                        // 0x0CB0(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ALWeapon*                               CurrWeapon;                                        // 0x0D30(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CurrWeaponIndex;                                   // 0x0D38(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockonLeftRightMaxSpeed;                           // 0x0D3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockonBackMaxSpeed;                                // 0x0D40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalMaxSpeed;                                    // 0x0D44(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackAttack_EnableDegree;                           // 0x0D48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4C[0x4];                                      // 0x0D4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           WeaponLists;                                       // 0x0D50(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class FName>                           WeaponNameLists;                                   // 0x0D60(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_D70[0x2];                                      // 0x0D70(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UpperBodyLookat_AlwaysActive;                      // 0x0D72(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D73[0x45];                                     // 0x0D73(0x0045)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFirstStatData>                FirstStatDataList;                                 // 0x0DB8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class ULCharacterSaveGame*                    PlayingGameData;                                   // 0x0DC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD0[0x20];                                     // 0x0DD0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle_ShowLocationMsg;                       // 0x0DF0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULSequenceActorData>     AppearanceSequenceActorData;                       // 0x0DF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootPrintInterval;                                 // 0x0E00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E04[0x4];                                      // 0x0E04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavFootPrintInterval;                              // 0x0E08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0C[0x6C];                                     // 0x0E0C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DieUI_CustomStartDelay;                            // 0x0E78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E7C[0x4];                                      // 0x0E7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALStatRoomPCCharacter*                  CachedStatRoomPC;                                  // 0x0E80(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E88[0x28];                                     // 0x0E88(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachPCLamp();
	void AttachRainHitSound(ELPhysicalSurfaceType InPhysicalSurface, const struct FVector& InLocation, float InRainIntensity, bool IsPCHit);
	bool CheckCanResetAllFirstStat();
	void CheckClearDeadInvincible();
	void ConsumeFrenzyPoint(int32 InAmount, ELFrenzyConsumeReason ConsumeReason);
	bool ConsumeSlaveMagazinePoint(int32 ConsumeAmount, int32 RequirementAmount);
	int32 ConvertFrenzyUnitCountToFrenzyPoint(int32 FrenzyUnitCount);
	void EndAction_GameStart();
	void EndAction_TeleportEnd();
	void Execute_ShowLocationMsg(bool Teleport);
	void ExecuteAction_GameStart();
	void ExecuteAction_Reconnect();
	bool ExecuteAction_Teleport_NewGamePlus();
	void ExecuteAction_TeleportEnd_Normal();
	void ExecuteAction_TeleportStart(class FName TeleportTorsionCoil, bool IsTeleportByClock);
	void ExecuteAppearanceProcessEnd();
	void GainFrenzyPoint(int32 InAmount);
	int32 GetCurrentFrenzyUnitCount();
	class ULStatComponent* GetDefaultStatComponent(class FName DefalutStatName);
	struct FWeightPenaltyInfoPtr GetWeightPenalty();
	struct FWeightPenaltyInfoPtr GetWeightPenaltyInGivenMaxWeight(int32 InMaxWeight);
	void InitialOverlapUpdate();
	bool IsEyeColorChanged();
	bool IsFrenzyActivated();
	bool IsStaminaChangeStatus();
	void OnAlertLamp(float DurationTime);
	void OnBackToHotelTorsionCoil(bool UseItem);
	void OnBackToLatestTorsionCoil(bool UseItem);
	void OnClosedLevelUpOrPOrgan(class FName WidgetTableName);
	void OnDialogLampOff();
	void OnDialogLampOn();
	void OnExecuteTeleport();
	void OnFinishedIntroSequenceActor();
	void OnFinishedPortalSequenceActor();
	void OnFrenzyModeMV(bool bFrenzyMode, bool bInstant);
	void OnGainExp(int32 InExp);
	void OnGainHumanity(int32 InHumanity);
	void OnGainItem(class FName ItemId, int32 ItemCount);
	void OnGainWeapon(const class FName& Handle, const class FName& Blade);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);
	void OnInitMainUI(class FName MainStateName);
	void OnMustBeEqualStatsKeepSamed(ELSecondStat StatType);
	void OnPlayIntroSequenceActor();
	void OnReadyHUD();
	void OnUIConfirmTeleport(class FName TeleportTorsionCoil);
	void OnUseItemBP(class FName ItemId, bool IsOn);
	void OnWatchActionStateAfterRemove(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair);
	void OnWatchActionStateBeforeAdd(class ULActMgrComponent* InActMgrComponent, class FName ActionState, bool IsPair);
	void ProcessBeginPlayBP();
	void RemoveRainHitSound();
	bool RequestResetAllFirstStat();
	void RequestResetFX();
	void SelectDefaultStat(class FName DefaultStatCodeName);
	void ShowUIMsgYouDie();
	void UIActiveLevelUpWidget(bool IsActive, bool IsResetLevelUp);

	bool CheckCanChangeFirstStat(ELFirstStat FirstStat, int32 ChangeData, int32* OutErrorCode) const;
	class FName GetCurrentWeaponName() const;
	int32 GetFirstStat(ELFirstStatDataType DataType, ELFirstStat StatType) const;
	class UMeshComponent* GetLampMesh() const;
	int32 GetMaxWeaponCount() const;
	int32 GetWeaponIndex() const;
	bool IsProtectErgoDrop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPCCharacter">();
	}
	static class ALPCCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPCCharacter>();
	}
};
static_assert(alignof(ALPCCharacter) == 0x000010, "Wrong alignment on ALPCCharacter");
static_assert(sizeof(ALPCCharacter) == 0x000EB0, "Wrong size on ALPCCharacter");
static_assert(offsetof(ALPCCharacter, DefaultStatInfo) == 0x000CA0, "Member 'ALPCCharacter::DefaultStatInfo' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, PlayerData) == 0x000CB0, "Member 'ALPCCharacter::PlayerData' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, CurrWeapon) == 0x000D30, "Member 'ALPCCharacter::CurrWeapon' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, CurrWeaponIndex) == 0x000D38, "Member 'ALPCCharacter::CurrWeaponIndex' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, LockonLeftRightMaxSpeed) == 0x000D3C, "Member 'ALPCCharacter::LockonLeftRightMaxSpeed' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, LockonBackMaxSpeed) == 0x000D40, "Member 'ALPCCharacter::LockonBackMaxSpeed' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, NormalMaxSpeed) == 0x000D44, "Member 'ALPCCharacter::NormalMaxSpeed' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, BackAttack_EnableDegree) == 0x000D48, "Member 'ALPCCharacter::BackAttack_EnableDegree' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, WeaponLists) == 0x000D50, "Member 'ALPCCharacter::WeaponLists' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, WeaponNameLists) == 0x000D60, "Member 'ALPCCharacter::WeaponNameLists' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, UpperBodyLookat_AlwaysActive) == 0x000D72, "Member 'ALPCCharacter::UpperBodyLookat_AlwaysActive' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, FirstStatDataList) == 0x000DB8, "Member 'ALPCCharacter::FirstStatDataList' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, PlayingGameData) == 0x000DC8, "Member 'ALPCCharacter::PlayingGameData' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, TimerHandle_ShowLocationMsg) == 0x000DF0, "Member 'ALPCCharacter::TimerHandle_ShowLocationMsg' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, AppearanceSequenceActorData) == 0x000DF8, "Member 'ALPCCharacter::AppearanceSequenceActorData' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, FootPrintInterval) == 0x000E00, "Member 'ALPCCharacter::FootPrintInterval' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, NavFootPrintInterval) == 0x000E08, "Member 'ALPCCharacter::NavFootPrintInterval' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, DieUI_CustomStartDelay) == 0x000E78, "Member 'ALPCCharacter::DieUI_CustomStartDelay' has a wrong offset!");
static_assert(offsetof(ALPCCharacter, CachedStatRoomPC) == 0x000E80, "Member 'ALPCCharacter::CachedStatRoomPC' has a wrong offset!");

// Class ProjectP.LPCControllerDefault
// 0x0000 (0x0548 - 0x0548)
class ALPCControllerDefault final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPCControllerDefault">();
	}
	static class ALPCControllerDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPCControllerDefault>();
	}
};
static_assert(alignof(ALPCControllerDefault) == 0x000008, "Wrong alignment on ALPCControllerDefault");
static_assert(sizeof(ALPCControllerDefault) == 0x000548, "Wrong size on ALPCControllerDefault");

// Class ProjectP.LPhysicalAnimationComponent
// 0x0240 (0x02F0 - 0x00B0)
class ULPhysicalAnimationComponent : public UActorComponent
{
public:
	ELPhysicsState                                CurrentState;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cached_RagdollStartTime;                           // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USkeletalMeshComponent>  PendingInfo_SkeletalMeshComponent;                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PendingInfo_FromBeginPlay;                         // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELPhysicsState>                        PendingStateArray;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FLPhysicsInfo_NoPhysics                PendingInfo_NoPhysics;                             // 0x00E0(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLPhysicsInfo_PhysicalAnimation        PendingInfo_PhysicalAnimation;                     // 0x00E1(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLPhysicsInfo_RagDoll                  PendingInfo_RagDoll;                               // 0x00E2(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x5];                                       // 0x00E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLPhysicsInfo_Explosion                PendingInfo_Explosion;                             // 0x00E8(0x0200)(Edit, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLPhysicsInfo_PhysicsAsset             PendingInfo_PhysicsAsset;                          // 0x02E8(0x0008)(Edit, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static bool GetUseRagdollSleepAndWake();

	bool ChangePhysicsAssetBP(const struct FLPhysicsInfo_PhysicsAsset& PhysicsInfo, EExecutePin* Branches);
	bool ChangeToExplosionBP(const struct FLPhysicsInfo_Explosion& PhysicsInfo, EExecutePin* Branches);
	bool ChangeToNoPhysicsBP(const struct FLPhysicsInfo_NoPhysics& PhysicsInfo, EExecutePin* Branches);
	bool ChangeToPhysicalAnimationBP(const struct FLPhysicsInfo_PhysicalAnimation& PhysicsInfo, EExecutePin* Branches);
	bool ChangeToRagdollBP(const struct FLPhysicsInfo_RagDoll& PhysicsInfo, EExecutePin* Branches);
	bool ChangeToRagdollFreezeBP(EExecutePin* Branches);
	void Debug_BindRagdollOverlapWake();
	void Debug_UnbindRagdollOverlapWake();
	class USkeletalMeshComponent* GetSkeletalMeshComponentBP(EExecutePin* Branches);
	struct FLPhysicsInfo_Explosion MakeExplosionInfo(class AActor* TargetActor, class AActor* Murderer, const struct FLHitInfo& HitInfo);
	bool OnChangePhysicsAssetBP(const struct FLPhysicsInfo_PhysicsAsset& PhysicsInfo);
	bool OnChangeToExplosionBP(const struct FLPhysicsInfo_Explosion& PhysicsInfo);
	bool OnChangeToNoPhysicsBP(const struct FLPhysicsInfo_NoPhysics& PhysicsInfo);
	bool OnChangeToPhysicalAnimationBP(const struct FLPhysicsInfo_PhysicalAnimation& PhysicsInfo);
	bool OnChangeToRagdollBP(const struct FLPhysicsInfo_RagDoll& PhysicsInfo);
	bool OnChangeToRagdollFreezeBP();
	void OnResetBP(class USkeletalMeshComponent* InSkeletalMeshComponent);
	void PutAllRigidBodiesToSleep();
	bool ReserveChangePhysicsAssetBP(const struct FLPhysicsInfo_PhysicsAsset& PhysicsInfo, EExecutePin* Branches);
	bool ReserveChangeToExplosionBP(const struct FLPhysicsInfo_Explosion& PhysicsInfo, EExecutePin* Branches);
	bool ReserveChangeToNoPhysicsBP(const struct FLPhysicsInfo_NoPhysics& PhysicsInfo, EExecutePin* Branches);
	bool ReserveChangeToPhysicalAnimationBP(const struct FLPhysicsInfo_PhysicalAnimation& PhysicsInfo, EExecutePin* Branches);
	bool ReserveChangeToRagdollBP(const struct FLPhysicsInfo_RagDoll& PhysicsInfo, EExecutePin* Branches);
	bool ReserveChangeToRagdollFreezeBP(EExecutePin* Branches);
	bool ReserveResetBP(class USkeletalMeshComponent* InSkeletalMeshComponent, bool FromBeginPlay, EExecutePin* Branches);
	void Reset(class USkeletalMeshComponent* InSkeletalMeshComponent, bool FromBeginPlay);
	void ResetExplosionState();
	void WakeAllRigidBodies();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPhysicalAnimationComponent">();
	}
	static class ULPhysicalAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPhysicalAnimationComponent>();
	}
};
static_assert(alignof(ULPhysicalAnimationComponent) == 0x000008, "Wrong alignment on ULPhysicalAnimationComponent");
static_assert(sizeof(ULPhysicalAnimationComponent) == 0x0002F0, "Wrong size on ULPhysicalAnimationComponent");
static_assert(offsetof(ULPhysicalAnimationComponent, CurrentState) == 0x0000B0, "Member 'ULPhysicalAnimationComponent::CurrentState' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, Cached_RagdollStartTime) == 0x0000B4, "Member 'ULPhysicalAnimationComponent::Cached_RagdollStartTime' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_SkeletalMeshComponent) == 0x0000C0, "Member 'ULPhysicalAnimationComponent::PendingInfo_SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_FromBeginPlay) == 0x0000C8, "Member 'ULPhysicalAnimationComponent::PendingInfo_FromBeginPlay' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingStateArray) == 0x0000D0, "Member 'ULPhysicalAnimationComponent::PendingStateArray' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_NoPhysics) == 0x0000E0, "Member 'ULPhysicalAnimationComponent::PendingInfo_NoPhysics' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_PhysicalAnimation) == 0x0000E1, "Member 'ULPhysicalAnimationComponent::PendingInfo_PhysicalAnimation' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_RagDoll) == 0x0000E2, "Member 'ULPhysicalAnimationComponent::PendingInfo_RagDoll' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_Explosion) == 0x0000E8, "Member 'ULPhysicalAnimationComponent::PendingInfo_Explosion' has a wrong offset!");
static_assert(offsetof(ULPhysicalAnimationComponent, PendingInfo_PhysicsAsset) == 0x0002E8, "Member 'ULPhysicalAnimationComponent::PendingInfo_PhysicsAsset' has a wrong offset!");

// Class ProjectP.LPlayerEquipment
// 0x0190 (0x01B8 - 0x0028)
class ULPlayerEquipment final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChangeEquipItem;                                 // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeUseItem;                                   // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeAssistUseItem;                             // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeComplexItem;                               // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMap<ELEquipSlotType, struct FLEquipItemSlot> EquipSlots;                                        // 0x0068(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLUseItemSlot>                  UseSlots1;                                         // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLUseItemSlot>                  UseSlots2;                                         // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         SelectedIdx_UseSlot1;                              // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedIdx_UseSlot2;                              // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ELAssistUseItemSlotType, struct FLAssistUseItemSlot> AssistUseSlots;                                    // 0x00E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChooseWeaponItem;                                // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChooseSlaveArmItem;                              // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChooseUseItem;                                   // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FLEquipItemSlot                        ChosenEquipSlot;                                   // 0x0168(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLEquipItemSlot                        ChosenSlaveArmSlot;                                // 0x0180(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLUseItemSlot                          ChosenUseSlot;                                     // 0x0198(0x0014)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ELItemMaterial                                PartsSetMaterial;                                  // 0x01AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PartsSetAbnormalCodeName;                          // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckCanEquipItem(ELEquipSlotType SlotType, class ULItem* Item);
	void ChooseNextSlaveArmItem(bool bSelectPrevious);
	void ChooseNextUseItem(bool bSelectPrevious);
	void ChooseNextWeaponItem(bool bSelectPrevious);
	bool EquipAssistUseItem(ELAssistUseItemSlotType SlotType, class ULItem* Item);
	bool EquipItem(ELEquipSlotType SlotType, class ULItem* Item);
	bool EquipUseItem_CurrentLine(int32 SlotIndex, class ULItem* Item);
	bool EquipUseItem_SpecifiedLine(int32 SlotIndex, class ULItem* Item, bool FirstLine);
	struct FLAssistUseItemSlot FindAssistUseItem(class FName ItemCodeName);
	struct FLEquipItemSlot FindEquipItem(class ULItem* Item);
	TArray<struct FLEquipItemSlot> FindEquipItems_ByEquipGroupId(int32 InEquipGroupId);
	struct FLUseItemSlot FindUseItem_CurrentLine(class FName ItemCodeName);
	struct FLUseItemSlot FindUseItem_SpecifiedLine(class FName ItemCodeName, bool FirstLine);
	class ULItem* GetAssistUseItem(ELAssistUseItemSlotType SlotType);
	class FName GetAssistUseItemCodeName(ELAssistUseItemSlotType SlotType);
	struct FLEquipItemSlot GetChosenSlaveArmItem();
	struct FLUseItemSlot GetChosenUseItem();
	struct FLEquipItemSlot GetChosenWeaponItem();
	void GetChosenWeaponItemBP(class ALWeapon** Weapon, ELEquipSlotType* EquipSlot);
	class ULItem* GetEquipItem(ELEquipSlotType SlotType);
	struct FLEquipItemSlot GetEquipItemSlot(ELEquipSlotType EquipSlotType, bool* bFound);
	ELEquipSlotType GetEquipSlot(const class ULItem* Item);
	class ULItem* GetUseItem_CurrentLine(int32 SlotIndex);
	class ULItem* GetUseItem_SpecifiedLine(int32 SlotIndex, bool FirstLine);
	class FName GetUseItemCodeName_CurrentLine(int32 SlotIndex);
	class FName GetUseItemCodeName_SpecifiedLine(int32 SlotIndex, bool FirstLine);
	struct FLUseItemSlot GetUseItemSlot(bool FirstLine, int32 SlotIndex, bool* bFound);
	TArray<struct FLUseItemSlot> GetUseSlotsLine(bool FirstLine);
	const TArray<struct FLUseItemSlot> GetUseSlotsLine_AllSlot(bool FirstLine);
	void SetUnlockEquipSlot(ELEquipSlotType SlotType, bool bUnlock);
	void SetUnlockEquipSlotByCategory(class FName SlotCategoryType, bool bUnlock);
	void SetUnlockEquipUseSlot(bool bUnlock, int32 Count);
	bool SwapUseSlotsLine();
	bool UnEquipAssistUseItem(ELAssistUseItemSlotType SlotType);
	bool UnEquipItem(ELEquipSlotType SlotType);
	bool UnEquipUseItem_CurrentLine(int32 SlotIndex);
	bool UnEquipUseItem_SpecifiedLine(int32 SlotIndex, bool FirstLine);

	TArray<ELEquipSlotType> GetGearArmSlotTypeList() const;
	TArray<ELEquipSlotType> GetSlaveArmSlotTypeList() const;
	TArray<ELEquipSlotType> GetWeaponSlotTypeList() const;
	bool IsEquipedPartsSet() const;
	bool IsSelectedUseSlotsLineFirst() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayerEquipment">();
	}
	static class ULPlayerEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayerEquipment>();
	}
};
static_assert(alignof(ULPlayerEquipment) == 0x000008, "Wrong alignment on ULPlayerEquipment");
static_assert(sizeof(ULPlayerEquipment) == 0x0001B8, "Wrong size on ULPlayerEquipment");
static_assert(offsetof(ULPlayerEquipment, OnChangeEquipItem) == 0x000028, "Member 'ULPlayerEquipment::OnChangeEquipItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, OnChangeUseItem) == 0x000038, "Member 'ULPlayerEquipment::OnChangeUseItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, OnChangeAssistUseItem) == 0x000048, "Member 'ULPlayerEquipment::OnChangeAssistUseItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, OnChangeComplexItem) == 0x000058, "Member 'ULPlayerEquipment::OnChangeComplexItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, EquipSlots) == 0x000068, "Member 'ULPlayerEquipment::EquipSlots' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, UseSlots1) == 0x0000C0, "Member 'ULPlayerEquipment::UseSlots1' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, UseSlots2) == 0x0000D0, "Member 'ULPlayerEquipment::UseSlots2' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, SelectedIdx_UseSlot1) == 0x0000E0, "Member 'ULPlayerEquipment::SelectedIdx_UseSlot1' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, SelectedIdx_UseSlot2) == 0x0000E4, "Member 'ULPlayerEquipment::SelectedIdx_UseSlot2' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, AssistUseSlots) == 0x0000E8, "Member 'ULPlayerEquipment::AssistUseSlots' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, OnChooseWeaponItem) == 0x000138, "Member 'ULPlayerEquipment::OnChooseWeaponItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, OnChooseSlaveArmItem) == 0x000148, "Member 'ULPlayerEquipment::OnChooseSlaveArmItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, OnChooseUseItem) == 0x000158, "Member 'ULPlayerEquipment::OnChooseUseItem' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, ChosenEquipSlot) == 0x000168, "Member 'ULPlayerEquipment::ChosenEquipSlot' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, ChosenSlaveArmSlot) == 0x000180, "Member 'ULPlayerEquipment::ChosenSlaveArmSlot' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, ChosenUseSlot) == 0x000198, "Member 'ULPlayerEquipment::ChosenUseSlot' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, PartsSetMaterial) == 0x0001AC, "Member 'ULPlayerEquipment::PartsSetMaterial' has a wrong offset!");
static_assert(offsetof(ULPlayerEquipment, PartsSetAbnormalCodeName) == 0x0001B0, "Member 'ULPlayerEquipment::PartsSetAbnormalCodeName' has a wrong offset!");

// Class ProjectP.LPlayInputSystem
// 0x00A0 (0x0118 - 0x0078)
class ULPlayInputSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnChangePlayInput;                                 // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputNavigationKey;                              // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<struct FLInputAxisSpeedMapping>        InputAxisValueStep;                                // 0x0098(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLInputAxisSpeedMapping>        InputAxisValueStepForLockOnSideStep;               // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLInputAxisSpeedMapping>        InputAxisValueStepForLockOnForwardStep;            // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLInputAxisSpeedMapping>        InputAxisValueStepForLockOnBackwardStep;           // 0x00C8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         LockOnRotationInterpSpeed;                         // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   LastInputKey;                                      // 0x00E0(0x0018)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamePadMode;                                      // 0x00F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWinDualShock;                                  // 0x00F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA[0x16];                                      // 0x00FA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayInputLock;                                    // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushPressedActionBindingKeysExceptAxisKeys();
	void FlushPressedKeys();
	void SetPlayInputLock(bool block);

	class FString GetInputPlatformName() const;
	const struct FKey GetLastInputKey() const;
	class ULPlayerInput* GetPlayerInput() const;
	bool IsGamePadMode() const;
	bool IsRightAcceptButton() const;
	bool IsUsingPlayStationGamePad() const;
	bool IsUsingWinDualSense() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPlayInputSystem">();
	}
	static class ULPlayInputSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPlayInputSystem>();
	}
};
static_assert(alignof(ULPlayInputSystem) == 0x000008, "Wrong alignment on ULPlayInputSystem");
static_assert(sizeof(ULPlayInputSystem) == 0x000118, "Wrong size on ULPlayInputSystem");
static_assert(offsetof(ULPlayInputSystem, OnChangePlayInput) == 0x000078, "Member 'ULPlayInputSystem::OnChangePlayInput' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, OnInputNavigationKey) == 0x000088, "Member 'ULPlayInputSystem::OnInputNavigationKey' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, InputAxisValueStep) == 0x000098, "Member 'ULPlayInputSystem::InputAxisValueStep' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, InputAxisValueStepForLockOnSideStep) == 0x0000A8, "Member 'ULPlayInputSystem::InputAxisValueStepForLockOnSideStep' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, InputAxisValueStepForLockOnForwardStep) == 0x0000B8, "Member 'ULPlayInputSystem::InputAxisValueStepForLockOnForwardStep' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, InputAxisValueStepForLockOnBackwardStep) == 0x0000C8, "Member 'ULPlayInputSystem::InputAxisValueStepForLockOnBackwardStep' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, LockOnRotationInterpSpeed) == 0x0000D8, "Member 'ULPlayInputSystem::LockOnRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, LastInputKey) == 0x0000E0, "Member 'ULPlayInputSystem::LastInputKey' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, bGamePadMode) == 0x0000F8, "Member 'ULPlayInputSystem::bGamePadMode' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, bUseWinDualShock) == 0x0000F9, "Member 'ULPlayInputSystem::bUseWinDualShock' has a wrong offset!");
static_assert(offsetof(ULPlayInputSystem, bPlayInputLock) == 0x000110, "Member 'ULPlayInputSystem::bPlayInputLock' has a wrong offset!");

// Class ProjectP.LPreventFallingDamageVolume
// 0x0000 (0x0238 - 0x0238)
class ALPreventFallingDamageVolume final : public ALVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPreventFallingDamageVolume">();
	}
	static class ALPreventFallingDamageVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPreventFallingDamageVolume>();
	}
};
static_assert(alignof(ALPreventFallingDamageVolume) == 0x000008, "Wrong alignment on ALPreventFallingDamageVolume");
static_assert(sizeof(ALPreventFallingDamageVolume) == 0x000238, "Wrong size on ALPreventFallingDamageVolume");

// Class ProjectP.LProductSellShop
// 0x0000 (0x0028 - 0x0028)
class ULProductSellShop final : public UObject
{
public:
	TSet<ELItemFirstCategory> GetSellCategorys();
	TArray<class ULItem*> GetSellList(ELItemFirstCategory Category);
	bool Sell(class ULItem* InSell, int32 InCount, bool IsLockerItem);

	int32 CalcSellingPrice(const class ULItem* InItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProductSellShop">();
	}
	static class ULProductSellShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProductSellShop>();
	}
};
static_assert(alignof(ULProductSellShop) == 0x000008, "Wrong alignment on ULProductSellShop");
static_assert(sizeof(ULProductSellShop) == 0x000028, "Wrong size on ULProductSellShop");

// Class ProjectP.LProjectileHit_PeriodicHandler
// 0x00A8 (0x00D0 - 0x0028)
class ULProjectileHit_PeriodicHandler final : public UObject
{
public:
	class ALProjectile*                           Owner;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectileHitInfo                    HitInfo;                                           // 0x0030(0x0090)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Initialize(class ALProjectile* InOwner, const struct FLProjectileHitInfo& InHitInfo);
	void OnGenerateHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectileHit_PeriodicHandler">();
	}
	static class ULProjectileHit_PeriodicHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjectileHit_PeriodicHandler>();
	}
};
static_assert(alignof(ULProjectileHit_PeriodicHandler) == 0x000010, "Wrong alignment on ULProjectileHit_PeriodicHandler");
static_assert(sizeof(ULProjectileHit_PeriodicHandler) == 0x0000D0, "Wrong size on ULProjectileHit_PeriodicHandler");
static_assert(offsetof(ULProjectileHit_PeriodicHandler, Owner) == 0x000028, "Member 'ULProjectileHit_PeriodicHandler::Owner' has a wrong offset!");
static_assert(offsetof(ULProjectileHit_PeriodicHandler, HitInfo) == 0x000030, "Member 'ULProjectileHit_PeriodicHandler::HitInfo' has a wrong offset!");
static_assert(offsetof(ULProjectileHit_PeriodicHandler, TimerHandle) == 0x0000C0, "Member 'ULProjectileHit_PeriodicHandler::TimerHandle' has a wrong offset!");
static_assert(offsetof(ULProjectileHit_PeriodicHandler, Count) == 0x0000C8, "Member 'ULProjectileHit_PeriodicHandler::Count' has a wrong offset!");

// Class ProjectP.LProjectileSpawn_PeriodicHandler
// 0x0068 (0x0090 - 0x0028)
class ULProjectileSpawn_PeriodicHandler final : public UObject
{
public:
	class ALProjectile*                           Owner;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLChildProjectileSpawnInfo             SpawnInfo;                                         // 0x0030(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Initialize(class ALProjectile* InOwner, const struct FLChildProjectileSpawnInfo& InSpawnInfo);
	void OnSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectileSpawn_PeriodicHandler">();
	}
	static class ULProjectileSpawn_PeriodicHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjectileSpawn_PeriodicHandler>();
	}
};
static_assert(alignof(ULProjectileSpawn_PeriodicHandler) == 0x000010, "Wrong alignment on ULProjectileSpawn_PeriodicHandler");
static_assert(sizeof(ULProjectileSpawn_PeriodicHandler) == 0x000090, "Wrong size on ULProjectileSpawn_PeriodicHandler");
static_assert(offsetof(ULProjectileSpawn_PeriodicHandler, Owner) == 0x000028, "Member 'ULProjectileSpawn_PeriodicHandler::Owner' has a wrong offset!");
static_assert(offsetof(ULProjectileSpawn_PeriodicHandler, SpawnInfo) == 0x000030, "Member 'ULProjectileSpawn_PeriodicHandler::SpawnInfo' has a wrong offset!");
static_assert(offsetof(ULProjectileSpawn_PeriodicHandler, TimerHandle) == 0x000080, "Member 'ULProjectileSpawn_PeriodicHandler::TimerHandle' has a wrong offset!");
static_assert(offsetof(ULProjectileSpawn_PeriodicHandler, Count) == 0x000088, "Member 'ULProjectileSpawn_PeriodicHandler::Count' has a wrong offset!");

// Class ProjectP.LProjectile_AbnormalApplyInRange
// 0x0040 (0x0068 - 0x0028)
class ULProjectile_AbnormalApplyInRange final : public UObject
{
public:
	class ALProjectile*                           Owner;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectileAbnormalApplyInRangeInfo   AbnormalApplyInfo;                                 // 0x0030(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class ULProjetileAbnormalApplyTargetInfo*> AppliedTargetList;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Initialize(class ALProjectile* InOwner, const struct FLProjectileAbnormalApplyInRangeInfo& InAbnormalApplyInfo);
	void OnActorBeginOverlap(class AActor* Other);
	void OnActorEndOverlap(class AActor* Other);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_AbnormalApplyInRange">();
	}
	static class ULProjectile_AbnormalApplyInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjectile_AbnormalApplyInRange>();
	}
};
static_assert(alignof(ULProjectile_AbnormalApplyInRange) == 0x000008, "Wrong alignment on ULProjectile_AbnormalApplyInRange");
static_assert(sizeof(ULProjectile_AbnormalApplyInRange) == 0x000068, "Wrong size on ULProjectile_AbnormalApplyInRange");
static_assert(offsetof(ULProjectile_AbnormalApplyInRange, Owner) == 0x000028, "Member 'ULProjectile_AbnormalApplyInRange::Owner' has a wrong offset!");
static_assert(offsetof(ULProjectile_AbnormalApplyInRange, AbnormalApplyInfo) == 0x000030, "Member 'ULProjectile_AbnormalApplyInRange::AbnormalApplyInfo' has a wrong offset!");
static_assert(offsetof(ULProjectile_AbnormalApplyInRange, AppliedTargetList) == 0x000048, "Member 'ULProjectile_AbnormalApplyInRange::AppliedTargetList' has a wrong offset!");

// Class ProjectP.LProjectileMovementComponent
// 0x0010 (0x01E0 - 0x01D0)
class ULProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	bool                                          bHandleBlockingHit;                                // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandleImpact;                                     // 0x01D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x2];                                      // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HomingTargetSocket;                                // 0x01D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectileMovementComponent">();
	}
	static class ULProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjectileMovementComponent>();
	}
};
static_assert(alignof(ULProjectileMovementComponent) == 0x000010, "Wrong alignment on ULProjectileMovementComponent");
static_assert(sizeof(ULProjectileMovementComponent) == 0x0001E0, "Wrong size on ULProjectileMovementComponent");
static_assert(offsetof(ULProjectileMovementComponent, bHandleBlockingHit) == 0x0001D0, "Member 'ULProjectileMovementComponent::bHandleBlockingHit' has a wrong offset!");
static_assert(offsetof(ULProjectileMovementComponent, bHandleImpact) == 0x0001D1, "Member 'ULProjectileMovementComponent::bHandleImpact' has a wrong offset!");
static_assert(offsetof(ULProjectileMovementComponent, HomingTargetSocket) == 0x0001D4, "Member 'ULProjectileMovementComponent::HomingTargetSocket' has a wrong offset!");

// Class ProjectP.LProjectile_Direct
// 0x0010 (0x0410 - 0x0400)
class ALProjectile_Direct : public ALProjectile_Typical
{
public:
	uint8                                         Pad_3F8[0x18];                                     // 0x03F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_Direct">();
	}
	static class ALProjectile_Direct* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_Direct>();
	}
};
static_assert(alignof(ALProjectile_Direct) == 0x000010, "Wrong alignment on ALProjectile_Direct");
static_assert(sizeof(ALProjectile_Direct) == 0x000410, "Wrong size on ALProjectile_Direct");

// Class ProjectP.LProjectile_Chase
// 0x0040 (0x0440 - 0x0400)
class ALProjectile_Chase final : public ALProjectile_Typical
{
public:
	ELChaseProjectileState                        ChasingState;                                      // 0x03F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Chase_Start_Distance;                              // 0x03FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chase_Start_Angle;                                 // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chase_Start_HalfHeight;                            // 0x0404(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chase_End_Distance;                                // 0x0408(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chase_End_Angle;                                   // 0x040C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chase_End_HalfHeight;                              // 0x0410(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Chase_Target_Socket;                               // 0x0414(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0x24];                                     // 0x041C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeChasingState(ELChaseProjectileState NewState);
	void UpdateChaseProjectileState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_Chase">();
	}
	static class ALProjectile_Chase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_Chase>();
	}
};
static_assert(alignof(ALProjectile_Chase) == 0x000010, "Wrong alignment on ALProjectile_Chase");
static_assert(sizeof(ALProjectile_Chase) == 0x000440, "Wrong size on ALProjectile_Chase");
static_assert(offsetof(ALProjectile_Chase, ChasingState) == 0x0003F8, "Member 'ALProjectile_Chase::ChasingState' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_Start_Distance) == 0x0003FC, "Member 'ALProjectile_Chase::Chase_Start_Distance' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_Start_Angle) == 0x000400, "Member 'ALProjectile_Chase::Chase_Start_Angle' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_Start_HalfHeight) == 0x000404, "Member 'ALProjectile_Chase::Chase_Start_HalfHeight' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_End_Distance) == 0x000408, "Member 'ALProjectile_Chase::Chase_End_Distance' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_End_Angle) == 0x00040C, "Member 'ALProjectile_Chase::Chase_End_Angle' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_End_HalfHeight) == 0x000410, "Member 'ALProjectile_Chase::Chase_End_HalfHeight' has a wrong offset!");
static_assert(offsetof(ALProjectile_Chase, Chase_Target_Socket) == 0x000414, "Member 'ALProjectile_Chase::Chase_Target_Socket' has a wrong offset!");

// Class ProjectP.LProjectile_Ring
// 0x0020 (0x0420 - 0x0400)
class ALProjectile_Ring final : public ALProjectile_Typical
{
public:
	struct FLProjectileCollisionData_Cylinder     RingCollisionData;                                 // 0x03F8(0x001C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0xC];                                      // 0x0414(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectile_Ring">();
	}
	static class ALProjectile_Ring* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALProjectile_Ring>();
	}
};
static_assert(alignof(ALProjectile_Ring) == 0x000010, "Wrong alignment on ALProjectile_Ring");
static_assert(sizeof(ALProjectile_Ring) == 0x000420, "Wrong size on ALProjectile_Ring");
static_assert(offsetof(ALProjectile_Ring, RingCollisionData) == 0x0003F8, "Member 'ALProjectile_Ring::RingCollisionData' has a wrong offset!");

// Class ProjectP.LProjectileSystem
// 0x00B8 (0x0130 - 0x0078)
class ULProjectileSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0xB1];                                      // 0x0078(0x00B1)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         GDebugDrawType;                                    // 0x0129(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x6];                                      // 0x012A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUniqueSkillHit(class AActor* Victim, class FName SkillHitCodeName, float InDuration);
	void ClearAllProjectile();
	float FindAngularProjectileAngle(const struct FVector& FireLocation, const struct FVector& TargetLocation, float Speed, float GravityForce);
	float FindAngularProjectileSpeed(const struct FVector& FireLocation, const struct FVector& TargetLocation, float Angle);
	struct FVector FindAngularProjectileVelocity(const struct FVector& FireLocation, const struct FVector& TargetLocation, float Duration);
	bool IsSkillHitIgnored(class AActor* Victim, class FName SkillHitCodeName);
	class ALProjectile* LaunchProjectile(class AActor* Instigator, const struct FLProjectileSpawnParameter& SpawnParameters);
	void PauseAllProjectile(bool PauseFlag);
	void RemoveProjectile(int64 ProjectileHandleId);

	bool BoxOverlapMultiByProfile(class ALProjectile* Projectile, TArray<struct FLOverlapResult>* OutOverlaps, const struct FVector& Pos, const struct FRotator& Rot, const struct FVector& Extent, class FName ProfileName) const;
	bool SphereOverlapMultiByProfile(class ALProjectile* Projectile, TArray<struct FLOverlapResult>* OutOverlaps, const struct FVector& Pos, const struct FRotator& Rot, float Radius, class FName ProfileName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LProjectileSystem">();
	}
	static class ULProjectileSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULProjectileSystem>();
	}
};
static_assert(alignof(ULProjectileSystem) == 0x000008, "Wrong alignment on ULProjectileSystem");
static_assert(sizeof(ULProjectileSystem) == 0x000130, "Wrong size on ULProjectileSystem");
static_assert(offsetof(ULProjectileSystem, GDebugDrawType) == 0x000129, "Member 'ULProjectileSystem::GDebugDrawType' has a wrong offset!");

// Class ProjectP.LSpotProjectileSpawn_PeriodicHandler
// 0x0078 (0x00A0 - 0x0028)
class ULSpotProjectileSpawn_PeriodicHandler final : public UObject
{
public:
	class ALProjectilePropActor*                  Owner;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLProjectilePropSpawnParameter         SpawnInfo;                                         // 0x0030(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCount;                                        // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x14];                                      // 0x008C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Initialize(class ALProjectilePropActor* InOwner, const struct FLProjectilePropSpawnParameter& InSpawnInfo);
	void SpawnProjectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpotProjectileSpawn_PeriodicHandler">();
	}
	static class ULSpotProjectileSpawn_PeriodicHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpotProjectileSpawn_PeriodicHandler>();
	}
};
static_assert(alignof(ULSpotProjectileSpawn_PeriodicHandler) == 0x000010, "Wrong alignment on ULSpotProjectileSpawn_PeriodicHandler");
static_assert(sizeof(ULSpotProjectileSpawn_PeriodicHandler) == 0x0000A0, "Wrong size on ULSpotProjectileSpawn_PeriodicHandler");
static_assert(offsetof(ULSpotProjectileSpawn_PeriodicHandler, Owner) == 0x000028, "Member 'ULSpotProjectileSpawn_PeriodicHandler::Owner' has a wrong offset!");
static_assert(offsetof(ULSpotProjectileSpawn_PeriodicHandler, SpawnInfo) == 0x000030, "Member 'ULSpotProjectileSpawn_PeriodicHandler::SpawnInfo' has a wrong offset!");
static_assert(offsetof(ULSpotProjectileSpawn_PeriodicHandler, TimerHandle) == 0x000080, "Member 'ULSpotProjectileSpawn_PeriodicHandler::TimerHandle' has a wrong offset!");
static_assert(offsetof(ULSpotProjectileSpawn_PeriodicHandler, SpawnCount) == 0x000088, "Member 'ULSpotProjectileSpawn_PeriodicHandler::SpawnCount' has a wrong offset!");

// Class ProjectP.LPropComponent
// 0x0070 (0x0260 - 0x01F0)
class ULPropComponent final : public USceneComponent
{
public:
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALPropSpot*                             OwnerProp;                                         // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLPropInteractionInfo>          InteractionInfoList;                               // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALPropActor>             TargetPropActor;                                   // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALLevelObject>           TargetLevelObject;                                 // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLPropState                            PropState;                                         // 0x0218(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UPrimitiveComponent>     UserInteractedComp;                                // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELPropInteractState                           PropInteractState;                                 // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELInteractResult                              PropInteractResult;                                // 0x0239(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A[0xE];                                      // 0x023A(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle_PropMotionDelay;                       // 0x0248(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InteractMotionOnly;                                // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0xF];                                      // 0x0251(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsFixCameraOnInteraction();
	void OnComponentBeginOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void OnComponentEndOverlapped_Interact(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropComponent">();
	}
	static class ULPropComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropComponent>();
	}
};
static_assert(alignof(ULPropComponent) == 0x000010, "Wrong alignment on ULPropComponent");
static_assert(sizeof(ULPropComponent) == 0x000260, "Wrong size on ULPropComponent");
static_assert(offsetof(ULPropComponent, OwnerProp) == 0x0001F0, "Member 'ULPropComponent::OwnerProp' has a wrong offset!");
static_assert(offsetof(ULPropComponent, InteractionInfoList) == 0x0001F8, "Member 'ULPropComponent::InteractionInfoList' has a wrong offset!");
static_assert(offsetof(ULPropComponent, TargetPropActor) == 0x000208, "Member 'ULPropComponent::TargetPropActor' has a wrong offset!");
static_assert(offsetof(ULPropComponent, TargetLevelObject) == 0x000210, "Member 'ULPropComponent::TargetLevelObject' has a wrong offset!");
static_assert(offsetof(ULPropComponent, PropState) == 0x000218, "Member 'ULPropComponent::PropState' has a wrong offset!");
static_assert(offsetof(ULPropComponent, UserInteractedComp) == 0x000230, "Member 'ULPropComponent::UserInteractedComp' has a wrong offset!");
static_assert(offsetof(ULPropComponent, PropInteractState) == 0x000238, "Member 'ULPropComponent::PropInteractState' has a wrong offset!");
static_assert(offsetof(ULPropComponent, PropInteractResult) == 0x000239, "Member 'ULPropComponent::PropInteractResult' has a wrong offset!");
static_assert(offsetof(ULPropComponent, TimerHandle_PropMotionDelay) == 0x000248, "Member 'ULPropComponent::TimerHandle_PropMotionDelay' has a wrong offset!");
static_assert(offsetof(ULPropComponent, InteractMotionOnly) == 0x000250, "Member 'ULPropComponent::InteractMotionOnly' has a wrong offset!");

// Class ProjectP.LPropDestructionSpot
// 0x0028 (0x0378 - 0x0350)
class ALPropDestructionSpot : public ALPropSpot
{
public:
	float                                         OverrideMassScale;                                 // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ControlVolumeSpot;                                 // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ControlShapeObjectSpots;                           // 0x0360(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DestructionObjectCrashed;                          // 0x0370(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoFracture();
	void OnDestructionObjectCrashed();
	void SetCodeNameByBP(class FName InCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropDestructionSpot">();
	}
	static class ALPropDestructionSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropDestructionSpot>();
	}
};
static_assert(alignof(ALPropDestructionSpot) == 0x000008, "Wrong alignment on ALPropDestructionSpot");
static_assert(sizeof(ALPropDestructionSpot) == 0x000378, "Wrong size on ALPropDestructionSpot");
static_assert(offsetof(ALPropDestructionSpot, OverrideMassScale) == 0x000350, "Member 'ALPropDestructionSpot::OverrideMassScale' has a wrong offset!");
static_assert(offsetof(ALPropDestructionSpot, ControlVolumeSpot) == 0x000358, "Member 'ALPropDestructionSpot::ControlVolumeSpot' has a wrong offset!");
static_assert(offsetof(ALPropDestructionSpot, ControlShapeObjectSpots) == 0x000360, "Member 'ALPropDestructionSpot::ControlShapeObjectSpots' has a wrong offset!");
static_assert(offsetof(ALPropDestructionSpot, DestructionObjectCrashed) == 0x000370, "Member 'ALPropDestructionSpot::DestructionObjectCrashed' has a wrong offset!");

// Class ProjectP.LPropGuideObjectSpot
// 0x0000 (0x0350 - 0x0350)
class ALPropGuideObjectSpot final : public ALPropShapeObjectSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropGuideObjectSpot">();
	}
	static class ALPropGuideObjectSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropGuideObjectSpot>();
	}
};
static_assert(alignof(ALPropGuideObjectSpot) == 0x000008, "Wrong alignment on ALPropGuideObjectSpot");
static_assert(sizeof(ALPropGuideObjectSpot) == 0x000350, "Wrong size on ALPropGuideObjectSpot");

// Class ProjectP.LDynamicPropItemSpot
// 0x0000 (0x0378 - 0x0378)
class ALDynamicPropItemSpot final : public ALPropItemSpot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LDynamicPropItemSpot">();
	}
	static class ALDynamicPropItemSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALDynamicPropItemSpot>();
	}
};
static_assert(alignof(ALDynamicPropItemSpot) == 0x000008, "Wrong alignment on ALDynamicPropItemSpot");
static_assert(sizeof(ALDynamicPropItemSpot) == 0x000378, "Wrong size on ALDynamicPropItemSpot");

// Class ProjectP.LPropLadderSpot
// 0x0028 (0x0378 - 0x0350)
class ALPropLadderSpot : public ALPropSpot
{
public:
	class USceneComponent*                        DownStairInteract;                                 // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DownStairStart;                                    // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        UpStairInteract;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        UpStairStart;                                      // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxClimbCount;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FPropLadderInfoPtr GetPropLadderInfo(int32 FindState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropLadderSpot">();
	}
	static class ALPropLadderSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropLadderSpot>();
	}
};
static_assert(alignof(ALPropLadderSpot) == 0x000008, "Wrong alignment on ALPropLadderSpot");
static_assert(sizeof(ALPropLadderSpot) == 0x000378, "Wrong size on ALPropLadderSpot");
static_assert(offsetof(ALPropLadderSpot, DownStairInteract) == 0x000350, "Member 'ALPropLadderSpot::DownStairInteract' has a wrong offset!");
static_assert(offsetof(ALPropLadderSpot, DownStairStart) == 0x000358, "Member 'ALPropLadderSpot::DownStairStart' has a wrong offset!");
static_assert(offsetof(ALPropLadderSpot, UpStairInteract) == 0x000360, "Member 'ALPropLadderSpot::UpStairInteract' has a wrong offset!");
static_assert(offsetof(ALPropLadderSpot, UpStairStart) == 0x000368, "Member 'ALPropLadderSpot::UpStairStart' has a wrong offset!");
static_assert(offsetof(ALPropLadderSpot, MaxClimbCount) == 0x000370, "Member 'ALPropLadderSpot::MaxClimbCount' has a wrong offset!");

// Class ProjectP.LPropLiftSpot
// 0x00C8 (0x0418 - 0x0350)
class ALPropLiftSpot : public ALPropSpot
{
public:
	class USceneComponent*                        PointA_DoorComp;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PointB_DoorComp;                                   // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PointA_TriggerComp;                                // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PointB_TriggerComp;                                // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PointA_Position;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PointB_Position;                                   // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropLiftOverlapPawnComponent*         PointA_OverlapPawn;                                // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropLiftOverlapPawnComponent*         PointB_OverlapPawn;                                // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ElevatorSoundVolume_Name;                          // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceDefaultState;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALLiftObject>            ElevatorObject;                                    // 0x039C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALLiftObject>            PointA_DoorObject;                                 // 0x03A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALLiftObject>            PointB_DoorObject;                                 // 0x03AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALLiftObject>            PointA_TriggerObject;                              // 0x03B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALLiftObject>            PointB_TriggerObject;                              // 0x03BC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             MoveCurveData;                                     // 0x03C8(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseLiftMove;                                       // 0x03F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x27];                                     // 0x03F1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentBeginOverlapPropLiftOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentBeginOverlapSetLiftStartPoint(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlapPropLiftOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropLiftSpot">();
	}
	static class ALPropLiftSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropLiftSpot>();
	}
};
static_assert(alignof(ALPropLiftSpot) == 0x000008, "Wrong alignment on ALPropLiftSpot");
static_assert(sizeof(ALPropLiftSpot) == 0x000418, "Wrong size on ALPropLiftSpot");
static_assert(offsetof(ALPropLiftSpot, PointA_DoorComp) == 0x000350, "Member 'ALPropLiftSpot::PointA_DoorComp' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointB_DoorComp) == 0x000358, "Member 'ALPropLiftSpot::PointB_DoorComp' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointA_TriggerComp) == 0x000360, "Member 'ALPropLiftSpot::PointA_TriggerComp' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointB_TriggerComp) == 0x000368, "Member 'ALPropLiftSpot::PointB_TriggerComp' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointA_Position) == 0x000370, "Member 'ALPropLiftSpot::PointA_Position' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointB_Position) == 0x000378, "Member 'ALPropLiftSpot::PointB_Position' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointA_OverlapPawn) == 0x000380, "Member 'ALPropLiftSpot::PointA_OverlapPawn' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointB_OverlapPawn) == 0x000388, "Member 'ALPropLiftSpot::PointB_OverlapPawn' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, ElevatorSoundVolume_Name) == 0x000390, "Member 'ALPropLiftSpot::ElevatorSoundVolume_Name' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, ForceDefaultState) == 0x000398, "Member 'ALPropLiftSpot::ForceDefaultState' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, ElevatorObject) == 0x00039C, "Member 'ALPropLiftSpot::ElevatorObject' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointA_DoorObject) == 0x0003A4, "Member 'ALPropLiftSpot::PointA_DoorObject' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointB_DoorObject) == 0x0003AC, "Member 'ALPropLiftSpot::PointB_DoorObject' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointA_TriggerObject) == 0x0003B4, "Member 'ALPropLiftSpot::PointA_TriggerObject' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, PointB_TriggerObject) == 0x0003BC, "Member 'ALPropLiftSpot::PointB_TriggerObject' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, MoveCurveData) == 0x0003C8, "Member 'ALPropLiftSpot::MoveCurveData' has a wrong offset!");
static_assert(offsetof(ALPropLiftSpot, UseLiftMove) == 0x0003F0, "Member 'ALPropLiftSpot::UseLiftMove' has a wrong offset!");

// Class ProjectP.LPropVolumeComponent
// 0x0000 (0x0470 - 0x0470)
class ULPropVolumeComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropVolumeComponent">();
	}
	static class ULPropVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropVolumeComponent>();
	}
};
static_assert(alignof(ULPropVolumeComponent) == 0x000010, "Wrong alignment on ULPropVolumeComponent");
static_assert(sizeof(ULPropVolumeComponent) == 0x000470, "Wrong size on ULPropVolumeComponent");

// Class ProjectP.LPropNavigationComponent
// 0x0000 (0x0470 - 0x0470)
class ULPropNavigationComponent final : public UBoxComponent
{
public:
	void SetNavObstacleArea();
	void SetNavWalkableArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropNavigationComponent">();
	}
	static class ULPropNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropNavigationComponent>();
	}
};
static_assert(alignof(ULPropNavigationComponent) == 0x000010, "Wrong alignment on ULPropNavigationComponent");
static_assert(sizeof(ULPropNavigationComponent) == 0x000470, "Wrong size on ULPropNavigationComponent");

// Class ProjectP.LPropInteractCollisionComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULPropInteractCollisionComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropInteractCollisionComponent">();
	}
	static class ULPropInteractCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropInteractCollisionComponent>();
	}
};
static_assert(alignof(ULPropInteractCollisionComponent) == 0x000010, "Wrong alignment on ULPropInteractCollisionComponent");
static_assert(sizeof(ULPropInteractCollisionComponent) == 0x0001F0, "Wrong size on ULPropInteractCollisionComponent");

// Class ProjectP.LPropSoundLocationComponent
// 0x0000 (0x01F0 - 0x01F0)
class ULPropSoundLocationComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropSoundLocationComponent">();
	}
	static class ULPropSoundLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropSoundLocationComponent>();
	}
};
static_assert(alignof(ULPropSoundLocationComponent) == 0x000010, "Wrong alignment on ULPropSoundLocationComponent");
static_assert(sizeof(ULPropSoundLocationComponent) == 0x0001F0, "Wrong size on ULPropSoundLocationComponent");

// Class ProjectP.LPropMonologueComponent
// 0x0010 (0x00C0 - 0x00B0)
class ULPropMonologueComponent final : public UActorComponent
{
public:
	class FName                                   DialogCodeName;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlay2DSound;                                      // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropMonologueComponent">();
	}
	static class ULPropMonologueComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropMonologueComponent>();
	}
};
static_assert(alignof(ULPropMonologueComponent) == 0x000008, "Wrong alignment on ULPropMonologueComponent");
static_assert(sizeof(ULPropMonologueComponent) == 0x0000C0, "Wrong size on ULPropMonologueComponent");
static_assert(offsetof(ULPropMonologueComponent, DialogCodeName) == 0x0000B0, "Member 'ULPropMonologueComponent::DialogCodeName' has a wrong offset!");
static_assert(offsetof(ULPropMonologueComponent, bPlay2DSound) == 0x0000B8, "Member 'ULPropMonologueComponent::bPlay2DSound' has a wrong offset!");

// Class ProjectP.ChildActorComponentForProp
// 0x0000 (0x0220 - 0x0220)
class UChildActorComponentForProp final : public UChildActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChildActorComponentForProp">();
	}
	static class UChildActorComponentForProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChildActorComponentForProp>();
	}
};
static_assert(alignof(UChildActorComponentForProp) == 0x000010, "Wrong alignment on UChildActorComponentForProp");
static_assert(sizeof(UChildActorComponentForProp) == 0x000220, "Wrong size on UChildActorComponentForProp");

// Class ProjectP.LPropVolumeSpot
// 0x0048 (0x0398 - 0x0350)
class ALPropVolumeSpot : public ALPropSpot
{
public:
	uint8                                         bLocationNameDisplay : 1;                          // 0x0350(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ALSpot*                                 Lookat_Object;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lookat_Offset;                                     // 0x0360(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ALCharacter>>     OverlapCharacterList;                              // 0x0370(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALCharacter>>     AbnormalStateApplyList;                            // 0x0380(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle_AbnormalState_BuildUp;                 // 0x0390(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CheckAbnormalStateBuildUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropVolumeSpot">();
	}
	static class ALPropVolumeSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALPropVolumeSpot>();
	}
};
static_assert(alignof(ALPropVolumeSpot) == 0x000008, "Wrong alignment on ALPropVolumeSpot");
static_assert(sizeof(ALPropVolumeSpot) == 0x000398, "Wrong size on ALPropVolumeSpot");
static_assert(offsetof(ALPropVolumeSpot, Lookat_Object) == 0x000358, "Member 'ALPropVolumeSpot::Lookat_Object' has a wrong offset!");
static_assert(offsetof(ALPropVolumeSpot, Lookat_Offset) == 0x000360, "Member 'ALPropVolumeSpot::Lookat_Offset' has a wrong offset!");
static_assert(offsetof(ALPropVolumeSpot, OverlapCharacterList) == 0x000370, "Member 'ALPropVolumeSpot::OverlapCharacterList' has a wrong offset!");
static_assert(offsetof(ALPropVolumeSpot, AbnormalStateApplyList) == 0x000380, "Member 'ALPropVolumeSpot::AbnormalStateApplyList' has a wrong offset!");
static_assert(offsetof(ALPropVolumeSpot, TimerHandle_AbnormalState_BuildUp) == 0x000390, "Member 'ALPropVolumeSpot::TimerHandle_AbnormalState_BuildUp' has a wrong offset!");

// Class ProjectP.LQuartzEffect
// 0x0010 (0x0038 - 0x0028)
class ULQuartzEffect final : public UObject
{
public:
	struct FQuartzEffectInfoPtr                   Info;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstalled;                                        // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LQuartzEffect">();
	}
	static class ULQuartzEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULQuartzEffect>();
	}
};
static_assert(alignof(ULQuartzEffect) == 0x000008, "Wrong alignment on ULQuartzEffect");
static_assert(sizeof(ULQuartzEffect) == 0x000038, "Wrong size on ULQuartzEffect");
static_assert(offsetof(ULQuartzEffect, Info) == 0x000028, "Member 'ULQuartzEffect::Info' has a wrong offset!");
static_assert(offsetof(ULQuartzEffect, bUnlock) == 0x000030, "Member 'ULQuartzEffect::bUnlock' has a wrong offset!");
static_assert(offsetof(ULQuartzEffect, bInstalled) == 0x000031, "Member 'ULQuartzEffect::bInstalled' has a wrong offset!");

// Class ProjectP.LQuartzSystem
// 0x0088 (0x0100 - 0x0078)
class ULQuartzSystem final : public ULGameSubSystem
{
public:
	TMap<class FName, class ULQuartzPocket*>      QuartzPocketMap;                                   // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class ULQuartzEffect*>                 QuartzEffectList;                                  // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xC];                                       // 0x00D8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastInstalledPocketCodeName;                       // 0x00E4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnQuartzLevelUp;                                   // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	bool CheckCanResetAllQuartz(bool bIgnoreRequirements);
	class ULQuartzPocket* GetPocketData(class FName PocketCodeName);
	class ULQuartzPocket* GetPocketDataByIndex(int32 InPocketIndex);
	class ULQuartzEffect* GetQuartzEffect(class FName QuartzEffectCodeName);
	void GetRequireItemsForReset(TMap<class FName, int32>* OutRequireItems);
	void GetReturnItemsAfterReset(TMap<class FName, int32>* OutReturnItems);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);
	bool RequestResetAllQuartz(bool bIgnoreRequirements);
	bool RequestUpgradeCoreLevel();
	void ResetAllQuartz(bool bForceReset, bool bNewgamePlus);

	int32 GetCoreItemCount() const;
	int32 GetEnabledCoreLevel() const;
	bool GetEnabledQuartzMenu() const;
	int32 GetMaxLevelLimit() const;
	int32 GetQuartzItemCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LQuartzSystem">();
	}
	static class ULQuartzSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULQuartzSystem>();
	}
};
static_assert(alignof(ULQuartzSystem) == 0x000008, "Wrong alignment on ULQuartzSystem");
static_assert(sizeof(ULQuartzSystem) == 0x000100, "Wrong size on ULQuartzSystem");
static_assert(offsetof(ULQuartzSystem, QuartzPocketMap) == 0x000078, "Member 'ULQuartzSystem::QuartzPocketMap' has a wrong offset!");
static_assert(offsetof(ULQuartzSystem, QuartzEffectList) == 0x0000C8, "Member 'ULQuartzSystem::QuartzEffectList' has a wrong offset!");
static_assert(offsetof(ULQuartzSystem, LastInstalledPocketCodeName) == 0x0000E4, "Member 'ULQuartzSystem::LastInstalledPocketCodeName' has a wrong offset!");
static_assert(offsetof(ULQuartzSystem, OnQuartzLevelUp) == 0x0000F0, "Member 'ULQuartzSystem::OnQuartzLevelUp' has a wrong offset!");

// Class ProjectP.LQuestDebugInfo
// 0x0010 (0x0038 - 0x0028)
class ULQuestDebugInfo final : public UObject
{
public:
	class FString                                 QuestLog;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LQuestDebugInfo">();
	}
	static class ULQuestDebugInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULQuestDebugInfo>();
	}
};
static_assert(alignof(ULQuestDebugInfo) == 0x000008, "Wrong alignment on ULQuestDebugInfo");
static_assert(sizeof(ULQuestDebugInfo) == 0x000038, "Wrong size on ULQuestDebugInfo");
static_assert(offsetof(ULQuestDebugInfo, QuestLog) == 0x000028, "Member 'ULQuestDebugInfo::QuestLog' has a wrong offset!");

// Class ProjectP.LQuestSystem
// 0x0178 (0x01F0 - 0x0078)
class ULQuestSystem final : public ULGameSubSystem
{
public:
	TMap<class FName, struct FQuestDetailInfo>    QuestProgressMap;                                  // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FQuestDetailInfo>    QuestCompleteMap;                                  // 0x00C8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLQuestHierarchyInfo> QuestDB;                                           // 0x0118(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<ELCallBackEventType, struct FLAutoQuestInfoList> AutoAddQuestDB;                                    // 0x0168(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FLQuestTaskInfo>                QuestTaskInfoDB;                                   // 0x01B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLCallBackEventData>            DelayQuestEventList;                               // 0x01C8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnRefreshQuestDebugInfo;                           // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class ULQuestDebugInfo*                       QuestDebugInfo;                                    // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetQuestIconFromTeleportName(class FName FindTeleport, TArray<TSoftObjectPtr<class UObject>>* OutQuestIconList);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LQuestSystem">();
	}
	static class ULQuestSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULQuestSystem>();
	}
};
static_assert(alignof(ULQuestSystem) == 0x000008, "Wrong alignment on ULQuestSystem");
static_assert(sizeof(ULQuestSystem) == 0x0001F0, "Wrong size on ULQuestSystem");
static_assert(offsetof(ULQuestSystem, QuestProgressMap) == 0x000078, "Member 'ULQuestSystem::QuestProgressMap' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, QuestCompleteMap) == 0x0000C8, "Member 'ULQuestSystem::QuestCompleteMap' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, QuestDB) == 0x000118, "Member 'ULQuestSystem::QuestDB' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, AutoAddQuestDB) == 0x000168, "Member 'ULQuestSystem::AutoAddQuestDB' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, QuestTaskInfoDB) == 0x0001B8, "Member 'ULQuestSystem::QuestTaskInfoDB' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, DelayQuestEventList) == 0x0001C8, "Member 'ULQuestSystem::DelayQuestEventList' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, OnRefreshQuestDebugInfo) == 0x0001D8, "Member 'ULQuestSystem::OnRefreshQuestDebugInfo' has a wrong offset!");
static_assert(offsetof(ULQuestSystem, QuestDebugInfo) == 0x0001E8, "Member 'ULQuestSystem::QuestDebugInfo' has a wrong offset!");

// Class ProjectP.LRedButterFlySearchCollisionComponent
// 0x0000 (0x0460 - 0x0460)
class ULRedButterFlySearchCollisionComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LRedButterFlySearchCollisionComponent">();
	}
	static class ULRedButterFlySearchCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULRedButterFlySearchCollisionComponent>();
	}
};
static_assert(alignof(ULRedButterFlySearchCollisionComponent) == 0x000010, "Wrong alignment on ULRedButterFlySearchCollisionComponent");
static_assert(sizeof(ULRedButterFlySearchCollisionComponent) == 0x000460, "Wrong size on ULRedButterFlySearchCollisionComponent");

// Class ProjectP.LRedButterFlySearchBoxCollisionComponent
// 0x0000 (0x0470 - 0x0470)
class ULRedButterFlySearchBoxCollisionComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LRedButterFlySearchBoxCollisionComponent">();
	}
	static class ULRedButterFlySearchBoxCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULRedButterFlySearchBoxCollisionComponent>();
	}
};
static_assert(alignof(ULRedButterFlySearchBoxCollisionComponent) == 0x000010, "Wrong alignment on ULRedButterFlySearchBoxCollisionComponent");
static_assert(sizeof(ULRedButterFlySearchBoxCollisionComponent) == 0x000470, "Wrong size on ULRedButterFlySearchBoxCollisionComponent");

// Class ProjectP.RichImageRowFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URichImageRowFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* GetImage(const struct FRichImageRow& Row);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichImageRowFunctionLibrary">();
	}
	static class URichImageRowFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichImageRowFunctionLibrary>();
	}
};
static_assert(alignof(URichImageRowFunctionLibrary) == 0x000008, "Wrong alignment on URichImageRowFunctionLibrary");
static_assert(sizeof(URichImageRowFunctionLibrary) == 0x000028, "Wrong size on URichImageRowFunctionLibrary");

// Class ProjectP.LAccountSaveGame
// 0x0118 (0x0170 - 0x0058)
class ULAccountSaveGame final : public ULSaveGame
{
public:
	struct FLAccountData                          AccountData;                                       // 0x0058(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLAchievementSaveData                  AchievementSaveData;                               // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLCharacterStorageData>         CharacterStorageList;                              // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FLDLCSaveData_Account                  DLCSaveData_Account;                               // 0x00C0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           SequencePlayList;                                  // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FLPatchRewardSaveData_Account          PatchRewardSaveData_Account;                       // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LAccountSaveGame">();
	}
	static class ULAccountSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULAccountSaveGame>();
	}
};
static_assert(alignof(ULAccountSaveGame) == 0x000008, "Wrong alignment on ULAccountSaveGame");
static_assert(sizeof(ULAccountSaveGame) == 0x000170, "Wrong size on ULAccountSaveGame");
static_assert(offsetof(ULAccountSaveGame, AccountData) == 0x000058, "Member 'ULAccountSaveGame::AccountData' has a wrong offset!");
static_assert(offsetof(ULAccountSaveGame, AchievementSaveData) == 0x0000A0, "Member 'ULAccountSaveGame::AchievementSaveData' has a wrong offset!");
static_assert(offsetof(ULAccountSaveGame, CharacterStorageList) == 0x0000B0, "Member 'ULAccountSaveGame::CharacterStorageList' has a wrong offset!");
static_assert(offsetof(ULAccountSaveGame, DLCSaveData_Account) == 0x0000C0, "Member 'ULAccountSaveGame::DLCSaveData_Account' has a wrong offset!");
static_assert(offsetof(ULAccountSaveGame, SequencePlayList) == 0x000110, "Member 'ULAccountSaveGame::SequencePlayList' has a wrong offset!");
static_assert(offsetof(ULAccountSaveGame, PatchRewardSaveData_Account) == 0x000120, "Member 'ULAccountSaveGame::PatchRewardSaveData_Account' has a wrong offset!");

// Class ProjectP.LOptionSaveGame
// 0x00B8 (0x0110 - 0x0058)
class ULOptionSaveGame final : public ULSaveGame
{
public:
	struct FLOptionData                           OptionData;                                        // 0x0058(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LOptionSaveGame">();
	}
	static class ULOptionSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULOptionSaveGame>();
	}
};
static_assert(alignof(ULOptionSaveGame) == 0x000008, "Wrong alignment on ULOptionSaveGame");
static_assert(sizeof(ULOptionSaveGame) == 0x000110, "Wrong size on ULOptionSaveGame");
static_assert(offsetof(ULOptionSaveGame, OptionData) == 0x000058, "Member 'ULOptionSaveGame::OptionData' has a wrong offset!");

// Class ProjectP.LSaveGameSystem
// 0x00D8 (0x0150 - 0x0078)
class ULSaveGameSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0xB0];                                      // 0x0078(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugLog;                                         // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameSyncSave;                                    // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameSyncLoad;                                    // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void LoadGameDelegateFunction(const class FString& InSlotName, const int32 InUserIndex, class USaveGame* LoadedSave);
	void SaveGameDelegateFunction(const class FString& InSlotName, const int32 InUserIndex, bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSaveGameSystem">();
	}
	static class ULSaveGameSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSaveGameSystem>();
	}
};
static_assert(alignof(ULSaveGameSystem) == 0x000008, "Wrong alignment on ULSaveGameSystem");
static_assert(sizeof(ULSaveGameSystem) == 0x000150, "Wrong size on ULSaveGameSystem");
static_assert(offsetof(ULSaveGameSystem, bDebugLog) == 0x000128, "Member 'ULSaveGameSystem::bDebugLog' has a wrong offset!");
static_assert(offsetof(ULSaveGameSystem, OnGameSyncSave) == 0x000130, "Member 'ULSaveGameSystem::OnGameSyncSave' has a wrong offset!");
static_assert(offsetof(ULSaveGameSystem, OnGameSyncLoad) == 0x000140, "Member 'ULSaveGameSystem::OnGameSyncLoad' has a wrong offset!");

// Class ProjectP.LSlaveArmPage
// 0x0020 (0x0048 - 0x0028)
class ULSlaveArmPage final : public UObject
{
public:
	struct FSlaveArmPageInfoPtr                   Info;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCanReset();
	bool GetCanReset();
	TMap<class FName, int32> GetRequireItemsToReset();
	TMap<class FName, int32> GetReturnItemsAfterReset();
	bool IsFullyReinforced();
	bool RequestReset();
	void Reset(bool bForceReset);

	class ULSlaveArmTree* GetNextReinforceTree() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSlaveArmPage">();
	}
	static class ULSlaveArmPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSlaveArmPage>();
	}
};
static_assert(alignof(ULSlaveArmPage) == 0x000008, "Wrong alignment on ULSlaveArmPage");
static_assert(sizeof(ULSlaveArmPage) == 0x000048, "Wrong size on ULSlaveArmPage");
static_assert(offsetof(ULSlaveArmPage, Info) == 0x000028, "Member 'ULSlaveArmPage::Info' has a wrong offset!");
static_assert(offsetof(ULSlaveArmPage, bActivated) == 0x000030, "Member 'ULSlaveArmPage::bActivated' has a wrong offset!");

// Class ProjectP.LSlaveArmReinforcementSystem
// 0x00C8 (0x0140 - 0x0078)
class ULSlaveArmReinforcementSystem final : public ULGameSubSystem
{
public:
	TArray<class ULSlaveArmPage*>                 SlaveArmPageList;                                  // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class ULSlaveArmTree*>      SlaveArmTreeMap;                                   // 0x0088(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLSlaveArmInfoHolder> SlaveArmReinforceInfoMap;                          // 0x00D8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ActiveSlaveArmReinforceList;                       // 0x0128(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsLoadedSaveData;                                  // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckHaveEnoughMagazinePoint();
	void CheckPageActivated();
	class ULSlaveArmTree* FindTreeByCodeName(class FName SlaveArmTreeCodename);
	class ULSlaveArmTree* FindTreeByDepth(class FName SlaveArmItemCodename, int32 Depth);
	TArray<class ULSlaveArmTree*> FindTreeByPageCodeName(class FName SlaveArmPageCodename);
	float GetConsumeMagazinePointMultiplier(class FName SlaveArmCodeName);
	int32 GetIncreasedAmmo(class FName ItemSlaveArmCodeName);
	int32 GetReinforcedHitIndex(class FName SlaveArmItemCodename, int32 BaseHitIndex);
	class FName GetReinforcedProjectile(class FName SlaveArmItemCodename, class FName BaseProjectileID);
	TArray<struct FSlaveArmReinforcementInfoPtr> GetReinforcementInfoList(class FName SlavearmReinforcementInfoname);
	class ULSlaveArmPage* GetSlaveArmPage(class FName SlaveArmPageCodename);
	class ULSlaveArmPage* GetSlaveArmPageBySlaveArmCodeName(class FName SlaveArmItemCodename);
	TArray<class ULSlaveArmPage*> GetSlaveArmPageList();
	class FName GetSlaveArmSkillCodeName(class FName SlaveArmItemCodename);
	int32 GetSlaveArmStat(class FName ItemSlaveArmCodeName, ELSecondStat InStat);
	TArray<class ULSlaveArmTree*> GetSlaveArmTreeListByPageCodeName(class FName SlaveArmPageCodename);
	TArray<class ULSlaveArmTree*> GetSlaveArmTreeListBySlaveArmCodeName(class FName SlaveArmItemCodename);
	bool HasReinforcement(class FName SlaveArmReinfocementCodeName);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);
	void OnOpenUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSlaveArmReinforcementSystem">();
	}
	static class ULSlaveArmReinforcementSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSlaveArmReinforcementSystem>();
	}
};
static_assert(alignof(ULSlaveArmReinforcementSystem) == 0x000008, "Wrong alignment on ULSlaveArmReinforcementSystem");
static_assert(sizeof(ULSlaveArmReinforcementSystem) == 0x000140, "Wrong size on ULSlaveArmReinforcementSystem");
static_assert(offsetof(ULSlaveArmReinforcementSystem, SlaveArmPageList) == 0x000078, "Member 'ULSlaveArmReinforcementSystem::SlaveArmPageList' has a wrong offset!");
static_assert(offsetof(ULSlaveArmReinforcementSystem, SlaveArmTreeMap) == 0x000088, "Member 'ULSlaveArmReinforcementSystem::SlaveArmTreeMap' has a wrong offset!");
static_assert(offsetof(ULSlaveArmReinforcementSystem, SlaveArmReinforceInfoMap) == 0x0000D8, "Member 'ULSlaveArmReinforcementSystem::SlaveArmReinforceInfoMap' has a wrong offset!");
static_assert(offsetof(ULSlaveArmReinforcementSystem, ActiveSlaveArmReinforceList) == 0x000128, "Member 'ULSlaveArmReinforcementSystem::ActiveSlaveArmReinforceList' has a wrong offset!");
static_assert(offsetof(ULSlaveArmReinforcementSystem, IsLoadedSaveData) == 0x000138, "Member 'ULSlaveArmReinforcementSystem::IsLoadedSaveData' has a wrong offset!");

// Class ProjectP.LSoulDropObject
// 0x0000 (0x0260 - 0x0260)
class ALSoulDropObject : public ALLevelObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSoulDropObject">();
	}
	static class ALSoulDropObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSoulDropObject>();
	}
};
static_assert(alignof(ALSoulDropObject) == 0x000008, "Wrong alignment on ALSoulDropObject");
static_assert(sizeof(ALSoulDropObject) == 0x000260, "Wrong size on ALSoulDropObject");

// Class ProjectP.LSoundSystemData
// 0x0008 (0x01E8 - 0x01E0)
class ALSoundSystemData : public AActor
{
public:
	float                                         SwishMultiplier;                                   // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USoundMix* GetBaseSoundMix();
	void GetGlobalMuteSoundMixes(TArray<class USoundMix*>* MuteMixes);
	float GetSoundVolumeFadeTime();
	void OnCompletePlayDialogSound();
	void OnFadeMuteSound(bool bMute);
	void OnPlayBGM(class FName SoundName, bool* PlayResult);
	bool OnPlayDialogSound(const struct FDialogInfoPtr& InDialog);
	bool OnPlayRecord(class FName RecordCodeName, class ALPropSpot* InSoundSource);
	void OnPreCompletePlayDialogSound();
	void OnStopBGM();
	bool OnStopDialogSound(bool SkipFadeOut);
	bool OnStopRecord();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSoundSystemData">();
	}
	static class ALSoundSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSoundSystemData>();
	}
};
static_assert(alignof(ALSoundSystemData) == 0x000008, "Wrong alignment on ALSoundSystemData");
static_assert(sizeof(ALSoundSystemData) == 0x0001E8, "Wrong size on ALSoundSystemData");
static_assert(offsetof(ALSoundSystemData, SwishMultiplier) == 0x0001E0, "Member 'ALSoundSystemData::SwishMultiplier' has a wrong offset!");

// Class ProjectP.LSoundSystem
// 0x0190 (0x0208 - 0x0078)
class ULSoundSystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayBGM;                                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRecordPlayback;                                  // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayRecord;                                      // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FName                                   PlayingRecordCodename;                             // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Pending_NextPlayRecordCodeName;                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayingRecordSpotUniqueId;                         // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastReached_RecordSpotUniqueId;                    // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PlayingDialogActor;                                // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayingDialogSound;                              // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayingMonologueSound;                           // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShortRecordBGM;                                // 0x00E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x55];                                      // 0x00E3(0x0055)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundMix*>                      MuteSoundMixes;                                    // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALSoundSystemData*                      SystemData;                                        // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x10];                                     // 0x0158(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundMix*>                      SoundMixSequenceList;                              // 0x0168(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UAudioComponent>> Sound2DSequenceList;                               // 0x0178(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   PlayBGMCodeName;                                   // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Cache_NpcBGMCodeName;                              // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           BGM_ActiveNpcList;                                 // 0x0198(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         FadeOutTimeFromSequence;                           // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ULSoundControlComponent>> SoundControlComponentList_to_Refresh;              // 0x01B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNpcDeadDelegate;                                 // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBossRoomDestroyedDelegate;                       // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAsyncLoadingMap;                                 // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMuteOffOnLoadingScreenOffEvent;                  // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	bool AcquireHumanityRecord(class FName RecordCodeName);
	void AddSoundControlComponentToRefresh(class ULSoundControlComponent* Comp);
	void CheckPlayBGM_FromNpc(const class FName& NpcName, const class FName& SoundName, bool bShowSoundNameUI);
	void CheckStopBGM(const class FName& SoundName);
	void CheckStopBGM_FromNpc(const class FName& NpcName, const class FName& SoundName);
	void ClearSoundControlComponentsToRefresh();
	void ClearSoundMix(class USoundMix* SoundMix);
	void DoCompletePlayDialogSound();
	bool DoNextPlayRecord();
	bool DoPlayBGM(const class FName& SoundName, bool bShowSoundNameUI);
	bool DoPlayDialogSound(const struct FDialogInfoPtr& InDialog);
	bool DoPlayRecord(class FName RecordCodeName);
	bool DoPrevPlayRecord();
	void DoStopBGM();
	bool DoStopDialogSound(bool SkipFadeOut);
	bool DoStopRecord();
	void FadeMuteSound(bool bMute);
	class FName FindPlayableRecordFromPlayingNow(bool FindNext);
	const TArray<struct FItemCommonInfo> GetAllRecordList();
	float GetClassVolume(class USoundClass* TargetSoundClass);
	class USoundCue* GetDialogSound(class FName RowName, bool* OutUseSoundMix);
	float GetMultifliedVolume(ELVolumeType FindType);
	class USoundCue* GetRecordCue(class FName RecordCodeName);
	float GetRecordCurrentDuration(const class USoundWave* PlayingSoundWave, const float PlaybackPercent);
	float GetRecordDuration(class FName RecordCodeName);
	float GetSwishMultiplier();
	float GetVolume(ELVolumeType FindType);
	bool IsPlayableUISound();
	bool IsPlayingBGM();
	bool IsPushedSoundMix(class USoundMix* SoundMix);
	void MuteAllSound(bool bMute, bool bFade);
	void MuteSound(bool bMute);
	void MuteUISound(bool Mute);
	void OnExecuteTeleport();
	void OnRecordPlaybackPercent(const class USoundWave* PlayingSoundWave, const float PlaybackPercent);
	void PlaySound2DFromSequence(class USoundBase* Sound);
	void PopSoundMixFromSequence(class USoundMix* SoundMix);
	void PushSoundMix_MustFadeIn(class USoundMix* SoundMix);
	void PushSoundMixFromSequence(class USoundMix* SoundMix);
	void RefreshRecordState();
	void SetPendingNextPlayRecord(class FName RecordCodeName);
	bool SetVolume(ELVolumeType FindType, float InVolume);

	float GetAudioVolumeConcurrency(const class UAudioComponent* InAudioComp) const;
	bool GetIsAsncLoadingMapCompleted() const;
	bool IsNotiRecord(class FName RecordCodeName) const;
	bool IsRecord_CanAquireHumanity(class FName RecordCodeName) const;
	bool IsRecordHavingHumanity(class FName RecordCodeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSoundSystem">();
	}
	static class ULSoundSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSoundSystem>();
	}
};
static_assert(alignof(ULSoundSystem) == 0x000008, "Wrong alignment on ULSoundSystem");
static_assert(sizeof(ULSoundSystem) == 0x000208, "Wrong size on ULSoundSystem");
static_assert(offsetof(ULSoundSystem, OnPlayBGM) == 0x000078, "Member 'ULSoundSystem::OnPlayBGM' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, OnRecordPlayback) == 0x000088, "Member 'ULSoundSystem::OnRecordPlayback' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, OnPlayRecord) == 0x000098, "Member 'ULSoundSystem::OnPlayRecord' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, PlayingRecordCodename) == 0x0000A8, "Member 'ULSoundSystem::PlayingRecordCodename' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, Pending_NextPlayRecordCodeName) == 0x0000B0, "Member 'ULSoundSystem::Pending_NextPlayRecordCodeName' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, PlayingRecordSpotUniqueId) == 0x0000B8, "Member 'ULSoundSystem::PlayingRecordSpotUniqueId' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, LastReached_RecordSpotUniqueId) == 0x0000C8, "Member 'ULSoundSystem::LastReached_RecordSpotUniqueId' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, PlayingDialogActor) == 0x0000D8, "Member 'ULSoundSystem::PlayingDialogActor' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, IsPlayingDialogSound) == 0x0000E0, "Member 'ULSoundSystem::IsPlayingDialogSound' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, IsPlayingMonologueSound) == 0x0000E1, "Member 'ULSoundSystem::IsPlayingMonologueSound' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, bUseShortRecordBGM) == 0x0000E2, "Member 'ULSoundSystem::bUseShortRecordBGM' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, MuteSoundMixes) == 0x000138, "Member 'ULSoundSystem::MuteSoundMixes' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, SystemData) == 0x000150, "Member 'ULSoundSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, SoundMixSequenceList) == 0x000168, "Member 'ULSoundSystem::SoundMixSequenceList' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, Sound2DSequenceList) == 0x000178, "Member 'ULSoundSystem::Sound2DSequenceList' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, PlayBGMCodeName) == 0x000188, "Member 'ULSoundSystem::PlayBGMCodeName' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, Cache_NpcBGMCodeName) == 0x000190, "Member 'ULSoundSystem::Cache_NpcBGMCodeName' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, BGM_ActiveNpcList) == 0x000198, "Member 'ULSoundSystem::BGM_ActiveNpcList' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, FadeOutTimeFromSequence) == 0x0001A8, "Member 'ULSoundSystem::FadeOutTimeFromSequence' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, SoundControlComponentList_to_Refresh) == 0x0001B0, "Member 'ULSoundSystem::SoundControlComponentList_to_Refresh' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, OnNpcDeadDelegate) == 0x0001C0, "Member 'ULSoundSystem::OnNpcDeadDelegate' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, OnBossRoomDestroyedDelegate) == 0x0001D0, "Member 'ULSoundSystem::OnBossRoomDestroyedDelegate' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, OnAsyncLoadingMap) == 0x0001E8, "Member 'ULSoundSystem::OnAsyncLoadingMap' has a wrong offset!");
static_assert(offsetof(ULSoundSystem, OnMuteOffOnLoadingScreenOffEvent) == 0x0001F8, "Member 'ULSoundSystem::OnMuteOffOnLoadingScreenOffEvent' has a wrong offset!");

// Class ProjectP.LSoundVolume
// 0x0010 (0x0248 - 0x0238)
class ALSoundVolume final : public ALVolume
{
public:
	ELSoundVolumeType                             SoundVolumeType;                                   // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SoundName;                                         // 0x023C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSoundVolume">();
	}
	static class ALSoundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSoundVolume>();
	}
};
static_assert(alignof(ALSoundVolume) == 0x000008, "Wrong alignment on ALSoundVolume");
static_assert(sizeof(ALSoundVolume) == 0x000248, "Wrong size on ALSoundVolume");
static_assert(offsetof(ALSoundVolume, SoundVolumeType) == 0x000238, "Member 'ALSoundVolume::SoundVolumeType' has a wrong offset!");
static_assert(offsetof(ALSoundVolume, SoundName) == 0x00023C, "Member 'ALSoundVolume::SoundName' has a wrong offset!");

// Class ProjectP.LSpecialBuff_ActionState
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_ActionState final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_ActionState">();
	}
	static class ULSpecialBuff_ActionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_ActionState>();
	}
};
static_assert(alignof(ULSpecialBuff_ActionState) == 0x000008, "Wrong alignment on ULSpecialBuff_ActionState");
static_assert(sizeof(ULSpecialBuff_ActionState) == 0x000048, "Wrong size on ULSpecialBuff_ActionState");

// Class ProjectP.LSpecialBuff_Abnormal
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_Abnormal final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal">();
	}
	static class ULSpecialBuff_Abnormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal");
static_assert(sizeof(ULSpecialBuff_Abnormal) == 0x000048, "Wrong size on ULSpecialBuff_Abnormal");

// Class ProjectP.LSpecialBuff_Abnormal_By_HP
// 0x0008 (0x0050 - 0x0048)
class ULSpecialBuff_Abnormal_By_HP final : public ULSpecialBuff
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateHP(int32 CurrentHP, int32 MaxHP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_By_HP">();
	}
	static class ULSpecialBuff_Abnormal_By_HP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_By_HP>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_By_HP) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_By_HP");
static_assert(sizeof(ULSpecialBuff_Abnormal_By_HP) == 0x000050, "Wrong size on ULSpecialBuff_Abnormal_By_HP");

// Class ProjectP.LSpecialBuff_Abnormal_By_WeaponChange
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_Abnormal_By_WeaponChange final : public ULSpecialBuff
{
public:
	void ApplyAbnormal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_By_WeaponChange">();
	}
	static class ULSpecialBuff_Abnormal_By_WeaponChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_By_WeaponChange>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_By_WeaponChange) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_By_WeaponChange");
static_assert(sizeof(ULSpecialBuff_Abnormal_By_WeaponChange) == 0x000048, "Wrong size on ULSpecialBuff_Abnormal_By_WeaponChange");

// Class ProjectP.LSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack final : public ULSpecialBuff
{
public:
	void ApplyAbnormal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack">();
	}
	static class ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack");
static_assert(sizeof(ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack) == 0x000048, "Wrong size on ULSpecialBuff_Abnormal_On_PerfectGuardSuccessOnFuryAttack");

// Class ProjectP.LSpecialBuff_Resurrection
// 0x0008 (0x0050 - 0x0048)
class ULSpecialBuff_Resurrection final : public ULSpecialBuff
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateHP(int32 CurrentHP, int32 MaxHP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Resurrection">();
	}
	static class ULSpecialBuff_Resurrection* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Resurrection>();
	}
};
static_assert(alignof(ULSpecialBuff_Resurrection) == 0x000008, "Wrong alignment on ULSpecialBuff_Resurrection");
static_assert(sizeof(ULSpecialBuff_Resurrection) == 0x000050, "Wrong size on ULSpecialBuff_Resurrection");

// Class ProjectP.LSpecialBuff_Abnormal_On_PulseRechargeState
// 0x0008 (0x0050 - 0x0048)
class ULSpecialBuff_Abnormal_On_PulseRechargeState final : public ULSpecialBuff
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnterActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair);
	void OnLeaveActionState(class ULActMgrComponent* ActMgrComponent, class FName ActionState, bool IsPair);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_On_PulseRechargeState">();
	}
	static class ULSpecialBuff_Abnormal_On_PulseRechargeState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_On_PulseRechargeState>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_On_PulseRechargeState) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_On_PulseRechargeState");
static_assert(sizeof(ULSpecialBuff_Abnormal_On_PulseRechargeState) == 0x000050, "Wrong size on ULSpecialBuff_Abnormal_On_PulseRechargeState");

// Class ProjectP.LSpecialBuff_Abnormal_On_Debuff
// 0x0008 (0x0050 - 0x0048)
class ULSpecialBuff_Abnormal_On_Debuff final : public ULSpecialBuff
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyRunningAbnormal(bool IsApply, class FName AbnormalCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_On_Debuff">();
	}
	static class ULSpecialBuff_Abnormal_On_Debuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_On_Debuff>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_On_Debuff) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_On_Debuff");
static_assert(sizeof(ULSpecialBuff_Abnormal_On_Debuff) == 0x000050, "Wrong size on ULSpecialBuff_Abnormal_On_Debuff");

// Class ProjectP.LSpecialBuff_AbnormalGroupDurationAdd
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_AbnormalGroupDurationAdd final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_AbnormalGroupDurationAdd">();
	}
	static class ULSpecialBuff_AbnormalGroupDurationAdd* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_AbnormalGroupDurationAdd>();
	}
};
static_assert(alignof(ULSpecialBuff_AbnormalGroupDurationAdd) == 0x000008, "Wrong alignment on ULSpecialBuff_AbnormalGroupDurationAdd");
static_assert(sizeof(ULSpecialBuff_AbnormalGroupDurationAdd) == 0x000048, "Wrong size on ULSpecialBuff_AbnormalGroupDurationAdd");

// Class ProjectP.LSpecialBuff_Abnormal_By_Pulse_ExhastedCount
// 0x0008 (0x0050 - 0x0048)
class ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount final : public ULSpecialBuff
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAbnormal(int32 ExhastedCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Abnormal_By_Pulse_ExhastedCount">();
	}
	static class ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount>();
	}
};
static_assert(alignof(ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount) == 0x000008, "Wrong alignment on ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount");
static_assert(sizeof(ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount) == 0x000050, "Wrong size on ULSpecialBuff_Abnormal_By_Pulse_ExhastedCount");

// Class ProjectP.LSpecialBuff_GoldenTree_Time_Sub
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_GoldenTree_Time_Sub final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_GoldenTree_Time_Sub">();
	}
	static class ULSpecialBuff_GoldenTree_Time_Sub* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_GoldenTree_Time_Sub>();
	}
};
static_assert(alignof(ULSpecialBuff_GoldenTree_Time_Sub) == 0x000008, "Wrong alignment on ULSpecialBuff_GoldenTree_Time_Sub");
static_assert(sizeof(ULSpecialBuff_GoldenTree_Time_Sub) == 0x000048, "Wrong size on ULSpecialBuff_GoldenTree_Time_Sub");

// Class ProjectP.LSpecialBuff_SlaveMagazine_Consume_MulAdd
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_SlaveMagazine_Consume_MulAdd final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_SlaveMagazine_Consume_MulAdd">();
	}
	static class ULSpecialBuff_SlaveMagazine_Consume_MulAdd* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_SlaveMagazine_Consume_MulAdd>();
	}
};
static_assert(alignof(ULSpecialBuff_SlaveMagazine_Consume_MulAdd) == 0x000008, "Wrong alignment on ULSpecialBuff_SlaveMagazine_Consume_MulAdd");
static_assert(sizeof(ULSpecialBuff_SlaveMagazine_Consume_MulAdd) == 0x000048, "Wrong size on ULSpecialBuff_SlaveMagazine_Consume_MulAdd");

// Class ProjectP.LSpecialBuff_Sharpness_Recover_OffHand
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_Sharpness_Recover_OffHand final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Sharpness_Recover_OffHand">();
	}
	static class ULSpecialBuff_Sharpness_Recover_OffHand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Sharpness_Recover_OffHand>();
	}
};
static_assert(alignof(ULSpecialBuff_Sharpness_Recover_OffHand) == 0x000008, "Wrong alignment on ULSpecialBuff_Sharpness_Recover_OffHand");
static_assert(sizeof(ULSpecialBuff_Sharpness_Recover_OffHand) == 0x000048, "Wrong size on ULSpecialBuff_Sharpness_Recover_OffHand");

// Class ProjectP.LSpecialBuff_Item_Rechargeable_Max_Stack_Add
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_Item_Rechargeable_Max_Stack_Add final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_Item_Rechargeable_Max_Stack_Add">();
	}
	static class ULSpecialBuff_Item_Rechargeable_Max_Stack_Add* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_Item_Rechargeable_Max_Stack_Add>();
	}
};
static_assert(alignof(ULSpecialBuff_Item_Rechargeable_Max_Stack_Add) == 0x000008, "Wrong alignment on ULSpecialBuff_Item_Rechargeable_Max_Stack_Add");
static_assert(sizeof(ULSpecialBuff_Item_Rechargeable_Max_Stack_Add) == 0x000048, "Wrong size on ULSpecialBuff_Item_Rechargeable_Max_Stack_Add");

// Class ProjectP.LSpecialBuff_UpgradeSlaveArmCorrectionCode
// 0x0000 (0x0048 - 0x0048)
class ULSpecialBuff_UpgradeSlaveArmCorrectionCode final : public ULSpecialBuff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuff_UpgradeSlaveArmCorrectionCode">();
	}
	static class ULSpecialBuff_UpgradeSlaveArmCorrectionCode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuff_UpgradeSlaveArmCorrectionCode>();
	}
};
static_assert(alignof(ULSpecialBuff_UpgradeSlaveArmCorrectionCode) == 0x000008, "Wrong alignment on ULSpecialBuff_UpgradeSlaveArmCorrectionCode");
static_assert(sizeof(ULSpecialBuff_UpgradeSlaveArmCorrectionCode) == 0x000048, "Wrong size on ULSpecialBuff_UpgradeSlaveArmCorrectionCode");

// Class ProjectP.LSpecialBuffSystem
// 0x0150 (0x01C8 - 0x0078)
class ULSpecialBuffSystem final : public ULGameSubSystem
{
public:
	TMap<ELSpecialBuffType, struct FLSpecialBuffContainer> BuffMap;                                           // 0x0078(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULSpecialBuff*>                  ReservedSpecialBuffList;                           // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0xE8];                                      // 0x00E0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBuff(class FName SpecialBuffCodeName, class FName Reason);
	bool CheckHaveBuff(ELSpecialBuffType Type);
	bool GetAppliedBuff(ELSpecialBuffType Type, TArray<class ULSpecialBuff*>* OutBuffInfoList);
	bool GetAppliedBuffAll(TArray<class ULSpecialBuff*>* OutBuffInfoList);
	int32 GetAppliedBuffTotalAmount(ELSpecialBuffType Type);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);
	void OnHumanityChangesSpecialBuff(const struct FHumanizationBuffAlterInfoPtr& BuffAlterInfo);
	void OnPerfectGuardSuccessOnFuryAttack();
	void OnStatChanged(ELSecondStat StatType, int32 AddedValue, int32 PrevStatValue);
	void RemoveBuff(class FName SpecialBuffCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpecialBuffSystem">();
	}
	static class ULSpecialBuffSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpecialBuffSystem>();
	}
};
static_assert(alignof(ULSpecialBuffSystem) == 0x000008, "Wrong alignment on ULSpecialBuffSystem");
static_assert(sizeof(ULSpecialBuffSystem) == 0x0001C8, "Wrong size on ULSpecialBuffSystem");
static_assert(offsetof(ULSpecialBuffSystem, BuffMap) == 0x000078, "Member 'ULSpecialBuffSystem::BuffMap' has a wrong offset!");
static_assert(offsetof(ULSpecialBuffSystem, ReservedSpecialBuffList) == 0x0000D0, "Member 'ULSpecialBuffSystem::ReservedSpecialBuffList' has a wrong offset!");

// Class ProjectP.CapsuleComponentForGuide
// 0x0000 (0x0460 - 0x0460)
class UCapsuleComponentForGuide final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsuleComponentForGuide">();
	}
	static class UCapsuleComponentForGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsuleComponentForGuide>();
	}
};
static_assert(alignof(UCapsuleComponentForGuide) == 0x000010, "Wrong alignment on UCapsuleComponentForGuide");
static_assert(sizeof(UCapsuleComponentForGuide) == 0x000460, "Wrong size on UCapsuleComponentForGuide");

// Class ProjectP.LMultiTriggerBase
// 0x0000 (0x01E0 - 0x01E0)
class ALMultiTriggerBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LMultiTriggerBase">();
	}
	static class ALMultiTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALMultiTriggerBase>();
	}
};
static_assert(alignof(ALMultiTriggerBase) == 0x000008, "Wrong alignment on ALMultiTriggerBase");
static_assert(sizeof(ALMultiTriggerBase) == 0x0001E0, "Wrong size on ALMultiTriggerBase");

// Class ProjectP.LSpotVolume
// 0x0010 (0x01F0 - 0x01E0)
class ALSpotVolume final : public ALMultiTriggerBase
{
public:
	TArray<class ALSpot*>                         Spots;                                             // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpotVolume">();
	}
	static class ALSpotVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALSpotVolume>();
	}
};
static_assert(alignof(ALSpotVolume) == 0x000008, "Wrong alignment on ALSpotVolume");
static_assert(sizeof(ALSpotVolume) == 0x0001F0, "Wrong size on ALSpotVolume");
static_assert(offsetof(ALSpotVolume, Spots) == 0x0001E0, "Member 'ALSpotVolume::Spots' has a wrong offset!");

// Class ProjectP.LLevelInactiveVolume
// 0x0010 (0x01F0 - 0x01E0)
class ALLevelInactiveVolume final : public ALMultiTriggerBase
{
public:
	TArray<class AActor*>                         LevelActors;                                       // 0x01E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLevelInactiveVolume">();
	}
	static class ALLevelInactiveVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALLevelInactiveVolume>();
	}
};
static_assert(alignof(ALLevelInactiveVolume) == 0x000008, "Wrong alignment on ALLevelInactiveVolume");
static_assert(sizeof(ALLevelInactiveVolume) == 0x0001F0, "Wrong size on ALLevelInactiveVolume");
static_assert(offsetof(ALLevelInactiveVolume, LevelActors) == 0x0001E0, "Member 'ALLevelInactiveVolume::LevelActors' has a wrong offset!");

// Class ProjectP.LSpringArmComponent
// 0x0030 (0x02A0 - 0x0270)
class ULSpringArmComponent final : public USpringArmComponent
{
public:
	bool                                          bRotationPause;                                    // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotationLinearInterpolate;                        // 0x0271(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_272[0x2E];                                     // 0x0272(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LSpringArmComponent">();
	}
	static class ULSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULSpringArmComponent>();
	}
};
static_assert(alignof(ULSpringArmComponent) == 0x000010, "Wrong alignment on ULSpringArmComponent");
static_assert(sizeof(ULSpringArmComponent) == 0x0002A0, "Wrong size on ULSpringArmComponent");
static_assert(offsetof(ULSpringArmComponent, bRotationPause) == 0x000270, "Member 'ULSpringArmComponent::bRotationPause' has a wrong offset!");
static_assert(offsetof(ULSpringArmComponent, bRotationLinearInterpolate) == 0x000271, "Member 'ULSpringArmComponent::bRotationLinearInterpolate' has a wrong offset!");

// Class ProjectP.LStatList
// 0x0040 (0x0068 - 0x0028)
class ULStatList final : public UObject
{
public:
	TArray<struct FLStatData>                     StatList;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLStatSimpleData>               BuffList;                                          // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLStatSimpleData>               EquipList;                                         // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLStatSimpleData>               MaxStatMultiflierList;                             // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LStatList">();
	}
	static class ULStatList* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULStatList>();
	}
};
static_assert(alignof(ULStatList) == 0x000008, "Wrong alignment on ULStatList");
static_assert(sizeof(ULStatList) == 0x000068, "Wrong size on ULStatList");
static_assert(offsetof(ULStatList, StatList) == 0x000028, "Member 'ULStatList::StatList' has a wrong offset!");
static_assert(offsetof(ULStatList, BuffList) == 0x000038, "Member 'ULStatList::BuffList' has a wrong offset!");
static_assert(offsetof(ULStatList, EquipList) == 0x000048, "Member 'ULStatList::EquipList' has a wrong offset!");
static_assert(offsetof(ULStatList, MaxStatMultiflierList) == 0x000058, "Member 'ULStatList::MaxStatMultiflierList' has a wrong offset!");

// Class ProjectP.LStatComponent
// 0x00D8 (0x0188 - 0x00B0)
class ULStatComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ALCharacter>             OwnerCharacter;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGuardStatOverride                    GuardStatOverride;                                 // 0x00B8(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULStatList*                             StatDataList;                                      // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLStatSimpleData>               RetainAcquireStatList;                             // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLStatGaugeContext>             StatGaugeList;                                     // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Delegate_StatChanged;                              // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Delegate_InitStatChanged;                          // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x58];                                     // 0x0128(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlockCalculate;                                   // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndStaminaRestore(class UObject* Instigator);
	int32 GetCharacterRawStat(ELSecondStat StatType);
	int32 GetCharacterStat(ELSecondStat StatType);
	int32 GetStat(ELStatDataType DataType, ELSecondStat StatType);
	int32 GetStatByPercent(ELSecondStat StatType, float CalcRatio);
	void GetStatInfo(ELSecondStat StatType, int32* Current, int32* Max, float* Ratio);
	float GetStatPercent(ELSecondStat StatType);
	bool RecoveryMaxStat(ELSecondStat StatType);
	bool RecoveryStat(ELSecondStat StatType, int32 Amount);
	void StartStaminaRestore(float Ratio, class UObject* Instigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LStatComponent">();
	}
	static class ULStatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULStatComponent>();
	}
};
static_assert(alignof(ULStatComponent) == 0x000008, "Wrong alignment on ULStatComponent");
static_assert(sizeof(ULStatComponent) == 0x000188, "Wrong size on ULStatComponent");
static_assert(offsetof(ULStatComponent, OwnerCharacter) == 0x0000B0, "Member 'ULStatComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(ULStatComponent, GuardStatOverride) == 0x0000B8, "Member 'ULStatComponent::GuardStatOverride' has a wrong offset!");
static_assert(offsetof(ULStatComponent, StatDataList) == 0x0000E0, "Member 'ULStatComponent::StatDataList' has a wrong offset!");
static_assert(offsetof(ULStatComponent, RetainAcquireStatList) == 0x0000E8, "Member 'ULStatComponent::RetainAcquireStatList' has a wrong offset!");
static_assert(offsetof(ULStatComponent, StatGaugeList) == 0x0000F8, "Member 'ULStatComponent::StatGaugeList' has a wrong offset!");
static_assert(offsetof(ULStatComponent, Delegate_StatChanged) == 0x000108, "Member 'ULStatComponent::Delegate_StatChanged' has a wrong offset!");
static_assert(offsetof(ULStatComponent, Delegate_InitStatChanged) == 0x000118, "Member 'ULStatComponent::Delegate_InitStatChanged' has a wrong offset!");
static_assert(offsetof(ULStatComponent, bBlockCalculate) == 0x000180, "Member 'ULStatComponent::bBlockCalculate' has a wrong offset!");

// Class ProjectP.LStatRoomPCCharacter
// 0x0040 (0x0CE0 - 0x0CA0)
class ALStatRoomPCCharacter : public ALCharacter
{
public:
	uint8                                         bEnableStatRoomEnterExitOptimize : 1;              // 0x0CA0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CA1[0x7];                                      // 0x0CA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULStatComponent*                        GrowingUpStatComponent;                            // 0x0CA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLFirstStatData>                SimulateFirstStatDataList;                         // 0x0CB0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLFirstStatSimpleData>          WillRaiseFirstStatCounts;                          // 0x0CC0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD0[0x10];                                     // 0x0CD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachPCLamp();
	bool CheckCanChangeFirstStat(ELFirstStat FirstStat, int32 ChangeData, int32* OutErrorCode);
	void GetDiffStat_ByFirstStat(TArray<struct FLSecondStatDiffData>* Common_SecondStatDiff, TArray<struct FLSecondStatDiffData>* Weapon1_SecondStatDiff, TArray<struct FLSecondStatDiffData>* Weapon2_SecondStatDiff, TArray<struct FLSecondStatDiffData>* Weapon3_SecondStatDiff, TArray<struct FLSecondStatDiffData>* SlaveArm1_SecondStatDiff, TArray<struct FLSecondStatDiffData>* SlaveArm2_SecondStatDiff, TArray<struct FLSecondStatDiffData>* SlaveArm3_SecondStatDiff);
	void OnActiveMesh(bool Active);
	void OnSetActiveEnvironment(bool Active);
	void UIChangeFirstStat(ELFirstStat FirstStat, int32 ChangeData);
	void UIConfirmCharacterStat();

	int32 GetFirstStat(ELFirstStatDataType DataType, ELFirstStat StatType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LStatRoomPCCharacter">();
	}
	static class ALStatRoomPCCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALStatRoomPCCharacter>();
	}
};
static_assert(alignof(ALStatRoomPCCharacter) == 0x000010, "Wrong alignment on ALStatRoomPCCharacter");
static_assert(sizeof(ALStatRoomPCCharacter) == 0x000CE0, "Wrong size on ALStatRoomPCCharacter");
static_assert(offsetof(ALStatRoomPCCharacter, GrowingUpStatComponent) == 0x000CA8, "Member 'ALStatRoomPCCharacter::GrowingUpStatComponent' has a wrong offset!");
static_assert(offsetof(ALStatRoomPCCharacter, SimulateFirstStatDataList) == 0x000CB0, "Member 'ALStatRoomPCCharacter::SimulateFirstStatDataList' has a wrong offset!");
static_assert(offsetof(ALStatRoomPCCharacter, WillRaiseFirstStatCounts) == 0x000CC0, "Member 'ALStatRoomPCCharacter::WillRaiseFirstStatCounts' has a wrong offset!");

// Class ProjectP.LPropOverlapPawnComponent
// 0x0000 (0x0470 - 0x0470)
class ULPropOverlapPawnComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LPropOverlapPawnComponent">();
	}
	static class ULPropOverlapPawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULPropOverlapPawnComponent>();
	}
};
static_assert(alignof(ULPropOverlapPawnComponent) == 0x000010, "Wrong alignment on ULPropOverlapPawnComponent");
static_assert(sizeof(ULPropOverlapPawnComponent) == 0x000470, "Wrong size on ULPropOverlapPawnComponent");

// Class ProjectP.LTeleportObjectSpot
// 0x0040 (0x0390 - 0x0350)
class ALTeleportObjectSpot : public ALPropShapeObjectSpot
{
public:
	class FName                                   TeleportObjectCodeName;                            // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TorsionCoilActivate;                               // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELTeleportType                                TeleportType;                                      // 0x0359(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStargazerType                               StargazerType;                                     // 0x035A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35B[0x5];                                      // 0x035B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SpawnPointComponent;                               // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULPropOverlapPawnComponent*             StargazerUnstableVolume;                           // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cached_OverlapEnemyNpc;                            // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle_RefreshStargazerUnstable;              // 0x0378(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULSequenceActorData>     PortalSequenceActorData;                           // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetSpawnPointTransform();
	class FName GetTeleportObjectCodeName();
	bool IsPortal();
	void OnClosedWindow(class FName WidgetTableName);
	void OnCompleteTorsionCoilActiveAlert();
	void OnComponentBeginOverlapPropOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlapPropOverlapPawn(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnFinishedPortalSequenceActor();
	void OnInteractTorsionCoil();
	void RefreshStargazerUnstable();
	void SetTeleportObjectCodeName(class FName InCodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTeleportObjectSpot">();
	}
	static class ALTeleportObjectSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALTeleportObjectSpot>();
	}
};
static_assert(alignof(ALTeleportObjectSpot) == 0x000008, "Wrong alignment on ALTeleportObjectSpot");
static_assert(sizeof(ALTeleportObjectSpot) == 0x000390, "Wrong size on ALTeleportObjectSpot");
static_assert(offsetof(ALTeleportObjectSpot, TeleportObjectCodeName) == 0x000350, "Member 'ALTeleportObjectSpot::TeleportObjectCodeName' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, TorsionCoilActivate) == 0x000358, "Member 'ALTeleportObjectSpot::TorsionCoilActivate' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, TeleportType) == 0x000359, "Member 'ALTeleportObjectSpot::TeleportType' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, StargazerType) == 0x00035A, "Member 'ALTeleportObjectSpot::StargazerType' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, SpawnPointComponent) == 0x000360, "Member 'ALTeleportObjectSpot::SpawnPointComponent' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, StargazerUnstableVolume) == 0x000368, "Member 'ALTeleportObjectSpot::StargazerUnstableVolume' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, Cached_OverlapEnemyNpc) == 0x000370, "Member 'ALTeleportObjectSpot::Cached_OverlapEnemyNpc' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, TimerHandle_RefreshStargazerUnstable) == 0x000378, "Member 'ALTeleportObjectSpot::TimerHandle_RefreshStargazerUnstable' has a wrong offset!");
static_assert(offsetof(ALTeleportObjectSpot, PortalSequenceActorData) == 0x000380, "Member 'ALTeleportObjectSpot::PortalSequenceActorData' has a wrong offset!");

// Class ProjectP.LTestHelper
// 0x0000 (0x01E0 - 0x01E0)
class ALTestHelper : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTestHelper">();
	}
	static class ALTestHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALTestHelper>();
	}
};
static_assert(alignof(ALTestHelper) == 0x000008, "Wrong alignment on ALTestHelper");
static_assert(sizeof(ALTestHelper) == 0x0001E0, "Wrong size on ALTestHelper");

// Class ProjectP.LTextBlock
// 0x0000 (0x02B0 - 0x02B0)
class ULTextBlock final : public UTextBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTextBlock">();
	}
	static class ULTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTextBlock>();
	}
};
static_assert(alignof(ULTextBlock) == 0x000008, "Wrong alignment on ULTextBlock");
static_assert(sizeof(ULTextBlock) == 0x0002B0, "Wrong size on ULTextBlock");

// Class ProjectP.LTextLocalization
// 0x0018 (0x0040 - 0x0028)
class ULTextLocalization final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoadConetentInfoText;                             // 0x0038(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FText GetGameStr(const class FString& CodeName);
	static class FText GetGameStrWithName(class FName CodeName);
	static void InitLoadLocalization();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTextLocalization">();
	}
	static class ULTextLocalization* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTextLocalization>();
	}
};
static_assert(alignof(ULTextLocalization) == 0x000008, "Wrong alignment on ULTextLocalization");
static_assert(sizeof(ULTextLocalization) == 0x000040, "Wrong size on ULTextLocalization");
static_assert(offsetof(ULTextLocalization, bLoadConetentInfoText) == 0x000038, "Member 'ULTextLocalization::bLoadConetentInfoText' has a wrong offset!");

// Class ProjectP.LTransformReserveVolume
// 0x0008 (0x0240 - 0x0238)
class ALTransformReserveVolume final : public ALVolume
{
public:
	class ALLocationActor*                        ReserveLocation;                                   // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTransformReserveVolume">();
	}
	static class ALTransformReserveVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALTransformReserveVolume>();
	}
};
static_assert(alignof(ALTransformReserveVolume) == 0x000008, "Wrong alignment on ALTransformReserveVolume");
static_assert(sizeof(ALTransformReserveVolume) == 0x000240, "Wrong size on ALTransformReserveVolume");
static_assert(offsetof(ALTransformReserveVolume, ReserveLocation) == 0x000238, "Member 'ALTransformReserveVolume::ReserveLocation' has a wrong offset!");

// Class ProjectP.LTreeView
// 0x04D0 (0x0898 - 0x03C8)
class ULTreeView final : public UTreeView
{
public:
	struct FScrollBarStyle                        WidgetStyle;                                       // 0x03C8(0x04D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LTreeView">();
	}
	static class ULTreeView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULTreeView>();
	}
};
static_assert(alignof(ULTreeView) == 0x000008, "Wrong alignment on ULTreeView");
static_assert(sizeof(ULTreeView) == 0x000898, "Wrong size on ULTreeView");
static_assert(offsetof(ULTreeView, WidgetStyle) == 0x0003C8, "Member 'ULTreeView::WidgetStyle' has a wrong offset!");

// Class ProjectP.LUISystem
// 0x01E8 (0x0260 - 0x0078)
class ULUISystem final : public ULGameSubSystem
{
public:
	FMulticastInlineDelegateProperty_             OnInitMainUI;                                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostInitMainUI;                                  // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExecuteCommandUI;                                // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestOpenWindow;                               // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestCloseWindow;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestOpenPopup;                                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestClosePopup;                               // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClosedWindow;                                    // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpenPopupForceUse;                               // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRequestCloseAllWindow;                           // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSystemMessage;                                   // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveSystemMessage;                             // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAcquireHumanityRecord;                           // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLWidgetTable                          WidgetTable;                                       // 0x0158(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULWidget>                MainWidget;                                        // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULLoadingWidget>         AsyncLoadingWidget;                                // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWidgetVisibility;                                 // 0x01D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bQAMode;                                           // 0x01D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bQuestDebugMode;                                   // 0x01DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELLoadingScreenType                           LoadingScreenType;                                 // 0x01DB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlertBlock;                                       // 0x01DC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULLoadingScreenHandler*                 LoadingScreenHandler;                              // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x50];                                     // 0x01E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLBuffIconData>                 BuffIconOrder;                                     // 0x0238(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDetachAsyncLoadingUI;                            // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)

public:
	void AddSystemMessage(const class FText& Message);
	void CompleteLoadingGauge();
	void CompleteNotify_UI(const class FString& InUIName);
	void CreateMainWidget();
	bool GetAlertBlock();
	class ULLoadingScreenHandler* GetLoadingScreenHandler();
	bool IsNotified_UI(const class FString& InUIName);
	void OnFirstSelectActionTypeForcly();
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);
	void RemoveSystemMessage(const class FText& Message);
	void StartLoadingScreen(ELLoadingScreenType Type);
	void StopLoadingScreen();

	class ULWidget* GetMainWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LUISystem">();
	}
	static class ULUISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULUISystem>();
	}
};
static_assert(alignof(ULUISystem) == 0x000008, "Wrong alignment on ULUISystem");
static_assert(sizeof(ULUISystem) == 0x000260, "Wrong size on ULUISystem");
static_assert(offsetof(ULUISystem, OnInitMainUI) == 0x000078, "Member 'ULUISystem::OnInitMainUI' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnPostInitMainUI) == 0x000088, "Member 'ULUISystem::OnPostInitMainUI' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnExecuteCommandUI) == 0x000098, "Member 'ULUISystem::OnExecuteCommandUI' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnRequestOpenWindow) == 0x0000A8, "Member 'ULUISystem::OnRequestOpenWindow' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnRequestCloseWindow) == 0x0000B8, "Member 'ULUISystem::OnRequestCloseWindow' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnRequestOpenPopup) == 0x0000C8, "Member 'ULUISystem::OnRequestOpenPopup' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnRequestClosePopup) == 0x0000D8, "Member 'ULUISystem::OnRequestClosePopup' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnClosedWindow) == 0x0000E8, "Member 'ULUISystem::OnClosedWindow' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnOpenPopupForceUse) == 0x0000F8, "Member 'ULUISystem::OnOpenPopupForceUse' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnRequestCloseAllWindow) == 0x000108, "Member 'ULUISystem::OnRequestCloseAllWindow' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnSystemMessage) == 0x000118, "Member 'ULUISystem::OnSystemMessage' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnRemoveSystemMessage) == 0x000128, "Member 'ULUISystem::OnRemoveSystemMessage' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnAcquireHumanityRecord) == 0x000138, "Member 'ULUISystem::OnAcquireHumanityRecord' has a wrong offset!");
static_assert(offsetof(ULUISystem, WidgetTable) == 0x000158, "Member 'ULUISystem::WidgetTable' has a wrong offset!");
static_assert(offsetof(ULUISystem, MainWidget) == 0x0001C8, "Member 'ULUISystem::MainWidget' has a wrong offset!");
static_assert(offsetof(ULUISystem, AsyncLoadingWidget) == 0x0001D0, "Member 'ULUISystem::AsyncLoadingWidget' has a wrong offset!");
static_assert(offsetof(ULUISystem, bWidgetVisibility) == 0x0001D8, "Member 'ULUISystem::bWidgetVisibility' has a wrong offset!");
static_assert(offsetof(ULUISystem, bQAMode) == 0x0001D9, "Member 'ULUISystem::bQAMode' has a wrong offset!");
static_assert(offsetof(ULUISystem, bQuestDebugMode) == 0x0001DA, "Member 'ULUISystem::bQuestDebugMode' has a wrong offset!");
static_assert(offsetof(ULUISystem, LoadingScreenType) == 0x0001DB, "Member 'ULUISystem::LoadingScreenType' has a wrong offset!");
static_assert(offsetof(ULUISystem, bAlertBlock) == 0x0001DC, "Member 'ULUISystem::bAlertBlock' has a wrong offset!");
static_assert(offsetof(ULUISystem, LoadingScreenHandler) == 0x0001E0, "Member 'ULUISystem::LoadingScreenHandler' has a wrong offset!");
static_assert(offsetof(ULUISystem, BuffIconOrder) == 0x000238, "Member 'ULUISystem::BuffIconOrder' has a wrong offset!");
static_assert(offsetof(ULUISystem, OnDetachAsyncLoadingUI) == 0x000250, "Member 'ULUISystem::OnDetachAsyncLoadingUI' has a wrong offset!");

// Class ProjectP.LLoadingScreenHandler
// 0x0068 (0x0090 - 0x0028)
class ULLoadingScreenHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSuccess();
	float GetProgressRate(float DeltaTime, bool bCheckLevelLoadOnly);
	class FName GetSelectedLoadingScreenTableCodeName();
	void InvisibleLoading();
	void MoveLifeTime(float Time);
	void NextIndicatorIndex();
	void SelectLoadingScreenTable(class ULDataTableSystem* DataTableSystem, class ULQuestSystem* QuestSystem);
	void SetIndicatorIndex(int32 Index_0);
	void StartLoadingSequence(const struct FLLoadingScreenContext& LoadingContext);
	void StopLoadingSequence(ELLoadingScreenUsage Usage);
	void VisibleLoading(bool bMainLoading);

	int32 GetIndicatorIndex() const;
	float GetLifeTime() const;
	TSoftObjectPtr<class UTexture2D> GetSelectedImage() const;
	const TArray<class FName> GetSelectedTipGameStringCodeNames() const;
	ELLoadingScreenUsage GetUsage() const;
	bool IsLoadingComplete() const;
	bool IsLoadingSequence() const;
	bool IsLoadingVisible() const;
	bool IsMovieEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLoadingScreenHandler">();
	}
	static class ULLoadingScreenHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLoadingScreenHandler>();
	}
};
static_assert(alignof(ULLoadingScreenHandler) == 0x000008, "Wrong alignment on ULLoadingScreenHandler");
static_assert(sizeof(ULLoadingScreenHandler) == 0x000090, "Wrong size on ULLoadingScreenHandler");

// Class ProjectP.LWaterVolume
// 0x0000 (0x0238 - 0x0238)
class ALWaterVolume final : public ALVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWaterVolume">();
	}
	static class ALWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALWaterVolume>();
	}
};
static_assert(alignof(ALWaterVolume) == 0x000008, "Wrong alignment on ALWaterVolume");
static_assert(sizeof(ALWaterVolume) == 0x000238, "Wrong size on ALWaterVolume");

// Class ProjectP.LWeaponHandleComponent
// 0x0000 (0x0460 - 0x0460)
class ULWeaponHandleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponHandleComponent">();
	}
	static class ULWeaponHandleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWeaponHandleComponent>();
	}
};
static_assert(alignof(ULWeaponHandleComponent) == 0x000010, "Wrong alignment on ULWeaponHandleComponent");
static_assert(sizeof(ULWeaponHandleComponent) == 0x000460, "Wrong size on ULWeaponHandleComponent");

// Class ProjectP.LWeaponBrokenBladeComponent
// 0x0000 (0x0460 - 0x0460)
class ULWeaponBrokenBladeComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponBrokenBladeComponent">();
	}
	static class ULWeaponBrokenBladeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWeaponBrokenBladeComponent>();
	}
};
static_assert(alignof(ULWeaponBrokenBladeComponent) == 0x000010, "Wrong alignment on ULWeaponBrokenBladeComponent");
static_assert(sizeof(ULWeaponBrokenBladeComponent) == 0x000460, "Wrong size on ULWeaponBrokenBladeComponent");

// Class ProjectP.LWeaponDerbisBlade
// 0x0010 (0x01F0 - 0x01E0)
class ALWeaponDerbisBlade : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x01E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x01E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UMeshComponent* GetActiveMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeaponDerbisBlade">();
	}
	static class ALWeaponDerbisBlade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALWeaponDerbisBlade>();
	}
};
static_assert(alignof(ALWeaponDerbisBlade) == 0x000008, "Wrong alignment on ALWeaponDerbisBlade");
static_assert(sizeof(ALWeaponDerbisBlade) == 0x0001F0, "Wrong size on ALWeaponDerbisBlade");
static_assert(offsetof(ALWeaponDerbisBlade, StaticMeshComponent) == 0x0001E0, "Member 'ALWeaponDerbisBlade::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ALWeaponDerbisBlade, SkeletalMeshComponent) == 0x0001E8, "Member 'ALWeaponDerbisBlade::SkeletalMeshComponent' has a wrong offset!");

// Class ProjectP.LWeapon
// 0x01A8 (0x0388 - 0x01E0)
class ALWeapon : public AActor
{
public:
	uint8                                         Pad_1E0[0x70];                                     // 0x01E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 HandleMeshComponent;                               // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 BladeMeshComponent;                                // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 BrokenBladeMeshComponent;                          // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DebrisBladeMeshComponent;                          // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALWeaponDerbisBlade*                    DebrisMeshActor;                                   // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLBladeTrailType                       BladeTrailType;                                    // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ALWeaponDerbisBlade>        DefaultWeaponDerbisBladeClass;                     // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysUpdateOnWeaponOff;                           // 0x0288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          DebrisSkeletalMesh;                                // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULWeaponHandleComponent*                HandleCollisionComponent;                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULWeaponBladeComponent*                 BladeCollisionComponent;                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULWeaponBrokenBladeComponent*           BrokenBladeCollisionComponent;                     // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULHitColMgrComponent*                   HitColMgrComponent;                                // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0xD];                                      // 0x02C8(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_2D5_0 : 1;                                  // 0x02D5(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bDropWeapon : 1;                                   // 0x02D5(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBrokenBlade : 1;                                  // 0x02D5(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReplaceBreakWeapon : 1;                           // 0x02D5(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBrokenImmediatelyHide : 1;                        // 0x02D5(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreClearAnimState_Handle : 1;                  // 0x02D5(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreClearAnimState_Blade : 1;                   // 0x02D5(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCombinedWeapon : 1;                               // 0x02D5(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2D6[0x32];                                     // 0x02D6(0x0032)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DestructionDurability;                             // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDropPrimitive>                DropPrimitives;                                    // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLComponentDrop>                DropComponents;                                    // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class ULWeaponItem*                           Item;                                              // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemWeaponMonsterPtr                  WeaponMonsterInfo;                                 // 0x0338(0x0008)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BladeLength;                                       // 0x0340(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALWeapon>                   HandleWeaponClass;                                 // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALWeapon>                   BladeWeaponClass;                                  // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0358(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastAppliedElementName;                            // 0x035C(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x14];                                     // 0x0364(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BladeFableArtsSkillCodeName;                       // 0x0378(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HandleFableArtsSkillCodeName;                      // 0x0380(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyElement(class FName ElementName);
	void ApplyFxParameter_BladeLength(struct FLAttachedEffectSet* EffectSet);
	void ApplyMaterialVarying(class FName MaterialFxCodename);
	void BreakBlade(const struct FVector& ImpulseDirection);
	void BrokenBlade();
	void BrokenBladeOnBuild();
	void BuildEachCollision_AutoLocation(class UCapsuleComponent* CollisionComp, const struct FVector& CapsuleOffset);
	void BuildEachCollision_AutoSize(class UCapsuleComponent* CollisionComp, class USkeletalMeshComponent* MeshComp, float CapsuleRadius, float CapsuleHalfHeight);
	void BuildWeapon();
	void ChangeAnimState(ELWeaponPartType PartType, class FName AnimState);
	void ChangeAnimStateInner(ELWeaponPartType PartType, class FName InAnimState);
	void ClearAnimState(ELWeaponPartType PartType);
	void CreateDebrisMeshAndDrop();
	class ALWeapon* CreateHandleTemplate();
	void CreateSweepTracer();
	void DecreaseDestructionDurability(int32 Durability, bool bVictimGuard, bool* bConsumed, bool* bDestructed);
	void DoDropBrokenBlade();
	void DoDropBrokenBladeMeshes();
	void DoDropWeaponMeshes();
	void DropWeapon();
	class ULWeaponBladeComponent* GetBladeCollision();
	struct FItemCommonInfoPtr GetBladeCommonInfo();
	bool GetBrokenBladeOnBuild();
	float GetHandleCapsuleRadius();
	class ULWeaponHandleComponent* GetHandleCollision();
	struct FItemCommonInfoPtr GetHandleCommonInfo();
	class ULWeaponItem* GetItem();
	struct FItemWeaponMonsterPtr GetMonsterWeaponInfo();
	void GetSkillDist(int32* AddSkillDist, int32* SkillDistMin, int32* SkillDistMax, float* SkillDistRateMin, float* SkillDistRateMax);
	class FName GetSkillHitCodeName();
	void JoinHandleAndBlade(bool bBrokenBladeBuild);
	void JoinHandleAndBladeMeshComponents();
	void OnApplyRunningAbnormal(bool IsApply, class FName AbnormalCodeName);
	void OnBreakBlade(const struct FVector& BreakPointLocation, const struct FVector& ImpulseDirection);
	void OnDropWeapon();
	void OnDuplicateHandle(class ALWeapon* DuplicatedHandle);
	void OnFxSocketTraceEvent(class ULActMgrComponent* ActMgrComponent, const struct FLFxSocketTracerInfo& SocketTraceInfo);
	void OnJoinHandleAndBlade();
	void OnUpdateBreakBlade();
	void OnWeaponChanged(class ALWeapon* From, class ALWeapon* To);
	void OnWeaponHitDamage();
	void OnWeaponOnOff(bool bOnOff);
	void OnWeaponOwnerDead();
	void OnWeaponRespawn();
	void PlayDurabilityConsumeFX();
	void PlayTrailElementFX();
	void ProcessDestructionDurability(int32 ConsumeAmount, const struct FVector& ImpulseDirection, bool* bSuccessConsume, bool* bDestructNow);
	void RemoveDebrisMesh();
	void RemoveElement(class FName ElementName);
	void RemoveMaterialVarying(class FName MaterialFxCodename);
	void ReplaceBreakBlade(const struct FVector& ImpulseDirection);
	void RespawnWeapon();
	void SetAnimRateScale(ELWeaponPartType PartType, float ScaleRate);
	void SetMonsterWeapon(const class FName& ItemMonsterWeaponCodeName);
	void SetWeaponAttachmentInfo(ELWeaponAttachPointType InWeaponAttachPointType);
	void SetWeaponClass(TSubclassOf<class ALWeapon> InHandleWeaponClass, TSubclassOf<class ALWeapon> InBladeWeaponClass);
	void SetWeaponItem(class ULWeaponItem* Item_0);
	void StartHideDerbisBlade();
	void StopTrailElementFX();
	void WeaponOff();
	void WeaponOffBareHand();
	void WeaponOffOwnerHidden();
	void WeaponOn();
	void WeaponOnBareHand();
	void WeaponOnOwnerHidden();

	bool CanJoinHandleBlade() const;
	class FName GetAddtiveSkillHitCodeName() const;
	float GetAtkPowerRate() const;
	struct FVector GetAttachPointBlade() const;
	struct FSkillInfoPtr GetBladeFableArtsSkillInfo() const;
	struct FItemBladeInfoPtr GetBladeInfo() const;
	float GetBladeLength() const;
	int32 GetDestructionDurability() const;
	class FName GetEquipAbnormalCodeName() const;
	struct FSkillInfoPtr GetHandleFableArtsSkillInfo() const;
	struct FItemHandleInfoPtr GetHandleInfo() const;
	int32 GetMaxDestructionDurability() const;
	float GetMotionSpeedRate() const;
	float GetMulpleRateAtkPowerAfterBoken() const;
	float GetMulpleRateDestructionPowerAfterBroken() const;
	ELWeaponAttachPointType GetWeaponAttachPointType() const;
	class AActor* GetWeaponOwner() const;
	bool HasBroken() const;
	bool HasCollisionComponent(class UPrimitiveComponent* Component) const;
	bool IsDroped() const;
	bool IsMonsterWeapon() const;
	bool IsNewBreakBlade() const;
	bool IsPickedWeapon() const;
	bool IsRemoveAbnormalStateAfterBroken() const;
	bool IsWeaponOn() const;
	bool IsWeaponOnOwnerHidden() const;
	float ToughRecoveryDelayTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWeapon">();
	}
	static class ALWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALWeapon>();
	}
};
static_assert(alignof(ALWeapon) == 0x000008, "Wrong alignment on ALWeapon");
static_assert(sizeof(ALWeapon) == 0x000388, "Wrong size on ALWeapon");
static_assert(offsetof(ALWeapon, HandleMeshComponent) == 0x000250, "Member 'ALWeapon::HandleMeshComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, BladeMeshComponent) == 0x000258, "Member 'ALWeapon::BladeMeshComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, BrokenBladeMeshComponent) == 0x000260, "Member 'ALWeapon::BrokenBladeMeshComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, DebrisBladeMeshComponent) == 0x000268, "Member 'ALWeapon::DebrisBladeMeshComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, DebrisMeshActor) == 0x000270, "Member 'ALWeapon::DebrisMeshActor' has a wrong offset!");
static_assert(offsetof(ALWeapon, BladeTrailType) == 0x000278, "Member 'ALWeapon::BladeTrailType' has a wrong offset!");
static_assert(offsetof(ALWeapon, DefaultWeaponDerbisBladeClass) == 0x000280, "Member 'ALWeapon::DefaultWeaponDerbisBladeClass' has a wrong offset!");
static_assert(offsetof(ALWeapon, AlwaysUpdateOnWeaponOff) == 0x000288, "Member 'ALWeapon::AlwaysUpdateOnWeaponOff' has a wrong offset!");
static_assert(offsetof(ALWeapon, DebrisSkeletalMesh) == 0x000290, "Member 'ALWeapon::DebrisSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ALWeapon, HandleCollisionComponent) == 0x000298, "Member 'ALWeapon::HandleCollisionComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, BladeCollisionComponent) == 0x0002A0, "Member 'ALWeapon::BladeCollisionComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, BrokenBladeCollisionComponent) == 0x0002A8, "Member 'ALWeapon::BrokenBladeCollisionComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, HitColMgrComponent) == 0x0002C0, "Member 'ALWeapon::HitColMgrComponent' has a wrong offset!");
static_assert(offsetof(ALWeapon, DestructionDurability) == 0x000308, "Member 'ALWeapon::DestructionDurability' has a wrong offset!");
static_assert(offsetof(ALWeapon, DropPrimitives) == 0x000310, "Member 'ALWeapon::DropPrimitives' has a wrong offset!");
static_assert(offsetof(ALWeapon, DropComponents) == 0x000320, "Member 'ALWeapon::DropComponents' has a wrong offset!");
static_assert(offsetof(ALWeapon, Item) == 0x000330, "Member 'ALWeapon::Item' has a wrong offset!");
static_assert(offsetof(ALWeapon, WeaponMonsterInfo) == 0x000338, "Member 'ALWeapon::WeaponMonsterInfo' has a wrong offset!");
static_assert(offsetof(ALWeapon, BladeLength) == 0x000340, "Member 'ALWeapon::BladeLength' has a wrong offset!");
static_assert(offsetof(ALWeapon, HandleWeaponClass) == 0x000348, "Member 'ALWeapon::HandleWeaponClass' has a wrong offset!");
static_assert(offsetof(ALWeapon, BladeWeaponClass) == 0x000350, "Member 'ALWeapon::BladeWeaponClass' has a wrong offset!");
static_assert(offsetof(ALWeapon, WeaponAttachPointType) == 0x000358, "Member 'ALWeapon::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(ALWeapon, LastAppliedElementName) == 0x00035C, "Member 'ALWeapon::LastAppliedElementName' has a wrong offset!");
static_assert(offsetof(ALWeapon, BladeFableArtsSkillCodeName) == 0x000378, "Member 'ALWeapon::BladeFableArtsSkillCodeName' has a wrong offset!");
static_assert(offsetof(ALWeapon, HandleFableArtsSkillCodeName) == 0x000380, "Member 'ALWeapon::HandleFableArtsSkillCodeName' has a wrong offset!");

// Class ProjectP.LWetBodyAreaComponent
// 0x0000 (0x0470 - 0x0470)
class ULWetBodyAreaComponent : public UBoxComponent
{
public:
	float                                         Wet_Amount;                                        // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWetBodyAreaComponent">();
	}
	static class ULWetBodyAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWetBodyAreaComponent>();
	}
};
static_assert(alignof(ULWetBodyAreaComponent) == 0x000010, "Wrong alignment on ULWetBodyAreaComponent");
static_assert(sizeof(ULWetBodyAreaComponent) == 0x000470, "Wrong size on ULWetBodyAreaComponent");
static_assert(offsetof(ULWetBodyAreaComponent, Wet_Amount) == 0x000468, "Member 'ULWetBodyAreaComponent::Wet_Amount' has a wrong offset!");

// Class ProjectP.LWidget
// 0x0040 (0x02A8 - 0x0268)
class ULWidget : public UUserWidget
{
public:
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DefaultTexture;                                    // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnCompleteTween;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bOverlayLoading;                                   // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x17];                                     // 0x0291(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteSetBrush_FromAsyncTexture();
	void ListenForInputAxis(class FName AxisName, bool bConsume, TDelegate<void(float AxisValue)> Callback);
	void SetBrush_FromAsyncTexture(class UImage* InImage, TSoftObjectPtr<class UObject> InSoftObject);
	void StopListeningForInputAxis(class FName AxisName);
	void Tween_CanvasMove(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time);
	void Tween_CanvasSize(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time);
	void Tween_ColorAndOpacity(class UWidget* Widget, const struct FLinearColor& Start, const struct FLinearColor& End, const struct FTweenEase& Ease, float Time);
	void Tween_ContentFloatValue(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time);
	void Tween_ContentsColorAndOpacity(class UWidget* Widget, const struct FLinearColor& Start, const struct FLinearColor& End, const struct FTweenEase& Ease, float Time);
	void Tween_MaterialColor(class UWidget* Widget, class FName ParameterName, const struct FLinearColor& Start, const struct FLinearColor& End, const struct FTweenEase& Ease, float Time);
	void Tween_MaterialScalar(class UWidget* Widget, class FName ParameterName, float Start, float End, const struct FTweenEase& Ease, float Time);
	void Tween_Opacity(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time);
	void Tween_RenderAngle(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time);
	void Tween_RenderOpacity(class UWidget* Widget, float Start, float End, const struct FTweenEase& Ease, float Time);
	void Tween_RenderScale(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time);
	void Tween_RenderTransform(class UWidget* Widget, const struct FWidgetTransform& Start, const struct FWidgetTransform& End, const struct FTweenEase& Ease, float Time);
	void Tween_RenderTranslation(class UWidget* Widget, const struct FVector2D& Start, const struct FVector2D& End, const struct FTweenEase& Ease, float Time);
	void Tween_Reset(class FName Category_Name);
	void Tween_Start(class FName Category_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWidget">();
	}
	static class ULWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWidget>();
	}
};
static_assert(alignof(ULWidget) == 0x000008, "Wrong alignment on ULWidget");
static_assert(sizeof(ULWidget) == 0x0002A8, "Wrong size on ULWidget");
static_assert(offsetof(ULWidget, DefaultTexture) == 0x000278, "Member 'ULWidget::DefaultTexture' has a wrong offset!");
static_assert(offsetof(ULWidget, OnCompleteTween) == 0x000280, "Member 'ULWidget::OnCompleteTween' has a wrong offset!");
static_assert(offsetof(ULWidget, bOverlayLoading) == 0x000290, "Member 'ULWidget::bOverlayLoading' has a wrong offset!");

// Class ProjectP.LLoadingWidget
// 0x0008 (0x02B0 - 0x02A8)
class ULLoadingWidget : public ULWidget
{
public:
	bool                                          bMainLoading;                                      // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsyncWorldLoading;                                // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInLoadingLevel;                                   // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB[0x5];                                      // 0x02AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LLoadingWidget">();
	}
	static class ULLoadingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULLoadingWidget>();
	}
};
static_assert(alignof(ULLoadingWidget) == 0x000008, "Wrong alignment on ULLoadingWidget");
static_assert(sizeof(ULLoadingWidget) == 0x0002B0, "Wrong size on ULLoadingWidget");
static_assert(offsetof(ULLoadingWidget, bMainLoading) == 0x0002A8, "Member 'ULLoadingWidget::bMainLoading' has a wrong offset!");
static_assert(offsetof(ULLoadingWidget, bAsyncWorldLoading) == 0x0002A9, "Member 'ULLoadingWidget::bAsyncWorldLoading' has a wrong offset!");
static_assert(offsetof(ULLoadingWidget, bInLoadingLevel) == 0x0002AA, "Member 'ULLoadingWidget::bInLoadingLevel' has a wrong offset!");

// Class ProjectP.LHeadTagWidget
// 0x0010 (0x02B8 - 0x02A8)
class ULHeadTagWidget : public ULWidget
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HeadTagOwner;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnAttachToActor();
	void OnDetachFromActor();
	void RefreshHeadTagVisibleTimer(bool InVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LHeadTagWidget">();
	}
	static class ULHeadTagWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULHeadTagWidget>();
	}
};
static_assert(alignof(ULHeadTagWidget) == 0x000008, "Wrong alignment on ULHeadTagWidget");
static_assert(sizeof(ULHeadTagWidget) == 0x0002B8, "Wrong size on ULHeadTagWidget");
static_assert(offsetof(ULHeadTagWidget, HeadTagOwner) == 0x0002B0, "Member 'ULHeadTagWidget::HeadTagOwner' has a wrong offset!");

// Class ProjectP.LWindSourceComponent
// 0x0010 (0x0220 - 0x0210)
class ULWindSourceComponent final : public UWindDirectionalSourceComponent
{
public:
	struct FVector                                VolumeSize;                                        // 0x0208(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0xC];                                      // 0x0214(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWindSourceComponent">();
	}
	static class ULWindSourceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWindSourceComponent>();
	}
};
static_assert(alignof(ULWindSourceComponent) == 0x000010, "Wrong alignment on ULWindSourceComponent");
static_assert(sizeof(ULWindSourceComponent) == 0x000220, "Wrong size on ULWindSourceComponent");
static_assert(offsetof(ULWindSourceComponent, VolumeSize) == 0x000208, "Member 'ULWindSourceComponent::VolumeSize' has a wrong offset!");

// Class ProjectP.LWindSourceVolume
// 0x0020 (0x0258 - 0x0238)
class ALWindSourceVolume final : public ALVolume
{
public:
	int32                                         Priority;                                          // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGustAmount;                                     // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGustAmount;                                     // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPointWind;                                        // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULWindSourceComponent*                  WindComponent;                                     // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWindSourceVolume">();
	}
	static class ALWindSourceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALWindSourceVolume>();
	}
};
static_assert(alignof(ALWindSourceVolume) == 0x000008, "Wrong alignment on ALWindSourceVolume");
static_assert(sizeof(ALWindSourceVolume) == 0x000258, "Wrong size on ALWindSourceVolume");
static_assert(offsetof(ALWindSourceVolume, Priority) == 0x000238, "Member 'ALWindSourceVolume::Priority' has a wrong offset!");
static_assert(offsetof(ALWindSourceVolume, Speed) == 0x00023C, "Member 'ALWindSourceVolume::Speed' has a wrong offset!");
static_assert(offsetof(ALWindSourceVolume, MinGustAmount) == 0x000240, "Member 'ALWindSourceVolume::MinGustAmount' has a wrong offset!");
static_assert(offsetof(ALWindSourceVolume, MaxGustAmount) == 0x000244, "Member 'ALWindSourceVolume::MaxGustAmount' has a wrong offset!");
static_assert(offsetof(ALWindSourceVolume, bPointWind) == 0x000248, "Member 'ALWindSourceVolume::bPointWind' has a wrong offset!");
static_assert(offsetof(ALWindSourceVolume, WindComponent) == 0x000250, "Member 'ALWindSourceVolume::WindComponent' has a wrong offset!");

// Class ProjectP.LWireActor
// 0x0048 (0x0228 - 0x01E0)
class ALWireActor : public AActor
{
public:
	class FName                                   SpawnSocketName;                                   // 0x01E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time_Pulling;                                      // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time_Fire;                                         // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time_Rewind;                                       // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelay_Before_Pulling_Animation;                // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelay_Before_Target_Pulling;                   // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelay_Before_Following;                        // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_Pitch;                                         // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_Pitch;                                         // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_Yaw;                                           // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_Yaw;                                           // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName_Attach;                           // 0x0214(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName_Pulling;                          // 0x021C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWireActor">();
	}
	static class ALWireActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALWireActor>();
	}
};
static_assert(alignof(ALWireActor) == 0x000008, "Wrong alignment on ALWireActor");
static_assert(sizeof(ALWireActor) == 0x000228, "Wrong size on ALWireActor");
static_assert(offsetof(ALWireActor, SpawnSocketName) == 0x0001E0, "Member 'ALWireActor::SpawnSocketName' has a wrong offset!");
static_assert(offsetof(ALWireActor, MaxDistance) == 0x0001E8, "Member 'ALWireActor::MaxDistance' has a wrong offset!");
static_assert(offsetof(ALWireActor, Time_Pulling) == 0x0001EC, "Member 'ALWireActor::Time_Pulling' has a wrong offset!");
static_assert(offsetof(ALWireActor, Time_Fire) == 0x0001F0, "Member 'ALWireActor::Time_Fire' has a wrong offset!");
static_assert(offsetof(ALWireActor, Time_Rewind) == 0x0001F4, "Member 'ALWireActor::Time_Rewind' has a wrong offset!");
static_assert(offsetof(ALWireActor, TimeDelay_Before_Pulling_Animation) == 0x0001F8, "Member 'ALWireActor::TimeDelay_Before_Pulling_Animation' has a wrong offset!");
static_assert(offsetof(ALWireActor, TimeDelay_Before_Target_Pulling) == 0x0001FC, "Member 'ALWireActor::TimeDelay_Before_Target_Pulling' has a wrong offset!");
static_assert(offsetof(ALWireActor, TimeDelay_Before_Following) == 0x000200, "Member 'ALWireActor::TimeDelay_Before_Following' has a wrong offset!");
static_assert(offsetof(ALWireActor, Min_Pitch) == 0x000204, "Member 'ALWireActor::Min_Pitch' has a wrong offset!");
static_assert(offsetof(ALWireActor, Max_Pitch) == 0x000208, "Member 'ALWireActor::Max_Pitch' has a wrong offset!");
static_assert(offsetof(ALWireActor, Min_Yaw) == 0x00020C, "Member 'ALWireActor::Min_Yaw' has a wrong offset!");
static_assert(offsetof(ALWireActor, Max_Yaw) == 0x000210, "Member 'ALWireActor::Max_Yaw' has a wrong offset!");
static_assert(offsetof(ALWireActor, SkillHitCodeName_Attach) == 0x000214, "Member 'ALWireActor::SkillHitCodeName_Attach' has a wrong offset!");
static_assert(offsetof(ALWireActor, SkillHitCodeName_Pulling) == 0x00021C, "Member 'ALWireActor::SkillHitCodeName_Pulling' has a wrong offset!");

// Class ProjectP.LWorldEventComponent
// 0x00D0 (0x0180 - 0x00B0)
class ULWorldEventComponent final : public UActorComponent
{
public:
	class FName                                   DefaultCodeName;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FWorldEventInfoList> WorldEventMap;                                     // 0x00B8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FWorldEventInfo>     DialogMonsterEventMap;                             // 0x0108(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<ELCallBackEventType>                   CallBackEventTypeList;                             // 0x0158(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bNeedCheckCombatTime;                              // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLCallBackEventData>            ReserveEventList;                                  // 0x0170(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnClosedLevelUpWindow(class FName WidgetTableName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldEventComponent">();
	}
	static class ULWorldEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWorldEventComponent>();
	}
};
static_assert(alignof(ULWorldEventComponent) == 0x000008, "Wrong alignment on ULWorldEventComponent");
static_assert(sizeof(ULWorldEventComponent) == 0x000180, "Wrong size on ULWorldEventComponent");
static_assert(offsetof(ULWorldEventComponent, DefaultCodeName) == 0x0000B0, "Member 'ULWorldEventComponent::DefaultCodeName' has a wrong offset!");
static_assert(offsetof(ULWorldEventComponent, WorldEventMap) == 0x0000B8, "Member 'ULWorldEventComponent::WorldEventMap' has a wrong offset!");
static_assert(offsetof(ULWorldEventComponent, DialogMonsterEventMap) == 0x000108, "Member 'ULWorldEventComponent::DialogMonsterEventMap' has a wrong offset!");
static_assert(offsetof(ULWorldEventComponent, CallBackEventTypeList) == 0x000158, "Member 'ULWorldEventComponent::CallBackEventTypeList' has a wrong offset!");
static_assert(offsetof(ULWorldEventComponent, bNeedCheckCombatTime) == 0x000168, "Member 'ULWorldEventComponent::bNeedCheckCombatTime' has a wrong offset!");
static_assert(offsetof(ULWorldEventComponent, ReserveEventList) == 0x000170, "Member 'ULWorldEventComponent::ReserveEventList' has a wrong offset!");

// Class ProjectP.LWorldEventSystem
// 0x0200 (0x0278 - 0x0078)
class ULWorldEventSystem final : public ULGameSubSystem
{
public:
	bool                                          UseWorldEventComponent;                            // 0x0078(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ALNPCSpot>>       DespawnNpcSpotList;                                // 0x0080(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ALNPCSpot>>       DeadNpcSpotList;                                   // 0x0090(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<class FName, struct FEventDetailInfoList> WorldEventDB;                                      // 0x00A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0xB0];                                      // 0x00F0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FContentConditionInfoList> ContentConditionDB;                                // 0x01A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FContentCommandInfoList> ContentCommandDB;                                  // 0x01F0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHolding_ContentCommand;                           // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnCommandUIFadeOutEnd;                             // 0x0254(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Cache_GamePause;                                   // 0x0264(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMonsterMonologueCooltimeInfo>  MonsterMonologueCooltimeInfo;                      // 0x0268(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void CommandUIFadeOutEnd();
	bool ExecuteContentCommand(const class FName& CommandName);
	bool IsValidEventConditionBP(const class FName& CommandName);
	void OnClosedWindow(class FName WidgetTableName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldEventSystem">();
	}
	static class ULWorldEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWorldEventSystem>();
	}
};
static_assert(alignof(ULWorldEventSystem) == 0x000008, "Wrong alignment on ULWorldEventSystem");
static_assert(sizeof(ULWorldEventSystem) == 0x000278, "Wrong size on ULWorldEventSystem");
static_assert(offsetof(ULWorldEventSystem, UseWorldEventComponent) == 0x000078, "Member 'ULWorldEventSystem::UseWorldEventComponent' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, DespawnNpcSpotList) == 0x000080, "Member 'ULWorldEventSystem::DespawnNpcSpotList' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, DeadNpcSpotList) == 0x000090, "Member 'ULWorldEventSystem::DeadNpcSpotList' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, WorldEventDB) == 0x0000A0, "Member 'ULWorldEventSystem::WorldEventDB' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, ContentConditionDB) == 0x0001A0, "Member 'ULWorldEventSystem::ContentConditionDB' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, ContentCommandDB) == 0x0001F0, "Member 'ULWorldEventSystem::ContentCommandDB' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, bHolding_ContentCommand) == 0x000250, "Member 'ULWorldEventSystem::bHolding_ContentCommand' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, OnCommandUIFadeOutEnd) == 0x000254, "Member 'ULWorldEventSystem::OnCommandUIFadeOutEnd' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, Cache_GamePause) == 0x000264, "Member 'ULWorldEventSystem::Cache_GamePause' has a wrong offset!");
static_assert(offsetof(ULWorldEventSystem, MonsterMonologueCooltimeInfo) == 0x000268, "Member 'ULWorldEventSystem::MonsterMonologueCooltimeInfo' has a wrong offset!");

// Class ProjectP.LWorldLoadSystem
// 0x0010 (0x0088 - 0x0078)
class ULWorldLoadSystem final : public ULGameSubSystem
{
public:
	class ULWorldLoadManager*                     WorldLoadManager;                                  // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULWorldLoadScreenInfo*                  WorldLoadScreenInfo;                               // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AsyncLoadAfterOpenWorld(bool bCreateForPIE);
	void AsyncWaitLevel(class FName TeleportCodeName);
	float GetAsyncLoadPercentage();
	class ULWorldLoadScreenInfo* GetWorldLoadScreenInfo();
	void MakeLoadAlwaysLoadLevelStreaming(class UWorld* World);
	void OnGameDataCharacterSync(class ULCharacterSaveGame* CharacterSaveGame, bool bLoad);

	bool CanSpawnActors() const;
	void GetLoadingStats(TArray<class FString>* Stats) const;
	bool IsAsyncWorldLoading() const;
	bool IsAsyncWorldLoadMode() const;
	bool IsAsyncWorldLoadModeInCurrentWorld(class UWorld* World) const;
	bool IsStartAsyncLoadMap(class FName LevelName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldLoadSystem">();
	}
	static class ULWorldLoadSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWorldLoadSystem>();
	}
};
static_assert(alignof(ULWorldLoadSystem) == 0x000008, "Wrong alignment on ULWorldLoadSystem");
static_assert(sizeof(ULWorldLoadSystem) == 0x000088, "Wrong size on ULWorldLoadSystem");
static_assert(offsetof(ULWorldLoadSystem, WorldLoadManager) == 0x000078, "Member 'ULWorldLoadSystem::WorldLoadManager' has a wrong offset!");
static_assert(offsetof(ULWorldLoadSystem, WorldLoadScreenInfo) == 0x000080, "Member 'ULWorldLoadSystem::WorldLoadScreenInfo' has a wrong offset!");

// Class ProjectP.LWorldLoadManager
// 0x0090 (0x00B8 - 0x0028)
class ULWorldLoadManager final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        KeepWorldObjectsInTask;                            // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        KeepLoadingObjectsInTask;                          // 0x0088(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ULWorldLoadSystem*                      OwnerSystem;                                       // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x4];                                       // 0x00A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxScreenCompleteTime;                             // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWorldDelayTime;                                 // 0x00A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWaitLevelTime;                                  // 0x00AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPostScreenTime;                                 // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddKeepLoadingObjectsInTask(const TArray<class UObject*>& Objects);
	void AddKeepWorldObjectsInTask(const TArray<class UObject*>& Objects);
	void AsyncLoadAfterOpenWorld();
	void AsyncWaitLevel(class FName TeleportCodeName);
	void EmptyKeepLoadingObjectsInTask();
	void EmptyKeepWorldObjectsInTask();
	float GetLoadPercentage();
	void MakeLoadAlwaysLoadLevelStreaming(class UWorld* World);
	void TickAsyncWorldLoading(float DeltaTime);

	void GetLoadingStats(TArray<class FString>* Stats) const;
	bool IsAsyncWorldLoading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldLoadManager">();
	}
	static class ULWorldLoadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWorldLoadManager>();
	}
};
static_assert(alignof(ULWorldLoadManager) == 0x000008, "Wrong alignment on ULWorldLoadManager");
static_assert(sizeof(ULWorldLoadManager) == 0x0000B8, "Wrong size on ULWorldLoadManager");
static_assert(offsetof(ULWorldLoadManager, KeepWorldObjectsInTask) == 0x000078, "Member 'ULWorldLoadManager::KeepWorldObjectsInTask' has a wrong offset!");
static_assert(offsetof(ULWorldLoadManager, KeepLoadingObjectsInTask) == 0x000088, "Member 'ULWorldLoadManager::KeepLoadingObjectsInTask' has a wrong offset!");
static_assert(offsetof(ULWorldLoadManager, OwnerSystem) == 0x000098, "Member 'ULWorldLoadManager::OwnerSystem' has a wrong offset!");
static_assert(offsetof(ULWorldLoadManager, MaxScreenCompleteTime) == 0x0000A4, "Member 'ULWorldLoadManager::MaxScreenCompleteTime' has a wrong offset!");
static_assert(offsetof(ULWorldLoadManager, MaxWorldDelayTime) == 0x0000A8, "Member 'ULWorldLoadManager::MaxWorldDelayTime' has a wrong offset!");
static_assert(offsetof(ULWorldLoadManager, MaxWaitLevelTime) == 0x0000AC, "Member 'ULWorldLoadManager::MaxWaitLevelTime' has a wrong offset!");
static_assert(offsetof(ULWorldLoadManager, MaxPostScreenTime) == 0x0000B0, "Member 'ULWorldLoadManager::MaxPostScreenTime' has a wrong offset!");

// Class ProjectP.LWorldSystemData
// 0x0000 (0x01E0 - 0x01E0)
class ALWorldSystemData : public AActor
{
public:
	void ChangeLightScenario(class FName UnLoadLevel, class FName LoadLevel);
	void OnMoveToTeleportSpotSameLevelLoadingFinished();
	void ProcessMoveToTeleportSpotSameLevel(class FName TeleportCodeName, bool bInGameLoadingScreen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldSystemData">();
	}
	static class ALWorldSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALWorldSystemData>();
	}
};
static_assert(alignof(ALWorldSystemData) == 0x000008, "Wrong alignment on ALWorldSystemData");
static_assert(sizeof(ALWorldSystemData) == 0x0001E0, "Wrong size on ALWorldSystemData");

// Class ProjectP.LWorldSystem
// 0x0088 (0x0100 - 0x0078)
class ULWorldSystem final : public ULGameSubSystem
{
public:
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShowLocationMsgDelayTime;                          // 0x0098(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELAppearanceType                              Cached_AppearanceType;                             // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLWorldMapInfo>                 WorldMapInfoList;                                  // 0x00A0(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         ReservedLevelDelayTime;                            // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShowLocationCodeName;                              // 0x00B4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HotelMapList;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	bool                                          bIncludeHotelMap;                                  // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentLevelName;                                  // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ALGlobalEnvActor>        GlobalEnvActor;                                    // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALWorldSystemData*                      SystemData;                                        // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShowControlGuide;                               // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndingCreditVelocityMultiply;                      // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndingCreditVelocityMultiply;                  // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyWeather(class FName InWeatherCodeName, float CustomChangeTime);
	void ChangeWeather(class FName InWeatherCodeName, float CustomChangeTime, float DelayTime);
	void FinishLoadingScreenSameLevel();
	float GetEndingCreditVelocityMultiply();
	class ALGlobalEnvActor* GetGlobalEnvActor();
	bool GetIsShowControlGuide();
	float GetWorldLoadingProgress(float DeltaTime, bool bCheckLevelLoadOnly);
	void GotoReservedLevel();
	bool IsShowControlGuide();
	bool IsUseEndingCreditVelocityMultiply();
	void MuteOffOnLoadingScreenOff();
	void NewOpenWorld_Inner(const class FName& LevelName, bool bMainLoading);
	void NewOpenWorld_Outer(const class FName& LevelName, bool bShowLoadingScreen, bool bPlayStart);
	void OnGlobalVariableChange(class FName InGlobalVariable, int32 InValue);
	void OnLoadedStatRoom();
	void OnLoadingScreenFinished();
	void OpenWorldFromMapType(ELWorldMapType TargetMapType, bool bShowLoadingScreen);
	void ProcessMoveToTeleportSpotSameLevel(class FName TeleportCodeName, bool bInGameLoadingScreen);
	void ProcessStartOnLoadingScreenFinished();
	void SetEndingCreditVelocityMultiply(float InVelocityMultiply);
	void SetGlobalDither(bool InFlag);
	void SetGlobalEnvActor(class ALGlobalEnvActor* InActor);
	void SetIsShowControlGuide(bool InIsShowControlGuide);
	void ShowLocationMsg();
	void TeleportToObject(class FName TeleportCodeName, bool bInGameLoadingScreen, bool bReservedLevel, bool bStartWithLoadingLevel);

	class FName GetAppliedWeatherCodeName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LWorldSystem">();
	}
	static class ULWorldSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULWorldSystem>();
	}
};
static_assert(alignof(ULWorldSystem) == 0x000008, "Wrong alignment on ULWorldSystem");
static_assert(sizeof(ULWorldSystem) == 0x000100, "Wrong size on ULWorldSystem");
static_assert(offsetof(ULWorldSystem, ShowLocationMsgDelayTime) == 0x000098, "Member 'ULWorldSystem::ShowLocationMsgDelayTime' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, Cached_AppearanceType) == 0x00009C, "Member 'ULWorldSystem::Cached_AppearanceType' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, WorldMapInfoList) == 0x0000A0, "Member 'ULWorldSystem::WorldMapInfoList' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, ReservedLevelDelayTime) == 0x0000B0, "Member 'ULWorldSystem::ReservedLevelDelayTime' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, ShowLocationCodeName) == 0x0000B4, "Member 'ULWorldSystem::ShowLocationCodeName' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, HotelMapList) == 0x0000C0, "Member 'ULWorldSystem::HotelMapList' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, bIncludeHotelMap) == 0x0000D0, "Member 'ULWorldSystem::bIncludeHotelMap' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, CurrentLevelName) == 0x0000D4, "Member 'ULWorldSystem::CurrentLevelName' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, GlobalEnvActor) == 0x0000E0, "Member 'ULWorldSystem::GlobalEnvActor' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, SystemData) == 0x0000E8, "Member 'ULWorldSystem::SystemData' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, bIsShowControlGuide) == 0x0000F0, "Member 'ULWorldSystem::bIsShowControlGuide' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, EndingCreditVelocityMultiply) == 0x0000F4, "Member 'ULWorldSystem::EndingCreditVelocityMultiply' has a wrong offset!");
static_assert(offsetof(ULWorldSystem, bUseEndingCreditVelocityMultiply) == 0x0000F8, "Member 'ULWorldSystem::bUseEndingCreditVelocityMultiply' has a wrong offset!");

}

